#![allow(non_snake_case)]


#[macro_use]
extern crate alloc;
extern crate azul_core;

#[cfg(target_arch = "wasm32")]
extern crate azul_web as azul_impl;
#[cfg(not(target_arch = "wasm32"))]
extern crate azul_desktop as azul_impl;

use core::ffi::c_void;
use core::mem;
use pyo3::prelude::*;
use pyo3::PyObjectProtocol;
use pyo3::types::*;
use pyo3::exceptions::PyException;
type GLuint = u32; type AzGLuint = GLuint;
type GLint = i32; type AzGLint = GLint;
type GLint64 = i64; type AzGLint64 = GLint64;
type GLuint64 = u64; type AzGLuint64 = GLuint64;
type GLenum = u32; type AzGLenum = GLenum;
type GLintptr = isize; type AzGLintptr = GLintptr;
type GLboolean = u8; type AzGLboolean = GLboolean;
type GLsizeiptr = isize; type AzGLsizeiptr = GLsizeiptr;
type GLvoid = c_void; type AzGLvoid = GLvoid;
type GLbitfield = u32; type AzGLbitfield = GLbitfield;
type GLsizei = i32; type AzGLsizei = GLsizei;
type GLclampf = f32; type AzGLclampf = GLclampf;
type GLfloat = f32; type AzGLfloat = GLfloat;
type AzF32 = f32;
type AzU16 = u16;
type AzU32 = u32;
type AzScanCode = u32;



use pyo3::{PyVisit, PyTraverseError, PyGCProtocol};

fn pystring_to_azstring(input: &String) -> AzString {
    input.clone().into()
}
fn az_string_to_py_string(input: AzString) -> String {
    input.into()
}
fn pystring_to_refstr(input: &str) -> AzRefstr {
    AzRefstr {
        ptr: input.as_ptr(),
        len: input.len(),
    }
}
fn az_vecu8_to_py_vecu8(input: AzU8Vec) -> Vec<u8> {
    let input: azul_impl::css::U8Vec = unsafe { mem::transmute(input) };
    input.into_library_owned_vec()
}
fn vec_string_to_vec_refstr(input: &Vec<&str>) -> Vec<AzRefstr> {
    input.iter().map(|i| pystring_to_refstr(i)).collect()
}
fn pybytesrefmut_to_vecu8refmut(input: &mut Vec<u8>) -> AzU8VecRefMut {
    AzU8VecRefMut { ptr: input.as_mut_ptr(), len: input.len() }
}
fn pybytesref_to_vecu8_ref(input: &Vec<u8>) -> AzU8VecRef {
    AzU8VecRef { ptr: input.as_ptr(), len: input.len() }
}
fn pylist_f32_to_rust(input: &Vec<f32>) -> AzF32VecRef {
    AzF32VecRef { ptr: input.as_ptr(), len: input.len() }
}
fn pylist_u32_to_rust(input: &Vec<u32>) -> AzGLuintVecRef {
    AzGLuintVecRef { ptr: input.as_ptr(), len: input.len() }
}
fn pylist_i32_to_rust(input: &mut Vec<i32>) -> AzGLintVecRefMut {
    AzGLintVecRefMut { ptr: input.as_mut_ptr(), len: input.len() }
}
fn pylist_i64_to_rust(input: &mut Vec<i64>) -> AzGLint64VecRefMut {
    AzGLint64VecRefMut { ptr: input.as_mut_ptr(), len: input.len() }
}
fn pylist_bool_to_rust(input: &mut Vec<u8>) -> AzGLbooleanVecRefMut {
    AzGLbooleanVecRefMut { ptr: input.as_mut_ptr(), len: input.len() }
}
fn pylist_glfoat_to_rust(input: &mut Vec<f32>) -> AzGLfloatVecRefMut {
    AzGLfloatVecRefMut { ptr: input.as_mut_ptr(), len: input.len() }
}
fn pylist_str_to_rust(input: &Vec<AzRefstr>) -> AzRefstrVecRef {
    AzRefstrVecRef { ptr: input.as_ptr(), len: input.len() }
}
fn pylist_tessellated_svg_node(input: &Vec<AzTessellatedSvgNode>) -> AzTessellatedSvgNodeVecRef {
    AzTessellatedSvgNodeVecRef { ptr: input.as_ptr(), len: input.len() }
}

impl From<String> for AzString {
    fn from(s: String) -> AzString {
        Self { vec: s.into_bytes().into() }
    }
}

impl From<AzString> for String {
    fn from(s: AzString) -> String {
        let s: azul_impl::css::AzString = unsafe { mem::transmute(s) };
        s.into_library_owned_string()
    }
}

// AzU8Vec
impl From<AzU8Vec> for Vec<u8> {
    fn from(input: AzU8Vec) -> Vec<u8> {
        let input: azul_impl::css::U8Vec = unsafe { mem::transmute(input) };
        input.into_library_owned_vec()
    }
}

impl From<Vec<u8>> for AzU8Vec {
    fn from(input: Vec<u8>) -> AzU8Vec {

        let ptr = input.as_ptr();
        let len = input.len();
        let cap = input.capacity();

        let _ = ::core::mem::ManuallyDrop::new(input);

        Self {
            ptr,
            len,
            cap,
            destructor: AzU8VecDestructorEnumWrapper::DefaultRust(),
        }

    }
}

// manually implement App::new, WindowState::new,
// WindowCreateOptions::new and LayoutCallback::new

#[pyproto]
impl PyGCProtocol for AzApp {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::app::AzAppPtr = unsafe { mem::transmute(self) };

        // NOTE: should not block - this should only succeed
        // AFTER the App has finished executing
        let mut app_lock = match data.ptr.try_lock().ok() {
            Some(s) => s,
            None => return Ok(()),
        };

        let data_ref = match app_lock.data.downcast_ref::<AppDataTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data_ref._py_app_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::app::AzAppPtr = unsafe { mem::transmute(self) };

        // NOTE: should not block - this should only succeed
        // AFTER the App has finished executing
        let mut app_lock = match data.ptr.try_lock().ok() {
            Some(s) => s,
            None => return,
        };

        let mut data = match app_lock.data.downcast_mut::<AppDataTy>() {
            Some(s) => s,
            None => return,
        };

        // Clear reference, this decrements Python ref counter.
        data._py_app_data = None;
    }
}

#[repr(C)]
pub struct AppDataTy {
    _py_app_data: Option<PyObject>,
}

#[repr(C)]
pub struct LayoutCallbackTy {
    // acual callable object from python
    _py_layout_callback: Option<PyObject>,
}

extern "C" fn invoke_py_marshaled_layout_callback(
    marshal_data: &mut AzRefAny,
    app_data: &mut AzRefAny,
    info: AzLayoutCallbackInfo
) -> AzStyledDom {

    let mut marshal_data: &mut azul_impl::callbacks::RefAny = unsafe { mem::transmute(marshal_data) };
    let mut app_data: &mut azul_impl::callbacks::RefAny = unsafe { mem::transmute(app_data) };

    let mut app_data_downcast = match app_data.downcast_mut::<AppDataTy>() {
        Some(s) => s,
        None => return AzStyledDom::default(),
    };

    let mut app_data_downcast = match app_data_downcast._py_app_data.as_mut() {
        Some(s) => s,
        None => return AzStyledDom::default(),
    };

    let mut pyfunction = match marshal_data.downcast_mut::<LayoutCallbackTy>() {
        Some(s) => s,
        None => return AzStyledDom::default(),
    };

    let mut pyfunction = match pyfunction._py_layout_callback.as_mut() {
        Some(s) => s,
        None => return AzStyledDom::default(),
    };

    // call layout callback into python
    let s: AzStyledDom = Python::with_gil(|py| {

        match pyfunction.call1(py.clone(), (app_data_downcast.clone_ref(py.clone()), info)) {
            Ok(o) => match o.as_ref(py).extract::<AzStyledDom>() {
                Ok(o) => o.clone(),
                Err(e) => {
                    #[cfg(feature = "logging")] {
                        let cb_any = o.as_ref(py);
                        let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
                        log::error!("ERROR: LayoutCallback returned object of type {}, expected azul.dom.StyledDom", type_name);
                    }
                    AzStyledDom::default()
                }
            },
            Err(e) => {
                #[cfg(feature = "logging")] {
                    log::error!("Exception caught when invoking LayoutCallback: {}", e);
                }
                AzStyledDom::default()
            }
        }
    });

    s
}

#[pyproto]
impl PyGCProtocol for AzMarshaledLayoutCallback {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let mut refany = data.marshal_data.clone();

        let data = match refany.downcast_ref::<LayoutCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_layout_callback.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) };

        let mut data = match data.marshal_data.downcast_mut::<LayoutCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_layout_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_layout_callback = None;
        }
    }
}

#[repr(C)]
pub struct IFrameCallbackTy {
    _py_iframe_data: Option<PyObject>,
    _py_iframe_callback: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzIFrameNode {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::dom::IFrameNode = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let mut refany = data.data.clone();

        let data = match refany.downcast_ref::<IFrameCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_iframe_data.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_iframe_callback.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::dom::IFrameNode = unsafe { mem::transmute(self) };

        let mut data = match data.data.downcast_mut::<IFrameCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_iframe_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_iframe_data = None;
        }

        if data._py_iframe_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_iframe_callback = None;
        }
    }
}

extern "C" fn invoke_python_iframe(data: &mut azul_impl::callbacks::RefAny, info: azul_impl::callbacks::IFrameCallbackInfo) -> azul_impl::callbacks::IFrameCallbackReturn {

    let default = azul_impl::callbacks::IFrameCallbackReturn {
         dom: azul_impl::styled_dom::StyledDom::default(),
         scroll_size: azul_core::window::LogicalSize::new(0.0, 0.0),
         scroll_offset: azul_core::window::LogicalPosition::new(0.0, 0.0),
         virtual_scroll_size: azul_core::window::LogicalSize::new(0.0, 0.0),
         virtual_scroll_offset: azul_core::window::LogicalPosition::new(0.0, 0.0),
    };

    let data: &mut azul_impl::callbacks::RefAny = unsafe { mem::transmute(data) };

    let mut iframe_cb = match data.downcast_mut::<IFrameCallbackTy>() {
        Some(s) => s,
        None => return default,
    };

    let mut iframe_cb = &mut *iframe_cb;

    let mut py_data = match iframe_cb._py_iframe_data.as_mut() {
        Some(s) => s,
        None => return default,
    };

    let mut py_function = match iframe_cb._py_iframe_callback.as_mut() {
        Some(s) => s,
        None => return default,
    };

    // call iframe callback into python
    let s: azul_impl::callbacks::IFrameCallbackReturn = Python::with_gil(|py| {
        let info: AzIFrameCallbackInfo = unsafe { mem::transmute(info) };
        match py_function.call1(py.clone(), (py_data.clone_ref(py.clone()), info)) {
            Ok(o) => match o.as_ref(py).extract::<AzIFrameCallbackReturn>() {
                Ok(o) => unsafe { mem::transmute(o.clone()) },
                Err(e) => {
                    #[cfg(feature = "logging")] {
                        let cb_any = o.as_ref(py);
                        let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
                        log::error!("ERROR: LayoutCallback returned object of type {}, expected azul.callbacks.AzIFrameCallbackReturn", type_name);
                    }
                    default
                }
            },
            Err(e) => {
                #[cfg(feature = "logging")] {
                    log::error!("Exception caught when invoking IFrameCallback: {}", e);
                }
                default
            }
        }
    });

    s
}

#[repr(C)]
pub struct CallbackTy {
    _py_callback: Option<PyObject>,
    _py_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzCallbackData {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::dom::CallbackData = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let mut refany = data.data.clone();

        let data = match refany.downcast_ref::<CallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_callback.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::dom::CallbackData = unsafe { mem::transmute(self) };

        let mut data = match data.data.downcast_mut::<CallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_callback = None;
        }

        if data._py_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_data = None;
        }
    }
}

extern "C" fn invoke_python_callback(data: &mut azul_impl::callbacks::RefAny, info: azul_impl::callbacks::CallbackInfo) -> azul_impl::callbacks::Update {

    let default: azul_impl::callbacks::Update = azul_impl::callbacks::Update::DoNothing;

    let data: &mut azul_impl::callbacks::RefAny = unsafe { mem::transmute(data) };

    let mut cb = match data.downcast_mut::<CallbackTy>() {
        Some(s) => s,
        None => return default,
    };

    let mut cb = &mut *cb;

    let mut py_data = match cb._py_data.as_mut() {
        Some(s) => s,
        None => return default,
    };

    let mut py_function = match cb._py_callback.as_mut() {
        Some(s) => s,
        None => return default,
    };

    // call callback into python
    let s: azul_impl::callbacks::Update = Python::with_gil(|py| {
        let info: AzCallbackInfo = unsafe { mem::transmute(info) };

        match py_function.call1(py.clone(), (py_data.clone_ref(py.clone()), info)) {
            Ok(o) => match o.as_ref(py).extract::<AzUpdateEnumWrapper>() {
                Ok(o) => unsafe { mem::transmute(o.clone()) },
                Err(e) => {
                    #[cfg(feature = "logging")] {
                        let cb_any = o.as_ref(py);
                        let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
                        log::error!("ERROR: Callback returned object of type {}, expected azul.callbacks.Update", type_name);
                    }
                    default
                }
            },
            Err(e) => {
                #[cfg(feature = "logging")] {
                    log::error!("Exception caught when invoking Callback: {}", e);
                }
                default
            }
        }
    });

    s
}

#[repr(C)]
pub struct TimerCallbackTy {
    _py_timer_callback: Option<PyObject>,
    _py_timer_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzTimer {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::task::Timer = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let mut refany = data.data.clone();

        let data = match refany.downcast_ref::<TimerCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_timer_callback.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_timer_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::task::Timer = unsafe { mem::transmute(self) };

        let mut data = match data.data.downcast_mut::<TimerCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_timer_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_timer_callback = None;
        }

        if data._py_timer_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_timer_data = None;
        }
    }
}

#[repr(C)]
pub struct ImageCallbackTy {
    _py_image_callback: Option<PyObject>,
    _py_image_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzImageRef {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::resources::ImageRef = unsafe { mem::transmute(self) };

        let image_callback = match data.get_image_callback() {
            Some(s) => s,
            None => return Ok(()),
        };

        // temporary clone since we can't borrow mutable here
        let mut refany = image_callback.data.clone();

        let data = match refany.downcast_ref::<ImageCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_image_callback.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_image_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::resources::ImageRef = unsafe { mem::transmute(self) };

        let image_callback = match data.get_image_callback_mut() {
            Some(s) => s,
            None => return,
        };

        let mut data = match image_callback.data.downcast_mut::<ImageCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_image_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_image_callback = None;
        }

        if data._py_image_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_image_data = None;
        }
    }
}

#[repr(C)]
pub struct ThreadWriteBackCallbackTy {
    _py_thread_callback: Option<PyObject>,
    _py_thread_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzThread {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::task::Thread = unsafe { mem::transmute(self) };

        let mut thread_inner = match data.ptr.try_lock().ok() {
            Some(o) => o,
            None => return Ok(()),
        };

        let mut data = match thread_inner.writeback_data.downcast_mut::<ThreadWriteBackCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_thread_callback.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_thread_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::task::Thread = unsafe { mem::transmute(self) };

        let mut thread_inner = match data.ptr.try_lock().ok() {
            Some(o) => o,
            None => return,
        };

        let mut data = match thread_inner.writeback_data.downcast_mut::<ThreadWriteBackCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_thread_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_thread_callback = None;
        }

        if data._py_thread_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_thread_data = None;
        }
    }
}

#[repr(C)]
pub struct DatasetTy {
    _py_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzNodeData {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::dom::NodeData = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let dataset = match data.get_dataset().as_ref() {
            Some(s) => s,
            None => return Ok(()),
        };

        let mut refany = dataset.clone();

        let data = match refany.downcast_ref::<DatasetTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::dom::NodeData = unsafe { mem::transmute(self) };

        let dataset = match data.get_dataset_mut().as_mut() {
            Some(s) => s,
            None => return,
        };

        let mut data = match dataset.downcast_mut::<DatasetTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_data = None;
        }
    }
}
/// Main application class
#[repr(C)]
pub struct AzApp {
    pub ptr: *const c_void,
}

/// Configuration to set which messages should be logged.
#[repr(C)]
pub enum AzAppLogLevel {
    Off,
    Error,
    Warn,
    Info,
    Debug,
    Trace,
}

/// Version of the layout solver to use - future binary versions of azul may have more fields here, necessary so that old compiled applications don't break with newer releases of azul. Newer layout versions are opt-in only.
#[repr(C)]
pub enum AzLayoutSolver {
    Default,
}

/// Whether the renderer has VSync enabled
#[repr(C)]
pub enum AzVsync {
    Enabled,
    Disabled,
    DontCare,
}

/// Does the renderer render in SRGB color space? By default, azul tries to set it to `Enabled` and falls back to `Disabled` if the OpenGL context can't be initialized properly
#[repr(C)]
pub enum AzSrgb {
    Enabled,
    Disabled,
    DontCare,
}

/// Does the renderer render using hardware acceleration? By default, azul tries to set it to `Enabled` and falls back to `Disabled` if the OpenGL context can't be initialized properly
#[repr(C)]
pub enum AzHwAcceleration {
    Enabled,
    Disabled,
    DontCare,
}

/// Offset in physical pixels (integer units)
#[repr(C)]
pub struct AzLayoutPoint {
    pub x: isize,
    pub y: isize,
}

/// Size in physical pixels (integer units)
#[repr(C)]
pub struct AzLayoutSize {
    pub width: isize,
    pub height: isize,
}

/// Re-export of rust-allocated (stack based) `IOSHandle` struct
#[repr(C)]
pub struct AzIOSHandle {
    pub ui_window: *mut c_void,
    pub ui_view: *mut c_void,
    pub ui_view_controller: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `MacOSHandle` struct
#[repr(C)]
pub struct AzMacOSHandle {
    pub ns_window: *mut c_void,
    pub ns_view: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `XlibHandle` struct
#[repr(C)]
pub struct AzXlibHandle {
    pub window: u64,
    pub display: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `XcbHandle` struct
#[repr(C)]
pub struct AzXcbHandle {
    pub window: u32,
    pub connection: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `WaylandHandle` struct
#[repr(C)]
pub struct AzWaylandHandle {
    pub surface: *mut c_void,
    pub display: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `WindowsHandle` struct
#[repr(C)]
pub struct AzWindowsHandle {
    pub hwnd: *mut c_void,
    pub hinstance: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `WebHandle` struct
#[repr(C)]
pub struct AzWebHandle {
    pub id: u32,
}

/// Re-export of rust-allocated (stack based) `AndroidHandle` struct
#[repr(C)]
pub struct AzAndroidHandle {
    pub a_native_window: *mut c_void,
}

/// X11 window hint: Type of window
#[repr(C)]
pub enum AzXWindowType {
    Desktop,
    Dock,
    Toolbar,
    Menu,
    Utility,
    Splash,
    Dialog,
    DropdownMenu,
    PopupMenu,
    Tooltip,
    Notification,
    Combo,
    Dnd,
    Normal,
}

/// Same as `LayoutPoint`, but uses `i32` instead of `isize`
#[repr(C)]
pub struct AzPhysicalPositionI32 {
    pub x: i32,
    pub y: i32,
}

/// Same as `LayoutPoint`, but uses `u32` instead of `isize`
#[repr(C)]
pub struct AzPhysicalSizeU32 {
    pub width: u32,
    pub height: u32,
}

/// Logical position (can differ based on HiDPI settings). Usually this is what you'd want for hit-testing and positioning elements.
#[repr(C)]
pub struct AzLogicalPosition {
    pub x: f32,
    pub y: f32,
}

/// A size in "logical" (non-HiDPI-adjusted) pixels in floating-point units
#[repr(C)]
pub struct AzLogicalSize {
    pub width: f32,
    pub height: f32,
}

/// Unique hash of a window icon, so that azul does not have to compare the actual bytes to see wether the window icon has changed.
#[repr(C)]
pub struct AzIconKey {
    pub id: usize,
}

/// Symbolic name for a keyboard key, does **not** take the keyboard locale into account
#[repr(C)]
pub enum AzVirtualKeyCode {
    Key1,
    Key2,
    Key3,
    Key4,
    Key5,
    Key6,
    Key7,
    Key8,
    Key9,
    Key0,
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z,
    Escape,
    F1,
    F2,
    F3,
    F4,
    F5,
    F6,
    F7,
    F8,
    F9,
    F10,
    F11,
    F12,
    F13,
    F14,
    F15,
    F16,
    F17,
    F18,
    F19,
    F20,
    F21,
    F22,
    F23,
    F24,
    Snapshot,
    Scroll,
    Pause,
    Insert,
    Home,
    Delete,
    End,
    PageDown,
    PageUp,
    Left,
    Up,
    Right,
    Down,
    Back,
    Return,
    Space,
    Compose,
    Caret,
    Numlock,
    Numpad0,
    Numpad1,
    Numpad2,
    Numpad3,
    Numpad4,
    Numpad5,
    Numpad6,
    Numpad7,
    Numpad8,
    Numpad9,
    NumpadAdd,
    NumpadDivide,
    NumpadDecimal,
    NumpadComma,
    NumpadEnter,
    NumpadEquals,
    NumpadMultiply,
    NumpadSubtract,
    AbntC1,
    AbntC2,
    Apostrophe,
    Apps,
    Asterisk,
    At,
    Ax,
    Backslash,
    Calculator,
    Capital,
    Colon,
    Comma,
    Convert,
    Equals,
    Grave,
    Kana,
    Kanji,
    LAlt,
    LBracket,
    LControl,
    LShift,
    LWin,
    Mail,
    MediaSelect,
    MediaStop,
    Minus,
    Mute,
    MyComputer,
    NavigateForward,
    NavigateBackward,
    NextTrack,
    NoConvert,
    OEM102,
    Period,
    PlayPause,
    Plus,
    Power,
    PrevTrack,
    RAlt,
    RBracket,
    RControl,
    RShift,
    RWin,
    Semicolon,
    Slash,
    Sleep,
    Stop,
    Sysrq,
    Tab,
    Underline,
    Unlabeled,
    VolumeDown,
    VolumeUp,
    Wake,
    WebBack,
    WebFavorites,
    WebForward,
    WebHome,
    WebRefresh,
    WebSearch,
    WebStop,
    Yen,
    Copy,
    Paste,
    Cut,
}

/// State of the window frame (minimized, maximized, fullscreen or normal window)
#[repr(C)]
pub enum AzWindowFrame {
    Normal,
    Minimized,
    Maximized,
    Fullscreen,
}

/// Debugging information, will be rendered as an overlay on top of the UI
#[repr(C)]
pub struct AzDebugState {
    pub profiler_dbg: bool,
    pub render_target_dbg: bool,
    pub texture_cache_dbg: bool,
    pub gpu_time_queries: bool,
    pub gpu_sample_queries: bool,
    pub disable_batching: bool,
    pub epochs: bool,
    pub echo_driver_messages: bool,
    pub show_overdraw: bool,
    pub gpu_cache_dbg: bool,
    pub texture_cache_dbg_clear_evicted: bool,
    pub picture_caching_dbg: bool,
    pub primitive_dbg: bool,
    pub zoom_dbg: bool,
    pub small_screen: bool,
    pub disable_opaque_pass: bool,
    pub disable_alpha_pass: bool,
    pub disable_clip_masks: bool,
    pub disable_text_prims: bool,
    pub disable_gradient_prims: bool,
    pub obscure_images: bool,
    pub glyph_flashing: bool,
    pub smart_profiler: bool,
    pub invalidation_dbg: bool,
    pub tile_cache_logging_dbg: bool,
    pub profiler_capture: bool,
    pub force_picture_invalidation: bool,
}

/// Current icon of the mouse cursor
#[repr(C)]
pub enum AzMouseCursorType {
    Default,
    Crosshair,
    Hand,
    Arrow,
    Move,
    Text,
    Wait,
    Help,
    Progress,
    NotAllowed,
    ContextMenu,
    Cell,
    VerticalText,
    Alias,
    Copy,
    NoDrop,
    Grab,
    Grabbing,
    AllScroll,
    ZoomIn,
    ZoomOut,
    EResize,
    NResize,
    NeResize,
    NwResize,
    SResize,
    SeResize,
    SwResize,
    WResize,
    EwResize,
    NsResize,
    NeswResize,
    NwseResize,
    ColResize,
    RowResize,
}

/// Renderer type of the current windows OpenGL context
#[repr(C)]
pub enum AzRendererType {
    Hardware,
    Software,
}

/// Re-export of rust-allocated (stack based) `MacWindowOptions` struct
#[repr(C)]
pub struct AzMacWindowOptions {
    pub _reserved: u8,
}

/// Re-export of rust-allocated (stack based) `WasmWindowOptions` struct
#[repr(C)]
pub struct AzWasmWindowOptions {
    pub _reserved: u8,
}

/// Re-export of rust-allocated (stack based) `FullScreenMode` struct
#[repr(C)]
pub enum AzFullScreenMode {
    SlowFullScreen,
    FastFullScreen,
    SlowWindowed,
    FastWindowed,
}

/// Window theme, set by the operating system or `WindowCreateOptions.theme` on startup
#[repr(C)]
pub enum AzWindowTheme {
    DarkMode,
    LightMode,
}

/// Current state of touch devices / touch inputs
#[repr(C)]
pub struct AzTouchState {
    pub unused: u8,
}

/// C-ABI stable wrapper over a `MarshaledLayoutCallbackInner`
#[repr(C)]
pub struct AzMarshaledLayoutCallbackInner {
    pub cb: AzMarshaledLayoutCallbackType,
}

/// `AzMarshaledLayoutCallbackType` struct
pub type AzMarshaledLayoutCallbackType = extern "C" fn(&mut AzRefAny, &mut AzRefAny, AzLayoutCallbackInfo) -> AzStyledDom;

/// C-ABI stable wrapper over a `LayoutCallbackType`
#[repr(C)]
pub struct AzLayoutCallbackInner {
    pub cb: AzLayoutCallbackType,
}

/// `AzLayoutCallbackType` struct
pub type AzLayoutCallbackType = extern "C" fn(&mut AzRefAny, &mut AzLayoutCallbackInfo) -> AzStyledDom;

/// C-ABI stable wrapper over a `CallbackType`
#[repr(C)]
pub struct AzCallback {
    pub cb: AzCallbackType,
}

/// `AzCallbackType` struct
pub type AzCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo) -> AzUpdate;

/// Which type of image should be updated: background image (the CSS background) or content image (the <img src=""> content)
#[repr(C)]
pub enum AzUpdateImageType {
    Background,
    Content,
}

/// Specifies if the screen should be updated after the callback function has returned
#[repr(C)]
pub enum AzUpdate {
    DoNothing,
    RefreshDom,
    RefreshDomAllWindows,
}

/// Index of a Node in the internal `NodeDataContainer`
#[repr(C)]
pub struct AzNodeId {
    pub inner: usize,
}

/// ID of a DOM - one window can contain multiple, nested DOMs (such as iframes)
#[repr(C)]
pub struct AzDomId {
    pub inner: usize,
}

/// Re-export of rust-allocated (stack based) `PositionInfoInner` struct
#[repr(C)]
pub struct AzPositionInfoInner {
    pub x_offset: f32,
    pub y_offset: f32,
    pub static_x_offset: f32,
    pub static_y_offset: f32,
}

/// How should an animation repeat (loop, ping-pong, etc.)
#[repr(C)]
pub enum AzAnimationRepeat {
    NoRepeat,
    Loop,
    PingPong,
}

/// How many times should an animation repeat
#[repr(C, u8)]
pub enum AzAnimationRepeatCount {
    Times(usize),
    Infinite,
}

/// C-ABI wrapper over an `IFrameCallbackType`
#[repr(C)]
pub struct AzIFrameCallback {
    pub cb: AzIFrameCallbackType,
}

/// `AzIFrameCallbackType` struct
pub type AzIFrameCallbackType = extern "C" fn(&mut AzRefAny, &mut AzIFrameCallbackInfo) -> AzIFrameCallbackReturn;

/// Re-export of rust-allocated (stack based) `RenderImageCallback` struct
#[repr(C)]
pub struct AzRenderImageCallback {
    pub cb: AzRenderImageCallbackType,
}

/// `AzRenderImageCallbackType` struct
pub type AzRenderImageCallbackType = extern "C" fn(&mut AzRefAny, &mut AzRenderImageCallbackInfo) -> AzImageRef;

/// Re-export of rust-allocated (stack based) `TimerCallback` struct
#[repr(C)]
pub struct AzTimerCallback {
    pub cb: AzTimerCallbackType,
}

/// `AzTimerCallbackType` struct
pub type AzTimerCallbackType = extern "C" fn(&mut AzRefAny, &mut AzTimerCallbackInfo) -> AzTimerCallbackReturn;

/// `AzWriteBackCallbackType` struct
pub type AzWriteBackCallbackType = extern "C" fn(&mut AzRefAny, &mut AzRefAny, &mut AzCallbackInfo) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `WriteBackCallback` struct
#[repr(C)]
pub struct AzWriteBackCallback {
    pub cb: AzWriteBackCallbackType,
}

/// Re-export of rust-allocated (stack based) `ThreadCallback` struct
#[repr(C)]
pub struct AzThreadCallback {
    pub cb: AzThreadCallbackType,
}

/// `AzThreadCallbackType` struct
pub type AzThreadCallbackType = extern "C" fn(AzRefAny, AzThreadSender, AzThreadReceiver);

/// `AzRefAnyDestructorType` struct
pub type AzRefAnyDestructorType = extern "C" fn(&mut c_void);

/// Re-export of rust-allocated (stack based) `RefCount` struct
#[repr(C)]
pub struct AzRefCount {
    pub ptr: *const c_void,
}

/// When to call a callback action - `On::MouseOver`, `On::MouseOut`, etc.
#[repr(C)]
pub enum AzOn {
    MouseOver,
    MouseDown,
    LeftMouseDown,
    MiddleMouseDown,
    RightMouseDown,
    MouseUp,
    LeftMouseUp,
    MiddleMouseUp,
    RightMouseUp,
    MouseEnter,
    MouseLeave,
    Scroll,
    TextInput,
    VirtualKeyDown,
    VirtualKeyUp,
    HoveredFile,
    DroppedFile,
    HoveredFileCancelled,
    FocusReceived,
    FocusLost,
}

/// Re-export of rust-allocated (stack based) `HoverEventFilter` struct
#[repr(C)]
pub enum AzHoverEventFilter {
    MouseOver,
    MouseDown,
    LeftMouseDown,
    RightMouseDown,
    MiddleMouseDown,
    MouseUp,
    LeftMouseUp,
    RightMouseUp,
    MiddleMouseUp,
    MouseEnter,
    MouseLeave,
    Scroll,
    ScrollStart,
    ScrollEnd,
    TextInput,
    VirtualKeyDown,
    VirtualKeyUp,
    HoveredFile,
    DroppedFile,
    HoveredFileCancelled,
    TouchStart,
    TouchMove,
    TouchEnd,
    TouchCancel,
}

/// Re-export of rust-allocated (stack based) `FocusEventFilter` struct
#[repr(C)]
pub enum AzFocusEventFilter {
    MouseOver,
    MouseDown,
    LeftMouseDown,
    RightMouseDown,
    MiddleMouseDown,
    MouseUp,
    LeftMouseUp,
    RightMouseUp,
    MiddleMouseUp,
    MouseEnter,
    MouseLeave,
    Scroll,
    ScrollStart,
    ScrollEnd,
    TextInput,
    VirtualKeyDown,
    VirtualKeyUp,
    FocusReceived,
    FocusLost,
}

/// Re-export of rust-allocated (stack based) `WindowEventFilter` struct
#[repr(C)]
pub enum AzWindowEventFilter {
    MouseOver,
    MouseDown,
    LeftMouseDown,
    RightMouseDown,
    MiddleMouseDown,
    MouseUp,
    LeftMouseUp,
    RightMouseUp,
    MiddleMouseUp,
    MouseEnter,
    MouseLeave,
    Scroll,
    ScrollStart,
    ScrollEnd,
    TextInput,
    VirtualKeyDown,
    VirtualKeyUp,
    HoveredFile,
    DroppedFile,
    HoveredFileCancelled,
    Resized,
    Moved,
    TouchStart,
    TouchMove,
    TouchEnd,
    TouchCancel,
    FocusReceived,
    FocusLost,
    CloseRequested,
    ThemeChanged,
}

/// Re-export of rust-allocated (stack based) `ComponentEventFilter` struct
#[repr(C)]
pub enum AzComponentEventFilter {
    AfterMount,
    BeforeUnmount,
    NodeResized,
    DefaultAction,
    Selected,
}

/// Re-export of rust-allocated (stack based) `ApplicationEventFilter` struct
#[repr(C)]
pub enum AzApplicationEventFilter {
    DeviceConnected,
    DeviceDisconnected,
}

/// MSAA Accessibility role constants. For information on what each role does, see the <a href="https://docs.microsoft.com/en-us/windows/win32/winauto/object-roles">MSDN Role Constants page</a>
#[repr(C)]
pub enum AzAccessibilityRole {
    TitleBar,
    MenuBar,
    ScrollBar,
    Grip,
    Sound,
    Cursor,
    Caret,
    Alert,
    Window,
    Client,
    MenuPopup,
    MenuItem,
    Tooltip,
    Application,
    Document,
    Pane,
    Chart,
    Dialog,
    Border,
    Grouping,
    Separator,
    Toolbar,
    StatusBar,
    Table,
    ColumnHeader,
    RowHeader,
    Column,
    Row,
    Cell,
    Link,
    HelpBalloon,
    Character,
    List,
    ListItem,
    Outline,
    OutlineItem,
    Pagetab,
    PropertyPage,
    Indicator,
    Graphic,
    StaticText,
    Text,
    PushButton,
    CheckButton,
    RadioButton,
    ComboBox,
    DropList,
    ProgressBar,
    Dial,
    HotkeyField,
    Slider,
    SpinButton,
    Diagram,
    Animation,
    Equation,
    ButtonDropdown,
    ButtonMenu,
    ButtonDropdownGrid,
    Whitespace,
    PageTabList,
    Clock,
    SplitButton,
    IpAddress,
    Nothing,
}

/// MSAA accessibility state. For information on what each state does, see the <a href="https://docs.microsoft.com/en-us/windows/win32/winauto/object-state-constants">MSDN State Constants page</a>.
#[repr(C)]
pub enum AzAccessibilityState {
    Unavailable,
    Selected,
    Focused,
    Checked,
    Readonly,
    Default,
    Expanded,
    Collapsed,
    Busy,
    Offscreen,
    Focusable,
    Selectable,
    Linked,
    Traversed,
    Multiselectable,
    Protected,
}

/// Re-export of rust-allocated (stack based) `TabIndex` struct
#[repr(C, u8)]
pub enum AzTabIndex {
    Auto,
    OverrideInParent(u32),
    NoKeyboardFocus,
}

/// Determines whether this context menu should pop up on a left, right or middle click
#[repr(C)]
pub enum AzContextMenuMouseButton {
    Right,
    Middle,
    Left,
}

/// Position of where the context menu should pop up
#[repr(C)]
pub enum AzMenuPopupPosition {
    BottomLeftOfCursor,
    BottomRightOfCursor,
    TopLeftOfCursor,
    TopRightOfCursor,
    BottomOfHitRect,
    LeftOfHitRect,
    TopOfHitRect,
    RightOfHitRect,
    AutoCursor,
    AutoHitRect,
}

/// Describes the state of a menu item
#[repr(C)]
pub enum AzMenuItemState {
    Normal,
    Greyed,
    Disabled,
}

/// Re-export of rust-allocated (stack based) `NodeTypeKey` struct
#[repr(C)]
pub enum AzNodeTypeKey {
    Body,
    Div,
    Br,
    P,
    Img,
    IFrame,
}

/// Re-export of rust-allocated (stack based) `CssNthChildPattern` struct
#[repr(C)]
pub struct AzCssNthChildPattern {
    pub repeat: u32,
    pub offset: u32,
}

/// Re-export of rust-allocated (stack based) `CssPropertyType` struct
#[repr(C)]
pub enum AzCssPropertyType {
    TextColor,
    FontSize,
    FontFamily,
    TextAlign,
    LetterSpacing,
    LineHeight,
    WordSpacing,
    TabWidth,
    Cursor,
    Display,
    Float,
    BoxSizing,
    Width,
    Height,
    MinWidth,
    MinHeight,
    MaxWidth,
    MaxHeight,
    Position,
    Top,
    Right,
    Left,
    Bottom,
    FlexWrap,
    FlexDirection,
    FlexGrow,
    FlexShrink,
    JustifyContent,
    AlignItems,
    AlignContent,
    BackgroundContent,
    BackgroundPosition,
    BackgroundSize,
    BackgroundRepeat,
    OverflowX,
    OverflowY,
    PaddingTop,
    PaddingLeft,
    PaddingRight,
    PaddingBottom,
    MarginTop,
    MarginLeft,
    MarginRight,
    MarginBottom,
    BorderTopLeftRadius,
    BorderTopRightRadius,
    BorderBottomLeftRadius,
    BorderBottomRightRadius,
    BorderTopColor,
    BorderRightColor,
    BorderLeftColor,
    BorderBottomColor,
    BorderTopStyle,
    BorderRightStyle,
    BorderLeftStyle,
    BorderBottomStyle,
    BorderTopWidth,
    BorderRightWidth,
    BorderLeftWidth,
    BorderBottomWidth,
    BoxShadowLeft,
    BoxShadowRight,
    BoxShadowTop,
    BoxShadowBottom,
    ScrollbarStyle,
    Opacity,
    Transform,
    TransformOrigin,
    PerspectiveOrigin,
    BackfaceVisibility,
}

/// Re-export of rust-allocated (stack based) `ColorU` struct
#[repr(C)]
pub struct AzColorU {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}

/// Re-export of rust-allocated (stack based) `SizeMetric` struct
#[repr(C)]
pub enum AzSizeMetric {
    Px,
    Pt,
    Em,
    Percent,
}

/// Re-export of rust-allocated (stack based) `FloatValue` struct
#[repr(C)]
pub struct AzFloatValue {
    pub number: isize,
}

/// Re-export of rust-allocated (stack based) `BoxShadowClipMode` struct
#[repr(C)]
pub enum AzBoxShadowClipMode {
    Outset,
    Inset,
}

/// Re-export of rust-allocated (stack based) `LayoutAlignContent` struct
#[repr(C)]
pub enum AzLayoutAlignContent {
    Stretch,
    Center,
    Start,
    End,
    SpaceBetween,
    SpaceAround,
}

/// Re-export of rust-allocated (stack based) `LayoutAlignItems` struct
#[repr(C)]
pub enum AzLayoutAlignItems {
    Stretch,
    Center,
    FlexStart,
    FlexEnd,
}

/// Re-export of rust-allocated (stack based) `LayoutBoxSizing` struct
#[repr(C)]
pub enum AzLayoutBoxSizing {
    ContentBox,
    BorderBox,
}

/// Re-export of rust-allocated (stack based) `LayoutFlexDirection` struct
#[repr(C)]
pub enum AzLayoutFlexDirection {
    Row,
    RowReverse,
    Column,
    ColumnReverse,
}

/// Re-export of rust-allocated (stack based) `LayoutDisplay` struct
#[repr(C)]
pub enum AzLayoutDisplay {
    None,
    Flex,
    Block,
    InlineBlock,
}

/// Re-export of rust-allocated (stack based) `LayoutFloat` struct
#[repr(C)]
pub enum AzLayoutFloat {
    Left,
    Right,
}

/// Re-export of rust-allocated (stack based) `LayoutJustifyContent` struct
#[repr(C)]
pub enum AzLayoutJustifyContent {
    Start,
    End,
    Center,
    SpaceBetween,
    SpaceAround,
    SpaceEvenly,
}

/// Re-export of rust-allocated (stack based) `LayoutPosition` struct
#[repr(C)]
pub enum AzLayoutPosition {
    Static,
    Relative,
    Absolute,
    Fixed,
}

/// Re-export of rust-allocated (stack based) `LayoutFlexWrap` struct
#[repr(C)]
pub enum AzLayoutFlexWrap {
    Wrap,
    NoWrap,
}

/// Re-export of rust-allocated (stack based) `LayoutOverflow` struct
#[repr(C)]
pub enum AzLayoutOverflow {
    Scroll,
    Auto,
    Hidden,
    Visible,
}

/// Re-export of rust-allocated (stack based) `AngleMetric` struct
#[repr(C)]
pub enum AzAngleMetric {
    Degree,
    Radians,
    Grad,
    Turn,
    Percent,
}

/// Re-export of rust-allocated (stack based) `DirectionCorner` struct
#[repr(C)]
pub enum AzDirectionCorner {
    Right,
    Left,
    Top,
    Bottom,
    TopRight,
    TopLeft,
    BottomRight,
    BottomLeft,
}

/// Re-export of rust-allocated (stack based) `ExtendMode` struct
#[repr(C)]
pub enum AzExtendMode {
    Clamp,
    Repeat,
}

/// Re-export of rust-allocated (stack based) `Shape` struct
#[repr(C)]
pub enum AzShape {
    Ellipse,
    Circle,
}

/// Re-export of rust-allocated (stack based) `RadialGradientSize` struct
#[repr(C)]
pub enum AzRadialGradientSize {
    ClosestSide,
    ClosestCorner,
    FarthestSide,
    FarthestCorner,
}

/// Re-export of rust-allocated (stack based) `StyleBackgroundRepeat` struct
#[repr(C)]
pub enum AzStyleBackgroundRepeat {
    NoRepeat,
    Repeat,
    RepeatX,
    RepeatY,
}

/// Re-export of rust-allocated (stack based) `BorderStyle` struct
#[repr(C)]
pub enum AzBorderStyle {
    None,
    Solid,
    Double,
    Dotted,
    Dashed,
    Hidden,
    Groove,
    Ridge,
    Inset,
    Outset,
}

/// Re-export of rust-allocated (stack based) `StyleCursor` struct
#[repr(C)]
pub enum AzStyleCursor {
    Alias,
    AllScroll,
    Cell,
    ColResize,
    ContextMenu,
    Copy,
    Crosshair,
    Default,
    EResize,
    EwResize,
    Grab,
    Grabbing,
    Help,
    Move,
    NResize,
    NsResize,
    NeswResize,
    NwseResize,
    Pointer,
    Progress,
    RowResize,
    SResize,
    SeResize,
    Text,
    Unset,
    VerticalText,
    WResize,
    Wait,
    ZoomIn,
    ZoomOut,
}

/// Re-export of rust-allocated (stack based) `StyleBackfaceVisibility` struct
#[repr(C)]
pub enum AzStyleBackfaceVisibility {
    Hidden,
    Visible,
}

/// Re-export of rust-allocated (stack based) `StyleTextAlign` struct
#[repr(C)]
pub enum AzStyleTextAlign {
    Left,
    Center,
    Right,
}

/// Re-export of rust-allocated (stack based) `CheckBoxOnToggleCallback` struct
#[repr(C)]
pub struct AzCheckBoxOnToggleCallback {
    pub cb: AzCheckBoxOnToggleCallbackType,
}

/// `AzCheckBoxOnToggleCallbackType` struct
pub type AzCheckBoxOnToggleCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzCheckBoxState) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `CheckBoxState` struct
#[repr(C)]
pub struct AzCheckBoxState {
    pub checked: bool,
}

/// Re-export of rust-allocated (stack based) `ColorInputOnValueChangeCallback` struct
#[repr(C)]
pub struct AzColorInputOnValueChangeCallback {
    pub cb: AzColorInputOnValueChangeCallbackType,
}

/// `AzColorInputOnValueChangeCallbackType` struct
pub type AzColorInputOnValueChangeCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzColorInputState) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `TextInputSelectionRange` struct
#[repr(C)]
pub struct AzTextInputSelectionRange {
    pub from: usize,
    pub to: usize,
}

/// Re-export of rust-allocated (stack based) `TextInputOnTextInputCallback` struct
#[repr(C)]
pub struct AzTextInputOnTextInputCallback {
    pub cb: AzTextInputOnTextInputCallbackType,
}

/// `AzTextInputOnTextInputCallbackType` struct
pub type AzTextInputOnTextInputCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzTextInputState) -> AzOnTextInputReturn;

/// Re-export of rust-allocated (stack based) `TextInputOnVirtualKeyDownCallback` struct
#[repr(C)]
pub struct AzTextInputOnVirtualKeyDownCallback {
    pub cb: AzTextInputOnVirtualKeyDownCallbackType,
}

/// `AzTextInputOnVirtualKeyDownCallbackType` struct
pub type AzTextInputOnVirtualKeyDownCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzTextInputState) -> AzOnTextInputReturn;

/// Re-export of rust-allocated (stack based) `TextInputOnFocusLostCallback` struct
#[repr(C)]
pub struct AzTextInputOnFocusLostCallback {
    pub cb: AzTextInputOnFocusLostCallbackType,
}

/// `AzTextInputOnFocusLostCallbackType` struct
pub type AzTextInputOnFocusLostCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzTextInputState) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `TextInputValid` struct
#[repr(C)]
pub enum AzTextInputValid {
    Yes,
    No,
}

/// Re-export of rust-allocated (stack based) `NumberInputState` struct
#[repr(C)]
pub struct AzNumberInputState {
    pub previous: f32,
    pub number: f32,
    pub min: f32,
    pub max: f32,
}

/// Re-export of rust-allocated (stack based) `NumberInputOnValueChangeCallback` struct
#[repr(C)]
pub struct AzNumberInputOnValueChangeCallback {
    pub cb: AzNumberInputOnValueChangeCallbackType,
}

/// `AzNumberInputOnValueChangeCallbackType` struct
pub type AzNumberInputOnValueChangeCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzNumberInputState) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NumberInputOnFocusLostCallback` struct
#[repr(C)]
pub struct AzNumberInputOnFocusLostCallback {
    pub cb: AzNumberInputOnFocusLostCallbackType,
}

/// `AzNumberInputOnFocusLostCallbackType` struct
pub type AzNumberInputOnFocusLostCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzNumberInputState) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `ProgressBarState` struct
#[repr(C)]
pub struct AzProgressBarState {
    pub percent_done: f32,
    pub display_percentage: bool,
}

/// Re-export of rust-allocated (stack based) `NodeGraphStyle` struct
#[repr(C)]
pub enum AzNodeGraphStyle {
    Default,
}

/// `AzNodeGraphOnNodeAddedCallbackType` struct
pub type AzNodeGraphOnNodeAddedCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeTypeId, AzNodeGraphNodeId, AzNodePosition) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeAddedCallback` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeAddedCallback {
    pub cb: AzNodeGraphOnNodeAddedCallbackType,
}

/// `AzNodeGraphOnNodeRemovedCallbackType` struct
pub type AzNodeGraphOnNodeRemovedCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeRemovedCallback` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeRemovedCallback {
    pub cb: AzNodeGraphOnNodeRemovedCallbackType,
}

/// `AzNodeGraphOnNodeGraphDraggedCallbackType` struct
pub type AzNodeGraphOnNodeGraphDraggedCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzGraphDragAmount) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeGraphDraggedCallback` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeGraphDraggedCallback {
    pub cb: AzNodeGraphOnNodeGraphDraggedCallbackType,
}

/// `AzNodeGraphOnNodeDraggedCallbackType` struct
pub type AzNodeGraphOnNodeDraggedCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId, AzNodeDragAmount) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeDraggedCallback` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeDraggedCallback {
    pub cb: AzNodeGraphOnNodeDraggedCallbackType,
}

/// `AzNodeGraphOnNodeConnectedCallbackType` struct
pub type AzNodeGraphOnNodeConnectedCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId, usize, AzNodeGraphNodeId, usize) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeConnectedCallback` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeConnectedCallback {
    pub cb: AzNodeGraphOnNodeConnectedCallbackType,
}

/// `AzNodeGraphOnNodeInputDisconnectedCallbackType` struct
pub type AzNodeGraphOnNodeInputDisconnectedCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId, usize) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeInputDisconnectedCallback` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeInputDisconnectedCallback {
    pub cb: AzNodeGraphOnNodeInputDisconnectedCallbackType,
}

/// `AzNodeGraphOnNodeOutputDisconnectedCallbackType` struct
pub type AzNodeGraphOnNodeOutputDisconnectedCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId, usize) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeOutputDisconnectedCallback` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeOutputDisconnectedCallback {
    pub cb: AzNodeGraphOnNodeOutputDisconnectedCallbackType,
}

/// `AzNodeGraphOnNodeFieldEditedCallbackType` struct
pub type AzNodeGraphOnNodeFieldEditedCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId, usize, AzNodeTypeId, AzNodeTypeFieldValue) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeFieldEditedCallback` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeFieldEditedCallback {
    pub cb: AzNodeGraphOnNodeFieldEditedCallbackType,
}

/// Re-export of rust-allocated (stack based) `InputOutputTypeId` struct
#[repr(C)]
pub struct AzInputOutputTypeId {
    pub inner: u64,
}

/// Re-export of rust-allocated (stack based) `NodeTypeId` struct
#[repr(C)]
pub struct AzNodeTypeId {
    pub inner: u64,
}

/// Re-export of rust-allocated (stack based) `NodeGraphNodeId` struct
#[repr(C)]
pub struct AzNodeGraphNodeId {
    pub inner: u64,
}

/// Re-export of rust-allocated (stack based) `NodePosition` struct
#[repr(C)]
pub struct AzNodePosition {
    pub x: f32,
    pub y: f32,
}

/// Re-export of rust-allocated (stack based) `GraphDragAmount` struct
#[repr(C)]
pub struct AzGraphDragAmount {
    pub x: f32,
    pub y: f32,
}

/// Re-export of rust-allocated (stack based) `NodeDragAmount` struct
#[repr(C)]
pub struct AzNodeDragAmount {
    pub x: f32,
    pub y: f32,
}

/// `AzDropDownOnChoiceChangeCallbackType` struct
pub type AzDropDownOnChoiceChangeCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, usize) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `DropDownOnChoiceChangeCallback` struct
#[repr(C)]
pub struct AzDropDownOnChoiceChangeCallback {
    pub cb: AzDropDownOnChoiceChangeCallbackType,
}

/// Re-export of rust-allocated (stack based) `NodeHierarchyItem` struct
#[repr(C)]
pub struct AzNodeHierarchyItem {
    pub parent: usize,
    pub previous_sibling: usize,
    pub next_sibling: usize,
    pub last_child: usize,
}

/// Re-export of rust-allocated (stack based) `CascadeInfo` struct
#[repr(C)]
pub struct AzCascadeInfo {
    pub index_in_parent: u32,
    pub is_last_child: bool,
}

/// Re-export of rust-allocated (stack based) `StyledNodeState` struct
#[repr(C)]
pub struct AzStyledNodeState {
    pub normal: bool,
    pub hover: bool,
    pub active: bool,
    pub focused: bool,
}

/// Re-export of rust-allocated (stack based) `TagId` struct
#[repr(C)]
pub struct AzTagId {
    pub inner: u64,
}

/// Re-export of rust-allocated (stack based) `CssPropertyCache` struct
#[repr(C)]
pub struct AzCssPropertyCache {
    pub ptr: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `GlVoidPtrConst` struct
#[repr(C)]
pub struct AzGlVoidPtrConst {
    pub ptr: *const c_void,
}

/// Re-export of rust-allocated (stack based) `GlVoidPtrMut` struct
#[repr(C)]
pub struct AzGlVoidPtrMut {
    pub ptr: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `GlShaderPrecisionFormatReturn` struct
#[repr(C)]
pub struct AzGlShaderPrecisionFormatReturn {
    pub _0: i32,
    pub _1: i32,
    pub _2: i32,
}

/// Re-export of rust-allocated (stack based) `VertexAttributeType` struct
#[repr(C)]
pub enum AzVertexAttributeType {
    Float,
    Double,
    UnsignedByte,
    UnsignedShort,
    UnsignedInt,
}

/// Re-export of rust-allocated (stack based) `IndexBufferFormat` struct
#[repr(C)]
pub enum AzIndexBufferFormat {
    Points,
    Lines,
    LineStrip,
    Triangles,
    TriangleStrip,
    TriangleFan,
}

/// Re-export of rust-allocated (stack based) `GlType` struct
#[repr(C)]
pub enum AzGlType {
    Gl,
    Gles,
}

/// C-ABI stable reexport of `&[u8]`
#[repr(C)]
pub struct AzU8VecRef {
    pub ptr: *const u8,
    pub len: usize,
}

/// C-ABI stable reexport of `&mut [u8]`
#[repr(C)]
pub struct AzU8VecRefMut {
    pub ptr: *mut u8,
    pub len: usize,
}

/// C-ABI stable reexport of `&[f32]`
#[repr(C)]
pub struct AzF32VecRef {
    pub ptr: *const f32,
    pub len: usize,
}

/// C-ABI stable reexport of `&[i32]`
#[repr(C)]
pub struct AzI32VecRef {
    pub ptr: *const i32,
    pub len: usize,
}

/// C-ABI stable reexport of `&[GLuint]` aka `&[u32]`
#[repr(C)]
pub struct AzGLuintVecRef {
    pub ptr: *const u32,
    pub len: usize,
}

/// C-ABI stable reexport of `&[GLenum]` aka `&[u32]`
#[repr(C)]
pub struct AzGLenumVecRef {
    pub ptr: *const u32,
    pub len: usize,
}

/// C-ABI stable reexport of `&mut [GLint]` aka `&mut [i32]`
#[repr(C)]
pub struct AzGLintVecRefMut {
    pub ptr: *mut i32,
    pub len: usize,
}

/// C-ABI stable reexport of `&mut [GLint64]` aka `&mut [i64]`
#[repr(C)]
pub struct AzGLint64VecRefMut {
    pub ptr: *mut i64,
    pub len: usize,
}

/// C-ABI stable reexport of `&mut [GLboolean]` aka `&mut [u8]`
#[repr(C)]
pub struct AzGLbooleanVecRefMut {
    pub ptr: *mut u8,
    pub len: usize,
}

/// C-ABI stable reexport of `&mut [GLfloat]` aka `&mut [f32]`
#[repr(C)]
pub struct AzGLfloatVecRefMut {
    pub ptr: *mut f32,
    pub len: usize,
}

/// C-ABI stable reexport of `&str`
#[repr(C)]
pub struct AzRefstr {
    pub ptr: *const u8,
    pub len: usize,
}

/// C-ABI stable reexport of `*const gleam::gl::GLsync`
#[repr(C)]
pub struct AzGLsyncPtr {
    pub ptr: *const c_void,
}

/// Re-export of rust-allocated (stack based) `TextureFlags` struct
#[repr(C)]
pub struct AzTextureFlags {
    pub is_opaque: bool,
    pub is_video_texture: bool,
}

/// Re-export of rust-allocated (stack based) `ImageRef` struct
#[repr(C)]
pub struct AzImageRef {
    pub data: *const c_void,
    pub copies: *const c_void,
}

/// Re-export of rust-allocated (stack based) `RawImageFormat` struct
#[repr(C)]
pub enum AzRawImageFormat {
    R8,
    RG8,
    RGB8,
    RGBA8,
    R16,
    RG16,
    RGB16,
    RGBA16,
    BGR8,
    BGRA8,
}

/// Re-export of rust-allocated (stack based) `EncodeImageError` struct
#[repr(C)]
pub enum AzEncodeImageError {
    EncoderNotAvailable,
    InsufficientMemory,
    DimensionError,
    InvalidData,
    Unknown,
}

/// Re-export of rust-allocated (stack based) `DecodeImageError` struct
#[repr(C)]
pub enum AzDecodeImageError {
    InsufficientMemory,
    DimensionError,
    UnsupportedImageFormat,
    Unknown,
}

/// `AzParsedFontDestructorFnType` struct
pub type AzParsedFontDestructorFnType = extern "C" fn(&mut c_void);

/// Atomically reference-counted parsed font data
#[repr(C)]
pub struct AzFontRef {
    pub data: *const c_void,
    pub copies: *const c_void,
}

/// Re-export of rust-allocated (stack based) `Svg` struct
#[repr(C)]
pub struct AzSvg {
    pub ptr: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `SvgXmlNode` struct
#[repr(C)]
pub struct AzSvgXmlNode {
    pub ptr: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `SvgCircle` struct
#[repr(C)]
pub struct AzSvgCircle {
    pub center_x: f32,
    pub center_y: f32,
    pub radius: f32,
}

/// Re-export of rust-allocated (stack based) `SvgPoint` struct
#[repr(C)]
pub struct AzSvgPoint {
    pub x: f32,
    pub y: f32,
}

/// Re-export of rust-allocated (stack based) `SvgRect` struct
#[repr(C)]
pub struct AzSvgRect {
    pub width: f32,
    pub height: f32,
    pub x: f32,
    pub y: f32,
    pub radius_top_left: f32,
    pub radius_top_right: f32,
    pub radius_bottom_left: f32,
    pub radius_bottom_right: f32,
}

/// Re-export of rust-allocated (stack based) `SvgVertex` struct
#[repr(C)]
pub struct AzSvgVertex {
    pub x: f32,
    pub y: f32,
}

/// Re-export of rust-allocated (stack based) `ShapeRendering` struct
#[repr(C)]
pub enum AzShapeRendering {
    OptimizeSpeed,
    CrispEdges,
    GeometricPrecision,
}

/// Re-export of rust-allocated (stack based) `TextRendering` struct
#[repr(C)]
pub enum AzTextRendering {
    OptimizeSpeed,
    OptimizeLegibility,
    GeometricPrecision,
}

/// Re-export of rust-allocated (stack based) `ImageRendering` struct
#[repr(C)]
pub enum AzImageRendering {
    OptimizeQuality,
    OptimizeSpeed,
}

/// Re-export of rust-allocated (stack based) `FontDatabase` struct
#[repr(C)]
pub enum AzFontDatabase {
    Empty,
    System,
}

/// Re-export of rust-allocated (stack based) `Indent` struct
#[repr(C, u8)]
pub enum AzIndent {
    None,
    Spaces(u8),
    Tabs,
}

/// Re-export of rust-allocated (stack based) `SvgFitTo` struct
#[repr(C, u8)]
pub enum AzSvgFitTo {
    Original,
    Width(u32),
    Height(u32),
    Zoom(f32),
}

/// Re-export of rust-allocated (stack based) `SvgFillRule` struct
#[repr(C)]
pub enum AzSvgFillRule {
    Winding,
    EvenOdd,
}

/// Re-export of rust-allocated (stack based) `SvgTransform` struct
#[repr(C)]
pub struct AzSvgTransform {
    pub sx: f32,
    pub kx: f32,
    pub ky: f32,
    pub sy: f32,
    pub tx: f32,
    pub ty: f32,
}

/// Re-export of rust-allocated (stack based) `SvgLineJoin` struct
#[repr(C)]
pub enum AzSvgLineJoin {
    Miter,
    MiterClip,
    Round,
    Bevel,
}

/// Re-export of rust-allocated (stack based) `SvgLineCap` struct
#[repr(C)]
pub enum AzSvgLineCap {
    Butt,
    Square,
    Round,
}

/// Re-export of rust-allocated (stack based) `SvgDashPattern` struct
#[repr(C)]
pub struct AzSvgDashPattern {
    pub offset: f32,
    pub length_1: f32,
    pub gap_1: f32,
    pub length_2: f32,
    pub gap_2: f32,
    pub length_3: f32,
    pub gap_3: f32,
}

/// Re-export of rust-allocated (stack based) `MsgBox` struct
#[repr(C)]
pub struct AzMsgBox {
    pub _reserved: usize,
}

/// Type of message box icon
#[repr(C)]
pub enum AzMsgBoxIcon {
    Info,
    Warning,
    Error,
    Question,
}

/// Value returned from a yes / no message box
#[repr(C)]
pub enum AzMsgBoxYesNo {
    Yes,
    No,
}

/// Value returned from an ok / cancel message box
#[repr(C)]
pub enum AzMsgBoxOkCancel {
    Ok,
    Cancel,
}

/// File picker dialog
#[repr(C)]
pub struct AzFileDialog {
    pub _reserved: usize,
}

/// Re-export of rust-allocated (stack based) `ColorPickerDialog` struct
#[repr(C)]
pub struct AzColorPickerDialog {
    pub _reserved: usize,
}

/// Connection to the system clipboard, on some systems this connection can be cached
#[repr(C)]
pub struct AzSystemClipboard {
    pub _native: *const c_void,
}

/// `AzInstantPtrCloneFnType` struct
pub type AzInstantPtrCloneFnType = extern "C" fn(&AzInstantPtr) -> AzInstantPtr;

/// Re-export of rust-allocated (stack based) `InstantPtrCloneFn` struct
#[repr(C)]
pub struct AzInstantPtrCloneFn {
    pub cb: AzInstantPtrCloneFnType,
}

/// `AzInstantPtrDestructorFnType` struct
pub type AzInstantPtrDestructorFnType = extern "C" fn(&mut AzInstantPtr);

/// Re-export of rust-allocated (stack based) `InstantPtrDestructorFn` struct
#[repr(C)]
pub struct AzInstantPtrDestructorFn {
    pub cb: AzInstantPtrDestructorFnType,
}

/// Re-export of rust-allocated (stack based) `SystemTick` struct
#[repr(C)]
pub struct AzSystemTick {
    pub tick_counter: u64,
}

/// Re-export of rust-allocated (stack based) `SystemTimeDiff` struct
#[repr(C)]
pub struct AzSystemTimeDiff {
    pub secs: u64,
    pub nanos: u32,
}

/// Re-export of rust-allocated (stack based) `SystemTickDiff` struct
#[repr(C)]
pub struct AzSystemTickDiff {
    pub tick_diff: u64,
}

/// Re-export of rust-allocated (stack based) `TimerId` struct
#[repr(C)]
pub struct AzTimerId {
    pub id: usize,
}

/// Should a timer terminate or not - used to remove active timers
#[repr(C)]
pub enum AzTerminateTimer {
    Terminate,
    Continue,
}

/// Re-export of rust-allocated (stack based) `ThreadId` struct
#[repr(C)]
pub struct AzThreadId {
    pub id: usize,
}

/// Re-export of rust-allocated (stack based) `Thread` struct
#[repr(C)]
pub struct AzThread {
    pub ptr: *const c_void,
}

/// Re-export of rust-allocated (stack based) `ThreadSender` struct
#[repr(C)]
pub struct AzThreadSender {
    pub ptr: *const c_void,
}

/// Re-export of rust-allocated (stack based) `ThreadReceiver` struct
#[repr(C)]
pub struct AzThreadReceiver {
    pub ptr: *const c_void,
}

/// `AzCreateThreadFnType` struct
pub type AzCreateThreadFnType = extern "C" fn(AzRefAny, AzRefAny, AzThreadCallback) -> AzThread;

/// Re-export of rust-allocated (stack based) `CreateThreadFn` struct
#[repr(C)]
pub struct AzCreateThreadFn {
    pub cb: AzCreateThreadFnType,
}

/// `AzGetSystemTimeFnType` struct
pub type AzGetSystemTimeFnType = extern "C" fn() -> AzInstant;

/// Get the current system time, equivalent to `std::time::Instant::now()`, except it also works on systems that work with "ticks" instead of timers
#[repr(C)]
pub struct AzGetSystemTimeFn {
    pub cb: AzGetSystemTimeFnType,
}

/// `AzCheckThreadFinishedFnType` struct
pub type AzCheckThreadFinishedFnType = extern "C" fn(&c_void) -> bool;

/// Function called to check if the thread has finished
#[repr(C)]
pub struct AzCheckThreadFinishedFn {
    pub cb: AzCheckThreadFinishedFnType,
}

/// `AzLibrarySendThreadMsgFnType` struct
pub type AzLibrarySendThreadMsgFnType = extern "C" fn(&c_void, AzThreadSendMsg) -> bool;

/// Function to send a message to the thread
#[repr(C)]
pub struct AzLibrarySendThreadMsgFn {
    pub cb: AzLibrarySendThreadMsgFnType,
}

/// `AzLibraryReceiveThreadMsgFnType` struct
pub type AzLibraryReceiveThreadMsgFnType = extern "C" fn(&c_void) -> AzOptionThreadReceiveMsg;

/// Function to receive a message from the thread
#[repr(C)]
pub struct AzLibraryReceiveThreadMsgFn {
    pub cb: AzLibraryReceiveThreadMsgFnType,
}

/// `AzThreadRecvFnType` struct
pub type AzThreadRecvFnType = extern "C" fn(&c_void) -> AzOptionThreadSendMsg;

/// Function that the running `Thread` can call to receive messages from the main UI thread
#[repr(C)]
pub struct AzThreadRecvFn {
    pub cb: AzThreadRecvFnType,
}

/// `AzThreadSendFnType` struct
pub type AzThreadSendFnType = extern "C" fn(&c_void, AzThreadReceiveMsg) -> bool;

/// Function that the running `Thread` can call to receive messages from the main UI thread
#[repr(C)]
pub struct AzThreadSendFn {
    pub cb: AzThreadSendFnType,
}

/// `AzThreadDestructorFnType` struct
pub type AzThreadDestructorFnType = extern "C" fn(&mut AzThread);

/// Destructor of the `Thread`
#[repr(C)]
pub struct AzThreadDestructorFn {
    pub cb: AzThreadDestructorFnType,
}

/// `AzThreadReceiverDestructorFnType` struct
pub type AzThreadReceiverDestructorFnType = extern "C" fn(&mut AzThreadReceiver);

/// Destructor of the `ThreadReceiver`
#[repr(C)]
pub struct AzThreadReceiverDestructorFn {
    pub cb: AzThreadReceiverDestructorFnType,
}

/// `AzThreadSenderDestructorFnType` struct
pub type AzThreadSenderDestructorFnType = extern "C" fn(&mut AzThreadSender);

/// Destructor of the `ThreadSender`
#[repr(C)]
pub struct AzThreadSenderDestructorFn {
    pub cb: AzThreadSenderDestructorFnType,
}

/// Re-export of rust-allocated (stack based) `StyleFontFamilyVecDestructor` struct
#[repr(C, u8)]
pub enum AzStyleFontFamilyVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStyleFontFamilyVecDestructorType),
}

/// `AzStyleFontFamilyVecDestructorType` struct
pub type AzStyleFontFamilyVecDestructorType = extern "C" fn(&mut AzStyleFontFamilyVec);

/// Re-export of rust-allocated (stack based) `LogicalRectVecDestructor` struct
#[repr(C, u8)]
pub enum AzLogicalRectVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzLogicalRectVecDestructorType),
}

/// `AzLogicalRectVecDestructorType` struct
pub type AzLogicalRectVecDestructorType = extern "C" fn(&mut AzLogicalRectVec);

/// Re-export of rust-allocated (stack based) `NodeTypeIdInfoMapVecDestructor` struct
#[repr(C, u8)]
pub enum AzNodeTypeIdInfoMapVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNodeTypeIdInfoMapVecDestructorType),
}

/// `AzNodeTypeIdInfoMapVecDestructorType` struct
pub type AzNodeTypeIdInfoMapVecDestructorType = extern "C" fn(&mut AzNodeTypeIdInfoMapVec);

/// Re-export of rust-allocated (stack based) `InputOutputTypeIdInfoMapVecDestructor` struct
#[repr(C, u8)]
pub enum AzInputOutputTypeIdInfoMapVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzInputOutputTypeIdInfoMapVecDestructorType),
}

/// `AzInputOutputTypeIdInfoMapVecDestructorType` struct
pub type AzInputOutputTypeIdInfoMapVecDestructorType = extern "C" fn(&mut AzInputOutputTypeIdInfoMapVec);

/// Re-export of rust-allocated (stack based) `NodeIdNodeMapVecDestructor` struct
#[repr(C, u8)]
pub enum AzNodeIdNodeMapVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNodeIdNodeMapVecDestructorType),
}

/// `AzNodeIdNodeMapVecDestructorType` struct
pub type AzNodeIdNodeMapVecDestructorType = extern "C" fn(&mut AzNodeIdNodeMapVec);

/// Re-export of rust-allocated (stack based) `InputOutputTypeIdVecDestructor` struct
#[repr(C, u8)]
pub enum AzInputOutputTypeIdVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzInputOutputTypeIdVecDestructorType),
}

/// `AzInputOutputTypeIdVecDestructorType` struct
pub type AzInputOutputTypeIdVecDestructorType = extern "C" fn(&mut AzInputOutputTypeIdVec);

/// Re-export of rust-allocated (stack based) `NodeTypeFieldVecDestructor` struct
#[repr(C, u8)]
pub enum AzNodeTypeFieldVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNodeTypeFieldVecDestructorType),
}

/// `AzNodeTypeFieldVecDestructorType` struct
pub type AzNodeTypeFieldVecDestructorType = extern "C" fn(&mut AzNodeTypeFieldVec);

/// Re-export of rust-allocated (stack based) `InputConnectionVecDestructor` struct
#[repr(C, u8)]
pub enum AzInputConnectionVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzInputConnectionVecDestructorType),
}

/// `AzInputConnectionVecDestructorType` struct
pub type AzInputConnectionVecDestructorType = extern "C" fn(&mut AzInputConnectionVec);

/// Re-export of rust-allocated (stack based) `OutputNodeAndIndexVecDestructor` struct
#[repr(C, u8)]
pub enum AzOutputNodeAndIndexVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzOutputNodeAndIndexVecDestructorType),
}

/// `AzOutputNodeAndIndexVecDestructorType` struct
pub type AzOutputNodeAndIndexVecDestructorType = extern "C" fn(&mut AzOutputNodeAndIndexVec);

/// Re-export of rust-allocated (stack based) `OutputConnectionVecDestructor` struct
#[repr(C, u8)]
pub enum AzOutputConnectionVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzOutputConnectionVecDestructorType),
}

/// `AzOutputConnectionVecDestructorType` struct
pub type AzOutputConnectionVecDestructorType = extern "C" fn(&mut AzOutputConnectionVec);

/// Re-export of rust-allocated (stack based) `InputNodeAndIndexVecDestructor` struct
#[repr(C, u8)]
pub enum AzInputNodeAndIndexVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzInputNodeAndIndexVecDestructorType),
}

/// `AzInputNodeAndIndexVecDestructorType` struct
pub type AzInputNodeAndIndexVecDestructorType = extern "C" fn(&mut AzInputNodeAndIndexVec);

/// Re-export of rust-allocated (stack based) `TabVecDestructor` struct
#[repr(C, u8)]
pub enum AzTabVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzTabVecDestructorType),
}

/// `AzTabVecDestructorType` struct
pub type AzTabVecDestructorType = extern "C" fn(&mut AzTabVec);

/// Re-export of rust-allocated (stack based) `AccessibilityStateVecDestructor` struct
#[repr(C, u8)]
pub enum AzAccessibilityStateVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzAccessibilityStateVecDestructorType),
}

/// `AzAccessibilityStateVecDestructorType` struct
pub type AzAccessibilityStateVecDestructorType = extern "C" fn(&mut AzAccessibilityStateVec);

/// Re-export of rust-allocated (stack based) `MenuItemVecDestructor` struct
#[repr(C, u8)]
pub enum AzMenuItemVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzMenuItemVecDestructorType),
}

/// `AzMenuItemVecDestructorType` struct
pub type AzMenuItemVecDestructorType = extern "C" fn(&mut AzMenuItemVec);

/// Re-export of rust-allocated (stack based) `TessellatedSvgNodeVecDestructor` struct
#[repr(C, u8)]
pub enum AzTessellatedSvgNodeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzTessellatedSvgNodeVecDestructorType),
}

/// `AzTessellatedSvgNodeVecDestructorType` struct
pub type AzTessellatedSvgNodeVecDestructorType = extern "C" fn(&mut AzTessellatedSvgNodeVec);

/// Re-export of rust-allocated (stack based) `XmlNodeVecDestructor` struct
#[repr(C, u8)]
pub enum AzXmlNodeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzXmlNodeVecDestructorType),
}

/// `AzXmlNodeVecDestructorType` struct
pub type AzXmlNodeVecDestructorType = extern "C" fn(&mut AzXmlNodeVec);

/// Re-export of rust-allocated (stack based) `FmtArgVecDestructor` struct
#[repr(C, u8)]
pub enum AzFmtArgVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzFmtArgVecDestructorType),
}

/// `AzFmtArgVecDestructorType` struct
pub type AzFmtArgVecDestructorType = extern "C" fn(&mut AzFmtArgVec);

/// Re-export of rust-allocated (stack based) `InlineLineVecDestructor` struct
#[repr(C, u8)]
pub enum AzInlineLineVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzInlineLineVecDestructorType),
}

/// `AzInlineLineVecDestructorType` struct
pub type AzInlineLineVecDestructorType = extern "C" fn(&mut AzInlineLineVec);

/// Re-export of rust-allocated (stack based) `InlineWordVecDestructor` struct
#[repr(C, u8)]
pub enum AzInlineWordVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzInlineWordVecDestructorType),
}

/// `AzInlineWordVecDestructorType` struct
pub type AzInlineWordVecDestructorType = extern "C" fn(&mut AzInlineWordVec);

/// Re-export of rust-allocated (stack based) `InlineGlyphVecDestructor` struct
#[repr(C, u8)]
pub enum AzInlineGlyphVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzInlineGlyphVecDestructorType),
}

/// `AzInlineGlyphVecDestructorType` struct
pub type AzInlineGlyphVecDestructorType = extern "C" fn(&mut AzInlineGlyphVec);

/// Re-export of rust-allocated (stack based) `InlineTextHitVecDestructor` struct
#[repr(C, u8)]
pub enum AzInlineTextHitVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzInlineTextHitVecDestructorType),
}

/// `AzInlineTextHitVecDestructorType` struct
pub type AzInlineTextHitVecDestructorType = extern "C" fn(&mut AzInlineTextHitVec);

/// Re-export of rust-allocated (stack based) `MonitorVecDestructor` struct
#[repr(C, u8)]
pub enum AzMonitorVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzMonitorVecDestructorType),
}

/// `AzMonitorVecDestructorType` struct
pub type AzMonitorVecDestructorType = extern "C" fn(&mut AzMonitorVec);

/// Re-export of rust-allocated (stack based) `VideoModeVecDestructor` struct
#[repr(C, u8)]
pub enum AzVideoModeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzVideoModeVecDestructorType),
}

/// `AzVideoModeVecDestructorType` struct
pub type AzVideoModeVecDestructorType = extern "C" fn(&mut AzVideoModeVec);

/// Re-export of rust-allocated (stack based) `DomVecDestructor` struct
#[repr(C, u8)]
pub enum AzDomVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzDomVecDestructorType),
}

/// `AzDomVecDestructorType` struct
pub type AzDomVecDestructorType = extern "C" fn(&mut AzDomVec);

/// Re-export of rust-allocated (stack based) `IdOrClassVecDestructor` struct
#[repr(C, u8)]
pub enum AzIdOrClassVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzIdOrClassVecDestructorType),
}

/// `AzIdOrClassVecDestructorType` struct
pub type AzIdOrClassVecDestructorType = extern "C" fn(&mut AzIdOrClassVec);

/// Re-export of rust-allocated (stack based) `NodeDataInlineCssPropertyVecDestructor` struct
#[repr(C, u8)]
pub enum AzNodeDataInlineCssPropertyVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNodeDataInlineCssPropertyVecDestructorType),
}

/// `AzNodeDataInlineCssPropertyVecDestructorType` struct
pub type AzNodeDataInlineCssPropertyVecDestructorType = extern "C" fn(&mut AzNodeDataInlineCssPropertyVec);

/// Re-export of rust-allocated (stack based) `StyleBackgroundContentVecDestructor` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundContentVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStyleBackgroundContentVecDestructorType),
}

/// `AzStyleBackgroundContentVecDestructorType` struct
pub type AzStyleBackgroundContentVecDestructorType = extern "C" fn(&mut AzStyleBackgroundContentVec);

/// Re-export of rust-allocated (stack based) `StyleBackgroundPositionVecDestructor` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundPositionVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStyleBackgroundPositionVecDestructorType),
}

/// `AzStyleBackgroundPositionVecDestructorType` struct
pub type AzStyleBackgroundPositionVecDestructorType = extern "C" fn(&mut AzStyleBackgroundPositionVec);

/// Re-export of rust-allocated (stack based) `StyleBackgroundRepeatVecDestructor` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundRepeatVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStyleBackgroundRepeatVecDestructorType),
}

/// `AzStyleBackgroundRepeatVecDestructorType` struct
pub type AzStyleBackgroundRepeatVecDestructorType = extern "C" fn(&mut AzStyleBackgroundRepeatVec);

/// Re-export of rust-allocated (stack based) `StyleBackgroundSizeVecDestructor` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundSizeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStyleBackgroundSizeVecDestructorType),
}

/// `AzStyleBackgroundSizeVecDestructorType` struct
pub type AzStyleBackgroundSizeVecDestructorType = extern "C" fn(&mut AzStyleBackgroundSizeVec);

/// Re-export of rust-allocated (stack based) `StyleTransformVecDestructor` struct
#[repr(C, u8)]
pub enum AzStyleTransformVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStyleTransformVecDestructorType),
}

/// `AzStyleTransformVecDestructorType` struct
pub type AzStyleTransformVecDestructorType = extern "C" fn(&mut AzStyleTransformVec);

/// Re-export of rust-allocated (stack based) `CssPropertyVecDestructor` struct
#[repr(C, u8)]
pub enum AzCssPropertyVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzCssPropertyVecDestructorType),
}

/// `AzCssPropertyVecDestructorType` struct
pub type AzCssPropertyVecDestructorType = extern "C" fn(&mut AzCssPropertyVec);

/// Re-export of rust-allocated (stack based) `SvgMultiPolygonVecDestructor` struct
#[repr(C, u8)]
pub enum AzSvgMultiPolygonVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzSvgMultiPolygonVecDestructorType),
}

/// `AzSvgMultiPolygonVecDestructorType` struct
pub type AzSvgMultiPolygonVecDestructorType = extern "C" fn(&mut AzSvgMultiPolygonVec);

/// Re-export of rust-allocated (stack based) `SvgPathVecDestructor` struct
#[repr(C, u8)]
pub enum AzSvgPathVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzSvgPathVecDestructorType),
}

/// `AzSvgPathVecDestructorType` struct
pub type AzSvgPathVecDestructorType = extern "C" fn(&mut AzSvgPathVec);

/// Re-export of rust-allocated (stack based) `VertexAttributeVecDestructor` struct
#[repr(C, u8)]
pub enum AzVertexAttributeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzVertexAttributeVecDestructorType),
}

/// `AzVertexAttributeVecDestructorType` struct
pub type AzVertexAttributeVecDestructorType = extern "C" fn(&mut AzVertexAttributeVec);

/// Re-export of rust-allocated (stack based) `SvgPathElementVecDestructor` struct
#[repr(C, u8)]
pub enum AzSvgPathElementVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzSvgPathElementVecDestructorType),
}

/// `AzSvgPathElementVecDestructorType` struct
pub type AzSvgPathElementVecDestructorType = extern "C" fn(&mut AzSvgPathElementVec);

/// Re-export of rust-allocated (stack based) `SvgVertexVecDestructor` struct
#[repr(C, u8)]
pub enum AzSvgVertexVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzSvgVertexVecDestructorType),
}

/// `AzSvgVertexVecDestructorType` struct
pub type AzSvgVertexVecDestructorType = extern "C" fn(&mut AzSvgVertexVec);

/// Re-export of rust-allocated (stack based) `U32VecDestructor` struct
#[repr(C, u8)]
pub enum AzU32VecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzU32VecDestructorType),
}

/// `AzU32VecDestructorType` struct
pub type AzU32VecDestructorType = extern "C" fn(&mut AzU32Vec);

/// Re-export of rust-allocated (stack based) `XWindowTypeVecDestructor` struct
#[repr(C, u8)]
pub enum AzXWindowTypeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzXWindowTypeVecDestructorType),
}

/// `AzXWindowTypeVecDestructorType` struct
pub type AzXWindowTypeVecDestructorType = extern "C" fn(&mut AzXWindowTypeVec);

/// Re-export of rust-allocated (stack based) `VirtualKeyCodeVecDestructor` struct
#[repr(C, u8)]
pub enum AzVirtualKeyCodeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzVirtualKeyCodeVecDestructorType),
}

/// `AzVirtualKeyCodeVecDestructorType` struct
pub type AzVirtualKeyCodeVecDestructorType = extern "C" fn(&mut AzVirtualKeyCodeVec);

/// Re-export of rust-allocated (stack based) `CascadeInfoVecDestructor` struct
#[repr(C, u8)]
pub enum AzCascadeInfoVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzCascadeInfoVecDestructorType),
}

/// `AzCascadeInfoVecDestructorType` struct
pub type AzCascadeInfoVecDestructorType = extern "C" fn(&mut AzCascadeInfoVec);

/// Re-export of rust-allocated (stack based) `ScanCodeVecDestructor` struct
#[repr(C, u8)]
pub enum AzScanCodeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzScanCodeVecDestructorType),
}

/// `AzScanCodeVecDestructorType` struct
pub type AzScanCodeVecDestructorType = extern "C" fn(&mut AzScanCodeVec);

/// Re-export of rust-allocated (stack based) `CssDeclarationVecDestructor` struct
#[repr(C, u8)]
pub enum AzCssDeclarationVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzCssDeclarationVecDestructorType),
}

/// `AzCssDeclarationVecDestructorType` struct
pub type AzCssDeclarationVecDestructorType = extern "C" fn(&mut AzCssDeclarationVec);

/// Re-export of rust-allocated (stack based) `CssPathSelectorVecDestructor` struct
#[repr(C, u8)]
pub enum AzCssPathSelectorVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzCssPathSelectorVecDestructorType),
}

/// `AzCssPathSelectorVecDestructorType` struct
pub type AzCssPathSelectorVecDestructorType = extern "C" fn(&mut AzCssPathSelectorVec);

/// Re-export of rust-allocated (stack based) `StylesheetVecDestructor` struct
#[repr(C, u8)]
pub enum AzStylesheetVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStylesheetVecDestructorType),
}

/// `AzStylesheetVecDestructorType` struct
pub type AzStylesheetVecDestructorType = extern "C" fn(&mut AzStylesheetVec);

/// Re-export of rust-allocated (stack based) `CssRuleBlockVecDestructor` struct
#[repr(C, u8)]
pub enum AzCssRuleBlockVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzCssRuleBlockVecDestructorType),
}

/// `AzCssRuleBlockVecDestructorType` struct
pub type AzCssRuleBlockVecDestructorType = extern "C" fn(&mut AzCssRuleBlockVec);

/// Re-export of rust-allocated (stack based) `F32VecDestructor` struct
#[repr(C, u8)]
pub enum AzF32VecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzF32VecDestructorType),
}

/// `AzF32VecDestructorType` struct
pub type AzF32VecDestructorType = extern "C" fn(&mut AzF32Vec);

/// Re-export of rust-allocated (stack based) `U16VecDestructor` struct
#[repr(C, u8)]
pub enum AzU16VecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzU16VecDestructorType),
}

/// `AzU16VecDestructorType` struct
pub type AzU16VecDestructorType = extern "C" fn(&mut AzU16Vec);

/// Re-export of rust-allocated (stack based) `U8VecDestructor` struct
#[repr(C, u8)]
pub enum AzU8VecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzU8VecDestructorType),
}

/// `AzU8VecDestructorType` struct
pub type AzU8VecDestructorType = extern "C" fn(&mut AzU8Vec);

/// Re-export of rust-allocated (stack based) `CallbackDataVecDestructor` struct
#[repr(C, u8)]
pub enum AzCallbackDataVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzCallbackDataVecDestructorType),
}

/// `AzCallbackDataVecDestructorType` struct
pub type AzCallbackDataVecDestructorType = extern "C" fn(&mut AzCallbackDataVec);

/// Re-export of rust-allocated (stack based) `DebugMessageVecDestructor` struct
#[repr(C, u8)]
pub enum AzDebugMessageVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzDebugMessageVecDestructorType),
}

/// `AzDebugMessageVecDestructorType` struct
pub type AzDebugMessageVecDestructorType = extern "C" fn(&mut AzDebugMessageVec);

/// Re-export of rust-allocated (stack based) `GLuintVecDestructor` struct
#[repr(C, u8)]
pub enum AzGLuintVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzGLuintVecDestructorType),
}

/// `AzGLuintVecDestructorType` struct
pub type AzGLuintVecDestructorType = extern "C" fn(&mut AzGLuintVec);

/// Re-export of rust-allocated (stack based) `GLintVecDestructor` struct
#[repr(C, u8)]
pub enum AzGLintVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzGLintVecDestructorType),
}

/// `AzGLintVecDestructorType` struct
pub type AzGLintVecDestructorType = extern "C" fn(&mut AzGLintVec);

/// Re-export of rust-allocated (stack based) `StringVecDestructor` struct
#[repr(C, u8)]
pub enum AzStringVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStringVecDestructorType),
}

/// `AzStringVecDestructorType` struct
pub type AzStringVecDestructorType = extern "C" fn(&mut AzStringVec);

/// Re-export of rust-allocated (stack based) `StringPairVecDestructor` struct
#[repr(C, u8)]
pub enum AzStringPairVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStringPairVecDestructorType),
}

/// `AzStringPairVecDestructorType` struct
pub type AzStringPairVecDestructorType = extern "C" fn(&mut AzStringPairVec);

/// Re-export of rust-allocated (stack based) `NormalizedLinearColorStopVecDestructor` struct
#[repr(C, u8)]
pub enum AzNormalizedLinearColorStopVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNormalizedLinearColorStopVecDestructorType),
}

/// `AzNormalizedLinearColorStopVecDestructorType` struct
pub type AzNormalizedLinearColorStopVecDestructorType = extern "C" fn(&mut AzNormalizedLinearColorStopVec);

/// Re-export of rust-allocated (stack based) `NormalizedRadialColorStopVecDestructor` struct
#[repr(C, u8)]
pub enum AzNormalizedRadialColorStopVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNormalizedRadialColorStopVecDestructorType),
}

/// `AzNormalizedRadialColorStopVecDestructorType` struct
pub type AzNormalizedRadialColorStopVecDestructorType = extern "C" fn(&mut AzNormalizedRadialColorStopVec);

/// Re-export of rust-allocated (stack based) `NodeIdVecDestructor` struct
#[repr(C, u8)]
pub enum AzNodeIdVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNodeIdVecDestructorType),
}

/// `AzNodeIdVecDestructorType` struct
pub type AzNodeIdVecDestructorType = extern "C" fn(&mut AzNodeIdVec);

/// Re-export of rust-allocated (stack based) `NodeHierarchyItemVecDestructor` struct
#[repr(C, u8)]
pub enum AzNodeHierarchyItemVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNodeHierarchyItemVecDestructorType),
}

/// `AzNodeHierarchyItemVecDestructorType` struct
pub type AzNodeHierarchyItemVecDestructorType = extern "C" fn(&mut AzNodeHierarchyItemVec);

/// Re-export of rust-allocated (stack based) `StyledNodeVecDestructor` struct
#[repr(C, u8)]
pub enum AzStyledNodeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStyledNodeVecDestructorType),
}

/// `AzStyledNodeVecDestructorType` struct
pub type AzStyledNodeVecDestructorType = extern "C" fn(&mut AzStyledNodeVec);

/// Re-export of rust-allocated (stack based) `TagIdToNodeIdMappingVecDestructor` struct
#[repr(C, u8)]
pub enum AzTagIdToNodeIdMappingVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzTagIdToNodeIdMappingVecDestructorType),
}

/// `AzTagIdToNodeIdMappingVecDestructorType` struct
pub type AzTagIdToNodeIdMappingVecDestructorType = extern "C" fn(&mut AzTagIdToNodeIdMappingVec);

/// Re-export of rust-allocated (stack based) `ParentWithNodeDepthVecDestructor` struct
#[repr(C, u8)]
pub enum AzParentWithNodeDepthVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzParentWithNodeDepthVecDestructorType),
}

/// `AzParentWithNodeDepthVecDestructorType` struct
pub type AzParentWithNodeDepthVecDestructorType = extern "C" fn(&mut AzParentWithNodeDepthVec);

/// Re-export of rust-allocated (stack based) `NodeDataVecDestructor` struct
#[repr(C, u8)]
pub enum AzNodeDataVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNodeDataVecDestructorType),
}

/// `AzNodeDataVecDestructorType` struct
pub type AzNodeDataVecDestructorType = extern "C" fn(&mut AzNodeDataVec);

/// Re-export of rust-allocated (stack based) `OptionI16` struct
#[repr(C, u8)]
pub enum AzOptionI16 {
    None,
    Some(i16),
}

/// Re-export of rust-allocated (stack based) `OptionU16` struct
#[repr(C, u8)]
pub enum AzOptionU16 {
    None,
    Some(u16),
}

/// Re-export of rust-allocated (stack based) `OptionU32` struct
#[repr(C, u8)]
pub enum AzOptionU32 {
    None,
    Some(u32),
}

/// Re-export of rust-allocated (stack based) `OptionHwndHandle` struct
#[repr(C, u8)]
pub enum AzOptionHwndHandle {
    None,
    Some(*mut c_void),
}

/// Re-export of rust-allocated (stack based) `OptionX11Visual` struct
#[repr(C, u8)]
pub enum AzOptionX11Visual {
    None,
    Some(*const c_void),
}

/// Re-export of rust-allocated (stack based) `OptionI32` struct
#[repr(C, u8)]
pub enum AzOptionI32 {
    None,
    Some(i32),
}

/// Re-export of rust-allocated (stack based) `OptionF32` struct
#[repr(C, u8)]
pub enum AzOptionF32 {
    None,
    Some(f32),
}

/// Option<char> but the char is a u32, for C FFI stability reasons
#[repr(C, u8)]
pub enum AzOptionChar {
    None,
    Some(u32),
}

/// Re-export of rust-allocated (stack based) `OptionUsize` struct
#[repr(C, u8)]
pub enum AzOptionUsize {
    None,
    Some(usize),
}

/// Re-export of rust-allocated (stack based) `SvgParseErrorPosition` struct
#[repr(C)]
pub struct AzSvgParseErrorPosition {
    pub row: u32,
    pub col: u32,
}

/// External system callbacks to get the system time or create / manage threads
#[repr(C)]
pub struct AzSystemCallbacks {
    pub create_thread_fn: AzCreateThreadFn,
    pub get_system_time_fn: AzGetSystemTimeFn,
}

/// Force a specific renderer: note that azul will **crash** on startup if the `RendererOptions` are not satisfied.
#[repr(C)]
pub struct AzRendererOptions {
    pub vsync: AzVsyncEnumWrapper,
    pub srgb: AzSrgbEnumWrapper,
    pub hw_accel: AzHwAccelerationEnumWrapper,
}

/// Represents a rectangle in physical pixels (integer units)
#[repr(C)]
pub struct AzLayoutRect {
    pub origin: AzLayoutPoint,
    pub size: AzLayoutSize,
}

/// Raw platform handle, for integration in / with other toolkits and custom non-azul window extensions
#[repr(C, u8)]
pub enum AzRawWindowHandle {
    IOS(AzIOSHandle),
    MacOS(AzMacOSHandle),
    Xlib(AzXlibHandle),
    Xcb(AzXcbHandle),
    Wayland(AzWaylandHandle),
    Windows(AzWindowsHandle),
    Web(AzWebHandle),
    Android(AzAndroidHandle),
    Unsupported,
}

/// Logical rectangle area (can differ based on HiDPI settings). Usually this is what you'd want for hit-testing and positioning elements.
#[repr(C)]
pub struct AzLogicalRect {
    pub origin: AzLogicalPosition,
    pub size: AzLogicalSize,
}

/// Symbolic accelerator key (ctrl, alt, shift)
#[repr(C, u8)]
pub enum AzAcceleratorKey {
    Ctrl,
    Alt,
    Shift,
    Key(AzVirtualKeyCode),
}

/// Boolean flags relating to the current window state
#[repr(C)]
pub struct AzWindowFlags {
    pub frame: AzWindowFrameEnumWrapper,
    pub is_about_to_close: bool,
    pub has_decorations: bool,
    pub is_visible: bool,
    pub is_always_on_top: bool,
    pub is_resizable: bool,
    pub has_focus: bool,
    pub has_extended_window_frame: bool,
    pub has_blur_behind_window: bool,
    pub smooth_scroll_enabled: bool,
    pub autotab_enabled: bool,
}

/// Current position of the mouse cursor, relative to the window. Set to `Uninitialized` on startup (gets initialized on the first frame).
#[repr(C, u8)]
pub enum AzCursorPosition {
    OutOfWindow,
    Uninitialized,
    InWindow(AzLogicalPosition),
}

/// Position of the top left corner of the window relative to the top left of the monitor
#[repr(C, u8)]
pub enum AzWindowPosition {
    Uninitialized,
    Initialized(AzPhysicalPositionI32),
}

/// Position of the virtual keyboard necessary to insert CJK characters
#[repr(C, u8)]
pub enum AzImePosition {
    Uninitialized,
    Initialized(AzLogicalPosition),
}

/// Describes a rendering configuration for a monitor
#[repr(C)]
pub struct AzVideoMode {
    pub size: AzLayoutSize,
    pub bit_depth: u16,
    pub refresh_rate: u16,
}

/// Combination of node ID + DOM ID, both together can identify a node
#[repr(C)]
pub struct AzDomNodeId {
    pub dom: AzDomId,
    pub node: AzNodeId,
}

/// Re-export of rust-allocated (stack based) `PositionInfo` struct
#[repr(C, u8)]
pub enum AzPositionInfo {
    Static(AzPositionInfoInner),
    Fixed(AzPositionInfoInner),
    Absolute(AzPositionInfoInner),
    Relative(AzPositionInfoInner),
}

/// Re-export of rust-allocated (stack based) `HidpiAdjustedBounds` struct
#[repr(C)]
pub struct AzHidpiAdjustedBounds {
    pub logical_size: AzLogicalSize,
    pub hidpi_factor: f32,
}

/// Re-export of rust-allocated (stack based) `InlineGlyph` struct
#[repr(C)]
pub struct AzInlineGlyph {
    pub bounds: AzLogicalRect,
    pub unicode_codepoint: AzOptionCharEnumWrapper,
    pub glyph_index: u32,
}

/// Re-export of rust-allocated (stack based) `InlineTextHit` struct
#[repr(C)]
pub struct AzInlineTextHit {
    pub unicode_codepoint: AzOptionCharEnumWrapper,
    pub hit_relative_to_inline_text: AzLogicalPosition,
    pub hit_relative_to_line: AzLogicalPosition,
    pub hit_relative_to_text_content: AzLogicalPosition,
    pub hit_relative_to_glyph: AzLogicalPosition,
    pub line_index_relative_to_text: usize,
    pub word_index_relative_to_text: usize,
    pub text_content_index_relative_to_text: usize,
    pub glyph_index_relative_to_text: usize,
    pub char_index_relative_to_text: usize,
    pub word_index_relative_to_line: usize,
    pub text_content_index_relative_to_line: usize,
    pub glyph_index_relative_to_line: usize,
    pub char_index_relative_to_line: usize,
    pub glyph_index_relative_to_word: usize,
    pub char_index_relative_to_word: usize,
}

/// Re-export of rust-allocated (stack based) `IFrameCallbackInfo` struct
#[repr(C)]
pub struct AzIFrameCallbackInfo {
    pub system_fonts: *const c_void,
    pub image_cache: *const c_void,
    pub window_theme: AzWindowThemeEnumWrapper,
    pub bounds: AzHidpiAdjustedBounds,
    pub scroll_size: AzLogicalSize,
    pub scroll_offset: AzLogicalPosition,
    pub virtual_scroll_size: AzLogicalSize,
    pub virtual_scroll_offset: AzLogicalPosition,
    pub _reserved_ref: *const c_void,
    pub _reserved_mut: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `TimerCallbackReturn` struct
#[repr(C)]
pub struct AzTimerCallbackReturn {
    pub should_update: AzUpdateEnumWrapper,
    pub should_terminate: AzTerminateTimerEnumWrapper,
}

/// RefAny is a reference-counted, opaque pointer, which stores a reference to a struct. `RefAny` can be up- and downcasted (this usually done via generics and can't be expressed in the Rust API)
#[repr(C)]
pub struct AzRefAny {
    pub _internal_ptr: *const c_void,
    pub sharing_info: AzRefCount,
    pub instance_id: u64,
}

/// Re-export of rust-allocated (stack based) `IFrameNode` struct
#[repr(C)]
pub struct AzIFrameNode {
    pub callback: AzIFrameCallback,
    pub data: AzRefAny,
}

/// Re-export of rust-allocated (stack based) `NotEventFilter` struct
#[repr(C, u8)]
pub enum AzNotEventFilter {
    Hover(AzHoverEventFilter),
    Focus(AzFocusEventFilter),
}

/// Similar to `dom.CallbackData`, stores some data + a callback to call when the menu is activated
#[repr(C)]
pub struct AzMenuCallback {
    pub callback: AzCallback,
    pub data: AzRefAny,
}

/// Icon of a menu entry
#[repr(C, u8)]
pub enum AzMenuItemIcon {
    Checkbox(bool),
    Image(AzImageRef),
}

/// Re-export of rust-allocated (stack based) `CssNthChildSelector` struct
#[repr(C, u8)]
pub enum AzCssNthChildSelector {
    Number(u32),
    Even,
    Odd,
    Pattern(AzCssNthChildPattern),
}

/// Re-export of rust-allocated (stack based) `PixelValue` struct
#[repr(C)]
pub struct AzPixelValue {
    pub metric: AzSizeMetricEnumWrapper,
    pub number: AzFloatValue,
}

/// Re-export of rust-allocated (stack based) `PixelValueNoPercent` struct
#[repr(C)]
pub struct AzPixelValueNoPercent {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBoxShadow` struct
#[repr(C)]
pub struct AzStyleBoxShadow {
    pub offset: [AzPixelValueNoPercent;2],
    pub color: AzColorU,
    pub blur_radius: AzPixelValueNoPercent,
    pub spread_radius: AzPixelValueNoPercent,
    pub clip_mode: AzBoxShadowClipModeEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `LayoutBottom` struct
#[repr(C)]
pub struct AzLayoutBottom {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutFlexGrow` struct
#[repr(C)]
pub struct AzLayoutFlexGrow {
    pub inner: AzFloatValue,
}

/// Re-export of rust-allocated (stack based) `LayoutFlexShrink` struct
#[repr(C)]
pub struct AzLayoutFlexShrink {
    pub inner: AzFloatValue,
}

/// Re-export of rust-allocated (stack based) `LayoutHeight` struct
#[repr(C)]
pub struct AzLayoutHeight {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutLeft` struct
#[repr(C)]
pub struct AzLayoutLeft {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutMarginBottom` struct
#[repr(C)]
pub struct AzLayoutMarginBottom {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutMarginLeft` struct
#[repr(C)]
pub struct AzLayoutMarginLeft {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutMarginRight` struct
#[repr(C)]
pub struct AzLayoutMarginRight {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutMarginTop` struct
#[repr(C)]
pub struct AzLayoutMarginTop {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutMaxHeight` struct
#[repr(C)]
pub struct AzLayoutMaxHeight {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutMaxWidth` struct
#[repr(C)]
pub struct AzLayoutMaxWidth {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutMinHeight` struct
#[repr(C)]
pub struct AzLayoutMinHeight {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutMinWidth` struct
#[repr(C)]
pub struct AzLayoutMinWidth {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutPaddingBottom` struct
#[repr(C)]
pub struct AzLayoutPaddingBottom {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutPaddingLeft` struct
#[repr(C)]
pub struct AzLayoutPaddingLeft {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutPaddingRight` struct
#[repr(C)]
pub struct AzLayoutPaddingRight {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutPaddingTop` struct
#[repr(C)]
pub struct AzLayoutPaddingTop {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutRight` struct
#[repr(C)]
pub struct AzLayoutRight {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutTop` struct
#[repr(C)]
pub struct AzLayoutTop {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutWidth` struct
#[repr(C)]
pub struct AzLayoutWidth {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `PercentageValue` struct
#[repr(C)]
pub struct AzPercentageValue {
    pub number: AzFloatValue,
}

/// Re-export of rust-allocated (stack based) `AngleValue` struct
#[repr(C)]
pub struct AzAngleValue {
    pub metric: AzAngleMetricEnumWrapper,
    pub number: AzFloatValue,
}

/// Re-export of rust-allocated (stack based) `NormalizedLinearColorStop` struct
#[repr(C)]
pub struct AzNormalizedLinearColorStop {
    pub offset: AzPercentageValue,
    pub color: AzColorU,
}

/// Re-export of rust-allocated (stack based) `NormalizedRadialColorStop` struct
#[repr(C)]
pub struct AzNormalizedRadialColorStop {
    pub offset: AzAngleValue,
    pub color: AzColorU,
}

/// Re-export of rust-allocated (stack based) `DirectionCorners` struct
#[repr(C)]
pub struct AzDirectionCorners {
    pub from: AzDirectionCornerEnumWrapper,
    pub to: AzDirectionCornerEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `Direction` struct
#[repr(C, u8)]
pub enum AzDirection {
    Angle(AzAngleValue),
    FromTo(AzDirectionCorners),
}

/// Re-export of rust-allocated (stack based) `BackgroundPositionHorizontal` struct
#[repr(C, u8)]
pub enum AzBackgroundPositionHorizontal {
    Left,
    Center,
    Right,
    Exact(AzPixelValue),
}

/// Re-export of rust-allocated (stack based) `BackgroundPositionVertical` struct
#[repr(C, u8)]
pub enum AzBackgroundPositionVertical {
    Top,
    Center,
    Bottom,
    Exact(AzPixelValue),
}

/// Re-export of rust-allocated (stack based) `StyleBackgroundPosition` struct
#[repr(C)]
pub struct AzStyleBackgroundPosition {
    pub horizontal: AzBackgroundPositionHorizontalEnumWrapper,
    pub vertical: AzBackgroundPositionVerticalEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `StyleBackgroundSize` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundSize {
    ExactSize([AzPixelValue;2]),
    Contain,
    Cover,
}

/// Re-export of rust-allocated (stack based) `StyleBorderBottomColor` struct
#[repr(C)]
pub struct AzStyleBorderBottomColor {
    pub inner: AzColorU,
}

/// Re-export of rust-allocated (stack based) `StyleBorderBottomLeftRadius` struct
#[repr(C)]
pub struct AzStyleBorderBottomLeftRadius {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBorderBottomRightRadius` struct
#[repr(C)]
pub struct AzStyleBorderBottomRightRadius {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBorderBottomStyle` struct
#[repr(C)]
pub struct AzStyleBorderBottomStyle {
    pub inner: AzBorderStyleEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `LayoutBorderBottomWidth` struct
#[repr(C)]
pub struct AzLayoutBorderBottomWidth {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBorderLeftColor` struct
#[repr(C)]
pub struct AzStyleBorderLeftColor {
    pub inner: AzColorU,
}

/// Re-export of rust-allocated (stack based) `StyleBorderLeftStyle` struct
#[repr(C)]
pub struct AzStyleBorderLeftStyle {
    pub inner: AzBorderStyleEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `LayoutBorderLeftWidth` struct
#[repr(C)]
pub struct AzLayoutBorderLeftWidth {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBorderRightColor` struct
#[repr(C)]
pub struct AzStyleBorderRightColor {
    pub inner: AzColorU,
}

/// Re-export of rust-allocated (stack based) `StyleBorderRightStyle` struct
#[repr(C)]
pub struct AzStyleBorderRightStyle {
    pub inner: AzBorderStyleEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `LayoutBorderRightWidth` struct
#[repr(C)]
pub struct AzLayoutBorderRightWidth {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBorderTopColor` struct
#[repr(C)]
pub struct AzStyleBorderTopColor {
    pub inner: AzColorU,
}

/// Re-export of rust-allocated (stack based) `StyleBorderTopLeftRadius` struct
#[repr(C)]
pub struct AzStyleBorderTopLeftRadius {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBorderTopRightRadius` struct
#[repr(C)]
pub struct AzStyleBorderTopRightRadius {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBorderTopStyle` struct
#[repr(C)]
pub struct AzStyleBorderTopStyle {
    pub inner: AzBorderStyleEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `LayoutBorderTopWidth` struct
#[repr(C)]
pub struct AzLayoutBorderTopWidth {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleFontSize` struct
#[repr(C)]
pub struct AzStyleFontSize {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleLetterSpacing` struct
#[repr(C)]
pub struct AzStyleLetterSpacing {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleLineHeight` struct
#[repr(C)]
pub struct AzStyleLineHeight {
    pub inner: AzPercentageValue,
}

/// Re-export of rust-allocated (stack based) `StyleTabWidth` struct
#[repr(C)]
pub struct AzStyleTabWidth {
    pub inner: AzPercentageValue,
}

/// Re-export of rust-allocated (stack based) `StyleOpacity` struct
#[repr(C)]
pub struct AzStyleOpacity {
    pub inner: AzPercentageValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformOrigin` struct
#[repr(C)]
pub struct AzStyleTransformOrigin {
    pub x: AzPixelValue,
    pub y: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StylePerspectiveOrigin` struct
#[repr(C)]
pub struct AzStylePerspectiveOrigin {
    pub x: AzPixelValue,
    pub y: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformMatrix2D` struct
#[repr(C)]
pub struct AzStyleTransformMatrix2D {
    pub a: AzPixelValue,
    pub b: AzPixelValue,
    pub c: AzPixelValue,
    pub d: AzPixelValue,
    pub tx: AzPixelValue,
    pub ty: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformMatrix3D` struct
#[repr(C)]
pub struct AzStyleTransformMatrix3D {
    pub m11: AzPixelValue,
    pub m12: AzPixelValue,
    pub m13: AzPixelValue,
    pub m14: AzPixelValue,
    pub m21: AzPixelValue,
    pub m22: AzPixelValue,
    pub m23: AzPixelValue,
    pub m24: AzPixelValue,
    pub m31: AzPixelValue,
    pub m32: AzPixelValue,
    pub m33: AzPixelValue,
    pub m34: AzPixelValue,
    pub m41: AzPixelValue,
    pub m42: AzPixelValue,
    pub m43: AzPixelValue,
    pub m44: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformTranslate2D` struct
#[repr(C)]
pub struct AzStyleTransformTranslate2D {
    pub x: AzPixelValue,
    pub y: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformTranslate3D` struct
#[repr(C)]
pub struct AzStyleTransformTranslate3D {
    pub x: AzPixelValue,
    pub y: AzPixelValue,
    pub z: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformRotate3D` struct
#[repr(C)]
pub struct AzStyleTransformRotate3D {
    pub x: AzPercentageValue,
    pub y: AzPercentageValue,
    pub z: AzPercentageValue,
    pub angle: AzAngleValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformScale2D` struct
#[repr(C)]
pub struct AzStyleTransformScale2D {
    pub x: AzPercentageValue,
    pub y: AzPercentageValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformScale3D` struct
#[repr(C)]
pub struct AzStyleTransformScale3D {
    pub x: AzPercentageValue,
    pub y: AzPercentageValue,
    pub z: AzPercentageValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformSkew2D` struct
#[repr(C)]
pub struct AzStyleTransformSkew2D {
    pub x: AzPercentageValue,
    pub y: AzPercentageValue,
}

/// Re-export of rust-allocated (stack based) `StyleTextColor` struct
#[repr(C)]
pub struct AzStyleTextColor {
    pub inner: AzColorU,
}

/// Re-export of rust-allocated (stack based) `StyleWordSpacing` struct
#[repr(C)]
pub struct AzStyleWordSpacing {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBoxShadowValue` struct
#[repr(C, u8)]
pub enum AzStyleBoxShadowValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBoxShadow),
}

/// Re-export of rust-allocated (stack based) `LayoutAlignContentValue` struct
#[repr(C, u8)]
pub enum AzLayoutAlignContentValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutAlignContent),
}

/// Re-export of rust-allocated (stack based) `LayoutAlignItemsValue` struct
#[repr(C, u8)]
pub enum AzLayoutAlignItemsValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutAlignItems),
}

/// Re-export of rust-allocated (stack based) `LayoutBottomValue` struct
#[repr(C, u8)]
pub enum AzLayoutBottomValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutBottom),
}

/// Re-export of rust-allocated (stack based) `LayoutBoxSizingValue` struct
#[repr(C, u8)]
pub enum AzLayoutBoxSizingValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutBoxSizing),
}

/// Re-export of rust-allocated (stack based) `LayoutFlexDirectionValue` struct
#[repr(C, u8)]
pub enum AzLayoutFlexDirectionValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutFlexDirection),
}

/// Re-export of rust-allocated (stack based) `LayoutDisplayValue` struct
#[repr(C, u8)]
pub enum AzLayoutDisplayValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutDisplay),
}

/// Re-export of rust-allocated (stack based) `LayoutFlexGrowValue` struct
#[repr(C, u8)]
pub enum AzLayoutFlexGrowValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutFlexGrow),
}

/// Re-export of rust-allocated (stack based) `LayoutFlexShrinkValue` struct
#[repr(C, u8)]
pub enum AzLayoutFlexShrinkValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutFlexShrink),
}

/// Re-export of rust-allocated (stack based) `LayoutFloatValue` struct
#[repr(C, u8)]
pub enum AzLayoutFloatValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutFloat),
}

/// Re-export of rust-allocated (stack based) `LayoutHeightValue` struct
#[repr(C, u8)]
pub enum AzLayoutHeightValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutHeight),
}

/// Re-export of rust-allocated (stack based) `LayoutJustifyContentValue` struct
#[repr(C, u8)]
pub enum AzLayoutJustifyContentValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutJustifyContent),
}

/// Re-export of rust-allocated (stack based) `LayoutLeftValue` struct
#[repr(C, u8)]
pub enum AzLayoutLeftValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutLeft),
}

/// Re-export of rust-allocated (stack based) `LayoutMarginBottomValue` struct
#[repr(C, u8)]
pub enum AzLayoutMarginBottomValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutMarginBottom),
}

/// Re-export of rust-allocated (stack based) `LayoutMarginLeftValue` struct
#[repr(C, u8)]
pub enum AzLayoutMarginLeftValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutMarginLeft),
}

/// Re-export of rust-allocated (stack based) `LayoutMarginRightValue` struct
#[repr(C, u8)]
pub enum AzLayoutMarginRightValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutMarginRight),
}

/// Re-export of rust-allocated (stack based) `LayoutMarginTopValue` struct
#[repr(C, u8)]
pub enum AzLayoutMarginTopValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutMarginTop),
}

/// Re-export of rust-allocated (stack based) `LayoutMaxHeightValue` struct
#[repr(C, u8)]
pub enum AzLayoutMaxHeightValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutMaxHeight),
}

/// Re-export of rust-allocated (stack based) `LayoutMaxWidthValue` struct
#[repr(C, u8)]
pub enum AzLayoutMaxWidthValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutMaxWidth),
}

/// Re-export of rust-allocated (stack based) `LayoutMinHeightValue` struct
#[repr(C, u8)]
pub enum AzLayoutMinHeightValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutMinHeight),
}

/// Re-export of rust-allocated (stack based) `LayoutMinWidthValue` struct
#[repr(C, u8)]
pub enum AzLayoutMinWidthValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutMinWidth),
}

/// Re-export of rust-allocated (stack based) `LayoutPaddingBottomValue` struct
#[repr(C, u8)]
pub enum AzLayoutPaddingBottomValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutPaddingBottom),
}

/// Re-export of rust-allocated (stack based) `LayoutPaddingLeftValue` struct
#[repr(C, u8)]
pub enum AzLayoutPaddingLeftValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutPaddingLeft),
}

/// Re-export of rust-allocated (stack based) `LayoutPaddingRightValue` struct
#[repr(C, u8)]
pub enum AzLayoutPaddingRightValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutPaddingRight),
}

/// Re-export of rust-allocated (stack based) `LayoutPaddingTopValue` struct
#[repr(C, u8)]
pub enum AzLayoutPaddingTopValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutPaddingTop),
}

/// Re-export of rust-allocated (stack based) `LayoutPositionValue` struct
#[repr(C, u8)]
pub enum AzLayoutPositionValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutPosition),
}

/// Re-export of rust-allocated (stack based) `LayoutRightValue` struct
#[repr(C, u8)]
pub enum AzLayoutRightValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutRight),
}

/// Re-export of rust-allocated (stack based) `LayoutTopValue` struct
#[repr(C, u8)]
pub enum AzLayoutTopValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutTop),
}

/// Re-export of rust-allocated (stack based) `LayoutWidthValue` struct
#[repr(C, u8)]
pub enum AzLayoutWidthValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutWidth),
}

/// Re-export of rust-allocated (stack based) `LayoutFlexWrapValue` struct
#[repr(C, u8)]
pub enum AzLayoutFlexWrapValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutFlexWrap),
}

/// Re-export of rust-allocated (stack based) `LayoutOverflowValue` struct
#[repr(C, u8)]
pub enum AzLayoutOverflowValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutOverflow),
}

/// Re-export of rust-allocated (stack based) `StyleBorderBottomColorValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderBottomColorValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderBottomColor),
}

/// Re-export of rust-allocated (stack based) `StyleBorderBottomLeftRadiusValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderBottomLeftRadiusValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderBottomLeftRadius),
}

/// Re-export of rust-allocated (stack based) `StyleBorderBottomRightRadiusValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderBottomRightRadiusValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderBottomRightRadius),
}

/// Re-export of rust-allocated (stack based) `StyleBorderBottomStyleValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderBottomStyleValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderBottomStyle),
}

/// Re-export of rust-allocated (stack based) `LayoutBorderBottomWidthValue` struct
#[repr(C, u8)]
pub enum AzLayoutBorderBottomWidthValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutBorderBottomWidth),
}

/// Re-export of rust-allocated (stack based) `StyleBorderLeftColorValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderLeftColorValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderLeftColor),
}

/// Re-export of rust-allocated (stack based) `StyleBorderLeftStyleValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderLeftStyleValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderLeftStyle),
}

/// Re-export of rust-allocated (stack based) `LayoutBorderLeftWidthValue` struct
#[repr(C, u8)]
pub enum AzLayoutBorderLeftWidthValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutBorderLeftWidth),
}

/// Re-export of rust-allocated (stack based) `StyleBorderRightColorValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderRightColorValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderRightColor),
}

/// Re-export of rust-allocated (stack based) `StyleBorderRightStyleValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderRightStyleValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderRightStyle),
}

/// Re-export of rust-allocated (stack based) `LayoutBorderRightWidthValue` struct
#[repr(C, u8)]
pub enum AzLayoutBorderRightWidthValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutBorderRightWidth),
}

/// Re-export of rust-allocated (stack based) `StyleBorderTopColorValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderTopColorValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderTopColor),
}

/// Re-export of rust-allocated (stack based) `StyleBorderTopLeftRadiusValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderTopLeftRadiusValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderTopLeftRadius),
}

/// Re-export of rust-allocated (stack based) `StyleBorderTopRightRadiusValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderTopRightRadiusValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderTopRightRadius),
}

/// Re-export of rust-allocated (stack based) `StyleBorderTopStyleValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderTopStyleValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderTopStyle),
}

/// Re-export of rust-allocated (stack based) `LayoutBorderTopWidthValue` struct
#[repr(C, u8)]
pub enum AzLayoutBorderTopWidthValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutBorderTopWidth),
}

/// Re-export of rust-allocated (stack based) `StyleCursorValue` struct
#[repr(C, u8)]
pub enum AzStyleCursorValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleCursor),
}

/// Re-export of rust-allocated (stack based) `StyleFontSizeValue` struct
#[repr(C, u8)]
pub enum AzStyleFontSizeValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleFontSize),
}

/// Re-export of rust-allocated (stack based) `StyleLetterSpacingValue` struct
#[repr(C, u8)]
pub enum AzStyleLetterSpacingValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleLetterSpacing),
}

/// Re-export of rust-allocated (stack based) `StyleLineHeightValue` struct
#[repr(C, u8)]
pub enum AzStyleLineHeightValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleLineHeight),
}

/// Re-export of rust-allocated (stack based) `StyleTabWidthValue` struct
#[repr(C, u8)]
pub enum AzStyleTabWidthValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleTabWidth),
}

/// Re-export of rust-allocated (stack based) `StyleTextAlignValue` struct
#[repr(C, u8)]
pub enum AzStyleTextAlignValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleTextAlign),
}

/// Re-export of rust-allocated (stack based) `StyleTextColorValue` struct
#[repr(C, u8)]
pub enum AzStyleTextColorValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleTextColor),
}

/// Re-export of rust-allocated (stack based) `StyleWordSpacingValue` struct
#[repr(C, u8)]
pub enum AzStyleWordSpacingValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleWordSpacing),
}

/// Re-export of rust-allocated (stack based) `StyleOpacityValue` struct
#[repr(C, u8)]
pub enum AzStyleOpacityValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleOpacity),
}

/// Re-export of rust-allocated (stack based) `StyleTransformOriginValue` struct
#[repr(C, u8)]
pub enum AzStyleTransformOriginValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleTransformOrigin),
}

/// Re-export of rust-allocated (stack based) `StylePerspectiveOriginValue` struct
#[repr(C, u8)]
pub enum AzStylePerspectiveOriginValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStylePerspectiveOrigin),
}

/// Re-export of rust-allocated (stack based) `StyleBackfaceVisibilityValue` struct
#[repr(C, u8)]
pub enum AzStyleBackfaceVisibilityValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBackfaceVisibility),
}

/// Re-export of rust-allocated (stack based) `ButtonOnClick` struct
#[repr(C)]
pub struct AzButtonOnClick {
    pub data: AzRefAny,
    pub callback: AzCallback,
}

/// Re-export of rust-allocated (stack based) `CheckBoxOnToggle` struct
#[repr(C)]
pub struct AzCheckBoxOnToggle {
    pub data: AzRefAny,
    pub callback: AzCheckBoxOnToggleCallback,
}

/// Re-export of rust-allocated (stack based) `ColorInputState` struct
#[repr(C)]
pub struct AzColorInputState {
    pub color: AzColorU,
}

/// Re-export of rust-allocated (stack based) `ColorInputOnValueChange` struct
#[repr(C)]
pub struct AzColorInputOnValueChange {
    pub data: AzRefAny,
    pub callback: AzColorInputOnValueChangeCallback,
}

/// Re-export of rust-allocated (stack based) `TextInputSelection` struct
#[repr(C, u8)]
pub enum AzTextInputSelection {
    All,
    FromTo(AzTextInputSelectionRange),
}

/// Re-export of rust-allocated (stack based) `TextInputOnTextInput` struct
#[repr(C)]
pub struct AzTextInputOnTextInput {
    pub data: AzRefAny,
    pub callback: AzTextInputOnTextInputCallback,
}

/// Re-export of rust-allocated (stack based) `TextInputOnVirtualKeyDown` struct
#[repr(C)]
pub struct AzTextInputOnVirtualKeyDown {
    pub data: AzRefAny,
    pub callback: AzTextInputOnVirtualKeyDownCallback,
}

/// Re-export of rust-allocated (stack based) `TextInputOnFocusLost` struct
#[repr(C)]
pub struct AzTextInputOnFocusLost {
    pub data: AzRefAny,
    pub callback: AzTextInputOnFocusLostCallback,
}

/// Re-export of rust-allocated (stack based) `OnTextInputReturn` struct
#[repr(C)]
pub struct AzOnTextInputReturn {
    pub update: AzUpdateEnumWrapper,
    pub valid: AzTextInputValidEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `NumberInputOnValueChange` struct
#[repr(C)]
pub struct AzNumberInputOnValueChange {
    pub data: AzRefAny,
    pub callback: AzNumberInputOnValueChangeCallback,
}

/// Re-export of rust-allocated (stack based) `NumberInputOnFocusLost` struct
#[repr(C)]
pub struct AzNumberInputOnFocusLost {
    pub data: AzRefAny,
    pub callback: AzNumberInputOnFocusLostCallback,
}

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeAdded` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeAdded {
    pub data: AzRefAny,
    pub callback: AzNodeGraphOnNodeAddedCallback,
}

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeRemoved` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeRemoved {
    pub data: AzRefAny,
    pub callback: AzNodeGraphOnNodeRemovedCallback,
}

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeGraphDragged` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeGraphDragged {
    pub data: AzRefAny,
    pub callback: AzNodeGraphOnNodeGraphDraggedCallback,
}

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeDragged` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeDragged {
    pub data: AzRefAny,
    pub callback: AzNodeGraphOnNodeDraggedCallback,
}

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeConnected` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeConnected {
    pub data: AzRefAny,
    pub callback: AzNodeGraphOnNodeConnectedCallback,
}

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeInputDisconnected` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeInputDisconnected {
    pub data: AzRefAny,
    pub callback: AzNodeGraphOnNodeInputDisconnectedCallback,
}

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeOutputDisconnected` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeOutputDisconnected {
    pub data: AzRefAny,
    pub callback: AzNodeGraphOnNodeOutputDisconnectedCallback,
}

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeFieldEdited` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeFieldEdited {
    pub data: AzRefAny,
    pub callback: AzNodeGraphOnNodeFieldEditedCallback,
}

/// Re-export of rust-allocated (stack based) `OutputNodeAndIndex` struct
#[repr(C)]
pub struct AzOutputNodeAndIndex {
    pub node_id: AzNodeGraphNodeId,
    pub output_index: usize,
}

/// Re-export of rust-allocated (stack based) `InputNodeAndIndex` struct
#[repr(C)]
pub struct AzInputNodeAndIndex {
    pub node_id: AzNodeGraphNodeId,
    pub input_index: usize,
}

/// Re-export of rust-allocated (stack based) `DropDownOnChoiceChange` struct
#[repr(C)]
pub struct AzDropDownOnChoiceChange {
    pub data: AzRefAny,
    pub callback: AzDropDownOnChoiceChangeCallback,
}

/// Re-export of rust-allocated (stack based) `ParentWithNodeDepth` struct
#[repr(C)]
pub struct AzParentWithNodeDepth {
    pub depth: usize,
    pub node_id: AzNodeId,
}

/// Re-export of rust-allocated (stack based) `Gl` struct
#[repr(C)]
pub struct AzGl {
    pub ptr: *const c_void,
    pub renderer_type: AzRendererTypeEnumWrapper,
}

/// C-ABI stable reexport of `&[Refstr]` aka `&mut [&str]`
#[repr(C)]
pub struct AzRefstrVecRef {
    pub(crate) ptr: *const AzRefstr,
    pub len: usize,
}

/// Re-export of rust-allocated (stack based) `ImageMask` struct
#[repr(C)]
pub struct AzImageMask {
    pub image: AzImageRef,
    pub rect: AzLogicalRect,
    pub repeat: bool,
}

/// Re-export of rust-allocated (stack based) `FontMetrics` struct
#[repr(C)]
pub struct AzFontMetrics {
    pub units_per_em: u16,
    pub font_flags: u16,
    pub x_min: i16,
    pub y_min: i16,
    pub x_max: i16,
    pub y_max: i16,
    pub ascender: i16,
    pub descender: i16,
    pub line_gap: i16,
    pub advance_width_max: u16,
    pub min_left_side_bearing: i16,
    pub min_right_side_bearing: i16,
    pub x_max_extent: i16,
    pub caret_slope_rise: i16,
    pub caret_slope_run: i16,
    pub caret_offset: i16,
    pub num_h_metrics: u16,
    pub x_avg_char_width: i16,
    pub us_weight_class: u16,
    pub us_width_class: u16,
    pub fs_type: u16,
    pub y_subscript_x_size: i16,
    pub y_subscript_y_size: i16,
    pub y_subscript_x_offset: i16,
    pub y_subscript_y_offset: i16,
    pub y_superscript_x_size: i16,
    pub y_superscript_y_size: i16,
    pub y_superscript_x_offset: i16,
    pub y_superscript_y_offset: i16,
    pub y_strikeout_size: i16,
    pub y_strikeout_position: i16,
    pub s_family_class: i16,
    pub panose: [u8; 10],
    pub ul_unicode_range1: u32,
    pub ul_unicode_range2: u32,
    pub ul_unicode_range3: u32,
    pub ul_unicode_range4: u32,
    pub ach_vend_id: u32,
    pub fs_selection: u16,
    pub us_first_char_index: u16,
    pub us_last_char_index: u16,
    pub s_typo_ascender: AzOptionI16EnumWrapper,
    pub s_typo_descender: AzOptionI16EnumWrapper,
    pub s_typo_line_gap: AzOptionI16EnumWrapper,
    pub us_win_ascent: AzOptionU16EnumWrapper,
    pub us_win_descent: AzOptionU16EnumWrapper,
    pub ul_code_page_range1: AzOptionU32EnumWrapper,
    pub ul_code_page_range2: AzOptionU32EnumWrapper,
    pub sx_height: AzOptionI16EnumWrapper,
    pub s_cap_height: AzOptionI16EnumWrapper,
    pub us_default_char: AzOptionU16EnumWrapper,
    pub us_break_char: AzOptionU16EnumWrapper,
    pub us_max_context: AzOptionU16EnumWrapper,
    pub us_lower_optical_point_size: AzOptionU16EnumWrapper,
    pub us_upper_optical_point_size: AzOptionU16EnumWrapper,
}

/// Re-export of rust-allocated (stack based) `SvgLine` struct
#[repr(C)]
pub struct AzSvgLine {
    pub start: AzSvgPoint,
    pub end: AzSvgPoint,
}

/// Re-export of rust-allocated (stack based) `SvgQuadraticCurve` struct
#[repr(C)]
pub struct AzSvgQuadraticCurve {
    pub start: AzSvgPoint,
    pub ctrl: AzSvgPoint,
    pub end: AzSvgPoint,
}

/// Re-export of rust-allocated (stack based) `SvgCubicCurve` struct
#[repr(C)]
pub struct AzSvgCubicCurve {
    pub start: AzSvgPoint,
    pub ctrl_1: AzSvgPoint,
    pub ctrl_2: AzSvgPoint,
    pub end: AzSvgPoint,
}

/// Re-export of rust-allocated (stack based) `SvgStringFormatOptions` struct
#[repr(C)]
pub struct AzSvgStringFormatOptions {
    pub use_single_quote: bool,
    pub indent: AzIndentEnumWrapper,
    pub attributes_indent: AzIndentEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `SvgFillStyle` struct
#[repr(C)]
pub struct AzSvgFillStyle {
    pub line_join: AzSvgLineJoinEnumWrapper,
    pub miter_limit: f32,
    pub tolerance: f32,
    pub fill_rule: AzSvgFillRuleEnumWrapper,
    pub transform: AzSvgTransform,
    pub anti_alias: bool,
    pub high_quality_aa: bool,
}

/// Re-export of rust-allocated (stack based) `InstantPtr` struct
#[repr(C)]
pub struct AzInstantPtr {
    pub ptr: *const c_void,
    pub clone_fn: AzInstantPtrCloneFn,
    pub destructor: AzInstantPtrDestructorFn,
}

/// Re-export of rust-allocated (stack based) `Duration` struct
#[repr(C, u8)]
pub enum AzDuration {
    System(AzSystemTimeDiff),
    Tick(AzSystemTickDiff),
}

/// Re-export of rust-allocated (stack based) `ThreadSendMsg` struct
#[repr(C, u8)]
pub enum AzThreadSendMsg {
    TerminateThread,
    Tick,
    Custom(AzRefAny),
}

/// Re-export of rust-allocated (stack based) `ThreadWriteBackMsg` struct
#[repr(C)]
pub struct AzThreadWriteBackMsg {
    pub data: AzRefAny,
    pub callback: AzWriteBackCallback,
}

/// Wrapper over a Rust-allocated `Vec<LogicalRect>`
#[repr(C)]
pub struct AzLogicalRectVec {
    pub(crate) ptr: *const AzLogicalRect,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzLogicalRectVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<InputOutputTypeId>`
#[repr(C)]
pub struct AzInputOutputTypeIdVec {
    pub(crate) ptr: *const AzInputOutputTypeId,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzInputOutputTypeIdVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<OutputNodeAndIndex>`
#[repr(C)]
pub struct AzOutputNodeAndIndexVec {
    pub(crate) ptr: *const AzOutputNodeAndIndex,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzOutputNodeAndIndexVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<InputNodeAndIndex>`
#[repr(C)]
pub struct AzInputNodeAndIndexVec {
    pub(crate) ptr: *const AzInputNodeAndIndex,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzInputNodeAndIndexVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<AccessibilityState>`
#[repr(C)]
pub struct AzAccessibilityStateVec {
    pub(crate) ptr: *const AzAccessibilityStateEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzAccessibilityStateVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<MenuItem>`
#[repr(C)]
pub struct AzMenuItemVec {
    pub(crate) ptr: *const AzMenuItemEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzMenuItemVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<XmlNode>`
#[repr(C)]
pub struct AzXmlNodeVec {
    pub(crate) ptr: *const AzXmlNode,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzXmlNodeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<InlineGlyph>`
#[repr(C)]
pub struct AzInlineGlyphVec {
    pub(crate) ptr: *const AzInlineGlyph,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzInlineGlyphVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<InlineTextHit>`
#[repr(C)]
pub struct AzInlineTextHitVec {
    pub(crate) ptr: *const AzInlineTextHit,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzInlineTextHitVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<VideoMode>`
#[repr(C)]
pub struct AzVideoModeVec {
    pub(crate) ptr: *const AzVideoMode,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzVideoModeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<Dom>`
#[repr(C)]
pub struct AzDomVec {
    pub(crate) ptr: *const AzDom,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzDomVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundPosition>`
#[repr(C)]
pub struct AzStyleBackgroundPositionVec {
    pub(crate) ptr: *const AzStyleBackgroundPosition,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStyleBackgroundPositionVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundRepeat>`
#[repr(C)]
pub struct AzStyleBackgroundRepeatVec {
    pub(crate) ptr: *const AzStyleBackgroundRepeatEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStyleBackgroundRepeatVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundSize>`
#[repr(C)]
pub struct AzStyleBackgroundSizeVec {
    pub(crate) ptr: *const AzStyleBackgroundSizeEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStyleBackgroundSizeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `SvgVertex`
#[repr(C)]
pub struct AzSvgVertexVec {
    pub(crate) ptr: *const AzSvgVertex,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzSvgVertexVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<u32>`
#[repr(C)]
pub struct AzU32Vec {
    pub ptr: *const u32,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzU32VecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `XWindowType`
#[repr(C)]
pub struct AzXWindowTypeVec {
    pub(crate) ptr: *const AzXWindowTypeEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzXWindowTypeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `VirtualKeyCode`
#[repr(C)]
pub struct AzVirtualKeyCodeVec {
    pub(crate) ptr: *const AzVirtualKeyCodeEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzVirtualKeyCodeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `CascadeInfo`
#[repr(C)]
pub struct AzCascadeInfoVec {
    pub(crate) ptr: *const AzCascadeInfo,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzCascadeInfoVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `ScanCode`
#[repr(C)]
pub struct AzScanCodeVec {
    pub ptr: *const u32,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzScanCodeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<u16>`
#[repr(C)]
pub struct AzU16Vec {
    pub ptr: *const u16,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzU16VecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<f32>`
#[repr(C)]
pub struct AzF32Vec {
    pub ptr: *const f32,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzF32VecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `U8Vec`
#[repr(C)]
pub struct AzU8Vec {
    pub ptr: *const u8,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzU8VecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `U32Vec`
#[repr(C)]
pub struct AzGLuintVec {
    pub ptr: *const u32,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzGLuintVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `GLintVec`
#[repr(C)]
pub struct AzGLintVec {
    pub ptr: *const i32,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzGLintVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `NormalizedLinearColorStopVec`
#[repr(C)]
pub struct AzNormalizedLinearColorStopVec {
    pub(crate) ptr: *const AzNormalizedLinearColorStop,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNormalizedLinearColorStopVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `NormalizedRadialColorStopVec`
#[repr(C)]
pub struct AzNormalizedRadialColorStopVec {
    pub(crate) ptr: *const AzNormalizedRadialColorStop,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNormalizedRadialColorStopVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `NodeIdVec`
#[repr(C)]
pub struct AzNodeIdVec {
    pub(crate) ptr: *const AzNodeId,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNodeIdVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<NodeHierarchyItem>`
#[repr(C)]
pub struct AzNodeHierarchyItemVec {
    pub(crate) ptr: *const AzNodeHierarchyItem,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNodeHierarchyItemVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `ParentWithNodeDepthVec`
#[repr(C)]
pub struct AzParentWithNodeDepthVec {
    pub(crate) ptr: *const AzParentWithNodeDepth,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzParentWithNodeDepthVecDestructorEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `OptionDropDownOnChoiceChange` struct
#[repr(C, u8)]
pub enum AzOptionDropDownOnChoiceChange {
    None,
    Some(AzDropDownOnChoiceChange),
}

/// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeAdded` struct
#[repr(C, u8)]
pub enum AzOptionNodeGraphOnNodeAdded {
    None,
    Some(AzNodeGraphOnNodeAdded),
}

/// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeRemoved` struct
#[repr(C, u8)]
pub enum AzOptionNodeGraphOnNodeRemoved {
    None,
    Some(AzNodeGraphOnNodeRemoved),
}

/// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeGraphDragged` struct
#[repr(C, u8)]
pub enum AzOptionNodeGraphOnNodeGraphDragged {
    None,
    Some(AzNodeGraphOnNodeGraphDragged),
}

/// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeDragged` struct
#[repr(C, u8)]
pub enum AzOptionNodeGraphOnNodeDragged {
    None,
    Some(AzNodeGraphOnNodeDragged),
}

/// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeConnected` struct
#[repr(C, u8)]
pub enum AzOptionNodeGraphOnNodeConnected {
    None,
    Some(AzNodeGraphOnNodeConnected),
}

/// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeInputDisconnected` struct
#[repr(C, u8)]
pub enum AzOptionNodeGraphOnNodeInputDisconnected {
    None,
    Some(AzNodeGraphOnNodeInputDisconnected),
}

/// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeOutputDisconnected` struct
#[repr(C, u8)]
pub enum AzOptionNodeGraphOnNodeOutputDisconnected {
    None,
    Some(AzNodeGraphOnNodeOutputDisconnected),
}

/// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeFieldEdited` struct
#[repr(C, u8)]
pub enum AzOptionNodeGraphOnNodeFieldEdited {
    None,
    Some(AzNodeGraphOnNodeFieldEdited),
}

/// Re-export of rust-allocated (stack based) `OptionColorInputOnValueChange` struct
#[repr(C, u8)]
pub enum AzOptionColorInputOnValueChange {
    None,
    Some(AzColorInputOnValueChange),
}

/// Re-export of rust-allocated (stack based) `OptionButtonOnClick` struct
#[repr(C, u8)]
pub enum AzOptionButtonOnClick {
    None,
    Some(AzButtonOnClick),
}

/// Re-export of rust-allocated (stack based) `OptionCheckBoxOnToggle` struct
#[repr(C, u8)]
pub enum AzOptionCheckBoxOnToggle {
    None,
    Some(AzCheckBoxOnToggle),
}

/// Re-export of rust-allocated (stack based) `OptionTextInputOnTextInput` struct
#[repr(C, u8)]
pub enum AzOptionTextInputOnTextInput {
    None,
    Some(AzTextInputOnTextInput),
}

/// Re-export of rust-allocated (stack based) `OptionTextInputOnVirtualKeyDown` struct
#[repr(C, u8)]
pub enum AzOptionTextInputOnVirtualKeyDown {
    None,
    Some(AzTextInputOnVirtualKeyDown),
}

/// Re-export of rust-allocated (stack based) `OptionTextInputOnFocusLost` struct
#[repr(C, u8)]
pub enum AzOptionTextInputOnFocusLost {
    None,
    Some(AzTextInputOnFocusLost),
}

/// Re-export of rust-allocated (stack based) `OptionTextInputSelection` struct
#[repr(C, u8)]
pub enum AzOptionTextInputSelection {
    None,
    Some(AzTextInputSelection),
}

/// Re-export of rust-allocated (stack based) `OptionNumberInputOnFocusLost` struct
#[repr(C, u8)]
pub enum AzOptionNumberInputOnFocusLost {
    None,
    Some(AzNumberInputOnFocusLost),
}

/// Re-export of rust-allocated (stack based) `OptionNumberInputOnValueChange` struct
#[repr(C, u8)]
pub enum AzOptionNumberInputOnValueChange {
    None,
    Some(AzNumberInputOnValueChange),
}

/// Re-export of rust-allocated (stack based) `OptionMenuItemIcon` struct
#[repr(C, u8)]
pub enum AzOptionMenuItemIcon {
    None,
    Some(AzMenuItemIcon),
}

/// Re-export of rust-allocated (stack based) `OptionMenuCallback` struct
#[repr(C, u8)]
pub enum AzOptionMenuCallback {
    None,
    Some(AzMenuCallback),
}

/// Re-export of rust-allocated (stack based) `OptionPositionInfo` struct
#[repr(C, u8)]
pub enum AzOptionPositionInfo {
    None,
    Some(AzPositionInfo),
}

/// Re-export of rust-allocated (stack based) `OptionTimerId` struct
#[repr(C, u8)]
pub enum AzOptionTimerId {
    None,
    Some(AzTimerId),
}

/// Re-export of rust-allocated (stack based) `OptionThreadId` struct
#[repr(C, u8)]
pub enum AzOptionThreadId {
    None,
    Some(AzThreadId),
}

/// Re-export of rust-allocated (stack based) `OptionImageRef` struct
#[repr(C, u8)]
pub enum AzOptionImageRef {
    None,
    Some(AzImageRef),
}

/// Re-export of rust-allocated (stack based) `OptionFontRef` struct
#[repr(C, u8)]
pub enum AzOptionFontRef {
    None,
    Some(AzFontRef),
}

/// Re-export of rust-allocated (stack based) `OptionSystemClipboard` struct
#[repr(C, u8)]
pub enum AzOptionSystemClipboard {
    None,
    Some(AzSystemClipboard),
}

/// Re-export of rust-allocated (stack based) `OptionGl` struct
#[repr(C, u8)]
pub enum AzOptionGl {
    None,
    Some(AzGl),
}

/// Re-export of rust-allocated (stack based) `OptionPercentageValue` struct
#[repr(C, u8)]
pub enum AzOptionPercentageValue {
    None,
    Some(AzPercentageValue),
}

/// Re-export of rust-allocated (stack based) `OptionAngleValue` struct
#[repr(C, u8)]
pub enum AzOptionAngleValue {
    None,
    Some(AzAngleValue),
}

/// Re-export of rust-allocated (stack based) `OptionRendererOptions` struct
#[repr(C, u8)]
pub enum AzOptionRendererOptions {
    None,
    Some(AzRendererOptions),
}

/// Re-export of rust-allocated (stack based) `OptionCallback` struct
#[repr(C, u8)]
pub enum AzOptionCallback {
    None,
    Some(AzCallback),
}

/// Re-export of rust-allocated (stack based) `OptionThreadSendMsg` struct
#[repr(C, u8)]
pub enum AzOptionThreadSendMsg {
    None,
    Some(AzThreadSendMsg),
}

/// Re-export of rust-allocated (stack based) `OptionLayoutRect` struct
#[repr(C, u8)]
pub enum AzOptionLayoutRect {
    None,
    Some(AzLayoutRect),
}

/// Re-export of rust-allocated (stack based) `OptionRefAny` struct
#[repr(C, u8)]
pub enum AzOptionRefAny {
    None,
    Some(AzRefAny),
}

/// Re-export of rust-allocated (stack based) `OptionLayoutPoint` struct
#[repr(C, u8)]
pub enum AzOptionLayoutPoint {
    None,
    Some(AzLayoutPoint),
}

/// Re-export of rust-allocated (stack based) `OptionLayoutSize` struct
#[repr(C, u8)]
pub enum AzOptionLayoutSize {
    None,
    Some(AzLayoutSize),
}

/// Re-export of rust-allocated (stack based) `OptionWindowTheme` struct
#[repr(C, u8)]
pub enum AzOptionWindowTheme {
    None,
    Some(AzWindowTheme),
}

/// Re-export of rust-allocated (stack based) `OptionNodeId` struct
#[repr(C, u8)]
pub enum AzOptionNodeId {
    None,
    Some(AzNodeId),
}

/// Re-export of rust-allocated (stack based) `OptionDomNodeId` struct
#[repr(C, u8)]
pub enum AzOptionDomNodeId {
    None,
    Some(AzDomNodeId),
}

/// Re-export of rust-allocated (stack based) `OptionColorU` struct
#[repr(C, u8)]
pub enum AzOptionColorU {
    None,
    Some(AzColorU),
}

/// Re-export of rust-allocated (stack based) `OptionSvgDashPattern` struct
#[repr(C, u8)]
pub enum AzOptionSvgDashPattern {
    None,
    Some(AzSvgDashPattern),
}

/// Re-export of rust-allocated (stack based) `OptionLogicalPosition` struct
#[repr(C, u8)]
pub enum AzOptionLogicalPosition {
    None,
    Some(AzLogicalPosition),
}

/// Re-export of rust-allocated (stack based) `OptionPhysicalPositionI32` struct
#[repr(C, u8)]
pub enum AzOptionPhysicalPositionI32 {
    None,
    Some(AzPhysicalPositionI32),
}

/// Re-export of rust-allocated (stack based) `OptionMouseCursorType` struct
#[repr(C, u8)]
pub enum AzOptionMouseCursorType {
    None,
    Some(AzMouseCursorType),
}

/// Re-export of rust-allocated (stack based) `OptionLogicalSize` struct
#[repr(C, u8)]
pub enum AzOptionLogicalSize {
    None,
    Some(AzLogicalSize),
}

/// Re-export of rust-allocated (stack based) `OptionVirtualKeyCode` struct
#[repr(C, u8)]
pub enum AzOptionVirtualKeyCode {
    None,
    Some(AzVirtualKeyCode),
}

/// Re-export of rust-allocated (stack based) `OptionImageMask` struct
#[repr(C, u8)]
pub enum AzOptionImageMask {
    None,
    Some(AzImageMask),
}

/// Re-export of rust-allocated (stack based) `OptionTabIndex` struct
#[repr(C, u8)]
pub enum AzOptionTabIndex {
    None,
    Some(AzTabIndex),
}

/// Re-export of rust-allocated (stack based) `OptionTagId` struct
#[repr(C, u8)]
pub enum AzOptionTagId {
    None,
    Some(AzTagId),
}

/// Re-export of rust-allocated (stack based) `OptionDuration` struct
#[repr(C, u8)]
pub enum AzOptionDuration {
    None,
    Some(AzDuration),
}

/// Re-export of rust-allocated (stack based) `OptionU8Vec` struct
#[repr(C, u8)]
pub enum AzOptionU8Vec {
    None,
    Some(AzU8Vec),
}

/// Re-export of rust-allocated (stack based) `OptionU8VecRef` struct
#[repr(C, u8)]
pub enum AzOptionU8VecRef {
    None,
    Some(AzU8VecRef),
}

/// Re-export of rust-allocated (stack based) `ResultU8VecEncodeImageError` struct
#[repr(C, u8)]
pub enum AzResultU8VecEncodeImageError {
    Ok(AzU8Vec),
    Err(AzEncodeImageError),
}

/// Re-export of rust-allocated (stack based) `NonXmlCharError` struct
#[repr(C)]
pub struct AzNonXmlCharError {
    pub ch: u32,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `InvalidCharError` struct
#[repr(C)]
pub struct AzInvalidCharError {
    pub expected: u8,
    pub got: u8,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `InvalidCharMultipleError` struct
#[repr(C)]
pub struct AzInvalidCharMultipleError {
    pub expected: u8,
    pub got: AzU8Vec,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `InvalidQuoteError` struct
#[repr(C)]
pub struct AzInvalidQuoteError {
    pub got: u8,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `InvalidSpaceError` struct
#[repr(C)]
pub struct AzInvalidSpaceError {
    pub got: u8,
    pub pos: AzSvgParseErrorPosition,
}

/// Configuration for optional features, such as whether to enable logging or panic hooks
#[repr(C)]
pub struct AzAppConfig {
    pub layout_solver: AzLayoutSolverEnumWrapper,
    pub log_level: AzAppLogLevelEnumWrapper,
    pub enable_visual_panic_hook: bool,
    pub enable_logging_on_panic: bool,
    pub enable_tab_navigation: bool,
    pub system_callbacks: AzSystemCallbacks,
}

/// Small (16x16x4) window icon, usually shown in the window titlebar
#[repr(C)]
pub struct AzSmallWindowIconBytes {
    pub key: AzIconKey,
    pub rgba_bytes: AzU8Vec,
}

/// Large (32x32x4) window icon, usually used on high-resolution displays (instead of `SmallWindowIcon`)
#[repr(C)]
pub struct AzLargeWindowIconBytes {
    pub key: AzIconKey,
    pub rgba_bytes: AzU8Vec,
}

/// Window "favicon", usually shown in the top left of the window on Windows
#[repr(C, u8)]
pub enum AzWindowIcon {
    Small(AzSmallWindowIconBytes),
    Large(AzLargeWindowIconBytes),
}

/// Application taskbar icon, 256x256x4 bytes in size
#[repr(C)]
pub struct AzTaskBarIcon {
    pub key: AzIconKey,
    pub rgba_bytes: AzU8Vec,
}

/// Minimum / maximum / current size of the window in logical dimensions
#[repr(C)]
pub struct AzWindowSize {
    pub dimensions: AzLogicalSize,
    pub hidpi_factor: f32,
    pub system_hidpi_factor: f32,
    pub dpi: u32,
    pub min_dimensions: AzOptionLogicalSizeEnumWrapper,
    pub max_dimensions: AzOptionLogicalSizeEnumWrapper,
}

/// Current keyboard state, stores what keys / characters have been pressed
#[repr(C)]
pub struct AzKeyboardState {
    pub shift_down: bool,
    pub ctrl_down: bool,
    pub alt_down: bool,
    pub super_down: bool,
    pub current_char: AzOptionCharEnumWrapper,
    pub current_virtual_keycode: AzOptionVirtualKeyCodeEnumWrapper,
    pub pressed_virtual_keycodes: AzVirtualKeyCodeVec,
    pub pressed_scancodes: AzScanCodeVec,
}

/// Current mouse / cursor state
#[repr(C)]
pub struct AzMouseState {
    pub mouse_cursor_type: AzOptionMouseCursorTypeEnumWrapper,
    pub cursor_position: AzCursorPositionEnumWrapper,
    pub is_cursor_locked: bool,
    pub left_down: bool,
    pub right_down: bool,
    pub middle_down: bool,
    pub scroll_x: AzOptionF32EnumWrapper,
    pub scroll_y: AzOptionF32EnumWrapper,
}

/// C-ABI stable wrapper over a `MarshaledLayoutCallback`
#[repr(C)]
pub struct AzMarshaledLayoutCallback {
    pub marshal_data: AzRefAny,
    pub cb: AzMarshaledLayoutCallbackInner,
}

/// Re-export of rust-allocated (stack based) `InlineTextContents` struct
#[repr(C)]
pub struct AzInlineTextContents {
    pub glyphs: AzInlineGlyphVec,
    pub bounds: AzLogicalRect,
}

/// Re-export of rust-allocated (stack based) `ResolvedTextLayoutOptions` struct
#[repr(C)]
pub struct AzResolvedTextLayoutOptions {
    pub font_size_px: f32,
    pub line_height: AzOptionF32EnumWrapper,
    pub letter_spacing: AzOptionF32EnumWrapper,
    pub word_spacing: AzOptionF32EnumWrapper,
    pub tab_width: AzOptionF32EnumWrapper,
    pub max_horizontal_width: AzOptionF32EnumWrapper,
    pub leading: AzOptionF32EnumWrapper,
    pub holes: AzLogicalRectVec,
}

/// Easing function of the animation (ease-in, ease-out, ease-in-out, custom)
#[repr(C, u8)]
pub enum AzAnimationEasing {
    Ease,
    Linear,
    EaseIn,
    EaseOut,
    EaseInOut,
    CubicBezier(AzSvgCubicCurve),
}

/// Re-export of rust-allocated (stack based) `RenderImageCallbackInfo` struct
#[repr(C)]
pub struct AzRenderImageCallbackInfo {
    pub callback_node_id: AzDomNodeId,
    pub bounds: AzHidpiAdjustedBounds,
    pub gl_context: *const AzOptionGlEnumWrapper,
    pub image_cache: *const c_void,
    pub system_fonts: *const c_void,
    pub node_hierarchy: *const AzNodeHierarchyItemVec,
    pub words_cache: *const c_void,
    pub shaped_words_cache: *const c_void,
    pub positioned_words_cache: *const c_void,
    pub positioned_rects: *const c_void,
    pub _reserved_ref: *const c_void,
    pub _reserved_mut: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `LayoutCallbackInfo` struct
#[repr(C)]
pub struct AzLayoutCallbackInfo {
    pub window_size: AzWindowSize,
    pub theme: AzWindowThemeEnumWrapper,
    pub image_cache: *const c_void,
    pub gl_context: *const AzOptionGlEnumWrapper,
    pub system_fonts: *const c_void,
    pub _reserved_ref: *const c_void,
    pub _reserved_mut: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `EventFilter` struct
#[repr(C, u8)]
pub enum AzEventFilter {
    Hover(AzHoverEventFilter),
    Not(AzNotEventFilter),
    Focus(AzFocusEventFilter),
    Window(AzWindowEventFilter),
    Component(AzComponentEventFilter),
    Application(AzApplicationEventFilter),
}

/// Menu struct (application / window menu, dropdown menu, context menu). Modeled after the Windows API
#[repr(C)]
pub struct AzMenu {
    pub items: AzMenuItemVec,
    pub position: AzMenuPopupPositionEnumWrapper,
    pub context_mouse_btn: AzContextMenuMouseButtonEnumWrapper,
}

/// Combination of virtual key codes that have to be pressed together
#[repr(C)]
pub struct AzVirtualKeyCodeCombo {
    pub keys: AzVirtualKeyCodeVec,
}

/// Re-export of rust-allocated (stack based) `CssPathPseudoSelector` struct
#[repr(C, u8)]
pub enum AzCssPathPseudoSelector {
    First,
    Last,
    NthChild(AzCssNthChildSelector),
    Hover,
    Active,
    Focus,
}

/// Re-export of rust-allocated (stack based) `AnimationInterpolationFunction` struct
#[repr(C, u8)]
pub enum AzAnimationInterpolationFunction {
    Ease,
    Linear,
    EaseIn,
    EaseOut,
    EaseInOut,
    CubicBezier(AzSvgCubicCurve),
}

/// Re-export of rust-allocated (stack based) `InterpolateContext` struct
#[repr(C)]
pub struct AzInterpolateContext {
    pub animation_func: AzAnimationInterpolationFunctionEnumWrapper,
    pub parent_rect_width: f32,
    pub parent_rect_height: f32,
    pub current_rect_width: f32,
    pub current_rect_height: f32,
}

/// Re-export of rust-allocated (stack based) `LinearGradient` struct
#[repr(C)]
pub struct AzLinearGradient {
    pub direction: AzDirectionEnumWrapper,
    pub extend_mode: AzExtendModeEnumWrapper,
    pub stops: AzNormalizedLinearColorStopVec,
}

/// Re-export of rust-allocated (stack based) `RadialGradient` struct
#[repr(C)]
pub struct AzRadialGradient {
    pub shape: AzShapeEnumWrapper,
    pub size: AzRadialGradientSizeEnumWrapper,
    pub position: AzStyleBackgroundPosition,
    pub extend_mode: AzExtendModeEnumWrapper,
    pub stops: AzNormalizedLinearColorStopVec,
}

/// Re-export of rust-allocated (stack based) `ConicGradient` struct
#[repr(C)]
pub struct AzConicGradient {
    pub extend_mode: AzExtendModeEnumWrapper,
    pub center: AzStyleBackgroundPosition,
    pub angle: AzAngleValue,
    pub stops: AzNormalizedRadialColorStopVec,
}

/// Re-export of rust-allocated (stack based) `StyleTransform` struct
#[repr(C, u8)]
pub enum AzStyleTransform {
    Matrix(AzStyleTransformMatrix2D),
    Matrix3D(AzStyleTransformMatrix3D),
    Translate(AzStyleTransformTranslate2D),
    Translate3D(AzStyleTransformTranslate3D),
    TranslateX(AzPixelValue),
    TranslateY(AzPixelValue),
    TranslateZ(AzPixelValue),
    Rotate(AzAngleValue),
    Rotate3D(AzStyleTransformRotate3D),
    RotateX(AzAngleValue),
    RotateY(AzAngleValue),
    RotateZ(AzAngleValue),
    Scale(AzStyleTransformScale2D),
    Scale3D(AzStyleTransformScale3D),
    ScaleX(AzPercentageValue),
    ScaleY(AzPercentageValue),
    ScaleZ(AzPercentageValue),
    Skew(AzStyleTransformSkew2D),
    SkewX(AzPercentageValue),
    SkewY(AzPercentageValue),
    Perspective(AzPixelValue),
}

/// Re-export of rust-allocated (stack based) `StyleBackgroundPositionVecValue` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundPositionVecValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBackgroundPositionVec),
}

/// Re-export of rust-allocated (stack based) `StyleBackgroundRepeatVecValue` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundRepeatVecValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBackgroundRepeatVec),
}

/// Re-export of rust-allocated (stack based) `StyleBackgroundSizeVecValue` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundSizeVecValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBackgroundSizeVec),
}

/// Re-export of rust-allocated (stack based) `CheckBoxStateWrapper` struct
#[repr(C)]
pub struct AzCheckBoxStateWrapper {
    pub inner: AzCheckBoxState,
    pub on_toggle: AzOptionCheckBoxOnToggleEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `NumberInputStateWrapper` struct
#[repr(C)]
pub struct AzNumberInputStateWrapper {
    pub inner: AzNumberInputState,
    pub on_value_change: AzOptionNumberInputOnValueChangeEnumWrapper,
    pub on_focus_lost: AzOptionNumberInputOnFocusLostEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `NodeGraphCallbacks` struct
#[repr(C)]
pub struct AzNodeGraphCallbacks {
    pub on_node_added: AzOptionNodeGraphOnNodeAddedEnumWrapper,
    pub on_node_removed: AzOptionNodeGraphOnNodeRemovedEnumWrapper,
    pub on_node_dragged: AzOptionNodeGraphOnNodeDraggedEnumWrapper,
    pub on_node_graph_dragged: AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper,
    pub on_node_connected: AzOptionNodeGraphOnNodeConnectedEnumWrapper,
    pub on_node_input_disconnected: AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper,
    pub on_node_output_disconnected: AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper,
    pub on_node_field_edited: AzOptionNodeGraphOnNodeFieldEditedEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `InputConnection` struct
#[repr(C)]
pub struct AzInputConnection {
    pub input_index: usize,
    pub connects_to: AzOutputNodeAndIndexVec,
}

/// Re-export of rust-allocated (stack based) `OutputConnection` struct
#[repr(C)]
pub struct AzOutputConnection {
    pub output_index: usize,
    pub connects_to: AzInputNodeAndIndexVec,
}

/// Re-export of rust-allocated (stack based) `StyledNode` struct
#[repr(C)]
pub struct AzStyledNode {
    pub state: AzStyledNodeState,
    pub tag_id: AzOptionTagIdEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `TagIdToNodeIdMapping` struct
#[repr(C)]
pub struct AzTagIdToNodeIdMapping {
    pub tag_id: AzTagId,
    pub node_id: AzNodeId,
    pub tab_index: AzOptionTabIndexEnumWrapper,
    pub parents: AzNodeIdVec,
}

/// Re-export of rust-allocated (stack based) `Texture` struct
#[repr(C)]
pub struct AzTexture {
    pub texture_id: u32,
    pub flags: AzTextureFlags,
    pub size: AzPhysicalSizeU32,
    pub background_color: AzColorU,
    pub gl_context: AzGl,
    pub format: AzRawImageFormatEnumWrapper,
    pub refcount: *const c_void,
}

/// C-ABI stable reexport of `(U8Vec, u32)`
#[repr(C)]
pub struct AzGetProgramBinaryReturn {
    pub _0: AzU8Vec,
    pub _1: u32,
}

/// Re-export of rust-allocated (stack based) `RawImageData` struct
#[repr(C, u8)]
pub enum AzRawImageData {
    U8(AzU8Vec),
    U16(AzU16Vec),
    F32(AzF32Vec),
}

/// Source data of a font file (bytes)
#[repr(C)]
pub struct AzFontSource {
    pub data: AzU8Vec,
    pub font_index: u32,
    pub parse_glyph_outlines: bool,
}

/// Re-export of rust-allocated (stack based) `SvgPathElement` struct
#[repr(C, u8)]
pub enum AzSvgPathElement {
    Line(AzSvgLine),
    QuadraticCurve(AzSvgQuadraticCurve),
    CubicCurve(AzSvgCubicCurve),
}

/// Re-export of rust-allocated (stack based) `TessellatedSvgNode` struct
#[repr(C)]
pub struct AzTessellatedSvgNode {
    pub vertices: AzSvgVertexVec,
    pub indices: AzU32Vec,
}

/// Rust wrapper over a `&[TessellatedSvgNode]` or `&Vec<TessellatedSvgNode>`
#[repr(C)]
pub struct AzTessellatedSvgNodeVecRef {
    pub(crate) ptr: *const AzTessellatedSvgNode,
    pub len: usize,
}

/// Re-export of rust-allocated (stack based) `SvgRenderOptions` struct
#[repr(C)]
pub struct AzSvgRenderOptions {
    pub target_size: AzOptionLayoutSizeEnumWrapper,
    pub background_color: AzOptionColorUEnumWrapper,
    pub fit: AzSvgFitToEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `SvgStrokeStyle` struct
#[repr(C)]
pub struct AzSvgStrokeStyle {
    pub start_cap: AzSvgLineCapEnumWrapper,
    pub end_cap: AzSvgLineCapEnumWrapper,
    pub line_join: AzSvgLineJoinEnumWrapper,
    pub dash_pattern: AzOptionSvgDashPatternEnumWrapper,
    pub line_width: f32,
    pub miter_limit: f32,
    pub tolerance: f32,
    pub apply_line_width: bool,
    pub transform: AzSvgTransform,
    pub anti_alias: bool,
    pub high_quality_aa: bool,
}

/// Re-export of rust-allocated (stack based) `Xml` struct
#[repr(C)]
pub struct AzXml {
    pub root: AzXmlNodeVec,
}

/// Re-export of rust-allocated (stack based) `Instant` struct
#[repr(C, u8)]
pub enum AzInstant {
    System(AzInstantPtr),
    Tick(AzSystemTick),
}

/// Re-export of rust-allocated (stack based) `ThreadReceiveMsg` struct
#[repr(C, u8)]
pub enum AzThreadReceiveMsg {
    WriteBack(AzThreadWriteBackMsg),
    Update(AzUpdate),
}

/// Re-export of rust-allocated (stack based) `String` struct
#[repr(C)]
pub struct AzString {
    pub vec: AzU8Vec,
}

/// Wrapper over a Rust-allocated `Vec<InputConnection>`
#[repr(C)]
pub struct AzInputConnectionVec {
    pub(crate) ptr: *const AzInputConnection,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzInputConnectionVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<OutputConnection>`
#[repr(C)]
pub struct AzOutputConnectionVec {
    pub(crate) ptr: *const AzOutputConnection,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzOutputConnectionVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<TessellatedSvgNode>`
#[repr(C)]
pub struct AzTessellatedSvgNodeVec {
    pub(crate) ptr: *const AzTessellatedSvgNode,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzTessellatedSvgNodeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<StyleTransform>`
#[repr(C)]
pub struct AzStyleTransformVec {
    pub(crate) ptr: *const AzStyleTransformEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStyleTransformVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `VertexAttribute`
#[repr(C)]
pub struct AzSvgPathElementVec {
    pub(crate) ptr: *const AzSvgPathElementEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzSvgPathElementVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `StringVec`
#[repr(C)]
pub struct AzStringVec {
    pub(crate) ptr: *const AzString,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStringVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `StyledNodeVec`
#[repr(C)]
pub struct AzStyledNodeVec {
    pub(crate) ptr: *const AzStyledNode,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStyledNodeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `TagIdToNodeIdMappingVec`
#[repr(C)]
pub struct AzTagIdToNodeIdMappingVec {
    pub(crate) ptr: *const AzTagIdToNodeIdMapping,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzTagIdToNodeIdMappingVecDestructorEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `OptionResolvedTextLayoutOptions` struct
#[repr(C, u8)]
pub enum AzOptionResolvedTextLayoutOptions {
    None,
    Some(AzResolvedTextLayoutOptions),
}

/// Re-export of rust-allocated (stack based) `OptionVirtualKeyCodeCombo` struct
#[repr(C, u8)]
pub enum AzOptionVirtualKeyCodeCombo {
    None,
    Some(AzVirtualKeyCodeCombo),
}

/// Re-export of rust-allocated (stack based) `OptionMouseState` struct
#[repr(C, u8)]
pub enum AzOptionMouseState {
    None,
    Some(AzMouseState),
}

/// Re-export of rust-allocated (stack based) `OptionKeyboardState` struct
#[repr(C, u8)]
pub enum AzOptionKeyboardState {
    None,
    Some(AzKeyboardState),
}

/// Re-export of rust-allocated (stack based) `OptionStringVec` struct
#[repr(C, u8)]
pub enum AzOptionStringVec {
    None,
    Some(AzStringVec),
}

/// Re-export of rust-allocated (stack based) `OptionThreadReceiveMsg` struct
#[repr(C, u8)]
pub enum AzOptionThreadReceiveMsg {
    None,
    Some(AzThreadReceiveMsg),
}

/// Re-export of rust-allocated (stack based) `OptionTaskBarIcon` struct
#[repr(C, u8)]
pub enum AzOptionTaskBarIcon {
    None,
    Some(AzTaskBarIcon),
}

/// Re-export of rust-allocated (stack based) `OptionWindowIcon` struct
#[repr(C, u8)]
pub enum AzOptionWindowIcon {
    None,
    Some(AzWindowIcon),
}

/// Re-export of rust-allocated (stack based) `OptionString` struct
#[repr(C, u8)]
pub enum AzOptionString {
    None,
    Some(AzString),
}

/// Re-export of rust-allocated (stack based) `OptionTexture` struct
#[repr(C, u8)]
pub enum AzOptionTexture {
    None,
    Some(AzTexture),
}

/// Re-export of rust-allocated (stack based) `OptionInstant` struct
#[repr(C, u8)]
pub enum AzOptionInstant {
    None,
    Some(AzInstant),
}

/// Re-export of rust-allocated (stack based) `DuplicatedNamespaceError` struct
#[repr(C)]
pub struct AzDuplicatedNamespaceError {
    pub ns: AzString,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `UnknownNamespaceError` struct
#[repr(C)]
pub struct AzUnknownNamespaceError {
    pub ns: AzString,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `UnexpectedCloseTagError` struct
#[repr(C)]
pub struct AzUnexpectedCloseTagError {
    pub expected: AzString,
    pub actual: AzString,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `UnknownEntityReferenceError` struct
#[repr(C)]
pub struct AzUnknownEntityReferenceError {
    pub entity: AzString,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `DuplicatedAttributeError` struct
#[repr(C)]
pub struct AzDuplicatedAttributeError {
    pub attribute: AzString,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `InvalidStringError` struct
#[repr(C)]
pub struct AzInvalidStringError {
    pub got: AzString,
    pub pos: AzSvgParseErrorPosition,
}

/// Window configuration specific to Win32
#[repr(C)]
pub struct AzWindowsWindowOptions {
    pub allow_drag_drop: bool,
    pub no_redirection_bitmap: bool,
    pub window_icon: AzOptionWindowIconEnumWrapper,
    pub taskbar_icon: AzOptionTaskBarIconEnumWrapper,
    pub parent_window: AzOptionHwndHandleEnumWrapper,
}

/// CSD theme of the window title / button controls
#[repr(C)]
pub struct AzWaylandTheme {
    pub title_bar_active_background_color: [u8;4],
    pub title_bar_active_separator_color: [u8;4],
    pub title_bar_active_text_color: [u8;4],
    pub title_bar_inactive_background_color: [u8;4],
    pub title_bar_inactive_separator_color: [u8;4],
    pub title_bar_inactive_text_color: [u8;4],
    pub maximize_idle_foreground_inactive_color: [u8;4],
    pub minimize_idle_foreground_inactive_color: [u8;4],
    pub close_idle_foreground_inactive_color: [u8;4],
    pub maximize_hovered_foreground_inactive_color: [u8;4],
    pub minimize_hovered_foreground_inactive_color: [u8;4],
    pub close_hovered_foreground_inactive_color: [u8;4],
    pub maximize_disabled_foreground_inactive_color: [u8;4],
    pub minimize_disabled_foreground_inactive_color: [u8;4],
    pub close_disabled_foreground_inactive_color: [u8;4],
    pub maximize_idle_background_inactive_color: [u8;4],
    pub minimize_idle_background_inactive_color: [u8;4],
    pub close_idle_background_inactive_color: [u8;4],
    pub maximize_hovered_background_inactive_color: [u8;4],
    pub minimize_hovered_background_inactive_color: [u8;4],
    pub close_hovered_background_inactive_color: [u8;4],
    pub maximize_disabled_background_inactive_color: [u8;4],
    pub minimize_disabled_background_inactive_color: [u8;4],
    pub close_disabled_background_inactive_color: [u8;4],
    pub maximize_idle_foreground_active_color: [u8;4],
    pub minimize_idle_foreground_active_color: [u8;4],
    pub close_idle_foreground_active_color: [u8;4],
    pub maximize_hovered_foreground_active_color: [u8;4],
    pub minimize_hovered_foreground_active_color: [u8;4],
    pub close_hovered_foreground_active_color: [u8;4],
    pub maximize_disabled_foreground_active_color: [u8;4],
    pub minimize_disabled_foreground_active_color: [u8;4],
    pub close_disabled_foreground_active_color: [u8;4],
    pub maximize_idle_background_active_color: [u8;4],
    pub minimize_idle_background_active_color: [u8;4],
    pub close_idle_background_active_color: [u8;4],
    pub maximize_hovered_background_active_color: [u8;4],
    pub minimize_hovered_background_active_color: [u8;4],
    pub close_hovered_background_active_color: [u8;4],
    pub maximize_disabled_background_active_color: [u8;4],
    pub minimize_disabled_background_active_color: [u8;4],
    pub close_disabled_background_active_color: [u8;4],
    pub title_bar_font: AzString,
    pub title_bar_font_size: f32,
}

/// Key-value pair, used for setting WM hints values specific to GNOME
#[repr(C)]
pub struct AzStringPair {
    pub key: AzString,
    pub value: AzString,
}

/// Information about a single (or many) monitors, useful for dock widgets
#[repr(C)]
pub struct AzMonitor {
    pub id: usize,
    pub name: AzOptionStringEnumWrapper,
    pub size: AzLayoutSize,
    pub position: AzLayoutPoint,
    pub scale_factor: f64,
    pub video_modes: AzVideoModeVec,
    pub is_primary_monitor: bool,
}

/// Re-export of rust-allocated (stack based) `LayoutCallback` struct
#[repr(C, u8)]
pub enum AzLayoutCallback {
    Raw(AzLayoutCallbackInner),
    Marshaled(AzMarshaledLayoutCallback),
}

/// Re-export of rust-allocated (stack based) `InlineWord` struct
#[repr(C, u8)]
pub enum AzInlineWord {
    Tab,
    Return,
    Space,
    Word(AzInlineTextContents),
}

/// Re-export of rust-allocated (stack based) `CallbackData` struct
#[repr(C)]
pub struct AzCallbackData {
    pub event: AzEventFilterEnumWrapper,
    pub callback: AzCallback,
    pub data: AzRefAny,
}

/// List of core DOM node types built-into by `azul`
#[repr(C, u8)]
pub enum AzNodeType {
    Body,
    Div,
    Br,
    Text(AzString),
    Image(AzImageRef),
    IFrame(AzIFrameNode),
}

/// Accessibility information (MSAA wrapper). See `NodeData.set_accessibility_info()`
#[repr(C)]
pub struct AzAccessibilityInfo {
    pub name: AzOptionStringEnumWrapper,
    pub value: AzOptionStringEnumWrapper,
    pub role: AzAccessibilityRoleEnumWrapper,
    pub states: AzAccessibilityStateVec,
    pub accelerator: AzOptionVirtualKeyCodeComboEnumWrapper,
    pub default_action: AzOptionStringEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `IdOrClass` struct
#[repr(C, u8)]
pub enum AzIdOrClass {
    Id(AzString),
    Class(AzString),
}

/// Regular labeled menu item
#[repr(C)]
pub struct AzStringMenuItem {
    pub label: AzString,
    pub accelerator: AzOptionVirtualKeyCodeComboEnumWrapper,
    pub callback: AzOptionMenuCallbackEnumWrapper,
    pub state: AzMenuItemStateEnumWrapper,
    pub icon: AzOptionMenuItemIconEnumWrapper,
    pub children: AzMenuItemVec,
}

/// Re-export of rust-allocated (stack based) `CssPathSelector` struct
#[repr(C, u8)]
pub enum AzCssPathSelector {
    Global,
    Type(AzNodeTypeKey),
    Class(AzString),
    Id(AzString),
    PseudoSelector(AzCssPathPseudoSelector),
    DirectChildren,
    Children,
}

/// Re-export of rust-allocated (stack based) `StyleBackgroundContent` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundContent {
    LinearGradient(AzLinearGradient),
    RadialGradient(AzRadialGradient),
    ConicGradient(AzConicGradient),
    Image(AzString),
    Color(AzColorU),
}

/// Re-export of rust-allocated (stack based) `ScrollbarInfo` struct
#[repr(C)]
pub struct AzScrollbarInfo {
    pub width: AzLayoutWidth,
    pub padding_left: AzLayoutPaddingLeft,
    pub padding_right: AzLayoutPaddingRight,
    pub track: AzStyleBackgroundContentEnumWrapper,
    pub thumb: AzStyleBackgroundContentEnumWrapper,
    pub button: AzStyleBackgroundContentEnumWrapper,
    pub corner: AzStyleBackgroundContentEnumWrapper,
    pub resizer: AzStyleBackgroundContentEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `ScrollbarStyle` struct
#[repr(C)]
pub struct AzScrollbarStyle {
    pub horizontal: AzScrollbarInfo,
    pub vertical: AzScrollbarInfo,
}

/// Re-export of rust-allocated (stack based) `StyleFontFamily` struct
#[repr(C, u8)]
pub enum AzStyleFontFamily {
    System(AzString),
    File(AzString),
    Ref(AzFontRef),
}

/// Re-export of rust-allocated (stack based) `ScrollbarStyleValue` struct
#[repr(C, u8)]
pub enum AzScrollbarStyleValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzScrollbarStyle),
}

/// Re-export of rust-allocated (stack based) `StyleTransformVecValue` struct
#[repr(C, u8)]
pub enum AzStyleTransformVecValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleTransformVec),
}

/// Re-export of rust-allocated (stack based) `ColorInputStateWrapper` struct
#[repr(C)]
pub struct AzColorInputStateWrapper {
    pub inner: AzColorInputState,
    pub title: AzString,
    pub on_value_change: AzOptionColorInputOnValueChangeEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `TextInputState` struct
#[repr(C)]
pub struct AzTextInputState {
    pub text: AzU32Vec,
    pub placeholder: AzOptionStringEnumWrapper,
    pub max_len: usize,
    pub selection: AzOptionTextInputSelectionEnumWrapper,
    pub cursor_pos: usize,
}

/// Re-export of rust-allocated (stack based) `NodeTypeFieldValue` struct
#[repr(C, u8)]
pub enum AzNodeTypeFieldValue {
    TextInput(AzString),
    NumberInput(f32),
    CheckBox(bool),
    ColorInput(AzColorU),
}

/// Re-export of rust-allocated (stack based) `NodeTypeInfo` struct
#[repr(C)]
pub struct AzNodeTypeInfo {
    pub is_root: bool,
    pub name: AzString,
    pub inputs: AzInputOutputTypeIdVec,
    pub outputs: AzInputOutputTypeIdVec,
}

/// Re-export of rust-allocated (stack based) `InputOutputInfo` struct
#[repr(C)]
pub struct AzInputOutputInfo {
    pub data_type: AzString,
    pub color: AzColorU,
}

/// Re-export of rust-allocated (stack based) `ListView` struct
#[repr(C)]
pub struct AzListView {
    pub columns: AzStringVec,
}

/// Re-export of rust-allocated (stack based) `TreeView` struct
#[repr(C)]
pub struct AzTreeView {
    pub root: AzString,
}

/// Re-export of rust-allocated (stack based) `DropDown` struct
#[repr(C)]
pub struct AzDropDown {
    pub choices: AzStringVec,
    pub selected: usize,
    pub on_choice_change: AzOptionDropDownOnChoiceChangeEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `VertexAttribute` struct
#[repr(C)]
pub struct AzVertexAttribute {
    pub name: AzString,
    pub layout_location: AzOptionUsizeEnumWrapper,
    pub attribute_type: AzVertexAttributeTypeEnumWrapper,
    pub item_count: usize,
}

/// Re-export of rust-allocated (stack based) `DebugMessage` struct
#[repr(C)]
pub struct AzDebugMessage {
    pub message: AzString,
    pub source: u32,
    pub ty: u32,
    pub id: u32,
    pub severity: u32,
}

/// C-ABI stable reexport of `(i32, u32, AzString)`
#[repr(C)]
pub struct AzGetActiveAttribReturn {
    pub _0: i32,
    pub _1: u32,
    pub _2: AzString,
}

/// C-ABI stable reexport of `(i32, u32, AzString)`
#[repr(C)]
pub struct AzGetActiveUniformReturn {
    pub _0: i32,
    pub _1: u32,
    pub _2: AzString,
}

/// Re-export of rust-allocated (stack based) `RawImage` struct
#[repr(C)]
pub struct AzRawImage {
    pub pixels: AzRawImageDataEnumWrapper,
    pub width: usize,
    pub height: usize,
    pub alpha_premultiplied: bool,
    pub data_format: AzRawImageFormatEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `SvgPath` struct
#[repr(C)]
pub struct AzSvgPath {
    pub items: AzSvgPathElementVec,
}

/// Re-export of rust-allocated (stack based) `SvgParseOptions` struct
#[repr(C)]
pub struct AzSvgParseOptions {
    pub relative_image_path: AzOptionStringEnumWrapper,
    pub dpi: f32,
    pub default_font_family: AzString,
    pub font_size: f32,
    pub languages: AzStringVec,
    pub shape_rendering: AzShapeRenderingEnumWrapper,
    pub text_rendering: AzTextRenderingEnumWrapper,
    pub image_rendering: AzImageRenderingEnumWrapper,
    pub keep_named_groups: bool,
    pub fontdb: AzFontDatabaseEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `SvgStyle` struct
#[repr(C, u8)]
pub enum AzSvgStyle {
    Fill(AzSvgFillStyle),
    Stroke(AzSvgStrokeStyle),
}

/// **Reference-counted** file handle
#[repr(C)]
pub struct AzFile {
    pub ptr: *const c_void,
    pub path: AzString,
}

/// Re-export of rust-allocated (stack based) `FileTypeList` struct
#[repr(C)]
pub struct AzFileTypeList {
    pub document_types: AzStringVec,
    pub document_descriptor: AzString,
}

/// Re-export of rust-allocated (stack based) `Timer` struct
#[repr(C)]
pub struct AzTimer {
    pub data: AzRefAny,
    pub node_id: AzOptionDomNodeIdEnumWrapper,
    pub created: AzInstantEnumWrapper,
    pub last_run: AzOptionInstantEnumWrapper,
    pub run_count: usize,
    pub delay: AzOptionDurationEnumWrapper,
    pub interval: AzOptionDurationEnumWrapper,
    pub timeout: AzOptionDurationEnumWrapper,
    pub callback: AzTimerCallback,
}

/// Re-export of rust-allocated (stack based) `FmtValue` struct
#[repr(C, u8)]
pub enum AzFmtValue {
    Bool(bool),
    Uchar(u8),
    Schar(i8),
    Ushort(u16),
    Sshort(i16),
    Uint(u32),
    Sint(i32),
    Ulong(u64),
    Slong(i64),
    Isize(isize),
    Usize(usize),
    Float(f32),
    Double(f64),
    Str(AzString),
    StrVec(AzStringVec),
}

/// Re-export of rust-allocated (stack based) `FmtArg` struct
#[repr(C)]
pub struct AzFmtArg {
    pub key: AzString,
    pub value: AzFmtValueEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<StyleFontFamily>`
#[repr(C)]
pub struct AzStyleFontFamilyVec {
    pub(crate) ptr: *const AzStyleFontFamilyEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStyleFontFamilyVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<FmtArg>`
#[repr(C)]
pub struct AzFmtArgVec {
    pub(crate) ptr: *const AzFmtArg,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzFmtArgVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<InlineWord>`
#[repr(C)]
pub struct AzInlineWordVec {
    pub(crate) ptr: *const AzInlineWordEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzInlineWordVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<Monitor>`
#[repr(C)]
pub struct AzMonitorVec {
    pub(crate) ptr: *const AzMonitor,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzMonitorVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<IdOrClass>`
#[repr(C)]
pub struct AzIdOrClassVec {
    pub(crate) ptr: *const AzIdOrClassEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzIdOrClassVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundContent>`
#[repr(C)]
pub struct AzStyleBackgroundContentVec {
    pub(crate) ptr: *const AzStyleBackgroundContentEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStyleBackgroundContentVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<SvgPath>`
#[repr(C)]
pub struct AzSvgPathVec {
    pub(crate) ptr: *const AzSvgPath,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzSvgPathVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<VertexAttribute>`
#[repr(C)]
pub struct AzVertexAttributeVec {
    pub(crate) ptr: *const AzVertexAttribute,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzVertexAttributeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `CssPathSelector`
#[repr(C)]
pub struct AzCssPathSelectorVec {
    pub(crate) ptr: *const AzCssPathSelectorEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzCssPathSelectorVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `CallbackData`
#[repr(C)]
pub struct AzCallbackDataVec {
    pub(crate) ptr: *const AzCallbackData,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzCallbackDataVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<DebugMessage>`
#[repr(C)]
pub struct AzDebugMessageVec {
    pub(crate) ptr: *const AzDebugMessage,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzDebugMessageVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `StringPairVec`
#[repr(C)]
pub struct AzStringPairVec {
    pub(crate) ptr: *const AzStringPair,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStringPairVecDestructorEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `OptionFileTypeList` struct
#[repr(C, u8)]
pub enum AzOptionFileTypeList {
    None,
    Some(AzFileTypeList),
}

/// Re-export of rust-allocated (stack based) `OptionFile` struct
#[repr(C, u8)]
pub enum AzOptionFile {
    None,
    Some(AzFile),
}

/// Re-export of rust-allocated (stack based) `OptionRawImage` struct
#[repr(C, u8)]
pub enum AzOptionRawImage {
    None,
    Some(AzRawImage),
}

/// Re-export of rust-allocated (stack based) `OptionWaylandTheme` struct
#[repr(C, u8)]
pub enum AzOptionWaylandTheme {
    None,
    Some(AzWaylandTheme),
}

/// Re-export of rust-allocated (stack based) `ResultRawImageDecodeImageError` struct
#[repr(C, u8)]
pub enum AzResultRawImageDecodeImageError {
    Ok(AzRawImage),
    Err(AzDecodeImageError),
}

/// Re-export of rust-allocated (stack based) `XmlStreamError` struct
#[repr(C, u8)]
pub enum AzXmlStreamError {
    UnexpectedEndOfStream,
    InvalidName,
    NonXmlChar(AzNonXmlCharError),
    InvalidChar(AzInvalidCharError),
    InvalidCharMultiple(AzInvalidCharMultipleError),
    InvalidQuote(AzInvalidQuoteError),
    InvalidSpace(AzInvalidSpaceError),
    InvalidString(AzInvalidStringError),
    InvalidReference,
    InvalidExternalID,
    InvalidCommentData,
    InvalidCommentEnd,
    InvalidCharacterData,
}

/// Re-export of rust-allocated (stack based) `LinuxWindowOptions` struct
#[repr(C)]
pub struct AzLinuxWindowOptions {
    pub x11_visual: AzOptionX11VisualEnumWrapper,
    pub x11_screen: AzOptionI32EnumWrapper,
    pub x11_wm_classes: AzStringPairVec,
    pub x11_override_redirect: bool,
    pub x11_window_types: AzXWindowTypeVec,
    pub x11_gtk_theme_variant: AzOptionStringEnumWrapper,
    pub x11_resize_increments: AzOptionLogicalSizeEnumWrapper,
    pub x11_base_size: AzOptionLogicalSizeEnumWrapper,
    pub wayland_app_id: AzOptionStringEnumWrapper,
    pub wayland_theme: AzOptionWaylandThemeEnumWrapper,
    pub request_user_attention: bool,
    pub window_icon: AzOptionWindowIconEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `InlineLine` struct
#[repr(C)]
pub struct AzInlineLine {
    pub words: AzInlineWordVec,
    pub bounds: AzLogicalRect,
}

/// Item entry in a menu or menu bar
#[repr(C, u8)]
pub enum AzMenuItem {
    String(AzStringMenuItem),
    Separator,
    BreakLine,
}

/// Re-export of rust-allocated (stack based) `CssPath` struct
#[repr(C)]
pub struct AzCssPath {
    pub selectors: AzCssPathSelectorVec,
}

/// Re-export of rust-allocated (stack based) `StyleBackgroundContentVecValue` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundContentVecValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBackgroundContentVec),
}

/// Re-export of rust-allocated (stack based) `StyleFontFamilyVecValue` struct
#[repr(C, u8)]
pub enum AzStyleFontFamilyVecValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleFontFamilyVec),
}

/// Parsed CSS key-value pair
#[repr(C, u8)]
pub enum AzCssProperty {
    TextColor(AzStyleTextColorValue),
    FontSize(AzStyleFontSizeValue),
    FontFamily(AzStyleFontFamilyVecValue),
    TextAlign(AzStyleTextAlignValue),
    LetterSpacing(AzStyleLetterSpacingValue),
    LineHeight(AzStyleLineHeightValue),
    WordSpacing(AzStyleWordSpacingValue),
    TabWidth(AzStyleTabWidthValue),
    Cursor(AzStyleCursorValue),
    Display(AzLayoutDisplayValue),
    Float(AzLayoutFloatValue),
    BoxSizing(AzLayoutBoxSizingValue),
    Width(AzLayoutWidthValue),
    Height(AzLayoutHeightValue),
    MinWidth(AzLayoutMinWidthValue),
    MinHeight(AzLayoutMinHeightValue),
    MaxWidth(AzLayoutMaxWidthValue),
    MaxHeight(AzLayoutMaxHeightValue),
    Position(AzLayoutPositionValue),
    Top(AzLayoutTopValue),
    Right(AzLayoutRightValue),
    Left(AzLayoutLeftValue),
    Bottom(AzLayoutBottomValue),
    FlexWrap(AzLayoutFlexWrapValue),
    FlexDirection(AzLayoutFlexDirectionValue),
    FlexGrow(AzLayoutFlexGrowValue),
    FlexShrink(AzLayoutFlexShrinkValue),
    JustifyContent(AzLayoutJustifyContentValue),
    AlignItems(AzLayoutAlignItemsValue),
    AlignContent(AzLayoutAlignContentValue),
    BackgroundContent(AzStyleBackgroundContentVecValue),
    BackgroundPosition(AzStyleBackgroundPositionVecValue),
    BackgroundSize(AzStyleBackgroundSizeVecValue),
    BackgroundRepeat(AzStyleBackgroundRepeatVecValue),
    OverflowX(AzLayoutOverflowValue),
    OverflowY(AzLayoutOverflowValue),
    PaddingTop(AzLayoutPaddingTopValue),
    PaddingLeft(AzLayoutPaddingLeftValue),
    PaddingRight(AzLayoutPaddingRightValue),
    PaddingBottom(AzLayoutPaddingBottomValue),
    MarginTop(AzLayoutMarginTopValue),
    MarginLeft(AzLayoutMarginLeftValue),
    MarginRight(AzLayoutMarginRightValue),
    MarginBottom(AzLayoutMarginBottomValue),
    BorderTopLeftRadius(AzStyleBorderTopLeftRadiusValue),
    BorderTopRightRadius(AzStyleBorderTopRightRadiusValue),
    BorderBottomLeftRadius(AzStyleBorderBottomLeftRadiusValue),
    BorderBottomRightRadius(AzStyleBorderBottomRightRadiusValue),
    BorderTopColor(AzStyleBorderTopColorValue),
    BorderRightColor(AzStyleBorderRightColorValue),
    BorderLeftColor(AzStyleBorderLeftColorValue),
    BorderBottomColor(AzStyleBorderBottomColorValue),
    BorderTopStyle(AzStyleBorderTopStyleValue),
    BorderRightStyle(AzStyleBorderRightStyleValue),
    BorderLeftStyle(AzStyleBorderLeftStyleValue),
    BorderBottomStyle(AzStyleBorderBottomStyleValue),
    BorderTopWidth(AzLayoutBorderTopWidthValue),
    BorderRightWidth(AzLayoutBorderRightWidthValue),
    BorderLeftWidth(AzLayoutBorderLeftWidthValue),
    BorderBottomWidth(AzLayoutBorderBottomWidthValue),
    BoxShadowLeft(AzStyleBoxShadowValue),
    BoxShadowRight(AzStyleBoxShadowValue),
    BoxShadowTop(AzStyleBoxShadowValue),
    BoxShadowBottom(AzStyleBoxShadowValue),
    ScrollbarStyle(AzScrollbarStyleValue),
    Opacity(AzStyleOpacityValue),
    Transform(AzStyleTransformVecValue),
    TransformOrigin(AzStyleTransformOriginValue),
    PerspectiveOrigin(AzStylePerspectiveOriginValue),
    BackfaceVisibility(AzStyleBackfaceVisibilityValue),
}

/// Re-export of rust-allocated (stack based) `TextInputStateWrapper` struct
#[repr(C)]
pub struct AzTextInputStateWrapper {
    pub inner: AzTextInputState,
    pub on_text_input: AzOptionTextInputOnTextInputEnumWrapper,
    pub on_virtual_key_down: AzOptionTextInputOnVirtualKeyDownEnumWrapper,
    pub on_focus_lost: AzOptionTextInputOnFocusLostEnumWrapper,
    pub update_text_input_before_calling_focus_lost_fn: bool,
    pub update_text_input_before_calling_vk_down_fn: bool,
    pub cursor_animation: AzOptionTimerIdEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `ProgressBar` struct
#[repr(C)]
pub struct AzProgressBar {
    pub state: AzProgressBarState,
    pub height: AzPixelValue,
    pub bar_background: AzStyleBackgroundContentVec,
    pub container_background: AzStyleBackgroundContentVec,
}

/// Re-export of rust-allocated (stack based) `NodeTypeIdInfoMap` struct
#[repr(C)]
pub struct AzNodeTypeIdInfoMap {
    pub node_type_id: AzNodeTypeId,
    pub node_type_info: AzNodeTypeInfo,
}

/// Re-export of rust-allocated (stack based) `InputOutputTypeIdInfoMap` struct
#[repr(C)]
pub struct AzInputOutputTypeIdInfoMap {
    pub io_type_id: AzInputOutputTypeId,
    pub io_info: AzInputOutputInfo,
}

/// Re-export of rust-allocated (stack based) `NodeTypeField` struct
#[repr(C)]
pub struct AzNodeTypeField {
    pub key: AzString,
    pub value: AzNodeTypeFieldValueEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `CssPropertySource` struct
#[repr(C, u8)]
pub enum AzCssPropertySource {
    Css(AzCssPath),
    Inline,
}

/// Re-export of rust-allocated (stack based) `VertexLayout` struct
#[repr(C)]
pub struct AzVertexLayout {
    pub fields: AzVertexAttributeVec,
}

/// Re-export of rust-allocated (stack based) `VertexArrayObject` struct
#[repr(C)]
pub struct AzVertexArrayObject {
    pub vertex_layout: AzVertexLayout,
    pub vao_id: u32,
    pub gl_context: AzGl,
    pub refcount: *const c_void,
}

/// Re-export of rust-allocated (stack based) `VertexBuffer` struct
#[repr(C)]
pub struct AzVertexBuffer {
    pub vertex_buffer_id: u32,
    pub vertex_buffer_len: usize,
    pub vao: AzVertexArrayObject,
    pub index_buffer_id: u32,
    pub index_buffer_len: usize,
    pub index_buffer_format: AzIndexBufferFormatEnumWrapper,
    pub refcount: *const c_void,
}

/// Re-export of rust-allocated (stack based) `SvgMultiPolygon` struct
#[repr(C)]
pub struct AzSvgMultiPolygon {
    pub rings: AzSvgPathVec,
}

/// Re-export of rust-allocated (stack based) `TessellatedGPUSvgNode` struct
#[repr(C)]
pub struct AzTessellatedGPUSvgNode {
    pub vertex_index_buffer: AzVertexBuffer,
}

/// Re-export of rust-allocated (stack based) `XmlNode` struct
#[repr(C)]
pub struct AzXmlNode {
    pub tag: AzString,
    pub attributes: AzStringPairVec,
    pub children: AzXmlNodeVec,
    pub text: AzOptionStringEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<NodeTypeIdInfoMap>`
#[repr(C)]
pub struct AzNodeTypeIdInfoMapVec {
    pub(crate) ptr: *const AzNodeTypeIdInfoMap,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNodeTypeIdInfoMapVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<InputOutputTypeIdInfoMap>`
#[repr(C)]
pub struct AzInputOutputTypeIdInfoMapVec {
    pub(crate) ptr: *const AzInputOutputTypeIdInfoMap,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<NodeTypeField>`
#[repr(C)]
pub struct AzNodeTypeFieldVec {
    pub(crate) ptr: *const AzNodeTypeField,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNodeTypeFieldVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<InlineLine>`
#[repr(C)]
pub struct AzInlineLineVec {
    pub(crate) ptr: *const AzInlineLine,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzInlineLineVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<CssProperty>`
#[repr(C)]
pub struct AzCssPropertyVec {
    pub(crate) ptr: *const AzCssPropertyEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzCssPropertyVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<SvgMultiPolygon>`
#[repr(C)]
pub struct AzSvgMultiPolygonVec {
    pub(crate) ptr: *const AzSvgMultiPolygon,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzSvgMultiPolygonVecDestructorEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `OptionCssProperty` struct
#[repr(C, u8)]
pub enum AzOptionCssProperty {
    None,
    Some(AzCssProperty),
}

/// Re-export of rust-allocated (stack based) `XmlTextError` struct
#[repr(C)]
pub struct AzXmlTextError {
    pub stream_error: AzXmlStreamErrorEnumWrapper,
    pub pos: AzSvgParseErrorPosition,
}

/// Platform-specific window configuration, i.e. WM options that are not cross-platform
#[repr(C)]
pub struct AzPlatformSpecificOptions {
    pub windows_options: AzWindowsWindowOptions,
    pub linux_options: AzLinuxWindowOptions,
    pub mac_options: AzMacWindowOptions,
    pub wasm_options: AzWasmWindowOptions,
}

/// Re-export of rust-allocated (stack based) `WindowState` struct
#[repr(C)]
pub struct AzWindowState {
    pub title: AzString,
    pub theme: AzWindowThemeEnumWrapper,
    pub size: AzWindowSize,
    pub position: AzWindowPositionEnumWrapper,
    pub flags: AzWindowFlags,
    pub debug_state: AzDebugState,
    pub keyboard_state: AzKeyboardState,
    pub mouse_state: AzMouseState,
    pub touch_state: AzTouchState,
    pub ime_position: AzImePositionEnumWrapper,
    pub monitor: AzMonitor,
    pub platform_specific_options: AzPlatformSpecificOptions,
    pub renderer_options: AzRendererOptions,
    pub background_color: AzColorU,
    pub layout_callback: AzLayoutCallbackEnumWrapper,
    pub close_callback: AzOptionCallbackEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `CallbackInfo` struct
#[repr(C)]
pub struct AzCallbackInfo {
    pub css_property_cache: *const c_void,
    pub styled_node_states: *const c_void,
    pub previous_window_state: *const c_void,
    pub current_window_state: *const c_void,
    pub modifiable_window_state: *mut AzWindowState,
    pub gl_context: *const AzOptionGlEnumWrapper,
    pub image_cache: *mut c_void,
    pub system_fonts: *mut c_void,
    pub timers: *mut c_void,
    pub threads: *mut c_void,
    pub timers_removed: *mut c_void,
    pub threads_removed: *mut c_void,
    pub new_windows: *mut c_void,
    pub current_window_handle: *const AzRawWindowHandleEnumWrapper,
    pub node_hierarchy: *const c_void,
    pub system_callbacks: *const AzSystemCallbacks,
    pub fonts: *const c_void,
    pub datasets: *mut c_void,
    pub stop_propagation: *mut bool,
    pub focus_target: *mut c_void,
    pub words_cache: *const c_void,
    pub shaped_words_cache: *const c_void,
    pub positioned_words_cache: *const c_void,
    pub positioned_rects: *const c_void,
    pub words_changed_in_callbacks: *mut c_void,
    pub images_changed_in_callbacks: *mut c_void,
    pub image_masks_changed_in_callbacks: *mut c_void,
    pub css_properties_changed_in_callbacks: *mut c_void,
    pub current_scroll_states: *const c_void,
    pub nodes_scrolled_in_callback: *mut c_void,
    pub hit_dom_node: AzDomNodeId,
    pub cursor_relative_to_item: AzOptionLogicalPositionEnumWrapper,
    pub cursor_in_viewport: AzOptionLogicalPositionEnumWrapper,
    pub _reserved_ref: *const c_void,
    pub _reserved_mut: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `InlineText` struct
#[repr(C)]
pub struct AzInlineText {
    pub lines: AzInlineLineVec,
    pub content_size: AzLogicalSize,
    pub font_size_px: f32,
    pub last_word_index: usize,
    pub baseline_descender_px: f32,
}

/// CSS path to set the keyboard input focus
#[repr(C)]
pub struct AzFocusTargetPath {
    pub dom: AzDomId,
    pub css_path: AzCssPath,
}

/// Animation struct to start a new animation
#[repr(C)]
pub struct AzAnimation {
    pub from: AzCssPropertyEnumWrapper,
    pub to: AzCssPropertyEnumWrapper,
    pub duration: AzDurationEnumWrapper,
    pub repeat: AzAnimationRepeatEnumWrapper,
    pub repeat_count: AzAnimationRepeatCountEnumWrapper,
    pub easing: AzAnimationEasingEnumWrapper,
    pub relayout_on_finish: bool,
}

/// Re-export of rust-allocated (stack based) `TimerCallbackInfo` struct
#[repr(C)]
pub struct AzTimerCallbackInfo {
    pub callback_info: AzCallbackInfo,
    pub node_id: AzOptionDomNodeIdEnumWrapper,
    pub frame_start: AzInstantEnumWrapper,
    pub call_count: usize,
    pub is_about_to_finish: bool,
    pub _reserved_ref: *const c_void,
    pub _reserved_mut: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `NodeDataInlineCssProperty` struct
#[repr(C, u8)]
pub enum AzNodeDataInlineCssProperty {
    Normal(AzCssProperty),
    Active(AzCssProperty),
    Focus(AzCssProperty),
    Hover(AzCssProperty),
}

/// Re-export of rust-allocated (stack based) `DynamicCssProperty` struct
#[repr(C)]
pub struct AzDynamicCssProperty {
    pub dynamic_id: AzString,
    pub default_value: AzCssPropertyEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `Node` struct
#[repr(C)]
pub struct AzNode {
    pub node_type: AzNodeTypeId,
    pub position: AzNodePosition,
    pub fields: AzNodeTypeFieldVec,
    pub connect_in: AzInputConnectionVec,
    pub connect_out: AzOutputConnectionVec,
}

/// Re-export of rust-allocated (stack based) `SvgNode` struct
#[repr(C, u8)]
pub enum AzSvgNode {
    MultiPolygonCollection(AzSvgMultiPolygonVec),
    MultiPolygon(AzSvgMultiPolygon),
    Path(AzSvgPath),
    Circle(AzSvgCircle),
    Rect(AzSvgRect),
}

/// Re-export of rust-allocated (stack based) `SvgStyledNode` struct
#[repr(C)]
pub struct AzSvgStyledNode {
    pub geometry: AzSvgNodeEnumWrapper,
    pub style: AzSvgStyleEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<NodeDataInlineCssProperty>`
#[repr(C)]
pub struct AzNodeDataInlineCssPropertyVec {
    pub(crate) ptr: *const AzNodeDataInlineCssPropertyEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNodeDataInlineCssPropertyVecDestructorEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `OptionWindowState` struct
#[repr(C, u8)]
pub enum AzOptionWindowState {
    None,
    Some(AzWindowState),
}

/// Re-export of rust-allocated (stack based) `OptionInlineText` struct
#[repr(C, u8)]
pub enum AzOptionInlineText {
    None,
    Some(AzInlineText),
}

/// Re-export of rust-allocated (stack based) `XmlParseError` struct
#[repr(C, u8)]
pub enum AzXmlParseError {
    InvalidDeclaration(AzXmlTextError),
    InvalidComment(AzXmlTextError),
    InvalidPI(AzXmlTextError),
    InvalidDoctype(AzXmlTextError),
    InvalidEntity(AzXmlTextError),
    InvalidElement(AzXmlTextError),
    InvalidAttribute(AzXmlTextError),
    InvalidCdata(AzXmlTextError),
    InvalidCharData(AzXmlTextError),
    UnknownToken(AzSvgParseErrorPosition),
}

/// Options on how to initially create the window
#[repr(C)]
pub struct AzWindowCreateOptions {
    pub state: AzWindowState,
    pub size_to_content: bool,
    pub renderer_type: AzOptionRendererOptionsEnumWrapper,
    pub theme: AzOptionWindowThemeEnumWrapper,
    pub create_callback: AzOptionCallbackEnumWrapper,
    pub hot_reload: bool,
}

/// Defines the keyboard input focus target
#[repr(C, u8)]
pub enum AzFocusTarget {
    Id(AzDomNodeId),
    Path(AzFocusTargetPath),
    Previous,
    Next,
    First,
    Last,
    NoFocus,
}

/// Represents one single DOM node (node type, classes, ids and callbacks are stored here)
#[repr(C)]
pub struct AzNodeData {
    pub node_type: AzNodeTypeEnumWrapper,
    pub dataset: AzOptionRefAnyEnumWrapper,
    pub ids_and_classes: AzIdOrClassVec,
    pub callbacks: AzCallbackDataVec,
    pub inline_css_props: AzNodeDataInlineCssPropertyVec,
    pub tab_index: AzOptionTabIndexEnumWrapper,
    pub extra: *const c_void,
}

/// Re-export of rust-allocated (stack based) `CssDeclaration` struct
#[repr(C, u8)]
pub enum AzCssDeclaration {
    Static(AzCssProperty),
    Dynamic(AzDynamicCssProperty),
}

/// Re-export of rust-allocated (stack based) `Button` struct
#[repr(C)]
pub struct AzButton {
    pub label: AzString,
    pub image: AzOptionImageRefEnumWrapper,
    pub container_style: AzNodeDataInlineCssPropertyVec,
    pub label_style: AzNodeDataInlineCssPropertyVec,
    pub image_style: AzNodeDataInlineCssPropertyVec,
    pub on_click: AzOptionButtonOnClickEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `CheckBox` struct
#[repr(C)]
pub struct AzCheckBox {
    pub state: AzCheckBoxStateWrapper,
    pub container_style: AzNodeDataInlineCssPropertyVec,
    pub content_style: AzNodeDataInlineCssPropertyVec,
}

/// Re-export of rust-allocated (stack based) `Label` struct
#[repr(C)]
pub struct AzLabel {
    pub text: AzString,
    pub style: AzNodeDataInlineCssPropertyVec,
}

/// Re-export of rust-allocated (stack based) `ColorInput` struct
#[repr(C)]
pub struct AzColorInput {
    pub state: AzColorInputStateWrapper,
    pub style: AzNodeDataInlineCssPropertyVec,
}

/// Re-export of rust-allocated (stack based) `TextInput` struct
#[repr(C)]
pub struct AzTextInput {
    pub state: AzTextInputStateWrapper,
    pub placeholder_style: AzNodeDataInlineCssPropertyVec,
    pub container_style: AzNodeDataInlineCssPropertyVec,
    pub label_style: AzNodeDataInlineCssPropertyVec,
}

/// Re-export of rust-allocated (stack based) `NumberInput` struct
#[repr(C)]
pub struct AzNumberInput {
    pub text_input: AzTextInput,
    pub state: AzNumberInputStateWrapper,
}

/// Re-export of rust-allocated (stack based) `NodeIdNodeMap` struct
#[repr(C)]
pub struct AzNodeIdNodeMap {
    pub node_id: AzNodeGraphNodeId,
    pub node: AzNode,
}

/// Wrapper over a Rust-allocated `Vec<NodeIdNodeMap>`
#[repr(C)]
pub struct AzNodeIdNodeMapVec {
    pub(crate) ptr: *const AzNodeIdNodeMap,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNodeIdNodeMapVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `CssDeclaration`
#[repr(C)]
pub struct AzCssDeclarationVec {
    pub(crate) ptr: *const AzCssDeclarationEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzCssDeclarationVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `NodeDataVec`
#[repr(C)]
pub struct AzNodeDataVec {
    pub(crate) ptr: *const AzNodeData,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNodeDataVecDestructorEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `XmlError` struct
#[repr(C, u8)]
pub enum AzXmlError {
    NoParserAvailable,
    InvalidXmlPrefixUri(AzSvgParseErrorPosition),
    UnexpectedXmlUri(AzSvgParseErrorPosition),
    UnexpectedXmlnsUri(AzSvgParseErrorPosition),
    InvalidElementNamePrefix(AzSvgParseErrorPosition),
    DuplicatedNamespace(AzDuplicatedNamespaceError),
    UnknownNamespace(AzUnknownNamespaceError),
    UnexpectedCloseTag(AzUnexpectedCloseTagError),
    UnexpectedEntityCloseTag(AzSvgParseErrorPosition),
    UnknownEntityReference(AzUnknownEntityReferenceError),
    MalformedEntityReference(AzSvgParseErrorPosition),
    EntityReferenceLoop(AzSvgParseErrorPosition),
    InvalidAttributeValue(AzSvgParseErrorPosition),
    DuplicatedAttribute(AzDuplicatedAttributeError),
    NoRootNode,
    SizeLimit,
    ParserError(AzXmlParseError),
}

/// Re-export of rust-allocated (stack based) `Dom` struct
#[repr(C)]
pub struct AzDom {
    pub root: AzNodeData,
    pub children: AzDomVec,
    pub total_children: usize,
}

/// Re-export of rust-allocated (stack based) `CssRuleBlock` struct
#[repr(C)]
pub struct AzCssRuleBlock {
    pub path: AzCssPath,
    pub declarations: AzCssDeclarationVec,
}

/// Re-export of rust-allocated (stack based) `Tab` struct
#[repr(C)]
pub struct AzTab {
    pub title: AzString,
    pub content: AzDom,
}

/// Re-export of rust-allocated (stack based) `Frame` struct
#[repr(C)]
pub struct AzFrame {
    pub title: AzString,
    pub flex_grow: f32,
    pub content: AzDom,
}

/// Re-export of rust-allocated (stack based) `NodeGraph` struct
#[repr(C)]
pub struct AzNodeGraph {
    pub node_types: AzNodeTypeIdInfoMapVec,
    pub input_output_types: AzInputOutputTypeIdInfoMapVec,
    pub nodes: AzNodeIdNodeMapVec,
    pub allow_multiple_root_nodes: bool,
    pub offset: AzLogicalPosition,
    pub style: AzNodeGraphStyleEnumWrapper,
    pub callbacks: AzNodeGraphCallbacks,
    pub add_node_str: AzString,
}

/// Re-export of rust-allocated (stack based) `StyledDom` struct
#[repr(C)]
pub struct AzStyledDom {
    pub root: AzNodeId,
    pub node_hierarchy: AzNodeHierarchyItemVec,
    pub node_data: AzNodeDataVec,
    pub styled_nodes: AzStyledNodeVec,
    pub cascade_info: AzCascadeInfoVec,
    pub nodes_with_window_callbacks: AzNodeIdVec,
    pub nodes_with_not_callbacks: AzNodeIdVec,
    pub nodes_with_datasets_and_callbacks: AzNodeIdVec,
    pub tag_ids_to_node_ids: AzTagIdToNodeIdMappingVec,
    pub non_leaf_nodes: AzParentWithNodeDepthVec,
    pub css_property_cache: AzCssPropertyCache,
}

/// Wrapper over a Rust-allocated `Vec<Tab>`
#[repr(C)]
pub struct AzTabVec {
    pub(crate) ptr: *const AzTab,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzTabVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `CssRuleBlock`
#[repr(C)]
pub struct AzCssRuleBlockVec {
    pub(crate) ptr: *const AzCssRuleBlock,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzCssRuleBlockVecDestructorEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `OptionDom` struct
#[repr(C, u8)]
pub enum AzOptionDom {
    None,
    Some(AzDom),
}

/// Re-export of rust-allocated (stack based) `ResultXmlXmlError` struct
#[repr(C, u8)]
pub enum AzResultXmlXmlError {
    Ok(AzXml),
    Err(AzXmlError),
}

/// Re-export of rust-allocated (stack based) `SvgParseError` struct
#[repr(C, u8)]
pub enum AzSvgParseError {
    NoParserAvailable,
    InvalidFileSuffix,
    FileOpenFailed,
    NotAnUtf8Str,
    MalformedGZip,
    InvalidSize,
    ParsingFailed(AzXmlError),
}

/// <img src="../images/scrollbounds.png"/>
#[repr(C)]
pub struct AzIFrameCallbackReturn {
    pub dom: AzStyledDom,
    pub scroll_size: AzLogicalSize,
    pub scroll_offset: AzLogicalPosition,
    pub virtual_scroll_size: AzLogicalSize,
    pub virtual_scroll_offset: AzLogicalPosition,
}

/// Re-export of rust-allocated (stack based) `Stylesheet` struct
#[repr(C)]
pub struct AzStylesheet {
    pub rules: AzCssRuleBlockVec,
}

/// Re-export of rust-allocated (stack based) `TabContainer` struct
#[repr(C)]
pub struct AzTabContainer {
    pub tabs: AzTabVec,
    pub active_tab: usize,
    pub has_padding: bool,
}

/// Wrapper over a Rust-allocated `Stylesheet`
#[repr(C)]
pub struct AzStylesheetVec {
    pub(crate) ptr: *const AzStylesheet,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStylesheetVecDestructorEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `ResultSvgXmlNodeSvgParseError` struct
#[repr(C, u8)]
pub enum AzResultSvgXmlNodeSvgParseError {
    Ok(AzSvgXmlNode),
    Err(AzSvgParseError),
}

/// Re-export of rust-allocated (stack based) `ResultSvgSvgParseError` struct
#[repr(C, u8)]
pub enum AzResultSvgSvgParseError {
    Ok(AzSvg),
    Err(AzSvgParseError),
}

/// Re-export of rust-allocated (stack based) `Css` struct
#[repr(C)]
pub struct AzCss {
    pub stylesheets: AzStylesheetVec,
}

/// `AzAppLogLevelEnumWrapper` struct
#[repr(transparent)]
pub struct AzAppLogLevelEnumWrapper {
    pub inner: AzAppLogLevel,
}

/// `AzLayoutSolverEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutSolverEnumWrapper {
    pub inner: AzLayoutSolver,
}

/// `AzVsyncEnumWrapper` struct
#[repr(transparent)]
pub struct AzVsyncEnumWrapper {
    pub inner: AzVsync,
}

/// `AzSrgbEnumWrapper` struct
#[repr(transparent)]
pub struct AzSrgbEnumWrapper {
    pub inner: AzSrgb,
}

/// `AzHwAccelerationEnumWrapper` struct
#[repr(transparent)]
pub struct AzHwAccelerationEnumWrapper {
    pub inner: AzHwAcceleration,
}

/// `AzXWindowTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzXWindowTypeEnumWrapper {
    pub inner: AzXWindowType,
}

/// `AzVirtualKeyCodeEnumWrapper` struct
#[repr(transparent)]
pub struct AzVirtualKeyCodeEnumWrapper {
    pub inner: AzVirtualKeyCode,
}

/// `AzWindowFrameEnumWrapper` struct
#[repr(transparent)]
pub struct AzWindowFrameEnumWrapper {
    pub inner: AzWindowFrame,
}

/// `AzMouseCursorTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzMouseCursorTypeEnumWrapper {
    pub inner: AzMouseCursorType,
}

/// `AzRendererTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzRendererTypeEnumWrapper {
    pub inner: AzRendererType,
}

/// `AzFullScreenModeEnumWrapper` struct
#[repr(transparent)]
pub struct AzFullScreenModeEnumWrapper {
    pub inner: AzFullScreenMode,
}

/// `AzWindowThemeEnumWrapper` struct
#[repr(transparent)]
pub struct AzWindowThemeEnumWrapper {
    pub inner: AzWindowTheme,
}

/// `AzUpdateImageTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzUpdateImageTypeEnumWrapper {
    pub inner: AzUpdateImageType,
}

/// `AzUpdateEnumWrapper` struct
#[repr(transparent)]
pub struct AzUpdateEnumWrapper {
    pub inner: AzUpdate,
}

/// `AzAnimationRepeatEnumWrapper` struct
#[repr(transparent)]
pub struct AzAnimationRepeatEnumWrapper {
    pub inner: AzAnimationRepeat,
}

/// `AzAnimationRepeatCountEnumWrapper` struct
#[repr(transparent)]
pub struct AzAnimationRepeatCountEnumWrapper {
    pub inner: AzAnimationRepeatCount,
}

/// `AzOnEnumWrapper` struct
#[repr(transparent)]
pub struct AzOnEnumWrapper {
    pub inner: AzOn,
}

/// `AzHoverEventFilterEnumWrapper` struct
#[repr(transparent)]
pub struct AzHoverEventFilterEnumWrapper {
    pub inner: AzHoverEventFilter,
}

/// `AzFocusEventFilterEnumWrapper` struct
#[repr(transparent)]
pub struct AzFocusEventFilterEnumWrapper {
    pub inner: AzFocusEventFilter,
}

/// `AzWindowEventFilterEnumWrapper` struct
#[repr(transparent)]
pub struct AzWindowEventFilterEnumWrapper {
    pub inner: AzWindowEventFilter,
}

/// `AzComponentEventFilterEnumWrapper` struct
#[repr(transparent)]
pub struct AzComponentEventFilterEnumWrapper {
    pub inner: AzComponentEventFilter,
}

/// `AzApplicationEventFilterEnumWrapper` struct
#[repr(transparent)]
pub struct AzApplicationEventFilterEnumWrapper {
    pub inner: AzApplicationEventFilter,
}

/// `AzAccessibilityRoleEnumWrapper` struct
#[repr(transparent)]
pub struct AzAccessibilityRoleEnumWrapper {
    pub inner: AzAccessibilityRole,
}

/// `AzAccessibilityStateEnumWrapper` struct
#[repr(transparent)]
pub struct AzAccessibilityStateEnumWrapper {
    pub inner: AzAccessibilityState,
}

/// `AzTabIndexEnumWrapper` struct
#[repr(transparent)]
pub struct AzTabIndexEnumWrapper {
    pub inner: AzTabIndex,
}

/// `AzContextMenuMouseButtonEnumWrapper` struct
#[repr(transparent)]
pub struct AzContextMenuMouseButtonEnumWrapper {
    pub inner: AzContextMenuMouseButton,
}

/// `AzMenuPopupPositionEnumWrapper` struct
#[repr(transparent)]
pub struct AzMenuPopupPositionEnumWrapper {
    pub inner: AzMenuPopupPosition,
}

/// `AzMenuItemStateEnumWrapper` struct
#[repr(transparent)]
pub struct AzMenuItemStateEnumWrapper {
    pub inner: AzMenuItemState,
}

/// `AzNodeTypeKeyEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeTypeKeyEnumWrapper {
    pub inner: AzNodeTypeKey,
}

/// `AzCssPropertyTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssPropertyTypeEnumWrapper {
    pub inner: AzCssPropertyType,
}

/// `AzSizeMetricEnumWrapper` struct
#[repr(transparent)]
pub struct AzSizeMetricEnumWrapper {
    pub inner: AzSizeMetric,
}

/// `AzBoxShadowClipModeEnumWrapper` struct
#[repr(transparent)]
pub struct AzBoxShadowClipModeEnumWrapper {
    pub inner: AzBoxShadowClipMode,
}

/// `AzLayoutAlignContentEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutAlignContentEnumWrapper {
    pub inner: AzLayoutAlignContent,
}

/// `AzLayoutAlignItemsEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutAlignItemsEnumWrapper {
    pub inner: AzLayoutAlignItems,
}

/// `AzLayoutBoxSizingEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutBoxSizingEnumWrapper {
    pub inner: AzLayoutBoxSizing,
}

/// `AzLayoutFlexDirectionEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutFlexDirectionEnumWrapper {
    pub inner: AzLayoutFlexDirection,
}

/// `AzLayoutDisplayEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutDisplayEnumWrapper {
    pub inner: AzLayoutDisplay,
}

/// `AzLayoutFloatEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutFloatEnumWrapper {
    pub inner: AzLayoutFloat,
}

/// `AzLayoutJustifyContentEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutJustifyContentEnumWrapper {
    pub inner: AzLayoutJustifyContent,
}

/// `AzLayoutPositionEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutPositionEnumWrapper {
    pub inner: AzLayoutPosition,
}

/// `AzLayoutFlexWrapEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutFlexWrapEnumWrapper {
    pub inner: AzLayoutFlexWrap,
}

/// `AzLayoutOverflowEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutOverflowEnumWrapper {
    pub inner: AzLayoutOverflow,
}

/// `AzAngleMetricEnumWrapper` struct
#[repr(transparent)]
pub struct AzAngleMetricEnumWrapper {
    pub inner: AzAngleMetric,
}

/// `AzDirectionCornerEnumWrapper` struct
#[repr(transparent)]
pub struct AzDirectionCornerEnumWrapper {
    pub inner: AzDirectionCorner,
}

/// `AzExtendModeEnumWrapper` struct
#[repr(transparent)]
pub struct AzExtendModeEnumWrapper {
    pub inner: AzExtendMode,
}

/// `AzShapeEnumWrapper` struct
#[repr(transparent)]
pub struct AzShapeEnumWrapper {
    pub inner: AzShape,
}

/// `AzRadialGradientSizeEnumWrapper` struct
#[repr(transparent)]
pub struct AzRadialGradientSizeEnumWrapper {
    pub inner: AzRadialGradientSize,
}

/// `AzStyleBackgroundRepeatEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundRepeatEnumWrapper {
    pub inner: AzStyleBackgroundRepeat,
}

/// `AzBorderStyleEnumWrapper` struct
#[repr(transparent)]
pub struct AzBorderStyleEnumWrapper {
    pub inner: AzBorderStyle,
}

/// `AzStyleCursorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleCursorEnumWrapper {
    pub inner: AzStyleCursor,
}

/// `AzStyleBackfaceVisibilityEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackfaceVisibilityEnumWrapper {
    pub inner: AzStyleBackfaceVisibility,
}

/// `AzStyleTextAlignEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleTextAlignEnumWrapper {
    pub inner: AzStyleTextAlign,
}

/// `AzTextInputValidEnumWrapper` struct
#[repr(transparent)]
pub struct AzTextInputValidEnumWrapper {
    pub inner: AzTextInputValid,
}

/// `AzNodeGraphStyleEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeGraphStyleEnumWrapper {
    pub inner: AzNodeGraphStyle,
}

/// `AzVertexAttributeTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzVertexAttributeTypeEnumWrapper {
    pub inner: AzVertexAttributeType,
}

/// `AzIndexBufferFormatEnumWrapper` struct
#[repr(transparent)]
pub struct AzIndexBufferFormatEnumWrapper {
    pub inner: AzIndexBufferFormat,
}

/// `AzGlTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzGlTypeEnumWrapper {
    pub inner: AzGlType,
}

/// `AzRawImageFormatEnumWrapper` struct
#[repr(transparent)]
pub struct AzRawImageFormatEnumWrapper {
    pub inner: AzRawImageFormat,
}

/// `AzEncodeImageErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzEncodeImageErrorEnumWrapper {
    pub inner: AzEncodeImageError,
}

/// `AzDecodeImageErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzDecodeImageErrorEnumWrapper {
    pub inner: AzDecodeImageError,
}

/// `AzShapeRenderingEnumWrapper` struct
#[repr(transparent)]
pub struct AzShapeRenderingEnumWrapper {
    pub inner: AzShapeRendering,
}

/// `AzTextRenderingEnumWrapper` struct
#[repr(transparent)]
pub struct AzTextRenderingEnumWrapper {
    pub inner: AzTextRendering,
}

/// `AzImageRenderingEnumWrapper` struct
#[repr(transparent)]
pub struct AzImageRenderingEnumWrapper {
    pub inner: AzImageRendering,
}

/// `AzFontDatabaseEnumWrapper` struct
#[repr(transparent)]
pub struct AzFontDatabaseEnumWrapper {
    pub inner: AzFontDatabase,
}

/// `AzIndentEnumWrapper` struct
#[repr(transparent)]
pub struct AzIndentEnumWrapper {
    pub inner: AzIndent,
}

/// `AzSvgFitToEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgFitToEnumWrapper {
    pub inner: AzSvgFitTo,
}

/// `AzSvgFillRuleEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgFillRuleEnumWrapper {
    pub inner: AzSvgFillRule,
}

/// `AzSvgLineJoinEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgLineJoinEnumWrapper {
    pub inner: AzSvgLineJoin,
}

/// `AzSvgLineCapEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgLineCapEnumWrapper {
    pub inner: AzSvgLineCap,
}

/// `AzMsgBoxIconEnumWrapper` struct
#[repr(transparent)]
pub struct AzMsgBoxIconEnumWrapper {
    pub inner: AzMsgBoxIcon,
}

/// `AzMsgBoxYesNoEnumWrapper` struct
#[repr(transparent)]
pub struct AzMsgBoxYesNoEnumWrapper {
    pub inner: AzMsgBoxYesNo,
}

/// `AzMsgBoxOkCancelEnumWrapper` struct
#[repr(transparent)]
pub struct AzMsgBoxOkCancelEnumWrapper {
    pub inner: AzMsgBoxOkCancel,
}

/// `AzTerminateTimerEnumWrapper` struct
#[repr(transparent)]
pub struct AzTerminateTimerEnumWrapper {
    pub inner: AzTerminateTimer,
}

/// `AzStyleFontFamilyVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleFontFamilyVecDestructorEnumWrapper {
    pub inner: AzStyleFontFamilyVecDestructor,
}

/// `AzLogicalRectVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzLogicalRectVecDestructorEnumWrapper {
    pub inner: AzLogicalRectVecDestructor,
}

/// `AzNodeTypeIdInfoMapVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
    pub inner: AzNodeTypeIdInfoMapVecDestructor,
}

/// `AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
    pub inner: AzInputOutputTypeIdInfoMapVecDestructor,
}

/// `AzNodeIdNodeMapVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeIdNodeMapVecDestructorEnumWrapper {
    pub inner: AzNodeIdNodeMapVecDestructor,
}

/// `AzInputOutputTypeIdVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzInputOutputTypeIdVecDestructorEnumWrapper {
    pub inner: AzInputOutputTypeIdVecDestructor,
}

/// `AzNodeTypeFieldVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeTypeFieldVecDestructorEnumWrapper {
    pub inner: AzNodeTypeFieldVecDestructor,
}

/// `AzInputConnectionVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzInputConnectionVecDestructorEnumWrapper {
    pub inner: AzInputConnectionVecDestructor,
}

/// `AzOutputNodeAndIndexVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzOutputNodeAndIndexVecDestructorEnumWrapper {
    pub inner: AzOutputNodeAndIndexVecDestructor,
}

/// `AzOutputConnectionVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzOutputConnectionVecDestructorEnumWrapper {
    pub inner: AzOutputConnectionVecDestructor,
}

/// `AzInputNodeAndIndexVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzInputNodeAndIndexVecDestructorEnumWrapper {
    pub inner: AzInputNodeAndIndexVecDestructor,
}

/// `AzTabVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzTabVecDestructorEnumWrapper {
    pub inner: AzTabVecDestructor,
}

/// `AzAccessibilityStateVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzAccessibilityStateVecDestructorEnumWrapper {
    pub inner: AzAccessibilityStateVecDestructor,
}

/// `AzMenuItemVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzMenuItemVecDestructorEnumWrapper {
    pub inner: AzMenuItemVecDestructor,
}

/// `AzTessellatedSvgNodeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzTessellatedSvgNodeVecDestructorEnumWrapper {
    pub inner: AzTessellatedSvgNodeVecDestructor,
}

/// `AzXmlNodeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzXmlNodeVecDestructorEnumWrapper {
    pub inner: AzXmlNodeVecDestructor,
}

/// `AzFmtArgVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzFmtArgVecDestructorEnumWrapper {
    pub inner: AzFmtArgVecDestructor,
}

/// `AzInlineLineVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzInlineLineVecDestructorEnumWrapper {
    pub inner: AzInlineLineVecDestructor,
}

/// `AzInlineWordVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzInlineWordVecDestructorEnumWrapper {
    pub inner: AzInlineWordVecDestructor,
}

/// `AzInlineGlyphVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzInlineGlyphVecDestructorEnumWrapper {
    pub inner: AzInlineGlyphVecDestructor,
}

/// `AzInlineTextHitVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzInlineTextHitVecDestructorEnumWrapper {
    pub inner: AzInlineTextHitVecDestructor,
}

/// `AzMonitorVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzMonitorVecDestructorEnumWrapper {
    pub inner: AzMonitorVecDestructor,
}

/// `AzVideoModeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzVideoModeVecDestructorEnumWrapper {
    pub inner: AzVideoModeVecDestructor,
}

/// `AzDomVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzDomVecDestructorEnumWrapper {
    pub inner: AzDomVecDestructor,
}

/// `AzIdOrClassVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzIdOrClassVecDestructorEnumWrapper {
    pub inner: AzIdOrClassVecDestructor,
}

/// `AzNodeDataInlineCssPropertyVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
    pub inner: AzNodeDataInlineCssPropertyVecDestructor,
}

/// `AzStyleBackgroundContentVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundContentVecDestructorEnumWrapper {
    pub inner: AzStyleBackgroundContentVecDestructor,
}

/// `AzStyleBackgroundPositionVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundPositionVecDestructorEnumWrapper {
    pub inner: AzStyleBackgroundPositionVecDestructor,
}

/// `AzStyleBackgroundRepeatVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundRepeatVecDestructorEnumWrapper {
    pub inner: AzStyleBackgroundRepeatVecDestructor,
}

/// `AzStyleBackgroundSizeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundSizeVecDestructorEnumWrapper {
    pub inner: AzStyleBackgroundSizeVecDestructor,
}

/// `AzStyleTransformVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleTransformVecDestructorEnumWrapper {
    pub inner: AzStyleTransformVecDestructor,
}

/// `AzCssPropertyVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssPropertyVecDestructorEnumWrapper {
    pub inner: AzCssPropertyVecDestructor,
}

/// `AzSvgMultiPolygonVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgMultiPolygonVecDestructorEnumWrapper {
    pub inner: AzSvgMultiPolygonVecDestructor,
}

/// `AzSvgPathVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgPathVecDestructorEnumWrapper {
    pub inner: AzSvgPathVecDestructor,
}

/// `AzVertexAttributeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzVertexAttributeVecDestructorEnumWrapper {
    pub inner: AzVertexAttributeVecDestructor,
}

/// `AzSvgPathElementVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgPathElementVecDestructorEnumWrapper {
    pub inner: AzSvgPathElementVecDestructor,
}

/// `AzSvgVertexVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgVertexVecDestructorEnumWrapper {
    pub inner: AzSvgVertexVecDestructor,
}

/// `AzU32VecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzU32VecDestructorEnumWrapper {
    pub inner: AzU32VecDestructor,
}

/// `AzXWindowTypeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzXWindowTypeVecDestructorEnumWrapper {
    pub inner: AzXWindowTypeVecDestructor,
}

/// `AzVirtualKeyCodeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzVirtualKeyCodeVecDestructorEnumWrapper {
    pub inner: AzVirtualKeyCodeVecDestructor,
}

/// `AzCascadeInfoVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCascadeInfoVecDestructorEnumWrapper {
    pub inner: AzCascadeInfoVecDestructor,
}

/// `AzScanCodeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzScanCodeVecDestructorEnumWrapper {
    pub inner: AzScanCodeVecDestructor,
}

/// `AzCssDeclarationVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssDeclarationVecDestructorEnumWrapper {
    pub inner: AzCssDeclarationVecDestructor,
}

/// `AzCssPathSelectorVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssPathSelectorVecDestructorEnumWrapper {
    pub inner: AzCssPathSelectorVecDestructor,
}

/// `AzStylesheetVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStylesheetVecDestructorEnumWrapper {
    pub inner: AzStylesheetVecDestructor,
}

/// `AzCssRuleBlockVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssRuleBlockVecDestructorEnumWrapper {
    pub inner: AzCssRuleBlockVecDestructor,
}

/// `AzF32VecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzF32VecDestructorEnumWrapper {
    pub inner: AzF32VecDestructor,
}

/// `AzU16VecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzU16VecDestructorEnumWrapper {
    pub inner: AzU16VecDestructor,
}

/// `AzU8VecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzU8VecDestructorEnumWrapper {
    pub inner: AzU8VecDestructor,
}

/// `AzCallbackDataVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCallbackDataVecDestructorEnumWrapper {
    pub inner: AzCallbackDataVecDestructor,
}

/// `AzDebugMessageVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzDebugMessageVecDestructorEnumWrapper {
    pub inner: AzDebugMessageVecDestructor,
}

/// `AzGLuintVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzGLuintVecDestructorEnumWrapper {
    pub inner: AzGLuintVecDestructor,
}

/// `AzGLintVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzGLintVecDestructorEnumWrapper {
    pub inner: AzGLintVecDestructor,
}

/// `AzStringVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStringVecDestructorEnumWrapper {
    pub inner: AzStringVecDestructor,
}

/// `AzStringPairVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStringPairVecDestructorEnumWrapper {
    pub inner: AzStringPairVecDestructor,
}

/// `AzNormalizedLinearColorStopVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNormalizedLinearColorStopVecDestructorEnumWrapper {
    pub inner: AzNormalizedLinearColorStopVecDestructor,
}

/// `AzNormalizedRadialColorStopVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNormalizedRadialColorStopVecDestructorEnumWrapper {
    pub inner: AzNormalizedRadialColorStopVecDestructor,
}

/// `AzNodeIdVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeIdVecDestructorEnumWrapper {
    pub inner: AzNodeIdVecDestructor,
}

/// `AzNodeHierarchyItemVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeHierarchyItemVecDestructorEnumWrapper {
    pub inner: AzNodeHierarchyItemVecDestructor,
}

/// `AzStyledNodeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyledNodeVecDestructorEnumWrapper {
    pub inner: AzStyledNodeVecDestructor,
}

/// `AzTagIdToNodeIdMappingVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
    pub inner: AzTagIdToNodeIdMappingVecDestructor,
}

/// `AzParentWithNodeDepthVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzParentWithNodeDepthVecDestructorEnumWrapper {
    pub inner: AzParentWithNodeDepthVecDestructor,
}

/// `AzNodeDataVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeDataVecDestructorEnumWrapper {
    pub inner: AzNodeDataVecDestructor,
}

/// `AzOptionI16EnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionI16EnumWrapper {
    pub inner: AzOptionI16,
}

/// `AzOptionU16EnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionU16EnumWrapper {
    pub inner: AzOptionU16,
}

/// `AzOptionU32EnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionU32EnumWrapper {
    pub inner: AzOptionU32,
}

/// `AzOptionHwndHandleEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionHwndHandleEnumWrapper {
    pub inner: AzOptionHwndHandle,
}

/// `AzOptionX11VisualEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionX11VisualEnumWrapper {
    pub inner: AzOptionX11Visual,
}

/// `AzOptionI32EnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionI32EnumWrapper {
    pub inner: AzOptionI32,
}

/// `AzOptionF32EnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionF32EnumWrapper {
    pub inner: AzOptionF32,
}

/// `AzOptionCharEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionCharEnumWrapper {
    pub inner: AzOptionChar,
}

/// `AzOptionUsizeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionUsizeEnumWrapper {
    pub inner: AzOptionUsize,
}

/// `AzRawWindowHandleEnumWrapper` struct
#[repr(transparent)]
pub struct AzRawWindowHandleEnumWrapper {
    pub inner: AzRawWindowHandle,
}

/// `AzAcceleratorKeyEnumWrapper` struct
#[repr(transparent)]
pub struct AzAcceleratorKeyEnumWrapper {
    pub inner: AzAcceleratorKey,
}

/// `AzCursorPositionEnumWrapper` struct
#[repr(transparent)]
pub struct AzCursorPositionEnumWrapper {
    pub inner: AzCursorPosition,
}

/// `AzWindowPositionEnumWrapper` struct
#[repr(transparent)]
pub struct AzWindowPositionEnumWrapper {
    pub inner: AzWindowPosition,
}

/// `AzImePositionEnumWrapper` struct
#[repr(transparent)]
pub struct AzImePositionEnumWrapper {
    pub inner: AzImePosition,
}

/// `AzPositionInfoEnumWrapper` struct
#[repr(transparent)]
pub struct AzPositionInfoEnumWrapper {
    pub inner: AzPositionInfo,
}

/// `AzNotEventFilterEnumWrapper` struct
#[repr(transparent)]
pub struct AzNotEventFilterEnumWrapper {
    pub inner: AzNotEventFilter,
}

/// `AzMenuItemIconEnumWrapper` struct
#[repr(transparent)]
pub struct AzMenuItemIconEnumWrapper {
    pub inner: AzMenuItemIcon,
}

/// `AzCssNthChildSelectorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssNthChildSelectorEnumWrapper {
    pub inner: AzCssNthChildSelector,
}

/// `AzDirectionEnumWrapper` struct
#[repr(transparent)]
pub struct AzDirectionEnumWrapper {
    pub inner: AzDirection,
}

/// `AzBackgroundPositionHorizontalEnumWrapper` struct
#[repr(transparent)]
pub struct AzBackgroundPositionHorizontalEnumWrapper {
    pub inner: AzBackgroundPositionHorizontal,
}

/// `AzBackgroundPositionVerticalEnumWrapper` struct
#[repr(transparent)]
pub struct AzBackgroundPositionVerticalEnumWrapper {
    pub inner: AzBackgroundPositionVertical,
}

/// `AzStyleBackgroundSizeEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundSizeEnumWrapper {
    pub inner: AzStyleBackgroundSize,
}

/// `AzStyleBoxShadowValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBoxShadowValueEnumWrapper {
    pub inner: AzStyleBoxShadowValue,
}

/// `AzLayoutAlignContentValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutAlignContentValueEnumWrapper {
    pub inner: AzLayoutAlignContentValue,
}

/// `AzLayoutAlignItemsValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutAlignItemsValueEnumWrapper {
    pub inner: AzLayoutAlignItemsValue,
}

/// `AzLayoutBottomValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutBottomValueEnumWrapper {
    pub inner: AzLayoutBottomValue,
}

/// `AzLayoutBoxSizingValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutBoxSizingValueEnumWrapper {
    pub inner: AzLayoutBoxSizingValue,
}

/// `AzLayoutFlexDirectionValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutFlexDirectionValueEnumWrapper {
    pub inner: AzLayoutFlexDirectionValue,
}

/// `AzLayoutDisplayValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutDisplayValueEnumWrapper {
    pub inner: AzLayoutDisplayValue,
}

/// `AzLayoutFlexGrowValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutFlexGrowValueEnumWrapper {
    pub inner: AzLayoutFlexGrowValue,
}

/// `AzLayoutFlexShrinkValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutFlexShrinkValueEnumWrapper {
    pub inner: AzLayoutFlexShrinkValue,
}

/// `AzLayoutFloatValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutFloatValueEnumWrapper {
    pub inner: AzLayoutFloatValue,
}

/// `AzLayoutHeightValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutHeightValueEnumWrapper {
    pub inner: AzLayoutHeightValue,
}

/// `AzLayoutJustifyContentValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutJustifyContentValueEnumWrapper {
    pub inner: AzLayoutJustifyContentValue,
}

/// `AzLayoutLeftValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutLeftValueEnumWrapper {
    pub inner: AzLayoutLeftValue,
}

/// `AzLayoutMarginBottomValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutMarginBottomValueEnumWrapper {
    pub inner: AzLayoutMarginBottomValue,
}

/// `AzLayoutMarginLeftValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutMarginLeftValueEnumWrapper {
    pub inner: AzLayoutMarginLeftValue,
}

/// `AzLayoutMarginRightValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutMarginRightValueEnumWrapper {
    pub inner: AzLayoutMarginRightValue,
}

/// `AzLayoutMarginTopValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutMarginTopValueEnumWrapper {
    pub inner: AzLayoutMarginTopValue,
}

/// `AzLayoutMaxHeightValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutMaxHeightValueEnumWrapper {
    pub inner: AzLayoutMaxHeightValue,
}

/// `AzLayoutMaxWidthValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutMaxWidthValueEnumWrapper {
    pub inner: AzLayoutMaxWidthValue,
}

/// `AzLayoutMinHeightValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutMinHeightValueEnumWrapper {
    pub inner: AzLayoutMinHeightValue,
}

/// `AzLayoutMinWidthValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutMinWidthValueEnumWrapper {
    pub inner: AzLayoutMinWidthValue,
}

/// `AzLayoutPaddingBottomValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutPaddingBottomValueEnumWrapper {
    pub inner: AzLayoutPaddingBottomValue,
}

/// `AzLayoutPaddingLeftValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutPaddingLeftValueEnumWrapper {
    pub inner: AzLayoutPaddingLeftValue,
}

/// `AzLayoutPaddingRightValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutPaddingRightValueEnumWrapper {
    pub inner: AzLayoutPaddingRightValue,
}

/// `AzLayoutPaddingTopValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutPaddingTopValueEnumWrapper {
    pub inner: AzLayoutPaddingTopValue,
}

/// `AzLayoutPositionValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutPositionValueEnumWrapper {
    pub inner: AzLayoutPositionValue,
}

/// `AzLayoutRightValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutRightValueEnumWrapper {
    pub inner: AzLayoutRightValue,
}

/// `AzLayoutTopValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutTopValueEnumWrapper {
    pub inner: AzLayoutTopValue,
}

/// `AzLayoutWidthValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutWidthValueEnumWrapper {
    pub inner: AzLayoutWidthValue,
}

/// `AzLayoutFlexWrapValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutFlexWrapValueEnumWrapper {
    pub inner: AzLayoutFlexWrapValue,
}

/// `AzLayoutOverflowValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutOverflowValueEnumWrapper {
    pub inner: AzLayoutOverflowValue,
}

/// `AzStyleBorderBottomColorValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderBottomColorValueEnumWrapper {
    pub inner: AzStyleBorderBottomColorValue,
}

/// `AzStyleBorderBottomLeftRadiusValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderBottomLeftRadiusValueEnumWrapper {
    pub inner: AzStyleBorderBottomLeftRadiusValue,
}

/// `AzStyleBorderBottomRightRadiusValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderBottomRightRadiusValueEnumWrapper {
    pub inner: AzStyleBorderBottomRightRadiusValue,
}

/// `AzStyleBorderBottomStyleValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderBottomStyleValueEnumWrapper {
    pub inner: AzStyleBorderBottomStyleValue,
}

/// `AzLayoutBorderBottomWidthValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutBorderBottomWidthValueEnumWrapper {
    pub inner: AzLayoutBorderBottomWidthValue,
}

/// `AzStyleBorderLeftColorValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderLeftColorValueEnumWrapper {
    pub inner: AzStyleBorderLeftColorValue,
}

/// `AzStyleBorderLeftStyleValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderLeftStyleValueEnumWrapper {
    pub inner: AzStyleBorderLeftStyleValue,
}

/// `AzLayoutBorderLeftWidthValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutBorderLeftWidthValueEnumWrapper {
    pub inner: AzLayoutBorderLeftWidthValue,
}

/// `AzStyleBorderRightColorValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderRightColorValueEnumWrapper {
    pub inner: AzStyleBorderRightColorValue,
}

/// `AzStyleBorderRightStyleValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderRightStyleValueEnumWrapper {
    pub inner: AzStyleBorderRightStyleValue,
}

/// `AzLayoutBorderRightWidthValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutBorderRightWidthValueEnumWrapper {
    pub inner: AzLayoutBorderRightWidthValue,
}

/// `AzStyleBorderTopColorValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderTopColorValueEnumWrapper {
    pub inner: AzStyleBorderTopColorValue,
}

/// `AzStyleBorderTopLeftRadiusValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderTopLeftRadiusValueEnumWrapper {
    pub inner: AzStyleBorderTopLeftRadiusValue,
}

/// `AzStyleBorderTopRightRadiusValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderTopRightRadiusValueEnumWrapper {
    pub inner: AzStyleBorderTopRightRadiusValue,
}

/// `AzStyleBorderTopStyleValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderTopStyleValueEnumWrapper {
    pub inner: AzStyleBorderTopStyleValue,
}

/// `AzLayoutBorderTopWidthValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutBorderTopWidthValueEnumWrapper {
    pub inner: AzLayoutBorderTopWidthValue,
}

/// `AzStyleCursorValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleCursorValueEnumWrapper {
    pub inner: AzStyleCursorValue,
}

/// `AzStyleFontSizeValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleFontSizeValueEnumWrapper {
    pub inner: AzStyleFontSizeValue,
}

/// `AzStyleLetterSpacingValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleLetterSpacingValueEnumWrapper {
    pub inner: AzStyleLetterSpacingValue,
}

/// `AzStyleLineHeightValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleLineHeightValueEnumWrapper {
    pub inner: AzStyleLineHeightValue,
}

/// `AzStyleTabWidthValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleTabWidthValueEnumWrapper {
    pub inner: AzStyleTabWidthValue,
}

/// `AzStyleTextAlignValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleTextAlignValueEnumWrapper {
    pub inner: AzStyleTextAlignValue,
}

/// `AzStyleTextColorValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleTextColorValueEnumWrapper {
    pub inner: AzStyleTextColorValue,
}

/// `AzStyleWordSpacingValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleWordSpacingValueEnumWrapper {
    pub inner: AzStyleWordSpacingValue,
}

/// `AzStyleOpacityValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleOpacityValueEnumWrapper {
    pub inner: AzStyleOpacityValue,
}

/// `AzStyleTransformOriginValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleTransformOriginValueEnumWrapper {
    pub inner: AzStyleTransformOriginValue,
}

/// `AzStylePerspectiveOriginValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStylePerspectiveOriginValueEnumWrapper {
    pub inner: AzStylePerspectiveOriginValue,
}

/// `AzStyleBackfaceVisibilityValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackfaceVisibilityValueEnumWrapper {
    pub inner: AzStyleBackfaceVisibilityValue,
}

/// `AzTextInputSelectionEnumWrapper` struct
#[repr(transparent)]
pub struct AzTextInputSelectionEnumWrapper {
    pub inner: AzTextInputSelection,
}

/// `AzDurationEnumWrapper` struct
#[repr(transparent)]
pub struct AzDurationEnumWrapper {
    pub inner: AzDuration,
}

/// `AzThreadSendMsgEnumWrapper` struct
#[repr(transparent)]
pub struct AzThreadSendMsgEnumWrapper {
    pub inner: AzThreadSendMsg,
}

/// `AzOptionDropDownOnChoiceChangeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionDropDownOnChoiceChangeEnumWrapper {
    pub inner: AzOptionDropDownOnChoiceChange,
}

/// `AzOptionNodeGraphOnNodeAddedEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeGraphOnNodeAddedEnumWrapper {
    pub inner: AzOptionNodeGraphOnNodeAdded,
}

/// `AzOptionNodeGraphOnNodeRemovedEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeGraphOnNodeRemovedEnumWrapper {
    pub inner: AzOptionNodeGraphOnNodeRemoved,
}

/// `AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper {
    pub inner: AzOptionNodeGraphOnNodeGraphDragged,
}

/// `AzOptionNodeGraphOnNodeDraggedEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeGraphOnNodeDraggedEnumWrapper {
    pub inner: AzOptionNodeGraphOnNodeDragged,
}

/// `AzOptionNodeGraphOnNodeConnectedEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeGraphOnNodeConnectedEnumWrapper {
    pub inner: AzOptionNodeGraphOnNodeConnected,
}

/// `AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper {
    pub inner: AzOptionNodeGraphOnNodeInputDisconnected,
}

/// `AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper {
    pub inner: AzOptionNodeGraphOnNodeOutputDisconnected,
}

/// `AzOptionNodeGraphOnNodeFieldEditedEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeGraphOnNodeFieldEditedEnumWrapper {
    pub inner: AzOptionNodeGraphOnNodeFieldEdited,
}

/// `AzOptionColorInputOnValueChangeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionColorInputOnValueChangeEnumWrapper {
    pub inner: AzOptionColorInputOnValueChange,
}

/// `AzOptionButtonOnClickEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionButtonOnClickEnumWrapper {
    pub inner: AzOptionButtonOnClick,
}

/// `AzOptionCheckBoxOnToggleEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionCheckBoxOnToggleEnumWrapper {
    pub inner: AzOptionCheckBoxOnToggle,
}

/// `AzOptionTextInputOnTextInputEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTextInputOnTextInputEnumWrapper {
    pub inner: AzOptionTextInputOnTextInput,
}

/// `AzOptionTextInputOnVirtualKeyDownEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTextInputOnVirtualKeyDownEnumWrapper {
    pub inner: AzOptionTextInputOnVirtualKeyDown,
}

/// `AzOptionTextInputOnFocusLostEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTextInputOnFocusLostEnumWrapper {
    pub inner: AzOptionTextInputOnFocusLost,
}

/// `AzOptionTextInputSelectionEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTextInputSelectionEnumWrapper {
    pub inner: AzOptionTextInputSelection,
}

/// `AzOptionNumberInputOnFocusLostEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNumberInputOnFocusLostEnumWrapper {
    pub inner: AzOptionNumberInputOnFocusLost,
}

/// `AzOptionNumberInputOnValueChangeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNumberInputOnValueChangeEnumWrapper {
    pub inner: AzOptionNumberInputOnValueChange,
}

/// `AzOptionMenuItemIconEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionMenuItemIconEnumWrapper {
    pub inner: AzOptionMenuItemIcon,
}

/// `AzOptionMenuCallbackEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionMenuCallbackEnumWrapper {
    pub inner: AzOptionMenuCallback,
}

/// `AzOptionPositionInfoEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionPositionInfoEnumWrapper {
    pub inner: AzOptionPositionInfo,
}

/// `AzOptionTimerIdEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTimerIdEnumWrapper {
    pub inner: AzOptionTimerId,
}

/// `AzOptionThreadIdEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionThreadIdEnumWrapper {
    pub inner: AzOptionThreadId,
}

/// `AzOptionImageRefEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionImageRefEnumWrapper {
    pub inner: AzOptionImageRef,
}

/// `AzOptionFontRefEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionFontRefEnumWrapper {
    pub inner: AzOptionFontRef,
}

/// `AzOptionSystemClipboardEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionSystemClipboardEnumWrapper {
    pub inner: AzOptionSystemClipboard,
}

/// `AzOptionGlEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionGlEnumWrapper {
    pub inner: AzOptionGl,
}

/// `AzOptionPercentageValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionPercentageValueEnumWrapper {
    pub inner: AzOptionPercentageValue,
}

/// `AzOptionAngleValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionAngleValueEnumWrapper {
    pub inner: AzOptionAngleValue,
}

/// `AzOptionRendererOptionsEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionRendererOptionsEnumWrapper {
    pub inner: AzOptionRendererOptions,
}

/// `AzOptionCallbackEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionCallbackEnumWrapper {
    pub inner: AzOptionCallback,
}

/// `AzOptionThreadSendMsgEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionThreadSendMsgEnumWrapper {
    pub inner: AzOptionThreadSendMsg,
}

/// `AzOptionLayoutRectEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionLayoutRectEnumWrapper {
    pub inner: AzOptionLayoutRect,
}

/// `AzOptionRefAnyEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionRefAnyEnumWrapper {
    pub inner: AzOptionRefAny,
}

/// `AzOptionLayoutPointEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionLayoutPointEnumWrapper {
    pub inner: AzOptionLayoutPoint,
}

/// `AzOptionLayoutSizeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionLayoutSizeEnumWrapper {
    pub inner: AzOptionLayoutSize,
}

/// `AzOptionWindowThemeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionWindowThemeEnumWrapper {
    pub inner: AzOptionWindowTheme,
}

/// `AzOptionNodeIdEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeIdEnumWrapper {
    pub inner: AzOptionNodeId,
}

/// `AzOptionDomNodeIdEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionDomNodeIdEnumWrapper {
    pub inner: AzOptionDomNodeId,
}

/// `AzOptionColorUEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionColorUEnumWrapper {
    pub inner: AzOptionColorU,
}

/// `AzOptionSvgDashPatternEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionSvgDashPatternEnumWrapper {
    pub inner: AzOptionSvgDashPattern,
}

/// `AzOptionLogicalPositionEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionLogicalPositionEnumWrapper {
    pub inner: AzOptionLogicalPosition,
}

/// `AzOptionPhysicalPositionI32EnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionPhysicalPositionI32EnumWrapper {
    pub inner: AzOptionPhysicalPositionI32,
}

/// `AzOptionMouseCursorTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionMouseCursorTypeEnumWrapper {
    pub inner: AzOptionMouseCursorType,
}

/// `AzOptionLogicalSizeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionLogicalSizeEnumWrapper {
    pub inner: AzOptionLogicalSize,
}

/// `AzOptionVirtualKeyCodeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionVirtualKeyCodeEnumWrapper {
    pub inner: AzOptionVirtualKeyCode,
}

/// `AzOptionImageMaskEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionImageMaskEnumWrapper {
    pub inner: AzOptionImageMask,
}

/// `AzOptionTabIndexEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTabIndexEnumWrapper {
    pub inner: AzOptionTabIndex,
}

/// `AzOptionTagIdEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTagIdEnumWrapper {
    pub inner: AzOptionTagId,
}

/// `AzOptionDurationEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionDurationEnumWrapper {
    pub inner: AzOptionDuration,
}

/// `AzOptionU8VecEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionU8VecEnumWrapper {
    pub inner: AzOptionU8Vec,
}

/// `AzOptionU8VecRefEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionU8VecRefEnumWrapper {
    pub inner: AzOptionU8VecRef,
}

/// `AzResultU8VecEncodeImageErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzResultU8VecEncodeImageErrorEnumWrapper {
    pub inner: AzResultU8VecEncodeImageError,
}

/// `AzWindowIconEnumWrapper` struct
#[repr(transparent)]
pub struct AzWindowIconEnumWrapper {
    pub inner: AzWindowIcon,
}

/// `AzAnimationEasingEnumWrapper` struct
#[repr(transparent)]
pub struct AzAnimationEasingEnumWrapper {
    pub inner: AzAnimationEasing,
}

/// `AzEventFilterEnumWrapper` struct
#[repr(transparent)]
pub struct AzEventFilterEnumWrapper {
    pub inner: AzEventFilter,
}

/// `AzCssPathPseudoSelectorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssPathPseudoSelectorEnumWrapper {
    pub inner: AzCssPathPseudoSelector,
}

/// `AzAnimationInterpolationFunctionEnumWrapper` struct
#[repr(transparent)]
pub struct AzAnimationInterpolationFunctionEnumWrapper {
    pub inner: AzAnimationInterpolationFunction,
}

/// `AzStyleTransformEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleTransformEnumWrapper {
    pub inner: AzStyleTransform,
}

/// `AzStyleBackgroundPositionVecValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundPositionVecValueEnumWrapper {
    pub inner: AzStyleBackgroundPositionVecValue,
}

/// `AzStyleBackgroundRepeatVecValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundRepeatVecValueEnumWrapper {
    pub inner: AzStyleBackgroundRepeatVecValue,
}

/// `AzStyleBackgroundSizeVecValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundSizeVecValueEnumWrapper {
    pub inner: AzStyleBackgroundSizeVecValue,
}

/// `AzRawImageDataEnumWrapper` struct
#[repr(transparent)]
pub struct AzRawImageDataEnumWrapper {
    pub inner: AzRawImageData,
}

/// `AzSvgPathElementEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgPathElementEnumWrapper {
    pub inner: AzSvgPathElement,
}

/// `AzInstantEnumWrapper` struct
#[repr(transparent)]
pub struct AzInstantEnumWrapper {
    pub inner: AzInstant,
}

/// `AzThreadReceiveMsgEnumWrapper` struct
#[repr(transparent)]
pub struct AzThreadReceiveMsgEnumWrapper {
    pub inner: AzThreadReceiveMsg,
}

/// `AzOptionResolvedTextLayoutOptionsEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionResolvedTextLayoutOptionsEnumWrapper {
    pub inner: AzOptionResolvedTextLayoutOptions,
}

/// `AzOptionVirtualKeyCodeComboEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionVirtualKeyCodeComboEnumWrapper {
    pub inner: AzOptionVirtualKeyCodeCombo,
}

/// `AzOptionMouseStateEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionMouseStateEnumWrapper {
    pub inner: AzOptionMouseState,
}

/// `AzOptionKeyboardStateEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionKeyboardStateEnumWrapper {
    pub inner: AzOptionKeyboardState,
}

/// `AzOptionStringVecEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionStringVecEnumWrapper {
    pub inner: AzOptionStringVec,
}

/// `AzOptionThreadReceiveMsgEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionThreadReceiveMsgEnumWrapper {
    pub inner: AzOptionThreadReceiveMsg,
}

/// `AzOptionTaskBarIconEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTaskBarIconEnumWrapper {
    pub inner: AzOptionTaskBarIcon,
}

/// `AzOptionWindowIconEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionWindowIconEnumWrapper {
    pub inner: AzOptionWindowIcon,
}

/// `AzOptionStringEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionStringEnumWrapper {
    pub inner: AzOptionString,
}

/// `AzOptionTextureEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTextureEnumWrapper {
    pub inner: AzOptionTexture,
}

/// `AzOptionInstantEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionInstantEnumWrapper {
    pub inner: AzOptionInstant,
}

/// `AzLayoutCallbackEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutCallbackEnumWrapper {
    pub inner: AzLayoutCallback,
}

/// `AzInlineWordEnumWrapper` struct
#[repr(transparent)]
pub struct AzInlineWordEnumWrapper {
    pub inner: AzInlineWord,
}

/// `AzNodeTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeTypeEnumWrapper {
    pub inner: AzNodeType,
}

/// `AzIdOrClassEnumWrapper` struct
#[repr(transparent)]
pub struct AzIdOrClassEnumWrapper {
    pub inner: AzIdOrClass,
}

/// `AzCssPathSelectorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssPathSelectorEnumWrapper {
    pub inner: AzCssPathSelector,
}

/// `AzStyleBackgroundContentEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundContentEnumWrapper {
    pub inner: AzStyleBackgroundContent,
}

/// `AzStyleFontFamilyEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleFontFamilyEnumWrapper {
    pub inner: AzStyleFontFamily,
}

/// `AzScrollbarStyleValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzScrollbarStyleValueEnumWrapper {
    pub inner: AzScrollbarStyleValue,
}

/// `AzStyleTransformVecValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleTransformVecValueEnumWrapper {
    pub inner: AzStyleTransformVecValue,
}

/// `AzNodeTypeFieldValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeTypeFieldValueEnumWrapper {
    pub inner: AzNodeTypeFieldValue,
}

/// `AzSvgStyleEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgStyleEnumWrapper {
    pub inner: AzSvgStyle,
}

/// `AzFmtValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzFmtValueEnumWrapper {
    pub inner: AzFmtValue,
}

/// `AzOptionFileTypeListEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionFileTypeListEnumWrapper {
    pub inner: AzOptionFileTypeList,
}

/// `AzOptionFileEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionFileEnumWrapper {
    pub inner: AzOptionFile,
}

/// `AzOptionRawImageEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionRawImageEnumWrapper {
    pub inner: AzOptionRawImage,
}

/// `AzOptionWaylandThemeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionWaylandThemeEnumWrapper {
    pub inner: AzOptionWaylandTheme,
}

/// `AzResultRawImageDecodeImageErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzResultRawImageDecodeImageErrorEnumWrapper {
    pub inner: AzResultRawImageDecodeImageError,
}

/// `AzXmlStreamErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzXmlStreamErrorEnumWrapper {
    pub inner: AzXmlStreamError,
}

/// `AzMenuItemEnumWrapper` struct
#[repr(transparent)]
pub struct AzMenuItemEnumWrapper {
    pub inner: AzMenuItem,
}

/// `AzStyleBackgroundContentVecValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundContentVecValueEnumWrapper {
    pub inner: AzStyleBackgroundContentVecValue,
}

/// `AzStyleFontFamilyVecValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleFontFamilyVecValueEnumWrapper {
    pub inner: AzStyleFontFamilyVecValue,
}

/// `AzCssPropertyEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssPropertyEnumWrapper {
    pub inner: AzCssProperty,
}

/// `AzCssPropertySourceEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssPropertySourceEnumWrapper {
    pub inner: AzCssPropertySource,
}

/// `AzOptionCssPropertyEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionCssPropertyEnumWrapper {
    pub inner: AzOptionCssProperty,
}

/// `AzNodeDataInlineCssPropertyEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeDataInlineCssPropertyEnumWrapper {
    pub inner: AzNodeDataInlineCssProperty,
}

/// `AzSvgNodeEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgNodeEnumWrapper {
    pub inner: AzSvgNode,
}

/// `AzOptionWindowStateEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionWindowStateEnumWrapper {
    pub inner: AzOptionWindowState,
}

/// `AzOptionInlineTextEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionInlineTextEnumWrapper {
    pub inner: AzOptionInlineText,
}

/// `AzXmlParseErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzXmlParseErrorEnumWrapper {
    pub inner: AzXmlParseError,
}

/// `AzFocusTargetEnumWrapper` struct
#[repr(transparent)]
pub struct AzFocusTargetEnumWrapper {
    pub inner: AzFocusTarget,
}

/// `AzCssDeclarationEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssDeclarationEnumWrapper {
    pub inner: AzCssDeclaration,
}

/// `AzXmlErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzXmlErrorEnumWrapper {
    pub inner: AzXmlError,
}

/// `AzOptionDomEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionDomEnumWrapper {
    pub inner: AzOptionDom,
}

/// `AzResultXmlXmlErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzResultXmlXmlErrorEnumWrapper {
    pub inner: AzResultXmlXmlError,
}

/// `AzSvgParseErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgParseErrorEnumWrapper {
    pub inner: AzSvgParseError,
}

/// `AzResultSvgXmlNodeSvgParseErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzResultSvgXmlNodeSvgParseErrorEnumWrapper {
    pub inner: AzResultSvgXmlNodeSvgParseError,
}

/// `AzResultSvgSvgParseErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzResultSvgSvgParseErrorEnumWrapper {
    pub inner: AzResultSvgSvgParseError,
}


// Necessary because the Python interpreter may send structs across different threads
unsafe impl Send for AzApp { }
unsafe impl Send for AzIOSHandle { }
unsafe impl Send for AzMacOSHandle { }
unsafe impl Send for AzXlibHandle { }
unsafe impl Send for AzXcbHandle { }
unsafe impl Send for AzWaylandHandle { }
unsafe impl Send for AzWindowsHandle { }
unsafe impl Send for AzAndroidHandle { }
unsafe impl Send for AzRefCount { }
unsafe impl Send for AzCssPropertyCache { }
unsafe impl Send for AzGlVoidPtrConst { }
unsafe impl Send for AzGlVoidPtrMut { }
unsafe impl Send for AzU8VecRef { }
unsafe impl Send for AzU8VecRefMut { }
unsafe impl Send for AzF32VecRef { }
unsafe impl Send for AzI32VecRef { }
unsafe impl Send for AzGLuintVecRef { }
unsafe impl Send for AzGLenumVecRef { }
unsafe impl Send for AzGLintVecRefMut { }
unsafe impl Send for AzGLint64VecRefMut { }
unsafe impl Send for AzGLbooleanVecRefMut { }
unsafe impl Send for AzGLfloatVecRefMut { }
unsafe impl Send for AzRefstr { }
unsafe impl Send for AzGLsyncPtr { }
unsafe impl Send for AzImageRef { }
unsafe impl Send for AzFontRef { }
unsafe impl Send for AzSvg { }
unsafe impl Send for AzSvgXmlNode { }
unsafe impl Send for AzSystemClipboard { }
unsafe impl Send for AzThread { }
unsafe impl Send for AzThreadSender { }
unsafe impl Send for AzThreadReceiver { }
unsafe impl Send for AzOptionHwndHandle { }
unsafe impl Send for AzOptionX11Visual { }
unsafe impl Send for AzIFrameCallbackInfo { }
unsafe impl Send for AzRefAny { }
unsafe impl Send for AzStyleBoxShadow { }
unsafe impl Send for AzStyleBackgroundSize { }
unsafe impl Send for AzGl { }
unsafe impl Send for AzRefstrVecRef { }
unsafe impl Send for AzFontMetrics { }
unsafe impl Send for AzInstantPtr { }
unsafe impl Send for AzLogicalRectVec { }
unsafe impl Send for AzInputOutputTypeIdVec { }
unsafe impl Send for AzOutputNodeAndIndexVec { }
unsafe impl Send for AzInputNodeAndIndexVec { }
unsafe impl Send for AzAccessibilityStateVec { }
unsafe impl Send for AzMenuItemVec { }
unsafe impl Send for AzXmlNodeVec { }
unsafe impl Send for AzInlineGlyphVec { }
unsafe impl Send for AzInlineTextHitVec { }
unsafe impl Send for AzVideoModeVec { }
unsafe impl Send for AzDomVec { }
unsafe impl Send for AzStyleBackgroundPositionVec { }
unsafe impl Send for AzStyleBackgroundRepeatVec { }
unsafe impl Send for AzStyleBackgroundSizeVec { }
unsafe impl Send for AzSvgVertexVec { }
unsafe impl Send for AzU32Vec { }
unsafe impl Send for AzXWindowTypeVec { }
unsafe impl Send for AzVirtualKeyCodeVec { }
unsafe impl Send for AzCascadeInfoVec { }
unsafe impl Send for AzScanCodeVec { }
unsafe impl Send for AzU16Vec { }
unsafe impl Send for AzF32Vec { }
unsafe impl Send for AzU8Vec { }
unsafe impl Send for AzGLuintVec { }
unsafe impl Send for AzGLintVec { }
unsafe impl Send for AzNormalizedLinearColorStopVec { }
unsafe impl Send for AzNormalizedRadialColorStopVec { }
unsafe impl Send for AzNodeIdVec { }
unsafe impl Send for AzNodeHierarchyItemVec { }
unsafe impl Send for AzParentWithNodeDepthVec { }
unsafe impl Send for AzRenderImageCallbackInfo { }
unsafe impl Send for AzLayoutCallbackInfo { }
unsafe impl Send for AzTexture { }
unsafe impl Send for AzTessellatedSvgNodeVecRef { }
unsafe impl Send for AzInputConnectionVec { }
unsafe impl Send for AzOutputConnectionVec { }
unsafe impl Send for AzTessellatedSvgNodeVec { }
unsafe impl Send for AzStyleTransformVec { }
unsafe impl Send for AzSvgPathElementVec { }
unsafe impl Send for AzStringVec { }
unsafe impl Send for AzStyledNodeVec { }
unsafe impl Send for AzTagIdToNodeIdMappingVec { }
unsafe impl Send for AzWaylandTheme { }
unsafe impl Send for AzFile { }
unsafe impl Send for AzStyleFontFamilyVec { }
unsafe impl Send for AzFmtArgVec { }
unsafe impl Send for AzInlineWordVec { }
unsafe impl Send for AzMonitorVec { }
unsafe impl Send for AzIdOrClassVec { }
unsafe impl Send for AzStyleBackgroundContentVec { }
unsafe impl Send for AzSvgPathVec { }
unsafe impl Send for AzVertexAttributeVec { }
unsafe impl Send for AzCssPathSelectorVec { }
unsafe impl Send for AzCallbackDataVec { }
unsafe impl Send for AzDebugMessageVec { }
unsafe impl Send for AzStringPairVec { }
unsafe impl Send for AzVertexArrayObject { }
unsafe impl Send for AzVertexBuffer { }
unsafe impl Send for AzNodeTypeIdInfoMapVec { }
unsafe impl Send for AzInputOutputTypeIdInfoMapVec { }
unsafe impl Send for AzNodeTypeFieldVec { }
unsafe impl Send for AzInlineLineVec { }
unsafe impl Send for AzCssPropertyVec { }
unsafe impl Send for AzSvgMultiPolygonVec { }
unsafe impl Send for AzCallbackInfo { }
unsafe impl Send for AzTimerCallbackInfo { }
unsafe impl Send for AzNodeDataInlineCssPropertyVec { }
unsafe impl Send for AzNodeData { }
unsafe impl Send for AzNodeIdNodeMapVec { }
unsafe impl Send for AzCssDeclarationVec { }
unsafe impl Send for AzNodeDataVec { }
unsafe impl Send for AzTabVec { }
unsafe impl Send for AzCssRuleBlockVec { }
unsafe impl Send for AzStylesheetVec { }


// Python objects must implement Clone at minimum
impl Clone for AzApp { fn clone(&self) -> Self { let r: &azul_impl::app::AzAppPtr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAppLogLevelEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::resources::AppLogLevel = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutSolverEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::resources::LayoutSolverVersion = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVsyncEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::Vsync = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSrgbEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::Srgb = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzHwAccelerationEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::HwAcceleration = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPoint { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutPoint = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutSize { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIOSHandle { fn clone(&self) -> Self { let r: &azul_core::window::IOSHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMacOSHandle { fn clone(&self) -> Self { let r: &azul_core::window::MacOSHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXlibHandle { fn clone(&self) -> Self { let r: &azul_core::window::XlibHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXcbHandle { fn clone(&self) -> Self { let r: &azul_core::window::XcbHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWaylandHandle { fn clone(&self) -> Self { let r: &azul_core::window::WaylandHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowsHandle { fn clone(&self) -> Self { let r: &azul_core::window::WindowsHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWebHandle { fn clone(&self) -> Self { let r: &azul_core::window::WebHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAndroidHandle { fn clone(&self) -> Self { let r: &azul_core::window::AndroidHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXWindowTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::XWindowType = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPhysicalPositionI32 { fn clone(&self) -> Self { let r: &azul_core::window::PhysicalPositionI32 = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPhysicalSizeU32 { fn clone(&self) -> Self { let r: &azul_core::window::PhysicalSizeU32 = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLogicalPosition { fn clone(&self) -> Self { let r: &azul_core::window::LogicalPosition = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLogicalSize { fn clone(&self) -> Self { let r: &azul_core::window::LogicalSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIconKey { fn clone(&self) -> Self { let r: &azul_core::window::IconKey = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVirtualKeyCodeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::VirtualKeyCode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowFrameEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowFrame = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDebugState { fn clone(&self) -> Self { let r: &azul_core::window::DebugState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMouseCursorTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::MouseCursorType = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRendererTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::RendererType = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMacWindowOptions { fn clone(&self) -> Self { let r: &azul_core::window::MacWindowOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWasmWindowOptions { fn clone(&self) -> Self { let r: &azul_core::window::WasmWindowOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFullScreenModeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::FullScreenMode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowThemeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowTheme = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTouchState { fn clone(&self) -> Self { let r: &azul_core::window::TouchState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMarshaledLayoutCallbackInner { fn clone(&self) -> Self { let r: &azul_impl::callbacks::MarshaledLayoutCallbackInner = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutCallbackInner { fn clone(&self) -> Self { let r: &azul_impl::callbacks::LayoutCallbackInner = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCallback { fn clone(&self) -> Self { let r: &azul_impl::callbacks::Callback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzUpdateImageTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::callbacks::UpdateImageType = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzUpdateEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::callbacks::Update = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeId { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::NodeHierarchyItemId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDomId { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::DomId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPositionInfoInner { fn clone(&self) -> Self { let r: &azul_impl::ui_solver::PositionInfoInner = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAnimationRepeatEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::callbacks::AnimationRepeat = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAnimationRepeatCountEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::callbacks::AnimationRepeatCount = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIFrameCallback { fn clone(&self) -> Self { let r: &azul_impl::callbacks::IFrameCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRenderImageCallback { fn clone(&self) -> Self { let r: &azul_impl::callbacks::RenderImageCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTimerCallback { fn clone(&self) -> Self { let r: &azul_impl::callbacks::TimerCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWriteBackCallback { fn clone(&self) -> Self { let r: &azul_impl::callbacks::WriteBackCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadCallback { fn clone(&self) -> Self { let r: &azul_impl::callbacks::ThreadCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRefCount { fn clone(&self) -> Self { let r: &azul_impl::callbacks::RefCount = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::On = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzHoverEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::HoverEventFilter = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFocusEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::FocusEventFilter = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::WindowEventFilter = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzComponentEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::ComponentEventFilter = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzApplicationEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::ApplicationEventFilter = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityRoleEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::AccessibilityRole = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityStateEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::AccessibilityState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTabIndexEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::TabIndex = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzContextMenuMouseButtonEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::ContextMenuMouseButton = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuPopupPositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::MenuPopupPosition = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuItemStateEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::MenuItemState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeKeyEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::NodeTypeTag = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssNthChildPattern { fn clone(&self) -> Self { let r: &azul_impl::css::CssNthChildPattern = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPropertyTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::CssPropertyType = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorU { fn clone(&self) -> Self { let r: &azul_impl::css::ColorU = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSizeMetricEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::SizeMetric = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFloatValue { fn clone(&self) -> Self { let r: &azul_impl::css::FloatValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzBoxShadowClipModeEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::BoxShadowClipMode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutAlignContentEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutAlignContent = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutAlignItemsEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutAlignItems = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBoxSizingEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutBoxSizing = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexDirectionEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutFlexDirection = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutDisplayEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutDisplay = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFloatEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutFloat = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutJustifyContentEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutJustifyContent = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutPosition = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexWrapEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutFlexWrap = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutOverflowEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutOverflow = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAngleMetricEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::AngleMetric = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDirectionCornerEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::DirectionCorner = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzExtendModeEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::ExtendMode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapeEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::Shape = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRadialGradientSizeEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::RadialGradientSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundRepeatEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackgroundRepeat = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzBorderStyleEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::BorderStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleCursorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleCursor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackfaceVisibilityEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackfaceVisibility = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTextAlignEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTextAlign = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckBoxOnToggleCallback { fn clone(&self) -> Self { let r: &crate::widgets::check_box::CheckBoxOnToggleCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckBoxState { fn clone(&self) -> Self { let r: &crate::widgets::check_box::CheckBoxState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorInputOnValueChangeCallback { fn clone(&self) -> Self { let r: &crate::widgets::color_input::ColorInputOnValueChangeCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputSelectionRange { fn clone(&self) -> Self { let r: &crate::widgets::text_input::TextInputSelectionRange = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnTextInputCallback { fn clone(&self) -> Self { let r: &crate::widgets::text_input::TextInputOnTextInputCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnVirtualKeyDownCallback { fn clone(&self) -> Self { let r: &crate::widgets::text_input::TextInputOnVirtualKeyDownCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnFocusLostCallback { fn clone(&self) -> Self { let r: &crate::widgets::text_input::TextInputOnFocusLostCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputValidEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::text_input::TextInputValid = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputState { fn clone(&self) -> Self { let r: &crate::widgets::number_input::NumberInputState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputOnValueChangeCallback { fn clone(&self) -> Self { let r: &crate::widgets::number_input::NumberInputOnValueChangeCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputOnFocusLostCallback { fn clone(&self) -> Self { let r: &crate::widgets::number_input::NumberInputOnFocusLostCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzProgressBarState { fn clone(&self) -> Self { let r: &crate::widgets::progressbar::ProgressBarState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphStyleEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeGraphStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphOnNodeAddedCallback { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OnNodeAddedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphOnNodeRemovedCallback { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OnNodeRemovedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphOnNodeGraphDraggedCallback { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OnNodeGraphDraggedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphOnNodeDraggedCallback { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OnNodeDraggedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphOnNodeConnectedCallback { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OnNodeConnectedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphOnNodeInputDisconnectedCallback { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OnNodeInputDisconnectedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphOnNodeOutputDisconnectedCallback { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OnNodeOutputDisconnectedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphOnNodeFieldEditedCallback { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OnNodeFieldEditedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputOutputTypeId { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputOutputTypeId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeId { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeTypeId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphNodeId { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeGraphNodeId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodePosition { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodePosition = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGraphDragAmount { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::GraphDragAmount = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDragAmount { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeDragAmount = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDropDownOnChoiceChangeCallback { fn clone(&self) -> Self { let r: &crate::widgets::drop_down::DropDownOnChoiceChangeCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeHierarchyItem { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::NodeHierarchyItem = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCascadeInfo { fn clone(&self) -> Self { let r: &azul_impl::style::CascadeInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyledNodeState { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::StyledNodeState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTagId { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::AzTagId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPropertyCache { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::CssPropertyCachePtr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGlVoidPtrConst { fn clone(&self) -> Self { let r: &azul_impl::gl::GlVoidPtrConst = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGlVoidPtrMut { fn clone(&self) -> Self { let r: &azul_impl::gl::GlVoidPtrMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGlShaderPrecisionFormatReturn { fn clone(&self) -> Self { let r: &azul_impl::gl::GlShaderPrecisionFormatReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexAttributeTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::gl::VertexAttributeType = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIndexBufferFormatEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::gl::IndexBufferFormat = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGlTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::gl::AzGlType = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU8VecRef { fn clone(&self) -> Self { let r: &azul_impl::gl::U8VecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU8VecRefMut { fn clone(&self) -> Self { let r: &azul_impl::gl::U8VecRefMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzF32VecRef { fn clone(&self) -> Self { let r: &azul_impl::gl::F32VecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzI32VecRef { fn clone(&self) -> Self { let r: &azul_impl::gl::I32VecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLuintVecRef { fn clone(&self) -> Self { let r: &azul_impl::gl::GLuintVecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLenumVecRef { fn clone(&self) -> Self { let r: &azul_impl::gl::GLenumVecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLintVecRefMut { fn clone(&self) -> Self { let r: &azul_impl::gl::GLintVecRefMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLint64VecRefMut { fn clone(&self) -> Self { let r: &azul_impl::gl::GLint64VecRefMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLbooleanVecRefMut { fn clone(&self) -> Self { let r: &azul_impl::gl::GLbooleanVecRefMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLfloatVecRefMut { fn clone(&self) -> Self { let r: &azul_impl::gl::GLfloatVecRefMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRefstr { fn clone(&self) -> Self { let r: &azul_impl::gl::Refstr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLsyncPtr { fn clone(&self) -> Self { let r: &azul_impl::gl::GLsyncPtr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextureFlags { fn clone(&self) -> Self { let r: &azul_impl::gl::TextureFlags = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzImageRef { fn clone(&self) -> Self { let r: &azul_impl::resources::ImageRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRawImageFormatEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::resources::RawImageFormat = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzEncodeImageErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::resources::encode::EncodeImageError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDecodeImageErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::resources::decode::DecodeImageError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFontRef { fn clone(&self) -> Self { let r: &azul_impl::css::FontRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvg { fn clone(&self) -> Self { let r: &azul_impl::svg::Svg = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgXmlNode { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgXmlNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgCircle { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgCircle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPoint { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgPoint = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgRect { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgRect = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgVertex { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgVertex = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapeRenderingEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::ShapeRendering = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextRenderingEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::TextRendering = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzImageRenderingEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::ImageRendering = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFontDatabaseEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::FontDatabase = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIndentEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::Indent = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgFitToEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgFitTo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgFillRuleEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgFillRule = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgTransform { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgTransform = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgLineJoinEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgLineJoin = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgLineCapEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgLineCap = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgDashPattern { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgDashPattern = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMsgBox { fn clone(&self) -> Self { let r: &azul_impl::dialogs::MsgBox = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMsgBoxIconEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dialogs::MsgBoxIcon = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMsgBoxYesNoEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dialogs::YesNo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMsgBoxOkCancelEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dialogs::OkCancel = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFileDialog { fn clone(&self) -> Self { let r: &azul_impl::dialogs::FileDialog = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorPickerDialog { fn clone(&self) -> Self { let r: &azul_impl::dialogs::ColorPickerDialog = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSystemClipboard { fn clone(&self) -> Self { let r: &azul_impl::app::Clipboard = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInstantPtrCloneFn { fn clone(&self) -> Self { let r: &azul_impl::task::InstantPtrCloneCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInstantPtrDestructorFn { fn clone(&self) -> Self { let r: &azul_impl::task::InstantPtrDestructorCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSystemTick { fn clone(&self) -> Self { let r: &azul_impl::task::SystemTick = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSystemTimeDiff { fn clone(&self) -> Self { let r: &azul_impl::task::SystemTimeDiff = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSystemTickDiff { fn clone(&self) -> Self { let r: &azul_impl::task::SystemTickDiff = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTimerId { fn clone(&self) -> Self { let r: &azul_impl::task::TimerId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTerminateTimerEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::task::TerminateTimer = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadId { fn clone(&self) -> Self { let r: &azul_impl::task::ThreadId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThread { fn clone(&self) -> Self { let r: &azul_impl::task::Thread = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadSender { fn clone(&self) -> Self { let r: &azul_impl::task::ThreadSender = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadReceiver { fn clone(&self) -> Self { let r: &azul_impl::task::ThreadReceiver = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCreateThreadFn { fn clone(&self) -> Self { let r: &azul_impl::task::CreateThreadCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGetSystemTimeFn { fn clone(&self) -> Self { let r: &azul_impl::task::GetSystemTimeCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckThreadFinishedFn { fn clone(&self) -> Self { let r: &azul_impl::task::CheckThreadFinishedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLibrarySendThreadMsgFn { fn clone(&self) -> Self { let r: &azul_impl::task::LibrarySendThreadMsgCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLibraryReceiveThreadMsgFn { fn clone(&self) -> Self { let r: &azul_impl::task::LibraryReceiveThreadMsgCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadRecvFn { fn clone(&self) -> Self { let r: &azul_impl::task::ThreadRecvCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadSendFn { fn clone(&self) -> Self { let r: &azul_impl::task::ThreadSendCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadDestructorFn { fn clone(&self) -> Self { let r: &azul_impl::task::ThreadDestructorCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadReceiverDestructorFn { fn clone(&self) -> Self { let r: &azul_impl::task::ThreadReceiverDestructorCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadSenderDestructorFn { fn clone(&self) -> Self { let r: &azul_impl::task::ThreadSenderDestructorCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontFamilyVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleFontFamilyVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLogicalRectVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::LogicalRectVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeIdInfoMapVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeTypeIdInfoMapVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeIdNodeMapVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeIdNodeMapVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputOutputTypeIdVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputOutputTypeIdVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeFieldVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeTypeFieldVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputConnectionVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputConnectionVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOutputNodeAndIndexVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OutputNodeAndIndexVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOutputConnectionVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OutputConnectionVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputNodeAndIndexVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputNodeAndIndexVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTabVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::tabs::TabVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityStateVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::AccessibilityStateVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuItemVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::MenuItemVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedSvgNodeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::TessellatedSvgNodeVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlNodeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::xml::XmlNodeVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFmtArgVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::str::FmtArgVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineLineVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::callbacks::InlineLineVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineWordVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::callbacks::InlineWordVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineGlyphVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::callbacks::InlineGlyphVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineTextHitVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::callbacks::InlineTextHitVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMonitorVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::MonitorVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVideoModeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::VideoModeVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDomVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::DomVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIdOrClassVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::IdOrClassVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDataInlineCssPropertyVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::NodeDataInlineCssPropertyVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundContentVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackgroundContentVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundPositionVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackgroundPositionVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundRepeatVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackgroundRepeatVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundSizeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackgroundSizeVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTransformVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPropertyVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::CssPropertyVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgMultiPolygonVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgMultiPolygonVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPathVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgPathVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexAttributeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::gl::VertexAttributeVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPathElementVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgPathElementVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgVertexVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgVertexVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU32VecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::U32VecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXWindowTypeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::XWindowTypeVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVirtualKeyCodeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::VirtualKeyCodeVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCascadeInfoVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::style::CascadeInfoVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzScanCodeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::ScanCodeVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssDeclarationVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::CssDeclarationVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPathSelectorVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::CssPathSelectorVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStylesheetVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StylesheetVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssRuleBlockVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::CssRuleBlockVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzF32VecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::F32VecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU16VecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::U16VecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU8VecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::U8VecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCallbackDataVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::CallbackDataVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDebugMessageVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::gl::AzDebugMessageVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLuintVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::gl::GLuintVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLintVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::gl::GLintVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StringVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringPairVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::StringPairVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedLinearColorStopVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::NormalizedLinearColorStopVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedRadialColorStopVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::NormalizedRadialColorStopVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeIdVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::NodeIdVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeHierarchyItemVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::NodeHierarchyItemVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyledNodeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::StyledNodeVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTagIdToNodeIdMappingVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::TagIdToNodeIdMappingVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzParentWithNodeDepthVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::ParentWithNodeDepthVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDataVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::NodeDataVecDestructor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionI16EnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::OptionI16 = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionU16EnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::OptionU16 = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionU32EnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::OptionU32 = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionHwndHandleEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionHwndHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionX11VisualEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionX11Visual = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionI32EnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::OptionI32 = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionF32EnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::OptionF32 = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionCharEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionChar = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionUsizeEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::gl::OptionUsize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgParseErrorPosition { fn clone(&self) -> Self { let r: &azul_impl::xml::XmlTextPos = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSystemCallbacks { fn clone(&self) -> Self { let r: &azul_impl::task::ExternalSystemCallbacks = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRendererOptions { fn clone(&self) -> Self { let r: &azul_core::window::RendererOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutRect { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutRect = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRawWindowHandleEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::RawWindowHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLogicalRect { fn clone(&self) -> Self { let r: &azul_core::window::LogicalRect = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAcceleratorKeyEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::AcceleratorKey = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowFlags { fn clone(&self) -> Self { let r: &azul_core::window::WindowFlags = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCursorPositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::CursorPosition = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowPositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowPosition = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzImePositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::ImePosition = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVideoMode { fn clone(&self) -> Self { let r: &azul_core::window::VideoMode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDomNodeId { fn clone(&self) -> Self { let r: &azul_impl::callbacks::DomNodeId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPositionInfoEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::ui_solver::PositionInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzHidpiAdjustedBounds { fn clone(&self) -> Self { let r: &azul_impl::callbacks::HidpiAdjustedBounds = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineGlyph { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineGlyph = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineTextHit { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineTextHit = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIFrameCallbackInfo { fn clone(&self) -> Self { let r: &azul_impl::callbacks::IFrameCallbackInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTimerCallbackReturn { fn clone(&self) -> Self { let r: &azul_impl::callbacks::TimerCallbackReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRefAny { fn clone(&self) -> Self { let r: &azul_impl::callbacks::RefAny = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIFrameNode { fn clone(&self) -> Self { let r: &azul_impl::dom::IFrameNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNotEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::NotEventFilter = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuCallback { fn clone(&self) -> Self { let r: &azul_core::window::MenuCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuItemIconEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::MenuItemIcon = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssNthChildSelectorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::CssNthChildSelector = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPixelValue { fn clone(&self) -> Self { let r: &azul_impl::css::PixelValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPixelValueNoPercent { fn clone(&self) -> Self { let r: &azul_impl::css::PixelValueNoPercent = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBoxShadow { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBoxShadow = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBottom { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutBottom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexGrow { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutFlexGrow = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexShrink { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutFlexShrink = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutHeight { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutHeight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutLeft { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutLeft = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginBottom { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutMarginBottom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginLeft { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutMarginLeft = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginRight { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutMarginRight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginTop { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutMarginTop = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMaxHeight { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutMaxHeight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMaxWidth { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutMaxWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMinHeight { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutMinHeight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMinWidth { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutMinWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingBottom { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutPaddingBottom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingLeft { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutPaddingLeft = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingRight { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutPaddingRight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingTop { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutPaddingTop = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutRight { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutRight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutTop { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutTop = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutWidth { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPercentageValue { fn clone(&self) -> Self { let r: &azul_impl::css::PercentageValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAngleValue { fn clone(&self) -> Self { let r: &azul_impl::css::AngleValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedLinearColorStop { fn clone(&self) -> Self { let r: &azul_impl::css::NormalizedLinearColorStop = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedRadialColorStop { fn clone(&self) -> Self { let r: &azul_impl::css::NormalizedRadialColorStop = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDirectionCorners { fn clone(&self) -> Self { let r: &azul_impl::css::DirectionCorners = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDirectionEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::Direction = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzBackgroundPositionHorizontalEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::BackgroundPositionHorizontal = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzBackgroundPositionVerticalEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::BackgroundPositionVertical = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundPosition { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackgroundPosition = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundSizeEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackgroundSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomColor { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderBottomColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomLeftRadius { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderBottomLeftRadius = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomRightRadius { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderBottomRightRadius = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomStyle { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderBottomStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderBottomWidth { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutBorderBottomWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderLeftColor { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderLeftColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderLeftStyle { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderLeftStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderLeftWidth { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutBorderLeftWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderRightColor { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderRightColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderRightStyle { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderRightStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderRightWidth { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutBorderRightWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopColor { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderTopColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopLeftRadius { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderTopLeftRadius = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopRightRadius { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderTopRightRadius = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopStyle { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderTopStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderTopWidth { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutBorderTopWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontSize { fn clone(&self) -> Self { let r: &azul_impl::css::StyleFontSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleLetterSpacing { fn clone(&self) -> Self { let r: &azul_impl::css::StyleLetterSpacing = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleLineHeight { fn clone(&self) -> Self { let r: &azul_impl::css::StyleLineHeight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTabWidth { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTabWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleOpacity { fn clone(&self) -> Self { let r: &azul_impl::css::StyleOpacity = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformOrigin { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTransformOrigin = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStylePerspectiveOrigin { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTransformOrigin = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformMatrix2D { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTransformMatrix2D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformMatrix3D { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTransformMatrix3D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformTranslate2D { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTransformTranslate2D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformTranslate3D { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTransformTranslate3D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformRotate3D { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTransformRotate3D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformScale2D { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTransformScale2D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformScale3D { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTransformScale3D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformSkew2D { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTransformSkew2D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTextColor { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTextColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleWordSpacing { fn clone(&self) -> Self { let r: &azul_impl::css::StyleWordSpacing = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBoxShadowValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBoxShadowValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutAlignContentValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutAlignContentValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutAlignItemsValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutAlignItemsValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBottomValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutBottomValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBoxSizingValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutBoxSizingValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexDirectionValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutFlexDirectionValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutDisplayValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutDisplayValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexGrowValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutFlexGrowValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexShrinkValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutFlexShrinkValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFloatValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutFloatValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutHeightValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutHeightValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutJustifyContentValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutJustifyContentValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutLeftValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutLeftValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginBottomValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutMarginBottomValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginLeftValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutMarginLeftValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginRightValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutMarginRightValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginTopValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutMarginTopValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMaxHeightValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutMaxHeightValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMaxWidthValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutMaxWidthValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMinHeightValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutMinHeightValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMinWidthValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutMinWidthValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingBottomValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutPaddingBottomValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingLeftValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutPaddingLeftValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingRightValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutPaddingRightValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingTopValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutPaddingTopValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPositionValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutPositionValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutRightValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutRightValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutTopValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutTopValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutWidthValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutWidthValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexWrapValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutFlexWrapValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutOverflowValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutOverflowValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomColorValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderBottomColorValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomLeftRadiusValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderBottomLeftRadiusValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomRightRadiusValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderBottomRightRadiusValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomStyleValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderBottomStyleValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderBottomWidthValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutBorderBottomWidthValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderLeftColorValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderLeftColorValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderLeftStyleValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderLeftStyleValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderLeftWidthValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutBorderLeftWidthValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderRightColorValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderRightColorValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderRightStyleValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderRightStyleValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderRightWidthValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutBorderRightWidthValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopColorValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderTopColorValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopLeftRadiusValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderTopLeftRadiusValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopRightRadiusValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderTopRightRadiusValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopStyleValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBorderTopStyleValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderTopWidthValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::LayoutBorderTopWidthValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleCursorValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleCursorValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontSizeValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleFontSizeValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleLetterSpacingValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleLetterSpacingValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleLineHeightValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleLineHeightValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTabWidthValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTabWidthValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTextAlignValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTextAlignValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTextColorValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTextColorValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleWordSpacingValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleWordSpacingValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleOpacityValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleOpacityValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformOriginValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTransformOriginValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStylePerspectiveOriginValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StylePerspectiveOriginValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackfaceVisibilityValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackfaceVisibilityValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzButtonOnClick { fn clone(&self) -> Self { let r: &crate::widgets::button::ButtonOnClick = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckBoxOnToggle { fn clone(&self) -> Self { let r: &crate::widgets::check_box::CheckBoxOnToggle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorInputState { fn clone(&self) -> Self { let r: &crate::widgets::color_input::ColorInputState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorInputOnValueChange { fn clone(&self) -> Self { let r: &crate::widgets::color_input::ColorInputOnValueChange = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputSelectionEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::text_input::TextInputSelection = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnTextInput { fn clone(&self) -> Self { let r: &crate::widgets::text_input::TextInputOnTextInput = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnVirtualKeyDown { fn clone(&self) -> Self { let r: &crate::widgets::text_input::TextInputOnVirtualKeyDown = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnFocusLost { fn clone(&self) -> Self { let r: &crate::widgets::text_input::TextInputOnFocusLost = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnTextInputReturn { fn clone(&self) -> Self { let r: &crate::widgets::text_input::OnTextInputReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputOnValueChange { fn clone(&self) -> Self { let r: &crate::widgets::number_input::NumberInputOnValueChange = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputOnFocusLost { fn clone(&self) -> Self { let r: &crate::widgets::number_input::NumberInputOnFocusLost = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphOnNodeAdded { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OnNodeAdded = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphOnNodeRemoved { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OnNodeRemoved = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphOnNodeGraphDragged { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OnNodeGraphDragged = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphOnNodeDragged { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OnNodeDragged = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphOnNodeConnected { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OnNodeConnected = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphOnNodeInputDisconnected { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OnNodeInputDisconnected = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphOnNodeOutputDisconnected { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OnNodeOutputDisconnected = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphOnNodeFieldEdited { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OnNodeFieldEdited = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOutputNodeAndIndex { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OutputNodeAndIndex = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputNodeAndIndex { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputNodeAndIndex = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDropDownOnChoiceChange { fn clone(&self) -> Self { let r: &crate::widgets::drop_down::DropDownOnChoiceChange = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzParentWithNodeDepth { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::ParentWithNodeDepth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGl { fn clone(&self) -> Self { let r: &azul_impl::gl::GlContextPtr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRefstrVecRef { fn clone(&self) -> Self { let r: &azul_impl::gl::RefstrVecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzImageMask { fn clone(&self) -> Self { let r: &azul_impl::resources::ImageMask = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFontMetrics { fn clone(&self) -> Self { let r: &azul_impl::css::FontMetrics = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgLine { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgLine = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgQuadraticCurve { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgQuadraticCurve = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgCubicCurve { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgCubicCurve = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgStringFormatOptions { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgXmlOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgFillStyle { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgFillStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInstantPtr { fn clone(&self) -> Self { let r: &azul_impl::task::AzInstantPtr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDurationEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::task::Duration = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadSendMsgEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::task::ThreadSendMsg = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadWriteBackMsg { fn clone(&self) -> Self { let r: &azul_impl::task::ThreadWriteBackMsg = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLogicalRectVec { fn clone(&self) -> Self { let r: &azul_core::window::LogicalRectVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputOutputTypeIdVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputOutputTypeIdVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOutputNodeAndIndexVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OutputNodeAndIndexVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputNodeAndIndexVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputNodeAndIndexVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityStateVec { fn clone(&self) -> Self { let r: &azul_impl::dom::AccessibilityStateVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuItemVec { fn clone(&self) -> Self { let r: &azul_core::window::MenuItemVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlNodeVec { fn clone(&self) -> Self { let r: &azul_impl::xml::XmlNodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineGlyphVec { fn clone(&self) -> Self { let r: &azul_impl::callbacks::InlineGlyphVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineTextHitVec { fn clone(&self) -> Self { let r: &azul_impl::callbacks::InlineTextHitVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVideoModeVec { fn clone(&self) -> Self { let r: &azul_core::window::VideoModeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDomVec { fn clone(&self) -> Self { let r: &azul_impl::dom::DomVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundPositionVec { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackgroundPositionVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundRepeatVec { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackgroundRepeatVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundSizeVec { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackgroundSizeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgVertexVec { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgVertexVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU32Vec { fn clone(&self) -> Self { let r: &azul_impl::css::U32Vec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXWindowTypeVec { fn clone(&self) -> Self { let r: &azul_core::window::XWindowTypeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVirtualKeyCodeVec { fn clone(&self) -> Self { let r: &azul_core::window::VirtualKeyCodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCascadeInfoVec { fn clone(&self) -> Self { let r: &azul_impl::style::CascadeInfoVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzScanCodeVec { fn clone(&self) -> Self { let r: &azul_core::window::ScanCodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU16Vec { fn clone(&self) -> Self { let r: &azul_impl::css::U16Vec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzF32Vec { fn clone(&self) -> Self { let r: &azul_impl::css::F32Vec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU8Vec { fn clone(&self) -> Self { let r: &azul_impl::css::U8Vec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLuintVec { fn clone(&self) -> Self { let r: &azul_impl::gl::GLuintVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLintVec { fn clone(&self) -> Self { let r: &azul_impl::gl::GLintVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedLinearColorStopVec { fn clone(&self) -> Self { let r: &azul_impl::css::NormalizedLinearColorStopVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedRadialColorStopVec { fn clone(&self) -> Self { let r: &azul_impl::css::NormalizedRadialColorStopVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeIdVec { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::NodeIdVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeHierarchyItemVec { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::NodeHierarchyItemVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzParentWithNodeDepthVec { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::ParentWithNodeDepthVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionDropDownOnChoiceChangeEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::drop_down::OptionDropDownOnChoiceChange = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionNodeGraphOnNodeAddedEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OptionOnNodeAdded = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionNodeGraphOnNodeRemovedEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OptionOnNodeRemoved = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OptionOnNodeGraphDragged = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionNodeGraphOnNodeDraggedEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OptionOnNodeDragged = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionNodeGraphOnNodeConnectedEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OptionOnNodeConnected = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OptionOnNodeInputDisconnected = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OptionOnNodeOutputDisconnected = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionNodeGraphOnNodeFieldEditedEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OptionOnNodeFieldEdited = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionColorInputOnValueChangeEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::color_input::OptionColorInputOnValueChange = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionButtonOnClickEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::button::OptionButtonOnClick = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionCheckBoxOnToggleEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::check_box::OptionCheckBoxOnToggle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTextInputOnTextInputEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::text_input::OptionTextInputOnTextInput = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTextInputOnVirtualKeyDownEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::text_input::OptionTextInputOnVirtualKeyDown = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTextInputOnFocusLostEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::text_input::OptionTextInputOnFocusLost = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTextInputSelectionEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::text_input::OptionTextInputSelection = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionNumberInputOnFocusLostEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::number_input::OptionNumberInputOnFocusLost = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionNumberInputOnValueChangeEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::number_input::OptionNumberInputOnValueChange = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionMenuItemIconEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionMenuItemIcon = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionMenuCallbackEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionMenuCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionPositionInfoEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::ui_solver::OptionPositionInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTimerIdEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::task::OptionTimerId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionThreadIdEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::task::OptionThreadId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionImageRefEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::resources::OptionImageRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionFontRefEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::OptionFontRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionSystemClipboardEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::app::OptionClipboard = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionGlEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::gl::OptionGlContextPtr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionPercentageValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::OptionPercentageValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionAngleValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::OptionAngleValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionRendererOptionsEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionRendererOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionCallbackEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::callbacks::OptionCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionThreadSendMsgEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::task::OptionThreadSendMsg = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionLayoutRectEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::OptionLayoutRect = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionRefAnyEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::callbacks::OptionRefAny = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionLayoutPointEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::OptionLayoutPoint = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionLayoutSizeEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::OptionLayoutSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionWindowThemeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionWindowTheme = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionNodeIdEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::OptionNodeId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionDomNodeIdEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::callbacks::OptionDomNodeId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionColorUEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::OptionColorU = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionSvgDashPatternEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::OptionSvgDashPattern = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionLogicalPositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionLogicalPosition = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionPhysicalPositionI32EnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionPhysicalPositionI32 = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionMouseCursorTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionMouseCursorType = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionLogicalSizeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionLogicalSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionVirtualKeyCodeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionVirtualKeyCode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionImageMaskEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::resources::OptionImageMask = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTabIndexEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::OptionTabIndex = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTagIdEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::OptionTagId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionDurationEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::task::OptionDuration = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionU8VecEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::OptionU8Vec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionU8VecRefEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::gl::OptionU8VecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzResultU8VecEncodeImageErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::resources::encode::ResultU8VecEncodeImageError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNonXmlCharError { fn clone(&self) -> Self { let r: &azul_impl::xml::NonXmlCharError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInvalidCharError { fn clone(&self) -> Self { let r: &azul_impl::xml::InvalidCharError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInvalidCharMultipleError { fn clone(&self) -> Self { let r: &azul_impl::xml::InvalidCharMultipleError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInvalidQuoteError { fn clone(&self) -> Self { let r: &azul_impl::xml::InvalidQuoteError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInvalidSpaceError { fn clone(&self) -> Self { let r: &azul_impl::xml::InvalidSpaceError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAppConfig { fn clone(&self) -> Self { let r: &azul_impl::resources::AppConfig = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSmallWindowIconBytes { fn clone(&self) -> Self { let r: &azul_core::window::SmallWindowIconBytes = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLargeWindowIconBytes { fn clone(&self) -> Self { let r: &azul_core::window::LargeWindowIconBytes = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowIconEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowIcon = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTaskBarIcon { fn clone(&self) -> Self { let r: &azul_core::window::TaskBarIcon = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowSize { fn clone(&self) -> Self { let r: &azul_core::window::WindowSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzKeyboardState { fn clone(&self) -> Self { let r: &azul_core::window::KeyboardState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMouseState { fn clone(&self) -> Self { let r: &azul_core::window::MouseState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMarshaledLayoutCallback { fn clone(&self) -> Self { let r: &azul_impl::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineTextContents { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineTextContents = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzResolvedTextLayoutOptions { fn clone(&self) -> Self { let r: &azul_impl::ui_solver::ResolvedTextLayoutOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAnimationEasingEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::AnimationInterpolationFunction = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRenderImageCallbackInfo { fn clone(&self) -> Self { let r: &azul_impl::callbacks::RenderImageCallbackInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutCallbackInfo { fn clone(&self) -> Self { let r: &azul_impl::callbacks::LayoutCallbackInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::EventFilter = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenu { fn clone(&self) -> Self { let r: &azul_core::window::Menu = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVirtualKeyCodeCombo { fn clone(&self) -> Self { let r: &azul_core::window::VirtualKeyCodeCombo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPathPseudoSelectorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::CssPathPseudoSelector = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAnimationInterpolationFunctionEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::AnimationInterpolationFunction = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInterpolateContext { fn clone(&self) -> Self { let r: &azul_impl::css::InterpolateResolver = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLinearGradient { fn clone(&self) -> Self { let r: &azul_impl::css::LinearGradient = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRadialGradient { fn clone(&self) -> Self { let r: &azul_impl::css::RadialGradient = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzConicGradient { fn clone(&self) -> Self { let r: &azul_impl::css::ConicGradient = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTransform = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundPositionVecValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackgroundPositionVecValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundRepeatVecValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackgroundRepeatVecValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundSizeVecValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackgroundSizeVecValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckBoxStateWrapper { fn clone(&self) -> Self { let r: &crate::widgets::check_box::CheckBoxStateWrapper = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputStateWrapper { fn clone(&self) -> Self { let r: &crate::widgets::number_input::NumberInputStateWrapper = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphCallbacks { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeGraphCallbacks = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputConnection { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputConnection = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOutputConnection { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OutputConnection = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyledNode { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::StyledNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTagIdToNodeIdMapping { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::TagIdToNodeIdMapping = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTexture { fn clone(&self) -> Self { let r: &azul_impl::gl::Texture = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGetProgramBinaryReturn { fn clone(&self) -> Self { let r: &azul_impl::gl::GetProgramBinaryReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRawImageDataEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::resources::RawImageData = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFontSource { fn clone(&self) -> Self { let r: &azul_impl::resources::LoadedFontSource = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPathElementEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgPathElement = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedSvgNode { fn clone(&self) -> Self { let r: &azul_impl::svg::TessellatedSvgNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedSvgNodeVecRef { fn clone(&self) -> Self { let r: &azul_impl::svg::TessellatedSvgNodeVecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgRenderOptions { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgRenderOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgStrokeStyle { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgStrokeStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXml { fn clone(&self) -> Self { let r: &azul_impl::xml::Xml = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInstantEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::task::Instant = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadReceiveMsgEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::task::ThreadReceiveMsg = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzString { fn clone(&self) -> Self { let r: &azul_impl::css::AzString = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputConnectionVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputConnectionVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOutputConnectionVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OutputConnectionVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedSvgNodeVec { fn clone(&self) -> Self { let r: &azul_impl::svg::TessellatedSvgNodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformVec { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTransformVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPathElementVec { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgPathElementVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringVec { fn clone(&self) -> Self { let r: &azul_impl::css::StringVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyledNodeVec { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::StyledNodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTagIdToNodeIdMappingVec { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::TagIdToNodeIdMappingVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionResolvedTextLayoutOptionsEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::ui_solver::OptionResolvedTextLayoutOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionVirtualKeyCodeComboEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionVirtualKeyCodeCombo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionMouseStateEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionMouseState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionKeyboardStateEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionKeyboardState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionStringVecEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::OptionStringVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionThreadReceiveMsgEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::task::OptionThreadReceiveMsg = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTaskBarIconEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionTaskBarIcon = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionWindowIconEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionWindowIcon = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionStringEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::OptionAzString = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTextureEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::gl::OptionTexture = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionInstantEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::task::OptionInstant = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDuplicatedNamespaceError { fn clone(&self) -> Self { let r: &azul_impl::xml::DuplicatedNamespaceError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzUnknownNamespaceError { fn clone(&self) -> Self { let r: &azul_impl::xml::UnknownNamespaceError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzUnexpectedCloseTagError { fn clone(&self) -> Self { let r: &azul_impl::xml::UnexpectedCloseTagError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzUnknownEntityReferenceError { fn clone(&self) -> Self { let r: &azul_impl::xml::UnknownEntityReferenceError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDuplicatedAttributeError { fn clone(&self) -> Self { let r: &azul_impl::xml::DuplicatedAttributeError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInvalidStringError { fn clone(&self) -> Self { let r: &azul_impl::xml::InvalidStringError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowsWindowOptions { fn clone(&self) -> Self { let r: &azul_core::window::WindowsWindowOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWaylandTheme { fn clone(&self) -> Self { let r: &azul_core::window::WaylandTheme = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringPair { fn clone(&self) -> Self { let r: &azul_core::window::AzStringPair = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMonitor { fn clone(&self) -> Self { let r: &azul_core::window::Monitor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutCallbackEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::callbacks::LayoutCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineWordEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineWord = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCallbackData { fn clone(&self) -> Self { let r: &azul_impl::dom::CallbackData = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::NodeType = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityInfo { fn clone(&self) -> Self { let r: &azul_impl::dom::AccessibilityInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIdOrClassEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::IdOrClass = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringMenuItem { fn clone(&self) -> Self { let r: &azul_core::window::StringMenuItem = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPathSelectorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::CssPathSelector = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundContentEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackgroundContent = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzScrollbarInfo { fn clone(&self) -> Self { let r: &azul_impl::css::ScrollbarInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzScrollbarStyle { fn clone(&self) -> Self { let r: &azul_impl::css::ScrollbarStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontFamilyEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleFontFamily = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzScrollbarStyleValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::ScrollbarStyleValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformVecValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleTransformVecValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorInputStateWrapper { fn clone(&self) -> Self { let r: &crate::widgets::color_input::ColorInputStateWrapper = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputState { fn clone(&self) -> Self { let r: &crate::widgets::text_input::TextInputState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeFieldValueEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeTypeFieldValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeInfo { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeTypeInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputOutputInfo { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputOutputInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListView { fn clone(&self) -> Self { let r: &crate::widgets::list_view::ListView = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTreeView { fn clone(&self) -> Self { let r: &crate::widgets::tree_view::TreeView = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDropDown { fn clone(&self) -> Self { let r: &crate::widgets::drop_down::DropDown = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexAttribute { fn clone(&self) -> Self { let r: &azul_impl::gl::VertexAttribute = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDebugMessage { fn clone(&self) -> Self { let r: &azul_impl::gl::AzDebugMessage = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGetActiveAttribReturn { fn clone(&self) -> Self { let r: &azul_impl::gl::GetActiveAttribReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGetActiveUniformReturn { fn clone(&self) -> Self { let r: &azul_impl::gl::GetActiveUniformReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRawImage { fn clone(&self) -> Self { let r: &azul_impl::resources::RawImage = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPath { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgPath = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgParseOptions { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgParseOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgStyleEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFile { fn clone(&self) -> Self { let r: &azul_impl::file::File = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFileTypeList { fn clone(&self) -> Self { let r: &azul_impl::dialogs::FileTypeList = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTimer { fn clone(&self) -> Self { let r: &azul_impl::task::Timer = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFmtValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::str::FmtValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFmtArg { fn clone(&self) -> Self { let r: &azul_impl::str::FmtArg = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontFamilyVec { fn clone(&self) -> Self { let r: &azul_impl::css::StyleFontFamilyVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFmtArgVec { fn clone(&self) -> Self { let r: &azul_impl::str::FmtArgVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineWordVec { fn clone(&self) -> Self { let r: &azul_impl::callbacks::InlineWordVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMonitorVec { fn clone(&self) -> Self { let r: &azul_core::window::MonitorVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIdOrClassVec { fn clone(&self) -> Self { let r: &azul_impl::dom::IdOrClassVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundContentVec { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackgroundContentVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPathVec { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgPathVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexAttributeVec { fn clone(&self) -> Self { let r: &azul_impl::gl::VertexAttributeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPathSelectorVec { fn clone(&self) -> Self { let r: &azul_impl::css::CssPathSelectorVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCallbackDataVec { fn clone(&self) -> Self { let r: &azul_impl::dom::CallbackDataVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDebugMessageVec { fn clone(&self) -> Self { let r: &azul_impl::gl::AzDebugMessageVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringPairVec { fn clone(&self) -> Self { let r: &azul_core::window::StringPairVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionFileTypeListEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dialogs::OptionFileTypeList = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionFileEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::file::OptionFile = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionRawImageEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::resources::OptionRawImage = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionWaylandThemeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionWaylandTheme = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzResultRawImageDecodeImageErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::resources::decode::ResultRawImageDecodeImageError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlStreamErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::xml::XmlStreamError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLinuxWindowOptions { fn clone(&self) -> Self { let r: &azul_core::window::LinuxWindowOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineLine { fn clone(&self) -> Self { let r: &azul_impl::callbacks::InlineLine = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuItemEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::MenuItem = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPath { fn clone(&self) -> Self { let r: &azul_impl::css::CssPath = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundContentVecValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleBackgroundContentVecValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontFamilyVecValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::StyleFontFamilyVecValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPropertyEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::CssProperty = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputStateWrapper { fn clone(&self) -> Self { let r: &crate::widgets::text_input::TextInputStateWrapper = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzProgressBar { fn clone(&self) -> Self { let r: &crate::widgets::progressbar::ProgressBar = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeIdInfoMap { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeTypeIdInfoMap = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputOutputTypeIdInfoMap { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputOutputTypeIdInfoMap = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeField { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeTypeField = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPropertySourceEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::CssPropertySource = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexLayout { fn clone(&self) -> Self { let r: &azul_impl::gl::VertexLayout = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexArrayObject { fn clone(&self) -> Self { let r: &azul_impl::gl::VertexArrayObject = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexBuffer { fn clone(&self) -> Self { let r: &azul_impl::gl::VertexBuffer = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgMultiPolygon { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgMultiPolygon = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedGPUSvgNode { fn clone(&self) -> Self { let r: &azul_impl::svg::TessellatedGPUSvgNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlNode { fn clone(&self) -> Self { let r: &azul_impl::xml::XmlNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeIdInfoMapVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeTypeIdInfoMapVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputOutputTypeIdInfoMapVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeFieldVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeTypeFieldVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineLineVec { fn clone(&self) -> Self { let r: &azul_impl::callbacks::InlineLineVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPropertyVec { fn clone(&self) -> Self { let r: &azul_impl::css::CssPropertyVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgMultiPolygonVec { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgMultiPolygonVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionCssPropertyEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::OptionCssProperty = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlTextError { fn clone(&self) -> Self { let r: &azul_impl::xml::XmlTextError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPlatformSpecificOptions { fn clone(&self) -> Self { let r: &azul_core::window::PlatformSpecificOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowState { fn clone(&self) -> Self { let r: &azul_core::window::WindowState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCallbackInfo { fn clone(&self) -> Self { let r: &azul_impl::callbacks::CallbackInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineText { fn clone(&self) -> Self { let r: &azul_impl::callbacks::InlineText = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFocusTargetPath { fn clone(&self) -> Self { let r: &azul_impl::callbacks::FocusTargetPath = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAnimation { fn clone(&self) -> Self { let r: &azul_impl::callbacks::Animation = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTimerCallbackInfo { fn clone(&self) -> Self { let r: &azul_impl::callbacks::TimerCallbackInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDataInlineCssPropertyEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::NodeDataInlineCssProperty = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDynamicCssProperty { fn clone(&self) -> Self { let r: &azul_impl::css::DynamicCssProperty = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNode { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::Node = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgNodeEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgStyledNode { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgStyledNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDataInlineCssPropertyVec { fn clone(&self) -> Self { let r: &azul_impl::dom::NodeDataInlineCssPropertyVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionWindowStateEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionWindowState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionInlineTextEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::callbacks::OptionInlineText = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlParseErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::xml::XmlParseError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowCreateOptions { fn clone(&self) -> Self { let r: &azul_core::window::WindowCreateOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFocusTargetEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::callbacks::FocusTarget = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeData { fn clone(&self) -> Self { let r: &azul_impl::dom::NodeData = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssDeclarationEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::css::CssDeclaration = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzButton { fn clone(&self) -> Self { let r: &crate::widgets::button::Button = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckBox { fn clone(&self) -> Self { let r: &crate::widgets::check_box::CheckBox = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLabel { fn clone(&self) -> Self { let r: &crate::widgets::label::Label = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorInput { fn clone(&self) -> Self { let r: &crate::widgets::color_input::ColorInput = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInput { fn clone(&self) -> Self { let r: &crate::widgets::text_input::TextInput = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInput { fn clone(&self) -> Self { let r: &crate::widgets::number_input::NumberInput = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeIdNodeMap { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeIdNodeMap = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeIdNodeMapVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeIdNodeMapVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssDeclarationVec { fn clone(&self) -> Self { let r: &azul_impl::css::CssDeclarationVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDataVec { fn clone(&self) -> Self { let r: &azul_impl::dom::NodeDataVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::xml::XmlError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDom { fn clone(&self) -> Self { let r: &azul_impl::dom::Dom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssRuleBlock { fn clone(&self) -> Self { let r: &azul_impl::css::CssRuleBlock = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTab { fn clone(&self) -> Self { let r: &crate::widgets::tabs::Tab = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFrame { fn clone(&self) -> Self { let r: &crate::widgets::frame::Frame = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraph { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeGraph = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyledDom { fn clone(&self) -> Self { let r: &azul_impl::styled_dom::StyledDom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTabVec { fn clone(&self) -> Self { let r: &crate::widgets::tabs::TabVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssRuleBlockVec { fn clone(&self) -> Self { let r: &azul_impl::css::CssRuleBlockVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionDomEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::dom::OptionDom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzResultXmlXmlErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::xml::ResultXmlXmlError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgParseErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::SvgParseError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIFrameCallbackReturn { fn clone(&self) -> Self { let r: &azul_impl::callbacks::IFrameCallbackReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStylesheet { fn clone(&self) -> Self { let r: &azul_impl::css::Stylesheet = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTabContainer { fn clone(&self) -> Self { let r: &crate::widgets::tabs::TabContainer = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStylesheetVec { fn clone(&self) -> Self { let r: &azul_impl::css::StylesheetVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzResultSvgXmlNodeSvgParseErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::ResultSvgXmlNodeSvgParseError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzResultSvgSvgParseErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_impl::svg::ResultSvgSvgParseError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCss { fn clone(&self) -> Self { let r: &azul_impl::css::Css = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }

// Implement Drop for all objects with drop constructors
impl Drop for AzApp { fn drop(&mut self) { crate::AzApp_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzRefCount { fn drop(&mut self) { crate::AzRefCount_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCssPropertyCache { fn drop(&mut self) { crate::AzCssPropertyCache_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzGlVoidPtrConst { fn drop(&mut self) { crate::AzGlVoidPtrConst_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzGLsyncPtr { fn drop(&mut self) { crate::AzGLsyncPtr_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzImageRef { fn drop(&mut self) { crate::AzImageRef_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzFontRef { fn drop(&mut self) { crate::AzFontRef_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvg { fn drop(&mut self) { crate::AzSvg_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgXmlNode { fn drop(&mut self) { crate::AzSvgXmlNode_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSystemClipboard { fn drop(&mut self) { crate::AzSystemClipboard_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzThread { fn drop(&mut self) { crate::AzThread_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzThreadSender { fn drop(&mut self) { crate::AzThreadSender_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzThreadReceiver { fn drop(&mut self) { crate::AzThreadReceiver_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzRefAny { fn drop(&mut self) { crate::AzRefAny_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzGl { fn drop(&mut self) { crate::AzGl_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInstantPtr { fn drop(&mut self) { crate::AzInstantPtr_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzLogicalRectVec { fn drop(&mut self) { crate::AzLogicalRectVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInputOutputTypeIdVec { fn drop(&mut self) { crate::AzInputOutputTypeIdVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzOutputNodeAndIndexVec { fn drop(&mut self) { crate::AzOutputNodeAndIndexVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInputNodeAndIndexVec { fn drop(&mut self) { crate::AzInputNodeAndIndexVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzAccessibilityStateVec { fn drop(&mut self) { crate::AzAccessibilityStateVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzMenuItemVec { fn drop(&mut self) { crate::AzMenuItemVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzXmlNodeVec { fn drop(&mut self) { crate::AzXmlNodeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInlineGlyphVec { fn drop(&mut self) { crate::AzInlineGlyphVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInlineTextHitVec { fn drop(&mut self) { crate::AzInlineTextHitVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzVideoModeVec { fn drop(&mut self) { crate::AzVideoModeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzDomVec { fn drop(&mut self) { crate::AzDomVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleBackgroundPositionVec { fn drop(&mut self) { crate::AzStyleBackgroundPositionVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleBackgroundRepeatVec { fn drop(&mut self) { crate::AzStyleBackgroundRepeatVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleBackgroundSizeVec { fn drop(&mut self) { crate::AzStyleBackgroundSizeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgVertexVec { fn drop(&mut self) { crate::AzSvgVertexVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzU32Vec { fn drop(&mut self) { crate::AzU32Vec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzXWindowTypeVec { fn drop(&mut self) { crate::AzXWindowTypeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzVirtualKeyCodeVec { fn drop(&mut self) { crate::AzVirtualKeyCodeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCascadeInfoVec { fn drop(&mut self) { crate::AzCascadeInfoVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzScanCodeVec { fn drop(&mut self) { crate::AzScanCodeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzU16Vec { fn drop(&mut self) { crate::AzU16Vec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzF32Vec { fn drop(&mut self) { crate::AzF32Vec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzU8Vec { fn drop(&mut self) { crate::AzU8Vec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzGLuintVec { fn drop(&mut self) { crate::AzGLuintVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzGLintVec { fn drop(&mut self) { crate::AzGLintVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNormalizedLinearColorStopVec { fn drop(&mut self) { crate::AzNormalizedLinearColorStopVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNormalizedRadialColorStopVec { fn drop(&mut self) { crate::AzNormalizedRadialColorStopVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeIdVec { fn drop(&mut self) { crate::AzNodeIdVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeHierarchyItemVec { fn drop(&mut self) { crate::AzNodeHierarchyItemVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzParentWithNodeDepthVec { fn drop(&mut self) { crate::AzParentWithNodeDepthVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzTexture { fn drop(&mut self) { crate::AzTexture_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInputConnectionVec { fn drop(&mut self) { crate::AzInputConnectionVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzOutputConnectionVec { fn drop(&mut self) { crate::AzOutputConnectionVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzTessellatedSvgNodeVec { fn drop(&mut self) { crate::AzTessellatedSvgNodeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleTransformVec { fn drop(&mut self) { crate::AzStyleTransformVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgPathElementVec { fn drop(&mut self) { crate::AzSvgPathElementVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStringVec { fn drop(&mut self) { crate::AzStringVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyledNodeVec { fn drop(&mut self) { crate::AzStyledNodeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzTagIdToNodeIdMappingVec { fn drop(&mut self) { crate::AzTagIdToNodeIdMappingVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzFile { fn drop(&mut self) { crate::AzFile_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleFontFamilyVec { fn drop(&mut self) { crate::AzStyleFontFamilyVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzFmtArgVec { fn drop(&mut self) { crate::AzFmtArgVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInlineWordVec { fn drop(&mut self) { crate::AzInlineWordVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzMonitorVec { fn drop(&mut self) { crate::AzMonitorVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzIdOrClassVec { fn drop(&mut self) { crate::AzIdOrClassVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleBackgroundContentVec { fn drop(&mut self) { crate::AzStyleBackgroundContentVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgPathVec { fn drop(&mut self) { crate::AzSvgPathVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzVertexAttributeVec { fn drop(&mut self) { crate::AzVertexAttributeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCssPathSelectorVec { fn drop(&mut self) { crate::AzCssPathSelectorVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCallbackDataVec { fn drop(&mut self) { crate::AzCallbackDataVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzDebugMessageVec { fn drop(&mut self) { crate::AzDebugMessageVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStringPairVec { fn drop(&mut self) { crate::AzStringPairVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzVertexArrayObject { fn drop(&mut self) { crate::AzVertexArrayObject_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzVertexBuffer { fn drop(&mut self) { crate::AzVertexBuffer_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeTypeIdInfoMapVec { fn drop(&mut self) { crate::AzNodeTypeIdInfoMapVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInputOutputTypeIdInfoMapVec { fn drop(&mut self) { crate::AzInputOutputTypeIdInfoMapVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeTypeFieldVec { fn drop(&mut self) { crate::AzNodeTypeFieldVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInlineLineVec { fn drop(&mut self) { crate::AzInlineLineVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCssPropertyVec { fn drop(&mut self) { crate::AzCssPropertyVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgMultiPolygonVec { fn drop(&mut self) { crate::AzSvgMultiPolygonVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeDataInlineCssPropertyVec { fn drop(&mut self) { crate::AzNodeDataInlineCssPropertyVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeIdNodeMapVec { fn drop(&mut self) { crate::AzNodeIdNodeMapVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCssDeclarationVec { fn drop(&mut self) { crate::AzCssDeclarationVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeDataVec { fn drop(&mut self) { crate::AzNodeDataVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzTabVec { fn drop(&mut self) { crate::AzTabVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCssRuleBlockVec { fn drop(&mut self) { crate::AzCssRuleBlockVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStylesheetVec { fn drop(&mut self) { crate::AzStylesheetVec_delete(unsafe { mem::transmute(self) }); } }


#[pymethods]
impl AzApp {
    fn add_window(&mut self, window: AzWindowCreateOptions) -> () {
        unsafe { mem::transmute(crate::AzApp_addWindow(
            mem::transmute(self),
            mem::transmute(window),
        )) }
    }
    fn add_image(&mut self, id: String, image: AzImageRef) -> () {
        let id = pystring_to_azstring(&id);
        unsafe { mem::transmute(crate::AzApp_addImage(
            mem::transmute(self),
            mem::transmute(id),
            mem::transmute(image),
        )) }
    }
    fn get_monitors(&self) -> AzMonitorVec {
        unsafe { mem::transmute(crate::AzApp_getMonitors(
            mem::transmute(self),
        )) }
    }
    fn run(&self, window: AzWindowCreateOptions) -> () {
        unsafe { mem::transmute(crate::AzApp_run(
            mem::transmute(self),
            mem::transmute(window),
        )) }
    }
    // impl App {

    #[new]
    pub fn new(py: Python, data: PyObject, config: AzAppConfig) -> Result<Self, PyErr> {
        use pyo3::type_object::PyTypeInfo;

        if data.as_ref(py).is_callable() {
            return Err(PyException::new_err(format!("ERROR in App.new: - argument \"data\" is a function callback, expected class")));
        }

        let app_refany = azul_impl::callbacks::RefAny::new(AppDataTy { _py_app_data: Some(data) });
        Ok(unsafe { mem::transmute(crate::AzApp_new(app_refany, mem::transmute(config))) })
    }}

#[pyproto]
impl PyObjectProtocol for AzApp {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::app::AzAppPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::app::AzAppPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAppConfig {
    #[new]
    fn new(layout_solver: AzLayoutSolverEnumWrapper) -> AzAppConfig {
        unsafe { mem::transmute(crate::AzAppConfig_new(
            mem::transmute(layout_solver),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAppConfig {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::AppConfig = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::AppConfig = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAppLogLevelEnumWrapper {
    #[classattr]
    fn Off() -> AzAppLogLevelEnumWrapper { AzAppLogLevelEnumWrapper { inner: AzAppLogLevel::Off } }
    #[classattr]
    fn Error() -> AzAppLogLevelEnumWrapper { AzAppLogLevelEnumWrapper { inner: AzAppLogLevel::Error } }
    #[classattr]
    fn Warn() -> AzAppLogLevelEnumWrapper { AzAppLogLevelEnumWrapper { inner: AzAppLogLevel::Warn } }
    #[classattr]
    fn Info() -> AzAppLogLevelEnumWrapper { AzAppLogLevelEnumWrapper { inner: AzAppLogLevel::Info } }
    #[classattr]
    fn Debug() -> AzAppLogLevelEnumWrapper { AzAppLogLevelEnumWrapper { inner: AzAppLogLevel::Debug } }
    #[classattr]
    fn Trace() -> AzAppLogLevelEnumWrapper { AzAppLogLevelEnumWrapper { inner: AzAppLogLevel::Trace } }
}

#[pyproto]
impl PyObjectProtocol for AzAppLogLevelEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::AppLogLevel = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::AppLogLevel = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAppLogLevelEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutSolverEnumWrapper {
    #[classattr]
    fn Default() -> AzLayoutSolverEnumWrapper { AzLayoutSolverEnumWrapper { inner: AzLayoutSolver::Default } }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutSolverEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::LayoutSolverVersion = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::LayoutSolverVersion = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutSolverEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSystemCallbacks {
    #[staticmethod]
    fn library_internal() -> AzSystemCallbacks {
        unsafe { mem::transmute(crate::AzSystemCallbacks_libraryInternal()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSystemCallbacks {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ExternalSystemCallbacks = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ExternalSystemCallbacks = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowCreateOptions {
    // impl WindowCreateOptions {

    #[new]
    pub fn __new__(py: Python, cb: PyObject) -> Result<Self, PyErr> {
        let window = azul_core::window::WindowCreateOptions {
            state: unsafe { mem::transmute(AzWindowState::__new__(py, cb)?) },
            .. Default::default()
        };
        Ok(unsafe { mem::transmute(window) })
    }}

#[pyproto]
impl PyObjectProtocol for AzWindowCreateOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowCreateOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowCreateOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRendererOptions {
    #[new]
    fn __new__(vsync: AzVsyncEnumWrapper, srgb: AzSrgbEnumWrapper, hw_accel: AzHwAccelerationEnumWrapper) -> Self {
        Self {
            vsync,
            srgb,
            hw_accel,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzRendererOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::RendererOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::RendererOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVsyncEnumWrapper {
    #[classattr]
    fn Enabled() -> AzVsyncEnumWrapper { AzVsyncEnumWrapper { inner: AzVsync::Enabled } }
    #[classattr]
    fn Disabled() -> AzVsyncEnumWrapper { AzVsyncEnumWrapper { inner: AzVsync::Disabled } }
    #[classattr]
    fn DontCare() -> AzVsyncEnumWrapper { AzVsyncEnumWrapper { inner: AzVsync::DontCare } }
}

#[pyproto]
impl PyObjectProtocol for AzVsyncEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Vsync = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Vsync = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzVsyncEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSrgbEnumWrapper {
    #[classattr]
    fn Enabled() -> AzSrgbEnumWrapper { AzSrgbEnumWrapper { inner: AzSrgb::Enabled } }
    #[classattr]
    fn Disabled() -> AzSrgbEnumWrapper { AzSrgbEnumWrapper { inner: AzSrgb::Disabled } }
    #[classattr]
    fn DontCare() -> AzSrgbEnumWrapper { AzSrgbEnumWrapper { inner: AzSrgb::DontCare } }
}

#[pyproto]
impl PyObjectProtocol for AzSrgbEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Srgb = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Srgb = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzSrgbEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzHwAccelerationEnumWrapper {
    #[classattr]
    fn Enabled() -> AzHwAccelerationEnumWrapper { AzHwAccelerationEnumWrapper { inner: AzHwAcceleration::Enabled } }
    #[classattr]
    fn Disabled() -> AzHwAccelerationEnumWrapper { AzHwAccelerationEnumWrapper { inner: AzHwAcceleration::Disabled } }
    #[classattr]
    fn DontCare() -> AzHwAccelerationEnumWrapper { AzHwAccelerationEnumWrapper { inner: AzHwAcceleration::DontCare } }
}

#[pyproto]
impl PyObjectProtocol for AzHwAccelerationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::HwAcceleration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::HwAcceleration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzHwAccelerationEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutPoint {
    #[new]
    fn __new__(x: isize, y: isize) -> Self {
        Self {
            x,
            y,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutPoint {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutSize {
    #[new]
    fn __new__(width: isize, height: isize) -> Self {
        Self {
            width,
            height,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutSize {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutRect {
    #[new]
    fn __new__(origin: AzLayoutPoint, size: AzLayoutSize) -> Self {
        Self {
            origin,
            size,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutRect {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRawWindowHandleEnumWrapper {
    #[staticmethod]
    fn IOS(v: AzIOSHandle) -> AzRawWindowHandleEnumWrapper { AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::IOS(v) } }
    #[staticmethod]
    fn MacOS(v: AzMacOSHandle) -> AzRawWindowHandleEnumWrapper { AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::MacOS(v) } }
    #[staticmethod]
    fn Xlib(v: AzXlibHandle) -> AzRawWindowHandleEnumWrapper { AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::Xlib(v) } }
    #[staticmethod]
    fn Xcb(v: AzXcbHandle) -> AzRawWindowHandleEnumWrapper { AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::Xcb(v) } }
    #[staticmethod]
    fn Wayland(v: AzWaylandHandle) -> AzRawWindowHandleEnumWrapper { AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::Wayland(v) } }
    #[staticmethod]
    fn Windows(v: AzWindowsHandle) -> AzRawWindowHandleEnumWrapper { AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::Windows(v) } }
    #[staticmethod]
    fn Web(v: AzWebHandle) -> AzRawWindowHandleEnumWrapper { AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::Web(v) } }
    #[staticmethod]
    fn Android(v: AzAndroidHandle) -> AzRawWindowHandleEnumWrapper { AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::Android(v) } }
    #[classattr]
    fn Unsupported() -> AzRawWindowHandleEnumWrapper { AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::Unsupported } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzRawWindowHandle;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzRawWindowHandle::IOS(v) => Ok(vec!["IOS".into_py(py), v.clone().into_py(py)]),
            AzRawWindowHandle::MacOS(v) => Ok(vec!["MacOS".into_py(py), v.clone().into_py(py)]),
            AzRawWindowHandle::Xlib(v) => Ok(vec!["Xlib".into_py(py), v.clone().into_py(py)]),
            AzRawWindowHandle::Xcb(v) => Ok(vec!["Xcb".into_py(py), v.clone().into_py(py)]),
            AzRawWindowHandle::Wayland(v) => Ok(vec!["Wayland".into_py(py), v.clone().into_py(py)]),
            AzRawWindowHandle::Windows(v) => Ok(vec!["Windows".into_py(py), v.clone().into_py(py)]),
            AzRawWindowHandle::Web(v) => Ok(vec!["Web".into_py(py), v.clone().into_py(py)]),
            AzRawWindowHandle::Android(v) => Ok(vec!["Android".into_py(py), v.clone().into_py(py)]),
            AzRawWindowHandle::Unsupported => Ok(vec!["Unsupported".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRawWindowHandleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::RawWindowHandle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::RawWindowHandle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIOSHandle {
}

#[pyproto]
impl PyObjectProtocol for AzIOSHandle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::IOSHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::IOSHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMacOSHandle {
}

#[pyproto]
impl PyObjectProtocol for AzMacOSHandle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MacOSHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MacOSHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXlibHandle {
}

#[pyproto]
impl PyObjectProtocol for AzXlibHandle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XlibHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XlibHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXcbHandle {
}

#[pyproto]
impl PyObjectProtocol for AzXcbHandle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XcbHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XcbHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWaylandHandle {
}

#[pyproto]
impl PyObjectProtocol for AzWaylandHandle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WaylandHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WaylandHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowsHandle {
}

#[pyproto]
impl PyObjectProtocol for AzWindowsHandle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowsHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowsHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWebHandle {
    #[new]
    fn __new__(id: u32) -> Self {
        Self {
            id,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzWebHandle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WebHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WebHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAndroidHandle {
}

#[pyproto]
impl PyObjectProtocol for AzAndroidHandle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::AndroidHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::AndroidHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXWindowTypeEnumWrapper {
    #[classattr]
    fn Desktop() -> AzXWindowTypeEnumWrapper { AzXWindowTypeEnumWrapper { inner: AzXWindowType::Desktop } }
    #[classattr]
    fn Dock() -> AzXWindowTypeEnumWrapper { AzXWindowTypeEnumWrapper { inner: AzXWindowType::Dock } }
    #[classattr]
    fn Toolbar() -> AzXWindowTypeEnumWrapper { AzXWindowTypeEnumWrapper { inner: AzXWindowType::Toolbar } }
    #[classattr]
    fn Menu() -> AzXWindowTypeEnumWrapper { AzXWindowTypeEnumWrapper { inner: AzXWindowType::Menu } }
    #[classattr]
    fn Utility() -> AzXWindowTypeEnumWrapper { AzXWindowTypeEnumWrapper { inner: AzXWindowType::Utility } }
    #[classattr]
    fn Splash() -> AzXWindowTypeEnumWrapper { AzXWindowTypeEnumWrapper { inner: AzXWindowType::Splash } }
    #[classattr]
    fn Dialog() -> AzXWindowTypeEnumWrapper { AzXWindowTypeEnumWrapper { inner: AzXWindowType::Dialog } }
    #[classattr]
    fn DropdownMenu() -> AzXWindowTypeEnumWrapper { AzXWindowTypeEnumWrapper { inner: AzXWindowType::DropdownMenu } }
    #[classattr]
    fn PopupMenu() -> AzXWindowTypeEnumWrapper { AzXWindowTypeEnumWrapper { inner: AzXWindowType::PopupMenu } }
    #[classattr]
    fn Tooltip() -> AzXWindowTypeEnumWrapper { AzXWindowTypeEnumWrapper { inner: AzXWindowType::Tooltip } }
    #[classattr]
    fn Notification() -> AzXWindowTypeEnumWrapper { AzXWindowTypeEnumWrapper { inner: AzXWindowType::Notification } }
    #[classattr]
    fn Combo() -> AzXWindowTypeEnumWrapper { AzXWindowTypeEnumWrapper { inner: AzXWindowType::Combo } }
    #[classattr]
    fn Dnd() -> AzXWindowTypeEnumWrapper { AzXWindowTypeEnumWrapper { inner: AzXWindowType::Dnd } }
    #[classattr]
    fn Normal() -> AzXWindowTypeEnumWrapper { AzXWindowTypeEnumWrapper { inner: AzXWindowType::Normal } }
}

#[pyproto]
impl PyObjectProtocol for AzXWindowTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzXWindowTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzPhysicalPositionI32 {
    #[new]
    fn __new__(x: i32, y: i32) -> Self {
        Self {
            x,
            y,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzPhysicalPositionI32 {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::PhysicalPositionI32 = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::PhysicalPositionI32 = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPhysicalSizeU32 {
    #[new]
    fn __new__(width: u32, height: u32) -> Self {
        Self {
            width,
            height,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzPhysicalSizeU32 {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::PhysicalSizeU32 = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::PhysicalSizeU32 = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalRect {
    #[new]
    fn __new__(origin: AzLogicalPosition, size: AzLogicalSize) -> Self {
        Self {
            origin,
            size,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLogicalRect {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LogicalRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LogicalRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalPosition {
    #[new]
    fn __new__(x: f32, y: f32) -> Self {
        Self {
            x,
            y,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLogicalPosition {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LogicalPosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LogicalPosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalSize {
    #[new]
    fn __new__(width: f32, height: f32) -> Self {
        Self {
            width,
            height,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLogicalSize {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LogicalSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LogicalSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIconKey {
    #[new]
    fn __new__(id: usize) -> Self {
        Self {
            id,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzIconKey {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::IconKey = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::IconKey = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSmallWindowIconBytes {
    #[new]
    fn __new__(key: AzIconKey, rgba_bytes: AzU8Vec) -> Self {
        Self {
            key,
            rgba_bytes,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSmallWindowIconBytes {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::SmallWindowIconBytes = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::SmallWindowIconBytes = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLargeWindowIconBytes {
    #[new]
    fn __new__(key: AzIconKey, rgba_bytes: AzU8Vec) -> Self {
        Self {
            key,
            rgba_bytes,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLargeWindowIconBytes {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LargeWindowIconBytes = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LargeWindowIconBytes = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowIconEnumWrapper {
    #[staticmethod]
    fn Small(v: AzSmallWindowIconBytes) -> AzWindowIconEnumWrapper { AzWindowIconEnumWrapper { inner: AzWindowIcon::Small(v) } }
    #[staticmethod]
    fn Large(v: AzLargeWindowIconBytes) -> AzWindowIconEnumWrapper { AzWindowIconEnumWrapper { inner: AzWindowIcon::Large(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzWindowIcon;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzWindowIcon::Small(v) => Ok(vec!["Small".into_py(py), v.clone().into_py(py)]),
            AzWindowIcon::Large(v) => Ok(vec!["Large".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzWindowIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTaskBarIcon {
    #[new]
    fn __new__(key: AzIconKey, rgba_bytes: AzU8Vec) -> Self {
        Self {
            key,
            rgba_bytes,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzTaskBarIcon {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::TaskBarIcon = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::TaskBarIcon = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVirtualKeyCodeEnumWrapper {
    #[classattr]
    fn Key1() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Key1 } }
    #[classattr]
    fn Key2() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Key2 } }
    #[classattr]
    fn Key3() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Key3 } }
    #[classattr]
    fn Key4() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Key4 } }
    #[classattr]
    fn Key5() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Key5 } }
    #[classattr]
    fn Key6() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Key6 } }
    #[classattr]
    fn Key7() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Key7 } }
    #[classattr]
    fn Key8() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Key8 } }
    #[classattr]
    fn Key9() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Key9 } }
    #[classattr]
    fn Key0() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Key0 } }
    #[classattr]
    fn A() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::A } }
    #[classattr]
    fn B() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::B } }
    #[classattr]
    fn C() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::C } }
    #[classattr]
    fn D() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::D } }
    #[classattr]
    fn E() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::E } }
    #[classattr]
    fn F() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F } }
    #[classattr]
    fn G() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::G } }
    #[classattr]
    fn H() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::H } }
    #[classattr]
    fn I() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::I } }
    #[classattr]
    fn J() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::J } }
    #[classattr]
    fn K() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::K } }
    #[classattr]
    fn L() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::L } }
    #[classattr]
    fn M() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::M } }
    #[classattr]
    fn N() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::N } }
    #[classattr]
    fn O() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::O } }
    #[classattr]
    fn P() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::P } }
    #[classattr]
    fn Q() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Q } }
    #[classattr]
    fn R() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::R } }
    #[classattr]
    fn S() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::S } }
    #[classattr]
    fn T() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::T } }
    #[classattr]
    fn U() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::U } }
    #[classattr]
    fn V() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::V } }
    #[classattr]
    fn W() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::W } }
    #[classattr]
    fn X() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::X } }
    #[classattr]
    fn Y() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Y } }
    #[classattr]
    fn Z() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Z } }
    #[classattr]
    fn Escape() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Escape } }
    #[classattr]
    fn F1() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F1 } }
    #[classattr]
    fn F2() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F2 } }
    #[classattr]
    fn F3() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F3 } }
    #[classattr]
    fn F4() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F4 } }
    #[classattr]
    fn F5() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F5 } }
    #[classattr]
    fn F6() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F6 } }
    #[classattr]
    fn F7() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F7 } }
    #[classattr]
    fn F8() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F8 } }
    #[classattr]
    fn F9() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F9 } }
    #[classattr]
    fn F10() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F10 } }
    #[classattr]
    fn F11() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F11 } }
    #[classattr]
    fn F12() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F12 } }
    #[classattr]
    fn F13() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F13 } }
    #[classattr]
    fn F14() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F14 } }
    #[classattr]
    fn F15() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F15 } }
    #[classattr]
    fn F16() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F16 } }
    #[classattr]
    fn F17() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F17 } }
    #[classattr]
    fn F18() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F18 } }
    #[classattr]
    fn F19() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F19 } }
    #[classattr]
    fn F20() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F20 } }
    #[classattr]
    fn F21() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F21 } }
    #[classattr]
    fn F22() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F22 } }
    #[classattr]
    fn F23() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F23 } }
    #[classattr]
    fn F24() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::F24 } }
    #[classattr]
    fn Snapshot() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Snapshot } }
    #[classattr]
    fn Scroll() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Scroll } }
    #[classattr]
    fn Pause() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Pause } }
    #[classattr]
    fn Insert() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Insert } }
    #[classattr]
    fn Home() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Home } }
    #[classattr]
    fn Delete() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Delete } }
    #[classattr]
    fn End() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::End } }
    #[classattr]
    fn PageDown() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::PageDown } }
    #[classattr]
    fn PageUp() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::PageUp } }
    #[classattr]
    fn Left() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Left } }
    #[classattr]
    fn Up() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Up } }
    #[classattr]
    fn Right() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Right } }
    #[classattr]
    fn Down() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Down } }
    #[classattr]
    fn Back() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Back } }
    #[classattr]
    fn Return() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Return } }
    #[classattr]
    fn Space() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Space } }
    #[classattr]
    fn Compose() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Compose } }
    #[classattr]
    fn Caret() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Caret } }
    #[classattr]
    fn Numlock() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Numlock } }
    #[classattr]
    fn Numpad0() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Numpad0 } }
    #[classattr]
    fn Numpad1() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Numpad1 } }
    #[classattr]
    fn Numpad2() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Numpad2 } }
    #[classattr]
    fn Numpad3() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Numpad3 } }
    #[classattr]
    fn Numpad4() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Numpad4 } }
    #[classattr]
    fn Numpad5() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Numpad5 } }
    #[classattr]
    fn Numpad6() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Numpad6 } }
    #[classattr]
    fn Numpad7() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Numpad7 } }
    #[classattr]
    fn Numpad8() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Numpad8 } }
    #[classattr]
    fn Numpad9() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Numpad9 } }
    #[classattr]
    fn NumpadAdd() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::NumpadAdd } }
    #[classattr]
    fn NumpadDivide() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::NumpadDivide } }
    #[classattr]
    fn NumpadDecimal() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::NumpadDecimal } }
    #[classattr]
    fn NumpadComma() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::NumpadComma } }
    #[classattr]
    fn NumpadEnter() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::NumpadEnter } }
    #[classattr]
    fn NumpadEquals() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::NumpadEquals } }
    #[classattr]
    fn NumpadMultiply() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::NumpadMultiply } }
    #[classattr]
    fn NumpadSubtract() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::NumpadSubtract } }
    #[classattr]
    fn AbntC1() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::AbntC1 } }
    #[classattr]
    fn AbntC2() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::AbntC2 } }
    #[classattr]
    fn Apostrophe() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Apostrophe } }
    #[classattr]
    fn Apps() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Apps } }
    #[classattr]
    fn Asterisk() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Asterisk } }
    #[classattr]
    fn At() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::At } }
    #[classattr]
    fn Ax() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Ax } }
    #[classattr]
    fn Backslash() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Backslash } }
    #[classattr]
    fn Calculator() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Calculator } }
    #[classattr]
    fn Capital() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Capital } }
    #[classattr]
    fn Colon() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Colon } }
    #[classattr]
    fn Comma() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Comma } }
    #[classattr]
    fn Convert() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Convert } }
    #[classattr]
    fn Equals() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Equals } }
    #[classattr]
    fn Grave() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Grave } }
    #[classattr]
    fn Kana() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Kana } }
    #[classattr]
    fn Kanji() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Kanji } }
    #[classattr]
    fn LAlt() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::LAlt } }
    #[classattr]
    fn LBracket() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::LBracket } }
    #[classattr]
    fn LControl() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::LControl } }
    #[classattr]
    fn LShift() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::LShift } }
    #[classattr]
    fn LWin() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::LWin } }
    #[classattr]
    fn Mail() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Mail } }
    #[classattr]
    fn MediaSelect() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::MediaSelect } }
    #[classattr]
    fn MediaStop() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::MediaStop } }
    #[classattr]
    fn Minus() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Minus } }
    #[classattr]
    fn Mute() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Mute } }
    #[classattr]
    fn MyComputer() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::MyComputer } }
    #[classattr]
    fn NavigateForward() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::NavigateForward } }
    #[classattr]
    fn NavigateBackward() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::NavigateBackward } }
    #[classattr]
    fn NextTrack() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::NextTrack } }
    #[classattr]
    fn NoConvert() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::NoConvert } }
    #[classattr]
    fn OEM102() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::OEM102 } }
    #[classattr]
    fn Period() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Period } }
    #[classattr]
    fn PlayPause() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::PlayPause } }
    #[classattr]
    fn Plus() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Plus } }
    #[classattr]
    fn Power() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Power } }
    #[classattr]
    fn PrevTrack() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::PrevTrack } }
    #[classattr]
    fn RAlt() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::RAlt } }
    #[classattr]
    fn RBracket() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::RBracket } }
    #[classattr]
    fn RControl() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::RControl } }
    #[classattr]
    fn RShift() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::RShift } }
    #[classattr]
    fn RWin() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::RWin } }
    #[classattr]
    fn Semicolon() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Semicolon } }
    #[classattr]
    fn Slash() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Slash } }
    #[classattr]
    fn Sleep() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Sleep } }
    #[classattr]
    fn Stop() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Stop } }
    #[classattr]
    fn Sysrq() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Sysrq } }
    #[classattr]
    fn Tab() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Tab } }
    #[classattr]
    fn Underline() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Underline } }
    #[classattr]
    fn Unlabeled() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Unlabeled } }
    #[classattr]
    fn VolumeDown() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::VolumeDown } }
    #[classattr]
    fn VolumeUp() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::VolumeUp } }
    #[classattr]
    fn Wake() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Wake } }
    #[classattr]
    fn WebBack() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::WebBack } }
    #[classattr]
    fn WebFavorites() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::WebFavorites } }
    #[classattr]
    fn WebForward() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::WebForward } }
    #[classattr]
    fn WebHome() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::WebHome } }
    #[classattr]
    fn WebRefresh() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::WebRefresh } }
    #[classattr]
    fn WebSearch() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::WebSearch } }
    #[classattr]
    fn WebStop() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::WebStop } }
    #[classattr]
    fn Yen() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Yen } }
    #[classattr]
    fn Copy() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Copy } }
    #[classattr]
    fn Paste() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Paste } }
    #[classattr]
    fn Cut() -> AzVirtualKeyCodeEnumWrapper { AzVirtualKeyCodeEnumWrapper { inner: AzVirtualKeyCode::Cut } }
}

#[pyproto]
impl PyObjectProtocol for AzVirtualKeyCodeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzVirtualKeyCodeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAcceleratorKeyEnumWrapper {
    #[classattr]
    fn Ctrl() -> AzAcceleratorKeyEnumWrapper { AzAcceleratorKeyEnumWrapper { inner: AzAcceleratorKey::Ctrl } }
    #[classattr]
    fn Alt() -> AzAcceleratorKeyEnumWrapper { AzAcceleratorKeyEnumWrapper { inner: AzAcceleratorKey::Alt } }
    #[classattr]
    fn Shift() -> AzAcceleratorKeyEnumWrapper { AzAcceleratorKeyEnumWrapper { inner: AzAcceleratorKey::Shift } }
    #[staticmethod]
    fn Key(v: AzVirtualKeyCodeEnumWrapper) -> AzAcceleratorKeyEnumWrapper { AzAcceleratorKeyEnumWrapper { inner: AzAcceleratorKey::Key(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzAcceleratorKey;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAcceleratorKey::Ctrl => Ok(vec!["Ctrl".into_py(py), ().into_py(py)]),
            AzAcceleratorKey::Alt => Ok(vec!["Alt".into_py(py), ().into_py(py)]),
            AzAcceleratorKey::Shift => Ok(vec!["Shift".into_py(py), ().into_py(py)]),
            AzAcceleratorKey::Key(v) => Ok(vec!["Key".into_py(py), { let m: &AzVirtualKeyCodeEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAcceleratorKeyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::AcceleratorKey = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::AcceleratorKey = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowSize {
    #[new]
    fn __new__(dimensions: AzLogicalSize, hidpi_factor: f32, system_hidpi_factor: f32, dpi: u32, min_dimensions: AzOptionLogicalSizeEnumWrapper, max_dimensions: AzOptionLogicalSizeEnumWrapper) -> Self {
        Self {
            dimensions,
            hidpi_factor,
            system_hidpi_factor,
            dpi,
            min_dimensions,
            max_dimensions,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzWindowSize {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowFlags {
    #[new]
    fn __new__(frame: AzWindowFrameEnumWrapper, is_about_to_close: bool, has_decorations: bool, is_visible: bool, is_always_on_top: bool, is_resizable: bool, has_focus: bool, has_extended_window_frame: bool, has_blur_behind_window: bool, smooth_scroll_enabled: bool, autotab_enabled: bool) -> Self {
        Self {
            frame,
            is_about_to_close,
            has_decorations,
            is_visible,
            is_always_on_top,
            is_resizable,
            has_focus,
            has_extended_window_frame,
            has_blur_behind_window,
            smooth_scroll_enabled,
            autotab_enabled,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzWindowFlags {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowFlags = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowFlags = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowFrameEnumWrapper {
    #[classattr]
    fn Normal() -> AzWindowFrameEnumWrapper { AzWindowFrameEnumWrapper { inner: AzWindowFrame::Normal } }
    #[classattr]
    fn Minimized() -> AzWindowFrameEnumWrapper { AzWindowFrameEnumWrapper { inner: AzWindowFrame::Minimized } }
    #[classattr]
    fn Maximized() -> AzWindowFrameEnumWrapper { AzWindowFrameEnumWrapper { inner: AzWindowFrame::Maximized } }
    #[classattr]
    fn Fullscreen() -> AzWindowFrameEnumWrapper { AzWindowFrameEnumWrapper { inner: AzWindowFrame::Fullscreen } }
}

#[pyproto]
impl PyObjectProtocol for AzWindowFrameEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowFrame = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowFrame = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzWindowFrameEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzDebugState {
    #[new]
    fn __new__(profiler_dbg: bool, render_target_dbg: bool, texture_cache_dbg: bool, gpu_time_queries: bool, gpu_sample_queries: bool, disable_batching: bool, epochs: bool, echo_driver_messages: bool, show_overdraw: bool, gpu_cache_dbg: bool, texture_cache_dbg_clear_evicted: bool, picture_caching_dbg: bool, primitive_dbg: bool, zoom_dbg: bool, small_screen: bool, disable_opaque_pass: bool, disable_alpha_pass: bool, disable_clip_masks: bool, disable_text_prims: bool, disable_gradient_prims: bool, obscure_images: bool, glyph_flashing: bool, smart_profiler: bool, invalidation_dbg: bool, tile_cache_logging_dbg: bool, profiler_capture: bool, force_picture_invalidation: bool) -> Self {
        Self {
            profiler_dbg,
            render_target_dbg,
            texture_cache_dbg,
            gpu_time_queries,
            gpu_sample_queries,
            disable_batching,
            epochs,
            echo_driver_messages,
            show_overdraw,
            gpu_cache_dbg,
            texture_cache_dbg_clear_evicted,
            picture_caching_dbg,
            primitive_dbg,
            zoom_dbg,
            small_screen,
            disable_opaque_pass,
            disable_alpha_pass,
            disable_clip_masks,
            disable_text_prims,
            disable_gradient_prims,
            obscure_images,
            glyph_flashing,
            smart_profiler,
            invalidation_dbg,
            tile_cache_logging_dbg,
            profiler_capture,
            force_picture_invalidation,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzDebugState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::DebugState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::DebugState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzKeyboardState {
    #[new]
    fn __new__(shift_down: bool, ctrl_down: bool, alt_down: bool, super_down: bool, current_char: AzOptionCharEnumWrapper, current_virtual_keycode: AzOptionVirtualKeyCodeEnumWrapper, pressed_virtual_keycodes: AzVirtualKeyCodeVec, pressed_scancodes: AzScanCodeVec) -> Self {
        Self {
            shift_down,
            ctrl_down,
            alt_down,
            super_down,
            current_char,
            current_virtual_keycode,
            pressed_virtual_keycodes,
            pressed_scancodes,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzKeyboardState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::KeyboardState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::KeyboardState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMouseCursorTypeEnumWrapper {
    #[classattr]
    fn Default() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::Default } }
    #[classattr]
    fn Crosshair() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::Crosshair } }
    #[classattr]
    fn Hand() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::Hand } }
    #[classattr]
    fn Arrow() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::Arrow } }
    #[classattr]
    fn Move() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::Move } }
    #[classattr]
    fn Text() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::Text } }
    #[classattr]
    fn Wait() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::Wait } }
    #[classattr]
    fn Help() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::Help } }
    #[classattr]
    fn Progress() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::Progress } }
    #[classattr]
    fn NotAllowed() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::NotAllowed } }
    #[classattr]
    fn ContextMenu() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::ContextMenu } }
    #[classattr]
    fn Cell() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::Cell } }
    #[classattr]
    fn VerticalText() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::VerticalText } }
    #[classattr]
    fn Alias() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::Alias } }
    #[classattr]
    fn Copy() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::Copy } }
    #[classattr]
    fn NoDrop() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::NoDrop } }
    #[classattr]
    fn Grab() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::Grab } }
    #[classattr]
    fn Grabbing() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::Grabbing } }
    #[classattr]
    fn AllScroll() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::AllScroll } }
    #[classattr]
    fn ZoomIn() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::ZoomIn } }
    #[classattr]
    fn ZoomOut() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::ZoomOut } }
    #[classattr]
    fn EResize() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::EResize } }
    #[classattr]
    fn NResize() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::NResize } }
    #[classattr]
    fn NeResize() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::NeResize } }
    #[classattr]
    fn NwResize() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::NwResize } }
    #[classattr]
    fn SResize() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::SResize } }
    #[classattr]
    fn SeResize() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::SeResize } }
    #[classattr]
    fn SwResize() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::SwResize } }
    #[classattr]
    fn WResize() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::WResize } }
    #[classattr]
    fn EwResize() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::EwResize } }
    #[classattr]
    fn NsResize() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::NsResize } }
    #[classattr]
    fn NeswResize() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::NeswResize } }
    #[classattr]
    fn NwseResize() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::NwseResize } }
    #[classattr]
    fn ColResize() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::ColResize } }
    #[classattr]
    fn RowResize() -> AzMouseCursorTypeEnumWrapper { AzMouseCursorTypeEnumWrapper { inner: AzMouseCursorType::RowResize } }
}

#[pyproto]
impl PyObjectProtocol for AzMouseCursorTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MouseCursorType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MouseCursorType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzMouseCursorTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzCursorPositionEnumWrapper {
    #[classattr]
    fn OutOfWindow() -> AzCursorPositionEnumWrapper { AzCursorPositionEnumWrapper { inner: AzCursorPosition::OutOfWindow } }
    #[classattr]
    fn Uninitialized() -> AzCursorPositionEnumWrapper { AzCursorPositionEnumWrapper { inner: AzCursorPosition::Uninitialized } }
    #[staticmethod]
    fn InWindow(v: AzLogicalPosition) -> AzCursorPositionEnumWrapper { AzCursorPositionEnumWrapper { inner: AzCursorPosition::InWindow(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCursorPosition;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCursorPosition::OutOfWindow => Ok(vec!["OutOfWindow".into_py(py), ().into_py(py)]),
            AzCursorPosition::Uninitialized => Ok(vec!["Uninitialized".into_py(py), ().into_py(py)]),
            AzCursorPosition::InWindow(v) => Ok(vec!["InWindow".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCursorPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::CursorPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::CursorPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMouseState {
    #[new]
    fn __new__(mouse_cursor_type: AzOptionMouseCursorTypeEnumWrapper, cursor_position: AzCursorPositionEnumWrapper, is_cursor_locked: bool, left_down: bool, right_down: bool, middle_down: bool, scroll_x: AzOptionF32EnumWrapper, scroll_y: AzOptionF32EnumWrapper) -> Self {
        Self {
            mouse_cursor_type,
            cursor_position,
            is_cursor_locked,
            left_down,
            right_down,
            middle_down,
            scroll_x,
            scroll_y,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzMouseState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MouseState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MouseState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPlatformSpecificOptions {
    #[new]
    fn __new__(windows_options: AzWindowsWindowOptions, linux_options: AzLinuxWindowOptions, mac_options: AzMacWindowOptions, wasm_options: AzWasmWindowOptions) -> Self {
        Self {
            windows_options,
            linux_options,
            mac_options,
            wasm_options,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzPlatformSpecificOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::PlatformSpecificOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::PlatformSpecificOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowsWindowOptions {
    #[new]
    fn __new__(allow_drag_drop: bool, no_redirection_bitmap: bool, window_icon: AzOptionWindowIconEnumWrapper, taskbar_icon: AzOptionTaskBarIconEnumWrapper, parent_window: AzOptionHwndHandleEnumWrapper) -> Self {
        Self {
            allow_drag_drop,
            no_redirection_bitmap,
            window_icon,
            taskbar_icon,
            parent_window,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzWindowsWindowOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowsWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowsWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWaylandTheme {
}

#[pyproto]
impl PyObjectProtocol for AzWaylandTheme {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WaylandTheme = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WaylandTheme = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRendererTypeEnumWrapper {
    #[classattr]
    fn Hardware() -> AzRendererTypeEnumWrapper { AzRendererTypeEnumWrapper { inner: AzRendererType::Hardware } }
    #[classattr]
    fn Software() -> AzRendererTypeEnumWrapper { AzRendererTypeEnumWrapper { inner: AzRendererType::Software } }
}

#[pyproto]
impl PyObjectProtocol for AzRendererTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::RendererType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::RendererType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzRendererTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStringPair {
    #[new]
    fn __new__(key: AzString, value: AzString) -> Self {
        Self {
            key,
            value,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStringPair {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::AzStringPair = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::AzStringPair = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLinuxWindowOptions {
    #[new]
    fn __new__(x11_visual: AzOptionX11VisualEnumWrapper, x11_screen: AzOptionI32EnumWrapper, x11_wm_classes: AzStringPairVec, x11_override_redirect: bool, x11_window_types: AzXWindowTypeVec, x11_gtk_theme_variant: AzOptionStringEnumWrapper, x11_resize_increments: AzOptionLogicalSizeEnumWrapper, x11_base_size: AzOptionLogicalSizeEnumWrapper, wayland_app_id: AzOptionStringEnumWrapper, wayland_theme: AzOptionWaylandThemeEnumWrapper, request_user_attention: bool, window_icon: AzOptionWindowIconEnumWrapper) -> Self {
        Self {
            x11_visual,
            x11_screen,
            x11_wm_classes,
            x11_override_redirect,
            x11_window_types,
            x11_gtk_theme_variant,
            x11_resize_increments,
            x11_base_size,
            wayland_app_id,
            wayland_theme,
            request_user_attention,
            window_icon,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLinuxWindowOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LinuxWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LinuxWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMacWindowOptions {
    #[new]
    fn __new__(_reserved: u8) -> Self {
        Self {
            _reserved,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzMacWindowOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MacWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MacWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWasmWindowOptions {
    #[new]
    fn __new__(_reserved: u8) -> Self {
        Self {
            _reserved,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzWasmWindowOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WasmWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WasmWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFullScreenModeEnumWrapper {
    #[classattr]
    fn SlowFullScreen() -> AzFullScreenModeEnumWrapper { AzFullScreenModeEnumWrapper { inner: AzFullScreenMode::SlowFullScreen } }
    #[classattr]
    fn FastFullScreen() -> AzFullScreenModeEnumWrapper { AzFullScreenModeEnumWrapper { inner: AzFullScreenMode::FastFullScreen } }
    #[classattr]
    fn SlowWindowed() -> AzFullScreenModeEnumWrapper { AzFullScreenModeEnumWrapper { inner: AzFullScreenMode::SlowWindowed } }
    #[classattr]
    fn FastWindowed() -> AzFullScreenModeEnumWrapper { AzFullScreenModeEnumWrapper { inner: AzFullScreenMode::FastWindowed } }
}

#[pyproto]
impl PyObjectProtocol for AzFullScreenModeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::FullScreenMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::FullScreenMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzFullScreenModeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzWindowThemeEnumWrapper {
    #[classattr]
    fn DarkMode() -> AzWindowThemeEnumWrapper { AzWindowThemeEnumWrapper { inner: AzWindowTheme::DarkMode } }
    #[classattr]
    fn LightMode() -> AzWindowThemeEnumWrapper { AzWindowThemeEnumWrapper { inner: AzWindowTheme::LightMode } }
}

#[pyproto]
impl PyObjectProtocol for AzWindowThemeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzWindowThemeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzWindowPositionEnumWrapper {
    #[classattr]
    fn Uninitialized() -> AzWindowPositionEnumWrapper { AzWindowPositionEnumWrapper { inner: AzWindowPosition::Uninitialized } }
    #[staticmethod]
    fn Initialized(v: AzPhysicalPositionI32) -> AzWindowPositionEnumWrapper { AzWindowPositionEnumWrapper { inner: AzWindowPosition::Initialized(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzWindowPosition;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzWindowPosition::Uninitialized => Ok(vec!["Uninitialized".into_py(py), ().into_py(py)]),
            AzWindowPosition::Initialized(v) => Ok(vec!["Initialized".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzWindowPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzImePositionEnumWrapper {
    #[classattr]
    fn Uninitialized() -> AzImePositionEnumWrapper { AzImePositionEnumWrapper { inner: AzImePosition::Uninitialized } }
    #[staticmethod]
    fn Initialized(v: AzLogicalPosition) -> AzImePositionEnumWrapper { AzImePositionEnumWrapper { inner: AzImePosition::Initialized(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzImePosition;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzImePosition::Uninitialized => Ok(vec!["Uninitialized".into_py(py), ().into_py(py)]),
            AzImePosition::Initialized(v) => Ok(vec!["Initialized".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzImePositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ImePosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ImePosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTouchState {
    #[new]
    fn __new__(unused: u8) -> Self {
        Self {
            unused,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzTouchState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::TouchState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::TouchState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMonitor {
    #[new]
    fn __new__(id: usize, name: AzOptionStringEnumWrapper, size: AzLayoutSize, position: AzLayoutPoint, scale_factor: f64, video_modes: AzVideoModeVec, is_primary_monitor: bool) -> Self {
        Self {
            id,
            name,
            size,
            position,
            scale_factor,
            video_modes,
            is_primary_monitor,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzMonitor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Monitor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Monitor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVideoMode {
    #[new]
    fn __new__(size: AzLayoutSize, bit_depth: u16, refresh_rate: u16) -> Self {
        Self {
            size,
            bit_depth,
            refresh_rate,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzVideoMode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoMode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoMode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowState {
    #[staticmethod]
    fn default() -> AzWindowState {
        unsafe { mem::transmute(crate::AzWindowState_default()) }
    }
    // impl AzWindowState {

    #[new]
    pub fn __new__(py: Python, cb: PyObject) -> Result<Self, PyErr> {
        let layout_callback = AzLayoutCallbackEnumWrapper::__new__(py, cb)?;
        let window = azul_core::window::WindowState {
            layout_callback: unsafe { mem::transmute(layout_callback) },
            .. Default::default()
        };
        Ok(unsafe { mem::transmute(window) })
    }}

#[pyproto]
impl PyObjectProtocol for AzWindowState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutCallbackEnumWrapper {
    #[staticmethod]
    fn Raw(v: AzLayoutCallbackInner) -> AzLayoutCallbackEnumWrapper { AzLayoutCallbackEnumWrapper { inner: AzLayoutCallback::Raw(v) } }
    #[staticmethod]
    fn Marshaled(v: AzMarshaledLayoutCallback) -> AzLayoutCallbackEnumWrapper { AzLayoutCallbackEnumWrapper { inner: AzLayoutCallback::Marshaled(v) } }
    // impl LayoutCallbackEnumWrapper { ...

    #[new]
    pub fn __new__(py: Python, cb: PyObject) -> Result<Self, PyErr> {
        use pyo3::type_object::PyTypeInfo;

        {
            let cb_any = cb.as_ref(py);
            if !cb_any.is_callable() {
                let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
                return Err(PyException::new_err(format!("ERROR in LayoutCallback.new: - argument \"cb\" is of type \"{}\", expected function", type_name)));
            }
        }

        Ok(Self {
            inner: AzLayoutCallback::Marshaled(AzMarshaledLayoutCallback {
                marshal_data: unsafe { mem::transmute(azul_impl::callbacks::RefAny::new(LayoutCallbackTy {
                    _py_layout_callback: Some(cb)
                })) },
                cb: AzMarshaledLayoutCallbackInner { cb: invoke_py_marshaled_layout_callback },
            }),
        })
    }
    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutCallback;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutCallback::Raw(v) => Ok(vec!["Raw".into_py(py), v.clone().into_py(py)]),
            AzLayoutCallback::Marshaled(v) => Ok(vec!["Marshaled".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutCallbackEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::LayoutCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::LayoutCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMarshaledLayoutCallback {
    #[new]
    fn __new__(marshal_data: AzRefAny, cb: AzMarshaledLayoutCallbackInner) -> Self {
        Self {
            marshal_data,
            cb,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzMarshaledLayoutCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMarshaledLayoutCallbackInner {
}

#[pyproto]
impl PyObjectProtocol for AzMarshaledLayoutCallbackInner {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::MarshaledLayoutCallbackInner = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::MarshaledLayoutCallbackInner = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutCallbackInner {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutCallbackInner {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::LayoutCallbackInner = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::LayoutCallbackInner = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallback {
}

#[pyproto]
impl PyObjectProtocol for AzCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::Callback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::Callback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallbackInfo {
    fn get_hit_node(&self) -> AzDomNodeId {
        unsafe { mem::transmute(crate::AzCallbackInfo_getHitNode(
            mem::transmute(self),
        )) }
    }
    fn get_system_time_fn(&self) -> AzGetSystemTimeFn {
        unsafe { mem::transmute(crate::AzCallbackInfo_getSystemTimeFn(
            mem::transmute(self),
        )) }
    }
    fn get_cursor_relative_to_viewport(&self) -> Option<AzLogicalPosition> {
        let m: AzOptionLogicalPosition = unsafe { mem::transmute(crate::AzCallbackInfo_getCursorRelativeToViewport(
            mem::transmute(self),
        )) };
        match m {
            AzOptionLogicalPosition::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionLogicalPosition::None => None,
        }

    }
    fn get_cursor_relative_to_node(&self) -> Option<AzLogicalPosition> {
        let m: AzOptionLogicalPosition = unsafe { mem::transmute(crate::AzCallbackInfo_getCursorRelativeToNode(
            mem::transmute(self),
        )) };
        match m {
            AzOptionLogicalPosition::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionLogicalPosition::None => None,
        }

    }
    fn get_current_window_state(&self) -> AzWindowState {
        unsafe { mem::transmute(crate::AzCallbackInfo_getCurrentWindowState(
            mem::transmute(self),
        )) }
    }
    fn get_current_keyboard_state(&self) -> AzKeyboardState {
        unsafe { mem::transmute(crate::AzCallbackInfo_getCurrentKeyboardState(
            mem::transmute(self),
        )) }
    }
    fn get_current_mouse_state(&self) -> AzMouseState {
        unsafe { mem::transmute(crate::AzCallbackInfo_getCurrentMouseState(
            mem::transmute(self),
        )) }
    }
    fn get_previous_window_state(&self) -> Option<AzWindowState> {
        let m: AzOptionWindowState = unsafe { mem::transmute(crate::AzCallbackInfo_getPreviousWindowState(
            mem::transmute(self),
        )) };
        match m {
            AzOptionWindowState::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionWindowState::None => None,
        }

    }
    fn get_previous_keyboard_state(&self) -> Option<AzKeyboardState> {
        let m: AzOptionKeyboardState = unsafe { mem::transmute(crate::AzCallbackInfo_getPreviousKeyboardState(
            mem::transmute(self),
        )) };
        match m {
            AzOptionKeyboardState::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionKeyboardState::None => None,
        }

    }
    fn get_previous_mouse_state(&self) -> Option<AzMouseState> {
        let m: AzOptionMouseState = unsafe { mem::transmute(crate::AzCallbackInfo_getPreviousMouseState(
            mem::transmute(self),
        )) };
        match m {
            AzOptionMouseState::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionMouseState::None => None,
        }

    }
    fn get_current_window_handle(&self) -> AzRawWindowHandleEnumWrapper {
        unsafe { mem::transmute(crate::AzCallbackInfo_getCurrentWindowHandle(
            mem::transmute(self),
        )) }
    }
    fn get_gl_context(&self) -> Option<AzGl> {
        let m: AzOptionGl = unsafe { mem::transmute(crate::AzCallbackInfo_getGlContext(
            mem::transmute(self),
        )) };
        match m {
            AzOptionGl::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionGl::None => None,
        }

    }
    fn get_scroll_position(&self, node_id: AzDomNodeId) -> Option<AzLogicalPosition> {
        let m: AzOptionLogicalPosition = unsafe { mem::transmute(crate::AzCallbackInfo_getScrollPosition(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionLogicalPosition::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionLogicalPosition::None => None,
        }

    }
    fn get_dataset(&mut self, node_id: AzDomNodeId) -> Option<AzRefAny> {
        let m: AzOptionRefAny = unsafe { mem::transmute(crate::AzCallbackInfo_getDataset(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionRefAny::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionRefAny::None => None,
        }

    }
    fn get_string_contents(&self, node_id: AzDomNodeId) -> Option<String> {
        let m: AzOptionString = unsafe { mem::transmute(crate::AzCallbackInfo_getStringContents(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionString::Some(s) => Some({ let s: AzString = unsafe { mem::transmute(s) }; s.into() }),
            AzOptionString::None => None,
        }

    }
    fn get_inline_text(&self, node_id: AzDomNodeId) -> Option<AzInlineText> {
        let m: AzOptionInlineText = unsafe { mem::transmute(crate::AzCallbackInfo_getInlineText(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionInlineText::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionInlineText::None => None,
        }

    }
    fn get_font_ref(&self, node_id: AzDomNodeId) -> Option<AzFontRef> {
        let m: AzOptionFontRef = unsafe { mem::transmute(crate::AzCallbackInfo_getFontRef(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionFontRef::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionFontRef::None => None,
        }

    }
    fn get_text_layout_options(&self, node_id: AzDomNodeId) -> Option<AzResolvedTextLayoutOptions> {
        let m: AzOptionResolvedTextLayoutOptions = unsafe { mem::transmute(crate::AzCallbackInfo_getTextLayoutOptions(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionResolvedTextLayoutOptions::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionResolvedTextLayoutOptions::None => None,
        }

    }
    fn shape_text(&self, node_id: AzDomNodeId, text: String) -> Option<AzInlineText> {
        let text = pystring_to_azstring(&text);
        let m: AzOptionInlineText = unsafe { mem::transmute(crate::AzCallbackInfo_shapeText(
            mem::transmute(self),
            mem::transmute(node_id),
            mem::transmute(text),
        )) };
        match m {
            AzOptionInlineText::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionInlineText::None => None,
        }

    }
    fn get_index_in_parent(&mut self, node_id: AzDomNodeId) -> usize {
        unsafe { mem::transmute(crate::AzCallbackInfo_getIndexInParent(
            mem::transmute(self),
            mem::transmute(node_id),
        )) }
    }
    fn get_parent(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe { mem::transmute(crate::AzCallbackInfo_getParent(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }

    }
    fn get_previous_sibling(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe { mem::transmute(crate::AzCallbackInfo_getPreviousSibling(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }

    }
    fn get_next_sibling(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe { mem::transmute(crate::AzCallbackInfo_getNextSibling(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }

    }
    fn get_first_child(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe { mem::transmute(crate::AzCallbackInfo_getFirstChild(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }

    }
    fn get_last_child(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe { mem::transmute(crate::AzCallbackInfo_getLastChild(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }

    }
    fn get_node_position(&mut self, node_id: AzDomNodeId) -> Option<AzPositionInfoEnumWrapper> {
        let m: AzOptionPositionInfo = unsafe { mem::transmute(crate::AzCallbackInfo_getNodePosition(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionPositionInfo::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionPositionInfo::None => None,
        }

    }
    fn get_node_size(&mut self, node_id: AzDomNodeId) -> Option<AzLogicalSize> {
        let m: AzOptionLogicalSize = unsafe { mem::transmute(crate::AzCallbackInfo_getNodeSize(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionLogicalSize::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionLogicalSize::None => None,
        }

    }
    fn get_computed_css_property(&mut self, node_id: AzDomNodeId, property_type: AzCssPropertyTypeEnumWrapper) -> Option<AzCssPropertyEnumWrapper> {
        let m: AzOptionCssProperty = unsafe { mem::transmute(crate::AzCallbackInfo_getComputedCssProperty(
            mem::transmute(self),
            mem::transmute(node_id),
            mem::transmute(property_type),
        )) };
        match m {
            AzOptionCssProperty::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionCssProperty::None => None,
        }

    }
    fn set_window_state(&mut self, new_state: AzWindowState) -> () {
        unsafe { mem::transmute(crate::AzCallbackInfo_setWindowState(
            mem::transmute(self),
            mem::transmute(new_state),
        )) }
    }
    fn set_focus(&mut self, target: AzFocusTargetEnumWrapper) -> () {
        unsafe { mem::transmute(crate::AzCallbackInfo_setFocus(
            mem::transmute(self),
            mem::transmute(target),
        )) }
    }
    fn set_css_property(&mut self, node_id: AzDomNodeId, new_property: AzCssPropertyEnumWrapper) -> () {
        unsafe { mem::transmute(crate::AzCallbackInfo_setCssProperty(
            mem::transmute(self),
            mem::transmute(node_id),
            mem::transmute(new_property),
        )) }
    }
    fn set_scroll_position(&mut self, node_id: AzDomNodeId, scroll_position: AzLogicalPosition) -> () {
        unsafe { mem::transmute(crate::AzCallbackInfo_setScrollPosition(
            mem::transmute(self),
            mem::transmute(node_id),
            mem::transmute(scroll_position),
        )) }
    }
    fn set_string_contents(&mut self, node_id: AzDomNodeId, string: String) -> () {
        let string = pystring_to_azstring(&string);
        unsafe { mem::transmute(crate::AzCallbackInfo_setStringContents(
            mem::transmute(self),
            mem::transmute(node_id),
            mem::transmute(string),
        )) }
    }
    fn add_image(&mut self, id: String, image: AzImageRef) -> () {
        let id = pystring_to_azstring(&id);
        unsafe { mem::transmute(crate::AzCallbackInfo_addImage(
            mem::transmute(self),
            mem::transmute(id),
            mem::transmute(image),
        )) }
    }
    fn has_image(&self, id: String) -> bool {
        let id = pystring_to_azstring(&id);
        unsafe { mem::transmute(crate::AzCallbackInfo_hasImage(
            mem::transmute(self),
            mem::transmute(id),
        )) }
    }
    fn get_image(&self, id: String) -> Option<AzImageRef> {
        let id = pystring_to_azstring(&id);
        let m: AzOptionImageRef = unsafe { mem::transmute(crate::AzCallbackInfo_getImage(
            mem::transmute(self),
            mem::transmute(id),
        )) };
        match m {
            AzOptionImageRef::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionImageRef::None => None,
        }

    }
    fn update_image(&mut self, node_id: AzDomNodeId, new_image: AzImageRef, image_type: AzUpdateImageTypeEnumWrapper) -> () {
        unsafe { mem::transmute(crate::AzCallbackInfo_updateImage(
            mem::transmute(self),
            mem::transmute(node_id),
            mem::transmute(new_image),
            mem::transmute(image_type),
        )) }
    }
    fn delete_image(&mut self, id: String) -> () {
        let id = pystring_to_azstring(&id);
        unsafe { mem::transmute(crate::AzCallbackInfo_deleteImage(
            mem::transmute(self),
            mem::transmute(id),
        )) }
    }
    fn update_image_mask(&mut self, node_id: AzDomNodeId, new_mask: AzImageMask) -> () {
        unsafe { mem::transmute(crate::AzCallbackInfo_updateImageMask(
            mem::transmute(self),
            mem::transmute(node_id),
            mem::transmute(new_mask),
        )) }
    }
    fn stop_propagation(&mut self) -> () {
        unsafe { mem::transmute(crate::AzCallbackInfo_stopPropagation(
            mem::transmute(self),
        )) }
    }
    fn create_window(&mut self, new_window: AzWindowCreateOptions) -> () {
        unsafe { mem::transmute(crate::AzCallbackInfo_createWindow(
            mem::transmute(self),
            mem::transmute(new_window),
        )) }
    }
    fn start_timer(&mut self, timer: AzTimer) -> AzTimerId {
        unsafe { mem::transmute(crate::AzCallbackInfo_startTimer(
            mem::transmute(self),
            mem::transmute(timer),
        )) }
    }
    fn start_animation(&mut self, node: AzDomNodeId, animation: AzAnimation) -> Option<AzTimerId> {
        let m: AzOptionTimerId = unsafe { mem::transmute(crate::AzCallbackInfo_startAnimation(
            mem::transmute(self),
            mem::transmute(node),
            mem::transmute(animation),
        )) };
        match m {
            AzOptionTimerId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionTimerId::None => None,
        }

    }
    fn stop_timer(&mut self, timer_id: AzTimerId) -> bool {
        unsafe { mem::transmute(crate::AzCallbackInfo_stopTimer(
            mem::transmute(self),
            mem::transmute(timer_id),
        )) }
    }
    fn send_thread_msg(&mut self, thread_id: AzThreadId, msg: AzThreadSendMsgEnumWrapper) -> bool {
        unsafe { mem::transmute(crate::AzCallbackInfo_sendThreadMsg(
            mem::transmute(self),
            mem::transmute(thread_id),
            mem::transmute(msg),
        )) }
    }
    fn stop_thread(&mut self, thread_id: AzThreadId) -> bool {
        unsafe { mem::transmute(crate::AzCallbackInfo_stopThread(
            mem::transmute(self),
            mem::transmute(thread_id),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::CallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::CallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUpdateImageTypeEnumWrapper {
    #[classattr]
    fn Background() -> AzUpdateImageTypeEnumWrapper { AzUpdateImageTypeEnumWrapper { inner: AzUpdateImageType::Background } }
    #[classattr]
    fn Content() -> AzUpdateImageTypeEnumWrapper { AzUpdateImageTypeEnumWrapper { inner: AzUpdateImageType::Content } }
}

#[pyproto]
impl PyObjectProtocol for AzUpdateImageTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::UpdateImageType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::UpdateImageType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzUpdateImageTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzUpdateEnumWrapper {
    #[classattr]
    fn DoNothing() -> AzUpdateEnumWrapper { AzUpdateEnumWrapper { inner: AzUpdate::DoNothing } }
    #[classattr]
    fn RefreshDom() -> AzUpdateEnumWrapper { AzUpdateEnumWrapper { inner: AzUpdate::RefreshDom } }
    #[classattr]
    fn RefreshDomAllWindows() -> AzUpdateEnumWrapper { AzUpdateEnumWrapper { inner: AzUpdate::RefreshDomAllWindows } }
}

#[pyproto]
impl PyObjectProtocol for AzUpdateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::Update = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::Update = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzUpdateEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzNodeId {
    #[new]
    fn __new__(inner: usize) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::NodeHierarchyItemId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::NodeHierarchyItemId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomId {
    #[new]
    fn __new__(inner: usize) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzDomId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::DomId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::DomId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomNodeId {
    #[new]
    fn __new__(dom: AzDomId, node: AzNodeId) -> Self {
        Self {
            dom,
            node,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzDomNodeId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::DomNodeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::DomNodeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPositionInfoEnumWrapper {
    #[staticmethod]
    fn Static(v: AzPositionInfoInner) -> AzPositionInfoEnumWrapper { AzPositionInfoEnumWrapper { inner: AzPositionInfo::Static(v) } }
    #[staticmethod]
    fn Fixed(v: AzPositionInfoInner) -> AzPositionInfoEnumWrapper { AzPositionInfoEnumWrapper { inner: AzPositionInfo::Fixed(v) } }
    #[staticmethod]
    fn Absolute(v: AzPositionInfoInner) -> AzPositionInfoEnumWrapper { AzPositionInfoEnumWrapper { inner: AzPositionInfo::Absolute(v) } }
    #[staticmethod]
    fn Relative(v: AzPositionInfoInner) -> AzPositionInfoEnumWrapper { AzPositionInfoEnumWrapper { inner: AzPositionInfo::Relative(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzPositionInfo;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzPositionInfo::Static(v) => Ok(vec!["Static".into_py(py), v.clone().into_py(py)]),
            AzPositionInfo::Fixed(v) => Ok(vec!["Fixed".into_py(py), v.clone().into_py(py)]),
            AzPositionInfo::Absolute(v) => Ok(vec!["Absolute".into_py(py), v.clone().into_py(py)]),
            AzPositionInfo::Relative(v) => Ok(vec!["Relative".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzPositionInfoEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::ui_solver::PositionInfo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::ui_solver::PositionInfo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPositionInfoInner {
    #[new]
    fn __new__(x_offset: f32, y_offset: f32, static_x_offset: f32, static_y_offset: f32) -> Self {
        Self {
            x_offset,
            y_offset,
            static_x_offset,
            static_y_offset,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzPositionInfoInner {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::ui_solver::PositionInfoInner = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::ui_solver::PositionInfoInner = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzHidpiAdjustedBounds {
    #[new]
    fn __new__(logical_size: AzLogicalSize, hidpi_factor: f32) -> Self {
        Self {
            logical_size,
            hidpi_factor,
        }
    }

    fn get_logical_size(&self) -> AzLogicalSize {
        unsafe { mem::transmute(crate::AzHidpiAdjustedBounds_getLogicalSize(
            mem::transmute(self),
        )) }
    }
    fn get_physical_size(&self) -> AzPhysicalSizeU32 {
        unsafe { mem::transmute(crate::AzHidpiAdjustedBounds_getPhysicalSize(
            mem::transmute(self),
        )) }
    }
    fn get_hidpi_factor(&self) -> f32 {
        unsafe { mem::transmute(crate::AzHidpiAdjustedBounds_getHidpiFactor(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzHidpiAdjustedBounds {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::HidpiAdjustedBounds = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::HidpiAdjustedBounds = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineText {
    #[new]
    fn __new__(lines: AzInlineLineVec, content_size: AzLogicalSize, font_size_px: f32, last_word_index: usize, baseline_descender_px: f32) -> Self {
        Self {
            lines,
            content_size,
            font_size_px,
            last_word_index,
            baseline_descender_px,
        }
    }

    fn hit_test(&self, position: AzLogicalPosition) -> AzInlineTextHitVec {
        unsafe { mem::transmute(crate::AzInlineText_hitTest(
            mem::transmute(self),
            mem::transmute(position),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineText {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineText = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineText = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineLine {
    #[new]
    fn __new__(words: AzInlineWordVec, bounds: AzLogicalRect) -> Self {
        Self {
            words,
            bounds,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInlineLine {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineLine = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineLine = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineWordEnumWrapper {
    #[classattr]
    fn Tab() -> AzInlineWordEnumWrapper { AzInlineWordEnumWrapper { inner: AzInlineWord::Tab } }
    #[classattr]
    fn Return() -> AzInlineWordEnumWrapper { AzInlineWordEnumWrapper { inner: AzInlineWord::Return } }
    #[classattr]
    fn Space() -> AzInlineWordEnumWrapper { AzInlineWordEnumWrapper { inner: AzInlineWord::Space } }
    #[staticmethod]
    fn Word(v: AzInlineTextContents) -> AzInlineWordEnumWrapper { AzInlineWordEnumWrapper { inner: AzInlineWord::Word(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInlineWord;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInlineWord::Tab => Ok(vec!["Tab".into_py(py), ().into_py(py)]),
            AzInlineWord::Return => Ok(vec!["Return".into_py(py), ().into_py(py)]),
            AzInlineWord::Space => Ok(vec!["Space".into_py(py), ().into_py(py)]),
            AzInlineWord::Word(v) => Ok(vec!["Word".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineWordEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineWord = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineWord = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineTextContents {
    #[new]
    fn __new__(glyphs: AzInlineGlyphVec, bounds: AzLogicalRect) -> Self {
        Self {
            glyphs,
            bounds,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInlineTextContents {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineTextContents = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineTextContents = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineGlyph {
    #[new]
    fn __new__(bounds: AzLogicalRect, unicode_codepoint: AzOptionCharEnumWrapper, glyph_index: u32) -> Self {
        Self {
            bounds,
            unicode_codepoint,
            glyph_index,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInlineGlyph {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineGlyph = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineGlyph = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineTextHit {
    #[new]
    fn __new__(unicode_codepoint: AzOptionCharEnumWrapper, hit_relative_to_inline_text: AzLogicalPosition, hit_relative_to_line: AzLogicalPosition, hit_relative_to_text_content: AzLogicalPosition, hit_relative_to_glyph: AzLogicalPosition, line_index_relative_to_text: usize, word_index_relative_to_text: usize, text_content_index_relative_to_text: usize, glyph_index_relative_to_text: usize, char_index_relative_to_text: usize, word_index_relative_to_line: usize, text_content_index_relative_to_line: usize, glyph_index_relative_to_line: usize, char_index_relative_to_line: usize, glyph_index_relative_to_word: usize, char_index_relative_to_word: usize) -> Self {
        Self {
            unicode_codepoint,
            hit_relative_to_inline_text,
            hit_relative_to_line,
            hit_relative_to_text_content,
            hit_relative_to_glyph,
            line_index_relative_to_text,
            word_index_relative_to_text,
            text_content_index_relative_to_text,
            glyph_index_relative_to_text,
            char_index_relative_to_text,
            word_index_relative_to_line,
            text_content_index_relative_to_line,
            glyph_index_relative_to_line,
            char_index_relative_to_line,
            glyph_index_relative_to_word,
            char_index_relative_to_word,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInlineTextHit {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineTextHit = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineTextHit = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFocusTargetEnumWrapper {
    #[staticmethod]
    fn Id(v: AzDomNodeId) -> AzFocusTargetEnumWrapper { AzFocusTargetEnumWrapper { inner: AzFocusTarget::Id(v) } }
    #[staticmethod]
    fn Path(v: AzFocusTargetPath) -> AzFocusTargetEnumWrapper { AzFocusTargetEnumWrapper { inner: AzFocusTarget::Path(v) } }
    #[classattr]
    fn Previous() -> AzFocusTargetEnumWrapper { AzFocusTargetEnumWrapper { inner: AzFocusTarget::Previous } }
    #[classattr]
    fn Next() -> AzFocusTargetEnumWrapper { AzFocusTargetEnumWrapper { inner: AzFocusTarget::Next } }
    #[classattr]
    fn First() -> AzFocusTargetEnumWrapper { AzFocusTargetEnumWrapper { inner: AzFocusTarget::First } }
    #[classattr]
    fn Last() -> AzFocusTargetEnumWrapper { AzFocusTargetEnumWrapper { inner: AzFocusTarget::Last } }
    #[classattr]
    fn NoFocus() -> AzFocusTargetEnumWrapper { AzFocusTargetEnumWrapper { inner: AzFocusTarget::NoFocus } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzFocusTarget;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzFocusTarget::Id(v) => Ok(vec!["Id".into_py(py), v.clone().into_py(py)]),
            AzFocusTarget::Path(v) => Ok(vec!["Path".into_py(py), v.clone().into_py(py)]),
            AzFocusTarget::Previous => Ok(vec!["Previous".into_py(py), ().into_py(py)]),
            AzFocusTarget::Next => Ok(vec!["Next".into_py(py), ().into_py(py)]),
            AzFocusTarget::First => Ok(vec!["First".into_py(py), ().into_py(py)]),
            AzFocusTarget::Last => Ok(vec!["Last".into_py(py), ().into_py(py)]),
            AzFocusTarget::NoFocus => Ok(vec!["NoFocus".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFocusTargetEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::FocusTarget = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::FocusTarget = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFocusTargetPath {
    #[new]
    fn __new__(dom: AzDomId, css_path: AzCssPath) -> Self {
        Self {
            dom,
            css_path,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzFocusTargetPath {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::FocusTargetPath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::FocusTargetPath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResolvedTextLayoutOptions {
    #[new]
    fn __new__(font_size_px: f32, line_height: AzOptionF32EnumWrapper, letter_spacing: AzOptionF32EnumWrapper, word_spacing: AzOptionF32EnumWrapper, tab_width: AzOptionF32EnumWrapper, max_horizontal_width: AzOptionF32EnumWrapper, leading: AzOptionF32EnumWrapper, holes: AzLogicalRectVec) -> Self {
        Self {
            font_size_px,
            line_height,
            letter_spacing,
            word_spacing,
            tab_width,
            max_horizontal_width,
            leading,
            holes,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzResolvedTextLayoutOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::ui_solver::ResolvedTextLayoutOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::ui_solver::ResolvedTextLayoutOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAnimation {
    #[new]
    fn __new__(from: AzCssPropertyEnumWrapper, to: AzCssPropertyEnumWrapper, duration: AzDurationEnumWrapper, repeat: AzAnimationRepeatEnumWrapper, repeat_count: AzAnimationRepeatCountEnumWrapper, easing: AzAnimationEasingEnumWrapper, relayout_on_finish: bool) -> Self {
        Self {
            from,
            to,
            duration,
            repeat,
            repeat_count,
            easing,
            relayout_on_finish,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzAnimation {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::Animation = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::Animation = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAnimationRepeatEnumWrapper {
    #[classattr]
    fn NoRepeat() -> AzAnimationRepeatEnumWrapper { AzAnimationRepeatEnumWrapper { inner: AzAnimationRepeat::NoRepeat } }
    #[classattr]
    fn Loop() -> AzAnimationRepeatEnumWrapper { AzAnimationRepeatEnumWrapper { inner: AzAnimationRepeat::Loop } }
    #[classattr]
    fn PingPong() -> AzAnimationRepeatEnumWrapper { AzAnimationRepeatEnumWrapper { inner: AzAnimationRepeat::PingPong } }
}

#[pyproto]
impl PyObjectProtocol for AzAnimationRepeatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::AnimationRepeat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::AnimationRepeat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAnimationRepeatEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAnimationRepeatCountEnumWrapper {
    #[staticmethod]
    fn Times(v: usize) -> AzAnimationRepeatCountEnumWrapper { AzAnimationRepeatCountEnumWrapper { inner: AzAnimationRepeatCount::Times(v) } }
    #[classattr]
    fn Infinite() -> AzAnimationRepeatCountEnumWrapper { AzAnimationRepeatCountEnumWrapper { inner: AzAnimationRepeatCount::Infinite } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzAnimationRepeatCount;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAnimationRepeatCount::Times(v) => Ok(vec!["Times".into_py(py), v.into_py(py)]),
            AzAnimationRepeatCount::Infinite => Ok(vec!["Infinite".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAnimationRepeatCountEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::AnimationRepeatCount = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::AnimationRepeatCount = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAnimationEasingEnumWrapper {
    #[classattr]
    fn Ease() -> AzAnimationEasingEnumWrapper { AzAnimationEasingEnumWrapper { inner: AzAnimationEasing::Ease } }
    #[classattr]
    fn Linear() -> AzAnimationEasingEnumWrapper { AzAnimationEasingEnumWrapper { inner: AzAnimationEasing::Linear } }
    #[classattr]
    fn EaseIn() -> AzAnimationEasingEnumWrapper { AzAnimationEasingEnumWrapper { inner: AzAnimationEasing::EaseIn } }
    #[classattr]
    fn EaseOut() -> AzAnimationEasingEnumWrapper { AzAnimationEasingEnumWrapper { inner: AzAnimationEasing::EaseOut } }
    #[classattr]
    fn EaseInOut() -> AzAnimationEasingEnumWrapper { AzAnimationEasingEnumWrapper { inner: AzAnimationEasing::EaseInOut } }
    #[staticmethod]
    fn CubicBezier(v: AzSvgCubicCurve) -> AzAnimationEasingEnumWrapper { AzAnimationEasingEnumWrapper { inner: AzAnimationEasing::CubicBezier(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzAnimationEasing;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAnimationEasing::Ease => Ok(vec!["Ease".into_py(py), ().into_py(py)]),
            AzAnimationEasing::Linear => Ok(vec!["Linear".into_py(py), ().into_py(py)]),
            AzAnimationEasing::EaseIn => Ok(vec!["EaseIn".into_py(py), ().into_py(py)]),
            AzAnimationEasing::EaseOut => Ok(vec!["EaseOut".into_py(py), ().into_py(py)]),
            AzAnimationEasing::EaseInOut => Ok(vec!["EaseInOut".into_py(py), ().into_py(py)]),
            AzAnimationEasing::CubicBezier(v) => Ok(vec!["CubicBezier".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAnimationEasingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::AnimationInterpolationFunction = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::AnimationInterpolationFunction = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameCallback {
}

#[pyproto]
impl PyObjectProtocol for AzIFrameCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::IFrameCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::IFrameCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameCallbackInfo {
}

#[pyproto]
impl PyObjectProtocol for AzIFrameCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::IFrameCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::IFrameCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameCallbackReturn {
    #[new]
    fn __new__(dom: AzStyledDom, scroll_size: AzLogicalSize, scroll_offset: AzLogicalPosition, virtual_scroll_size: AzLogicalSize, virtual_scroll_offset: AzLogicalPosition) -> Self {
        Self {
            dom,
            scroll_size,
            scroll_offset,
            virtual_scroll_size,
            virtual_scroll_offset,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzIFrameCallbackReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::IFrameCallbackReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::IFrameCallbackReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRenderImageCallback {
}

#[pyproto]
impl PyObjectProtocol for AzRenderImageCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::RenderImageCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::RenderImageCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRenderImageCallbackInfo {
    fn get_gl_context(&self) -> Option<AzGl> {
        let m: AzOptionGl = unsafe { mem::transmute(crate::AzRenderImageCallbackInfo_getGlContext(
            mem::transmute(self),
        )) };
        match m {
            AzOptionGl::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionGl::None => None,
        }

    }
    fn get_bounds(&self) -> AzHidpiAdjustedBounds {
        unsafe { mem::transmute(crate::AzRenderImageCallbackInfo_getBounds(
            mem::transmute(self),
        )) }
    }
    fn get_callback_node_id(&self) -> AzDomNodeId {
        unsafe { mem::transmute(crate::AzRenderImageCallbackInfo_getCallbackNodeId(
            mem::transmute(self),
        )) }
    }
    fn get_inline_text(&self, node_id: AzDomNodeId) -> Option<AzInlineText> {
        let m: AzOptionInlineText = unsafe { mem::transmute(crate::AzRenderImageCallbackInfo_getInlineText(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionInlineText::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionInlineText::None => None,
        }

    }
    fn get_index_in_parent(&mut self, node_id: AzDomNodeId) -> usize {
        unsafe { mem::transmute(crate::AzRenderImageCallbackInfo_getIndexInParent(
            mem::transmute(self),
            mem::transmute(node_id),
        )) }
    }
    fn get_parent(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe { mem::transmute(crate::AzRenderImageCallbackInfo_getParent(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }

    }
    fn get_previous_sibling(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe { mem::transmute(crate::AzRenderImageCallbackInfo_getPreviousSibling(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }

    }
    fn get_next_sibling(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe { mem::transmute(crate::AzRenderImageCallbackInfo_getNextSibling(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }

    }
    fn get_first_child(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe { mem::transmute(crate::AzRenderImageCallbackInfo_getFirstChild(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }

    }
    fn get_last_child(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe { mem::transmute(crate::AzRenderImageCallbackInfo_getLastChild(
            mem::transmute(self),
            mem::transmute(node_id),
        )) };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }

    }
}

#[pyproto]
impl PyObjectProtocol for AzRenderImageCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::RenderImageCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::RenderImageCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTimerCallback {
}

#[pyproto]
impl PyObjectProtocol for AzTimerCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::TimerCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::TimerCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTimerCallbackInfo {
}

#[pyproto]
impl PyObjectProtocol for AzTimerCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::TimerCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::TimerCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTimerCallbackReturn {
    #[new]
    fn __new__(should_update: AzUpdateEnumWrapper, should_terminate: AzTerminateTimerEnumWrapper) -> Self {
        Self {
            should_update,
            should_terminate,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzTimerCallbackReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::TimerCallbackReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::TimerCallbackReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWriteBackCallback {
}

#[pyproto]
impl PyObjectProtocol for AzWriteBackCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::WriteBackCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::WriteBackCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadCallback {
}

#[pyproto]
impl PyObjectProtocol for AzThreadCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::ThreadCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::ThreadCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRefCount {
    fn can_be_shared(&self) -> bool {
        unsafe { mem::transmute(crate::AzRefCount_canBeShared(
            mem::transmute(self),
        )) }
    }
    fn can_be_shared_mut(&self) -> bool {
        unsafe { mem::transmute(crate::AzRefCount_canBeSharedMut(
            mem::transmute(self),
        )) }
    }
    fn increase_ref(&mut self) -> () {
        unsafe { mem::transmute(crate::AzRefCount_increaseRef(
            mem::transmute(self),
        )) }
    }
    fn decrease_ref(&mut self) -> () {
        unsafe { mem::transmute(crate::AzRefCount_decreaseRef(
            mem::transmute(self),
        )) }
    }
    fn increase_refmut(&mut self) -> () {
        unsafe { mem::transmute(crate::AzRefCount_increaseRefmut(
            mem::transmute(self),
        )) }
    }
    fn decrease_refmut(&mut self) -> () {
        unsafe { mem::transmute(crate::AzRefCount_decreaseRefmut(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRefCount {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::RefCount = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::RefCount = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRefAny {
    fn get_type_id(&self) -> u64 {
        unsafe { mem::transmute(crate::AzRefAny_getTypeId(
            mem::transmute(self),
        )) }
    }
    fn get_type_name(&self) -> String {
        az_string_to_py_string(unsafe { mem::transmute(crate::AzRefAny_getTypeName(
            mem::transmute(self),
        )) })
    }
}

#[pyproto]
impl PyObjectProtocol for AzRefAny {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::RefAny = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::RefAny = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutCallbackInfo {
    fn get_gl_context(&self) -> Option<AzGl> {
        let m: AzOptionGl = unsafe { mem::transmute(crate::AzLayoutCallbackInfo_getGlContext(
            mem::transmute(self),
        )) };
        match m {
            AzOptionGl::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionGl::None => None,
        }

    }
    fn get_system_fonts(&self) -> AzStringPairVec {
        unsafe { mem::transmute(crate::AzLayoutCallbackInfo_getSystemFonts(
            mem::transmute(self),
        )) }
    }
    fn get_image(&self, id: String) -> Option<AzImageRef> {
        let id = pystring_to_azstring(&id);
        let m: AzOptionImageRef = unsafe { mem::transmute(crate::AzLayoutCallbackInfo_getImage(
            mem::transmute(self),
            mem::transmute(id),
        )) };
        match m {
            AzOptionImageRef::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionImageRef::None => None,
        }

    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::LayoutCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::LayoutCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDom {
    #[new]
    fn new(node_type: AzNodeTypeEnumWrapper) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_new(
            mem::transmute(node_type),
        )) }
    }
    #[staticmethod]
    fn body() -> AzDom {
        unsafe { mem::transmute(crate::AzDom_body()) }
    }
    #[staticmethod]
    fn div() -> AzDom {
        unsafe { mem::transmute(crate::AzDom_div()) }
    }
    #[staticmethod]
    fn br() -> AzDom {
        unsafe { mem::transmute(crate::AzDom_br()) }
    }
    #[staticmethod]
    fn text(string: String) -> AzDom {
        let string = pystring_to_azstring(&string);
        unsafe { mem::transmute(crate::AzDom_text(
            mem::transmute(string),
        )) }
    }
    #[staticmethod]
    fn image(image: AzImageRef) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_image(
            mem::transmute(image),
        )) }
    }
    fn set_node_type(&mut self, node_type: AzNodeTypeEnumWrapper) -> () {
        unsafe { mem::transmute(crate::AzDom_setNodeType(
            mem::transmute(self),
            mem::transmute(node_type),
        )) }
    }
    fn with_node_type(&mut self, node_type: AzNodeTypeEnumWrapper) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_withNodeType(
            mem::transmute(self),
            mem::transmute(node_type),
        )) }
    }
    fn set_ids_and_classes(&mut self, ids_and_classes: AzIdOrClassVec) -> () {
        unsafe { mem::transmute(crate::AzDom_setIdsAndClasses(
            mem::transmute(self),
            mem::transmute(ids_and_classes),
        )) }
    }
    fn with_ids_and_classes(&mut self, ids_and_classes: AzIdOrClassVec) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_withIdsAndClasses(
            mem::transmute(self),
            mem::transmute(ids_and_classes),
        )) }
    }
    fn set_callbacks(&mut self, callbacks: AzCallbackDataVec) -> () {
        unsafe { mem::transmute(crate::AzDom_setCallbacks(
            mem::transmute(self),
            mem::transmute(callbacks),
        )) }
    }
    fn with_callbacks(&mut self, callbacks: AzCallbackDataVec) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_withCallbacks(
            mem::transmute(self),
            mem::transmute(callbacks),
        )) }
    }
    fn set_inline_css_props(&mut self, css_properties: AzNodeDataInlineCssPropertyVec) -> () {
        unsafe { mem::transmute(crate::AzDom_setInlineCssProps(
            mem::transmute(self),
            mem::transmute(css_properties),
        )) }
    }
    fn with_inline_css_props(&mut self, css_properties: AzNodeDataInlineCssPropertyVec) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_withInlineCssProps(
            mem::transmute(self),
            mem::transmute(css_properties),
        )) }
    }
    fn add_child(&mut self, child: AzDom) -> () {
        unsafe { mem::transmute(crate::AzDom_addChild(
            mem::transmute(self),
            mem::transmute(child),
        )) }
    }
    fn with_child(&mut self, child: AzDom) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_withChild(
            mem::transmute(self),
            mem::transmute(child),
        )) }
    }
    fn set_children(&mut self, children: AzDomVec) -> () {
        unsafe { mem::transmute(crate::AzDom_setChildren(
            mem::transmute(self),
            mem::transmute(children),
        )) }
    }
    fn with_children(&mut self, children: AzDomVec) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_withChildren(
            mem::transmute(self),
            mem::transmute(children),
        )) }
    }
    fn add_id(&mut self, id: String) -> () {
        let id = pystring_to_azstring(&id);
        unsafe { mem::transmute(crate::AzDom_addId(
            mem::transmute(self),
            mem::transmute(id),
        )) }
    }
    fn with_id(&mut self, id: String) -> AzDom {
        let id = pystring_to_azstring(&id);
        unsafe { mem::transmute(crate::AzDom_withId(
            mem::transmute(self),
            mem::transmute(id),
        )) }
    }
    fn add_class(&mut self, class: String) -> () {
        let class = pystring_to_azstring(&class);
        unsafe { mem::transmute(crate::AzDom_addClass(
            mem::transmute(self),
            mem::transmute(class),
        )) }
    }
    fn with_class(&mut self, class: String) -> AzDom {
        let class = pystring_to_azstring(&class);
        unsafe { mem::transmute(crate::AzDom_withClass(
            mem::transmute(self),
            mem::transmute(class),
        )) }
    }
    fn add_css_property(&mut self, prop: AzCssPropertyEnumWrapper) -> () {
        unsafe { mem::transmute(crate::AzDom_addCssProperty(
            mem::transmute(self),
            mem::transmute(prop),
        )) }
    }
    fn with_css_property(&mut self, prop: AzCssPropertyEnumWrapper) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_withCssProperty(
            mem::transmute(self),
            mem::transmute(prop),
        )) }
    }
    fn add_hover_css_property(&mut self, prop: AzCssPropertyEnumWrapper) -> () {
        unsafe { mem::transmute(crate::AzDom_addHoverCssProperty(
            mem::transmute(self),
            mem::transmute(prop),
        )) }
    }
    fn with_hover_css_property(&mut self, prop: AzCssPropertyEnumWrapper) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_withHoverCssProperty(
            mem::transmute(self),
            mem::transmute(prop),
        )) }
    }
    fn add_active_css_property(&mut self, prop: AzCssPropertyEnumWrapper) -> () {
        unsafe { mem::transmute(crate::AzDom_addActiveCssProperty(
            mem::transmute(self),
            mem::transmute(prop),
        )) }
    }
    fn with_active_css_property(&mut self, prop: AzCssPropertyEnumWrapper) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_withActiveCssProperty(
            mem::transmute(self),
            mem::transmute(prop),
        )) }
    }
    fn add_focus_css_property(&mut self, prop: AzCssPropertyEnumWrapper) -> () {
        unsafe { mem::transmute(crate::AzDom_addFocusCssProperty(
            mem::transmute(self),
            mem::transmute(prop),
        )) }
    }
    fn with_focus_css_property(&mut self, prop: AzCssPropertyEnumWrapper) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_withFocusCssProperty(
            mem::transmute(self),
            mem::transmute(prop),
        )) }
    }
    fn set_inline_style(&mut self, style: String) -> () {
        let style = pystring_to_azstring(&style);
        unsafe { mem::transmute(crate::AzDom_setInlineStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn with_inline_style(&mut self, style: String) -> AzDom {
        let style = pystring_to_azstring(&style);
        unsafe { mem::transmute(crate::AzDom_withInlineStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn set_inline_hover_style(&mut self, style: String) -> () {
        let style = pystring_to_azstring(&style);
        unsafe { mem::transmute(crate::AzDom_setInlineHoverStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn with_inline_hover_style(&mut self, style: String) -> AzDom {
        let style = pystring_to_azstring(&style);
        unsafe { mem::transmute(crate::AzDom_withInlineHoverStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn set_inline_active_style(&mut self, style: String) -> () {
        let style = pystring_to_azstring(&style);
        unsafe { mem::transmute(crate::AzDom_setInlineActiveStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn with_inline_active_style(&mut self, style: String) -> AzDom {
        let style = pystring_to_azstring(&style);
        unsafe { mem::transmute(crate::AzDom_withInlineActiveStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn set_inline_focus_style(&mut self, style: String) -> () {
        let style = pystring_to_azstring(&style);
        unsafe { mem::transmute(crate::AzDom_setInlineFocusStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn with_inline_focus_style(&mut self, style: String) -> AzDom {
        let style = pystring_to_azstring(&style);
        unsafe { mem::transmute(crate::AzDom_withInlineFocusStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn set_clip_mask(&mut self, clip_mask: AzImageMask) -> () {
        unsafe { mem::transmute(crate::AzDom_setClipMask(
            mem::transmute(self),
            mem::transmute(clip_mask),
        )) }
    }
    fn with_clip_mask(&mut self, clip_mask: AzImageMask) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_withClipMask(
            mem::transmute(self),
            mem::transmute(clip_mask),
        )) }
    }
    fn set_tab_index(&mut self, tab_index: AzTabIndexEnumWrapper) -> () {
        unsafe { mem::transmute(crate::AzDom_setTabIndex(
            mem::transmute(self),
            mem::transmute(tab_index),
        )) }
    }
    fn with_tab_index(&mut self, tab_index: AzTabIndexEnumWrapper) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_withTabIndex(
            mem::transmute(self),
            mem::transmute(tab_index),
        )) }
    }
    fn set_accessibility_info(&mut self, accessibility_info: AzAccessibilityInfo) -> () {
        unsafe { mem::transmute(crate::AzDom_setAccessibilityInfo(
            mem::transmute(self),
            mem::transmute(accessibility_info),
        )) }
    }
    fn with_accessibility_info(&mut self, accessibility_info: AzAccessibilityInfo) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_withAccessibilityInfo(
            mem::transmute(self),
            mem::transmute(accessibility_info),
        )) }
    }
    fn set_menu_bar(&mut self, menu_bar: AzMenu) -> () {
        unsafe { mem::transmute(crate::AzDom_setMenuBar(
            mem::transmute(self),
            mem::transmute(menu_bar),
        )) }
    }
    fn with_menu_bar(&mut self, menu_bar: AzMenu) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_withMenuBar(
            mem::transmute(self),
            mem::transmute(menu_bar),
        )) }
    }
    fn set_context_menu(&mut self, context_menu: AzMenu) -> () {
        unsafe { mem::transmute(crate::AzDom_setContextMenu(
            mem::transmute(self),
            mem::transmute(context_menu),
        )) }
    }
    fn with_context_menu(&mut self, context_menu: AzMenu) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_withContextMenu(
            mem::transmute(self),
            mem::transmute(context_menu),
        )) }
    }
    fn hash(&self) -> u64 {
        unsafe { mem::transmute(crate::AzDom_hash(
            mem::transmute(self),
        )) }
    }
    fn node_count(&self) -> usize {
        unsafe { mem::transmute(crate::AzDom_nodeCount(
            mem::transmute(self),
        )) }
    }
    fn get_html_string(&mut self) -> String {
        az_string_to_py_string(unsafe { mem::transmute(crate::AzDom_getHtmlString(
            mem::transmute(self),
        )) })
    }
    fn get_html_string_test(&mut self) -> String {
        az_string_to_py_string(unsafe { mem::transmute(crate::AzDom_getHtmlStringTest(
            mem::transmute(self),
        )) })
    }
    fn style(&mut self, css: AzCss) -> AzStyledDom {
        unsafe { mem::transmute(crate::AzDom_style(
            mem::transmute(self),
            mem::transmute(css),
        )) }
    }
// impl Dom {
    // data: RefAny, callback: IFrameCallbackType) -> Self {

    #[staticmethod]
    fn iframe(py: Python, data: PyObject, callback: PyObject) -> Result<Self, PyErr> { // RefAny<IFrameCallbackTy>

        use pyo3::type_object::PyTypeInfo;

        if data.as_ref(py.clone()).is_callable() {
            return Err(PyException::new_err(format!("ERROR in Dom.iframe: - argument \"data\" is a function callback, expected class")));
        }

        let cb_any = callback.as_ref(py);
        if !cb_any.is_callable() {
            let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
            return Err(PyException::new_err(format!("ERROR in Dom.iframe: - argument \"callback\" is of type \"{}\", expected function", type_name)));
        }

        let iframe_refany = azul_impl::callbacks::RefAny::new(IFrameCallbackTy {
            _py_iframe_data: Some(data),
            _py_iframe_callback: Some(callback),
        });

        Ok(unsafe { mem::transmute(crate::AzDom_iframe(iframe_refany, invoke_python_iframe)) })
    }

    fn set_dataset(&mut self, py: Python, dataset: PyObject) -> Result<(), PyErr> { // RefAny<DatasetTy>
        use pyo3::type_object::PyTypeInfo;

        if dataset.as_ref(py.clone()).is_callable() {
            return Err(PyException::new_err(format!("ERROR in Dom.set_dataset: - argument \"dataset\" is a function callback, expected class")));
        }

        let dataset_refany = azul_impl::callbacks::RefAny::new(DatasetTy {
            _py_data: Some(dataset),
        });

        crate::AzDom_setDataset(unsafe { mem::transmute(self) }, dataset_refany);

        Ok(())
    }

    fn with_dataset(&mut self, py: Python, dataset: PyObject) -> Result<Self, PyErr> { // RefAny<DatasetTy>
        self.set_dataset(py, dataset)?;
        let d: &mut azul_impl::dom::Dom = unsafe { mem::transmute(self) };
        Ok(unsafe { mem::transmute(d.swap_with_default()) })
    }

    fn add_callback(&mut self, py: Python, event: AzEventFilterEnumWrapper, data: PyObject, callback: PyObject) -> Result<(), PyErr> { // RefAny<CallbackTy>
        use pyo3::type_object::PyTypeInfo;

        if data.as_ref(py.clone()).is_callable() {
            return Err(PyException::new_err(format!("ERROR in Dom.add_callback: - argument \"data\" is a function callback, expected class")));
        }

        let cb_any = callback.as_ref(py);
        if !cb_any.is_callable() {
            let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
            return Err(PyException::new_err(format!("ERROR in Dom.add_callback: - argument \"callback\" is of type \"{}\", expected function", type_name)));
        }

        let callback_refany = azul_impl::callbacks::RefAny::new(CallbackTy {
            _py_callback: Some(callback),
            _py_data: Some(data),
        });

        unsafe {
            crate::AzDom_addCallback(
                mem::transmute(self),
                mem::transmute(event),
                callback_refany,
                invoke_python_callback
            );
        }

        Ok(())
    }

    fn with_callback(&mut self, py: Python, event: AzEventFilterEnumWrapper, data: PyObject, callback: PyObject) -> Result<Self, PyErr> { // RefAny<CallbackTy>
        self.add_callback(py, event, data, callback)?;
        let d: &mut azul_impl::dom::Dom = unsafe { mem::transmute(self) };
        Ok(unsafe { mem::transmute(d.swap_with_default()) })
    }}

#[pyproto]
impl PyObjectProtocol for AzDom {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::Dom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::Dom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameNode {
    #[new]
    fn __new__(callback: AzIFrameCallback, data: AzRefAny) -> Self {
        Self {
            callback,
            data,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzIFrameNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::IFrameNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::IFrameNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallbackData {
    #[new]
    fn __new__(event: AzEventFilterEnumWrapper, callback: AzCallback, data: AzRefAny) -> Self {
        Self {
            event,
            callback,
            data,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzCallbackData {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::CallbackData = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::CallbackData = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeData {
    #[new]
    fn new(node_type: AzNodeTypeEnumWrapper) -> AzNodeData {
        unsafe { mem::transmute(crate::AzNodeData_new(
            mem::transmute(node_type),
        )) }
    }
    #[staticmethod]
    fn body() -> AzNodeData {
        unsafe { mem::transmute(crate::AzNodeData_body()) }
    }
    #[staticmethod]
    fn div() -> AzNodeData {
        unsafe { mem::transmute(crate::AzNodeData_div()) }
    }
    #[staticmethod]
    fn br() -> AzNodeData {
        unsafe { mem::transmute(crate::AzNodeData_br()) }
    }
    #[staticmethod]
    fn text(string: String) -> AzNodeData {
        let string = pystring_to_azstring(&string);
        unsafe { mem::transmute(crate::AzNodeData_text(
            mem::transmute(string),
        )) }
    }
    #[staticmethod]
    fn image(image: AzImageRef) -> AzNodeData {
        unsafe { mem::transmute(crate::AzNodeData_image(
            mem::transmute(image),
        )) }
    }
    fn set_node_type(&mut self, node_type: AzNodeTypeEnumWrapper) -> () {
        unsafe { mem::transmute(crate::AzNodeData_setNodeType(
            mem::transmute(self),
            mem::transmute(node_type),
        )) }
    }
    fn with_node_type(&mut self, node_type: AzNodeTypeEnumWrapper) -> AzNodeData {
        unsafe { mem::transmute(crate::AzNodeData_withNodeType(
            mem::transmute(self),
            mem::transmute(node_type),
        )) }
    }
    fn set_ids_and_classes(&mut self, ids_and_classes: AzIdOrClassVec) -> () {
        unsafe { mem::transmute(crate::AzNodeData_setIdsAndClasses(
            mem::transmute(self),
            mem::transmute(ids_and_classes),
        )) }
    }
    fn with_ids_and_classes(&mut self, ids_and_classes: AzIdOrClassVec) -> AzNodeData {
        unsafe { mem::transmute(crate::AzNodeData_withIdsAndClasses(
            mem::transmute(self),
            mem::transmute(ids_and_classes),
        )) }
    }
    fn set_callbacks(&mut self, callbacks: AzCallbackDataVec) -> () {
        unsafe { mem::transmute(crate::AzNodeData_setCallbacks(
            mem::transmute(self),
            mem::transmute(callbacks),
        )) }
    }
    fn with_callbacks(&mut self, callbacks: AzCallbackDataVec) -> AzNodeData {
        unsafe { mem::transmute(crate::AzNodeData_withCallbacks(
            mem::transmute(self),
            mem::transmute(callbacks),
        )) }
    }
    fn set_inline_css_props(&mut self, css_properties: AzNodeDataInlineCssPropertyVec) -> () {
        unsafe { mem::transmute(crate::AzNodeData_setInlineCssProps(
            mem::transmute(self),
            mem::transmute(css_properties),
        )) }
    }
    fn with_inline_css_props(&mut self, css_properties: AzNodeDataInlineCssPropertyVec) -> AzNodeData {
        unsafe { mem::transmute(crate::AzNodeData_withInlineCssProps(
            mem::transmute(self),
            mem::transmute(css_properties),
        )) }
    }
    fn set_inline_style(&mut self, style: String) -> () {
        let style = pystring_to_azstring(&style);
        unsafe { mem::transmute(crate::AzNodeData_setInlineStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn with_inline_style(&mut self, style: String) -> AzNodeData {
        let style = pystring_to_azstring(&style);
        unsafe { mem::transmute(crate::AzNodeData_withInlineStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn set_inline_hover_style(&mut self, style: String) -> () {
        let style = pystring_to_azstring(&style);
        unsafe { mem::transmute(crate::AzNodeData_setInlineHoverStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn with_inline_hover_style(&mut self, style: String) -> AzNodeData {
        let style = pystring_to_azstring(&style);
        unsafe { mem::transmute(crate::AzNodeData_withInlineHoverStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn set_inline_active_style(&mut self, style: String) -> () {
        let style = pystring_to_azstring(&style);
        unsafe { mem::transmute(crate::AzNodeData_setInlineActiveStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn with_inline_active_style(&mut self, style: String) -> AzNodeData {
        let style = pystring_to_azstring(&style);
        unsafe { mem::transmute(crate::AzNodeData_withInlineActiveStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn set_inline_focus_style(&mut self, style: String) -> () {
        let style = pystring_to_azstring(&style);
        unsafe { mem::transmute(crate::AzNodeData_setInlineFocusStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn with_inline_focus_style(&mut self, style: String) -> AzNodeData {
        let style = pystring_to_azstring(&style);
        unsafe { mem::transmute(crate::AzNodeData_withInlineFocusStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn set_clip_mask(&mut self, image_mask: AzImageMask) -> () {
        unsafe { mem::transmute(crate::AzNodeData_setClipMask(
            mem::transmute(self),
            mem::transmute(image_mask),
        )) }
    }
    fn set_tab_index(&mut self, tab_index: AzTabIndexEnumWrapper) -> () {
        unsafe { mem::transmute(crate::AzNodeData_setTabIndex(
            mem::transmute(self),
            mem::transmute(tab_index),
        )) }
    }
    fn set_accessibility_info(&mut self, accessibility_info: AzAccessibilityInfo) -> () {
        unsafe { mem::transmute(crate::AzNodeData_setAccessibilityInfo(
            mem::transmute(self),
            mem::transmute(accessibility_info),
        )) }
    }
    fn set_menu_bar(&mut self, menu_bar: AzMenu) -> () {
        unsafe { mem::transmute(crate::AzNodeData_setMenuBar(
            mem::transmute(self),
            mem::transmute(menu_bar),
        )) }
    }
    fn set_context_menu(&mut self, context_menu: AzMenu) -> () {
        unsafe { mem::transmute(crate::AzNodeData_setContextMenu(
            mem::transmute(self),
            mem::transmute(context_menu),
        )) }
    }
    fn hash(&self) -> u64 {
        unsafe { mem::transmute(crate::AzNodeData_hash(
            mem::transmute(self),
        )) }
    }
// impl NodeData {

    #[staticmethod]
    fn iframe(py: Python, data: PyObject, callback: PyObject) -> Result<Self, PyErr> { // RefAny<IFrameCallbackTy>

        use pyo3::type_object::PyTypeInfo;

        if data.as_ref(py.clone()).is_callable() {
            return Err(PyException::new_err(format!("ERROR in Dom.iframe: - argument \"data\" is a function callback, expected class")));
        }

        let cb_any = callback.as_ref(py);
        if !cb_any.is_callable() {
            let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
            return Err(PyException::new_err(format!("ERROR in Dom.iframe: - argument \"callback\" is of type \"{}\", expected function", type_name)));
        }

        let iframe_refany = azul_impl::callbacks::RefAny::new(IFrameCallbackTy {
            _py_iframe_data: Some(data),
            _py_iframe_callback: Some(callback),
        });

        Ok(unsafe { mem::transmute(crate::AzNodeData_iframe(iframe_refany, invoke_python_iframe)) })
    }

    fn set_dataset(&mut self, py: Python, dataset: PyObject) -> Result<(), PyErr> { // RefAny<DatasetTy>
        use pyo3::type_object::PyTypeInfo;

        if dataset.as_ref(py.clone()).is_callable() {
            return Err(PyException::new_err(format!("ERROR in Dom.set_dataset: - argument \"dataset\" is a function callback, expected class")));
        }

        let dataset_refany = azul_impl::callbacks::RefAny::new(DatasetTy {
            _py_data: Some(dataset),
        });

        crate::AzNodeData_setDataset(unsafe { mem::transmute(self) }, dataset_refany);

        Ok(())
    }

    fn with_dataset(&mut self, py: Python, dataset: PyObject) -> Result<Self, PyErr> { // RefAny<DatasetTy>
        self.set_dataset(py, dataset)?;
        let d: &mut azul_impl::dom::NodeData = unsafe { mem::transmute(self) };
        Ok(unsafe { mem::transmute(d.swap_with_default()) })
    }

    fn add_callback(&mut self, py: Python, event: AzEventFilterEnumWrapper, data: PyObject, callback: PyObject) -> Result<(), PyErr> { // RefAny<CallbackTy>
        use pyo3::type_object::PyTypeInfo;

        if data.as_ref(py.clone()).is_callable() {
            return Err(PyException::new_err(format!("ERROR in Dom.add_callback: - argument \"data\" is a function callback, expected class")));
        }

        let cb_any = callback.as_ref(py);
        if !cb_any.is_callable() {
            let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
            return Err(PyException::new_err(format!("ERROR in Dom.add_callback: - argument \"callback\" is of type \"{}\", expected function", type_name)));
        }

        let callback_refany = azul_impl::callbacks::RefAny::new(CallbackTy {
            _py_callback: Some(callback),
            _py_data: Some(data),
        });

        unsafe {
            crate::AzNodeData_addCallback(
                mem::transmute(self),
                mem::transmute(event),
                callback_refany,
                invoke_python_callback
            );
        }

        Ok(())
    }

    fn with_callback(&mut self, py: Python, event: AzEventFilterEnumWrapper, data: PyObject, callback: PyObject) -> Result<Self, PyErr> { // RefAny<CallbackTy>
        self.add_callback(py, event, data, callback)?;
        let d: &mut azul_impl::dom::NodeData = unsafe { mem::transmute(self) };
        Ok(unsafe { mem::transmute(d.swap_with_default()) })
    }}

#[pyproto]
impl PyObjectProtocol for AzNodeData {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::NodeData = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::NodeData = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeEnumWrapper {
    #[classattr]
    fn Body() -> AzNodeTypeEnumWrapper { AzNodeTypeEnumWrapper { inner: AzNodeType::Body } }
    #[classattr]
    fn Div() -> AzNodeTypeEnumWrapper { AzNodeTypeEnumWrapper { inner: AzNodeType::Div } }
    #[classattr]
    fn Br() -> AzNodeTypeEnumWrapper { AzNodeTypeEnumWrapper { inner: AzNodeType::Br } }
    #[staticmethod]
    fn Text(v: AzString) -> AzNodeTypeEnumWrapper { AzNodeTypeEnumWrapper { inner: AzNodeType::Text(v) } }
    #[staticmethod]
    fn Image(v: AzImageRef) -> AzNodeTypeEnumWrapper { AzNodeTypeEnumWrapper { inner: AzNodeType::Image(v) } }
    #[staticmethod]
    fn IFrame(v: AzIFrameNode) -> AzNodeTypeEnumWrapper { AzNodeTypeEnumWrapper { inner: AzNodeType::IFrame(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeType;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeType::Body => Ok(vec!["Body".into_py(py), ().into_py(py)]),
            AzNodeType::Div => Ok(vec!["Div".into_py(py), ().into_py(py)]),
            AzNodeType::Br => Ok(vec!["Br".into_py(py), ().into_py(py)]),
            AzNodeType::Text(v) => Ok(vec!["Text".into_py(py), v.clone().into_py(py)]),
            AzNodeType::Image(v) => Ok(vec!["Image".into_py(py), v.clone().into_py(py)]),
            AzNodeType::IFrame(v) => Ok(vec!["IFrame".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::NodeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::NodeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnEnumWrapper {
    #[classattr]
    fn MouseOver() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::MouseOver } }
    #[classattr]
    fn MouseDown() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::MouseDown } }
    #[classattr]
    fn LeftMouseDown() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::LeftMouseDown } }
    #[classattr]
    fn MiddleMouseDown() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::MiddleMouseDown } }
    #[classattr]
    fn RightMouseDown() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::RightMouseDown } }
    #[classattr]
    fn MouseUp() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::MouseUp } }
    #[classattr]
    fn LeftMouseUp() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::LeftMouseUp } }
    #[classattr]
    fn MiddleMouseUp() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::MiddleMouseUp } }
    #[classattr]
    fn RightMouseUp() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::RightMouseUp } }
    #[classattr]
    fn MouseEnter() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::MouseEnter } }
    #[classattr]
    fn MouseLeave() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::MouseLeave } }
    #[classattr]
    fn Scroll() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::Scroll } }
    #[classattr]
    fn TextInput() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::TextInput } }
    #[classattr]
    fn VirtualKeyDown() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::VirtualKeyDown } }
    #[classattr]
    fn VirtualKeyUp() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::VirtualKeyUp } }
    #[classattr]
    fn HoveredFile() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::HoveredFile } }
    #[classattr]
    fn DroppedFile() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::DroppedFile } }
    #[classattr]
    fn HoveredFileCancelled() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::HoveredFileCancelled } }
    #[classattr]
    fn FocusReceived() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::FocusReceived } }
    #[classattr]
    fn FocusLost() -> AzOnEnumWrapper { AzOnEnumWrapper { inner: AzOn::FocusLost } }
}

#[pyproto]
impl PyObjectProtocol for AzOnEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::On = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::On = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzOnEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzEventFilterEnumWrapper {
    #[staticmethod]
    fn Hover(v: AzHoverEventFilterEnumWrapper) -> AzEventFilterEnumWrapper { AzEventFilterEnumWrapper { inner: AzEventFilter::Hover(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Not(v: AzNotEventFilterEnumWrapper) -> AzEventFilterEnumWrapper { AzEventFilterEnumWrapper { inner: AzEventFilter::Not(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Focus(v: AzFocusEventFilterEnumWrapper) -> AzEventFilterEnumWrapper { AzEventFilterEnumWrapper { inner: AzEventFilter::Focus(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Window(v: AzWindowEventFilterEnumWrapper) -> AzEventFilterEnumWrapper { AzEventFilterEnumWrapper { inner: AzEventFilter::Window(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Component(v: AzComponentEventFilterEnumWrapper) -> AzEventFilterEnumWrapper { AzEventFilterEnumWrapper { inner: AzEventFilter::Component(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Application(v: AzApplicationEventFilterEnumWrapper) -> AzEventFilterEnumWrapper { AzEventFilterEnumWrapper { inner: AzEventFilter::Application(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzEventFilter;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzEventFilter::Hover(v) => Ok(vec!["Hover".into_py(py), { let m: &AzHoverEventFilterEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzEventFilter::Not(v) => Ok(vec!["Not".into_py(py), { let m: &AzNotEventFilterEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzEventFilter::Focus(v) => Ok(vec!["Focus".into_py(py), { let m: &AzFocusEventFilterEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzEventFilter::Window(v) => Ok(vec!["Window".into_py(py), { let m: &AzWindowEventFilterEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzEventFilter::Component(v) => Ok(vec!["Component".into_py(py), { let m: &AzComponentEventFilterEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzEventFilter::Application(v) => Ok(vec!["Application".into_py(py), { let m: &AzApplicationEventFilterEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::EventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::EventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzHoverEventFilterEnumWrapper {
    #[classattr]
    fn MouseOver() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::MouseOver } }
    #[classattr]
    fn MouseDown() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::MouseDown } }
    #[classattr]
    fn LeftMouseDown() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::LeftMouseDown } }
    #[classattr]
    fn RightMouseDown() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::RightMouseDown } }
    #[classattr]
    fn MiddleMouseDown() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::MiddleMouseDown } }
    #[classattr]
    fn MouseUp() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::MouseUp } }
    #[classattr]
    fn LeftMouseUp() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::LeftMouseUp } }
    #[classattr]
    fn RightMouseUp() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::RightMouseUp } }
    #[classattr]
    fn MiddleMouseUp() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::MiddleMouseUp } }
    #[classattr]
    fn MouseEnter() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::MouseEnter } }
    #[classattr]
    fn MouseLeave() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::MouseLeave } }
    #[classattr]
    fn Scroll() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::Scroll } }
    #[classattr]
    fn ScrollStart() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::ScrollStart } }
    #[classattr]
    fn ScrollEnd() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::ScrollEnd } }
    #[classattr]
    fn TextInput() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::TextInput } }
    #[classattr]
    fn VirtualKeyDown() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::VirtualKeyDown } }
    #[classattr]
    fn VirtualKeyUp() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::VirtualKeyUp } }
    #[classattr]
    fn HoveredFile() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::HoveredFile } }
    #[classattr]
    fn DroppedFile() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::DroppedFile } }
    #[classattr]
    fn HoveredFileCancelled() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::HoveredFileCancelled } }
    #[classattr]
    fn TouchStart() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::TouchStart } }
    #[classattr]
    fn TouchMove() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::TouchMove } }
    #[classattr]
    fn TouchEnd() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::TouchEnd } }
    #[classattr]
    fn TouchCancel() -> AzHoverEventFilterEnumWrapper { AzHoverEventFilterEnumWrapper { inner: AzHoverEventFilter::TouchCancel } }
}

#[pyproto]
impl PyObjectProtocol for AzHoverEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::HoverEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::HoverEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzHoverEventFilterEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzFocusEventFilterEnumWrapper {
    #[classattr]
    fn MouseOver() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::MouseOver } }
    #[classattr]
    fn MouseDown() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::MouseDown } }
    #[classattr]
    fn LeftMouseDown() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::LeftMouseDown } }
    #[classattr]
    fn RightMouseDown() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::RightMouseDown } }
    #[classattr]
    fn MiddleMouseDown() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::MiddleMouseDown } }
    #[classattr]
    fn MouseUp() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::MouseUp } }
    #[classattr]
    fn LeftMouseUp() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::LeftMouseUp } }
    #[classattr]
    fn RightMouseUp() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::RightMouseUp } }
    #[classattr]
    fn MiddleMouseUp() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::MiddleMouseUp } }
    #[classattr]
    fn MouseEnter() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::MouseEnter } }
    #[classattr]
    fn MouseLeave() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::MouseLeave } }
    #[classattr]
    fn Scroll() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::Scroll } }
    #[classattr]
    fn ScrollStart() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::ScrollStart } }
    #[classattr]
    fn ScrollEnd() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::ScrollEnd } }
    #[classattr]
    fn TextInput() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::TextInput } }
    #[classattr]
    fn VirtualKeyDown() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::VirtualKeyDown } }
    #[classattr]
    fn VirtualKeyUp() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::VirtualKeyUp } }
    #[classattr]
    fn FocusReceived() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::FocusReceived } }
    #[classattr]
    fn FocusLost() -> AzFocusEventFilterEnumWrapper { AzFocusEventFilterEnumWrapper { inner: AzFocusEventFilter::FocusLost } }
}

#[pyproto]
impl PyObjectProtocol for AzFocusEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::FocusEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::FocusEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzFocusEventFilterEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzNotEventFilterEnumWrapper {
    #[staticmethod]
    fn Hover(v: AzHoverEventFilterEnumWrapper) -> AzNotEventFilterEnumWrapper { AzNotEventFilterEnumWrapper { inner: AzNotEventFilter::Hover(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Focus(v: AzFocusEventFilterEnumWrapper) -> AzNotEventFilterEnumWrapper { AzNotEventFilterEnumWrapper { inner: AzNotEventFilter::Focus(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNotEventFilter;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNotEventFilter::Hover(v) => Ok(vec!["Hover".into_py(py), { let m: &AzHoverEventFilterEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzNotEventFilter::Focus(v) => Ok(vec!["Focus".into_py(py), { let m: &AzFocusEventFilterEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNotEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::NotEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::NotEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowEventFilterEnumWrapper {
    #[classattr]
    fn MouseOver() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::MouseOver } }
    #[classattr]
    fn MouseDown() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::MouseDown } }
    #[classattr]
    fn LeftMouseDown() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::LeftMouseDown } }
    #[classattr]
    fn RightMouseDown() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::RightMouseDown } }
    #[classattr]
    fn MiddleMouseDown() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::MiddleMouseDown } }
    #[classattr]
    fn MouseUp() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::MouseUp } }
    #[classattr]
    fn LeftMouseUp() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::LeftMouseUp } }
    #[classattr]
    fn RightMouseUp() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::RightMouseUp } }
    #[classattr]
    fn MiddleMouseUp() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::MiddleMouseUp } }
    #[classattr]
    fn MouseEnter() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::MouseEnter } }
    #[classattr]
    fn MouseLeave() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::MouseLeave } }
    #[classattr]
    fn Scroll() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::Scroll } }
    #[classattr]
    fn ScrollStart() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::ScrollStart } }
    #[classattr]
    fn ScrollEnd() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::ScrollEnd } }
    #[classattr]
    fn TextInput() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::TextInput } }
    #[classattr]
    fn VirtualKeyDown() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::VirtualKeyDown } }
    #[classattr]
    fn VirtualKeyUp() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::VirtualKeyUp } }
    #[classattr]
    fn HoveredFile() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::HoveredFile } }
    #[classattr]
    fn DroppedFile() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::DroppedFile } }
    #[classattr]
    fn HoveredFileCancelled() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::HoveredFileCancelled } }
    #[classattr]
    fn Resized() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::Resized } }
    #[classattr]
    fn Moved() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::Moved } }
    #[classattr]
    fn TouchStart() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::TouchStart } }
    #[classattr]
    fn TouchMove() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::TouchMove } }
    #[classattr]
    fn TouchEnd() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::TouchEnd } }
    #[classattr]
    fn TouchCancel() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::TouchCancel } }
    #[classattr]
    fn FocusReceived() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::FocusReceived } }
    #[classattr]
    fn FocusLost() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::FocusLost } }
    #[classattr]
    fn CloseRequested() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::CloseRequested } }
    #[classattr]
    fn ThemeChanged() -> AzWindowEventFilterEnumWrapper { AzWindowEventFilterEnumWrapper { inner: AzWindowEventFilter::ThemeChanged } }
}

#[pyproto]
impl PyObjectProtocol for AzWindowEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::WindowEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::WindowEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzWindowEventFilterEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzComponentEventFilterEnumWrapper {
    #[classattr]
    fn AfterMount() -> AzComponentEventFilterEnumWrapper { AzComponentEventFilterEnumWrapper { inner: AzComponentEventFilter::AfterMount } }
    #[classattr]
    fn BeforeUnmount() -> AzComponentEventFilterEnumWrapper { AzComponentEventFilterEnumWrapper { inner: AzComponentEventFilter::BeforeUnmount } }
    #[classattr]
    fn NodeResized() -> AzComponentEventFilterEnumWrapper { AzComponentEventFilterEnumWrapper { inner: AzComponentEventFilter::NodeResized } }
    #[classattr]
    fn DefaultAction() -> AzComponentEventFilterEnumWrapper { AzComponentEventFilterEnumWrapper { inner: AzComponentEventFilter::DefaultAction } }
    #[classattr]
    fn Selected() -> AzComponentEventFilterEnumWrapper { AzComponentEventFilterEnumWrapper { inner: AzComponentEventFilter::Selected } }
}

#[pyproto]
impl PyObjectProtocol for AzComponentEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::ComponentEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::ComponentEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzComponentEventFilterEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzApplicationEventFilterEnumWrapper {
    #[classattr]
    fn DeviceConnected() -> AzApplicationEventFilterEnumWrapper { AzApplicationEventFilterEnumWrapper { inner: AzApplicationEventFilter::DeviceConnected } }
    #[classattr]
    fn DeviceDisconnected() -> AzApplicationEventFilterEnumWrapper { AzApplicationEventFilterEnumWrapper { inner: AzApplicationEventFilter::DeviceDisconnected } }
}

#[pyproto]
impl PyObjectProtocol for AzApplicationEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::ApplicationEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::ApplicationEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzApplicationEventFilterEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAccessibilityInfo {
    #[new]
    fn __new__(name: AzOptionStringEnumWrapper, value: AzOptionStringEnumWrapper, role: AzAccessibilityRoleEnumWrapper, states: AzAccessibilityStateVec, accelerator: AzOptionVirtualKeyCodeComboEnumWrapper, default_action: AzOptionStringEnumWrapper) -> Self {
        Self {
            name,
            value,
            role,
            states,
            accelerator,
            default_action,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::AccessibilityInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::AccessibilityInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAccessibilityRoleEnumWrapper {
    #[classattr]
    fn TitleBar() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::TitleBar } }
    #[classattr]
    fn MenuBar() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::MenuBar } }
    #[classattr]
    fn ScrollBar() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::ScrollBar } }
    #[classattr]
    fn Grip() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Grip } }
    #[classattr]
    fn Sound() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Sound } }
    #[classattr]
    fn Cursor() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Cursor } }
    #[classattr]
    fn Caret() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Caret } }
    #[classattr]
    fn Alert() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Alert } }
    #[classattr]
    fn Window() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Window } }
    #[classattr]
    fn Client() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Client } }
    #[classattr]
    fn MenuPopup() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::MenuPopup } }
    #[classattr]
    fn MenuItem() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::MenuItem } }
    #[classattr]
    fn Tooltip() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Tooltip } }
    #[classattr]
    fn Application() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Application } }
    #[classattr]
    fn Document() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Document } }
    #[classattr]
    fn Pane() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Pane } }
    #[classattr]
    fn Chart() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Chart } }
    #[classattr]
    fn Dialog() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Dialog } }
    #[classattr]
    fn Border() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Border } }
    #[classattr]
    fn Grouping() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Grouping } }
    #[classattr]
    fn Separator() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Separator } }
    #[classattr]
    fn Toolbar() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Toolbar } }
    #[classattr]
    fn StatusBar() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::StatusBar } }
    #[classattr]
    fn Table() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Table } }
    #[classattr]
    fn ColumnHeader() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::ColumnHeader } }
    #[classattr]
    fn RowHeader() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::RowHeader } }
    #[classattr]
    fn Column() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Column } }
    #[classattr]
    fn Row() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Row } }
    #[classattr]
    fn Cell() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Cell } }
    #[classattr]
    fn Link() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Link } }
    #[classattr]
    fn HelpBalloon() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::HelpBalloon } }
    #[classattr]
    fn Character() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Character } }
    #[classattr]
    fn List() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::List } }
    #[classattr]
    fn ListItem() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::ListItem } }
    #[classattr]
    fn Outline() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Outline } }
    #[classattr]
    fn OutlineItem() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::OutlineItem } }
    #[classattr]
    fn Pagetab() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Pagetab } }
    #[classattr]
    fn PropertyPage() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::PropertyPage } }
    #[classattr]
    fn Indicator() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Indicator } }
    #[classattr]
    fn Graphic() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Graphic } }
    #[classattr]
    fn StaticText() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::StaticText } }
    #[classattr]
    fn Text() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Text } }
    #[classattr]
    fn PushButton() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::PushButton } }
    #[classattr]
    fn CheckButton() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::CheckButton } }
    #[classattr]
    fn RadioButton() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::RadioButton } }
    #[classattr]
    fn ComboBox() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::ComboBox } }
    #[classattr]
    fn DropList() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::DropList } }
    #[classattr]
    fn ProgressBar() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::ProgressBar } }
    #[classattr]
    fn Dial() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Dial } }
    #[classattr]
    fn HotkeyField() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::HotkeyField } }
    #[classattr]
    fn Slider() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Slider } }
    #[classattr]
    fn SpinButton() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::SpinButton } }
    #[classattr]
    fn Diagram() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Diagram } }
    #[classattr]
    fn Animation() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Animation } }
    #[classattr]
    fn Equation() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Equation } }
    #[classattr]
    fn ButtonDropdown() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::ButtonDropdown } }
    #[classattr]
    fn ButtonMenu() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::ButtonMenu } }
    #[classattr]
    fn ButtonDropdownGrid() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::ButtonDropdownGrid } }
    #[classattr]
    fn Whitespace() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Whitespace } }
    #[classattr]
    fn PageTabList() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::PageTabList } }
    #[classattr]
    fn Clock() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Clock } }
    #[classattr]
    fn SplitButton() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::SplitButton } }
    #[classattr]
    fn IpAddress() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::IpAddress } }
    #[classattr]
    fn Nothing() -> AzAccessibilityRoleEnumWrapper { AzAccessibilityRoleEnumWrapper { inner: AzAccessibilityRole::Nothing } }
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityRoleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::AccessibilityRole = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::AccessibilityRole = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAccessibilityRoleEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAccessibilityStateEnumWrapper {
    #[classattr]
    fn Unavailable() -> AzAccessibilityStateEnumWrapper { AzAccessibilityStateEnumWrapper { inner: AzAccessibilityState::Unavailable } }
    #[classattr]
    fn Selected() -> AzAccessibilityStateEnumWrapper { AzAccessibilityStateEnumWrapper { inner: AzAccessibilityState::Selected } }
    #[classattr]
    fn Focused() -> AzAccessibilityStateEnumWrapper { AzAccessibilityStateEnumWrapper { inner: AzAccessibilityState::Focused } }
    #[classattr]
    fn Checked() -> AzAccessibilityStateEnumWrapper { AzAccessibilityStateEnumWrapper { inner: AzAccessibilityState::Checked } }
    #[classattr]
    fn Readonly() -> AzAccessibilityStateEnumWrapper { AzAccessibilityStateEnumWrapper { inner: AzAccessibilityState::Readonly } }
    #[classattr]
    fn Default() -> AzAccessibilityStateEnumWrapper { AzAccessibilityStateEnumWrapper { inner: AzAccessibilityState::Default } }
    #[classattr]
    fn Expanded() -> AzAccessibilityStateEnumWrapper { AzAccessibilityStateEnumWrapper { inner: AzAccessibilityState::Expanded } }
    #[classattr]
    fn Collapsed() -> AzAccessibilityStateEnumWrapper { AzAccessibilityStateEnumWrapper { inner: AzAccessibilityState::Collapsed } }
    #[classattr]
    fn Busy() -> AzAccessibilityStateEnumWrapper { AzAccessibilityStateEnumWrapper { inner: AzAccessibilityState::Busy } }
    #[classattr]
    fn Offscreen() -> AzAccessibilityStateEnumWrapper { AzAccessibilityStateEnumWrapper { inner: AzAccessibilityState::Offscreen } }
    #[classattr]
    fn Focusable() -> AzAccessibilityStateEnumWrapper { AzAccessibilityStateEnumWrapper { inner: AzAccessibilityState::Focusable } }
    #[classattr]
    fn Selectable() -> AzAccessibilityStateEnumWrapper { AzAccessibilityStateEnumWrapper { inner: AzAccessibilityState::Selectable } }
    #[classattr]
    fn Linked() -> AzAccessibilityStateEnumWrapper { AzAccessibilityStateEnumWrapper { inner: AzAccessibilityState::Linked } }
    #[classattr]
    fn Traversed() -> AzAccessibilityStateEnumWrapper { AzAccessibilityStateEnumWrapper { inner: AzAccessibilityState::Traversed } }
    #[classattr]
    fn Multiselectable() -> AzAccessibilityStateEnumWrapper { AzAccessibilityStateEnumWrapper { inner: AzAccessibilityState::Multiselectable } }
    #[classattr]
    fn Protected() -> AzAccessibilityStateEnumWrapper { AzAccessibilityStateEnumWrapper { inner: AzAccessibilityState::Protected } }
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::AccessibilityState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::AccessibilityState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAccessibilityStateEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzTabIndexEnumWrapper {
    #[classattr]
    fn Auto() -> AzTabIndexEnumWrapper { AzTabIndexEnumWrapper { inner: AzTabIndex::Auto } }
    #[staticmethod]
    fn OverrideInParent(v: u32) -> AzTabIndexEnumWrapper { AzTabIndexEnumWrapper { inner: AzTabIndex::OverrideInParent(v) } }
    #[classattr]
    fn NoKeyboardFocus() -> AzTabIndexEnumWrapper { AzTabIndexEnumWrapper { inner: AzTabIndex::NoKeyboardFocus } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzTabIndex;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTabIndex::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzTabIndex::OverrideInParent(v) => Ok(vec!["OverrideInParent".into_py(py), v.into_py(py)]),
            AzTabIndex::NoKeyboardFocus => Ok(vec!["NoKeyboardFocus".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTabIndexEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::TabIndex = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::TabIndex = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIdOrClassEnumWrapper {
    #[staticmethod]
    fn Id(v: AzString) -> AzIdOrClassEnumWrapper { AzIdOrClassEnumWrapper { inner: AzIdOrClass::Id(v) } }
    #[staticmethod]
    fn Class(v: AzString) -> AzIdOrClassEnumWrapper { AzIdOrClassEnumWrapper { inner: AzIdOrClass::Class(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzIdOrClass;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzIdOrClass::Id(v) => Ok(vec!["Id".into_py(py), v.clone().into_py(py)]),
            AzIdOrClass::Class(v) => Ok(vec!["Class".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIdOrClassEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::IdOrClass = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::IdOrClass = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataInlineCssPropertyEnumWrapper {
    #[staticmethod]
    fn Normal(v: AzCssPropertyEnumWrapper) -> AzNodeDataInlineCssPropertyEnumWrapper { AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Normal(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Active(v: AzCssPropertyEnumWrapper) -> AzNodeDataInlineCssPropertyEnumWrapper { AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Active(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Focus(v: AzCssPropertyEnumWrapper) -> AzNodeDataInlineCssPropertyEnumWrapper { AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Focus(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Hover(v: AzCssPropertyEnumWrapper) -> AzNodeDataInlineCssPropertyEnumWrapper { AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Hover(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeDataInlineCssProperty;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeDataInlineCssProperty::Normal(v) => Ok(vec!["Normal".into_py(py), { let m: &AzCssPropertyEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzNodeDataInlineCssProperty::Active(v) => Ok(vec!["Active".into_py(py), { let m: &AzCssPropertyEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzNodeDataInlineCssProperty::Focus(v) => Ok(vec!["Focus".into_py(py), { let m: &AzCssPropertyEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzNodeDataInlineCssProperty::Hover(v) => Ok(vec!["Hover".into_py(py), { let m: &AzCssPropertyEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataInlineCssPropertyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::NodeDataInlineCssProperty = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::NodeDataInlineCssProperty = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenu {
    #[new]
    fn new(items: AzMenuItemVec) -> AzMenu {
        unsafe { mem::transmute(crate::AzMenu_new(
            mem::transmute(items),
        )) }
    }
    fn set_popup_position(&mut self, position: AzMenuPopupPositionEnumWrapper) -> () {
        unsafe { mem::transmute(crate::AzMenu_setPopupPosition(
            mem::transmute(self),
            mem::transmute(position),
        )) }
    }
    fn with_popup_position(&mut self, position: AzMenuPopupPositionEnumWrapper) -> AzMenu {
        unsafe { mem::transmute(crate::AzMenu_withPopupPosition(
            mem::transmute(self),
            mem::transmute(position),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenu {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Menu = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Menu = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzContextMenuMouseButtonEnumWrapper {
    #[classattr]
    fn Right() -> AzContextMenuMouseButtonEnumWrapper { AzContextMenuMouseButtonEnumWrapper { inner: AzContextMenuMouseButton::Right } }
    #[classattr]
    fn Middle() -> AzContextMenuMouseButtonEnumWrapper { AzContextMenuMouseButtonEnumWrapper { inner: AzContextMenuMouseButton::Middle } }
    #[classattr]
    fn Left() -> AzContextMenuMouseButtonEnumWrapper { AzContextMenuMouseButtonEnumWrapper { inner: AzContextMenuMouseButton::Left } }
}

#[pyproto]
impl PyObjectProtocol for AzContextMenuMouseButtonEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ContextMenuMouseButton = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ContextMenuMouseButton = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzContextMenuMouseButtonEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzMenuPopupPositionEnumWrapper {
    #[classattr]
    fn BottomLeftOfCursor() -> AzMenuPopupPositionEnumWrapper { AzMenuPopupPositionEnumWrapper { inner: AzMenuPopupPosition::BottomLeftOfCursor } }
    #[classattr]
    fn BottomRightOfCursor() -> AzMenuPopupPositionEnumWrapper { AzMenuPopupPositionEnumWrapper { inner: AzMenuPopupPosition::BottomRightOfCursor } }
    #[classattr]
    fn TopLeftOfCursor() -> AzMenuPopupPositionEnumWrapper { AzMenuPopupPositionEnumWrapper { inner: AzMenuPopupPosition::TopLeftOfCursor } }
    #[classattr]
    fn TopRightOfCursor() -> AzMenuPopupPositionEnumWrapper { AzMenuPopupPositionEnumWrapper { inner: AzMenuPopupPosition::TopRightOfCursor } }
    #[classattr]
    fn BottomOfHitRect() -> AzMenuPopupPositionEnumWrapper { AzMenuPopupPositionEnumWrapper { inner: AzMenuPopupPosition::BottomOfHitRect } }
    #[classattr]
    fn LeftOfHitRect() -> AzMenuPopupPositionEnumWrapper { AzMenuPopupPositionEnumWrapper { inner: AzMenuPopupPosition::LeftOfHitRect } }
    #[classattr]
    fn TopOfHitRect() -> AzMenuPopupPositionEnumWrapper { AzMenuPopupPositionEnumWrapper { inner: AzMenuPopupPosition::TopOfHitRect } }
    #[classattr]
    fn RightOfHitRect() -> AzMenuPopupPositionEnumWrapper { AzMenuPopupPositionEnumWrapper { inner: AzMenuPopupPosition::RightOfHitRect } }
    #[classattr]
    fn AutoCursor() -> AzMenuPopupPositionEnumWrapper { AzMenuPopupPositionEnumWrapper { inner: AzMenuPopupPosition::AutoCursor } }
    #[classattr]
    fn AutoHitRect() -> AzMenuPopupPositionEnumWrapper { AzMenuPopupPositionEnumWrapper { inner: AzMenuPopupPosition::AutoHitRect } }
}

#[pyproto]
impl PyObjectProtocol for AzMenuPopupPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MenuPopupPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MenuPopupPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzMenuPopupPositionEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzMenuItemEnumWrapper {
    #[staticmethod]
    fn String(v: AzStringMenuItem) -> AzMenuItemEnumWrapper { AzMenuItemEnumWrapper { inner: AzMenuItem::String(v) } }
    #[classattr]
    fn Separator() -> AzMenuItemEnumWrapper { AzMenuItemEnumWrapper { inner: AzMenuItem::Separator } }
    #[classattr]
    fn BreakLine() -> AzMenuItemEnumWrapper { AzMenuItemEnumWrapper { inner: AzMenuItem::BreakLine } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzMenuItem;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzMenuItem::String(v) => Ok(vec!["String".into_py(py), v.clone().into_py(py)]),
            AzMenuItem::Separator => Ok(vec!["Separator".into_py(py), ().into_py(py)]),
            AzMenuItem::BreakLine => Ok(vec!["BreakLine".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MenuItem = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MenuItem = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringMenuItem {
    #[new]
    fn new(label: String) -> AzStringMenuItem {
        let label = pystring_to_azstring(&label);
        unsafe { mem::transmute(crate::AzStringMenuItem_new(
            mem::transmute(label),
        )) }
    }
    fn add_child(&mut self, child: AzMenuItemEnumWrapper) -> () {
        unsafe { mem::transmute(crate::AzStringMenuItem_addChild(
            mem::transmute(self),
            mem::transmute(child),
        )) }
    }
    fn with_child(&mut self, child: AzMenuItemEnumWrapper) -> AzStringMenuItem {
        unsafe { mem::transmute(crate::AzStringMenuItem_withChild(
            mem::transmute(self),
            mem::transmute(child),
        )) }
    }
    fn set_children(&mut self, children: AzMenuItemVec) -> () {
        unsafe { mem::transmute(crate::AzStringMenuItem_setChildren(
            mem::transmute(self),
            mem::transmute(children),
        )) }
    }
    fn with_children(&mut self, children: AzMenuItemVec) -> AzStringMenuItem {
        unsafe { mem::transmute(crate::AzStringMenuItem_withChildren(
            mem::transmute(self),
            mem::transmute(children),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStringMenuItem {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::StringMenuItem = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::StringMenuItem = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVirtualKeyCodeCombo {
    #[new]
    fn __new__(keys: AzVirtualKeyCodeVec) -> Self {
        Self {
            keys,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzVirtualKeyCodeCombo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeCombo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeCombo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuCallback {
}

#[pyproto]
impl PyObjectProtocol for AzMenuCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MenuCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MenuCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuItemIconEnumWrapper {
    #[staticmethod]
    fn Checkbox(v: bool) -> AzMenuItemIconEnumWrapper { AzMenuItemIconEnumWrapper { inner: AzMenuItemIcon::Checkbox(v) } }
    #[staticmethod]
    fn Image(v: AzImageRef) -> AzMenuItemIconEnumWrapper { AzMenuItemIconEnumWrapper { inner: AzMenuItemIcon::Image(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzMenuItemIcon;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzMenuItemIcon::Checkbox(v) => Ok(vec!["Checkbox".into_py(py), v.into_py(py)]),
            AzMenuItemIcon::Image(v) => Ok(vec!["Image".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MenuItemIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MenuItemIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuItemStateEnumWrapper {
    #[classattr]
    fn Normal() -> AzMenuItemStateEnumWrapper { AzMenuItemStateEnumWrapper { inner: AzMenuItemState::Normal } }
    #[classattr]
    fn Greyed() -> AzMenuItemStateEnumWrapper { AzMenuItemStateEnumWrapper { inner: AzMenuItemState::Greyed } }
    #[classattr]
    fn Disabled() -> AzMenuItemStateEnumWrapper { AzMenuItemStateEnumWrapper { inner: AzMenuItemState::Disabled } }
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MenuItemState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MenuItemState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzMenuItemStateEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzCssRuleBlock {
    #[new]
    fn __new__(path: AzCssPath, declarations: AzCssDeclarationVec) -> Self {
        Self {
            path,
            declarations,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzCssRuleBlock {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssRuleBlock = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssRuleBlock = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssDeclarationEnumWrapper {
    #[staticmethod]
    fn Static(v: AzCssPropertyEnumWrapper) -> AzCssDeclarationEnumWrapper { AzCssDeclarationEnumWrapper { inner: AzCssDeclaration::Static(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Dynamic(v: AzDynamicCssProperty) -> AzCssDeclarationEnumWrapper { AzCssDeclarationEnumWrapper { inner: AzCssDeclaration::Dynamic(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssDeclaration;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssDeclaration::Static(v) => Ok(vec!["Static".into_py(py), { let m: &AzCssPropertyEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssDeclaration::Dynamic(v) => Ok(vec!["Dynamic".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssDeclarationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssDeclaration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssDeclaration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDynamicCssProperty {
    #[new]
    fn __new__(dynamic_id: AzString, default_value: AzCssPropertyEnumWrapper) -> Self {
        Self {
            dynamic_id,
            default_value,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzDynamicCssProperty {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::DynamicCssProperty = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::DynamicCssProperty = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPath {
    #[new]
    fn __new__(selectors: AzCssPathSelectorVec) -> Self {
        Self {
            selectors,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzCssPath {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssPath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssPath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPathSelectorEnumWrapper {
    #[classattr]
    fn Global() -> AzCssPathSelectorEnumWrapper { AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::Global } }
    #[staticmethod]
    fn Type(v: AzNodeTypeKeyEnumWrapper) -> AzCssPathSelectorEnumWrapper { AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::Type(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Class(v: AzString) -> AzCssPathSelectorEnumWrapper { AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::Class(v) } }
    #[staticmethod]
    fn Id(v: AzString) -> AzCssPathSelectorEnumWrapper { AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::Id(v) } }
    #[staticmethod]
    fn PseudoSelector(v: AzCssPathPseudoSelectorEnumWrapper) -> AzCssPathSelectorEnumWrapper { AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::PseudoSelector(unsafe { mem::transmute(v) }) } }
    #[classattr]
    fn DirectChildren() -> AzCssPathSelectorEnumWrapper { AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::DirectChildren } }
    #[classattr]
    fn Children() -> AzCssPathSelectorEnumWrapper { AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::Children } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssPathSelector;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPathSelector::Global => Ok(vec!["Global".into_py(py), ().into_py(py)]),
            AzCssPathSelector::Type(v) => Ok(vec!["Type".into_py(py), { let m: &AzNodeTypeKeyEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssPathSelector::Class(v) => Ok(vec!["Class".into_py(py), v.clone().into_py(py)]),
            AzCssPathSelector::Id(v) => Ok(vec!["Id".into_py(py), v.clone().into_py(py)]),
            AzCssPathSelector::PseudoSelector(v) => Ok(vec!["PseudoSelector".into_py(py), { let m: &AzCssPathPseudoSelectorEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssPathSelector::DirectChildren => Ok(vec!["DirectChildren".into_py(py), ().into_py(py)]),
            AzCssPathSelector::Children => Ok(vec!["Children".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPathSelectorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssPathSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssPathSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeKeyEnumWrapper {
    #[classattr]
    fn Body() -> AzNodeTypeKeyEnumWrapper { AzNodeTypeKeyEnumWrapper { inner: AzNodeTypeKey::Body } }
    #[classattr]
    fn Div() -> AzNodeTypeKeyEnumWrapper { AzNodeTypeKeyEnumWrapper { inner: AzNodeTypeKey::Div } }
    #[classattr]
    fn Br() -> AzNodeTypeKeyEnumWrapper { AzNodeTypeKeyEnumWrapper { inner: AzNodeTypeKey::Br } }
    #[classattr]
    fn P() -> AzNodeTypeKeyEnumWrapper { AzNodeTypeKeyEnumWrapper { inner: AzNodeTypeKey::P } }
    #[classattr]
    fn Img() -> AzNodeTypeKeyEnumWrapper { AzNodeTypeKeyEnumWrapper { inner: AzNodeTypeKey::Img } }
    #[classattr]
    fn IFrame() -> AzNodeTypeKeyEnumWrapper { AzNodeTypeKeyEnumWrapper { inner: AzNodeTypeKey::IFrame } }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeKeyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::NodeTypeTag = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::NodeTypeTag = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzNodeTypeKeyEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzCssPathPseudoSelectorEnumWrapper {
    #[classattr]
    fn First() -> AzCssPathPseudoSelectorEnumWrapper { AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::First } }
    #[classattr]
    fn Last() -> AzCssPathPseudoSelectorEnumWrapper { AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::Last } }
    #[staticmethod]
    fn NthChild(v: AzCssNthChildSelectorEnumWrapper) -> AzCssPathPseudoSelectorEnumWrapper { AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::NthChild(unsafe { mem::transmute(v) }) } }
    #[classattr]
    fn Hover() -> AzCssPathPseudoSelectorEnumWrapper { AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::Hover } }
    #[classattr]
    fn Active() -> AzCssPathPseudoSelectorEnumWrapper { AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::Active } }
    #[classattr]
    fn Focus() -> AzCssPathPseudoSelectorEnumWrapper { AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::Focus } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssPathPseudoSelector;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPathPseudoSelector::First => Ok(vec!["First".into_py(py), ().into_py(py)]),
            AzCssPathPseudoSelector::Last => Ok(vec!["Last".into_py(py), ().into_py(py)]),
            AzCssPathPseudoSelector::NthChild(v) => Ok(vec!["NthChild".into_py(py), { let m: &AzCssNthChildSelectorEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssPathPseudoSelector::Hover => Ok(vec!["Hover".into_py(py), ().into_py(py)]),
            AzCssPathPseudoSelector::Active => Ok(vec!["Active".into_py(py), ().into_py(py)]),
            AzCssPathPseudoSelector::Focus => Ok(vec!["Focus".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPathPseudoSelectorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssPathPseudoSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssPathPseudoSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssNthChildSelectorEnumWrapper {
    #[staticmethod]
    fn Number(v: u32) -> AzCssNthChildSelectorEnumWrapper { AzCssNthChildSelectorEnumWrapper { inner: AzCssNthChildSelector::Number(v) } }
    #[classattr]
    fn Even() -> AzCssNthChildSelectorEnumWrapper { AzCssNthChildSelectorEnumWrapper { inner: AzCssNthChildSelector::Even } }
    #[classattr]
    fn Odd() -> AzCssNthChildSelectorEnumWrapper { AzCssNthChildSelectorEnumWrapper { inner: AzCssNthChildSelector::Odd } }
    #[staticmethod]
    fn Pattern(v: AzCssNthChildPattern) -> AzCssNthChildSelectorEnumWrapper { AzCssNthChildSelectorEnumWrapper { inner: AzCssNthChildSelector::Pattern(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssNthChildSelector;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssNthChildSelector::Number(v) => Ok(vec!["Number".into_py(py), v.into_py(py)]),
            AzCssNthChildSelector::Even => Ok(vec!["Even".into_py(py), ().into_py(py)]),
            AzCssNthChildSelector::Odd => Ok(vec!["Odd".into_py(py), ().into_py(py)]),
            AzCssNthChildSelector::Pattern(v) => Ok(vec!["Pattern".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssNthChildSelectorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssNthChildSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssNthChildSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssNthChildPattern {
    #[new]
    fn __new__(repeat: u32, offset: u32) -> Self {
        Self {
            repeat,
            offset,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzCssNthChildPattern {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssNthChildPattern = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssNthChildPattern = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylesheet {
    #[new]
    fn __new__(rules: AzCssRuleBlockVec) -> Self {
        Self {
            rules,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStylesheet {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::Stylesheet = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::Stylesheet = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCss {
    #[staticmethod]
    fn empty() -> AzCss {
        unsafe { mem::transmute(crate::AzCss_empty()) }
    }
    #[staticmethod]
    fn from_string(s: String) -> AzCss {
        let s = pystring_to_azstring(&s);
        unsafe { mem::transmute(crate::AzCss_fromString(
            mem::transmute(s),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCss {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::Css = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::Css = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyTypeEnumWrapper {
    #[classattr]
    fn TextColor() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::TextColor } }
    #[classattr]
    fn FontSize() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::FontSize } }
    #[classattr]
    fn FontFamily() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::FontFamily } }
    #[classattr]
    fn TextAlign() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::TextAlign } }
    #[classattr]
    fn LetterSpacing() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::LetterSpacing } }
    #[classattr]
    fn LineHeight() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::LineHeight } }
    #[classattr]
    fn WordSpacing() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::WordSpacing } }
    #[classattr]
    fn TabWidth() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::TabWidth } }
    #[classattr]
    fn Cursor() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::Cursor } }
    #[classattr]
    fn Display() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::Display } }
    #[classattr]
    fn Float() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::Float } }
    #[classattr]
    fn BoxSizing() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BoxSizing } }
    #[classattr]
    fn Width() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::Width } }
    #[classattr]
    fn Height() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::Height } }
    #[classattr]
    fn MinWidth() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::MinWidth } }
    #[classattr]
    fn MinHeight() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::MinHeight } }
    #[classattr]
    fn MaxWidth() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::MaxWidth } }
    #[classattr]
    fn MaxHeight() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::MaxHeight } }
    #[classattr]
    fn Position() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::Position } }
    #[classattr]
    fn Top() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::Top } }
    #[classattr]
    fn Right() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::Right } }
    #[classattr]
    fn Left() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::Left } }
    #[classattr]
    fn Bottom() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::Bottom } }
    #[classattr]
    fn FlexWrap() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::FlexWrap } }
    #[classattr]
    fn FlexDirection() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::FlexDirection } }
    #[classattr]
    fn FlexGrow() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::FlexGrow } }
    #[classattr]
    fn FlexShrink() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::FlexShrink } }
    #[classattr]
    fn JustifyContent() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::JustifyContent } }
    #[classattr]
    fn AlignItems() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::AlignItems } }
    #[classattr]
    fn AlignContent() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::AlignContent } }
    #[classattr]
    fn BackgroundContent() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BackgroundContent } }
    #[classattr]
    fn BackgroundPosition() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BackgroundPosition } }
    #[classattr]
    fn BackgroundSize() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BackgroundSize } }
    #[classattr]
    fn BackgroundRepeat() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BackgroundRepeat } }
    #[classattr]
    fn OverflowX() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::OverflowX } }
    #[classattr]
    fn OverflowY() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::OverflowY } }
    #[classattr]
    fn PaddingTop() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::PaddingTop } }
    #[classattr]
    fn PaddingLeft() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::PaddingLeft } }
    #[classattr]
    fn PaddingRight() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::PaddingRight } }
    #[classattr]
    fn PaddingBottom() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::PaddingBottom } }
    #[classattr]
    fn MarginTop() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::MarginTop } }
    #[classattr]
    fn MarginLeft() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::MarginLeft } }
    #[classattr]
    fn MarginRight() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::MarginRight } }
    #[classattr]
    fn MarginBottom() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::MarginBottom } }
    #[classattr]
    fn BorderTopLeftRadius() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BorderTopLeftRadius } }
    #[classattr]
    fn BorderTopRightRadius() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BorderTopRightRadius } }
    #[classattr]
    fn BorderBottomLeftRadius() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BorderBottomLeftRadius } }
    #[classattr]
    fn BorderBottomRightRadius() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BorderBottomRightRadius } }
    #[classattr]
    fn BorderTopColor() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BorderTopColor } }
    #[classattr]
    fn BorderRightColor() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BorderRightColor } }
    #[classattr]
    fn BorderLeftColor() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BorderLeftColor } }
    #[classattr]
    fn BorderBottomColor() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BorderBottomColor } }
    #[classattr]
    fn BorderTopStyle() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BorderTopStyle } }
    #[classattr]
    fn BorderRightStyle() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BorderRightStyle } }
    #[classattr]
    fn BorderLeftStyle() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BorderLeftStyle } }
    #[classattr]
    fn BorderBottomStyle() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BorderBottomStyle } }
    #[classattr]
    fn BorderTopWidth() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BorderTopWidth } }
    #[classattr]
    fn BorderRightWidth() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BorderRightWidth } }
    #[classattr]
    fn BorderLeftWidth() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BorderLeftWidth } }
    #[classattr]
    fn BorderBottomWidth() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BorderBottomWidth } }
    #[classattr]
    fn BoxShadowLeft() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BoxShadowLeft } }
    #[classattr]
    fn BoxShadowRight() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BoxShadowRight } }
    #[classattr]
    fn BoxShadowTop() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BoxShadowTop } }
    #[classattr]
    fn BoxShadowBottom() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BoxShadowBottom } }
    #[classattr]
    fn ScrollbarStyle() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::ScrollbarStyle } }
    #[classattr]
    fn Opacity() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::Opacity } }
    #[classattr]
    fn Transform() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::Transform } }
    #[classattr]
    fn TransformOrigin() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::TransformOrigin } }
    #[classattr]
    fn PerspectiveOrigin() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::PerspectiveOrigin } }
    #[classattr]
    fn BackfaceVisibility() -> AzCssPropertyTypeEnumWrapper { AzCssPropertyTypeEnumWrapper { inner: AzCssPropertyType::BackfaceVisibility } }
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssPropertyType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssPropertyType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzCssPropertyTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAnimationInterpolationFunctionEnumWrapper {
    #[classattr]
    fn Ease() -> AzAnimationInterpolationFunctionEnumWrapper { AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::Ease } }
    #[classattr]
    fn Linear() -> AzAnimationInterpolationFunctionEnumWrapper { AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::Linear } }
    #[classattr]
    fn EaseIn() -> AzAnimationInterpolationFunctionEnumWrapper { AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::EaseIn } }
    #[classattr]
    fn EaseOut() -> AzAnimationInterpolationFunctionEnumWrapper { AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::EaseOut } }
    #[classattr]
    fn EaseInOut() -> AzAnimationInterpolationFunctionEnumWrapper { AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::EaseInOut } }
    #[staticmethod]
    fn CubicBezier(v: AzSvgCubicCurve) -> AzAnimationInterpolationFunctionEnumWrapper { AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::CubicBezier(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzAnimationInterpolationFunction;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAnimationInterpolationFunction::Ease => Ok(vec!["Ease".into_py(py), ().into_py(py)]),
            AzAnimationInterpolationFunction::Linear => Ok(vec!["Linear".into_py(py), ().into_py(py)]),
            AzAnimationInterpolationFunction::EaseIn => Ok(vec!["EaseIn".into_py(py), ().into_py(py)]),
            AzAnimationInterpolationFunction::EaseOut => Ok(vec!["EaseOut".into_py(py), ().into_py(py)]),
            AzAnimationInterpolationFunction::EaseInOut => Ok(vec!["EaseInOut".into_py(py), ().into_py(py)]),
            AzAnimationInterpolationFunction::CubicBezier(v) => Ok(vec!["CubicBezier".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAnimationInterpolationFunctionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::AnimationInterpolationFunction = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::AnimationInterpolationFunction = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInterpolateContext {
    #[new]
    fn __new__(animation_func: AzAnimationInterpolationFunctionEnumWrapper, parent_rect_width: f32, parent_rect_height: f32, current_rect_width: f32, current_rect_height: f32) -> Self {
        Self {
            animation_func,
            parent_rect_width,
            parent_rect_height,
            current_rect_width,
            current_rect_height,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInterpolateContext {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::InterpolateResolver = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::InterpolateResolver = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorU {
    #[staticmethod]
    fn from_str(string: String) -> AzColorU {
        let string = pystring_to_azstring(&string);
        unsafe { mem::transmute(crate::AzColorU_fromStr(
            mem::transmute(string),
        )) }
    }
    #[staticmethod]
    fn transparent() -> AzColorU {
        unsafe { mem::transmute(crate::AzColorU_transparent()) }
    }
    #[staticmethod]
    fn white() -> AzColorU {
        unsafe { mem::transmute(crate::AzColorU_white()) }
    }
    #[staticmethod]
    fn black() -> AzColorU {
        unsafe { mem::transmute(crate::AzColorU_black()) }
    }
    fn to_hash(&self) -> String {
        az_string_to_py_string(unsafe { mem::transmute(crate::AzColorU_toHash(
            mem::transmute(self),
        )) })
    }
}

#[pyproto]
impl PyObjectProtocol for AzColorU {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::ColorU = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::ColorU = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSizeMetricEnumWrapper {
    #[classattr]
    fn Px() -> AzSizeMetricEnumWrapper { AzSizeMetricEnumWrapper { inner: AzSizeMetric::Px } }
    #[classattr]
    fn Pt() -> AzSizeMetricEnumWrapper { AzSizeMetricEnumWrapper { inner: AzSizeMetric::Pt } }
    #[classattr]
    fn Em() -> AzSizeMetricEnumWrapper { AzSizeMetricEnumWrapper { inner: AzSizeMetric::Em } }
    #[classattr]
    fn Percent() -> AzSizeMetricEnumWrapper { AzSizeMetricEnumWrapper { inner: AzSizeMetric::Percent } }
}

#[pyproto]
impl PyObjectProtocol for AzSizeMetricEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::SizeMetric = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::SizeMetric = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzSizeMetricEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzFloatValue {
    #[new]
    fn __new__(number: isize) -> Self {
        Self {
            number,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzFloatValue {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::FloatValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::FloatValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPixelValue {
    #[new]
    fn __new__(metric: AzSizeMetricEnumWrapper, number: AzFloatValue) -> Self {
        Self {
            metric,
            number,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzPixelValue {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::PixelValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::PixelValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPixelValueNoPercent {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzPixelValueNoPercent {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::PixelValueNoPercent = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::PixelValueNoPercent = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBoxShadowClipModeEnumWrapper {
    #[classattr]
    fn Outset() -> AzBoxShadowClipModeEnumWrapper { AzBoxShadowClipModeEnumWrapper { inner: AzBoxShadowClipMode::Outset } }
    #[classattr]
    fn Inset() -> AzBoxShadowClipModeEnumWrapper { AzBoxShadowClipModeEnumWrapper { inner: AzBoxShadowClipMode::Inset } }
}

#[pyproto]
impl PyObjectProtocol for AzBoxShadowClipModeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::BoxShadowClipMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::BoxShadowClipMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzBoxShadowClipModeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleBoxShadow {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBoxShadow {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBoxShadow = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBoxShadow = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutAlignContentEnumWrapper {
    #[classattr]
    fn Stretch() -> AzLayoutAlignContentEnumWrapper { AzLayoutAlignContentEnumWrapper { inner: AzLayoutAlignContent::Stretch } }
    #[classattr]
    fn Center() -> AzLayoutAlignContentEnumWrapper { AzLayoutAlignContentEnumWrapper { inner: AzLayoutAlignContent::Center } }
    #[classattr]
    fn Start() -> AzLayoutAlignContentEnumWrapper { AzLayoutAlignContentEnumWrapper { inner: AzLayoutAlignContent::Start } }
    #[classattr]
    fn End() -> AzLayoutAlignContentEnumWrapper { AzLayoutAlignContentEnumWrapper { inner: AzLayoutAlignContent::End } }
    #[classattr]
    fn SpaceBetween() -> AzLayoutAlignContentEnumWrapper { AzLayoutAlignContentEnumWrapper { inner: AzLayoutAlignContent::SpaceBetween } }
    #[classattr]
    fn SpaceAround() -> AzLayoutAlignContentEnumWrapper { AzLayoutAlignContentEnumWrapper { inner: AzLayoutAlignContent::SpaceAround } }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutAlignContentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutAlignContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutAlignContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutAlignContentEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutAlignItemsEnumWrapper {
    #[classattr]
    fn Stretch() -> AzLayoutAlignItemsEnumWrapper { AzLayoutAlignItemsEnumWrapper { inner: AzLayoutAlignItems::Stretch } }
    #[classattr]
    fn Center() -> AzLayoutAlignItemsEnumWrapper { AzLayoutAlignItemsEnumWrapper { inner: AzLayoutAlignItems::Center } }
    #[classattr]
    fn FlexStart() -> AzLayoutAlignItemsEnumWrapper { AzLayoutAlignItemsEnumWrapper { inner: AzLayoutAlignItems::FlexStart } }
    #[classattr]
    fn FlexEnd() -> AzLayoutAlignItemsEnumWrapper { AzLayoutAlignItemsEnumWrapper { inner: AzLayoutAlignItems::FlexEnd } }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutAlignItemsEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutAlignItems = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutAlignItems = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutAlignItemsEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutBottom {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutBottom {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBoxSizingEnumWrapper {
    #[classattr]
    fn ContentBox() -> AzLayoutBoxSizingEnumWrapper { AzLayoutBoxSizingEnumWrapper { inner: AzLayoutBoxSizing::ContentBox } }
    #[classattr]
    fn BorderBox() -> AzLayoutBoxSizingEnumWrapper { AzLayoutBoxSizingEnumWrapper { inner: AzLayoutBoxSizing::BorderBox } }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBoxSizingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBoxSizing = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBoxSizing = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutBoxSizingEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutFlexDirectionEnumWrapper {
    #[classattr]
    fn Row() -> AzLayoutFlexDirectionEnumWrapper { AzLayoutFlexDirectionEnumWrapper { inner: AzLayoutFlexDirection::Row } }
    #[classattr]
    fn RowReverse() -> AzLayoutFlexDirectionEnumWrapper { AzLayoutFlexDirectionEnumWrapper { inner: AzLayoutFlexDirection::RowReverse } }
    #[classattr]
    fn Column() -> AzLayoutFlexDirectionEnumWrapper { AzLayoutFlexDirectionEnumWrapper { inner: AzLayoutFlexDirection::Column } }
    #[classattr]
    fn ColumnReverse() -> AzLayoutFlexDirectionEnumWrapper { AzLayoutFlexDirectionEnumWrapper { inner: AzLayoutFlexDirection::ColumnReverse } }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexDirectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFlexDirection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFlexDirection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutFlexDirectionEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutDisplayEnumWrapper {
    #[classattr]
    fn None() -> AzLayoutDisplayEnumWrapper { AzLayoutDisplayEnumWrapper { inner: AzLayoutDisplay::None } }
    #[classattr]
    fn Flex() -> AzLayoutDisplayEnumWrapper { AzLayoutDisplayEnumWrapper { inner: AzLayoutDisplay::Flex } }
    #[classattr]
    fn Block() -> AzLayoutDisplayEnumWrapper { AzLayoutDisplayEnumWrapper { inner: AzLayoutDisplay::Block } }
    #[classattr]
    fn InlineBlock() -> AzLayoutDisplayEnumWrapper { AzLayoutDisplayEnumWrapper { inner: AzLayoutDisplay::InlineBlock } }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutDisplayEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutDisplay = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutDisplay = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutDisplayEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutFlexGrow {
    #[new]
    fn __new__(inner: AzFloatValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexGrow {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFlexGrow = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFlexGrow = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexShrink {
    #[new]
    fn __new__(inner: AzFloatValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexShrink {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFlexShrink = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFlexShrink = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFloatEnumWrapper {
    #[classattr]
    fn Left() -> AzLayoutFloatEnumWrapper { AzLayoutFloatEnumWrapper { inner: AzLayoutFloat::Left } }
    #[classattr]
    fn Right() -> AzLayoutFloatEnumWrapper { AzLayoutFloatEnumWrapper { inner: AzLayoutFloat::Right } }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFloatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFloat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFloat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutFloatEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutHeight {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutHeight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutJustifyContentEnumWrapper {
    #[classattr]
    fn Start() -> AzLayoutJustifyContentEnumWrapper { AzLayoutJustifyContentEnumWrapper { inner: AzLayoutJustifyContent::Start } }
    #[classattr]
    fn End() -> AzLayoutJustifyContentEnumWrapper { AzLayoutJustifyContentEnumWrapper { inner: AzLayoutJustifyContent::End } }
    #[classattr]
    fn Center() -> AzLayoutJustifyContentEnumWrapper { AzLayoutJustifyContentEnumWrapper { inner: AzLayoutJustifyContent::Center } }
    #[classattr]
    fn SpaceBetween() -> AzLayoutJustifyContentEnumWrapper { AzLayoutJustifyContentEnumWrapper { inner: AzLayoutJustifyContent::SpaceBetween } }
    #[classattr]
    fn SpaceAround() -> AzLayoutJustifyContentEnumWrapper { AzLayoutJustifyContentEnumWrapper { inner: AzLayoutJustifyContent::SpaceAround } }
    #[classattr]
    fn SpaceEvenly() -> AzLayoutJustifyContentEnumWrapper { AzLayoutJustifyContentEnumWrapper { inner: AzLayoutJustifyContent::SpaceEvenly } }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutJustifyContentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutJustifyContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutJustifyContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutJustifyContentEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutLeft {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutLeft {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginBottom {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginBottom {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMarginBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMarginBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginLeft {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginLeft {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMarginLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMarginLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginRight {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginRight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMarginRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMarginRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginTop {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginTop {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMarginTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMarginTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMaxHeight {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutMaxHeight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMaxHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMaxHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMaxWidth {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutMaxWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMaxWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMaxWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMinHeight {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutMinHeight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMinHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMinHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMinWidth {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutMinWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMinWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMinWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingBottom {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingBottom {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPaddingBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPaddingBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingLeft {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingLeft {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPaddingLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPaddingLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingRight {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingRight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPaddingRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPaddingRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingTop {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingTop {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPaddingTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPaddingTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPositionEnumWrapper {
    #[classattr]
    fn Static() -> AzLayoutPositionEnumWrapper { AzLayoutPositionEnumWrapper { inner: AzLayoutPosition::Static } }
    #[classattr]
    fn Relative() -> AzLayoutPositionEnumWrapper { AzLayoutPositionEnumWrapper { inner: AzLayoutPosition::Relative } }
    #[classattr]
    fn Absolute() -> AzLayoutPositionEnumWrapper { AzLayoutPositionEnumWrapper { inner: AzLayoutPosition::Absolute } }
    #[classattr]
    fn Fixed() -> AzLayoutPositionEnumWrapper { AzLayoutPositionEnumWrapper { inner: AzLayoutPosition::Fixed } }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutPositionEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutRight {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutRight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutTop {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutTop {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutWidth {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexWrapEnumWrapper {
    #[classattr]
    fn Wrap() -> AzLayoutFlexWrapEnumWrapper { AzLayoutFlexWrapEnumWrapper { inner: AzLayoutFlexWrap::Wrap } }
    #[classattr]
    fn NoWrap() -> AzLayoutFlexWrapEnumWrapper { AzLayoutFlexWrapEnumWrapper { inner: AzLayoutFlexWrap::NoWrap } }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexWrapEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFlexWrap = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFlexWrap = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutFlexWrapEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutOverflowEnumWrapper {
    #[classattr]
    fn Scroll() -> AzLayoutOverflowEnumWrapper { AzLayoutOverflowEnumWrapper { inner: AzLayoutOverflow::Scroll } }
    #[classattr]
    fn Auto() -> AzLayoutOverflowEnumWrapper { AzLayoutOverflowEnumWrapper { inner: AzLayoutOverflow::Auto } }
    #[classattr]
    fn Hidden() -> AzLayoutOverflowEnumWrapper { AzLayoutOverflowEnumWrapper { inner: AzLayoutOverflow::Hidden } }
    #[classattr]
    fn Visible() -> AzLayoutOverflowEnumWrapper { AzLayoutOverflowEnumWrapper { inner: AzLayoutOverflow::Visible } }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutOverflowEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutOverflow = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutOverflow = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutOverflowEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzPercentageValue {
    #[new]
    fn __new__(number: AzFloatValue) -> Self {
        Self {
            number,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzPercentageValue {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::PercentageValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::PercentageValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAngleMetricEnumWrapper {
    #[classattr]
    fn Degree() -> AzAngleMetricEnumWrapper { AzAngleMetricEnumWrapper { inner: AzAngleMetric::Degree } }
    #[classattr]
    fn Radians() -> AzAngleMetricEnumWrapper { AzAngleMetricEnumWrapper { inner: AzAngleMetric::Radians } }
    #[classattr]
    fn Grad() -> AzAngleMetricEnumWrapper { AzAngleMetricEnumWrapper { inner: AzAngleMetric::Grad } }
    #[classattr]
    fn Turn() -> AzAngleMetricEnumWrapper { AzAngleMetricEnumWrapper { inner: AzAngleMetric::Turn } }
    #[classattr]
    fn Percent() -> AzAngleMetricEnumWrapper { AzAngleMetricEnumWrapper { inner: AzAngleMetric::Percent } }
}

#[pyproto]
impl PyObjectProtocol for AzAngleMetricEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::AngleMetric = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::AngleMetric = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAngleMetricEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAngleValue {
    #[new]
    fn __new__(metric: AzAngleMetricEnumWrapper, number: AzFloatValue) -> Self {
        Self {
            metric,
            number,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzAngleValue {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::AngleValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::AngleValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedLinearColorStop {
    #[new]
    fn __new__(offset: AzPercentageValue, color: AzColorU) -> Self {
        Self {
            offset,
            color,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNormalizedLinearColorStop {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::NormalizedLinearColorStop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::NormalizedLinearColorStop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedRadialColorStop {
    #[new]
    fn __new__(offset: AzAngleValue, color: AzColorU) -> Self {
        Self {
            offset,
            color,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNormalizedRadialColorStop {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::NormalizedRadialColorStop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::NormalizedRadialColorStop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDirectionCornerEnumWrapper {
    #[classattr]
    fn Right() -> AzDirectionCornerEnumWrapper { AzDirectionCornerEnumWrapper { inner: AzDirectionCorner::Right } }
    #[classattr]
    fn Left() -> AzDirectionCornerEnumWrapper { AzDirectionCornerEnumWrapper { inner: AzDirectionCorner::Left } }
    #[classattr]
    fn Top() -> AzDirectionCornerEnumWrapper { AzDirectionCornerEnumWrapper { inner: AzDirectionCorner::Top } }
    #[classattr]
    fn Bottom() -> AzDirectionCornerEnumWrapper { AzDirectionCornerEnumWrapper { inner: AzDirectionCorner::Bottom } }
    #[classattr]
    fn TopRight() -> AzDirectionCornerEnumWrapper { AzDirectionCornerEnumWrapper { inner: AzDirectionCorner::TopRight } }
    #[classattr]
    fn TopLeft() -> AzDirectionCornerEnumWrapper { AzDirectionCornerEnumWrapper { inner: AzDirectionCorner::TopLeft } }
    #[classattr]
    fn BottomRight() -> AzDirectionCornerEnumWrapper { AzDirectionCornerEnumWrapper { inner: AzDirectionCorner::BottomRight } }
    #[classattr]
    fn BottomLeft() -> AzDirectionCornerEnumWrapper { AzDirectionCornerEnumWrapper { inner: AzDirectionCorner::BottomLeft } }
}

#[pyproto]
impl PyObjectProtocol for AzDirectionCornerEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::DirectionCorner = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::DirectionCorner = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzDirectionCornerEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzDirectionCorners {
    #[new]
    fn __new__(from: AzDirectionCornerEnumWrapper, to: AzDirectionCornerEnumWrapper) -> Self {
        Self {
            from,
            to,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzDirectionCorners {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::DirectionCorners = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::DirectionCorners = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDirectionEnumWrapper {
    #[staticmethod]
    fn Angle(v: AzAngleValue) -> AzDirectionEnumWrapper { AzDirectionEnumWrapper { inner: AzDirection::Angle(v) } }
    #[staticmethod]
    fn FromTo(v: AzDirectionCorners) -> AzDirectionEnumWrapper { AzDirectionEnumWrapper { inner: AzDirection::FromTo(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzDirection;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzDirection::Angle(v) => Ok(vec!["Angle".into_py(py), v.clone().into_py(py)]),
            AzDirection::FromTo(v) => Ok(vec!["FromTo".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDirectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::Direction = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::Direction = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzExtendModeEnumWrapper {
    #[classattr]
    fn Clamp() -> AzExtendModeEnumWrapper { AzExtendModeEnumWrapper { inner: AzExtendMode::Clamp } }
    #[classattr]
    fn Repeat() -> AzExtendModeEnumWrapper { AzExtendModeEnumWrapper { inner: AzExtendMode::Repeat } }
}

#[pyproto]
impl PyObjectProtocol for AzExtendModeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::ExtendMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::ExtendMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzExtendModeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLinearGradient {
    #[new]
    fn __new__(direction: AzDirectionEnumWrapper, extend_mode: AzExtendModeEnumWrapper, stops: AzNormalizedLinearColorStopVec) -> Self {
        Self {
            direction,
            extend_mode,
            stops,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLinearGradient {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LinearGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LinearGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapeEnumWrapper {
    #[classattr]
    fn Ellipse() -> AzShapeEnumWrapper { AzShapeEnumWrapper { inner: AzShape::Ellipse } }
    #[classattr]
    fn Circle() -> AzShapeEnumWrapper { AzShapeEnumWrapper { inner: AzShape::Circle } }
}

#[pyproto]
impl PyObjectProtocol for AzShapeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::Shape = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::Shape = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzShapeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzRadialGradientSizeEnumWrapper {
    #[classattr]
    fn ClosestSide() -> AzRadialGradientSizeEnumWrapper { AzRadialGradientSizeEnumWrapper { inner: AzRadialGradientSize::ClosestSide } }
    #[classattr]
    fn ClosestCorner() -> AzRadialGradientSizeEnumWrapper { AzRadialGradientSizeEnumWrapper { inner: AzRadialGradientSize::ClosestCorner } }
    #[classattr]
    fn FarthestSide() -> AzRadialGradientSizeEnumWrapper { AzRadialGradientSizeEnumWrapper { inner: AzRadialGradientSize::FarthestSide } }
    #[classattr]
    fn FarthestCorner() -> AzRadialGradientSizeEnumWrapper { AzRadialGradientSizeEnumWrapper { inner: AzRadialGradientSize::FarthestCorner } }
}

#[pyproto]
impl PyObjectProtocol for AzRadialGradientSizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::RadialGradientSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::RadialGradientSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzRadialGradientSizeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzRadialGradient {
    #[new]
    fn __new__(shape: AzShapeEnumWrapper, size: AzRadialGradientSizeEnumWrapper, position: AzStyleBackgroundPosition, extend_mode: AzExtendModeEnumWrapper, stops: AzNormalizedLinearColorStopVec) -> Self {
        Self {
            shape,
            size,
            position,
            extend_mode,
            stops,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzRadialGradient {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::RadialGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::RadialGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzConicGradient {
    #[new]
    fn __new__(extend_mode: AzExtendModeEnumWrapper, center: AzStyleBackgroundPosition, angle: AzAngleValue, stops: AzNormalizedRadialColorStopVec) -> Self {
        Self {
            extend_mode,
            center,
            angle,
            stops,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzConicGradient {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::ConicGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::ConicGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundContentEnumWrapper {
    #[staticmethod]
    fn LinearGradient(v: AzLinearGradient) -> AzStyleBackgroundContentEnumWrapper { AzStyleBackgroundContentEnumWrapper { inner: AzStyleBackgroundContent::LinearGradient(v) } }
    #[staticmethod]
    fn RadialGradient(v: AzRadialGradient) -> AzStyleBackgroundContentEnumWrapper { AzStyleBackgroundContentEnumWrapper { inner: AzStyleBackgroundContent::RadialGradient(v) } }
    #[staticmethod]
    fn ConicGradient(v: AzConicGradient) -> AzStyleBackgroundContentEnumWrapper { AzStyleBackgroundContentEnumWrapper { inner: AzStyleBackgroundContent::ConicGradient(v) } }
    #[staticmethod]
    fn Image(v: AzString) -> AzStyleBackgroundContentEnumWrapper { AzStyleBackgroundContentEnumWrapper { inner: AzStyleBackgroundContent::Image(v) } }
    #[staticmethod]
    fn Color(v: AzColorU) -> AzStyleBackgroundContentEnumWrapper { AzStyleBackgroundContentEnumWrapper { inner: AzStyleBackgroundContent::Color(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundContent;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundContent::LinearGradient(v) => Ok(vec!["LinearGradient".into_py(py), v.clone().into_py(py)]),
            AzStyleBackgroundContent::RadialGradient(v) => Ok(vec!["RadialGradient".into_py(py), v.clone().into_py(py)]),
            AzStyleBackgroundContent::ConicGradient(v) => Ok(vec!["ConicGradient".into_py(py), v.clone().into_py(py)]),
            AzStyleBackgroundContent::Image(v) => Ok(vec!["Image".into_py(py), v.clone().into_py(py)]),
            AzStyleBackgroundContent::Color(v) => Ok(vec!["Color".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundContentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBackgroundPositionHorizontalEnumWrapper {
    #[classattr]
    fn Left() -> AzBackgroundPositionHorizontalEnumWrapper { AzBackgroundPositionHorizontalEnumWrapper { inner: AzBackgroundPositionHorizontal::Left } }
    #[classattr]
    fn Center() -> AzBackgroundPositionHorizontalEnumWrapper { AzBackgroundPositionHorizontalEnumWrapper { inner: AzBackgroundPositionHorizontal::Center } }
    #[classattr]
    fn Right() -> AzBackgroundPositionHorizontalEnumWrapper { AzBackgroundPositionHorizontalEnumWrapper { inner: AzBackgroundPositionHorizontal::Right } }
    #[staticmethod]
    fn Exact(v: AzPixelValue) -> AzBackgroundPositionHorizontalEnumWrapper { AzBackgroundPositionHorizontalEnumWrapper { inner: AzBackgroundPositionHorizontal::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzBackgroundPositionHorizontal;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzBackgroundPositionHorizontal::Left => Ok(vec!["Left".into_py(py), ().into_py(py)]),
            AzBackgroundPositionHorizontal::Center => Ok(vec!["Center".into_py(py), ().into_py(py)]),
            AzBackgroundPositionHorizontal::Right => Ok(vec!["Right".into_py(py), ().into_py(py)]),
            AzBackgroundPositionHorizontal::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzBackgroundPositionHorizontalEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::BackgroundPositionHorizontal = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::BackgroundPositionHorizontal = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBackgroundPositionVerticalEnumWrapper {
    #[classattr]
    fn Top() -> AzBackgroundPositionVerticalEnumWrapper { AzBackgroundPositionVerticalEnumWrapper { inner: AzBackgroundPositionVertical::Top } }
    #[classattr]
    fn Center() -> AzBackgroundPositionVerticalEnumWrapper { AzBackgroundPositionVerticalEnumWrapper { inner: AzBackgroundPositionVertical::Center } }
    #[classattr]
    fn Bottom() -> AzBackgroundPositionVerticalEnumWrapper { AzBackgroundPositionVerticalEnumWrapper { inner: AzBackgroundPositionVertical::Bottom } }
    #[staticmethod]
    fn Exact(v: AzPixelValue) -> AzBackgroundPositionVerticalEnumWrapper { AzBackgroundPositionVerticalEnumWrapper { inner: AzBackgroundPositionVertical::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzBackgroundPositionVertical;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzBackgroundPositionVertical::Top => Ok(vec!["Top".into_py(py), ().into_py(py)]),
            AzBackgroundPositionVertical::Center => Ok(vec!["Center".into_py(py), ().into_py(py)]),
            AzBackgroundPositionVertical::Bottom => Ok(vec!["Bottom".into_py(py), ().into_py(py)]),
            AzBackgroundPositionVertical::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzBackgroundPositionVerticalEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::BackgroundPositionVertical = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::BackgroundPositionVertical = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundPosition {
    #[new]
    fn __new__(horizontal: AzBackgroundPositionHorizontalEnumWrapper, vertical: AzBackgroundPositionVerticalEnumWrapper) -> Self {
        Self {
            horizontal,
            vertical,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundPosition {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundPosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundPosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundRepeatEnumWrapper {
    #[classattr]
    fn NoRepeat() -> AzStyleBackgroundRepeatEnumWrapper { AzStyleBackgroundRepeatEnumWrapper { inner: AzStyleBackgroundRepeat::NoRepeat } }
    #[classattr]
    fn Repeat() -> AzStyleBackgroundRepeatEnumWrapper { AzStyleBackgroundRepeatEnumWrapper { inner: AzStyleBackgroundRepeat::Repeat } }
    #[classattr]
    fn RepeatX() -> AzStyleBackgroundRepeatEnumWrapper { AzStyleBackgroundRepeatEnumWrapper { inner: AzStyleBackgroundRepeat::RepeatX } }
    #[classattr]
    fn RepeatY() -> AzStyleBackgroundRepeatEnumWrapper { AzStyleBackgroundRepeatEnumWrapper { inner: AzStyleBackgroundRepeat::RepeatY } }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundRepeatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundRepeat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundRepeat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleBackgroundRepeatEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleBackgroundSizeEnumWrapper {
    #[classattr]
    fn Contain() -> AzStyleBackgroundSizeEnumWrapper { AzStyleBackgroundSizeEnumWrapper { inner: AzStyleBackgroundSize::Contain } }
    #[classattr]
    fn Cover() -> AzStyleBackgroundSizeEnumWrapper { AzStyleBackgroundSizeEnumWrapper { inner: AzStyleBackgroundSize::Cover } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundSize;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundSize::ExactSize(v) => Ok(vec!["ExactSize".into_py(py), v.to_vec().into_py(py)]),
            AzStyleBackgroundSize::Contain => Ok(vec!["Contain".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSize::Cover => Ok(vec!["Cover".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundSizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomColor {
    #[new]
    fn __new__(inner: AzColorU) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderBottomColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderBottomColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomLeftRadius {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomLeftRadius {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderBottomLeftRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderBottomLeftRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomRightRadius {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomRightRadius {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderBottomRightRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderBottomRightRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBorderStyleEnumWrapper {
    #[classattr]
    fn None() -> AzBorderStyleEnumWrapper { AzBorderStyleEnumWrapper { inner: AzBorderStyle::None } }
    #[classattr]
    fn Solid() -> AzBorderStyleEnumWrapper { AzBorderStyleEnumWrapper { inner: AzBorderStyle::Solid } }
    #[classattr]
    fn Double() -> AzBorderStyleEnumWrapper { AzBorderStyleEnumWrapper { inner: AzBorderStyle::Double } }
    #[classattr]
    fn Dotted() -> AzBorderStyleEnumWrapper { AzBorderStyleEnumWrapper { inner: AzBorderStyle::Dotted } }
    #[classattr]
    fn Dashed() -> AzBorderStyleEnumWrapper { AzBorderStyleEnumWrapper { inner: AzBorderStyle::Dashed } }
    #[classattr]
    fn Hidden() -> AzBorderStyleEnumWrapper { AzBorderStyleEnumWrapper { inner: AzBorderStyle::Hidden } }
    #[classattr]
    fn Groove() -> AzBorderStyleEnumWrapper { AzBorderStyleEnumWrapper { inner: AzBorderStyle::Groove } }
    #[classattr]
    fn Ridge() -> AzBorderStyleEnumWrapper { AzBorderStyleEnumWrapper { inner: AzBorderStyle::Ridge } }
    #[classattr]
    fn Inset() -> AzBorderStyleEnumWrapper { AzBorderStyleEnumWrapper { inner: AzBorderStyle::Inset } }
    #[classattr]
    fn Outset() -> AzBorderStyleEnumWrapper { AzBorderStyleEnumWrapper { inner: AzBorderStyle::Outset } }
}

#[pyproto]
impl PyObjectProtocol for AzBorderStyleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::BorderStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::BorderStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzBorderStyleEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleBorderBottomStyle {
    #[new]
    fn __new__(inner: AzBorderStyleEnumWrapper) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderBottomStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderBottomStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderBottomWidth {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderBottomWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBorderBottomWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBorderBottomWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderLeftColor {
    #[new]
    fn __new__(inner: AzColorU) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderLeftColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderLeftColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderLeftColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderLeftStyle {
    #[new]
    fn __new__(inner: AzBorderStyleEnumWrapper) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderLeftStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderLeftStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderLeftStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderLeftWidth {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderLeftWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBorderLeftWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBorderLeftWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderRightColor {
    #[new]
    fn __new__(inner: AzColorU) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderRightColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderRightColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderRightColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderRightStyle {
    #[new]
    fn __new__(inner: AzBorderStyleEnumWrapper) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderRightStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderRightStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderRightStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderRightWidth {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderRightWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBorderRightWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBorderRightWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopColor {
    #[new]
    fn __new__(inner: AzColorU) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderTopColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderTopColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopLeftRadius {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopLeftRadius {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderTopLeftRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderTopLeftRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopRightRadius {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopRightRadius {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderTopRightRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderTopRightRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopStyle {
    #[new]
    fn __new__(inner: AzBorderStyleEnumWrapper) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderTopStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderTopStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderTopWidth {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderTopWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBorderTopWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBorderTopWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScrollbarInfo {
    #[new]
    fn __new__(width: AzLayoutWidth, padding_left: AzLayoutPaddingLeft, padding_right: AzLayoutPaddingRight, track: AzStyleBackgroundContentEnumWrapper, thumb: AzStyleBackgroundContentEnumWrapper, button: AzStyleBackgroundContentEnumWrapper, corner: AzStyleBackgroundContentEnumWrapper, resizer: AzStyleBackgroundContentEnumWrapper) -> Self {
        Self {
            width,
            padding_left,
            padding_right,
            track,
            thumb,
            button,
            corner,
            resizer,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzScrollbarInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::ScrollbarInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::ScrollbarInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScrollbarStyle {
    #[new]
    fn __new__(horizontal: AzScrollbarInfo, vertical: AzScrollbarInfo) -> Self {
        Self {
            horizontal,
            vertical,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzScrollbarStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::ScrollbarStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::ScrollbarStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleCursorEnumWrapper {
    #[classattr]
    fn Alias() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::Alias } }
    #[classattr]
    fn AllScroll() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::AllScroll } }
    #[classattr]
    fn Cell() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::Cell } }
    #[classattr]
    fn ColResize() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::ColResize } }
    #[classattr]
    fn ContextMenu() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::ContextMenu } }
    #[classattr]
    fn Copy() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::Copy } }
    #[classattr]
    fn Crosshair() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::Crosshair } }
    #[classattr]
    fn Default() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::Default } }
    #[classattr]
    fn EResize() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::EResize } }
    #[classattr]
    fn EwResize() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::EwResize } }
    #[classattr]
    fn Grab() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::Grab } }
    #[classattr]
    fn Grabbing() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::Grabbing } }
    #[classattr]
    fn Help() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::Help } }
    #[classattr]
    fn Move() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::Move } }
    #[classattr]
    fn NResize() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::NResize } }
    #[classattr]
    fn NsResize() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::NsResize } }
    #[classattr]
    fn NeswResize() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::NeswResize } }
    #[classattr]
    fn NwseResize() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::NwseResize } }
    #[classattr]
    fn Pointer() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::Pointer } }
    #[classattr]
    fn Progress() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::Progress } }
    #[classattr]
    fn RowResize() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::RowResize } }
    #[classattr]
    fn SResize() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::SResize } }
    #[classattr]
    fn SeResize() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::SeResize } }
    #[classattr]
    fn Text() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::Text } }
    #[classattr]
    fn Unset() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::Unset } }
    #[classattr]
    fn VerticalText() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::VerticalText } }
    #[classattr]
    fn WResize() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::WResize } }
    #[classattr]
    fn Wait() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::Wait } }
    #[classattr]
    fn ZoomIn() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::ZoomIn } }
    #[classattr]
    fn ZoomOut() -> AzStyleCursorEnumWrapper { AzStyleCursorEnumWrapper { inner: AzStyleCursor::ZoomOut } }
}

#[pyproto]
impl PyObjectProtocol for AzStyleCursorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleCursor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleCursor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleCursorEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleFontFamilyEnumWrapper {
    #[staticmethod]
    fn System(v: AzString) -> AzStyleFontFamilyEnumWrapper { AzStyleFontFamilyEnumWrapper { inner: AzStyleFontFamily::System(v) } }
    #[staticmethod]
    fn File(v: AzString) -> AzStyleFontFamilyEnumWrapper { AzStyleFontFamilyEnumWrapper { inner: AzStyleFontFamily::File(v) } }
    #[staticmethod]
    fn Ref(v: AzFontRef) -> AzStyleFontFamilyEnumWrapper { AzStyleFontFamilyEnumWrapper { inner: AzStyleFontFamily::Ref(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleFontFamily;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFontFamily::System(v) => Ok(vec!["System".into_py(py), v.clone().into_py(py)]),
            AzStyleFontFamily::File(v) => Ok(vec!["File".into_py(py), v.clone().into_py(py)]),
            AzStyleFontFamily::Ref(v) => Ok(vec!["Ref".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontFamilyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleFontFamily = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleFontFamily = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontSize {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleFontSize {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleFontSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleFontSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleLetterSpacing {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleLetterSpacing {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleLetterSpacing = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleLetterSpacing = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleLineHeight {
    #[new]
    fn __new__(inner: AzPercentageValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleLineHeight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleLineHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleLineHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTabWidth {
    #[new]
    fn __new__(inner: AzPercentageValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleTabWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTabWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTabWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleOpacity {
    #[new]
    fn __new__(inner: AzPercentageValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleOpacity {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleOpacity = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleOpacity = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformOrigin {
    #[new]
    fn __new__(x: AzPixelValue, y: AzPixelValue) -> Self {
        Self {
            x,
            y,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformOrigin {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformOrigin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformOrigin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylePerspectiveOrigin {
    #[new]
    fn __new__(x: AzPixelValue, y: AzPixelValue) -> Self {
        Self {
            x,
            y,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStylePerspectiveOrigin {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformOrigin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformOrigin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackfaceVisibilityEnumWrapper {
    #[classattr]
    fn Hidden() -> AzStyleBackfaceVisibilityEnumWrapper { AzStyleBackfaceVisibilityEnumWrapper { inner: AzStyleBackfaceVisibility::Hidden } }
    #[classattr]
    fn Visible() -> AzStyleBackfaceVisibilityEnumWrapper { AzStyleBackfaceVisibilityEnumWrapper { inner: AzStyleBackfaceVisibility::Visible } }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackfaceVisibilityEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackfaceVisibility = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackfaceVisibility = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleBackfaceVisibilityEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleTransformEnumWrapper {
    #[staticmethod]
    fn Matrix(v: AzStyleTransformMatrix2D) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::Matrix(v) } }
    #[staticmethod]
    fn Matrix3D(v: AzStyleTransformMatrix3D) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::Matrix3D(v) } }
    #[staticmethod]
    fn Translate(v: AzStyleTransformTranslate2D) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::Translate(v) } }
    #[staticmethod]
    fn Translate3D(v: AzStyleTransformTranslate3D) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::Translate3D(v) } }
    #[staticmethod]
    fn TranslateX(v: AzPixelValue) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::TranslateX(v) } }
    #[staticmethod]
    fn TranslateY(v: AzPixelValue) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::TranslateY(v) } }
    #[staticmethod]
    fn TranslateZ(v: AzPixelValue) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::TranslateZ(v) } }
    #[staticmethod]
    fn Rotate(v: AzAngleValue) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::Rotate(v) } }
    #[staticmethod]
    fn Rotate3D(v: AzStyleTransformRotate3D) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::Rotate3D(v) } }
    #[staticmethod]
    fn RotateX(v: AzAngleValue) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::RotateX(v) } }
    #[staticmethod]
    fn RotateY(v: AzAngleValue) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::RotateY(v) } }
    #[staticmethod]
    fn RotateZ(v: AzAngleValue) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::RotateZ(v) } }
    #[staticmethod]
    fn Scale(v: AzStyleTransformScale2D) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::Scale(v) } }
    #[staticmethod]
    fn Scale3D(v: AzStyleTransformScale3D) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::Scale3D(v) } }
    #[staticmethod]
    fn ScaleX(v: AzPercentageValue) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::ScaleX(v) } }
    #[staticmethod]
    fn ScaleY(v: AzPercentageValue) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::ScaleY(v) } }
    #[staticmethod]
    fn ScaleZ(v: AzPercentageValue) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::ScaleZ(v) } }
    #[staticmethod]
    fn Skew(v: AzStyleTransformSkew2D) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::Skew(v) } }
    #[staticmethod]
    fn SkewX(v: AzPercentageValue) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::SkewX(v) } }
    #[staticmethod]
    fn SkewY(v: AzPercentageValue) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::SkewY(v) } }
    #[staticmethod]
    fn Perspective(v: AzPixelValue) -> AzStyleTransformEnumWrapper { AzStyleTransformEnumWrapper { inner: AzStyleTransform::Perspective(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTransform;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTransform::Matrix(v) => Ok(vec!["Matrix".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::Matrix3D(v) => Ok(vec!["Matrix3D".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::Translate(v) => Ok(vec!["Translate".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::Translate3D(v) => Ok(vec!["Translate3D".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::TranslateX(v) => Ok(vec!["TranslateX".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::TranslateY(v) => Ok(vec!["TranslateY".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::TranslateZ(v) => Ok(vec!["TranslateZ".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::Rotate(v) => Ok(vec!["Rotate".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::Rotate3D(v) => Ok(vec!["Rotate3D".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::RotateX(v) => Ok(vec!["RotateX".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::RotateY(v) => Ok(vec!["RotateY".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::RotateZ(v) => Ok(vec!["RotateZ".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::Scale(v) => Ok(vec!["Scale".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::Scale3D(v) => Ok(vec!["Scale3D".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::ScaleX(v) => Ok(vec!["ScaleX".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::ScaleY(v) => Ok(vec!["ScaleY".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::ScaleZ(v) => Ok(vec!["ScaleZ".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::Skew(v) => Ok(vec!["Skew".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::SkewX(v) => Ok(vec!["SkewX".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::SkewY(v) => Ok(vec!["SkewY".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::Perspective(v) => Ok(vec!["Perspective".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransform = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransform = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformMatrix2D {
    #[new]
    fn __new__(a: AzPixelValue, b: AzPixelValue, c: AzPixelValue, d: AzPixelValue, tx: AzPixelValue, ty: AzPixelValue) -> Self {
        Self {
            a,
            b,
            c,
            d,
            tx,
            ty,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformMatrix2D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformMatrix2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformMatrix2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformMatrix3D {
    #[new]
    fn __new__(m11: AzPixelValue, m12: AzPixelValue, m13: AzPixelValue, m14: AzPixelValue, m21: AzPixelValue, m22: AzPixelValue, m23: AzPixelValue, m24: AzPixelValue, m31: AzPixelValue, m32: AzPixelValue, m33: AzPixelValue, m34: AzPixelValue, m41: AzPixelValue, m42: AzPixelValue, m43: AzPixelValue, m44: AzPixelValue) -> Self {
        Self {
            m11,
            m12,
            m13,
            m14,
            m21,
            m22,
            m23,
            m24,
            m31,
            m32,
            m33,
            m34,
            m41,
            m42,
            m43,
            m44,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformMatrix3D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformMatrix3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformMatrix3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformTranslate2D {
    #[new]
    fn __new__(x: AzPixelValue, y: AzPixelValue) -> Self {
        Self {
            x,
            y,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformTranslate2D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformTranslate2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformTranslate2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformTranslate3D {
    #[new]
    fn __new__(x: AzPixelValue, y: AzPixelValue, z: AzPixelValue) -> Self {
        Self {
            x,
            y,
            z,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformTranslate3D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformTranslate3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformTranslate3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformRotate3D {
    #[new]
    fn __new__(x: AzPercentageValue, y: AzPercentageValue, z: AzPercentageValue, angle: AzAngleValue) -> Self {
        Self {
            x,
            y,
            z,
            angle,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformRotate3D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformRotate3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformRotate3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformScale2D {
    #[new]
    fn __new__(x: AzPercentageValue, y: AzPercentageValue) -> Self {
        Self {
            x,
            y,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformScale2D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformScale2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformScale2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformScale3D {
    #[new]
    fn __new__(x: AzPercentageValue, y: AzPercentageValue, z: AzPercentageValue) -> Self {
        Self {
            x,
            y,
            z,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformScale3D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformScale3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformScale3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformSkew2D {
    #[new]
    fn __new__(x: AzPercentageValue, y: AzPercentageValue) -> Self {
        Self {
            x,
            y,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformSkew2D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformSkew2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformSkew2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTextAlignEnumWrapper {
    #[classattr]
    fn Left() -> AzStyleTextAlignEnumWrapper { AzStyleTextAlignEnumWrapper { inner: AzStyleTextAlign::Left } }
    #[classattr]
    fn Center() -> AzStyleTextAlignEnumWrapper { AzStyleTextAlignEnumWrapper { inner: AzStyleTextAlign::Center } }
    #[classattr]
    fn Right() -> AzStyleTextAlignEnumWrapper { AzStyleTextAlignEnumWrapper { inner: AzStyleTextAlign::Right } }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextAlignEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTextAlign = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTextAlign = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleTextAlignEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleTextColor {
    #[new]
    fn __new__(inner: AzColorU) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleTextColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTextColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTextColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleWordSpacing {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleWordSpacing {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleWordSpacing = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleWordSpacing = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBoxShadowValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBoxShadowValueEnumWrapper { AzStyleBoxShadowValueEnumWrapper { inner: AzStyleBoxShadowValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBoxShadowValueEnumWrapper { AzStyleBoxShadowValueEnumWrapper { inner: AzStyleBoxShadowValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBoxShadowValueEnumWrapper { AzStyleBoxShadowValueEnumWrapper { inner: AzStyleBoxShadowValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBoxShadowValueEnumWrapper { AzStyleBoxShadowValueEnumWrapper { inner: AzStyleBoxShadowValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBoxShadow) -> AzStyleBoxShadowValueEnumWrapper { AzStyleBoxShadowValueEnumWrapper { inner: AzStyleBoxShadowValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBoxShadowValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBoxShadowValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBoxShadowValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBoxShadowValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBoxShadowValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBoxShadowValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBoxShadowValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBoxShadowValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBoxShadowValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutAlignContentValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutAlignContentValueEnumWrapper { AzLayoutAlignContentValueEnumWrapper { inner: AzLayoutAlignContentValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutAlignContentValueEnumWrapper { AzLayoutAlignContentValueEnumWrapper { inner: AzLayoutAlignContentValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutAlignContentValueEnumWrapper { AzLayoutAlignContentValueEnumWrapper { inner: AzLayoutAlignContentValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutAlignContentValueEnumWrapper { AzLayoutAlignContentValueEnumWrapper { inner: AzLayoutAlignContentValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutAlignContentEnumWrapper) -> AzLayoutAlignContentValueEnumWrapper { AzLayoutAlignContentValueEnumWrapper { inner: AzLayoutAlignContentValue::Exact(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutAlignContentValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutAlignContentValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutAlignContentValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutAlignContentValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutAlignContentValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutAlignContentValue::Exact(v) => Ok(vec!["Exact".into_py(py), { let m: &AzLayoutAlignContentEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutAlignContentValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutAlignContentValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutAlignContentValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutAlignItemsValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutAlignItemsValueEnumWrapper { AzLayoutAlignItemsValueEnumWrapper { inner: AzLayoutAlignItemsValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutAlignItemsValueEnumWrapper { AzLayoutAlignItemsValueEnumWrapper { inner: AzLayoutAlignItemsValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutAlignItemsValueEnumWrapper { AzLayoutAlignItemsValueEnumWrapper { inner: AzLayoutAlignItemsValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutAlignItemsValueEnumWrapper { AzLayoutAlignItemsValueEnumWrapper { inner: AzLayoutAlignItemsValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutAlignItemsEnumWrapper) -> AzLayoutAlignItemsValueEnumWrapper { AzLayoutAlignItemsValueEnumWrapper { inner: AzLayoutAlignItemsValue::Exact(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutAlignItemsValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutAlignItemsValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutAlignItemsValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutAlignItemsValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutAlignItemsValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutAlignItemsValue::Exact(v) => Ok(vec!["Exact".into_py(py), { let m: &AzLayoutAlignItemsEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutAlignItemsValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutAlignItemsValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutAlignItemsValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBottomValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBottomValueEnumWrapper { AzLayoutBottomValueEnumWrapper { inner: AzLayoutBottomValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutBottomValueEnumWrapper { AzLayoutBottomValueEnumWrapper { inner: AzLayoutBottomValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutBottomValueEnumWrapper { AzLayoutBottomValueEnumWrapper { inner: AzLayoutBottomValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutBottomValueEnumWrapper { AzLayoutBottomValueEnumWrapper { inner: AzLayoutBottomValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutBottom) -> AzLayoutBottomValueEnumWrapper { AzLayoutBottomValueEnumWrapper { inner: AzLayoutBottomValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutBottomValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBottomValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBottomValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBottomValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutBottomValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutBottomValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBottomValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBottomValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBottomValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBoxSizingValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBoxSizingValueEnumWrapper { AzLayoutBoxSizingValueEnumWrapper { inner: AzLayoutBoxSizingValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutBoxSizingValueEnumWrapper { AzLayoutBoxSizingValueEnumWrapper { inner: AzLayoutBoxSizingValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutBoxSizingValueEnumWrapper { AzLayoutBoxSizingValueEnumWrapper { inner: AzLayoutBoxSizingValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutBoxSizingValueEnumWrapper { AzLayoutBoxSizingValueEnumWrapper { inner: AzLayoutBoxSizingValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutBoxSizingEnumWrapper) -> AzLayoutBoxSizingValueEnumWrapper { AzLayoutBoxSizingValueEnumWrapper { inner: AzLayoutBoxSizingValue::Exact(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutBoxSizingValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBoxSizingValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBoxSizingValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBoxSizingValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutBoxSizingValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutBoxSizingValue::Exact(v) => Ok(vec!["Exact".into_py(py), { let m: &AzLayoutBoxSizingEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBoxSizingValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBoxSizingValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBoxSizingValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexDirectionValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFlexDirectionValueEnumWrapper { AzLayoutFlexDirectionValueEnumWrapper { inner: AzLayoutFlexDirectionValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutFlexDirectionValueEnumWrapper { AzLayoutFlexDirectionValueEnumWrapper { inner: AzLayoutFlexDirectionValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutFlexDirectionValueEnumWrapper { AzLayoutFlexDirectionValueEnumWrapper { inner: AzLayoutFlexDirectionValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutFlexDirectionValueEnumWrapper { AzLayoutFlexDirectionValueEnumWrapper { inner: AzLayoutFlexDirectionValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutFlexDirectionEnumWrapper) -> AzLayoutFlexDirectionValueEnumWrapper { AzLayoutFlexDirectionValueEnumWrapper { inner: AzLayoutFlexDirectionValue::Exact(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutFlexDirectionValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFlexDirectionValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFlexDirectionValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutFlexDirectionValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutFlexDirectionValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutFlexDirectionValue::Exact(v) => Ok(vec!["Exact".into_py(py), { let m: &AzLayoutFlexDirectionEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexDirectionValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFlexDirectionValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFlexDirectionValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutDisplayValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutDisplayValueEnumWrapper { AzLayoutDisplayValueEnumWrapper { inner: AzLayoutDisplayValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutDisplayValueEnumWrapper { AzLayoutDisplayValueEnumWrapper { inner: AzLayoutDisplayValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutDisplayValueEnumWrapper { AzLayoutDisplayValueEnumWrapper { inner: AzLayoutDisplayValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutDisplayValueEnumWrapper { AzLayoutDisplayValueEnumWrapper { inner: AzLayoutDisplayValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutDisplayEnumWrapper) -> AzLayoutDisplayValueEnumWrapper { AzLayoutDisplayValueEnumWrapper { inner: AzLayoutDisplayValue::Exact(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutDisplayValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutDisplayValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutDisplayValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutDisplayValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutDisplayValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutDisplayValue::Exact(v) => Ok(vec!["Exact".into_py(py), { let m: &AzLayoutDisplayEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutDisplayValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutDisplayValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutDisplayValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexGrowValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFlexGrowValueEnumWrapper { AzLayoutFlexGrowValueEnumWrapper { inner: AzLayoutFlexGrowValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutFlexGrowValueEnumWrapper { AzLayoutFlexGrowValueEnumWrapper { inner: AzLayoutFlexGrowValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutFlexGrowValueEnumWrapper { AzLayoutFlexGrowValueEnumWrapper { inner: AzLayoutFlexGrowValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutFlexGrowValueEnumWrapper { AzLayoutFlexGrowValueEnumWrapper { inner: AzLayoutFlexGrowValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutFlexGrow) -> AzLayoutFlexGrowValueEnumWrapper { AzLayoutFlexGrowValueEnumWrapper { inner: AzLayoutFlexGrowValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutFlexGrowValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFlexGrowValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFlexGrowValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutFlexGrowValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutFlexGrowValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutFlexGrowValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexGrowValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFlexGrowValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFlexGrowValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexShrinkValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFlexShrinkValueEnumWrapper { AzLayoutFlexShrinkValueEnumWrapper { inner: AzLayoutFlexShrinkValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutFlexShrinkValueEnumWrapper { AzLayoutFlexShrinkValueEnumWrapper { inner: AzLayoutFlexShrinkValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutFlexShrinkValueEnumWrapper { AzLayoutFlexShrinkValueEnumWrapper { inner: AzLayoutFlexShrinkValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutFlexShrinkValueEnumWrapper { AzLayoutFlexShrinkValueEnumWrapper { inner: AzLayoutFlexShrinkValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutFlexShrink) -> AzLayoutFlexShrinkValueEnumWrapper { AzLayoutFlexShrinkValueEnumWrapper { inner: AzLayoutFlexShrinkValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutFlexShrinkValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFlexShrinkValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFlexShrinkValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutFlexShrinkValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutFlexShrinkValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutFlexShrinkValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexShrinkValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFlexShrinkValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFlexShrinkValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFloatValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFloatValueEnumWrapper { AzLayoutFloatValueEnumWrapper { inner: AzLayoutFloatValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutFloatValueEnumWrapper { AzLayoutFloatValueEnumWrapper { inner: AzLayoutFloatValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutFloatValueEnumWrapper { AzLayoutFloatValueEnumWrapper { inner: AzLayoutFloatValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutFloatValueEnumWrapper { AzLayoutFloatValueEnumWrapper { inner: AzLayoutFloatValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutFloatEnumWrapper) -> AzLayoutFloatValueEnumWrapper { AzLayoutFloatValueEnumWrapper { inner: AzLayoutFloatValue::Exact(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutFloatValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFloatValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFloatValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutFloatValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutFloatValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutFloatValue::Exact(v) => Ok(vec!["Exact".into_py(py), { let m: &AzLayoutFloatEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFloatValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFloatValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFloatValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutHeightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutHeightValueEnumWrapper { AzLayoutHeightValueEnumWrapper { inner: AzLayoutHeightValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutHeightValueEnumWrapper { AzLayoutHeightValueEnumWrapper { inner: AzLayoutHeightValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutHeightValueEnumWrapper { AzLayoutHeightValueEnumWrapper { inner: AzLayoutHeightValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutHeightValueEnumWrapper { AzLayoutHeightValueEnumWrapper { inner: AzLayoutHeightValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutHeight) -> AzLayoutHeightValueEnumWrapper { AzLayoutHeightValueEnumWrapper { inner: AzLayoutHeightValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutHeightValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutHeightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutHeightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutHeightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutHeightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutHeightValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutHeightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutHeightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutHeightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutJustifyContentValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutJustifyContentValueEnumWrapper { AzLayoutJustifyContentValueEnumWrapper { inner: AzLayoutJustifyContentValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutJustifyContentValueEnumWrapper { AzLayoutJustifyContentValueEnumWrapper { inner: AzLayoutJustifyContentValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutJustifyContentValueEnumWrapper { AzLayoutJustifyContentValueEnumWrapper { inner: AzLayoutJustifyContentValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutJustifyContentValueEnumWrapper { AzLayoutJustifyContentValueEnumWrapper { inner: AzLayoutJustifyContentValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutJustifyContentEnumWrapper) -> AzLayoutJustifyContentValueEnumWrapper { AzLayoutJustifyContentValueEnumWrapper { inner: AzLayoutJustifyContentValue::Exact(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutJustifyContentValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutJustifyContentValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutJustifyContentValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutJustifyContentValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutJustifyContentValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutJustifyContentValue::Exact(v) => Ok(vec!["Exact".into_py(py), { let m: &AzLayoutJustifyContentEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutJustifyContentValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutJustifyContentValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutJustifyContentValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutLeftValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutLeftValueEnumWrapper { AzLayoutLeftValueEnumWrapper { inner: AzLayoutLeftValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutLeftValueEnumWrapper { AzLayoutLeftValueEnumWrapper { inner: AzLayoutLeftValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutLeftValueEnumWrapper { AzLayoutLeftValueEnumWrapper { inner: AzLayoutLeftValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutLeftValueEnumWrapper { AzLayoutLeftValueEnumWrapper { inner: AzLayoutLeftValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutLeft) -> AzLayoutLeftValueEnumWrapper { AzLayoutLeftValueEnumWrapper { inner: AzLayoutLeftValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutLeftValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutLeftValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutLeftValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutLeftValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutLeftValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutLeftValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutLeftValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutLeftValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutLeftValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginBottomValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMarginBottomValueEnumWrapper { AzLayoutMarginBottomValueEnumWrapper { inner: AzLayoutMarginBottomValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutMarginBottomValueEnumWrapper { AzLayoutMarginBottomValueEnumWrapper { inner: AzLayoutMarginBottomValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutMarginBottomValueEnumWrapper { AzLayoutMarginBottomValueEnumWrapper { inner: AzLayoutMarginBottomValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutMarginBottomValueEnumWrapper { AzLayoutMarginBottomValueEnumWrapper { inner: AzLayoutMarginBottomValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutMarginBottom) -> AzLayoutMarginBottomValueEnumWrapper { AzLayoutMarginBottomValueEnumWrapper { inner: AzLayoutMarginBottomValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutMarginBottomValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMarginBottomValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMarginBottomValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMarginBottomValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMarginBottomValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMarginBottomValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginBottomValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMarginBottomValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMarginBottomValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginLeftValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMarginLeftValueEnumWrapper { AzLayoutMarginLeftValueEnumWrapper { inner: AzLayoutMarginLeftValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutMarginLeftValueEnumWrapper { AzLayoutMarginLeftValueEnumWrapper { inner: AzLayoutMarginLeftValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutMarginLeftValueEnumWrapper { AzLayoutMarginLeftValueEnumWrapper { inner: AzLayoutMarginLeftValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutMarginLeftValueEnumWrapper { AzLayoutMarginLeftValueEnumWrapper { inner: AzLayoutMarginLeftValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutMarginLeft) -> AzLayoutMarginLeftValueEnumWrapper { AzLayoutMarginLeftValueEnumWrapper { inner: AzLayoutMarginLeftValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutMarginLeftValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMarginLeftValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMarginLeftValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMarginLeftValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMarginLeftValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMarginLeftValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginLeftValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMarginLeftValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMarginLeftValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginRightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMarginRightValueEnumWrapper { AzLayoutMarginRightValueEnumWrapper { inner: AzLayoutMarginRightValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutMarginRightValueEnumWrapper { AzLayoutMarginRightValueEnumWrapper { inner: AzLayoutMarginRightValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutMarginRightValueEnumWrapper { AzLayoutMarginRightValueEnumWrapper { inner: AzLayoutMarginRightValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutMarginRightValueEnumWrapper { AzLayoutMarginRightValueEnumWrapper { inner: AzLayoutMarginRightValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutMarginRight) -> AzLayoutMarginRightValueEnumWrapper { AzLayoutMarginRightValueEnumWrapper { inner: AzLayoutMarginRightValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutMarginRightValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMarginRightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMarginRightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMarginRightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMarginRightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMarginRightValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginRightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMarginRightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMarginRightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginTopValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMarginTopValueEnumWrapper { AzLayoutMarginTopValueEnumWrapper { inner: AzLayoutMarginTopValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutMarginTopValueEnumWrapper { AzLayoutMarginTopValueEnumWrapper { inner: AzLayoutMarginTopValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutMarginTopValueEnumWrapper { AzLayoutMarginTopValueEnumWrapper { inner: AzLayoutMarginTopValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutMarginTopValueEnumWrapper { AzLayoutMarginTopValueEnumWrapper { inner: AzLayoutMarginTopValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutMarginTop) -> AzLayoutMarginTopValueEnumWrapper { AzLayoutMarginTopValueEnumWrapper { inner: AzLayoutMarginTopValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutMarginTopValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMarginTopValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMarginTopValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMarginTopValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMarginTopValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMarginTopValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginTopValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMarginTopValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMarginTopValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMaxHeightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMaxHeightValueEnumWrapper { AzLayoutMaxHeightValueEnumWrapper { inner: AzLayoutMaxHeightValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutMaxHeightValueEnumWrapper { AzLayoutMaxHeightValueEnumWrapper { inner: AzLayoutMaxHeightValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutMaxHeightValueEnumWrapper { AzLayoutMaxHeightValueEnumWrapper { inner: AzLayoutMaxHeightValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutMaxHeightValueEnumWrapper { AzLayoutMaxHeightValueEnumWrapper { inner: AzLayoutMaxHeightValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutMaxHeight) -> AzLayoutMaxHeightValueEnumWrapper { AzLayoutMaxHeightValueEnumWrapper { inner: AzLayoutMaxHeightValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutMaxHeightValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMaxHeightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMaxHeightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMaxHeightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMaxHeightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMaxHeightValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMaxHeightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMaxHeightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMaxHeightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMaxWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMaxWidthValueEnumWrapper { AzLayoutMaxWidthValueEnumWrapper { inner: AzLayoutMaxWidthValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutMaxWidthValueEnumWrapper { AzLayoutMaxWidthValueEnumWrapper { inner: AzLayoutMaxWidthValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutMaxWidthValueEnumWrapper { AzLayoutMaxWidthValueEnumWrapper { inner: AzLayoutMaxWidthValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutMaxWidthValueEnumWrapper { AzLayoutMaxWidthValueEnumWrapper { inner: AzLayoutMaxWidthValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutMaxWidth) -> AzLayoutMaxWidthValueEnumWrapper { AzLayoutMaxWidthValueEnumWrapper { inner: AzLayoutMaxWidthValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutMaxWidthValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMaxWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMaxWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMaxWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMaxWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMaxWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMaxWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMaxWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMaxWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMinHeightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMinHeightValueEnumWrapper { AzLayoutMinHeightValueEnumWrapper { inner: AzLayoutMinHeightValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutMinHeightValueEnumWrapper { AzLayoutMinHeightValueEnumWrapper { inner: AzLayoutMinHeightValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutMinHeightValueEnumWrapper { AzLayoutMinHeightValueEnumWrapper { inner: AzLayoutMinHeightValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutMinHeightValueEnumWrapper { AzLayoutMinHeightValueEnumWrapper { inner: AzLayoutMinHeightValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutMinHeight) -> AzLayoutMinHeightValueEnumWrapper { AzLayoutMinHeightValueEnumWrapper { inner: AzLayoutMinHeightValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutMinHeightValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMinHeightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMinHeightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMinHeightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMinHeightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMinHeightValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMinHeightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMinHeightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMinHeightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMinWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMinWidthValueEnumWrapper { AzLayoutMinWidthValueEnumWrapper { inner: AzLayoutMinWidthValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutMinWidthValueEnumWrapper { AzLayoutMinWidthValueEnumWrapper { inner: AzLayoutMinWidthValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutMinWidthValueEnumWrapper { AzLayoutMinWidthValueEnumWrapper { inner: AzLayoutMinWidthValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutMinWidthValueEnumWrapper { AzLayoutMinWidthValueEnumWrapper { inner: AzLayoutMinWidthValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutMinWidth) -> AzLayoutMinWidthValueEnumWrapper { AzLayoutMinWidthValueEnumWrapper { inner: AzLayoutMinWidthValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutMinWidthValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMinWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMinWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMinWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMinWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMinWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMinWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMinWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutMinWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingBottomValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutPaddingBottomValueEnumWrapper { AzLayoutPaddingBottomValueEnumWrapper { inner: AzLayoutPaddingBottomValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutPaddingBottomValueEnumWrapper { AzLayoutPaddingBottomValueEnumWrapper { inner: AzLayoutPaddingBottomValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutPaddingBottomValueEnumWrapper { AzLayoutPaddingBottomValueEnumWrapper { inner: AzLayoutPaddingBottomValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutPaddingBottomValueEnumWrapper { AzLayoutPaddingBottomValueEnumWrapper { inner: AzLayoutPaddingBottomValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutPaddingBottom) -> AzLayoutPaddingBottomValueEnumWrapper { AzLayoutPaddingBottomValueEnumWrapper { inner: AzLayoutPaddingBottomValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutPaddingBottomValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutPaddingBottomValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutPaddingBottomValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutPaddingBottomValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutPaddingBottomValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutPaddingBottomValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingBottomValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPaddingBottomValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPaddingBottomValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingLeftValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutPaddingLeftValueEnumWrapper { AzLayoutPaddingLeftValueEnumWrapper { inner: AzLayoutPaddingLeftValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutPaddingLeftValueEnumWrapper { AzLayoutPaddingLeftValueEnumWrapper { inner: AzLayoutPaddingLeftValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutPaddingLeftValueEnumWrapper { AzLayoutPaddingLeftValueEnumWrapper { inner: AzLayoutPaddingLeftValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutPaddingLeftValueEnumWrapper { AzLayoutPaddingLeftValueEnumWrapper { inner: AzLayoutPaddingLeftValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutPaddingLeft) -> AzLayoutPaddingLeftValueEnumWrapper { AzLayoutPaddingLeftValueEnumWrapper { inner: AzLayoutPaddingLeftValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutPaddingLeftValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutPaddingLeftValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutPaddingLeftValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutPaddingLeftValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutPaddingLeftValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutPaddingLeftValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingLeftValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPaddingLeftValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPaddingLeftValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingRightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutPaddingRightValueEnumWrapper { AzLayoutPaddingRightValueEnumWrapper { inner: AzLayoutPaddingRightValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutPaddingRightValueEnumWrapper { AzLayoutPaddingRightValueEnumWrapper { inner: AzLayoutPaddingRightValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutPaddingRightValueEnumWrapper { AzLayoutPaddingRightValueEnumWrapper { inner: AzLayoutPaddingRightValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutPaddingRightValueEnumWrapper { AzLayoutPaddingRightValueEnumWrapper { inner: AzLayoutPaddingRightValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutPaddingRight) -> AzLayoutPaddingRightValueEnumWrapper { AzLayoutPaddingRightValueEnumWrapper { inner: AzLayoutPaddingRightValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutPaddingRightValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutPaddingRightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutPaddingRightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutPaddingRightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutPaddingRightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutPaddingRightValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingRightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPaddingRightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPaddingRightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingTopValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutPaddingTopValueEnumWrapper { AzLayoutPaddingTopValueEnumWrapper { inner: AzLayoutPaddingTopValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutPaddingTopValueEnumWrapper { AzLayoutPaddingTopValueEnumWrapper { inner: AzLayoutPaddingTopValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutPaddingTopValueEnumWrapper { AzLayoutPaddingTopValueEnumWrapper { inner: AzLayoutPaddingTopValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutPaddingTopValueEnumWrapper { AzLayoutPaddingTopValueEnumWrapper { inner: AzLayoutPaddingTopValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutPaddingTop) -> AzLayoutPaddingTopValueEnumWrapper { AzLayoutPaddingTopValueEnumWrapper { inner: AzLayoutPaddingTopValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutPaddingTopValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutPaddingTopValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutPaddingTopValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutPaddingTopValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutPaddingTopValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutPaddingTopValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingTopValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPaddingTopValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPaddingTopValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPositionValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutPositionValueEnumWrapper { AzLayoutPositionValueEnumWrapper { inner: AzLayoutPositionValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutPositionValueEnumWrapper { AzLayoutPositionValueEnumWrapper { inner: AzLayoutPositionValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutPositionValueEnumWrapper { AzLayoutPositionValueEnumWrapper { inner: AzLayoutPositionValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutPositionValueEnumWrapper { AzLayoutPositionValueEnumWrapper { inner: AzLayoutPositionValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutPositionEnumWrapper) -> AzLayoutPositionValueEnumWrapper { AzLayoutPositionValueEnumWrapper { inner: AzLayoutPositionValue::Exact(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutPositionValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutPositionValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutPositionValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutPositionValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutPositionValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutPositionValue::Exact(v) => Ok(vec!["Exact".into_py(py), { let m: &AzLayoutPositionEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPositionValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPositionValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutPositionValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutRightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutRightValueEnumWrapper { AzLayoutRightValueEnumWrapper { inner: AzLayoutRightValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutRightValueEnumWrapper { AzLayoutRightValueEnumWrapper { inner: AzLayoutRightValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutRightValueEnumWrapper { AzLayoutRightValueEnumWrapper { inner: AzLayoutRightValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutRightValueEnumWrapper { AzLayoutRightValueEnumWrapper { inner: AzLayoutRightValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutRight) -> AzLayoutRightValueEnumWrapper { AzLayoutRightValueEnumWrapper { inner: AzLayoutRightValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutRightValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutRightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutRightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutRightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutRightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutRightValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutRightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutRightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutRightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutTopValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutTopValueEnumWrapper { AzLayoutTopValueEnumWrapper { inner: AzLayoutTopValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutTopValueEnumWrapper { AzLayoutTopValueEnumWrapper { inner: AzLayoutTopValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutTopValueEnumWrapper { AzLayoutTopValueEnumWrapper { inner: AzLayoutTopValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutTopValueEnumWrapper { AzLayoutTopValueEnumWrapper { inner: AzLayoutTopValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutTop) -> AzLayoutTopValueEnumWrapper { AzLayoutTopValueEnumWrapper { inner: AzLayoutTopValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutTopValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutTopValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutTopValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutTopValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutTopValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutTopValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutTopValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutTopValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutTopValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutWidthValueEnumWrapper { AzLayoutWidthValueEnumWrapper { inner: AzLayoutWidthValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutWidthValueEnumWrapper { AzLayoutWidthValueEnumWrapper { inner: AzLayoutWidthValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutWidthValueEnumWrapper { AzLayoutWidthValueEnumWrapper { inner: AzLayoutWidthValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutWidthValueEnumWrapper { AzLayoutWidthValueEnumWrapper { inner: AzLayoutWidthValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutWidth) -> AzLayoutWidthValueEnumWrapper { AzLayoutWidthValueEnumWrapper { inner: AzLayoutWidthValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutWidthValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexWrapValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFlexWrapValueEnumWrapper { AzLayoutFlexWrapValueEnumWrapper { inner: AzLayoutFlexWrapValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutFlexWrapValueEnumWrapper { AzLayoutFlexWrapValueEnumWrapper { inner: AzLayoutFlexWrapValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutFlexWrapValueEnumWrapper { AzLayoutFlexWrapValueEnumWrapper { inner: AzLayoutFlexWrapValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutFlexWrapValueEnumWrapper { AzLayoutFlexWrapValueEnumWrapper { inner: AzLayoutFlexWrapValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutFlexWrapEnumWrapper) -> AzLayoutFlexWrapValueEnumWrapper { AzLayoutFlexWrapValueEnumWrapper { inner: AzLayoutFlexWrapValue::Exact(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutFlexWrapValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFlexWrapValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFlexWrapValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutFlexWrapValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutFlexWrapValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutFlexWrapValue::Exact(v) => Ok(vec!["Exact".into_py(py), { let m: &AzLayoutFlexWrapEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexWrapValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFlexWrapValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutFlexWrapValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutOverflowValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutOverflowValueEnumWrapper { AzLayoutOverflowValueEnumWrapper { inner: AzLayoutOverflowValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutOverflowValueEnumWrapper { AzLayoutOverflowValueEnumWrapper { inner: AzLayoutOverflowValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutOverflowValueEnumWrapper { AzLayoutOverflowValueEnumWrapper { inner: AzLayoutOverflowValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutOverflowValueEnumWrapper { AzLayoutOverflowValueEnumWrapper { inner: AzLayoutOverflowValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutOverflowEnumWrapper) -> AzLayoutOverflowValueEnumWrapper { AzLayoutOverflowValueEnumWrapper { inner: AzLayoutOverflowValue::Exact(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutOverflowValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutOverflowValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutOverflowValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutOverflowValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutOverflowValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutOverflowValue::Exact(v) => Ok(vec!["Exact".into_py(py), { let m: &AzLayoutOverflowEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutOverflowValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutOverflowValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutOverflowValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScrollbarStyleValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzScrollbarStyleValueEnumWrapper { AzScrollbarStyleValueEnumWrapper { inner: AzScrollbarStyleValue::Auto } }
    #[classattr]
    fn None() -> AzScrollbarStyleValueEnumWrapper { AzScrollbarStyleValueEnumWrapper { inner: AzScrollbarStyleValue::None } }
    #[classattr]
    fn Inherit() -> AzScrollbarStyleValueEnumWrapper { AzScrollbarStyleValueEnumWrapper { inner: AzScrollbarStyleValue::Inherit } }
    #[classattr]
    fn Initial() -> AzScrollbarStyleValueEnumWrapper { AzScrollbarStyleValueEnumWrapper { inner: AzScrollbarStyleValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzScrollbarStyle) -> AzScrollbarStyleValueEnumWrapper { AzScrollbarStyleValueEnumWrapper { inner: AzScrollbarStyleValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzScrollbarStyleValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzScrollbarStyleValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzScrollbarStyleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzScrollbarStyleValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzScrollbarStyleValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzScrollbarStyleValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzScrollbarStyleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::ScrollbarStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::ScrollbarStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundContentVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBackgroundContentVecValueEnumWrapper { AzStyleBackgroundContentVecValueEnumWrapper { inner: AzStyleBackgroundContentVecValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBackgroundContentVecValueEnumWrapper { AzStyleBackgroundContentVecValueEnumWrapper { inner: AzStyleBackgroundContentVecValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBackgroundContentVecValueEnumWrapper { AzStyleBackgroundContentVecValueEnumWrapper { inner: AzStyleBackgroundContentVecValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBackgroundContentVecValueEnumWrapper { AzStyleBackgroundContentVecValueEnumWrapper { inner: AzStyleBackgroundContentVecValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBackgroundContentVec) -> AzStyleBackgroundContentVecValueEnumWrapper { AzStyleBackgroundContentVecValueEnumWrapper { inner: AzStyleBackgroundContentVecValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundContentVecValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundContentVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBackgroundContentVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBackgroundContentVecValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBackgroundContentVecValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBackgroundContentVecValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundContentVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundContentVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundContentVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundPositionVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBackgroundPositionVecValueEnumWrapper { AzStyleBackgroundPositionVecValueEnumWrapper { inner: AzStyleBackgroundPositionVecValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBackgroundPositionVecValueEnumWrapper { AzStyleBackgroundPositionVecValueEnumWrapper { inner: AzStyleBackgroundPositionVecValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBackgroundPositionVecValueEnumWrapper { AzStyleBackgroundPositionVecValueEnumWrapper { inner: AzStyleBackgroundPositionVecValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBackgroundPositionVecValueEnumWrapper { AzStyleBackgroundPositionVecValueEnumWrapper { inner: AzStyleBackgroundPositionVecValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBackgroundPositionVec) -> AzStyleBackgroundPositionVecValueEnumWrapper { AzStyleBackgroundPositionVecValueEnumWrapper { inner: AzStyleBackgroundPositionVecValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundPositionVecValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundPositionVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBackgroundPositionVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBackgroundPositionVecValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBackgroundPositionVecValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBackgroundPositionVecValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundPositionVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundPositionVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundPositionVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundRepeatVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBackgroundRepeatVecValueEnumWrapper { AzStyleBackgroundRepeatVecValueEnumWrapper { inner: AzStyleBackgroundRepeatVecValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBackgroundRepeatVecValueEnumWrapper { AzStyleBackgroundRepeatVecValueEnumWrapper { inner: AzStyleBackgroundRepeatVecValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBackgroundRepeatVecValueEnumWrapper { AzStyleBackgroundRepeatVecValueEnumWrapper { inner: AzStyleBackgroundRepeatVecValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBackgroundRepeatVecValueEnumWrapper { AzStyleBackgroundRepeatVecValueEnumWrapper { inner: AzStyleBackgroundRepeatVecValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBackgroundRepeatVec) -> AzStyleBackgroundRepeatVecValueEnumWrapper { AzStyleBackgroundRepeatVecValueEnumWrapper { inner: AzStyleBackgroundRepeatVecValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundRepeatVecValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundRepeatVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBackgroundRepeatVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBackgroundRepeatVecValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBackgroundRepeatVecValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBackgroundRepeatVecValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundRepeatVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundRepeatVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundRepeatVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundSizeVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBackgroundSizeVecValueEnumWrapper { AzStyleBackgroundSizeVecValueEnumWrapper { inner: AzStyleBackgroundSizeVecValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBackgroundSizeVecValueEnumWrapper { AzStyleBackgroundSizeVecValueEnumWrapper { inner: AzStyleBackgroundSizeVecValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBackgroundSizeVecValueEnumWrapper { AzStyleBackgroundSizeVecValueEnumWrapper { inner: AzStyleBackgroundSizeVecValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBackgroundSizeVecValueEnumWrapper { AzStyleBackgroundSizeVecValueEnumWrapper { inner: AzStyleBackgroundSizeVecValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBackgroundSizeVec) -> AzStyleBackgroundSizeVecValueEnumWrapper { AzStyleBackgroundSizeVecValueEnumWrapper { inner: AzStyleBackgroundSizeVecValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundSizeVecValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundSizeVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSizeVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSizeVecValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSizeVecValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSizeVecValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundSizeVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundSizeVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundSizeVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomColorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderBottomColorValueEnumWrapper { AzStyleBorderBottomColorValueEnumWrapper { inner: AzStyleBorderBottomColorValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBorderBottomColorValueEnumWrapper { AzStyleBorderBottomColorValueEnumWrapper { inner: AzStyleBorderBottomColorValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBorderBottomColorValueEnumWrapper { AzStyleBorderBottomColorValueEnumWrapper { inner: AzStyleBorderBottomColorValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBorderBottomColorValueEnumWrapper { AzStyleBorderBottomColorValueEnumWrapper { inner: AzStyleBorderBottomColorValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBorderBottomColor) -> AzStyleBorderBottomColorValueEnumWrapper { AzStyleBorderBottomColorValueEnumWrapper { inner: AzStyleBorderBottomColorValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderBottomColorValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderBottomColorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomColorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomColorValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomColorValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomColorValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomColorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderBottomColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderBottomColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomLeftRadiusValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderBottomLeftRadiusValueEnumWrapper { AzStyleBorderBottomLeftRadiusValueEnumWrapper { inner: AzStyleBorderBottomLeftRadiusValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBorderBottomLeftRadiusValueEnumWrapper { AzStyleBorderBottomLeftRadiusValueEnumWrapper { inner: AzStyleBorderBottomLeftRadiusValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBorderBottomLeftRadiusValueEnumWrapper { AzStyleBorderBottomLeftRadiusValueEnumWrapper { inner: AzStyleBorderBottomLeftRadiusValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBorderBottomLeftRadiusValueEnumWrapper { AzStyleBorderBottomLeftRadiusValueEnumWrapper { inner: AzStyleBorderBottomLeftRadiusValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBorderBottomLeftRadius) -> AzStyleBorderBottomLeftRadiusValueEnumWrapper { AzStyleBorderBottomLeftRadiusValueEnumWrapper { inner: AzStyleBorderBottomLeftRadiusValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderBottomLeftRadiusValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderBottomLeftRadiusValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomLeftRadiusValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomLeftRadiusValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomLeftRadiusValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomLeftRadiusValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomLeftRadiusValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderBottomLeftRadiusValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderBottomLeftRadiusValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomRightRadiusValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderBottomRightRadiusValueEnumWrapper { AzStyleBorderBottomRightRadiusValueEnumWrapper { inner: AzStyleBorderBottomRightRadiusValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBorderBottomRightRadiusValueEnumWrapper { AzStyleBorderBottomRightRadiusValueEnumWrapper { inner: AzStyleBorderBottomRightRadiusValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBorderBottomRightRadiusValueEnumWrapper { AzStyleBorderBottomRightRadiusValueEnumWrapper { inner: AzStyleBorderBottomRightRadiusValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBorderBottomRightRadiusValueEnumWrapper { AzStyleBorderBottomRightRadiusValueEnumWrapper { inner: AzStyleBorderBottomRightRadiusValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBorderBottomRightRadius) -> AzStyleBorderBottomRightRadiusValueEnumWrapper { AzStyleBorderBottomRightRadiusValueEnumWrapper { inner: AzStyleBorderBottomRightRadiusValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderBottomRightRadiusValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderBottomRightRadiusValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomRightRadiusValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomRightRadiusValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomRightRadiusValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomRightRadiusValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomRightRadiusValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderBottomRightRadiusValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderBottomRightRadiusValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomStyleValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderBottomStyleValueEnumWrapper { AzStyleBorderBottomStyleValueEnumWrapper { inner: AzStyleBorderBottomStyleValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBorderBottomStyleValueEnumWrapper { AzStyleBorderBottomStyleValueEnumWrapper { inner: AzStyleBorderBottomStyleValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBorderBottomStyleValueEnumWrapper { AzStyleBorderBottomStyleValueEnumWrapper { inner: AzStyleBorderBottomStyleValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBorderBottomStyleValueEnumWrapper { AzStyleBorderBottomStyleValueEnumWrapper { inner: AzStyleBorderBottomStyleValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBorderBottomStyle) -> AzStyleBorderBottomStyleValueEnumWrapper { AzStyleBorderBottomStyleValueEnumWrapper { inner: AzStyleBorderBottomStyleValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderBottomStyleValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderBottomStyleValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomStyleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomStyleValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomStyleValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomStyleValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomStyleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderBottomStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderBottomStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderBottomWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBorderBottomWidthValueEnumWrapper { AzLayoutBorderBottomWidthValueEnumWrapper { inner: AzLayoutBorderBottomWidthValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutBorderBottomWidthValueEnumWrapper { AzLayoutBorderBottomWidthValueEnumWrapper { inner: AzLayoutBorderBottomWidthValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutBorderBottomWidthValueEnumWrapper { AzLayoutBorderBottomWidthValueEnumWrapper { inner: AzLayoutBorderBottomWidthValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutBorderBottomWidthValueEnumWrapper { AzLayoutBorderBottomWidthValueEnumWrapper { inner: AzLayoutBorderBottomWidthValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutBorderBottomWidth) -> AzLayoutBorderBottomWidthValueEnumWrapper { AzLayoutBorderBottomWidthValueEnumWrapper { inner: AzLayoutBorderBottomWidthValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutBorderBottomWidthValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBorderBottomWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBorderBottomWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBorderBottomWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutBorderBottomWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutBorderBottomWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderBottomWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBorderBottomWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBorderBottomWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderLeftColorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderLeftColorValueEnumWrapper { AzStyleBorderLeftColorValueEnumWrapper { inner: AzStyleBorderLeftColorValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBorderLeftColorValueEnumWrapper { AzStyleBorderLeftColorValueEnumWrapper { inner: AzStyleBorderLeftColorValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBorderLeftColorValueEnumWrapper { AzStyleBorderLeftColorValueEnumWrapper { inner: AzStyleBorderLeftColorValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBorderLeftColorValueEnumWrapper { AzStyleBorderLeftColorValueEnumWrapper { inner: AzStyleBorderLeftColorValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBorderLeftColor) -> AzStyleBorderLeftColorValueEnumWrapper { AzStyleBorderLeftColorValueEnumWrapper { inner: AzStyleBorderLeftColorValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderLeftColorValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderLeftColorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftColorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftColorValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftColorValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftColorValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderLeftColorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderLeftColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderLeftColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderLeftStyleValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderLeftStyleValueEnumWrapper { AzStyleBorderLeftStyleValueEnumWrapper { inner: AzStyleBorderLeftStyleValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBorderLeftStyleValueEnumWrapper { AzStyleBorderLeftStyleValueEnumWrapper { inner: AzStyleBorderLeftStyleValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBorderLeftStyleValueEnumWrapper { AzStyleBorderLeftStyleValueEnumWrapper { inner: AzStyleBorderLeftStyleValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBorderLeftStyleValueEnumWrapper { AzStyleBorderLeftStyleValueEnumWrapper { inner: AzStyleBorderLeftStyleValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBorderLeftStyle) -> AzStyleBorderLeftStyleValueEnumWrapper { AzStyleBorderLeftStyleValueEnumWrapper { inner: AzStyleBorderLeftStyleValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderLeftStyleValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderLeftStyleValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftStyleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftStyleValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftStyleValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftStyleValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderLeftStyleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderLeftStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderLeftStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderLeftWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBorderLeftWidthValueEnumWrapper { AzLayoutBorderLeftWidthValueEnumWrapper { inner: AzLayoutBorderLeftWidthValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutBorderLeftWidthValueEnumWrapper { AzLayoutBorderLeftWidthValueEnumWrapper { inner: AzLayoutBorderLeftWidthValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutBorderLeftWidthValueEnumWrapper { AzLayoutBorderLeftWidthValueEnumWrapper { inner: AzLayoutBorderLeftWidthValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutBorderLeftWidthValueEnumWrapper { AzLayoutBorderLeftWidthValueEnumWrapper { inner: AzLayoutBorderLeftWidthValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutBorderLeftWidth) -> AzLayoutBorderLeftWidthValueEnumWrapper { AzLayoutBorderLeftWidthValueEnumWrapper { inner: AzLayoutBorderLeftWidthValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutBorderLeftWidthValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBorderLeftWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBorderLeftWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBorderLeftWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutBorderLeftWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutBorderLeftWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderLeftWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBorderLeftWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBorderLeftWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderRightColorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderRightColorValueEnumWrapper { AzStyleBorderRightColorValueEnumWrapper { inner: AzStyleBorderRightColorValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBorderRightColorValueEnumWrapper { AzStyleBorderRightColorValueEnumWrapper { inner: AzStyleBorderRightColorValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBorderRightColorValueEnumWrapper { AzStyleBorderRightColorValueEnumWrapper { inner: AzStyleBorderRightColorValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBorderRightColorValueEnumWrapper { AzStyleBorderRightColorValueEnumWrapper { inner: AzStyleBorderRightColorValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBorderRightColor) -> AzStyleBorderRightColorValueEnumWrapper { AzStyleBorderRightColorValueEnumWrapper { inner: AzStyleBorderRightColorValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderRightColorValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderRightColorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderRightColorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderRightColorValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderRightColorValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderRightColorValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderRightColorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderRightColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderRightColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderRightStyleValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderRightStyleValueEnumWrapper { AzStyleBorderRightStyleValueEnumWrapper { inner: AzStyleBorderRightStyleValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBorderRightStyleValueEnumWrapper { AzStyleBorderRightStyleValueEnumWrapper { inner: AzStyleBorderRightStyleValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBorderRightStyleValueEnumWrapper { AzStyleBorderRightStyleValueEnumWrapper { inner: AzStyleBorderRightStyleValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBorderRightStyleValueEnumWrapper { AzStyleBorderRightStyleValueEnumWrapper { inner: AzStyleBorderRightStyleValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBorderRightStyle) -> AzStyleBorderRightStyleValueEnumWrapper { AzStyleBorderRightStyleValueEnumWrapper { inner: AzStyleBorderRightStyleValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderRightStyleValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderRightStyleValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderRightStyleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderRightStyleValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderRightStyleValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderRightStyleValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderRightStyleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderRightStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderRightStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderRightWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBorderRightWidthValueEnumWrapper { AzLayoutBorderRightWidthValueEnumWrapper { inner: AzLayoutBorderRightWidthValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutBorderRightWidthValueEnumWrapper { AzLayoutBorderRightWidthValueEnumWrapper { inner: AzLayoutBorderRightWidthValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutBorderRightWidthValueEnumWrapper { AzLayoutBorderRightWidthValueEnumWrapper { inner: AzLayoutBorderRightWidthValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutBorderRightWidthValueEnumWrapper { AzLayoutBorderRightWidthValueEnumWrapper { inner: AzLayoutBorderRightWidthValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutBorderRightWidth) -> AzLayoutBorderRightWidthValueEnumWrapper { AzLayoutBorderRightWidthValueEnumWrapper { inner: AzLayoutBorderRightWidthValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutBorderRightWidthValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBorderRightWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBorderRightWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBorderRightWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutBorderRightWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutBorderRightWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderRightWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBorderRightWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBorderRightWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopColorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderTopColorValueEnumWrapper { AzStyleBorderTopColorValueEnumWrapper { inner: AzStyleBorderTopColorValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBorderTopColorValueEnumWrapper { AzStyleBorderTopColorValueEnumWrapper { inner: AzStyleBorderTopColorValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBorderTopColorValueEnumWrapper { AzStyleBorderTopColorValueEnumWrapper { inner: AzStyleBorderTopColorValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBorderTopColorValueEnumWrapper { AzStyleBorderTopColorValueEnumWrapper { inner: AzStyleBorderTopColorValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBorderTopColor) -> AzStyleBorderTopColorValueEnumWrapper { AzStyleBorderTopColorValueEnumWrapper { inner: AzStyleBorderTopColorValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderTopColorValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderTopColorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderTopColorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderTopColorValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderTopColorValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderTopColorValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopColorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderTopColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderTopColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopLeftRadiusValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderTopLeftRadiusValueEnumWrapper { AzStyleBorderTopLeftRadiusValueEnumWrapper { inner: AzStyleBorderTopLeftRadiusValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBorderTopLeftRadiusValueEnumWrapper { AzStyleBorderTopLeftRadiusValueEnumWrapper { inner: AzStyleBorderTopLeftRadiusValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBorderTopLeftRadiusValueEnumWrapper { AzStyleBorderTopLeftRadiusValueEnumWrapper { inner: AzStyleBorderTopLeftRadiusValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBorderTopLeftRadiusValueEnumWrapper { AzStyleBorderTopLeftRadiusValueEnumWrapper { inner: AzStyleBorderTopLeftRadiusValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBorderTopLeftRadius) -> AzStyleBorderTopLeftRadiusValueEnumWrapper { AzStyleBorderTopLeftRadiusValueEnumWrapper { inner: AzStyleBorderTopLeftRadiusValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderTopLeftRadiusValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderTopLeftRadiusValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderTopLeftRadiusValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderTopLeftRadiusValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderTopLeftRadiusValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderTopLeftRadiusValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopLeftRadiusValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderTopLeftRadiusValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderTopLeftRadiusValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopRightRadiusValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderTopRightRadiusValueEnumWrapper { AzStyleBorderTopRightRadiusValueEnumWrapper { inner: AzStyleBorderTopRightRadiusValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBorderTopRightRadiusValueEnumWrapper { AzStyleBorderTopRightRadiusValueEnumWrapper { inner: AzStyleBorderTopRightRadiusValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBorderTopRightRadiusValueEnumWrapper { AzStyleBorderTopRightRadiusValueEnumWrapper { inner: AzStyleBorderTopRightRadiusValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBorderTopRightRadiusValueEnumWrapper { AzStyleBorderTopRightRadiusValueEnumWrapper { inner: AzStyleBorderTopRightRadiusValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBorderTopRightRadius) -> AzStyleBorderTopRightRadiusValueEnumWrapper { AzStyleBorderTopRightRadiusValueEnumWrapper { inner: AzStyleBorderTopRightRadiusValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderTopRightRadiusValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderTopRightRadiusValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderTopRightRadiusValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderTopRightRadiusValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderTopRightRadiusValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderTopRightRadiusValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopRightRadiusValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderTopRightRadiusValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderTopRightRadiusValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopStyleValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderTopStyleValueEnumWrapper { AzStyleBorderTopStyleValueEnumWrapper { inner: AzStyleBorderTopStyleValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBorderTopStyleValueEnumWrapper { AzStyleBorderTopStyleValueEnumWrapper { inner: AzStyleBorderTopStyleValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBorderTopStyleValueEnumWrapper { AzStyleBorderTopStyleValueEnumWrapper { inner: AzStyleBorderTopStyleValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBorderTopStyleValueEnumWrapper { AzStyleBorderTopStyleValueEnumWrapper { inner: AzStyleBorderTopStyleValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBorderTopStyle) -> AzStyleBorderTopStyleValueEnumWrapper { AzStyleBorderTopStyleValueEnumWrapper { inner: AzStyleBorderTopStyleValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderTopStyleValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderTopStyleValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderTopStyleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderTopStyleValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderTopStyleValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderTopStyleValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopStyleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderTopStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBorderTopStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderTopWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBorderTopWidthValueEnumWrapper { AzLayoutBorderTopWidthValueEnumWrapper { inner: AzLayoutBorderTopWidthValue::Auto } }
    #[classattr]
    fn None() -> AzLayoutBorderTopWidthValueEnumWrapper { AzLayoutBorderTopWidthValueEnumWrapper { inner: AzLayoutBorderTopWidthValue::None } }
    #[classattr]
    fn Inherit() -> AzLayoutBorderTopWidthValueEnumWrapper { AzLayoutBorderTopWidthValueEnumWrapper { inner: AzLayoutBorderTopWidthValue::Inherit } }
    #[classattr]
    fn Initial() -> AzLayoutBorderTopWidthValueEnumWrapper { AzLayoutBorderTopWidthValueEnumWrapper { inner: AzLayoutBorderTopWidthValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzLayoutBorderTopWidth) -> AzLayoutBorderTopWidthValueEnumWrapper { AzLayoutBorderTopWidthValueEnumWrapper { inner: AzLayoutBorderTopWidthValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutBorderTopWidthValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBorderTopWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBorderTopWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBorderTopWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutBorderTopWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutBorderTopWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderTopWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBorderTopWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::LayoutBorderTopWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleCursorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleCursorValueEnumWrapper { AzStyleCursorValueEnumWrapper { inner: AzStyleCursorValue::Auto } }
    #[classattr]
    fn None() -> AzStyleCursorValueEnumWrapper { AzStyleCursorValueEnumWrapper { inner: AzStyleCursorValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleCursorValueEnumWrapper { AzStyleCursorValueEnumWrapper { inner: AzStyleCursorValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleCursorValueEnumWrapper { AzStyleCursorValueEnumWrapper { inner: AzStyleCursorValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleCursorEnumWrapper) -> AzStyleCursorValueEnumWrapper { AzStyleCursorValueEnumWrapper { inner: AzStyleCursorValue::Exact(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleCursorValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleCursorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleCursorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleCursorValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleCursorValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleCursorValue::Exact(v) => Ok(vec!["Exact".into_py(py), { let m: &AzStyleCursorEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleCursorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleCursorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleCursorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontFamilyVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleFontFamilyVecValueEnumWrapper { AzStyleFontFamilyVecValueEnumWrapper { inner: AzStyleFontFamilyVecValue::Auto } }
    #[classattr]
    fn None() -> AzStyleFontFamilyVecValueEnumWrapper { AzStyleFontFamilyVecValueEnumWrapper { inner: AzStyleFontFamilyVecValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleFontFamilyVecValueEnumWrapper { AzStyleFontFamilyVecValueEnumWrapper { inner: AzStyleFontFamilyVecValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleFontFamilyVecValueEnumWrapper { AzStyleFontFamilyVecValueEnumWrapper { inner: AzStyleFontFamilyVecValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleFontFamilyVec) -> AzStyleFontFamilyVecValueEnumWrapper { AzStyleFontFamilyVecValueEnumWrapper { inner: AzStyleFontFamilyVecValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleFontFamilyVecValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFontFamilyVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontFamilyVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleFontFamilyVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleFontFamilyVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontSizeValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleFontSizeValueEnumWrapper { AzStyleFontSizeValueEnumWrapper { inner: AzStyleFontSizeValue::Auto } }
    #[classattr]
    fn None() -> AzStyleFontSizeValueEnumWrapper { AzStyleFontSizeValueEnumWrapper { inner: AzStyleFontSizeValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleFontSizeValueEnumWrapper { AzStyleFontSizeValueEnumWrapper { inner: AzStyleFontSizeValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleFontSizeValueEnumWrapper { AzStyleFontSizeValueEnumWrapper { inner: AzStyleFontSizeValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleFontSize) -> AzStyleFontSizeValueEnumWrapper { AzStyleFontSizeValueEnumWrapper { inner: AzStyleFontSizeValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleFontSizeValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFontSizeValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleFontSizeValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleFontSizeValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleFontSizeValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleFontSizeValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontSizeValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleFontSizeValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleFontSizeValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleLetterSpacingValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleLetterSpacingValueEnumWrapper { AzStyleLetterSpacingValueEnumWrapper { inner: AzStyleLetterSpacingValue::Auto } }
    #[classattr]
    fn None() -> AzStyleLetterSpacingValueEnumWrapper { AzStyleLetterSpacingValueEnumWrapper { inner: AzStyleLetterSpacingValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleLetterSpacingValueEnumWrapper { AzStyleLetterSpacingValueEnumWrapper { inner: AzStyleLetterSpacingValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleLetterSpacingValueEnumWrapper { AzStyleLetterSpacingValueEnumWrapper { inner: AzStyleLetterSpacingValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleLetterSpacing) -> AzStyleLetterSpacingValueEnumWrapper { AzStyleLetterSpacingValueEnumWrapper { inner: AzStyleLetterSpacingValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleLetterSpacingValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleLetterSpacingValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleLetterSpacingValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleLetterSpacingValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleLetterSpacingValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleLetterSpacingValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleLetterSpacingValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleLetterSpacingValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleLetterSpacingValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleLineHeightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleLineHeightValueEnumWrapper { AzStyleLineHeightValueEnumWrapper { inner: AzStyleLineHeightValue::Auto } }
    #[classattr]
    fn None() -> AzStyleLineHeightValueEnumWrapper { AzStyleLineHeightValueEnumWrapper { inner: AzStyleLineHeightValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleLineHeightValueEnumWrapper { AzStyleLineHeightValueEnumWrapper { inner: AzStyleLineHeightValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleLineHeightValueEnumWrapper { AzStyleLineHeightValueEnumWrapper { inner: AzStyleLineHeightValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleLineHeight) -> AzStyleLineHeightValueEnumWrapper { AzStyleLineHeightValueEnumWrapper { inner: AzStyleLineHeightValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleLineHeightValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleLineHeightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleLineHeightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleLineHeightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleLineHeightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleLineHeightValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleLineHeightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleLineHeightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleLineHeightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTabWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleTabWidthValueEnumWrapper { AzStyleTabWidthValueEnumWrapper { inner: AzStyleTabWidthValue::Auto } }
    #[classattr]
    fn None() -> AzStyleTabWidthValueEnumWrapper { AzStyleTabWidthValueEnumWrapper { inner: AzStyleTabWidthValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleTabWidthValueEnumWrapper { AzStyleTabWidthValueEnumWrapper { inner: AzStyleTabWidthValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleTabWidthValueEnumWrapper { AzStyleTabWidthValueEnumWrapper { inner: AzStyleTabWidthValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleTabWidth) -> AzStyleTabWidthValueEnumWrapper { AzStyleTabWidthValueEnumWrapper { inner: AzStyleTabWidthValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTabWidthValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTabWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleTabWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleTabWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleTabWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleTabWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTabWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTabWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTabWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTextAlignValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleTextAlignValueEnumWrapper { AzStyleTextAlignValueEnumWrapper { inner: AzStyleTextAlignValue::Auto } }
    #[classattr]
    fn None() -> AzStyleTextAlignValueEnumWrapper { AzStyleTextAlignValueEnumWrapper { inner: AzStyleTextAlignValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleTextAlignValueEnumWrapper { AzStyleTextAlignValueEnumWrapper { inner: AzStyleTextAlignValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleTextAlignValueEnumWrapper { AzStyleTextAlignValueEnumWrapper { inner: AzStyleTextAlignValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleTextAlignEnumWrapper) -> AzStyleTextAlignValueEnumWrapper { AzStyleTextAlignValueEnumWrapper { inner: AzStyleTextAlignValue::Exact(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTextAlignValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTextAlignValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleTextAlignValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleTextAlignValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleTextAlignValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleTextAlignValue::Exact(v) => Ok(vec!["Exact".into_py(py), { let m: &AzStyleTextAlignEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextAlignValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTextAlignValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTextAlignValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTextColorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleTextColorValueEnumWrapper { AzStyleTextColorValueEnumWrapper { inner: AzStyleTextColorValue::Auto } }
    #[classattr]
    fn None() -> AzStyleTextColorValueEnumWrapper { AzStyleTextColorValueEnumWrapper { inner: AzStyleTextColorValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleTextColorValueEnumWrapper { AzStyleTextColorValueEnumWrapper { inner: AzStyleTextColorValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleTextColorValueEnumWrapper { AzStyleTextColorValueEnumWrapper { inner: AzStyleTextColorValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleTextColor) -> AzStyleTextColorValueEnumWrapper { AzStyleTextColorValueEnumWrapper { inner: AzStyleTextColorValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTextColorValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTextColorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleTextColorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleTextColorValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleTextColorValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleTextColorValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextColorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTextColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTextColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleWordSpacingValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleWordSpacingValueEnumWrapper { AzStyleWordSpacingValueEnumWrapper { inner: AzStyleWordSpacingValue::Auto } }
    #[classattr]
    fn None() -> AzStyleWordSpacingValueEnumWrapper { AzStyleWordSpacingValueEnumWrapper { inner: AzStyleWordSpacingValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleWordSpacingValueEnumWrapper { AzStyleWordSpacingValueEnumWrapper { inner: AzStyleWordSpacingValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleWordSpacingValueEnumWrapper { AzStyleWordSpacingValueEnumWrapper { inner: AzStyleWordSpacingValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleWordSpacing) -> AzStyleWordSpacingValueEnumWrapper { AzStyleWordSpacingValueEnumWrapper { inner: AzStyleWordSpacingValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleWordSpacingValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleWordSpacingValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleWordSpacingValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleWordSpacingValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleWordSpacingValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleWordSpacingValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleWordSpacingValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleWordSpacingValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleWordSpacingValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleOpacityValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleOpacityValueEnumWrapper { AzStyleOpacityValueEnumWrapper { inner: AzStyleOpacityValue::Auto } }
    #[classattr]
    fn None() -> AzStyleOpacityValueEnumWrapper { AzStyleOpacityValueEnumWrapper { inner: AzStyleOpacityValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleOpacityValueEnumWrapper { AzStyleOpacityValueEnumWrapper { inner: AzStyleOpacityValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleOpacityValueEnumWrapper { AzStyleOpacityValueEnumWrapper { inner: AzStyleOpacityValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleOpacity) -> AzStyleOpacityValueEnumWrapper { AzStyleOpacityValueEnumWrapper { inner: AzStyleOpacityValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleOpacityValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleOpacityValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleOpacityValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleOpacityValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleOpacityValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleOpacityValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleOpacityValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleOpacityValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleOpacityValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleTransformVecValueEnumWrapper { AzStyleTransformVecValueEnumWrapper { inner: AzStyleTransformVecValue::Auto } }
    #[classattr]
    fn None() -> AzStyleTransformVecValueEnumWrapper { AzStyleTransformVecValueEnumWrapper { inner: AzStyleTransformVecValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleTransformVecValueEnumWrapper { AzStyleTransformVecValueEnumWrapper { inner: AzStyleTransformVecValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleTransformVecValueEnumWrapper { AzStyleTransformVecValueEnumWrapper { inner: AzStyleTransformVecValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleTransformVec) -> AzStyleTransformVecValueEnumWrapper { AzStyleTransformVecValueEnumWrapper { inner: AzStyleTransformVecValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTransformVecValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTransformVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleTransformVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleTransformVecValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleTransformVecValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleTransformVecValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformOriginValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleTransformOriginValueEnumWrapper { AzStyleTransformOriginValueEnumWrapper { inner: AzStyleTransformOriginValue::Auto } }
    #[classattr]
    fn None() -> AzStyleTransformOriginValueEnumWrapper { AzStyleTransformOriginValueEnumWrapper { inner: AzStyleTransformOriginValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleTransformOriginValueEnumWrapper { AzStyleTransformOriginValueEnumWrapper { inner: AzStyleTransformOriginValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleTransformOriginValueEnumWrapper { AzStyleTransformOriginValueEnumWrapper { inner: AzStyleTransformOriginValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleTransformOrigin) -> AzStyleTransformOriginValueEnumWrapper { AzStyleTransformOriginValueEnumWrapper { inner: AzStyleTransformOriginValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTransformOriginValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTransformOriginValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleTransformOriginValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleTransformOriginValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleTransformOriginValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleTransformOriginValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformOriginValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformOriginValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformOriginValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylePerspectiveOriginValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStylePerspectiveOriginValueEnumWrapper { AzStylePerspectiveOriginValueEnumWrapper { inner: AzStylePerspectiveOriginValue::Auto } }
    #[classattr]
    fn None() -> AzStylePerspectiveOriginValueEnumWrapper { AzStylePerspectiveOriginValueEnumWrapper { inner: AzStylePerspectiveOriginValue::None } }
    #[classattr]
    fn Inherit() -> AzStylePerspectiveOriginValueEnumWrapper { AzStylePerspectiveOriginValueEnumWrapper { inner: AzStylePerspectiveOriginValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStylePerspectiveOriginValueEnumWrapper { AzStylePerspectiveOriginValueEnumWrapper { inner: AzStylePerspectiveOriginValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStylePerspectiveOrigin) -> AzStylePerspectiveOriginValueEnumWrapper { AzStylePerspectiveOriginValueEnumWrapper { inner: AzStylePerspectiveOriginValue::Exact(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStylePerspectiveOriginValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStylePerspectiveOriginValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStylePerspectiveOriginValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStylePerspectiveOriginValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStylePerspectiveOriginValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStylePerspectiveOriginValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStylePerspectiveOriginValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StylePerspectiveOriginValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StylePerspectiveOriginValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackfaceVisibilityValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBackfaceVisibilityValueEnumWrapper { AzStyleBackfaceVisibilityValueEnumWrapper { inner: AzStyleBackfaceVisibilityValue::Auto } }
    #[classattr]
    fn None() -> AzStyleBackfaceVisibilityValueEnumWrapper { AzStyleBackfaceVisibilityValueEnumWrapper { inner: AzStyleBackfaceVisibilityValue::None } }
    #[classattr]
    fn Inherit() -> AzStyleBackfaceVisibilityValueEnumWrapper { AzStyleBackfaceVisibilityValueEnumWrapper { inner: AzStyleBackfaceVisibilityValue::Inherit } }
    #[classattr]
    fn Initial() -> AzStyleBackfaceVisibilityValueEnumWrapper { AzStyleBackfaceVisibilityValueEnumWrapper { inner: AzStyleBackfaceVisibilityValue::Initial } }
    #[staticmethod]
    fn Exact(v: AzStyleBackfaceVisibilityEnumWrapper) -> AzStyleBackfaceVisibilityValueEnumWrapper { AzStyleBackfaceVisibilityValueEnumWrapper { inner: AzStyleBackfaceVisibilityValue::Exact(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackfaceVisibilityValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackfaceVisibilityValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBackfaceVisibilityValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBackfaceVisibilityValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBackfaceVisibilityValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBackfaceVisibilityValue::Exact(v) => Ok(vec!["Exact".into_py(py), { let m: &AzStyleBackfaceVisibilityEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackfaceVisibilityValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackfaceVisibilityValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackfaceVisibilityValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyEnumWrapper {
    #[staticmethod]
    fn TextColor(v: AzStyleTextColorValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::TextColor(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn FontSize(v: AzStyleFontSizeValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::FontSize(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn FontFamily(v: AzStyleFontFamilyVecValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::FontFamily(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn TextAlign(v: AzStyleTextAlignValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::TextAlign(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn LetterSpacing(v: AzStyleLetterSpacingValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::LetterSpacing(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn LineHeight(v: AzStyleLineHeightValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::LineHeight(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn WordSpacing(v: AzStyleWordSpacingValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::WordSpacing(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn TabWidth(v: AzStyleTabWidthValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::TabWidth(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Cursor(v: AzStyleCursorValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::Cursor(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Display(v: AzLayoutDisplayValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::Display(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Float(v: AzLayoutFloatValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::Float(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BoxSizing(v: AzLayoutBoxSizingValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxSizing(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Width(v: AzLayoutWidthValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::Width(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Height(v: AzLayoutHeightValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::Height(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn MinWidth(v: AzLayoutMinWidthValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::MinWidth(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn MinHeight(v: AzLayoutMinHeightValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::MinHeight(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn MaxWidth(v: AzLayoutMaxWidthValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::MaxWidth(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn MaxHeight(v: AzLayoutMaxHeightValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::MaxHeight(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Position(v: AzLayoutPositionValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::Position(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Top(v: AzLayoutTopValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::Top(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Right(v: AzLayoutRightValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::Right(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Left(v: AzLayoutLeftValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::Left(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Bottom(v: AzLayoutBottomValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::Bottom(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn FlexWrap(v: AzLayoutFlexWrapValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::FlexWrap(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn FlexDirection(v: AzLayoutFlexDirectionValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::FlexDirection(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn FlexGrow(v: AzLayoutFlexGrowValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::FlexGrow(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn FlexShrink(v: AzLayoutFlexShrinkValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::FlexShrink(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn JustifyContent(v: AzLayoutJustifyContentValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::JustifyContent(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn AlignItems(v: AzLayoutAlignItemsValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::AlignItems(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn AlignContent(v: AzLayoutAlignContentValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::AlignContent(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BackgroundContent(v: AzStyleBackgroundContentVecValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BackgroundContent(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BackgroundPosition(v: AzStyleBackgroundPositionVecValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BackgroundPosition(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BackgroundSize(v: AzStyleBackgroundSizeVecValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BackgroundSize(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BackgroundRepeat(v: AzStyleBackgroundRepeatVecValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BackgroundRepeat(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn OverflowX(v: AzLayoutOverflowValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::OverflowX(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn OverflowY(v: AzLayoutOverflowValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::OverflowY(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn PaddingTop(v: AzLayoutPaddingTopValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::PaddingTop(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn PaddingLeft(v: AzLayoutPaddingLeftValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::PaddingLeft(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn PaddingRight(v: AzLayoutPaddingRightValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::PaddingRight(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn PaddingBottom(v: AzLayoutPaddingBottomValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::PaddingBottom(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn MarginTop(v: AzLayoutMarginTopValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::MarginTop(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn MarginLeft(v: AzLayoutMarginLeftValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::MarginLeft(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn MarginRight(v: AzLayoutMarginRightValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::MarginRight(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn MarginBottom(v: AzLayoutMarginBottomValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::MarginBottom(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BorderTopLeftRadius(v: AzStyleBorderTopLeftRadiusValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderTopLeftRadius(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BorderTopRightRadius(v: AzStyleBorderTopRightRadiusValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderTopRightRadius(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BorderBottomLeftRadius(v: AzStyleBorderBottomLeftRadiusValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderBottomLeftRadius(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BorderBottomRightRadius(v: AzStyleBorderBottomRightRadiusValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderBottomRightRadius(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BorderTopColor(v: AzStyleBorderTopColorValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderTopColor(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BorderRightColor(v: AzStyleBorderRightColorValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderRightColor(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BorderLeftColor(v: AzStyleBorderLeftColorValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderLeftColor(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BorderBottomColor(v: AzStyleBorderBottomColorValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderBottomColor(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BorderTopStyle(v: AzStyleBorderTopStyleValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderTopStyle(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BorderRightStyle(v: AzStyleBorderRightStyleValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderRightStyle(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BorderLeftStyle(v: AzStyleBorderLeftStyleValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderLeftStyle(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BorderBottomStyle(v: AzStyleBorderBottomStyleValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderBottomStyle(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BorderTopWidth(v: AzLayoutBorderTopWidthValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderTopWidth(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BorderRightWidth(v: AzLayoutBorderRightWidthValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderRightWidth(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BorderLeftWidth(v: AzLayoutBorderLeftWidthValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderLeftWidth(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BorderBottomWidth(v: AzLayoutBorderBottomWidthValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderBottomWidth(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BoxShadowLeft(v: AzStyleBoxShadowValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxShadowLeft(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BoxShadowRight(v: AzStyleBoxShadowValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxShadowRight(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BoxShadowTop(v: AzStyleBoxShadowValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxShadowTop(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BoxShadowBottom(v: AzStyleBoxShadowValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxShadowBottom(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn ScrollbarStyle(v: AzScrollbarStyleValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::ScrollbarStyle(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Opacity(v: AzStyleOpacityValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::Opacity(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn Transform(v: AzStyleTransformVecValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::Transform(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn TransformOrigin(v: AzStyleTransformOriginValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::TransformOrigin(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn PerspectiveOrigin(v: AzStylePerspectiveOriginValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::PerspectiveOrigin(unsafe { mem::transmute(v) }) } }
    #[staticmethod]
    fn BackfaceVisibility(v: AzStyleBackfaceVisibilityValueEnumWrapper) -> AzCssPropertyEnumWrapper { AzCssPropertyEnumWrapper { inner: AzCssProperty::BackfaceVisibility(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssProperty;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssProperty::TextColor(v) => Ok(vec!["TextColor".into_py(py), { let m: &AzStyleTextColorValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::FontSize(v) => Ok(vec!["FontSize".into_py(py), { let m: &AzStyleFontSizeValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::FontFamily(v) => Ok(vec!["FontFamily".into_py(py), { let m: &AzStyleFontFamilyVecValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::TextAlign(v) => Ok(vec!["TextAlign".into_py(py), { let m: &AzStyleTextAlignValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::LetterSpacing(v) => Ok(vec!["LetterSpacing".into_py(py), { let m: &AzStyleLetterSpacingValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::LineHeight(v) => Ok(vec!["LineHeight".into_py(py), { let m: &AzStyleLineHeightValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::WordSpacing(v) => Ok(vec!["WordSpacing".into_py(py), { let m: &AzStyleWordSpacingValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::TabWidth(v) => Ok(vec!["TabWidth".into_py(py), { let m: &AzStyleTabWidthValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::Cursor(v) => Ok(vec!["Cursor".into_py(py), { let m: &AzStyleCursorValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::Display(v) => Ok(vec!["Display".into_py(py), { let m: &AzLayoutDisplayValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::Float(v) => Ok(vec!["Float".into_py(py), { let m: &AzLayoutFloatValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BoxSizing(v) => Ok(vec!["BoxSizing".into_py(py), { let m: &AzLayoutBoxSizingValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::Width(v) => Ok(vec!["Width".into_py(py), { let m: &AzLayoutWidthValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::Height(v) => Ok(vec!["Height".into_py(py), { let m: &AzLayoutHeightValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::MinWidth(v) => Ok(vec!["MinWidth".into_py(py), { let m: &AzLayoutMinWidthValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::MinHeight(v) => Ok(vec!["MinHeight".into_py(py), { let m: &AzLayoutMinHeightValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::MaxWidth(v) => Ok(vec!["MaxWidth".into_py(py), { let m: &AzLayoutMaxWidthValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::MaxHeight(v) => Ok(vec!["MaxHeight".into_py(py), { let m: &AzLayoutMaxHeightValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::Position(v) => Ok(vec!["Position".into_py(py), { let m: &AzLayoutPositionValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::Top(v) => Ok(vec!["Top".into_py(py), { let m: &AzLayoutTopValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::Right(v) => Ok(vec!["Right".into_py(py), { let m: &AzLayoutRightValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::Left(v) => Ok(vec!["Left".into_py(py), { let m: &AzLayoutLeftValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::Bottom(v) => Ok(vec!["Bottom".into_py(py), { let m: &AzLayoutBottomValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::FlexWrap(v) => Ok(vec!["FlexWrap".into_py(py), { let m: &AzLayoutFlexWrapValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::FlexDirection(v) => Ok(vec!["FlexDirection".into_py(py), { let m: &AzLayoutFlexDirectionValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::FlexGrow(v) => Ok(vec!["FlexGrow".into_py(py), { let m: &AzLayoutFlexGrowValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::FlexShrink(v) => Ok(vec!["FlexShrink".into_py(py), { let m: &AzLayoutFlexShrinkValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::JustifyContent(v) => Ok(vec!["JustifyContent".into_py(py), { let m: &AzLayoutJustifyContentValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::AlignItems(v) => Ok(vec!["AlignItems".into_py(py), { let m: &AzLayoutAlignItemsValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::AlignContent(v) => Ok(vec!["AlignContent".into_py(py), { let m: &AzLayoutAlignContentValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BackgroundContent(v) => Ok(vec!["BackgroundContent".into_py(py), { let m: &AzStyleBackgroundContentVecValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BackgroundPosition(v) => Ok(vec!["BackgroundPosition".into_py(py), { let m: &AzStyleBackgroundPositionVecValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BackgroundSize(v) => Ok(vec!["BackgroundSize".into_py(py), { let m: &AzStyleBackgroundSizeVecValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BackgroundRepeat(v) => Ok(vec!["BackgroundRepeat".into_py(py), { let m: &AzStyleBackgroundRepeatVecValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::OverflowX(v) => Ok(vec!["OverflowX".into_py(py), { let m: &AzLayoutOverflowValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::OverflowY(v) => Ok(vec!["OverflowY".into_py(py), { let m: &AzLayoutOverflowValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::PaddingTop(v) => Ok(vec!["PaddingTop".into_py(py), { let m: &AzLayoutPaddingTopValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::PaddingLeft(v) => Ok(vec!["PaddingLeft".into_py(py), { let m: &AzLayoutPaddingLeftValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::PaddingRight(v) => Ok(vec!["PaddingRight".into_py(py), { let m: &AzLayoutPaddingRightValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::PaddingBottom(v) => Ok(vec!["PaddingBottom".into_py(py), { let m: &AzLayoutPaddingBottomValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::MarginTop(v) => Ok(vec!["MarginTop".into_py(py), { let m: &AzLayoutMarginTopValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::MarginLeft(v) => Ok(vec!["MarginLeft".into_py(py), { let m: &AzLayoutMarginLeftValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::MarginRight(v) => Ok(vec!["MarginRight".into_py(py), { let m: &AzLayoutMarginRightValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::MarginBottom(v) => Ok(vec!["MarginBottom".into_py(py), { let m: &AzLayoutMarginBottomValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BorderTopLeftRadius(v) => Ok(vec!["BorderTopLeftRadius".into_py(py), { let m: &AzStyleBorderTopLeftRadiusValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BorderTopRightRadius(v) => Ok(vec!["BorderTopRightRadius".into_py(py), { let m: &AzStyleBorderTopRightRadiusValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BorderBottomLeftRadius(v) => Ok(vec!["BorderBottomLeftRadius".into_py(py), { let m: &AzStyleBorderBottomLeftRadiusValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BorderBottomRightRadius(v) => Ok(vec!["BorderBottomRightRadius".into_py(py), { let m: &AzStyleBorderBottomRightRadiusValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BorderTopColor(v) => Ok(vec!["BorderTopColor".into_py(py), { let m: &AzStyleBorderTopColorValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BorderRightColor(v) => Ok(vec!["BorderRightColor".into_py(py), { let m: &AzStyleBorderRightColorValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BorderLeftColor(v) => Ok(vec!["BorderLeftColor".into_py(py), { let m: &AzStyleBorderLeftColorValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BorderBottomColor(v) => Ok(vec!["BorderBottomColor".into_py(py), { let m: &AzStyleBorderBottomColorValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BorderTopStyle(v) => Ok(vec!["BorderTopStyle".into_py(py), { let m: &AzStyleBorderTopStyleValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BorderRightStyle(v) => Ok(vec!["BorderRightStyle".into_py(py), { let m: &AzStyleBorderRightStyleValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BorderLeftStyle(v) => Ok(vec!["BorderLeftStyle".into_py(py), { let m: &AzStyleBorderLeftStyleValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BorderBottomStyle(v) => Ok(vec!["BorderBottomStyle".into_py(py), { let m: &AzStyleBorderBottomStyleValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BorderTopWidth(v) => Ok(vec!["BorderTopWidth".into_py(py), { let m: &AzLayoutBorderTopWidthValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BorderRightWidth(v) => Ok(vec!["BorderRightWidth".into_py(py), { let m: &AzLayoutBorderRightWidthValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BorderLeftWidth(v) => Ok(vec!["BorderLeftWidth".into_py(py), { let m: &AzLayoutBorderLeftWidthValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BorderBottomWidth(v) => Ok(vec!["BorderBottomWidth".into_py(py), { let m: &AzLayoutBorderBottomWidthValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BoxShadowLeft(v) => Ok(vec!["BoxShadowLeft".into_py(py), { let m: &AzStyleBoxShadowValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BoxShadowRight(v) => Ok(vec!["BoxShadowRight".into_py(py), { let m: &AzStyleBoxShadowValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BoxShadowTop(v) => Ok(vec!["BoxShadowTop".into_py(py), { let m: &AzStyleBoxShadowValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BoxShadowBottom(v) => Ok(vec!["BoxShadowBottom".into_py(py), { let m: &AzStyleBoxShadowValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::ScrollbarStyle(v) => Ok(vec!["ScrollbarStyle".into_py(py), { let m: &AzScrollbarStyleValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::Opacity(v) => Ok(vec!["Opacity".into_py(py), { let m: &AzStyleOpacityValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::Transform(v) => Ok(vec!["Transform".into_py(py), { let m: &AzStyleTransformVecValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::TransformOrigin(v) => Ok(vec!["TransformOrigin".into_py(py), { let m: &AzStyleTransformOriginValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::PerspectiveOrigin(v) => Ok(vec!["PerspectiveOrigin".into_py(py), { let m: &AzStylePerspectiveOriginValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
            AzCssProperty::BackfaceVisibility(v) => Ok(vec!["BackfaceVisibility".into_py(py), { let m: &AzStyleBackfaceVisibilityValueEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssProperty = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssProperty = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzButton {
    #[new]
    fn new(label: String) -> AzButton {
        let label = pystring_to_azstring(&label);
        unsafe { mem::transmute(crate::AzButton_new(
            mem::transmute(label),
        )) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzButton_dom(
            mem::transmute(self),
        )) }
    }
    // impl Button {

    fn set_on_click(&mut self, py: Python, data: PyObject, callback: PyObject) -> Result<(), PyErr> { // RefAny<CallbackTy>
        use pyo3::type_object::PyTypeInfo;

        if data.as_ref(py.clone()).is_callable() {
            return Err(PyException::new_err(format!("ERROR in Button.set_on_click: - argument \"data\" is a function callback, expected class")));
        }

        let cb_any = callback.as_ref(py);
        if !cb_any.is_callable() {
            let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
            return Err(PyException::new_err(format!("ERROR in Button.set_on_click: - argument \"callback\" is of type \"{}\", expected function", type_name)));
        }

        let callback_refany = azul_impl::callbacks::RefAny::new(CallbackTy {
            _py_callback: Some(callback),
            _py_data: Some(data),
        });

        unsafe {
            crate::AzButton_setOnClick(
                mem::transmute(self),
                callback_refany,
                invoke_python_callback
            );
        }

        Ok(())
    }

    fn with_on_click(&mut self, py: Python, data: PyObject, callback: PyObject) -> Result<Self, PyErr> { // RefAny<CallbackTy>
        self.set_on_click(py, data, callback)?;
        let d: &mut crate::widgets::button::Button = unsafe { mem::transmute(self) };
        Ok(unsafe { mem::transmute(d.swap_with_default()) })
    }
}

#[pyproto]
impl PyObjectProtocol for AzButton {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::button::Button = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::button::Button = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzButtonOnClick {
    #[new]
    fn __new__(data: AzRefAny, callback: AzCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzButtonOnClick {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::button::ButtonOnClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::button::ButtonOnClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBox {
    #[new]
    fn new(checked: bool) -> AzCheckBox {
        unsafe { mem::transmute(crate::AzCheckBox_new(
            mem::transmute(checked),
        )) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzCheckBox_dom(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCheckBox {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::check_box::CheckBox = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::check_box::CheckBox = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBoxStateWrapper {
    #[new]
    fn __new__(inner: AzCheckBoxState, on_toggle: AzOptionCheckBoxOnToggleEnumWrapper) -> Self {
        Self {
            inner,
            on_toggle,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzCheckBoxStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::check_box::CheckBoxStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::check_box::CheckBoxStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBoxOnToggle {
    #[new]
    fn __new__(data: AzRefAny, callback: AzCheckBoxOnToggleCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzCheckBoxOnToggle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::check_box::CheckBoxOnToggle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::check_box::CheckBoxOnToggle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBoxOnToggleCallback {
}

#[pyproto]
impl PyObjectProtocol for AzCheckBoxOnToggleCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::check_box::CheckBoxOnToggleCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::check_box::CheckBoxOnToggleCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBoxState {
    #[new]
    fn __new__(checked: bool) -> Self {
        Self {
            checked,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzCheckBoxState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::check_box::CheckBoxState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::check_box::CheckBoxState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLabel {
    #[new]
    fn new(text: String) -> AzLabel {
        let text = pystring_to_azstring(&text);
        unsafe { mem::transmute(crate::AzLabel_new(
            mem::transmute(text),
        )) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzLabel_dom(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLabel {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::label::Label = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::label::Label = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInput {
    #[new]
    fn new(color: AzColorU) -> AzColorInput {
        unsafe { mem::transmute(crate::AzColorInput_new(
            mem::transmute(color),
        )) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzColorInput_dom(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzColorInput {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::color_input::ColorInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::color_input::ColorInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInputStateWrapper {
    #[new]
    fn __new__(inner: AzColorInputState, title: AzString, on_value_change: AzOptionColorInputOnValueChangeEnumWrapper) -> Self {
        Self {
            inner,
            title,
            on_value_change,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzColorInputStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::color_input::ColorInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::color_input::ColorInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInputState {
    #[new]
    fn __new__(color: AzColorU) -> Self {
        Self {
            color,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzColorInputState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::color_input::ColorInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::color_input::ColorInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInputOnValueChange {
    #[new]
    fn __new__(data: AzRefAny, callback: AzColorInputOnValueChangeCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzColorInputOnValueChange {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::color_input::ColorInputOnValueChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::color_input::ColorInputOnValueChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInputOnValueChangeCallback {
}

#[pyproto]
impl PyObjectProtocol for AzColorInputOnValueChangeCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::color_input::ColorInputOnValueChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::color_input::ColorInputOnValueChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInput {
    #[new]
    fn new(initial_text: String) -> AzTextInput {
        let initial_text = pystring_to_azstring(&initial_text);
        unsafe { mem::transmute(crate::AzTextInput_new(
            mem::transmute(initial_text),
        )) }
    }
    fn set_placeholder_style(&mut self, placeholder_style: AzNodeDataInlineCssPropertyVec) -> () {
        unsafe { mem::transmute(crate::AzTextInput_setPlaceholderStyle(
            mem::transmute(self),
            mem::transmute(placeholder_style),
        )) }
    }
    fn with_placeholder_style(&mut self, placeholder_style: AzNodeDataInlineCssPropertyVec) -> AzTextInput {
        unsafe { mem::transmute(crate::AzTextInput_withPlaceholderStyle(
            mem::transmute(self),
            mem::transmute(placeholder_style),
        )) }
    }
    fn set_container_style(&mut self, container_style: AzNodeDataInlineCssPropertyVec) -> () {
        unsafe { mem::transmute(crate::AzTextInput_setContainerStyle(
            mem::transmute(self),
            mem::transmute(container_style),
        )) }
    }
    fn with_container_style(&mut self, container_style: AzNodeDataInlineCssPropertyVec) -> AzTextInput {
        unsafe { mem::transmute(crate::AzTextInput_withContainerStyle(
            mem::transmute(self),
            mem::transmute(container_style),
        )) }
    }
    fn set_label_style(&mut self, label_style: AzNodeDataInlineCssPropertyVec) -> () {
        unsafe { mem::transmute(crate::AzTextInput_setLabelStyle(
            mem::transmute(self),
            mem::transmute(label_style),
        )) }
    }
    fn with_label_style(&mut self, label_style: AzNodeDataInlineCssPropertyVec) -> AzTextInput {
        unsafe { mem::transmute(crate::AzTextInput_withLabelStyle(
            mem::transmute(self),
            mem::transmute(label_style),
        )) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzTextInput_dom(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextInput {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputStateWrapper {
    #[new]
    fn __new__(inner: AzTextInputState, on_text_input: AzOptionTextInputOnTextInputEnumWrapper, on_virtual_key_down: AzOptionTextInputOnVirtualKeyDownEnumWrapper, on_focus_lost: AzOptionTextInputOnFocusLostEnumWrapper, update_text_input_before_calling_focus_lost_fn: bool, update_text_input_before_calling_vk_down_fn: bool, cursor_animation: AzOptionTimerIdEnumWrapper) -> Self {
        Self {
            inner,
            on_text_input,
            on_virtual_key_down,
            on_focus_lost,
            update_text_input_before_calling_focus_lost_fn,
            update_text_input_before_calling_vk_down_fn,
            cursor_animation,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzTextInputStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputState {
    #[new]
    fn __new__(text: AzU32Vec, placeholder: AzOptionStringEnumWrapper, max_len: usize, selection: AzOptionTextInputSelectionEnumWrapper, cursor_pos: usize) -> Self {
        Self {
            text,
            placeholder,
            max_len,
            selection,
            cursor_pos,
        }
    }

    fn get_text(&self) -> String {
        az_string_to_py_string(unsafe { mem::transmute(crate::AzTextInputState_getText(
            mem::transmute(self),
        )) })
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextInputState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputSelectionEnumWrapper {
    #[classattr]
    fn All() -> AzTextInputSelectionEnumWrapper { AzTextInputSelectionEnumWrapper { inner: AzTextInputSelection::All } }
    #[staticmethod]
    fn FromTo(v: AzTextInputSelectionRange) -> AzTextInputSelectionEnumWrapper { AzTextInputSelectionEnumWrapper { inner: AzTextInputSelection::FromTo(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzTextInputSelection;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTextInputSelection::All => Ok(vec!["All".into_py(py), ().into_py(py)]),
            AzTextInputSelection::FromTo(v) => Ok(vec!["FromTo".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextInputSelectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputSelection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputSelection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputSelectionRange {
    #[new]
    fn __new__(from: usize, to: usize) -> Self {
        Self {
            from,
            to,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzTextInputSelectionRange {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputSelectionRange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputSelectionRange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnTextInput {
    #[new]
    fn __new__(data: AzRefAny, callback: AzTextInputOnTextInputCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnTextInput {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputOnTextInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputOnTextInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnTextInputCallback {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnTextInputCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputOnTextInputCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputOnTextInputCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnVirtualKeyDown {
    #[new]
    fn __new__(data: AzRefAny, callback: AzTextInputOnVirtualKeyDownCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnVirtualKeyDown {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputOnVirtualKeyDown = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputOnVirtualKeyDown = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnVirtualKeyDownCallback {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnVirtualKeyDownCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputOnVirtualKeyDownCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputOnVirtualKeyDownCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnFocusLost {
    #[new]
    fn __new__(data: AzRefAny, callback: AzTextInputOnFocusLostCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnFocusLost {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputOnFocusLost = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputOnFocusLost = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnFocusLostCallback {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnFocusLostCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputOnFocusLostCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputOnFocusLostCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnTextInputReturn {
    #[new]
    fn __new__(update: AzUpdateEnumWrapper, valid: AzTextInputValidEnumWrapper) -> Self {
        Self {
            update,
            valid,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzOnTextInputReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OnTextInputReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OnTextInputReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputValidEnumWrapper {
    #[classattr]
    fn Yes() -> AzTextInputValidEnumWrapper { AzTextInputValidEnumWrapper { inner: AzTextInputValid::Yes } }
    #[classattr]
    fn No() -> AzTextInputValidEnumWrapper { AzTextInputValidEnumWrapper { inner: AzTextInputValid::No } }
}

#[pyproto]
impl PyObjectProtocol for AzTextInputValidEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputValid = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::TextInputValid = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzTextInputValidEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzNumberInput {
    #[new]
    fn new(number: f32) -> AzNumberInput {
        unsafe { mem::transmute(crate::AzNumberInput_new(
            mem::transmute(number),
        )) }
    }
    fn set_placeholder_style(&mut self, style: AzNodeDataInlineCssPropertyVec) -> () {
        unsafe { mem::transmute(crate::AzNumberInput_setPlaceholderStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn with_placeholder_style(&mut self, style: AzNodeDataInlineCssPropertyVec) -> AzNumberInput {
        unsafe { mem::transmute(crate::AzNumberInput_withPlaceholderStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn set_container_style(&mut self, style: AzNodeDataInlineCssPropertyVec) -> () {
        unsafe { mem::transmute(crate::AzNumberInput_setContainerStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn with_container_style(&mut self, style: AzNodeDataInlineCssPropertyVec) -> AzNumberInput {
        unsafe { mem::transmute(crate::AzNumberInput_withContainerStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn set_label_style(&mut self, style: AzNodeDataInlineCssPropertyVec) -> () {
        unsafe { mem::transmute(crate::AzNumberInput_setLabelStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn with_label_style(&mut self, style: AzNodeDataInlineCssPropertyVec) -> AzNumberInput {
        unsafe { mem::transmute(crate::AzNumberInput_withLabelStyle(
            mem::transmute(self),
            mem::transmute(style),
        )) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzNumberInput_dom(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNumberInput {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::NumberInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::NumberInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputStateWrapper {
    #[new]
    fn __new__(inner: AzNumberInputState, on_value_change: AzOptionNumberInputOnValueChangeEnumWrapper, on_focus_lost: AzOptionNumberInputOnFocusLostEnumWrapper) -> Self {
        Self {
            inner,
            on_value_change,
            on_focus_lost,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNumberInputStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::NumberInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::NumberInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputState {
    #[new]
    fn __new__(previous: f32, number: f32, min: f32, max: f32) -> Self {
        Self {
            previous,
            number,
            min,
            max,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNumberInputState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::NumberInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::NumberInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputOnValueChange {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNumberInputOnValueChangeCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNumberInputOnValueChange {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::NumberInputOnValueChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::NumberInputOnValueChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputOnValueChangeCallback {
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputOnValueChangeCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::NumberInputOnValueChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::NumberInputOnValueChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputOnFocusLost {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNumberInputOnFocusLostCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNumberInputOnFocusLost {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::NumberInputOnFocusLost = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::NumberInputOnFocusLost = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputOnFocusLostCallback {
    #[new]
    fn __new__() -> Self {
        Self {
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNumberInputOnFocusLostCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::NumberInputOnFocusLostCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::NumberInputOnFocusLostCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzProgressBar {
    #[new]
    fn new(percent_done: f32) -> AzProgressBar {
        unsafe { mem::transmute(crate::AzProgressBar_new(
            mem::transmute(percent_done),
        )) }
    }
    fn set_height(&mut self, height: AzPixelValue) -> () {
        unsafe { mem::transmute(crate::AzProgressBar_setHeight(
            mem::transmute(self),
            mem::transmute(height),
        )) }
    }
    fn with_height(&mut self, height: AzPixelValue) -> AzProgressBar {
        unsafe { mem::transmute(crate::AzProgressBar_withHeight(
            mem::transmute(self),
            mem::transmute(height),
        )) }
    }
    fn set_container_background(&mut self, background: AzStyleBackgroundContentVec) -> () {
        unsafe { mem::transmute(crate::AzProgressBar_setContainerBackground(
            mem::transmute(self),
            mem::transmute(background),
        )) }
    }
    fn with_container_style(&mut self, background: AzStyleBackgroundContentVec) -> AzProgressBar {
        unsafe { mem::transmute(crate::AzProgressBar_withContainerStyle(
            mem::transmute(self),
            mem::transmute(background),
        )) }
    }
    fn set_bar_background(&mut self, background: AzStyleBackgroundContentVec) -> () {
        unsafe { mem::transmute(crate::AzProgressBar_setBarBackground(
            mem::transmute(self),
            mem::transmute(background),
        )) }
    }
    fn with_bar_background(&mut self, background: AzStyleBackgroundContentVec) -> AzProgressBar {
        unsafe { mem::transmute(crate::AzProgressBar_withBarBackground(
            mem::transmute(self),
            mem::transmute(background),
        )) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzProgressBar_dom(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzProgressBar {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::progressbar::ProgressBar = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::progressbar::ProgressBar = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzProgressBarState {
    #[new]
    fn __new__(percent_done: f32, display_percentage: bool) -> Self {
        Self {
            percent_done,
            display_percentage,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzProgressBarState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::progressbar::ProgressBarState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::progressbar::ProgressBarState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabContainer {
    #[new]
    fn new(tabs: AzTabVec) -> AzTabContainer {
        unsafe { mem::transmute(crate::AzTabContainer_new(
            mem::transmute(tabs),
        )) }
    }
    fn set_active_tab(&mut self, active_tab: usize) -> () {
        unsafe { mem::transmute(crate::AzTabContainer_setActiveTab(
            mem::transmute(self),
            mem::transmute(active_tab),
        )) }
    }
    fn with_active_tab(&mut self, active_tab: usize) -> AzTabContainer {
        unsafe { mem::transmute(crate::AzTabContainer_withActiveTab(
            mem::transmute(self),
            mem::transmute(active_tab),
        )) }
    }
    fn set_padding(&mut self, has_padding: bool) -> () {
        unsafe { mem::transmute(crate::AzTabContainer_setPadding(
            mem::transmute(self),
            mem::transmute(has_padding),
        )) }
    }
    fn with_padding(&mut self, has_padding: bool) -> AzTabContainer {
        unsafe { mem::transmute(crate::AzTabContainer_withPadding(
            mem::transmute(self),
            mem::transmute(has_padding),
        )) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzTabContainer_dom(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTabContainer {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::tabs::TabContainer = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::tabs::TabContainer = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTab {
    #[new]
    fn __new__(title: AzString, content: AzDom) -> Self {
        Self {
            title,
            content,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzTab {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::tabs::Tab = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::tabs::Tab = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFrame {
    #[new]
    fn new(title: String, dom: AzDom) -> AzFrame {
        let title = pystring_to_azstring(&title);
        unsafe { mem::transmute(crate::AzFrame_new(
            mem::transmute(title),
            mem::transmute(dom),
        )) }
    }
    fn set_flex_grow(&mut self, flex_grow: f32) -> () {
        unsafe { mem::transmute(crate::AzFrame_setFlexGrow(
            mem::transmute(self),
            mem::transmute(flex_grow),
        )) }
    }
    fn with_flex_grow(&mut self, flex_grow: f32) -> AzFrame {
        unsafe { mem::transmute(crate::AzFrame_withFlexGrow(
            mem::transmute(self),
            mem::transmute(flex_grow),
        )) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzFrame_dom(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFrame {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::frame::Frame = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::frame::Frame = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraph {
    #[new]
    fn __new__(node_types: AzNodeTypeIdInfoMapVec, input_output_types: AzInputOutputTypeIdInfoMapVec, nodes: AzNodeIdNodeMapVec, allow_multiple_root_nodes: bool, offset: AzLogicalPosition, style: AzNodeGraphStyleEnumWrapper, callbacks: AzNodeGraphCallbacks, add_node_str: AzString) -> Self {
        Self {
            node_types,
            input_output_types,
            nodes,
            allow_multiple_root_nodes,
            offset,
            style,
            callbacks,
            add_node_str,
        }
    }

    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzNodeGraph_dom(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraph {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeGraph = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeGraph = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeIdInfoMap {
    #[new]
    fn __new__(node_type_id: AzNodeTypeId, node_type_info: AzNodeTypeInfo) -> Self {
        Self {
            node_type_id,
            node_type_info,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeIdInfoMap {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeIdInfoMap {
    #[new]
    fn __new__(io_type_id: AzInputOutputTypeId, io_info: AzInputOutputInfo) -> Self {
        Self {
            io_type_id,
            io_info,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeIdInfoMap {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdNodeMap {
    #[new]
    fn __new__(node_id: AzNodeGraphNodeId, node: AzNode) -> Self {
        Self {
            node_id,
            node,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeIdNodeMap {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeIdNodeMap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeIdNodeMap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphStyleEnumWrapper {
    #[classattr]
    fn Default() -> AzNodeGraphStyleEnumWrapper { AzNodeGraphStyleEnumWrapper { inner: AzNodeGraphStyle::Default } }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphStyleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeGraphStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeGraphStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzNodeGraphStyleEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzNodeGraphCallbacks {
    #[new]
    fn __new__(on_node_added: AzOptionNodeGraphOnNodeAddedEnumWrapper, on_node_removed: AzOptionNodeGraphOnNodeRemovedEnumWrapper, on_node_dragged: AzOptionNodeGraphOnNodeDraggedEnumWrapper, on_node_graph_dragged: AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper, on_node_connected: AzOptionNodeGraphOnNodeConnectedEnumWrapper, on_node_input_disconnected: AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper, on_node_output_disconnected: AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper, on_node_field_edited: AzOptionNodeGraphOnNodeFieldEditedEnumWrapper) -> Self {
        Self {
            on_node_added,
            on_node_removed,
            on_node_dragged,
            on_node_graph_dragged,
            on_node_connected,
            on_node_input_disconnected,
            on_node_output_disconnected,
            on_node_field_edited,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphCallbacks {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeGraphCallbacks = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeGraphCallbacks = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeAddedCallback {
    #[new]
    fn __new__() -> Self {
        Self {
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeAddedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeAddedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeAddedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeAdded {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNodeGraphOnNodeAddedCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeAdded {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeAdded = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeAdded = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeRemovedCallback {
    #[new]
    fn __new__() -> Self {
        Self {
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeRemovedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeRemovedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeRemovedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeRemoved {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNodeGraphOnNodeRemovedCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeRemoved {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeRemoved = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeRemoved = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeGraphDraggedCallback {
    #[new]
    fn __new__() -> Self {
        Self {
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeGraphDraggedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeGraphDraggedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeGraphDraggedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeGraphDragged {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNodeGraphOnNodeGraphDraggedCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeGraphDragged {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeGraphDragged = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeGraphDragged = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeDraggedCallback {
    #[new]
    fn __new__() -> Self {
        Self {
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeDraggedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeDraggedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeDraggedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeDragged {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNodeGraphOnNodeDraggedCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeDragged {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeDragged = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeDragged = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeConnectedCallback {
    #[new]
    fn __new__() -> Self {
        Self {
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeConnectedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeConnectedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeConnectedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeConnected {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNodeGraphOnNodeConnectedCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeConnected {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeConnected = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeConnected = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeInputDisconnectedCallback {
    #[new]
    fn __new__() -> Self {
        Self {
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeInputDisconnectedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeInputDisconnectedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeInputDisconnectedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeInputDisconnected {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNodeGraphOnNodeInputDisconnectedCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeInputDisconnected {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeInputDisconnected = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeInputDisconnected = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeOutputDisconnectedCallback {
    #[new]
    fn __new__() -> Self {
        Self {
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeOutputDisconnectedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeOutputDisconnectedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeOutputDisconnectedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeOutputDisconnected {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNodeGraphOnNodeOutputDisconnectedCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeOutputDisconnected {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeOutputDisconnected = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeOutputDisconnected = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeFieldEditedCallback {
    #[new]
    fn __new__() -> Self {
        Self {
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeFieldEditedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeFieldEditedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeFieldEditedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeFieldEdited {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNodeGraphOnNodeFieldEditedCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeFieldEdited {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeFieldEdited = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OnNodeFieldEdited = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeId {
    #[new]
    fn __new__(inner: u64) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeId {
    #[new]
    fn __new__(inner: u64) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphNodeId {
    #[new]
    fn __new__(inner: u64) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphNodeId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeGraphNodeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeGraphNodeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNode {
    #[new]
    fn __new__(node_type: AzNodeTypeId, position: AzNodePosition, fields: AzNodeTypeFieldVec, connect_in: AzInputConnectionVec, connect_out: AzOutputConnectionVec) -> Self {
        Self {
            node_type,
            position,
            fields,
            connect_in,
            connect_out,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::Node = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::Node = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeField {
    #[new]
    fn __new__(key: AzString, value: AzNodeTypeFieldValueEnumWrapper) -> Self {
        Self {
            key,
            value,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeField {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeField = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeField = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeFieldValueEnumWrapper {
    #[staticmethod]
    fn TextInput(v: AzString) -> AzNodeTypeFieldValueEnumWrapper { AzNodeTypeFieldValueEnumWrapper { inner: AzNodeTypeFieldValue::TextInput(v) } }
    #[staticmethod]
    fn NumberInput(v: f32) -> AzNodeTypeFieldValueEnumWrapper { AzNodeTypeFieldValueEnumWrapper { inner: AzNodeTypeFieldValue::NumberInput(v) } }
    #[staticmethod]
    fn CheckBox(v: bool) -> AzNodeTypeFieldValueEnumWrapper { AzNodeTypeFieldValueEnumWrapper { inner: AzNodeTypeFieldValue::CheckBox(v) } }
    #[staticmethod]
    fn ColorInput(v: AzColorU) -> AzNodeTypeFieldValueEnumWrapper { AzNodeTypeFieldValueEnumWrapper { inner: AzNodeTypeFieldValue::ColorInput(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeTypeFieldValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeTypeFieldValue::TextInput(v) => Ok(vec!["TextInput".into_py(py), v.clone().into_py(py)]),
            AzNodeTypeFieldValue::NumberInput(v) => Ok(vec!["NumberInput".into_py(py), v.into_py(py)]),
            AzNodeTypeFieldValue::CheckBox(v) => Ok(vec!["CheckBox".into_py(py), v.into_py(py)]),
            AzNodeTypeFieldValue::ColorInput(v) => Ok(vec!["ColorInput".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeFieldValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeFieldValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeFieldValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputConnection {
    #[new]
    fn __new__(input_index: usize, connects_to: AzOutputNodeAndIndexVec) -> Self {
        Self {
            input_index,
            connects_to,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInputConnection {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputConnection = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputConnection = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputNodeAndIndex {
    #[new]
    fn __new__(node_id: AzNodeGraphNodeId, output_index: usize) -> Self {
        Self {
            node_id,
            output_index,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzOutputNodeAndIndex {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputNodeAndIndex = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputNodeAndIndex = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputConnection {
    #[new]
    fn __new__(output_index: usize, connects_to: AzInputNodeAndIndexVec) -> Self {
        Self {
            output_index,
            connects_to,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzOutputConnection {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputConnection = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputConnection = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputNodeAndIndex {
    #[new]
    fn __new__(node_id: AzNodeGraphNodeId, input_index: usize) -> Self {
        Self {
            node_id,
            input_index,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInputNodeAndIndex {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputNodeAndIndex = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputNodeAndIndex = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeInfo {
    #[new]
    fn __new__(is_root: bool, name: AzString, inputs: AzInputOutputTypeIdVec, outputs: AzInputOutputTypeIdVec) -> Self {
        Self {
            is_root,
            name,
            inputs,
            outputs,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputInfo {
    #[new]
    fn __new__(data_type: AzString, color: AzColorU) -> Self {
        Self {
            data_type,
            color,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInputOutputInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodePosition {
    #[new]
    fn __new__(x: f32, y: f32) -> Self {
        Self {
            x,
            y,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodePosition {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodePosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodePosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGraphDragAmount {
    #[new]
    fn __new__(x: f32, y: f32) -> Self {
        Self {
            x,
            y,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzGraphDragAmount {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::GraphDragAmount = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::GraphDragAmount = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDragAmount {
    #[new]
    fn __new__(x: f32, y: f32) -> Self {
        Self {
            x,
            y,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeDragAmount {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeDragAmount = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeDragAmount = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListView {
    #[new]
    fn new(columns: AzStringVec) -> AzListView {
        unsafe { mem::transmute(crate::AzListView_new(
            mem::transmute(columns),
        )) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzListView_dom(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzListView {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::list_view::ListView = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::list_view::ListView = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTreeView {
    #[new]
    fn new(root: String) -> AzTreeView {
        let root = pystring_to_azstring(&root);
        unsafe { mem::transmute(crate::AzTreeView_new(
            mem::transmute(root),
        )) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzTreeView_dom(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTreeView {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::tree_view::TreeView = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::tree_view::TreeView = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDropDown {
    #[new]
    fn new(choices: AzStringVec) -> AzDropDown {
        unsafe { mem::transmute(crate::AzDropDown_new(
            mem::transmute(choices),
        )) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzDropDown_dom(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDropDown {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::drop_down::DropDown = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::drop_down::DropDown = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDropDownOnChoiceChangeCallback {
    #[new]
    fn __new__() -> Self {
        Self {
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzDropDownOnChoiceChangeCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::drop_down::DropDownOnChoiceChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::drop_down::DropDownOnChoiceChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDropDownOnChoiceChange {
    #[new]
    fn __new__(data: AzRefAny, callback: AzDropDownOnChoiceChangeCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzDropDownOnChoiceChange {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::drop_down::DropDownOnChoiceChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::drop_down::DropDownOnChoiceChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeHierarchyItem {
    #[new]
    fn __new__(parent: usize, previous_sibling: usize, next_sibling: usize, last_child: usize) -> Self {
        Self {
            parent,
            previous_sibling,
            next_sibling,
            last_child,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeHierarchyItem {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::NodeHierarchyItem = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::NodeHierarchyItem = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCascadeInfo {
    #[new]
    fn __new__(index_in_parent: u32, is_last_child: bool) -> Self {
        Self {
            index_in_parent,
            is_last_child,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzCascadeInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::style::CascadeInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::style::CascadeInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertySourceEnumWrapper {
    #[staticmethod]
    fn Css(v: AzCssPath) -> AzCssPropertySourceEnumWrapper { AzCssPropertySourceEnumWrapper { inner: AzCssPropertySource::Css(v) } }
    #[classattr]
    fn Inline() -> AzCssPropertySourceEnumWrapper { AzCssPropertySourceEnumWrapper { inner: AzCssPropertySource::Inline } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssPropertySource;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPropertySource::Css(v) => Ok(vec!["Css".into_py(py), v.clone().into_py(py)]),
            AzCssPropertySource::Inline => Ok(vec!["Inline".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertySourceEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::CssPropertySource = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::CssPropertySource = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledNodeState {
    #[new]
    fn __new__(normal: bool, hover: bool, active: bool, focused: bool) -> Self {
        Self {
            normal,
            hover,
            active,
            focused,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyledNodeState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::StyledNodeState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::StyledNodeState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledNode {
    #[new]
    fn __new__(state: AzStyledNodeState, tag_id: AzOptionTagIdEnumWrapper) -> Self {
        Self {
            state,
            tag_id,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyledNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::StyledNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::StyledNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTagId {
    #[new]
    fn __new__(inner: u64) -> Self {
        Self {
            inner,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzTagId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::AzTagId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::AzTagId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTagIdToNodeIdMapping {
    #[new]
    fn __new__(tag_id: AzTagId, node_id: AzNodeId, tab_index: AzOptionTabIndexEnumWrapper, parents: AzNodeIdVec) -> Self {
        Self {
            tag_id,
            node_id,
            tab_index,
            parents,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzTagIdToNodeIdMapping {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::TagIdToNodeIdMapping = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::TagIdToNodeIdMapping = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzParentWithNodeDepth {
    #[new]
    fn __new__(depth: usize, node_id: AzNodeId) -> Self {
        Self {
            depth,
            node_id,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzParentWithNodeDepth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::ParentWithNodeDepth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::ParentWithNodeDepth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyCache {
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyCache {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::CssPropertyCachePtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::CssPropertyCachePtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledDom {
    #[new]
    fn new(dom: AzDom, css: AzCss) -> AzStyledDom {
        unsafe { mem::transmute(crate::AzStyledDom_new(
            mem::transmute(dom),
            mem::transmute(css),
        )) }
    }
    #[staticmethod]
    fn default() -> AzStyledDom {
        unsafe { mem::transmute(crate::AzStyledDom_default()) }
    }
    #[staticmethod]
    fn from_xml(xml_string: String) -> AzStyledDom {
        let xml_string = pystring_to_azstring(&xml_string);
        unsafe { mem::transmute(crate::AzStyledDom_fromXml(
            mem::transmute(xml_string),
        )) }
    }
    #[staticmethod]
    fn from_file(xml_file_path: String) -> AzStyledDom {
        let xml_file_path = pystring_to_azstring(&xml_file_path);
        unsafe { mem::transmute(crate::AzStyledDom_fromFile(
            mem::transmute(xml_file_path),
        )) }
    }
    fn append_child(&mut self, dom: AzStyledDom) -> () {
        unsafe { mem::transmute(crate::AzStyledDom_appendChild(
            mem::transmute(self),
            mem::transmute(dom),
        )) }
    }
    fn restyle(&mut self, css: AzCss) -> () {
        unsafe { mem::transmute(crate::AzStyledDom_restyle(
            mem::transmute(self),
            mem::transmute(css),
        )) }
    }
    fn node_count(&self) -> usize {
        unsafe { mem::transmute(crate::AzStyledDom_nodeCount(
            mem::transmute(self),
        )) }
    }
    fn get_html_string(&self) -> String {
        az_string_to_py_string(unsafe { mem::transmute(crate::AzStyledDom_getHtmlString(
            mem::transmute(self),
        )) })
    }
    fn get_html_string_test(&self) -> String {
        az_string_to_py_string(unsafe { mem::transmute(crate::AzStyledDom_getHtmlStringTest(
            mem::transmute(self),
        )) })
    }
    fn set_menu_bar(&mut self, menu: AzMenu) -> () {
        unsafe { mem::transmute(crate::AzStyledDom_setMenuBar(
            mem::transmute(self),
            mem::transmute(menu),
        )) }
    }
    fn with_menu_bar(&mut self, menu: AzMenu) -> AzStyledDom {
        unsafe { mem::transmute(crate::AzStyledDom_withMenuBar(
            mem::transmute(self),
            mem::transmute(menu),
        )) }
    }
    fn set_context_menu(&mut self, menu: AzMenu) -> () {
        unsafe { mem::transmute(crate::AzStyledDom_setContextMenu(
            mem::transmute(self),
            mem::transmute(menu),
        )) }
    }
    fn with_context_menu(&mut self, menu: AzMenu) -> AzStyledDom {
        unsafe { mem::transmute(crate::AzStyledDom_withContextMenu(
            mem::transmute(self),
            mem::transmute(menu),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyledDom {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::StyledDom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::StyledDom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTexture {
    #[new]
    fn new(texture_id: u32, flags: AzTextureFlags, size: AzPhysicalSizeU32, background_color: AzColorU, gl_context: AzGl, format: AzRawImageFormatEnumWrapper) -> AzTexture {
        unsafe { mem::transmute(crate::AzTexture_new(
            mem::transmute(texture_id),
            mem::transmute(flags),
            mem::transmute(size),
            mem::transmute(background_color),
            mem::transmute(gl_context),
            mem::transmute(format),
        )) }
    }
    #[staticmethod]
    fn allocate_rgba8(gl: AzGl, size: AzPhysicalSizeU32, background: AzColorU) -> AzTexture {
        unsafe { mem::transmute(crate::AzTexture_allocateRgba8(
            mem::transmute(gl),
            mem::transmute(size),
            mem::transmute(background),
        )) }
    }
    #[staticmethod]
    fn allocate_clip_mask(gl: AzGl, size: AzPhysicalSizeU32, background: AzColorU) -> AzTexture {
        unsafe { mem::transmute(crate::AzTexture_allocateClipMask(
            mem::transmute(gl),
            mem::transmute(size),
            mem::transmute(background),
        )) }
    }
    fn clear(&mut self) -> () {
        unsafe { mem::transmute(crate::AzTexture_clear(
            mem::transmute(self),
        )) }
    }
    fn draw_clip_mask(&mut self, node: AzTessellatedSvgNode) -> bool {
        unsafe { mem::transmute(crate::AzTexture_drawClipMask(
            mem::transmute(self),
            mem::transmute(node),
        )) }
    }
    fn apply_fxaa(&mut self) -> bool {
        unsafe { mem::transmute(crate::AzTexture_applyFxaa(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTexture {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::Texture = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::Texture = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlVoidPtrConst {
}

#[pyproto]
impl PyObjectProtocol for AzGlVoidPtrConst {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GlVoidPtrConst = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GlVoidPtrConst = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlVoidPtrMut {
}

#[pyproto]
impl PyObjectProtocol for AzGlVoidPtrMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GlVoidPtrMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GlVoidPtrMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGl {
    #[classattr]
    const ACCUM: u32 = 0x0100;
    #[classattr]
    const ACCUM_ALPHA_BITS: u32 = 0x0D5B;
    #[classattr]
    const ACCUM_BLUE_BITS: u32 = 0x0D5A;
    #[classattr]
    const ACCUM_BUFFER_BIT: u32 = 0x00000200;
    #[classattr]
    const ACCUM_CLEAR_VALUE: u32 = 0x0B80;
    #[classattr]
    const ACCUM_GREEN_BITS: u32 = 0x0D59;
    #[classattr]
    const ACCUM_RED_BITS: u32 = 0x0D58;
    #[classattr]
    const ACTIVE_ATTRIBUTES: u32 = 0x8B89;
    #[classattr]
    const ACTIVE_ATTRIBUTE_MAX_LENGTH: u32 = 0x8B8A;
    #[classattr]
    const ACTIVE_TEXTURE: u32 = 0x84E0;
    #[classattr]
    const ACTIVE_UNIFORMS: u32 = 0x8B86;
    #[classattr]
    const ACTIVE_UNIFORM_BLOCKS: u32 = 0x8A36;
    #[classattr]
    const ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: u32 = 0x8A35;
    #[classattr]
    const ACTIVE_UNIFORM_MAX_LENGTH: u32 = 0x8B87;
    #[classattr]
    const ADD: u32 = 0x0104;
    #[classattr]
    const ADD_SIGNED: u32 = 0x8574;
    #[classattr]
    const ALIASED_LINE_WIDTH_RANGE: u32 = 0x846E;
    #[classattr]
    const ALIASED_POINT_SIZE_RANGE: u32 = 0x846D;
    #[classattr]
    const ALL_ATTRIB_BITS: u32 = 0xFFFFFFFF;
    #[classattr]
    const ALPHA: u32 = 0x1906;
    #[classattr]
    const ALPHA12: u32 = 0x803D;
    #[classattr]
    const ALPHA16: u32 = 0x803E;
    #[classattr]
    const ALPHA16F_EXT: u32 = 0x881C;
    #[classattr]
    const ALPHA32F_EXT: u32 = 0x8816;
    #[classattr]
    const ALPHA4: u32 = 0x803B;
    #[classattr]
    const ALPHA8: u32 = 0x803C;
    #[classattr]
    const ALPHA8_EXT: u32 = 0x803C;
    #[classattr]
    const ALPHA_BIAS: u32 = 0x0D1D;
    #[classattr]
    const ALPHA_BITS: u32 = 0x0D55;
    #[classattr]
    const ALPHA_INTEGER: u32 = 0x8D97;
    #[classattr]
    const ALPHA_SCALE: u32 = 0x0D1C;
    #[classattr]
    const ALPHA_TEST: u32 = 0x0BC0;
    #[classattr]
    const ALPHA_TEST_FUNC: u32 = 0x0BC1;
    #[classattr]
    const ALPHA_TEST_REF: u32 = 0x0BC2;
    #[classattr]
    const ALREADY_SIGNALED: u32 = 0x911A;
    #[classattr]
    const ALWAYS: u32 = 0x0207;
    #[classattr]
    const AMBIENT: u32 = 0x1200;
    #[classattr]
    const AMBIENT_AND_DIFFUSE: u32 = 0x1602;
    #[classattr]
    const AND: u32 = 0x1501;
    #[classattr]
    const AND_INVERTED: u32 = 0x1504;
    #[classattr]
    const AND_REVERSE: u32 = 0x1502;
    #[classattr]
    const ANY_SAMPLES_PASSED: u32 = 0x8C2F;
    #[classattr]
    const ANY_SAMPLES_PASSED_CONSERVATIVE: u32 = 0x8D6A;
    #[classattr]
    const ARRAY_BUFFER: u32 = 0x8892;
    #[classattr]
    const ARRAY_BUFFER_BINDING: u32 = 0x8894;
    #[classattr]
    const ATTACHED_SHADERS: u32 = 0x8B85;
    #[classattr]
    const ATTRIB_STACK_DEPTH: u32 = 0x0BB0;
    #[classattr]
    const AUTO_NORMAL: u32 = 0x0D80;
    #[classattr]
    const AUX0: u32 = 0x0409;
    #[classattr]
    const AUX1: u32 = 0x040A;
    #[classattr]
    const AUX2: u32 = 0x040B;
    #[classattr]
    const AUX3: u32 = 0x040C;
    #[classattr]
    const AUX_BUFFERS: u32 = 0x0C00;
    #[classattr]
    const BACK: u32 = 0x0405;
    #[classattr]
    const BACK_LEFT: u32 = 0x0402;
    #[classattr]
    const BACK_RIGHT: u32 = 0x0403;
    #[classattr]
    const BGR: u32 = 0x80E0;
    #[classattr]
    const BGRA: u32 = 0x80E1;
    #[classattr]
    const BGRA8_EXT: u32 = 0x93A1;
    #[classattr]
    const BGRA_EXT: u32 = 0x80E1;
    #[classattr]
    const BGRA_INTEGER: u32 = 0x8D9B;
    #[classattr]
    const BGR_INTEGER: u32 = 0x8D9A;
    #[classattr]
    const BITMAP: u32 = 0x1A00;
    #[classattr]
    const BITMAP_TOKEN: u32 = 0x0704;
    #[classattr]
    const BLEND: u32 = 0x0BE2;
    #[classattr]
    const BLEND_ADVANCED_COHERENT_KHR: u32 = 0x9285;
    #[classattr]
    const BLEND_COLOR: u32 = 0x8005;
    #[classattr]
    const BLEND_DST: u32 = 0x0BE0;
    #[classattr]
    const BLEND_DST_ALPHA: u32 = 0x80CA;
    #[classattr]
    const BLEND_DST_RGB: u32 = 0x80C8;
    #[classattr]
    const BLEND_EQUATION: u32 = 0x8009;
    #[classattr]
    const BLEND_EQUATION_ALPHA: u32 = 0x883D;
    #[classattr]
    const BLEND_EQUATION_RGB: u32 = 0x8009;
    #[classattr]
    const BLEND_SRC: u32 = 0x0BE1;
    #[classattr]
    const BLEND_SRC_ALPHA: u32 = 0x80CB;
    #[classattr]
    const BLEND_SRC_RGB: u32 = 0x80C9;
    #[classattr]
    const BLUE: u32 = 0x1905;
    #[classattr]
    const BLUE_BIAS: u32 = 0x0D1B;
    #[classattr]
    const BLUE_BITS: u32 = 0x0D54;
    #[classattr]
    const BLUE_INTEGER: u32 = 0x8D96;
    #[classattr]
    const BLUE_SCALE: u32 = 0x0D1A;
    #[classattr]
    const BOOL: u32 = 0x8B56;
    #[classattr]
    const BOOL_VEC2: u32 = 0x8B57;
    #[classattr]
    const BOOL_VEC3: u32 = 0x8B58;
    #[classattr]
    const BOOL_VEC4: u32 = 0x8B59;
    #[classattr]
    const BUFFER: u32 = 0x82E0;
    #[classattr]
    const BUFFER_ACCESS: u32 = 0x88BB;
    #[classattr]
    const BUFFER_ACCESS_FLAGS: u32 = 0x911F;
    #[classattr]
    const BUFFER_KHR: u32 = 0x82E0;
    #[classattr]
    const BUFFER_MAPPED: u32 = 0x88BC;
    #[classattr]
    const BUFFER_MAP_LENGTH: u32 = 0x9120;
    #[classattr]
    const BUFFER_MAP_OFFSET: u32 = 0x9121;
    #[classattr]
    const BUFFER_MAP_POINTER: u32 = 0x88BD;
    #[classattr]
    const BUFFER_SIZE: u32 = 0x8764;
    #[classattr]
    const BUFFER_USAGE: u32 = 0x8765;
    #[classattr]
    const BYTE: u32 = 0x1400;
    #[classattr]
    const C3F_V3F: u32 = 0x2A24;
    #[classattr]
    const C4F_N3F_V3F: u32 = 0x2A26;
    #[classattr]
    const C4UB_V2F: u32 = 0x2A22;
    #[classattr]
    const C4UB_V3F: u32 = 0x2A23;
    #[classattr]
    const CCW: u32 = 0x0901;
    #[classattr]
    const CLAMP: u32 = 0x2900;
    #[classattr]
    const CLAMP_FRAGMENT_COLOR: u32 = 0x891B;
    #[classattr]
    const CLAMP_READ_COLOR: u32 = 0x891C;
    #[classattr]
    const CLAMP_TO_BORDER: u32 = 0x812D;
    #[classattr]
    const CLAMP_TO_EDGE: u32 = 0x812F;
    #[classattr]
    const CLAMP_VERTEX_COLOR: u32 = 0x891A;
    #[classattr]
    const CLEAR: u32 = 0x1500;
    #[classattr]
    const CLIENT_ACTIVE_TEXTURE: u32 = 0x84E1;
    #[classattr]
    const CLIENT_ALL_ATTRIB_BITS: u32 = 0xFFFFFFFF;
    #[classattr]
    const CLIENT_ATTRIB_STACK_DEPTH: u32 = 0x0BB1;
    #[classattr]
    const CLIENT_PIXEL_STORE_BIT: u32 = 0x00000001;
    #[classattr]
    const CLIENT_VERTEX_ARRAY_BIT: u32 = 0x00000002;
    #[classattr]
    const CLIP_DISTANCE0: u32 = 0x3000;
    #[classattr]
    const CLIP_DISTANCE1: u32 = 0x3001;
    #[classattr]
    const CLIP_DISTANCE2: u32 = 0x3002;
    #[classattr]
    const CLIP_DISTANCE3: u32 = 0x3003;
    #[classattr]
    const CLIP_DISTANCE4: u32 = 0x3004;
    #[classattr]
    const CLIP_DISTANCE5: u32 = 0x3005;
    #[classattr]
    const CLIP_DISTANCE6: u32 = 0x3006;
    #[classattr]
    const CLIP_DISTANCE7: u32 = 0x3007;
    #[classattr]
    const CLIP_PLANE0: u32 = 0x3000;
    #[classattr]
    const CLIP_PLANE1: u32 = 0x3001;
    #[classattr]
    const CLIP_PLANE2: u32 = 0x3002;
    #[classattr]
    const CLIP_PLANE3: u32 = 0x3003;
    #[classattr]
    const CLIP_PLANE4: u32 = 0x3004;
    #[classattr]
    const CLIP_PLANE5: u32 = 0x3005;
    #[classattr]
    const COEFF: u32 = 0x0A00;
    #[classattr]
    const COLOR: u32 = 0x1800;
    #[classattr]
    const COLORBURN_KHR: u32 = 0x929A;
    #[classattr]
    const COLORDODGE_KHR: u32 = 0x9299;
    #[classattr]
    const COLOR_ARRAY: u32 = 0x8076;
    #[classattr]
    const COLOR_ARRAY_BUFFER_BINDING: u32 = 0x8898;
    #[classattr]
    const COLOR_ARRAY_POINTER: u32 = 0x8090;
    #[classattr]
    const COLOR_ARRAY_SIZE: u32 = 0x8081;
    #[classattr]
    const COLOR_ARRAY_STRIDE: u32 = 0x8083;
    #[classattr]
    const COLOR_ARRAY_TYPE: u32 = 0x8082;
    #[classattr]
    const COLOR_ATTACHMENT0: u32 = 0x8CE0;
    #[classattr]
    const COLOR_ATTACHMENT1: u32 = 0x8CE1;
    #[classattr]
    const COLOR_ATTACHMENT10: u32 = 0x8CEA;
    #[classattr]
    const COLOR_ATTACHMENT11: u32 = 0x8CEB;
    #[classattr]
    const COLOR_ATTACHMENT12: u32 = 0x8CEC;
    #[classattr]
    const COLOR_ATTACHMENT13: u32 = 0x8CED;
    #[classattr]
    const COLOR_ATTACHMENT14: u32 = 0x8CEE;
    #[classattr]
    const COLOR_ATTACHMENT15: u32 = 0x8CEF;
    #[classattr]
    const COLOR_ATTACHMENT16: u32 = 0x8CF0;
    #[classattr]
    const COLOR_ATTACHMENT17: u32 = 0x8CF1;
    #[classattr]
    const COLOR_ATTACHMENT18: u32 = 0x8CF2;
    #[classattr]
    const COLOR_ATTACHMENT19: u32 = 0x8CF3;
    #[classattr]
    const COLOR_ATTACHMENT2: u32 = 0x8CE2;
    #[classattr]
    const COLOR_ATTACHMENT20: u32 = 0x8CF4;
    #[classattr]
    const COLOR_ATTACHMENT21: u32 = 0x8CF5;
    #[classattr]
    const COLOR_ATTACHMENT22: u32 = 0x8CF6;
    #[classattr]
    const COLOR_ATTACHMENT23: u32 = 0x8CF7;
    #[classattr]
    const COLOR_ATTACHMENT24: u32 = 0x8CF8;
    #[classattr]
    const COLOR_ATTACHMENT25: u32 = 0x8CF9;
    #[classattr]
    const COLOR_ATTACHMENT26: u32 = 0x8CFA;
    #[classattr]
    const COLOR_ATTACHMENT27: u32 = 0x8CFB;
    #[classattr]
    const COLOR_ATTACHMENT28: u32 = 0x8CFC;
    #[classattr]
    const COLOR_ATTACHMENT29: u32 = 0x8CFD;
    #[classattr]
    const COLOR_ATTACHMENT3: u32 = 0x8CE3;
    #[classattr]
    const COLOR_ATTACHMENT30: u32 = 0x8CFE;
    #[classattr]
    const COLOR_ATTACHMENT31: u32 = 0x8CFF;
    #[classattr]
    const COLOR_ATTACHMENT4: u32 = 0x8CE4;
    #[classattr]
    const COLOR_ATTACHMENT5: u32 = 0x8CE5;
    #[classattr]
    const COLOR_ATTACHMENT6: u32 = 0x8CE6;
    #[classattr]
    const COLOR_ATTACHMENT7: u32 = 0x8CE7;
    #[classattr]
    const COLOR_ATTACHMENT8: u32 = 0x8CE8;
    #[classattr]
    const COLOR_ATTACHMENT9: u32 = 0x8CE9;
    #[classattr]
    const COLOR_BUFFER_BIT: u32 = 0x00004000;
    #[classattr]
    const COLOR_CLEAR_VALUE: u32 = 0x0C22;
    #[classattr]
    const COLOR_INDEX: u32 = 0x1900;
    #[classattr]
    const COLOR_INDEXES: u32 = 0x1603;
    #[classattr]
    const COLOR_LOGIC_OP: u32 = 0x0BF2;
    #[classattr]
    const COLOR_MATERIAL: u32 = 0x0B57;
    #[classattr]
    const COLOR_MATERIAL_FACE: u32 = 0x0B55;
    #[classattr]
    const COLOR_MATERIAL_PARAMETER: u32 = 0x0B56;
    #[classattr]
    const COLOR_SUM: u32 = 0x8458;
    #[classattr]
    const COLOR_WRITEMASK: u32 = 0x0C23;
    #[classattr]
    const COMBINE: u32 = 0x8570;
    #[classattr]
    const COMBINE_ALPHA: u32 = 0x8572;
    #[classattr]
    const COMBINE_RGB: u32 = 0x8571;
    #[classattr]
    const COMPARE_REF_TO_TEXTURE: u32 = 0x884E;
    #[classattr]
    const COMPARE_R_TO_TEXTURE: u32 = 0x884E;
    #[classattr]
    const COMPILE: u32 = 0x1300;
    #[classattr]
    const COMPILE_AND_EXECUTE: u32 = 0x1301;
    #[classattr]
    const COMPILE_STATUS: u32 = 0x8B81;
    #[classattr]
    const COMPRESSED_ALPHA: u32 = 0x84E9;
    #[classattr]
    const COMPRESSED_INTENSITY: u32 = 0x84EC;
    #[classattr]
    const COMPRESSED_LUMINANCE: u32 = 0x84EA;
    #[classattr]
    const COMPRESSED_LUMINANCE_ALPHA: u32 = 0x84EB;
    #[classattr]
    const COMPRESSED_R11_EAC: u32 = 0x9270;
    #[classattr]
    const COMPRESSED_RED: u32 = 0x8225;
    #[classattr]
    const COMPRESSED_RED_RGTC1: u32 = 0x8DBB;
    #[classattr]
    const COMPRESSED_RG: u32 = 0x8226;
    #[classattr]
    const COMPRESSED_RG11_EAC: u32 = 0x9272;
    #[classattr]
    const COMPRESSED_RGB: u32 = 0x84ED;
    #[classattr]
    const COMPRESSED_RGB8_ETC2: u32 = 0x9274;
    #[classattr]
    const COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9276;
    #[classattr]
    const COMPRESSED_RGBA: u32 = 0x84EE;
    #[classattr]
    const COMPRESSED_RGBA8_ETC2_EAC: u32 = 0x9278;
    #[classattr]
    const COMPRESSED_RG_RGTC2: u32 = 0x8DBD;
    #[classattr]
    const COMPRESSED_SIGNED_R11_EAC: u32 = 0x9271;
    #[classattr]
    const COMPRESSED_SIGNED_RED_RGTC1: u32 = 0x8DBC;
    #[classattr]
    const COMPRESSED_SIGNED_RG11_EAC: u32 = 0x9273;
    #[classattr]
    const COMPRESSED_SIGNED_RG_RGTC2: u32 = 0x8DBE;
    #[classattr]
    const COMPRESSED_SLUMINANCE: u32 = 0x8C4A;
    #[classattr]
    const COMPRESSED_SLUMINANCE_ALPHA: u32 = 0x8C4B;
    #[classattr]
    const COMPRESSED_SRGB: u32 = 0x8C48;
    #[classattr]
    const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: u32 = 0x9279;
    #[classattr]
    const COMPRESSED_SRGB8_ETC2: u32 = 0x9275;
    #[classattr]
    const COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9277;
    #[classattr]
    const COMPRESSED_SRGB_ALPHA: u32 = 0x8C49;
    #[classattr]
    const COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A3;
    #[classattr]
    const CONDITION_SATISFIED: u32 = 0x911C;
    #[classattr]
    const CONSTANT: u32 = 0x8576;
    #[classattr]
    const CONSTANT_ALPHA: u32 = 0x8003;
    #[classattr]
    const CONSTANT_ATTENUATION: u32 = 0x1207;
    #[classattr]
    const CONSTANT_COLOR: u32 = 0x8001;
    #[classattr]
    const CONTEXT_COMPATIBILITY_PROFILE_BIT: u32 = 0x00000002;
    #[classattr]
    const CONTEXT_CORE_PROFILE_BIT: u32 = 0x00000001;
    #[classattr]
    const CONTEXT_FLAGS: u32 = 0x821E;
    #[classattr]
    const CONTEXT_FLAG_DEBUG_BIT: u32 = 0x00000002;
    #[classattr]
    const CONTEXT_FLAG_DEBUG_BIT_KHR: u32 = 0x00000002;
    #[classattr]
    const CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: u32 = 0x00000001;
    #[classattr]
    const CONTEXT_PROFILE_MASK: u32 = 0x9126;
    #[classattr]
    const COORD_REPLACE: u32 = 0x8862;
    #[classattr]
    const COPY: u32 = 0x1503;
    #[classattr]
    const COPY_INVERTED: u32 = 0x150C;
    #[classattr]
    const COPY_PIXEL_TOKEN: u32 = 0x0706;
    #[classattr]
    const COPY_READ_BUFFER: u32 = 0x8F36;
    #[classattr]
    const COPY_READ_BUFFER_BINDING: u32 = 0x8F36;
    #[classattr]
    const COPY_WRITE_BUFFER: u32 = 0x8F37;
    #[classattr]
    const COPY_WRITE_BUFFER_BINDING: u32 = 0x8F37;
    #[classattr]
    const CULL_FACE: u32 = 0x0B44;
    #[classattr]
    const CULL_FACE_MODE: u32 = 0x0B45;
    #[classattr]
    const CURRENT_BIT: u32 = 0x00000001;
    #[classattr]
    const CURRENT_COLOR: u32 = 0x0B00;
    #[classattr]
    const CURRENT_FOG_COORD: u32 = 0x8453;
    #[classattr]
    const CURRENT_FOG_COORDINATE: u32 = 0x8453;
    #[classattr]
    const CURRENT_INDEX: u32 = 0x0B01;
    #[classattr]
    const CURRENT_NORMAL: u32 = 0x0B02;
    #[classattr]
    const CURRENT_PROGRAM: u32 = 0x8B8D;
    #[classattr]
    const CURRENT_QUERY: u32 = 0x8865;
    #[classattr]
    const CURRENT_QUERY_EXT: u32 = 0x8865;
    #[classattr]
    const CURRENT_RASTER_COLOR: u32 = 0x0B04;
    #[classattr]
    const CURRENT_RASTER_DISTANCE: u32 = 0x0B09;
    #[classattr]
    const CURRENT_RASTER_INDEX: u32 = 0x0B05;
    #[classattr]
    const CURRENT_RASTER_POSITION: u32 = 0x0B07;
    #[classattr]
    const CURRENT_RASTER_POSITION_VALID: u32 = 0x0B08;
    #[classattr]
    const CURRENT_RASTER_SECONDARY_COLOR: u32 = 0x845F;
    #[classattr]
    const CURRENT_RASTER_TEXTURE_COORDS: u32 = 0x0B06;
    #[classattr]
    const CURRENT_SECONDARY_COLOR: u32 = 0x8459;
    #[classattr]
    const CURRENT_TEXTURE_COORDS: u32 = 0x0B03;
    #[classattr]
    const CURRENT_VERTEX_ATTRIB: u32 = 0x8626;
    #[classattr]
    const CW: u32 = 0x0900;
    #[classattr]
    const DARKEN_KHR: u32 = 0x9297;
    #[classattr]
    const DEBUG_CALLBACK_FUNCTION: u32 = 0x8244;
    #[classattr]
    const DEBUG_CALLBACK_FUNCTION_KHR: u32 = 0x8244;
    #[classattr]
    const DEBUG_CALLBACK_USER_PARAM: u32 = 0x8245;
    #[classattr]
    const DEBUG_CALLBACK_USER_PARAM_KHR: u32 = 0x8245;
    #[classattr]
    const DEBUG_GROUP_STACK_DEPTH: u32 = 0x826D;
    #[classattr]
    const DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826D;
    #[classattr]
    const DEBUG_LOGGED_MESSAGES: u32 = 0x9145;
    #[classattr]
    const DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9145;
    #[classattr]
    const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: u32 = 0x8243;
    #[classattr]
    const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR: u32 = 0x8243;
    #[classattr]
    const DEBUG_OUTPUT: u32 = 0x92E0;
    #[classattr]
    const DEBUG_OUTPUT_KHR: u32 = 0x92E0;
    #[classattr]
    const DEBUG_OUTPUT_SYNCHRONOUS: u32 = 0x8242;
    #[classattr]
    const DEBUG_OUTPUT_SYNCHRONOUS_KHR: u32 = 0x8242;
    #[classattr]
    const DEBUG_SEVERITY_HIGH: u32 = 0x9146;
    #[classattr]
    const DEBUG_SEVERITY_HIGH_KHR: u32 = 0x9146;
    #[classattr]
    const DEBUG_SEVERITY_LOW: u32 = 0x9148;
    #[classattr]
    const DEBUG_SEVERITY_LOW_KHR: u32 = 0x9148;
    #[classattr]
    const DEBUG_SEVERITY_MEDIUM: u32 = 0x9147;
    #[classattr]
    const DEBUG_SEVERITY_MEDIUM_KHR: u32 = 0x9147;
    #[classattr]
    const DEBUG_SEVERITY_NOTIFICATION: u32 = 0x826B;
    #[classattr]
    const DEBUG_SEVERITY_NOTIFICATION_KHR: u32 = 0x826B;
    #[classattr]
    const DEBUG_SOURCE_API: u32 = 0x8246;
    #[classattr]
    const DEBUG_SOURCE_API_KHR: u32 = 0x8246;
    #[classattr]
    const DEBUG_SOURCE_APPLICATION: u32 = 0x824A;
    #[classattr]
    const DEBUG_SOURCE_APPLICATION_KHR: u32 = 0x824A;
    #[classattr]
    const DEBUG_SOURCE_OTHER: u32 = 0x824B;
    #[classattr]
    const DEBUG_SOURCE_OTHER_KHR: u32 = 0x824B;
    #[classattr]
    const DEBUG_SOURCE_SHADER_COMPILER: u32 = 0x8248;
    #[classattr]
    const DEBUG_SOURCE_SHADER_COMPILER_KHR: u32 = 0x8248;
    #[classattr]
    const DEBUG_SOURCE_THIRD_PARTY: u32 = 0x8249;
    #[classattr]
    const DEBUG_SOURCE_THIRD_PARTY_KHR: u32 = 0x8249;
    #[classattr]
    const DEBUG_SOURCE_WINDOW_SYSTEM: u32 = 0x8247;
    #[classattr]
    const DEBUG_SOURCE_WINDOW_SYSTEM_KHR: u32 = 0x8247;
    #[classattr]
    const DEBUG_TYPE_DEPRECATED_BEHAVIOR: u32 = 0x824D;
    #[classattr]
    const DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR: u32 = 0x824D;
    #[classattr]
    const DEBUG_TYPE_ERROR: u32 = 0x824C;
    #[classattr]
    const DEBUG_TYPE_ERROR_KHR: u32 = 0x824C;
    #[classattr]
    const DEBUG_TYPE_MARKER: u32 = 0x8268;
    #[classattr]
    const DEBUG_TYPE_MARKER_KHR: u32 = 0x8268;
    #[classattr]
    const DEBUG_TYPE_OTHER: u32 = 0x8251;
    #[classattr]
    const DEBUG_TYPE_OTHER_KHR: u32 = 0x8251;
    #[classattr]
    const DEBUG_TYPE_PERFORMANCE: u32 = 0x8250;
    #[classattr]
    const DEBUG_TYPE_PERFORMANCE_KHR: u32 = 0x8250;
    #[classattr]
    const DEBUG_TYPE_POP_GROUP: u32 = 0x826A;
    #[classattr]
    const DEBUG_TYPE_POP_GROUP_KHR: u32 = 0x826A;
    #[classattr]
    const DEBUG_TYPE_PORTABILITY: u32 = 0x824F;
    #[classattr]
    const DEBUG_TYPE_PORTABILITY_KHR: u32 = 0x824F;
    #[classattr]
    const DEBUG_TYPE_PUSH_GROUP: u32 = 0x8269;
    #[classattr]
    const DEBUG_TYPE_PUSH_GROUP_KHR: u32 = 0x8269;
    #[classattr]
    const DEBUG_TYPE_UNDEFINED_BEHAVIOR: u32 = 0x824E;
    #[classattr]
    const DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR: u32 = 0x824E;
    #[classattr]
    const DECAL: u32 = 0x2101;
    #[classattr]
    const DECR: u32 = 0x1E03;
    #[classattr]
    const DECR_WRAP: u32 = 0x8508;
    #[classattr]
    const DELETE_STATUS: u32 = 0x8B80;
    #[classattr]
    const DEPTH: u32 = 0x1801;
    #[classattr]
    const DEPTH24_STENCIL8: u32 = 0x88F0;
    #[classattr]
    const DEPTH32F_STENCIL8: u32 = 0x8CAD;
    #[classattr]
    const DEPTH_ATTACHMENT: u32 = 0x8D00;
    #[classattr]
    const DEPTH_BIAS: u32 = 0x0D1F;
    #[classattr]
    const DEPTH_BITS: u32 = 0x0D56;
    #[classattr]
    const DEPTH_BUFFER_BIT: u32 = 0x00000100;
    #[classattr]
    const DEPTH_CLAMP: u32 = 0x864F;
    #[classattr]
    const DEPTH_CLEAR_VALUE: u32 = 0x0B73;
    #[classattr]
    const DEPTH_COMPONENT: u32 = 0x1902;
    #[classattr]
    const DEPTH_COMPONENT16: u32 = 0x81A5;
    #[classattr]
    const DEPTH_COMPONENT24: u32 = 0x81A6;
    #[classattr]
    const DEPTH_COMPONENT32: u32 = 0x81A7;
    #[classattr]
    const DEPTH_COMPONENT32F: u32 = 0x8CAC;
    #[classattr]
    const DEPTH_FUNC: u32 = 0x0B74;
    #[classattr]
    const DEPTH_RANGE: u32 = 0x0B70;
    #[classattr]
    const DEPTH_SCALE: u32 = 0x0D1E;
    #[classattr]
    const DEPTH_STENCIL: u32 = 0x84F9;
    #[classattr]
    const DEPTH_STENCIL_ATTACHMENT: u32 = 0x821A;
    #[classattr]
    const DEPTH_TEST: u32 = 0x0B71;
    #[classattr]
    const DEPTH_TEXTURE_MODE: u32 = 0x884B;
    #[classattr]
    const DEPTH_WRITEMASK: u32 = 0x0B72;
    #[classattr]
    const DIFFERENCE_KHR: u32 = 0x929E;
    #[classattr]
    const DIFFUSE: u32 = 0x1201;
    #[classattr]
    const DISPLAY_LIST: u32 = 0x82E7;
    #[classattr]
    const DITHER: u32 = 0x0BD0;
    #[classattr]
    const DOMAIN: u32 = 0x0A02;
    #[classattr]
    const DONT_CARE: u32 = 0x1100;
    #[classattr]
    const DOT3_RGB: u32 = 0x86AE;
    #[classattr]
    const DOT3_RGBA: u32 = 0x86AF;
    #[classattr]
    const DOUBLE: u32 = 0x140A;
    #[classattr]
    const DOUBLEBUFFER: u32 = 0x0C32;
    #[classattr]
    const DRAW_BUFFER: u32 = 0x0C01;
    #[classattr]
    const DRAW_BUFFER0: u32 = 0x8825;
    #[classattr]
    const DRAW_BUFFER1: u32 = 0x8826;
    #[classattr]
    const DRAW_BUFFER10: u32 = 0x882F;
    #[classattr]
    const DRAW_BUFFER11: u32 = 0x8830;
    #[classattr]
    const DRAW_BUFFER12: u32 = 0x8831;
    #[classattr]
    const DRAW_BUFFER13: u32 = 0x8832;
    #[classattr]
    const DRAW_BUFFER14: u32 = 0x8833;
    #[classattr]
    const DRAW_BUFFER15: u32 = 0x8834;
    #[classattr]
    const DRAW_BUFFER2: u32 = 0x8827;
    #[classattr]
    const DRAW_BUFFER3: u32 = 0x8828;
    #[classattr]
    const DRAW_BUFFER4: u32 = 0x8829;
    #[classattr]
    const DRAW_BUFFER5: u32 = 0x882A;
    #[classattr]
    const DRAW_BUFFER6: u32 = 0x882B;
    #[classattr]
    const DRAW_BUFFER7: u32 = 0x882C;
    #[classattr]
    const DRAW_BUFFER8: u32 = 0x882D;
    #[classattr]
    const DRAW_BUFFER9: u32 = 0x882E;
    #[classattr]
    const DRAW_FRAMEBUFFER: u32 = 0x8CA9;
    #[classattr]
    const DRAW_FRAMEBUFFER_BINDING: u32 = 0x8CA6;
    #[classattr]
    const DRAW_PIXELS_APPLE: u32 = 0x8A0A;
    #[classattr]
    const DRAW_PIXEL_TOKEN: u32 = 0x0705;
    #[classattr]
    const DST_ALPHA: u32 = 0x0304;
    #[classattr]
    const DST_COLOR: u32 = 0x0306;
    #[classattr]
    const DYNAMIC_COPY: u32 = 0x88EA;
    #[classattr]
    const DYNAMIC_DRAW: u32 = 0x88E8;
    #[classattr]
    const DYNAMIC_READ: u32 = 0x88E9;
    #[classattr]
    const EDGE_FLAG: u32 = 0x0B43;
    #[classattr]
    const EDGE_FLAG_ARRAY: u32 = 0x8079;
    #[classattr]
    const EDGE_FLAG_ARRAY_BUFFER_BINDING: u32 = 0x889B;
    #[classattr]
    const EDGE_FLAG_ARRAY_POINTER: u32 = 0x8093;
    #[classattr]
    const EDGE_FLAG_ARRAY_STRIDE: u32 = 0x808C;
    #[classattr]
    const ELEMENT_ARRAY_BUFFER: u32 = 0x8893;
    #[classattr]
    const ELEMENT_ARRAY_BUFFER_BINDING: u32 = 0x8895;
    #[classattr]
    const EMISSION: u32 = 0x1600;
    #[classattr]
    const ENABLE_BIT: u32 = 0x00002000;
    #[classattr]
    const EQUAL: u32 = 0x0202;
    #[classattr]
    const EQUIV: u32 = 0x1509;
    #[classattr]
    const EVAL_BIT: u32 = 0x00010000;
    #[classattr]
    const EXCLUSION_KHR: u32 = 0x92A0;
    #[classattr]
    const EXP: u32 = 0x0800;
    #[classattr]
    const EXP2: u32 = 0x0801;
    #[classattr]
    const EXTENSIONS: u32 = 0x1F03;
    #[classattr]
    const EYE_LINEAR: u32 = 0x2400;
    #[classattr]
    const EYE_PLANE: u32 = 0x2502;
    #[classattr]
    const FALSE: u8 = 0;
    #[classattr]
    const FASTEST: u32 = 0x1101;
    #[classattr]
    const FEEDBACK: u32 = 0x1C01;
    #[classattr]
    const FEEDBACK_BUFFER_POINTER: u32 = 0x0DF0;
    #[classattr]
    const FEEDBACK_BUFFER_SIZE: u32 = 0x0DF1;
    #[classattr]
    const FEEDBACK_BUFFER_TYPE: u32 = 0x0DF2;
    #[classattr]
    const FENCE_APPLE: u32 = 0x8A0B;
    #[classattr]
    const FILL: u32 = 0x1B02;
    #[classattr]
    const FIRST_VERTEX_CONVENTION: u32 = 0x8E4D;
    #[classattr]
    const FIXED: u32 = 0x140C;
    #[classattr]
    const FIXED_ONLY: u32 = 0x891D;
    #[classattr]
    const FLAT: u32 = 0x1D00;
    #[classattr]
    const FLOAT: u32 = 0x1406;
    #[classattr]
    const FLOAT_32_UNSIGNED_INT_24_8_REV: u32 = 0x8DAD;
    #[classattr]
    const FLOAT_MAT2: u32 = 0x8B5A;
    #[classattr]
    const FLOAT_MAT2x3: u32 = 0x8B65;
    #[classattr]
    const FLOAT_MAT2x4: u32 = 0x8B66;
    #[classattr]
    const FLOAT_MAT3: u32 = 0x8B5B;
    #[classattr]
    const FLOAT_MAT3x2: u32 = 0x8B67;
    #[classattr]
    const FLOAT_MAT3x4: u32 = 0x8B68;
    #[classattr]
    const FLOAT_MAT4: u32 = 0x8B5C;
    #[classattr]
    const FLOAT_MAT4x2: u32 = 0x8B69;
    #[classattr]
    const FLOAT_MAT4x3: u32 = 0x8B6A;
    #[classattr]
    const FLOAT_VEC2: u32 = 0x8B50;
    #[classattr]
    const FLOAT_VEC3: u32 = 0x8B51;
    #[classattr]
    const FLOAT_VEC4: u32 = 0x8B52;
    #[classattr]
    const FOG: u32 = 0x0B60;
    #[classattr]
    const FOG_BIT: u32 = 0x00000080;
    #[classattr]
    const FOG_COLOR: u32 = 0x0B66;
    #[classattr]
    const FOG_COORD: u32 = 0x8451;
    #[classattr]
    const FOG_COORDINATE: u32 = 0x8451;
    #[classattr]
    const FOG_COORDINATE_ARRAY: u32 = 0x8457;
    #[classattr]
    const FOG_COORDINATE_ARRAY_BUFFER_BINDING: u32 = 0x889D;
    #[classattr]
    const FOG_COORDINATE_ARRAY_POINTER: u32 = 0x8456;
    #[classattr]
    const FOG_COORDINATE_ARRAY_STRIDE: u32 = 0x8455;
    #[classattr]
    const FOG_COORDINATE_ARRAY_TYPE: u32 = 0x8454;
    #[classattr]
    const FOG_COORDINATE_SOURCE: u32 = 0x8450;
    #[classattr]
    const FOG_COORD_ARRAY: u32 = 0x8457;
    #[classattr]
    const FOG_COORD_ARRAY_BUFFER_BINDING: u32 = 0x889D;
    #[classattr]
    const FOG_COORD_ARRAY_POINTER: u32 = 0x8456;
    #[classattr]
    const FOG_COORD_ARRAY_STRIDE: u32 = 0x8455;
    #[classattr]
    const FOG_COORD_ARRAY_TYPE: u32 = 0x8454;
    #[classattr]
    const FOG_COORD_SRC: u32 = 0x8450;
    #[classattr]
    const FOG_DENSITY: u32 = 0x0B62;
    #[classattr]
    const FOG_END: u32 = 0x0B64;
    #[classattr]
    const FOG_HINT: u32 = 0x0C54;
    #[classattr]
    const FOG_INDEX: u32 = 0x0B61;
    #[classattr]
    const FOG_MODE: u32 = 0x0B65;
    #[classattr]
    const FOG_START: u32 = 0x0B63;
    #[classattr]
    const FRAGMENT_DEPTH: u32 = 0x8452;
    #[classattr]
    const FRAGMENT_SHADER: u32 = 0x8B30;
    #[classattr]
    const FRAGMENT_SHADER_DERIVATIVE_HINT: u32 = 0x8B8B;
    #[classattr]
    const FRAMEBUFFER: u32 = 0x8D40;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: u32 = 0x8215;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_ANGLE: u32 = 0x93A3;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: u32 = 0x8214;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: u32 = 0x8210;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: u32 = 0x8211;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: u32 = 0x8216;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: u32 = 0x8213;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_LAYERED: u32 = 0x8DA7;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: u32 = 0x8CD1;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: u32 = 0x8CD0;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_RED_SIZE: u32 = 0x8212;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: u32 = 0x8217;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: u32 = 0x8CD3;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: u32 = 0x8CD4;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: u32 = 0x8CD2;
    #[classattr]
    const FRAMEBUFFER_BINDING: u32 = 0x8CA6;
    #[classattr]
    const FRAMEBUFFER_COMPLETE: u32 = 0x8CD5;
    #[classattr]
    const FRAMEBUFFER_DEFAULT: u32 = 0x8218;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_ATTACHMENT: u32 = 0x8CD6;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_DIMENSIONS: u32 = 0x8CD9;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: u32 = 0x8CDB;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS: u32 = 0x8DA8;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: u32 = 0x8CD7;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: u32 = 0x8D56;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_READ_BUFFER: u32 = 0x8CDC;
    #[classattr]
    const FRAMEBUFFER_SRGB: u32 = 0x8DB9;
    #[classattr]
    const FRAMEBUFFER_UNDEFINED: u32 = 0x8219;
    #[classattr]
    const FRAMEBUFFER_UNSUPPORTED: u32 = 0x8CDD;
    #[classattr]
    const FRONT: u32 = 0x0404;
    #[classattr]
    const FRONT_AND_BACK: u32 = 0x0408;
    #[classattr]
    const FRONT_FACE: u32 = 0x0B46;
    #[classattr]
    const FRONT_LEFT: u32 = 0x0400;
    #[classattr]
    const FRONT_RIGHT: u32 = 0x0401;
    #[classattr]
    const FUNC_ADD: u32 = 0x8006;
    #[classattr]
    const FUNC_REVERSE_SUBTRACT: u32 = 0x800B;
    #[classattr]
    const FUNC_SUBTRACT: u32 = 0x800A;
    #[classattr]
    const GENERATE_MIPMAP: u32 = 0x8191;
    #[classattr]
    const GENERATE_MIPMAP_HINT: u32 = 0x8192;
    #[classattr]
    const GEOMETRY_INPUT_TYPE: u32 = 0x8917;
    #[classattr]
    const GEOMETRY_OUTPUT_TYPE: u32 = 0x8918;
    #[classattr]
    const GEOMETRY_SHADER: u32 = 0x8DD9;
    #[classattr]
    const GEOMETRY_VERTICES_OUT: u32 = 0x8916;
    #[classattr]
    const GEQUAL: u32 = 0x0206;
    #[classattr]
    const GPU_DISJOINT_EXT: u32 = 0x8FBB;
    #[classattr]
    const GREATER: u32 = 0x0204;
    #[classattr]
    const GREEN: u32 = 0x1904;
    #[classattr]
    const GREEN_BIAS: u32 = 0x0D19;
    #[classattr]
    const GREEN_BITS: u32 = 0x0D53;
    #[classattr]
    const GREEN_INTEGER: u32 = 0x8D95;
    #[classattr]
    const GREEN_SCALE: u32 = 0x0D18;
    #[classattr]
    const HALF_FLOAT: u32 = 0x140B;
    #[classattr]
    const HALF_FLOAT_OES: u32 = 0x8D61;
    #[classattr]
    const HARDLIGHT_KHR: u32 = 0x929B;
    #[classattr]
    const HIGH_FLOAT: u32 = 0x8DF2;
    #[classattr]
    const HIGH_INT: u32 = 0x8DF5;
    #[classattr]
    const HINT_BIT: u32 = 0x00008000;
    #[classattr]
    const HSL_COLOR_KHR: u32 = 0x92AF;
    #[classattr]
    const HSL_HUE_KHR: u32 = 0x92AD;
    #[classattr]
    const HSL_LUMINOSITY_KHR: u32 = 0x92B0;
    #[classattr]
    const HSL_SATURATION_KHR: u32 = 0x92AE;
    #[classattr]
    const IMPLEMENTATION_COLOR_READ_FORMAT: u32 = 0x8B9B;
    #[classattr]
    const IMPLEMENTATION_COLOR_READ_TYPE: u32 = 0x8B9A;
    #[classattr]
    const INCR: u32 = 0x1E02;
    #[classattr]
    const INCR_WRAP: u32 = 0x8507;
    #[classattr]
    const INDEX: u32 = 0x8222;
    #[classattr]
    const INDEX_ARRAY: u32 = 0x8077;
    #[classattr]
    const INDEX_ARRAY_BUFFER_BINDING: u32 = 0x8899;
    #[classattr]
    const INDEX_ARRAY_POINTER: u32 = 0x8091;
    #[classattr]
    const INDEX_ARRAY_STRIDE: u32 = 0x8086;
    #[classattr]
    const INDEX_ARRAY_TYPE: u32 = 0x8085;
    #[classattr]
    const INDEX_BITS: u32 = 0x0D51;
    #[classattr]
    const INDEX_CLEAR_VALUE: u32 = 0x0C20;
    #[classattr]
    const INDEX_LOGIC_OP: u32 = 0x0BF1;
    #[classattr]
    const INDEX_MODE: u32 = 0x0C30;
    #[classattr]
    const INDEX_OFFSET: u32 = 0x0D13;
    #[classattr]
    const INDEX_SHIFT: u32 = 0x0D12;
    #[classattr]
    const INDEX_WRITEMASK: u32 = 0x0C21;
    #[classattr]
    const INFO_LOG_LENGTH: u32 = 0x8B84;
    #[classattr]
    const INT: u32 = 0x1404;
    #[classattr]
    const INTENSITY: u32 = 0x8049;
    #[classattr]
    const INTENSITY12: u32 = 0x804C;
    #[classattr]
    const INTENSITY16: u32 = 0x804D;
    #[classattr]
    const INTENSITY4: u32 = 0x804A;
    #[classattr]
    const INTENSITY8: u32 = 0x804B;
    #[classattr]
    const INTERLEAVED_ATTRIBS: u32 = 0x8C8C;
    #[classattr]
    const INTERPOLATE: u32 = 0x8575;
    #[classattr]
    const INT_2_10_10_10_REV: u32 = 0x8D9F;
    #[classattr]
    const INT_SAMPLER_1D: u32 = 0x8DC9;
    #[classattr]
    const INT_SAMPLER_1D_ARRAY: u32 = 0x8DCE;
    #[classattr]
    const INT_SAMPLER_2D: u32 = 0x8DCA;
    #[classattr]
    const INT_SAMPLER_2D_ARRAY: u32 = 0x8DCF;
    #[classattr]
    const INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x9109;
    #[classattr]
    const INT_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910C;
    #[classattr]
    const INT_SAMPLER_2D_RECT: u32 = 0x8DCD;
    #[classattr]
    const INT_SAMPLER_3D: u32 = 0x8DCB;
    #[classattr]
    const INT_SAMPLER_BUFFER: u32 = 0x8DD0;
    #[classattr]
    const INT_SAMPLER_CUBE: u32 = 0x8DCC;
    #[classattr]
    const INT_VEC2: u32 = 0x8B53;
    #[classattr]
    const INT_VEC3: u32 = 0x8B54;
    #[classattr]
    const INT_VEC4: u32 = 0x8B55;
    #[classattr]
    const INVALID_ENUM: u32 = 0x0500;
    #[classattr]
    const INVALID_FRAMEBUFFER_OPERATION: u32 = 0x0506;
    #[classattr]
    const INVALID_INDEX: u32 = 0xFFFFFFFF;
    #[classattr]
    const INVALID_OPERATION: u32 = 0x0502;
    #[classattr]
    const INVALID_VALUE: u32 = 0x0501;
    #[classattr]
    const INVERT: u32 = 0x150A;
    #[classattr]
    const KEEP: u32 = 0x1E00;
    #[classattr]
    const LAST_VERTEX_CONVENTION: u32 = 0x8E4E;
    #[classattr]
    const LEFT: u32 = 0x0406;
    #[classattr]
    const LEQUAL: u32 = 0x0203;
    #[classattr]
    const LESS: u32 = 0x0201;
    #[classattr]
    const LIGHT0: u32 = 0x4000;
    #[classattr]
    const LIGHT1: u32 = 0x4001;
    #[classattr]
    const LIGHT2: u32 = 0x4002;
    #[classattr]
    const LIGHT3: u32 = 0x4003;
    #[classattr]
    const LIGHT4: u32 = 0x4004;
    #[classattr]
    const LIGHT5: u32 = 0x4005;
    #[classattr]
    const LIGHT6: u32 = 0x4006;
    #[classattr]
    const LIGHT7: u32 = 0x4007;
    #[classattr]
    const LIGHTEN_KHR: u32 = 0x9298;
    #[classattr]
    const LIGHTING: u32 = 0x0B50;
    #[classattr]
    const LIGHTING_BIT: u32 = 0x00000040;
    #[classattr]
    const LIGHT_MODEL_AMBIENT: u32 = 0x0B53;
    #[classattr]
    const LIGHT_MODEL_COLOR_CONTROL: u32 = 0x81F8;
    #[classattr]
    const LIGHT_MODEL_LOCAL_VIEWER: u32 = 0x0B51;
    #[classattr]
    const LIGHT_MODEL_TWO_SIDE: u32 = 0x0B52;
    #[classattr]
    const LINE: u32 = 0x1B01;
    #[classattr]
    const LINEAR: u32 = 0x2601;
    #[classattr]
    const LINEAR_ATTENUATION: u32 = 0x1208;
    #[classattr]
    const LINEAR_MIPMAP_LINEAR: u32 = 0x2703;
    #[classattr]
    const LINEAR_MIPMAP_NEAREST: u32 = 0x2701;
    #[classattr]
    const LINES: u32 = 0x0001;
    #[classattr]
    const LINES_ADJACENCY: u32 = 0x000A;
    #[classattr]
    const LINE_BIT: u32 = 0x00000004;
    #[classattr]
    const LINE_LOOP: u32 = 0x0002;
    #[classattr]
    const LINE_RESET_TOKEN: u32 = 0x0707;
    #[classattr]
    const LINE_SMOOTH: u32 = 0x0B20;
    #[classattr]
    const LINE_SMOOTH_HINT: u32 = 0x0C52;
    #[classattr]
    const LINE_STIPPLE: u32 = 0x0B24;
    #[classattr]
    const LINE_STIPPLE_PATTERN: u32 = 0x0B25;
    #[classattr]
    const LINE_STIPPLE_REPEAT: u32 = 0x0B26;
    #[classattr]
    const LINE_STRIP: u32 = 0x0003;
    #[classattr]
    const LINE_STRIP_ADJACENCY: u32 = 0x000B;
    #[classattr]
    const LINE_TOKEN: u32 = 0x0702;
    #[classattr]
    const LINE_WIDTH: u32 = 0x0B21;
    #[classattr]
    const LINE_WIDTH_GRANULARITY: u32 = 0x0B23;
    #[classattr]
    const LINE_WIDTH_RANGE: u32 = 0x0B22;
    #[classattr]
    const LINK_STATUS: u32 = 0x8B82;
    #[classattr]
    const LIST_BASE: u32 = 0x0B32;
    #[classattr]
    const LIST_BIT: u32 = 0x00020000;
    #[classattr]
    const LIST_INDEX: u32 = 0x0B33;
    #[classattr]
    const LIST_MODE: u32 = 0x0B30;
    #[classattr]
    const LOAD: u32 = 0x0101;
    #[classattr]
    const LOGIC_OP: u32 = 0x0BF1;
    #[classattr]
    const LOGIC_OP_MODE: u32 = 0x0BF0;
    #[classattr]
    const LOWER_LEFT: u32 = 0x8CA1;
    #[classattr]
    const LOW_FLOAT: u32 = 0x8DF0;
    #[classattr]
    const LOW_INT: u32 = 0x8DF3;
    #[classattr]
    const LUMINANCE: u32 = 0x1909;
    #[classattr]
    const LUMINANCE12: u32 = 0x8041;
    #[classattr]
    const LUMINANCE12_ALPHA12: u32 = 0x8047;
    #[classattr]
    const LUMINANCE12_ALPHA4: u32 = 0x8046;
    #[classattr]
    const LUMINANCE16: u32 = 0x8042;
    #[classattr]
    const LUMINANCE16F_EXT: u32 = 0x881E;
    #[classattr]
    const LUMINANCE16_ALPHA16: u32 = 0x8048;
    #[classattr]
    const LUMINANCE32F_EXT: u32 = 0x8818;
    #[classattr]
    const LUMINANCE4: u32 = 0x803F;
    #[classattr]
    const LUMINANCE4_ALPHA4: u32 = 0x8043;
    #[classattr]
    const LUMINANCE6_ALPHA2: u32 = 0x8044;
    #[classattr]
    const LUMINANCE8: u32 = 0x8040;
    #[classattr]
    const LUMINANCE8_ALPHA8: u32 = 0x8045;
    #[classattr]
    const LUMINANCE8_ALPHA8_EXT: u32 = 0x8045;
    #[classattr]
    const LUMINANCE8_EXT: u32 = 0x8040;
    #[classattr]
    const LUMINANCE_ALPHA: u32 = 0x190A;
    #[classattr]
    const LUMINANCE_ALPHA16F_EXT: u32 = 0x881F;
    #[classattr]
    const LUMINANCE_ALPHA32F_EXT: u32 = 0x8819;
    #[classattr]
    const MAJOR_VERSION: u32 = 0x821B;
    #[classattr]
    const MAP1_COLOR_4: u32 = 0x0D90;
    #[classattr]
    const MAP1_GRID_DOMAIN: u32 = 0x0DD0;
    #[classattr]
    const MAP1_GRID_SEGMENTS: u32 = 0x0DD1;
    #[classattr]
    const MAP1_INDEX: u32 = 0x0D91;
    #[classattr]
    const MAP1_NORMAL: u32 = 0x0D92;
    #[classattr]
    const MAP1_TEXTURE_COORD_1: u32 = 0x0D93;
    #[classattr]
    const MAP1_TEXTURE_COORD_2: u32 = 0x0D94;
    #[classattr]
    const MAP1_TEXTURE_COORD_3: u32 = 0x0D95;
    #[classattr]
    const MAP1_TEXTURE_COORD_4: u32 = 0x0D96;
    #[classattr]
    const MAP1_VERTEX_3: u32 = 0x0D97;
    #[classattr]
    const MAP1_VERTEX_4: u32 = 0x0D98;
    #[classattr]
    const MAP2_COLOR_4: u32 = 0x0DB0;
    #[classattr]
    const MAP2_GRID_DOMAIN: u32 = 0x0DD2;
    #[classattr]
    const MAP2_GRID_SEGMENTS: u32 = 0x0DD3;
    #[classattr]
    const MAP2_INDEX: u32 = 0x0DB1;
    #[classattr]
    const MAP2_NORMAL: u32 = 0x0DB2;
    #[classattr]
    const MAP2_TEXTURE_COORD_1: u32 = 0x0DB3;
    #[classattr]
    const MAP2_TEXTURE_COORD_2: u32 = 0x0DB4;
    #[classattr]
    const MAP2_TEXTURE_COORD_3: u32 = 0x0DB5;
    #[classattr]
    const MAP2_TEXTURE_COORD_4: u32 = 0x0DB6;
    #[classattr]
    const MAP2_VERTEX_3: u32 = 0x0DB7;
    #[classattr]
    const MAP2_VERTEX_4: u32 = 0x0DB8;
    #[classattr]
    const MAP_COLOR: u32 = 0x0D10;
    #[classattr]
    const MAP_FLUSH_EXPLICIT_BIT: u32 = 0x0010;
    #[classattr]
    const MAP_INVALIDATE_BUFFER_BIT: u32 = 0x0008;
    #[classattr]
    const MAP_INVALIDATE_RANGE_BIT: u32 = 0x0004;
    #[classattr]
    const MAP_READ_BIT: u32 = 0x0001;
    #[classattr]
    const MAP_STENCIL: u32 = 0x0D11;
    #[classattr]
    const MAP_UNSYNCHRONIZED_BIT: u32 = 0x0020;
    #[classattr]
    const MAP_WRITE_BIT: u32 = 0x0002;
    #[classattr]
    const MATRIX_MODE: u32 = 0x0BA0;
    #[classattr]
    const MAX: u32 = 0x8008;
    #[classattr]
    const MAX_3D_TEXTURE_SIZE: u32 = 0x8073;
    #[classattr]
    const MAX_ARRAY_TEXTURE_LAYERS: u32 = 0x88FF;
    #[classattr]
    const MAX_ATTRIB_STACK_DEPTH: u32 = 0x0D35;
    #[classattr]
    const MAX_CLIENT_ATTRIB_STACK_DEPTH: u32 = 0x0D3B;
    #[classattr]
    const MAX_CLIP_DISTANCES: u32 = 0x0D32;
    #[classattr]
    const MAX_CLIP_PLANES: u32 = 0x0D32;
    #[classattr]
    const MAX_COLOR_ATTACHMENTS: u32 = 0x8CDF;
    #[classattr]
    const MAX_COLOR_TEXTURE_SAMPLES: u32 = 0x910E;
    #[classattr]
    const MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8A33;
    #[classattr]
    const MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS: u32 = 0x8A32;
    #[classattr]
    const MAX_COMBINED_TEXTURE_IMAGE_UNITS: u32 = 0x8B4D;
    #[classattr]
    const MAX_COMBINED_UNIFORM_BLOCKS: u32 = 0x8A2E;
    #[classattr]
    const MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8A31;
    #[classattr]
    const MAX_CUBE_MAP_TEXTURE_SIZE: u32 = 0x851C;
    #[classattr]
    const MAX_DEBUG_GROUP_STACK_DEPTH: u32 = 0x826C;
    #[classattr]
    const MAX_DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826C;
    #[classattr]
    const MAX_DEBUG_LOGGED_MESSAGES: u32 = 0x9144;
    #[classattr]
    const MAX_DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9144;
    #[classattr]
    const MAX_DEBUG_MESSAGE_LENGTH: u32 = 0x9143;
    #[classattr]
    const MAX_DEBUG_MESSAGE_LENGTH_KHR: u32 = 0x9143;
    #[classattr]
    const MAX_DEPTH_TEXTURE_SAMPLES: u32 = 0x910F;
    #[classattr]
    const MAX_DRAW_BUFFERS: u32 = 0x8824;
    #[classattr]
    const MAX_DUAL_SOURCE_DRAW_BUFFERS: u32 = 0x88FC;
    #[classattr]
    const MAX_ELEMENTS_INDICES: u32 = 0x80E9;
    #[classattr]
    const MAX_ELEMENTS_VERTICES: u32 = 0x80E8;
    #[classattr]
    const MAX_ELEMENT_INDEX: u32 = 0x8D6B;
    #[classattr]
    const MAX_EVAL_ORDER: u32 = 0x0D30;
    #[classattr]
    const MAX_FRAGMENT_INPUT_COMPONENTS: u32 = 0x9125;
    #[classattr]
    const MAX_FRAGMENT_UNIFORM_BLOCKS: u32 = 0x8A2D;
    #[classattr]
    const MAX_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8B49;
    #[classattr]
    const MAX_FRAGMENT_UNIFORM_VECTORS: u32 = 0x8DFD;
    #[classattr]
    const MAX_GEOMETRY_INPUT_COMPONENTS: u32 = 0x9123;
    #[classattr]
    const MAX_GEOMETRY_OUTPUT_COMPONENTS: u32 = 0x9124;
    #[classattr]
    const MAX_GEOMETRY_OUTPUT_VERTICES: u32 = 0x8DE0;
    #[classattr]
    const MAX_GEOMETRY_TEXTURE_IMAGE_UNITS: u32 = 0x8C29;
    #[classattr]
    const MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS: u32 = 0x8DE1;
    #[classattr]
    const MAX_GEOMETRY_UNIFORM_BLOCKS: u32 = 0x8A2C;
    #[classattr]
    const MAX_GEOMETRY_UNIFORM_COMPONENTS: u32 = 0x8DDF;
    #[classattr]
    const MAX_INTEGER_SAMPLES: u32 = 0x9110;
    #[classattr]
    const MAX_LABEL_LENGTH: u32 = 0x82E8;
    #[classattr]
    const MAX_LABEL_LENGTH_KHR: u32 = 0x82E8;
    #[classattr]
    const MAX_LIGHTS: u32 = 0x0D31;
    #[classattr]
    const MAX_LIST_NESTING: u32 = 0x0B31;
    #[classattr]
    const MAX_MODELVIEW_STACK_DEPTH: u32 = 0x0D36;
    #[classattr]
    const MAX_NAME_STACK_DEPTH: u32 = 0x0D37;
    #[classattr]
    const MAX_PIXEL_MAP_TABLE: u32 = 0x0D34;
    #[classattr]
    const MAX_PROGRAM_TEXEL_OFFSET: u32 = 0x8905;
    #[classattr]
    const MAX_PROJECTION_STACK_DEPTH: u32 = 0x0D38;
    #[classattr]
    const MAX_RECTANGLE_TEXTURE_SIZE: u32 = 0x84F8;
    #[classattr]
    const MAX_RECTANGLE_TEXTURE_SIZE_ARB: u32 = 0x84F8;
    #[classattr]
    const MAX_RENDERBUFFER_SIZE: u32 = 0x84E8;
    #[classattr]
    const MAX_SAMPLES: u32 = 0x8D57;
    #[classattr]
    const MAX_SAMPLE_MASK_WORDS: u32 = 0x8E59;
    #[classattr]
    const MAX_SERVER_WAIT_TIMEOUT: u32 = 0x9111;
    #[classattr]
    const MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT: u32 = 0x8F63;
    #[classattr]
    const MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT: u32 = 0x8F67;
    #[classattr]
    const MAX_TEXTURE_BUFFER_SIZE: u32 = 0x8C2B;
    #[classattr]
    const MAX_TEXTURE_COORDS: u32 = 0x8871;
    #[classattr]
    const MAX_TEXTURE_IMAGE_UNITS: u32 = 0x8872;
    #[classattr]
    const MAX_TEXTURE_LOD_BIAS: u32 = 0x84FD;
    #[classattr]
    const MAX_TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FF;
    #[classattr]
    const MAX_TEXTURE_SIZE: u32 = 0x0D33;
    #[classattr]
    const MAX_TEXTURE_STACK_DEPTH: u32 = 0x0D39;
    #[classattr]
    const MAX_TEXTURE_UNITS: u32 = 0x84E2;
    #[classattr]
    const MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: u32 = 0x8C8A;
    #[classattr]
    const MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: u32 = 0x8C8B;
    #[classattr]
    const MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: u32 = 0x8C80;
    #[classattr]
    const MAX_UNIFORM_BLOCK_SIZE: u32 = 0x8A30;
    #[classattr]
    const MAX_UNIFORM_BUFFER_BINDINGS: u32 = 0x8A2F;
    #[classattr]
    const MAX_VARYING_COMPONENTS: u32 = 0x8B4B;
    #[classattr]
    const MAX_VARYING_FLOATS: u32 = 0x8B4B;
    #[classattr]
    const MAX_VARYING_VECTORS: u32 = 0x8DFC;
    #[classattr]
    const MAX_VERTEX_ATTRIBS: u32 = 0x8869;
    #[classattr]
    const MAX_VERTEX_OUTPUT_COMPONENTS: u32 = 0x9122;
    #[classattr]
    const MAX_VERTEX_TEXTURE_IMAGE_UNITS: u32 = 0x8B4C;
    #[classattr]
    const MAX_VERTEX_UNIFORM_BLOCKS: u32 = 0x8A2B;
    #[classattr]
    const MAX_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8B4A;
    #[classattr]
    const MAX_VERTEX_UNIFORM_VECTORS: u32 = 0x8DFB;
    #[classattr]
    const MAX_VIEWPORT_DIMS: u32 = 0x0D3A;
    #[classattr]
    const MEDIUM_FLOAT: u32 = 0x8DF1;
    #[classattr]
    const MEDIUM_INT: u32 = 0x8DF4;
    #[classattr]
    const MIN: u32 = 0x8007;
    #[classattr]
    const MINOR_VERSION: u32 = 0x821C;
    #[classattr]
    const MIN_PROGRAM_TEXEL_OFFSET: u32 = 0x8904;
    #[classattr]
    const MIRRORED_REPEAT: u32 = 0x8370;
    #[classattr]
    const MODELVIEW: u32 = 0x1700;
    #[classattr]
    const MODELVIEW_MATRIX: u32 = 0x0BA6;
    #[classattr]
    const MODELVIEW_STACK_DEPTH: u32 = 0x0BA3;
    #[classattr]
    const MODULATE: u32 = 0x2100;
    #[classattr]
    const MULT: u32 = 0x0103;
    #[classattr]
    const MULTIPLY_KHR: u32 = 0x9294;
    #[classattr]
    const MULTISAMPLE: u32 = 0x809D;
    #[classattr]
    const MULTISAMPLE_BIT: u32 = 0x20000000;
    #[classattr]
    const N3F_V3F: u32 = 0x2A25;
    #[classattr]
    const NAME_STACK_DEPTH: u32 = 0x0D70;
    #[classattr]
    const NAND: u32 = 0x150E;
    #[classattr]
    const NEAREST: u32 = 0x2600;
    #[classattr]
    const NEAREST_MIPMAP_LINEAR: u32 = 0x2702;
    #[classattr]
    const NEAREST_MIPMAP_NEAREST: u32 = 0x2700;
    #[classattr]
    const NEVER: u32 = 0x0200;
    #[classattr]
    const NICEST: u32 = 0x1102;
    #[classattr]
    const NONE: u32 = 0;
    #[classattr]
    const NOOP: u32 = 0x1505;
    #[classattr]
    const NOR: u32 = 0x1508;
    #[classattr]
    const NORMALIZE: u32 = 0x0BA1;
    #[classattr]
    const NORMAL_ARRAY: u32 = 0x8075;
    #[classattr]
    const NORMAL_ARRAY_BUFFER_BINDING: u32 = 0x8897;
    #[classattr]
    const NORMAL_ARRAY_POINTER: u32 = 0x808F;
    #[classattr]
    const NORMAL_ARRAY_STRIDE: u32 = 0x807F;
    #[classattr]
    const NORMAL_ARRAY_TYPE: u32 = 0x807E;
    #[classattr]
    const NORMAL_MAP: u32 = 0x8511;
    #[classattr]
    const NOTEQUAL: u32 = 0x0205;
    #[classattr]
    const NO_ERROR: u32 = 0;
    #[classattr]
    const NUM_COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A2;
    #[classattr]
    const NUM_EXTENSIONS: u32 = 0x821D;
    #[classattr]
    const NUM_PROGRAM_BINARY_FORMATS: u32 = 0x87FE;
    #[classattr]
    const NUM_SAMPLE_COUNTS: u32 = 0x9380;
    #[classattr]
    const NUM_SHADER_BINARY_FORMATS: u32 = 0x8DF9;
    #[classattr]
    const OBJECT_LINEAR: u32 = 0x2401;
    #[classattr]
    const OBJECT_PLANE: u32 = 0x2501;
    #[classattr]
    const OBJECT_TYPE: u32 = 0x9112;
    #[classattr]
    const ONE: u32 = 1;
    #[classattr]
    const ONE_MINUS_CONSTANT_ALPHA: u32 = 0x8004;
    #[classattr]
    const ONE_MINUS_CONSTANT_COLOR: u32 = 0x8002;
    #[classattr]
    const ONE_MINUS_DST_ALPHA: u32 = 0x0305;
    #[classattr]
    const ONE_MINUS_DST_COLOR: u32 = 0x0307;
    #[classattr]
    const ONE_MINUS_SRC1_ALPHA: u32 = 0x88FB;
    #[classattr]
    const ONE_MINUS_SRC1_COLOR: u32 = 0x88FA;
    #[classattr]
    const ONE_MINUS_SRC_ALPHA: u32 = 0x0303;
    #[classattr]
    const ONE_MINUS_SRC_COLOR: u32 = 0x0301;
    #[classattr]
    const OPERAND0_ALPHA: u32 = 0x8598;
    #[classattr]
    const OPERAND0_RGB: u32 = 0x8590;
    #[classattr]
    const OPERAND1_ALPHA: u32 = 0x8599;
    #[classattr]
    const OPERAND1_RGB: u32 = 0x8591;
    #[classattr]
    const OPERAND2_ALPHA: u32 = 0x859A;
    #[classattr]
    const OPERAND2_RGB: u32 = 0x8592;
    #[classattr]
    const OR: u32 = 0x1507;
    #[classattr]
    const ORDER: u32 = 0x0A01;
    #[classattr]
    const OR_INVERTED: u32 = 0x150D;
    #[classattr]
    const OR_REVERSE: u32 = 0x150B;
    #[classattr]
    const OUT_OF_MEMORY: u32 = 0x0505;
    #[classattr]
    const OVERLAY_KHR: u32 = 0x9296;
    #[classattr]
    const PACK_ALIGNMENT: u32 = 0x0D05;
    #[classattr]
    const PACK_IMAGE_HEIGHT: u32 = 0x806C;
    #[classattr]
    const PACK_LSB_FIRST: u32 = 0x0D01;
    #[classattr]
    const PACK_ROW_LENGTH: u32 = 0x0D02;
    #[classattr]
    const PACK_SKIP_IMAGES: u32 = 0x806B;
    #[classattr]
    const PACK_SKIP_PIXELS: u32 = 0x0D04;
    #[classattr]
    const PACK_SKIP_ROWS: u32 = 0x0D03;
    #[classattr]
    const PACK_SWAP_BYTES: u32 = 0x0D00;
    #[classattr]
    const PASS_THROUGH_TOKEN: u32 = 0x0700;
    #[classattr]
    const PERSPECTIVE_CORRECTION_HINT: u32 = 0x0C50;
    #[classattr]
    const PIXEL_MAP_A_TO_A: u32 = 0x0C79;
    #[classattr]
    const PIXEL_MAP_A_TO_A_SIZE: u32 = 0x0CB9;
    #[classattr]
    const PIXEL_MAP_B_TO_B: u32 = 0x0C78;
    #[classattr]
    const PIXEL_MAP_B_TO_B_SIZE: u32 = 0x0CB8;
    #[classattr]
    const PIXEL_MAP_G_TO_G: u32 = 0x0C77;
    #[classattr]
    const PIXEL_MAP_G_TO_G_SIZE: u32 = 0x0CB7;
    #[classattr]
    const PIXEL_MAP_I_TO_A: u32 = 0x0C75;
    #[classattr]
    const PIXEL_MAP_I_TO_A_SIZE: u32 = 0x0CB5;
    #[classattr]
    const PIXEL_MAP_I_TO_B: u32 = 0x0C74;
    #[classattr]
    const PIXEL_MAP_I_TO_B_SIZE: u32 = 0x0CB4;
    #[classattr]
    const PIXEL_MAP_I_TO_G: u32 = 0x0C73;
    #[classattr]
    const PIXEL_MAP_I_TO_G_SIZE: u32 = 0x0CB3;
    #[classattr]
    const PIXEL_MAP_I_TO_I: u32 = 0x0C70;
    #[classattr]
    const PIXEL_MAP_I_TO_I_SIZE: u32 = 0x0CB0;
    #[classattr]
    const PIXEL_MAP_I_TO_R: u32 = 0x0C72;
    #[classattr]
    const PIXEL_MAP_I_TO_R_SIZE: u32 = 0x0CB2;
    #[classattr]
    const PIXEL_MAP_R_TO_R: u32 = 0x0C76;
    #[classattr]
    const PIXEL_MAP_R_TO_R_SIZE: u32 = 0x0CB6;
    #[classattr]
    const PIXEL_MAP_S_TO_S: u32 = 0x0C71;
    #[classattr]
    const PIXEL_MAP_S_TO_S_SIZE: u32 = 0x0CB1;
    #[classattr]
    const PIXEL_MODE_BIT: u32 = 0x00000020;
    #[classattr]
    const PIXEL_PACK_BUFFER: u32 = 0x88EB;
    #[classattr]
    const PIXEL_PACK_BUFFER_BINDING: u32 = 0x88ED;
    #[classattr]
    const PIXEL_UNPACK_BUFFER: u32 = 0x88EC;
    #[classattr]
    const PIXEL_UNPACK_BUFFER_BINDING: u32 = 0x88EF;
    #[classattr]
    const POINT: u32 = 0x1B00;
    #[classattr]
    const POINTS: u32 = 0x0000;
    #[classattr]
    const POINT_BIT: u32 = 0x00000002;
    #[classattr]
    const POINT_DISTANCE_ATTENUATION: u32 = 0x8129;
    #[classattr]
    const POINT_FADE_THRESHOLD_SIZE: u32 = 0x8128;
    #[classattr]
    const POINT_SIZE: u32 = 0x0B11;
    #[classattr]
    const POINT_SIZE_GRANULARITY: u32 = 0x0B13;
    #[classattr]
    const POINT_SIZE_MAX: u32 = 0x8127;
    #[classattr]
    const POINT_SIZE_MIN: u32 = 0x8126;
    #[classattr]
    const POINT_SIZE_RANGE: u32 = 0x0B12;
    #[classattr]
    const POINT_SMOOTH: u32 = 0x0B10;
    #[classattr]
    const POINT_SMOOTH_HINT: u32 = 0x0C51;
    #[classattr]
    const POINT_SPRITE: u32 = 0x8861;
    #[classattr]
    const POINT_SPRITE_COORD_ORIGIN: u32 = 0x8CA0;
    #[classattr]
    const POINT_TOKEN: u32 = 0x0701;
    #[classattr]
    const POLYGON: u32 = 0x0009;
    #[classattr]
    const POLYGON_BIT: u32 = 0x00000008;
    #[classattr]
    const POLYGON_MODE: u32 = 0x0B40;
    #[classattr]
    const POLYGON_OFFSET_FACTOR: u32 = 0x8038;
    #[classattr]
    const POLYGON_OFFSET_FILL: u32 = 0x8037;
    #[classattr]
    const POLYGON_OFFSET_LINE: u32 = 0x2A02;
    #[classattr]
    const POLYGON_OFFSET_POINT: u32 = 0x2A01;
    #[classattr]
    const POLYGON_OFFSET_UNITS: u32 = 0x2A00;
    #[classattr]
    const POLYGON_SMOOTH: u32 = 0x0B41;
    #[classattr]
    const POLYGON_SMOOTH_HINT: u32 = 0x0C53;
    #[classattr]
    const POLYGON_STIPPLE: u32 = 0x0B42;
    #[classattr]
    const POLYGON_STIPPLE_BIT: u32 = 0x00000010;
    #[classattr]
    const POLYGON_TOKEN: u32 = 0x0703;
    #[classattr]
    const POSITION: u32 = 0x1203;
    #[classattr]
    const PREVIOUS: u32 = 0x8578;
    #[classattr]
    const PRIMARY_COLOR: u32 = 0x8577;
    #[classattr]
    const PRIMITIVES_GENERATED: u32 = 0x8C87;
    #[classattr]
    const PRIMITIVE_RESTART: u32 = 0x8F9D;
    #[classattr]
    const PRIMITIVE_RESTART_FIXED_INDEX: u32 = 0x8D69;
    #[classattr]
    const PRIMITIVE_RESTART_INDEX: u32 = 0x8F9E;
    #[classattr]
    const PROGRAM: u32 = 0x82E2;
    #[classattr]
    const PROGRAM_BINARY_FORMATS: u32 = 0x87FF;
    #[classattr]
    const PROGRAM_BINARY_LENGTH: u32 = 0x8741;
    #[classattr]
    const PROGRAM_BINARY_RETRIEVABLE_HINT: u32 = 0x8257;
    #[classattr]
    const PROGRAM_KHR: u32 = 0x82E2;
    #[classattr]
    const PROGRAM_PIPELINE: u32 = 0x82E4;
    #[classattr]
    const PROGRAM_PIPELINE_KHR: u32 = 0x82E4;
    #[classattr]
    const PROGRAM_POINT_SIZE: u32 = 0x8642;
    #[classattr]
    const PROJECTION: u32 = 0x1701;
    #[classattr]
    const PROJECTION_MATRIX: u32 = 0x0BA7;
    #[classattr]
    const PROJECTION_STACK_DEPTH: u32 = 0x0BA4;
    #[classattr]
    const PROVOKING_VERTEX: u32 = 0x8E4F;
    #[classattr]
    const PROXY_TEXTURE_1D: u32 = 0x8063;
    #[classattr]
    const PROXY_TEXTURE_1D_ARRAY: u32 = 0x8C19;
    #[classattr]
    const PROXY_TEXTURE_2D: u32 = 0x8064;
    #[classattr]
    const PROXY_TEXTURE_2D_ARRAY: u32 = 0x8C1B;
    #[classattr]
    const PROXY_TEXTURE_2D_MULTISAMPLE: u32 = 0x9101;
    #[classattr]
    const PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: u32 = 0x9103;
    #[classattr]
    const PROXY_TEXTURE_3D: u32 = 0x8070;
    #[classattr]
    const PROXY_TEXTURE_CUBE_MAP: u32 = 0x851B;
    #[classattr]
    const PROXY_TEXTURE_RECTANGLE: u32 = 0x84F7;
    #[classattr]
    const PROXY_TEXTURE_RECTANGLE_ARB: u32 = 0x84F7;
    #[classattr]
    const Q: u32 = 0x2003;
    #[classattr]
    const QUADRATIC_ATTENUATION: u32 = 0x1209;
    #[classattr]
    const QUADS: u32 = 0x0007;
    #[classattr]
    const QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION: u32 = 0x8E4C;
    #[classattr]
    const QUAD_STRIP: u32 = 0x0008;
    #[classattr]
    const QUERY: u32 = 0x82E3;
    #[classattr]
    const QUERY_BY_REGION_NO_WAIT: u32 = 0x8E16;
    #[classattr]
    const QUERY_BY_REGION_WAIT: u32 = 0x8E15;
    #[classattr]
    const QUERY_COUNTER_BITS: u32 = 0x8864;
    #[classattr]
    const QUERY_COUNTER_BITS_EXT: u32 = 0x8864;
    #[classattr]
    const QUERY_KHR: u32 = 0x82E3;
    #[classattr]
    const QUERY_NO_WAIT: u32 = 0x8E14;
    #[classattr]
    const QUERY_RESULT: u32 = 0x8866;
    #[classattr]
    const QUERY_RESULT_AVAILABLE: u32 = 0x8867;
    #[classattr]
    const QUERY_RESULT_AVAILABLE_EXT: u32 = 0x8867;
    #[classattr]
    const QUERY_RESULT_EXT: u32 = 0x8866;
    #[classattr]
    const QUERY_WAIT: u32 = 0x8E13;
    #[classattr]
    const R: u32 = 0x2002;
    #[classattr]
    const R11F_G11F_B10F: u32 = 0x8C3A;
    #[classattr]
    const R16: u32 = 0x822A;
    #[classattr]
    const R16F: u32 = 0x822D;
    #[classattr]
    const R16F_EXT: u32 = 0x822D;
    #[classattr]
    const R16I: u32 = 0x8233;
    #[classattr]
    const R16UI: u32 = 0x8234;
    #[classattr]
    const R16_SNORM: u32 = 0x8F98;
    #[classattr]
    const R32F: u32 = 0x822E;
    #[classattr]
    const R32F_EXT: u32 = 0x822E;
    #[classattr]
    const R32I: u32 = 0x8235;
    #[classattr]
    const R32UI: u32 = 0x8236;
    #[classattr]
    const R3_G3_B2: u32 = 0x2A10;
    #[classattr]
    const R8: u32 = 0x8229;
    #[classattr]
    const R8I: u32 = 0x8231;
    #[classattr]
    const R8UI: u32 = 0x8232;
    #[classattr]
    const R8_EXT: u32 = 0x8229;
    #[classattr]
    const R8_SNORM: u32 = 0x8F94;
    #[classattr]
    const RASTERIZER_DISCARD: u32 = 0x8C89;
    #[classattr]
    const READ_BUFFER: u32 = 0x0C02;
    #[classattr]
    const READ_FRAMEBUFFER: u32 = 0x8CA8;
    #[classattr]
    const READ_FRAMEBUFFER_BINDING: u32 = 0x8CAA;
    #[classattr]
    const READ_ONLY: u32 = 0x88B8;
    #[classattr]
    const READ_WRITE: u32 = 0x88BA;
    #[classattr]
    const RED: u32 = 0x1903;
    #[classattr]
    const RED_BIAS: u32 = 0x0D15;
    #[classattr]
    const RED_BITS: u32 = 0x0D52;
    #[classattr]
    const RED_INTEGER: u32 = 0x8D94;
    #[classattr]
    const RED_SCALE: u32 = 0x0D14;
    #[classattr]
    const REFLECTION_MAP: u32 = 0x8512;
    #[classattr]
    const RENDER: u32 = 0x1C00;
    #[classattr]
    const RENDERBUFFER: u32 = 0x8D41;
    #[classattr]
    const RENDERBUFFER_ALPHA_SIZE: u32 = 0x8D53;
    #[classattr]
    const RENDERBUFFER_BINDING: u32 = 0x8CA7;
    #[classattr]
    const RENDERBUFFER_BLUE_SIZE: u32 = 0x8D52;
    #[classattr]
    const RENDERBUFFER_DEPTH_SIZE: u32 = 0x8D54;
    #[classattr]
    const RENDERBUFFER_GREEN_SIZE: u32 = 0x8D51;
    #[classattr]
    const RENDERBUFFER_HEIGHT: u32 = 0x8D43;
    #[classattr]
    const RENDERBUFFER_INTERNAL_FORMAT: u32 = 0x8D44;
    #[classattr]
    const RENDERBUFFER_RED_SIZE: u32 = 0x8D50;
    #[classattr]
    const RENDERBUFFER_SAMPLES: u32 = 0x8CAB;
    #[classattr]
    const RENDERBUFFER_STENCIL_SIZE: u32 = 0x8D55;
    #[classattr]
    const RENDERBUFFER_WIDTH: u32 = 0x8D42;
    #[classattr]
    const RENDERER: u32 = 0x1F01;
    #[classattr]
    const RENDER_MODE: u32 = 0x0C40;
    #[classattr]
    const REPEAT: u32 = 0x2901;
    #[classattr]
    const REPLACE: u32 = 0x1E01;
    #[classattr]
    const REQUIRED_TEXTURE_IMAGE_UNITS_OES: u32 = 0x8D68;
    #[classattr]
    const RESCALE_NORMAL: u32 = 0x803A;
    #[classattr]
    const RETURN: u32 = 0x0102;
    #[classattr]
    const RG: u32 = 0x8227;
    #[classattr]
    const RG16: u32 = 0x822C;
    #[classattr]
    const RG16F: u32 = 0x822F;
    #[classattr]
    const RG16F_EXT: u32 = 0x822F;
    #[classattr]
    const RG16I: u32 = 0x8239;
    #[classattr]
    const RG16UI: u32 = 0x823A;
    #[classattr]
    const RG16_SNORM: u32 = 0x8F99;
    #[classattr]
    const RG32F: u32 = 0x8230;
    #[classattr]
    const RG32F_EXT: u32 = 0x8230;
    #[classattr]
    const RG32I: u32 = 0x823B;
    #[classattr]
    const RG32UI: u32 = 0x823C;
    #[classattr]
    const RG8: u32 = 0x822B;
    #[classattr]
    const RG8I: u32 = 0x8237;
    #[classattr]
    const RG8UI: u32 = 0x8238;
    #[classattr]
    const RG8_EXT: u32 = 0x822B;
    #[classattr]
    const RG8_SNORM: u32 = 0x8F95;
    #[classattr]
    const RGB: u32 = 0x1907;
    #[classattr]
    const RGB10: u32 = 0x8052;
    #[classattr]
    const RGB10_A2: u32 = 0x8059;
    #[classattr]
    const RGB10_A2UI: u32 = 0x906F;
    #[classattr]
    const RGB10_A2_EXT: u32 = 0x8059;
    #[classattr]
    const RGB10_EXT: u32 = 0x8052;
    #[classattr]
    const RGB12: u32 = 0x8053;
    #[classattr]
    const RGB16: u32 = 0x8054;
    #[classattr]
    const RGB16F: u32 = 0x881B;
    #[classattr]
    const RGB16F_EXT: u32 = 0x881B;
    #[classattr]
    const RGB16I: u32 = 0x8D89;
    #[classattr]
    const RGB16UI: u32 = 0x8D77;
    #[classattr]
    const RGB16_SNORM: u32 = 0x8F9A;
    #[classattr]
    const RGB32F: u32 = 0x8815;
    #[classattr]
    const RGB32F_EXT: u32 = 0x8815;
    #[classattr]
    const RGB32I: u32 = 0x8D83;
    #[classattr]
    const RGB32UI: u32 = 0x8D71;
    #[classattr]
    const RGB4: u32 = 0x804F;
    #[classattr]
    const RGB5: u32 = 0x8050;
    #[classattr]
    const RGB565: u32 = 0x8D62;
    #[classattr]
    const RGB5_A1: u32 = 0x8057;
    #[classattr]
    const RGB8: u32 = 0x8051;
    #[classattr]
    const RGB8I: u32 = 0x8D8F;
    #[classattr]
    const RGB8UI: u32 = 0x8D7D;
    #[classattr]
    const RGB8_SNORM: u32 = 0x8F96;
    #[classattr]
    const RGB9_E5: u32 = 0x8C3D;
    #[classattr]
    const RGBA: u32 = 0x1908;
    #[classattr]
    const RGBA12: u32 = 0x805A;
    #[classattr]
    const RGBA16: u32 = 0x805B;
    #[classattr]
    const RGBA16F: u32 = 0x881A;
    #[classattr]
    const RGBA16F_EXT: u32 = 0x881A;
    #[classattr]
    const RGBA16I: u32 = 0x8D88;
    #[classattr]
    const RGBA16UI: u32 = 0x8D76;
    #[classattr]
    const RGBA16_SNORM: u32 = 0x8F9B;
    #[classattr]
    const RGBA2: u32 = 0x8055;
    #[classattr]
    const RGBA32F: u32 = 0x8814;
    #[classattr]
    const RGBA32F_EXT: u32 = 0x8814;
    #[classattr]
    const RGBA32I: u32 = 0x8D82;
    #[classattr]
    const RGBA32UI: u32 = 0x8D70;
    #[classattr]
    const RGBA4: u32 = 0x8056;
    #[classattr]
    const RGBA8: u32 = 0x8058;
    #[classattr]
    const RGBA8I: u32 = 0x8D8E;
    #[classattr]
    const RGBA8UI: u32 = 0x8D7C;
    #[classattr]
    const RGBA8_SNORM: u32 = 0x8F97;
    #[classattr]
    const RGBA_INTEGER: u32 = 0x8D99;
    #[classattr]
    const RGBA_MODE: u32 = 0x0C31;
    #[classattr]
    const RGB_INTEGER: u32 = 0x8D98;
    #[classattr]
    const RGB_SCALE: u32 = 0x8573;
    #[classattr]
    const RG_INTEGER: u32 = 0x8228;
    #[classattr]
    const RIGHT: u32 = 0x0407;
    #[classattr]
    const S: u32 = 0x2000;
    #[classattr]
    const SAMPLER: u32 = 0x82E6;
    #[classattr]
    const SAMPLER_1D: u32 = 0x8B5D;
    #[classattr]
    const SAMPLER_1D_ARRAY: u32 = 0x8DC0;
    #[classattr]
    const SAMPLER_1D_ARRAY_SHADOW: u32 = 0x8DC3;
    #[classattr]
    const SAMPLER_1D_SHADOW: u32 = 0x8B61;
    #[classattr]
    const SAMPLER_2D: u32 = 0x8B5E;
    #[classattr]
    const SAMPLER_2D_ARRAY: u32 = 0x8DC1;
    #[classattr]
    const SAMPLER_2D_ARRAY_SHADOW: u32 = 0x8DC4;
    #[classattr]
    const SAMPLER_2D_MULTISAMPLE: u32 = 0x9108;
    #[classattr]
    const SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910B;
    #[classattr]
    const SAMPLER_2D_RECT: u32 = 0x8B63;
    #[classattr]
    const SAMPLER_2D_RECT_SHADOW: u32 = 0x8B64;
    #[classattr]
    const SAMPLER_2D_SHADOW: u32 = 0x8B62;
    #[classattr]
    const SAMPLER_3D: u32 = 0x8B5F;
    #[classattr]
    const SAMPLER_BINDING: u32 = 0x8919;
    #[classattr]
    const SAMPLER_BUFFER: u32 = 0x8DC2;
    #[classattr]
    const SAMPLER_CUBE: u32 = 0x8B60;
    #[classattr]
    const SAMPLER_CUBE_SHADOW: u32 = 0x8DC5;
    #[classattr]
    const SAMPLER_EXTERNAL_OES: u32 = 0x8D66;
    #[classattr]
    const SAMPLER_KHR: u32 = 0x82E6;
    #[classattr]
    const SAMPLES: u32 = 0x80A9;
    #[classattr]
    const SAMPLES_PASSED: u32 = 0x8914;
    #[classattr]
    const SAMPLE_ALPHA_TO_COVERAGE: u32 = 0x809E;
    #[classattr]
    const SAMPLE_ALPHA_TO_ONE: u32 = 0x809F;
    #[classattr]
    const SAMPLE_BUFFERS: u32 = 0x80A8;
    #[classattr]
    const SAMPLE_COVERAGE: u32 = 0x80A0;
    #[classattr]
    const SAMPLE_COVERAGE_INVERT: u32 = 0x80AB;
    #[classattr]
    const SAMPLE_COVERAGE_VALUE: u32 = 0x80AA;
    #[classattr]
    const SAMPLE_MASK: u32 = 0x8E51;
    #[classattr]
    const SAMPLE_MASK_VALUE: u32 = 0x8E52;
    #[classattr]
    const SAMPLE_POSITION: u32 = 0x8E50;
    #[classattr]
    const SCISSOR_BIT: u32 = 0x00080000;
    #[classattr]
    const SCISSOR_BOX: u32 = 0x0C10;
    #[classattr]
    const SCISSOR_TEST: u32 = 0x0C11;
    #[classattr]
    const SCREEN_KHR: u32 = 0x9295;
    #[classattr]
    const SECONDARY_COLOR_ARRAY: u32 = 0x845E;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_BUFFER_BINDING: u32 = 0x889C;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_POINTER: u32 = 0x845D;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_SIZE: u32 = 0x845A;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_STRIDE: u32 = 0x845C;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_TYPE: u32 = 0x845B;
    #[classattr]
    const SELECT: u32 = 0x1C02;
    #[classattr]
    const SELECTION_BUFFER_POINTER: u32 = 0x0DF3;
    #[classattr]
    const SELECTION_BUFFER_SIZE: u32 = 0x0DF4;
    #[classattr]
    const SEPARATE_ATTRIBS: u32 = 0x8C8D;
    #[classattr]
    const SEPARATE_SPECULAR_COLOR: u32 = 0x81FA;
    #[classattr]
    const SET: u32 = 0x150F;
    #[classattr]
    const SHADER: u32 = 0x82E1;
    #[classattr]
    const SHADER_BINARY_FORMATS: u32 = 0x8DF8;
    #[classattr]
    const SHADER_COMPILER: u32 = 0x8DFA;
    #[classattr]
    const SHADER_KHR: u32 = 0x82E1;
    #[classattr]
    const SHADER_PIXEL_LOCAL_STORAGE_EXT: u32 = 0x8F64;
    #[classattr]
    const SHADER_SOURCE_LENGTH: u32 = 0x8B88;
    #[classattr]
    const SHADER_TYPE: u32 = 0x8B4F;
    #[classattr]
    const SHADE_MODEL: u32 = 0x0B54;
    #[classattr]
    const SHADING_LANGUAGE_VERSION: u32 = 0x8B8C;
    #[classattr]
    const SHININESS: u32 = 0x1601;
    #[classattr]
    const SHORT: u32 = 0x1402;
    #[classattr]
    const SIGNALED: u32 = 0x9119;
    #[classattr]
    const SIGNED_NORMALIZED: u32 = 0x8F9C;
    #[classattr]
    const SINGLE_COLOR: u32 = 0x81F9;
    #[classattr]
    const SLUMINANCE: u32 = 0x8C46;
    #[classattr]
    const SLUMINANCE8: u32 = 0x8C47;
    #[classattr]
    const SLUMINANCE8_ALPHA8: u32 = 0x8C45;
    #[classattr]
    const SLUMINANCE_ALPHA: u32 = 0x8C44;
    #[classattr]
    const SMOOTH: u32 = 0x1D01;
    #[classattr]
    const SMOOTH_LINE_WIDTH_GRANULARITY: u32 = 0x0B23;
    #[classattr]
    const SMOOTH_LINE_WIDTH_RANGE: u32 = 0x0B22;
    #[classattr]
    const SMOOTH_POINT_SIZE_GRANULARITY: u32 = 0x0B13;
    #[classattr]
    const SMOOTH_POINT_SIZE_RANGE: u32 = 0x0B12;
    #[classattr]
    const SOFTLIGHT_KHR: u32 = 0x929C;
    #[classattr]
    const SOURCE0_ALPHA: u32 = 0x8588;
    #[classattr]
    const SOURCE0_RGB: u32 = 0x8580;
    #[classattr]
    const SOURCE1_ALPHA: u32 = 0x8589;
    #[classattr]
    const SOURCE1_RGB: u32 = 0x8581;
    #[classattr]
    const SOURCE2_ALPHA: u32 = 0x858A;
    #[classattr]
    const SOURCE2_RGB: u32 = 0x8582;
    #[classattr]
    const SPECULAR: u32 = 0x1202;
    #[classattr]
    const SPHERE_MAP: u32 = 0x2402;
    #[classattr]
    const SPOT_CUTOFF: u32 = 0x1206;
    #[classattr]
    const SPOT_DIRECTION: u32 = 0x1204;
    #[classattr]
    const SPOT_EXPONENT: u32 = 0x1205;
    #[classattr]
    const SRC0_ALPHA: u32 = 0x8588;
    #[classattr]
    const SRC0_RGB: u32 = 0x8580;
    #[classattr]
    const SRC1_ALPHA: u32 = 0x8589;
    #[classattr]
    const SRC1_COLOR: u32 = 0x88F9;
    #[classattr]
    const SRC1_RGB: u32 = 0x8581;
    #[classattr]
    const SRC2_ALPHA: u32 = 0x858A;
    #[classattr]
    const SRC2_RGB: u32 = 0x8582;
    #[classattr]
    const SRC_ALPHA: u32 = 0x0302;
    #[classattr]
    const SRC_ALPHA_SATURATE: u32 = 0x0308;
    #[classattr]
    const SRC_COLOR: u32 = 0x0300;
    #[classattr]
    const SRGB: u32 = 0x8C40;
    #[classattr]
    const SRGB8: u32 = 0x8C41;
    #[classattr]
    const SRGB8_ALPHA8: u32 = 0x8C43;
    #[classattr]
    const SRGB_ALPHA: u32 = 0x8C42;
    #[classattr]
    const STACK_OVERFLOW: u32 = 0x0503;
    #[classattr]
    const STACK_OVERFLOW_KHR: u32 = 0x0503;
    #[classattr]
    const STACK_UNDERFLOW: u32 = 0x0504;
    #[classattr]
    const STACK_UNDERFLOW_KHR: u32 = 0x0504;
    #[classattr]
    const STATIC_COPY: u32 = 0x88E6;
    #[classattr]
    const STATIC_DRAW: u32 = 0x88E4;
    #[classattr]
    const STATIC_READ: u32 = 0x88E5;
    #[classattr]
    const STENCIL: u32 = 0x1802;
    #[classattr]
    const STENCIL_ATTACHMENT: u32 = 0x8D20;
    #[classattr]
    const STENCIL_BACK_FAIL: u32 = 0x8801;
    #[classattr]
    const STENCIL_BACK_FUNC: u32 = 0x8800;
    #[classattr]
    const STENCIL_BACK_PASS_DEPTH_FAIL: u32 = 0x8802;
    #[classattr]
    const STENCIL_BACK_PASS_DEPTH_PASS: u32 = 0x8803;
    #[classattr]
    const STENCIL_BACK_REF: u32 = 0x8CA3;
    #[classattr]
    const STENCIL_BACK_VALUE_MASK: u32 = 0x8CA4;
    #[classattr]
    const STENCIL_BACK_WRITEMASK: u32 = 0x8CA5;
    #[classattr]
    const STENCIL_BITS: u32 = 0x0D57;
    #[classattr]
    const STENCIL_BUFFER_BIT: u32 = 0x00000400;
    #[classattr]
    const STENCIL_CLEAR_VALUE: u32 = 0x0B91;
    #[classattr]
    const STENCIL_FAIL: u32 = 0x0B94;
    #[classattr]
    const STENCIL_FUNC: u32 = 0x0B92;
    #[classattr]
    const STENCIL_INDEX: u32 = 0x1901;
    #[classattr]
    const STENCIL_INDEX1: u32 = 0x8D46;
    #[classattr]
    const STENCIL_INDEX16: u32 = 0x8D49;
    #[classattr]
    const STENCIL_INDEX4: u32 = 0x8D47;
    #[classattr]
    const STENCIL_INDEX8: u32 = 0x8D48;
    #[classattr]
    const STENCIL_PASS_DEPTH_FAIL: u32 = 0x0B95;
    #[classattr]
    const STENCIL_PASS_DEPTH_PASS: u32 = 0x0B96;
    #[classattr]
    const STENCIL_REF: u32 = 0x0B97;
    #[classattr]
    const STENCIL_TEST: u32 = 0x0B90;
    #[classattr]
    const STENCIL_VALUE_MASK: u32 = 0x0B93;
    #[classattr]
    const STENCIL_WRITEMASK: u32 = 0x0B98;
    #[classattr]
    const STEREO: u32 = 0x0C33;
    #[classattr]
    const STORAGE_CACHED_APPLE: u32 = 0x85BE;
    #[classattr]
    const STORAGE_PRIVATE_APPLE: u32 = 0x85BD;
    #[classattr]
    const STORAGE_SHARED_APPLE: u32 = 0x85BF;
    #[classattr]
    const STREAM_COPY: u32 = 0x88E2;
    #[classattr]
    const STREAM_DRAW: u32 = 0x88E0;
    #[classattr]
    const STREAM_READ: u32 = 0x88E1;
    #[classattr]
    const SUBPIXEL_BITS: u32 = 0x0D50;
    #[classattr]
    const SUBTRACT: u32 = 0x84E7;
    #[classattr]
    const SYNC_CONDITION: u32 = 0x9113;
    #[classattr]
    const SYNC_FENCE: u32 = 0x9116;
    #[classattr]
    const SYNC_FLAGS: u32 = 0x9115;
    #[classattr]
    const SYNC_FLUSH_COMMANDS_BIT: u32 = 0x00000001;
    #[classattr]
    const SYNC_GPU_COMMANDS_COMPLETE: u32 = 0x9117;
    #[classattr]
    const SYNC_STATUS: u32 = 0x9114;
    #[classattr]
    const T: u32 = 0x2001;
    #[classattr]
    const T2F_C3F_V3F: u32 = 0x2A2A;
    #[classattr]
    const T2F_C4F_N3F_V3F: u32 = 0x2A2C;
    #[classattr]
    const T2F_C4UB_V3F: u32 = 0x2A29;
    #[classattr]
    const T2F_N3F_V3F: u32 = 0x2A2B;
    #[classattr]
    const T2F_V3F: u32 = 0x2A27;
    #[classattr]
    const T4F_C4F_N3F_V4F: u32 = 0x2A2D;
    #[classattr]
    const T4F_V4F: u32 = 0x2A28;
    #[classattr]
    const TEXTURE: u32 = 0x1702;
    #[classattr]
    const TEXTURE0: u32 = 0x84C0;
    #[classattr]
    const TEXTURE1: u32 = 0x84C1;
    #[classattr]
    const TEXTURE10: u32 = 0x84CA;
    #[classattr]
    const TEXTURE11: u32 = 0x84CB;
    #[classattr]
    const TEXTURE12: u32 = 0x84CC;
    #[classattr]
    const TEXTURE13: u32 = 0x84CD;
    #[classattr]
    const TEXTURE14: u32 = 0x84CE;
    #[classattr]
    const TEXTURE15: u32 = 0x84CF;
    #[classattr]
    const TEXTURE16: u32 = 0x84D0;
    #[classattr]
    const TEXTURE17: u32 = 0x84D1;
    #[classattr]
    const TEXTURE18: u32 = 0x84D2;
    #[classattr]
    const TEXTURE19: u32 = 0x84D3;
    #[classattr]
    const TEXTURE2: u32 = 0x84C2;
    #[classattr]
    const TEXTURE20: u32 = 0x84D4;
    #[classattr]
    const TEXTURE21: u32 = 0x84D5;
    #[classattr]
    const TEXTURE22: u32 = 0x84D6;
    #[classattr]
    const TEXTURE23: u32 = 0x84D7;
    #[classattr]
    const TEXTURE24: u32 = 0x84D8;
    #[classattr]
    const TEXTURE25: u32 = 0x84D9;
    #[classattr]
    const TEXTURE26: u32 = 0x84DA;
    #[classattr]
    const TEXTURE27: u32 = 0x84DB;
    #[classattr]
    const TEXTURE28: u32 = 0x84DC;
    #[classattr]
    const TEXTURE29: u32 = 0x84DD;
    #[classattr]
    const TEXTURE3: u32 = 0x84C3;
    #[classattr]
    const TEXTURE30: u32 = 0x84DE;
    #[classattr]
    const TEXTURE31: u32 = 0x84DF;
    #[classattr]
    const TEXTURE4: u32 = 0x84C4;
    #[classattr]
    const TEXTURE5: u32 = 0x84C5;
    #[classattr]
    const TEXTURE6: u32 = 0x84C6;
    #[classattr]
    const TEXTURE7: u32 = 0x84C7;
    #[classattr]
    const TEXTURE8: u32 = 0x84C8;
    #[classattr]
    const TEXTURE9: u32 = 0x84C9;
    #[classattr]
    const TEXTURE_1D: u32 = 0x0DE0;
    #[classattr]
    const TEXTURE_1D_ARRAY: u32 = 0x8C18;
    #[classattr]
    const TEXTURE_2D: u32 = 0x0DE1;
    #[classattr]
    const TEXTURE_2D_ARRAY: u32 = 0x8C1A;
    #[classattr]
    const TEXTURE_2D_MULTISAMPLE: u32 = 0x9100;
    #[classattr]
    const TEXTURE_2D_MULTISAMPLE_ARRAY: u32 = 0x9102;
    #[classattr]
    const TEXTURE_3D: u32 = 0x806F;
    #[classattr]
    const TEXTURE_ALPHA_SIZE: u32 = 0x805F;
    #[classattr]
    const TEXTURE_ALPHA_TYPE: u32 = 0x8C13;
    #[classattr]
    const TEXTURE_BASE_LEVEL: u32 = 0x813C;
    #[classattr]
    const TEXTURE_BINDING_1D: u32 = 0x8068;
    #[classattr]
    const TEXTURE_BINDING_1D_ARRAY: u32 = 0x8C1C;
    #[classattr]
    const TEXTURE_BINDING_2D: u32 = 0x8069;
    #[classattr]
    const TEXTURE_BINDING_2D_ARRAY: u32 = 0x8C1D;
    #[classattr]
    const TEXTURE_BINDING_2D_MULTISAMPLE: u32 = 0x9104;
    #[classattr]
    const TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY: u32 = 0x9105;
    #[classattr]
    const TEXTURE_BINDING_3D: u32 = 0x806A;
    #[classattr]
    const TEXTURE_BINDING_BUFFER: u32 = 0x8C2C;
    #[classattr]
    const TEXTURE_BINDING_CUBE_MAP: u32 = 0x8514;
    #[classattr]
    const TEXTURE_BINDING_EXTERNAL_OES: u32 = 0x8D67;
    #[classattr]
    const TEXTURE_BINDING_RECTANGLE: u32 = 0x84F6;
    #[classattr]
    const TEXTURE_BINDING_RECTANGLE_ARB: u32 = 0x84F6;
    #[classattr]
    const TEXTURE_BIT: u32 = 0x00040000;
    #[classattr]
    const TEXTURE_BLUE_SIZE: u32 = 0x805E;
    #[classattr]
    const TEXTURE_BLUE_TYPE: u32 = 0x8C12;
    #[classattr]
    const TEXTURE_BORDER: u32 = 0x1005;
    #[classattr]
    const TEXTURE_BORDER_COLOR: u32 = 0x1004;
    #[classattr]
    const TEXTURE_BUFFER: u32 = 0x8C2A;
    #[classattr]
    const TEXTURE_BUFFER_DATA_STORE_BINDING: u32 = 0x8C2D;
    #[classattr]
    const TEXTURE_COMPARE_FUNC: u32 = 0x884D;
    #[classattr]
    const TEXTURE_COMPARE_MODE: u32 = 0x884C;
    #[classattr]
    const TEXTURE_COMPONENTS: u32 = 0x1003;
    #[classattr]
    const TEXTURE_COMPRESSED: u32 = 0x86A1;
    #[classattr]
    const TEXTURE_COMPRESSED_IMAGE_SIZE: u32 = 0x86A0;
    #[classattr]
    const TEXTURE_COMPRESSION_HINT: u32 = 0x84EF;
    #[classattr]
    const TEXTURE_COORD_ARRAY: u32 = 0x8078;
    #[classattr]
    const TEXTURE_COORD_ARRAY_BUFFER_BINDING: u32 = 0x889A;
    #[classattr]
    const TEXTURE_COORD_ARRAY_POINTER: u32 = 0x8092;
    #[classattr]
    const TEXTURE_COORD_ARRAY_SIZE: u32 = 0x8088;
    #[classattr]
    const TEXTURE_COORD_ARRAY_STRIDE: u32 = 0x808A;
    #[classattr]
    const TEXTURE_COORD_ARRAY_TYPE: u32 = 0x8089;
    #[classattr]
    const TEXTURE_CUBE_MAP: u32 = 0x8513;
    #[classattr]
    const TEXTURE_CUBE_MAP_NEGATIVE_X: u32 = 0x8516;
    #[classattr]
    const TEXTURE_CUBE_MAP_NEGATIVE_Y: u32 = 0x8518;
    #[classattr]
    const TEXTURE_CUBE_MAP_NEGATIVE_Z: u32 = 0x851A;
    #[classattr]
    const TEXTURE_CUBE_MAP_POSITIVE_X: u32 = 0x8515;
    #[classattr]
    const TEXTURE_CUBE_MAP_POSITIVE_Y: u32 = 0x8517;
    #[classattr]
    const TEXTURE_CUBE_MAP_POSITIVE_Z: u32 = 0x8519;
    #[classattr]
    const TEXTURE_CUBE_MAP_SEAMLESS: u32 = 0x884F;
    #[classattr]
    const TEXTURE_DEPTH: u32 = 0x8071;
    #[classattr]
    const TEXTURE_DEPTH_SIZE: u32 = 0x884A;
    #[classattr]
    const TEXTURE_DEPTH_TYPE: u32 = 0x8C16;
    #[classattr]
    const TEXTURE_ENV: u32 = 0x2300;
    #[classattr]
    const TEXTURE_ENV_COLOR: u32 = 0x2201;
    #[classattr]
    const TEXTURE_ENV_MODE: u32 = 0x2200;
    #[classattr]
    const TEXTURE_EXTERNAL_OES: u32 = 0x8D65;
    #[classattr]
    const TEXTURE_FILTER_CONTROL: u32 = 0x8500;
    #[classattr]
    const TEXTURE_FIXED_SAMPLE_LOCATIONS: u32 = 0x9107;
    #[classattr]
    const TEXTURE_GEN_MODE: u32 = 0x2500;
    #[classattr]
    const TEXTURE_GEN_Q: u32 = 0x0C63;
    #[classattr]
    const TEXTURE_GEN_R: u32 = 0x0C62;
    #[classattr]
    const TEXTURE_GEN_S: u32 = 0x0C60;
    #[classattr]
    const TEXTURE_GEN_T: u32 = 0x0C61;
    #[classattr]
    const TEXTURE_GREEN_SIZE: u32 = 0x805D;
    #[classattr]
    const TEXTURE_GREEN_TYPE: u32 = 0x8C11;
    #[classattr]
    const TEXTURE_HEIGHT: u32 = 0x1001;
    #[classattr]
    const TEXTURE_IMMUTABLE_FORMAT: u32 = 0x912F;
    #[classattr]
    const TEXTURE_IMMUTABLE_FORMAT_EXT: u32 = 0x912F;
    #[classattr]
    const TEXTURE_IMMUTABLE_LEVELS: u32 = 0x82DF;
    #[classattr]
    const TEXTURE_INTENSITY_SIZE: u32 = 0x8061;
    #[classattr]
    const TEXTURE_INTENSITY_TYPE: u32 = 0x8C15;
    #[classattr]
    const TEXTURE_INTERNAL_FORMAT: u32 = 0x1003;
    #[classattr]
    const TEXTURE_LOD_BIAS: u32 = 0x8501;
    #[classattr]
    const TEXTURE_LUMINANCE_SIZE: u32 = 0x8060;
    #[classattr]
    const TEXTURE_LUMINANCE_TYPE: u32 = 0x8C14;
    #[classattr]
    const TEXTURE_MAG_FILTER: u32 = 0x2800;
    #[classattr]
    const TEXTURE_MATRIX: u32 = 0x0BA8;
    #[classattr]
    const TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FE;
    #[classattr]
    const TEXTURE_MAX_LEVEL: u32 = 0x813D;
    #[classattr]
    const TEXTURE_MAX_LOD: u32 = 0x813B;
    #[classattr]
    const TEXTURE_MIN_FILTER: u32 = 0x2801;
    #[classattr]
    const TEXTURE_MIN_LOD: u32 = 0x813A;
    #[classattr]
    const TEXTURE_PRIORITY: u32 = 0x8066;
    #[classattr]
    const TEXTURE_RANGE_LENGTH_APPLE: u32 = 0x85B7;
    #[classattr]
    const TEXTURE_RANGE_POINTER_APPLE: u32 = 0x85B8;
    #[classattr]
    const TEXTURE_RECTANGLE: u32 = 0x84F5;
    #[classattr]
    const TEXTURE_RECTANGLE_ARB: u32 = 0x84F5;
    #[classattr]
    const TEXTURE_RED_SIZE: u32 = 0x805C;
    #[classattr]
    const TEXTURE_RED_TYPE: u32 = 0x8C10;
    #[classattr]
    const TEXTURE_RESIDENT: u32 = 0x8067;
    #[classattr]
    const TEXTURE_SAMPLES: u32 = 0x9106;
    #[classattr]
    const TEXTURE_SHARED_SIZE: u32 = 0x8C3F;
    #[classattr]
    const TEXTURE_STACK_DEPTH: u32 = 0x0BA5;
    #[classattr]
    const TEXTURE_STENCIL_SIZE: u32 = 0x88F1;
    #[classattr]
    const TEXTURE_STORAGE_HINT_APPLE: u32 = 0x85BC;
    #[classattr]
    const TEXTURE_SWIZZLE_A: u32 = 0x8E45;
    #[classattr]
    const TEXTURE_SWIZZLE_B: u32 = 0x8E44;
    #[classattr]
    const TEXTURE_SWIZZLE_G: u32 = 0x8E43;
    #[classattr]
    const TEXTURE_SWIZZLE_R: u32 = 0x8E42;
    #[classattr]
    const TEXTURE_SWIZZLE_RGBA: u32 = 0x8E46;
    #[classattr]
    const TEXTURE_USAGE_ANGLE: u32 = 0x93A2;
    #[classattr]
    const TEXTURE_WIDTH: u32 = 0x1000;
    #[classattr]
    const TEXTURE_WRAP_R: u32 = 0x8072;
    #[classattr]
    const TEXTURE_WRAP_S: u32 = 0x2802;
    #[classattr]
    const TEXTURE_WRAP_T: u32 = 0x2803;
    #[classattr]
    const TIMEOUT_EXPIRED: u32 = 0x911B;
    #[classattr]
    const TIMEOUT_IGNORED: u64 = 0xFFFFFFFFFFFFFFFF;
    #[classattr]
    const TIMESTAMP: u32 = 0x8E28;
    #[classattr]
    const TIMESTAMP_EXT: u32 = 0x8E28;
    #[classattr]
    const TIME_ELAPSED: u32 = 0x88BF;
    #[classattr]
    const TIME_ELAPSED_EXT: u32 = 0x88BF;
    #[classattr]
    const TRANSFORM_BIT: u32 = 0x00001000;
    #[classattr]
    const TRANSFORM_FEEDBACK: u32 = 0x8E22;
    #[classattr]
    const TRANSFORM_FEEDBACK_ACTIVE: u32 = 0x8E24;
    #[classattr]
    const TRANSFORM_FEEDBACK_BINDING: u32 = 0x8E25;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER: u32 = 0x8C8E;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER_BINDING: u32 = 0x8C8F;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER_MODE: u32 = 0x8C7F;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER_SIZE: u32 = 0x8C85;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER_START: u32 = 0x8C84;
    #[classattr]
    const TRANSFORM_FEEDBACK_PAUSED: u32 = 0x8E23;
    #[classattr]
    const TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: u32 = 0x8C88;
    #[classattr]
    const TRANSFORM_FEEDBACK_VARYINGS: u32 = 0x8C83;
    #[classattr]
    const TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: u32 = 0x8C76;
    #[classattr]
    const TRANSPOSE_COLOR_MATRIX: u32 = 0x84E6;
    #[classattr]
    const TRANSPOSE_MODELVIEW_MATRIX: u32 = 0x84E3;
    #[classattr]
    const TRANSPOSE_PROJECTION_MATRIX: u32 = 0x84E4;
    #[classattr]
    const TRANSPOSE_TEXTURE_MATRIX: u32 = 0x84E5;
    #[classattr]
    const TRIANGLES: u32 = 0x0004;
    #[classattr]
    const TRIANGLES_ADJACENCY: u32 = 0x000C;
    #[classattr]
    const TRIANGLE_FAN: u32 = 0x0006;
    #[classattr]
    const TRIANGLE_STRIP: u32 = 0x0005;
    #[classattr]
    const TRIANGLE_STRIP_ADJACENCY: u32 = 0x000D;
    #[classattr]
    const TRUE: u8 = 1;
    #[classattr]
    const UNIFORM_ARRAY_STRIDE: u32 = 0x8A3C;
    #[classattr]
    const UNIFORM_BLOCK_ACTIVE_UNIFORMS: u32 = 0x8A42;
    #[classattr]
    const UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: u32 = 0x8A43;
    #[classattr]
    const UNIFORM_BLOCK_BINDING: u32 = 0x8A3F;
    #[classattr]
    const UNIFORM_BLOCK_DATA_SIZE: u32 = 0x8A40;
    #[classattr]
    const UNIFORM_BLOCK_INDEX: u32 = 0x8A3A;
    #[classattr]
    const UNIFORM_BLOCK_NAME_LENGTH: u32 = 0x8A41;
    #[classattr]
    const UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: u32 = 0x8A46;
    #[classattr]
    const UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER: u32 = 0x8A45;
    #[classattr]
    const UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: u32 = 0x8A44;
    #[classattr]
    const UNIFORM_BUFFER: u32 = 0x8A11;
    #[classattr]
    const UNIFORM_BUFFER_BINDING: u32 = 0x8A28;
    #[classattr]
    const UNIFORM_BUFFER_OFFSET_ALIGNMENT: u32 = 0x8A34;
    #[classattr]
    const UNIFORM_BUFFER_SIZE: u32 = 0x8A2A;
    #[classattr]
    const UNIFORM_BUFFER_START: u32 = 0x8A29;
    #[classattr]
    const UNIFORM_IS_ROW_MAJOR: u32 = 0x8A3E;
    #[classattr]
    const UNIFORM_MATRIX_STRIDE: u32 = 0x8A3D;
    #[classattr]
    const UNIFORM_NAME_LENGTH: u32 = 0x8A39;
    #[classattr]
    const UNIFORM_OFFSET: u32 = 0x8A3B;
    #[classattr]
    const UNIFORM_SIZE: u32 = 0x8A38;
    #[classattr]
    const UNIFORM_TYPE: u32 = 0x8A37;
    #[classattr]
    const UNPACK_ALIGNMENT: u32 = 0x0CF5;
    #[classattr]
    const UNPACK_CLIENT_STORAGE_APPLE: u32 = 0x85B2;
    #[classattr]
    const UNPACK_IMAGE_HEIGHT: u32 = 0x806E;
    #[classattr]
    const UNPACK_LSB_FIRST: u32 = 0x0CF1;
    #[classattr]
    const UNPACK_ROW_LENGTH: u32 = 0x0CF2;
    #[classattr]
    const UNPACK_SKIP_IMAGES: u32 = 0x806D;
    #[classattr]
    const UNPACK_SKIP_PIXELS: u32 = 0x0CF4;
    #[classattr]
    const UNPACK_SKIP_ROWS: u32 = 0x0CF3;
    #[classattr]
    const UNPACK_SWAP_BYTES: u32 = 0x0CF0;
    #[classattr]
    const UNSIGNALED: u32 = 0x9118;
    #[classattr]
    const UNSIGNED_BYTE: u32 = 0x1401;
    #[classattr]
    const UNSIGNED_BYTE_2_3_3_REV: u32 = 0x8362;
    #[classattr]
    const UNSIGNED_BYTE_3_3_2: u32 = 0x8032;
    #[classattr]
    const UNSIGNED_INT: u32 = 0x1405;
    #[classattr]
    const UNSIGNED_INT_10F_11F_11F_REV: u32 = 0x8C3B;
    #[classattr]
    const UNSIGNED_INT_10_10_10_2: u32 = 0x8036;
    #[classattr]
    const UNSIGNED_INT_24_8: u32 = 0x84FA;
    #[classattr]
    const UNSIGNED_INT_2_10_10_10_REV: u32 = 0x8368;
    #[classattr]
    const UNSIGNED_INT_5_9_9_9_REV: u32 = 0x8C3E;
    #[classattr]
    const UNSIGNED_INT_8_8_8_8: u32 = 0x8035;
    #[classattr]
    const UNSIGNED_INT_8_8_8_8_REV: u32 = 0x8367;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_1D: u32 = 0x8DD1;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_1D_ARRAY: u32 = 0x8DD6;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D: u32 = 0x8DD2;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D_ARRAY: u32 = 0x8DD7;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x910A;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910D;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D_RECT: u32 = 0x8DD5;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_3D: u32 = 0x8DD3;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_BUFFER: u32 = 0x8DD8;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_CUBE: u32 = 0x8DD4;
    #[classattr]
    const UNSIGNED_INT_VEC2: u32 = 0x8DC6;
    #[classattr]
    const UNSIGNED_INT_VEC3: u32 = 0x8DC7;
    #[classattr]
    const UNSIGNED_INT_VEC4: u32 = 0x8DC8;
    #[classattr]
    const UNSIGNED_NORMALIZED: u32 = 0x8C17;
    #[classattr]
    const UNSIGNED_SHORT: u32 = 0x1403;
    #[classattr]
    const UNSIGNED_SHORT_1_5_5_5_REV: u32 = 0x8366;
    #[classattr]
    const UNSIGNED_SHORT_4_4_4_4: u32 = 0x8033;
    #[classattr]
    const UNSIGNED_SHORT_4_4_4_4_REV: u32 = 0x8365;
    #[classattr]
    const UNSIGNED_SHORT_5_5_5_1: u32 = 0x8034;
    #[classattr]
    const UNSIGNED_SHORT_5_6_5: u32 = 0x8363;
    #[classattr]
    const UNSIGNED_SHORT_5_6_5_REV: u32 = 0x8364;
    #[classattr]
    const UPPER_LEFT: u32 = 0x8CA2;
    #[classattr]
    const V2F: u32 = 0x2A20;
    #[classattr]
    const V3F: u32 = 0x2A21;
    #[classattr]
    const VALIDATE_STATUS: u32 = 0x8B83;
    #[classattr]
    const VENDOR: u32 = 0x1F00;
    #[classattr]
    const VERSION: u32 = 0x1F02;
    #[classattr]
    const VERTEX_ARRAY: u32 = 0x8074;
    #[classattr]
    const VERTEX_ARRAY_BINDING: u32 = 0x85B5;
    #[classattr]
    const VERTEX_ARRAY_BINDING_APPLE: u32 = 0x85B5;
    #[classattr]
    const VERTEX_ARRAY_BUFFER_BINDING: u32 = 0x8896;
    #[classattr]
    const VERTEX_ARRAY_KHR: u32 = 0x8074;
    #[classattr]
    const VERTEX_ARRAY_POINTER: u32 = 0x808E;
    #[classattr]
    const VERTEX_ARRAY_SIZE: u32 = 0x807A;
    #[classattr]
    const VERTEX_ARRAY_STRIDE: u32 = 0x807C;
    #[classattr]
    const VERTEX_ARRAY_TYPE: u32 = 0x807B;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: u32 = 0x889F;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_DIVISOR: u32 = 0x88FE;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_ENABLED: u32 = 0x8622;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_INTEGER: u32 = 0x88FD;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_NORMALIZED: u32 = 0x886A;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_POINTER: u32 = 0x8645;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_SIZE: u32 = 0x8623;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_STRIDE: u32 = 0x8624;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_TYPE: u32 = 0x8625;
    #[classattr]
    const VERTEX_PROGRAM_POINT_SIZE: u32 = 0x8642;
    #[classattr]
    const VERTEX_PROGRAM_TWO_SIDE: u32 = 0x8643;
    #[classattr]
    const VERTEX_SHADER: u32 = 0x8B31;
    #[classattr]
    const VIEWPORT: u32 = 0x0BA2;
    #[classattr]
    const VIEWPORT_BIT: u32 = 0x00000800;
    #[classattr]
    const WAIT_FAILED: u32 = 0x911D;
    #[classattr]
    const WEIGHT_ARRAY_BUFFER_BINDING: u32 = 0x889E;
    #[classattr]
    const WRITE_ONLY: u32 = 0x88B9;
    #[classattr]
    const XOR: u32 = 0x1506;
    #[classattr]
    const ZERO: u32 = 0;
    #[classattr]
    const ZOOM_X: u32 = 0x0D16;
    #[classattr]
    const ZOOM_Y: u32 = 0x0D17;

    fn get_type(&self) -> AzGlTypeEnumWrapper {
        unsafe { mem::transmute(crate::AzGl_getType(
            mem::transmute(self),
        )) }
    }
    fn buffer_data_untyped(&self, target: u32, size: isize, data: AzGlVoidPtrConst, usage: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_bufferDataUntyped(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(size),
            mem::transmute(data),
            mem::transmute(usage),
        )) }
    }
    fn buffer_sub_data_untyped(&self, target: u32, offset: isize, size: isize, data: AzGlVoidPtrConst) -> () {
        unsafe { mem::transmute(crate::AzGl_bufferSubDataUntyped(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(offset),
            mem::transmute(size),
            mem::transmute(data),
        )) }
    }
    fn map_buffer(&self, target: u32, access: u32) -> AzGlVoidPtrMut {
        unsafe { mem::transmute(crate::AzGl_mapBuffer(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(access),
        )) }
    }
    fn map_buffer_range(&self, target: u32, offset: isize, length: isize, access: u32) -> AzGlVoidPtrMut {
        unsafe { mem::transmute(crate::AzGl_mapBufferRange(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(offset),
            mem::transmute(length),
            mem::transmute(access),
        )) }
    }
    fn unmap_buffer(&self, target: u32) -> u8 {
        unsafe { mem::transmute(crate::AzGl_unmapBuffer(
            mem::transmute(self),
            mem::transmute(target),
        )) }
    }
    fn tex_buffer(&self, target: u32, internal_format: u32, buffer: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_texBuffer(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(internal_format),
            mem::transmute(buffer),
        )) }
    }
    fn shader_source(&self, shader: u32, strings: AzStringVec) -> () {
        unsafe { mem::transmute(crate::AzGl_shaderSource(
            mem::transmute(self),
            mem::transmute(shader),
            mem::transmute(strings),
        )) }
    }
    fn read_buffer(&self, mode: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_readBuffer(
            mem::transmute(self),
            mem::transmute(mode),
        )) }
    }
    fn read_pixels_into_buffer(&self, x: i32, y: i32, width: i32, height: i32, format: u32, pixel_type: u32, mut dst_buffer: Vec<u8>) -> () {
        let dst_buffer = pybytesrefmut_to_vecu8refmut(&mut dst_buffer);
        unsafe { mem::transmute(crate::AzGl_readPixelsIntoBuffer(
            mem::transmute(self),
            mem::transmute(x),
            mem::transmute(y),
            mem::transmute(width),
            mem::transmute(height),
            mem::transmute(format),
            mem::transmute(pixel_type),
            mem::transmute(dst_buffer),
        )) }
    }
    fn read_pixels(&self, x: i32, y: i32, width: i32, height: i32, format: u32, pixel_type: u32) -> Vec<u8> {
        az_vecu8_to_py_vecu8(unsafe { mem::transmute(crate::AzGl_readPixels(
            mem::transmute(self),
            mem::transmute(x),
            mem::transmute(y),
            mem::transmute(width),
            mem::transmute(height),
            mem::transmute(format),
            mem::transmute(pixel_type),
        )) })
    }
    fn read_pixels_into_pbo(&self, x: i32, y: i32, width: i32, height: i32, format: u32, pixel_type: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_readPixelsIntoPbo(
            mem::transmute(self),
            mem::transmute(x),
            mem::transmute(y),
            mem::transmute(width),
            mem::transmute(height),
            mem::transmute(format),
            mem::transmute(pixel_type),
        )) }
    }
    fn sample_coverage(&self, value: f32, invert: bool) -> () {
        unsafe { mem::transmute(crate::AzGl_sampleCoverage(
            mem::transmute(self),
            mem::transmute(value),
            mem::transmute(invert),
        )) }
    }
    fn polygon_offset(&self, factor: f32, units: f32) -> () {
        unsafe { mem::transmute(crate::AzGl_polygonOffset(
            mem::transmute(self),
            mem::transmute(factor),
            mem::transmute(units),
        )) }
    }
    fn pixel_store_i(&self, name: u32, param: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_pixelStoreI(
            mem::transmute(self),
            mem::transmute(name),
            mem::transmute(param),
        )) }
    }
    fn gen_buffers(&self, n: i32) -> AzGLuintVec {
        unsafe { mem::transmute(crate::AzGl_genBuffers(
            mem::transmute(self),
            mem::transmute(n),
        )) }
    }
    fn gen_renderbuffers(&self, n: i32) -> AzGLuintVec {
        unsafe { mem::transmute(crate::AzGl_genRenderbuffers(
            mem::transmute(self),
            mem::transmute(n),
        )) }
    }
    fn gen_framebuffers(&self, n: i32) -> AzGLuintVec {
        unsafe { mem::transmute(crate::AzGl_genFramebuffers(
            mem::transmute(self),
            mem::transmute(n),
        )) }
    }
    fn gen_textures(&self, n: i32) -> AzGLuintVec {
        unsafe { mem::transmute(crate::AzGl_genTextures(
            mem::transmute(self),
            mem::transmute(n),
        )) }
    }
    fn gen_vertex_arrays(&self, n: i32) -> AzGLuintVec {
        unsafe { mem::transmute(crate::AzGl_genVertexArrays(
            mem::transmute(self),
            mem::transmute(n),
        )) }
    }
    fn gen_queries(&self, n: i32) -> AzGLuintVec {
        unsafe { mem::transmute(crate::AzGl_genQueries(
            mem::transmute(self),
            mem::transmute(n),
        )) }
    }
    fn begin_query(&self, target: u32, id: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_beginQuery(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(id),
        )) }
    }
    fn end_query(&self, target: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_endQuery(
            mem::transmute(self),
            mem::transmute(target),
        )) }
    }
    fn query_counter(&self, id: u32, target: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_queryCounter(
            mem::transmute(self),
            mem::transmute(id),
            mem::transmute(target),
        )) }
    }
    fn get_query_object_iv(&self, id: u32, pname: u32) -> i32 {
        unsafe { mem::transmute(crate::AzGl_getQueryObjectIv(
            mem::transmute(self),
            mem::transmute(id),
            mem::transmute(pname),
        )) }
    }
    fn get_query_object_uiv(&self, id: u32, pname: u32) -> u32 {
        unsafe { mem::transmute(crate::AzGl_getQueryObjectUiv(
            mem::transmute(self),
            mem::transmute(id),
            mem::transmute(pname),
        )) }
    }
    fn get_query_object_i64v(&self, id: u32, pname: u32) -> i64 {
        unsafe { mem::transmute(crate::AzGl_getQueryObjectI64V(
            mem::transmute(self),
            mem::transmute(id),
            mem::transmute(pname),
        )) }
    }
    fn get_query_object_ui64v(&self, id: u32, pname: u32) -> u64 {
        unsafe { mem::transmute(crate::AzGl_getQueryObjectUi64V(
            mem::transmute(self),
            mem::transmute(id),
            mem::transmute(pname),
        )) }
    }
    fn delete_queries(&self, queries: Vec<u32>) -> () {
        let queries = pylist_u32_to_rust(&queries);
        unsafe { mem::transmute(crate::AzGl_deleteQueries(
            mem::transmute(self),
            mem::transmute(queries),
        )) }
    }
    fn delete_vertex_arrays(&self, vertex_arrays: Vec<u32>) -> () {
        let vertex_arrays = pylist_u32_to_rust(&vertex_arrays);
        unsafe { mem::transmute(crate::AzGl_deleteVertexArrays(
            mem::transmute(self),
            mem::transmute(vertex_arrays),
        )) }
    }
    fn delete_buffers(&self, buffers: Vec<u32>) -> () {
        let buffers = pylist_u32_to_rust(&buffers);
        unsafe { mem::transmute(crate::AzGl_deleteBuffers(
            mem::transmute(self),
            mem::transmute(buffers),
        )) }
    }
    fn delete_renderbuffers(&self, renderbuffers: Vec<u32>) -> () {
        let renderbuffers = pylist_u32_to_rust(&renderbuffers);
        unsafe { mem::transmute(crate::AzGl_deleteRenderbuffers(
            mem::transmute(self),
            mem::transmute(renderbuffers),
        )) }
    }
    fn delete_framebuffers(&self, framebuffers: Vec<u32>) -> () {
        let framebuffers = pylist_u32_to_rust(&framebuffers);
        unsafe { mem::transmute(crate::AzGl_deleteFramebuffers(
            mem::transmute(self),
            mem::transmute(framebuffers),
        )) }
    }
    fn delete_textures(&self, textures: Vec<u32>) -> () {
        let textures = pylist_u32_to_rust(&textures);
        unsafe { mem::transmute(crate::AzGl_deleteTextures(
            mem::transmute(self),
            mem::transmute(textures),
        )) }
    }
    fn framebuffer_renderbuffer(&self, target: u32, attachment: u32, renderbuffertarget: u32, renderbuffer: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_framebufferRenderbuffer(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(attachment),
            mem::transmute(renderbuffertarget),
            mem::transmute(renderbuffer),
        )) }
    }
    fn renderbuffer_storage(&self, target: u32, internalformat: u32, width: i32, height: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_renderbufferStorage(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(internalformat),
            mem::transmute(width),
            mem::transmute(height),
        )) }
    }
    fn depth_func(&self, func: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_depthFunc(
            mem::transmute(self),
            mem::transmute(func),
        )) }
    }
    fn active_texture(&self, texture: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_activeTexture(
            mem::transmute(self),
            mem::transmute(texture),
        )) }
    }
    fn attach_shader(&self, program: u32, shader: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_attachShader(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(shader),
        )) }
    }
    fn bind_attrib_location(&self, program: u32, index: u32, name: &str) -> () {
        let name = pystring_to_refstr(&name);
        unsafe { mem::transmute(crate::AzGl_bindAttribLocation(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(index),
            mem::transmute(name),
        )) }
    }
    fn get_uniform_iv(&self, program: u32, location: i32, mut result: Vec<i32>) -> () {
        let result = pylist_i32_to_rust(&mut result);
        unsafe { mem::transmute(crate::AzGl_getUniformIv(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(location),
            mem::transmute(result),
        )) }
    }
    fn get_uniform_fv(&self, program: u32, location: i32, mut result: Vec<f32>) -> () {
        let result = pylist_glfoat_to_rust(&mut result);
        unsafe { mem::transmute(crate::AzGl_getUniformFv(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(location),
            mem::transmute(result),
        )) }
    }
    fn get_uniform_block_index(&self, program: u32, name: &str) -> u32 {
        let name = pystring_to_refstr(&name);
        unsafe { mem::transmute(crate::AzGl_getUniformBlockIndex(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(name),
        )) }
    }
    fn get_uniform_indices(&self, program: u32, names: Vec<&str>) -> AzGLuintVec {
        let names = vec_string_to_vec_refstr(&names);
        let names = pylist_str_to_rust(&names);
        unsafe { mem::transmute(crate::AzGl_getUniformIndices(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(names),
        )) }
    }
    fn bind_buffer_base(&self, target: u32, index: u32, buffer: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_bindBufferBase(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(index),
            mem::transmute(buffer),
        )) }
    }
    fn bind_buffer_range(&self, target: u32, index: u32, buffer: u32, offset: isize, size: isize) -> () {
        unsafe { mem::transmute(crate::AzGl_bindBufferRange(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(index),
            mem::transmute(buffer),
            mem::transmute(offset),
            mem::transmute(size),
        )) }
    }
    fn uniform_block_binding(&self, program: u32, uniform_block_index: u32, uniform_block_binding: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_uniformBlockBinding(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(uniform_block_index),
            mem::transmute(uniform_block_binding),
        )) }
    }
    fn bind_buffer(&self, target: u32, buffer: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_bindBuffer(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(buffer),
        )) }
    }
    fn bind_vertex_array(&self, vao: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_bindVertexArray(
            mem::transmute(self),
            mem::transmute(vao),
        )) }
    }
    fn bind_renderbuffer(&self, target: u32, renderbuffer: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_bindRenderbuffer(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(renderbuffer),
        )) }
    }
    fn bind_framebuffer(&self, target: u32, framebuffer: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_bindFramebuffer(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(framebuffer),
        )) }
    }
    fn bind_texture(&self, target: u32, texture: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_bindTexture(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(texture),
        )) }
    }
    fn draw_buffers(&self, bufs: AzGLenumVecRef) -> () {
        unsafe { mem::transmute(crate::AzGl_drawBuffers(
            mem::transmute(self),
            mem::transmute(bufs),
        )) }
    }
    fn tex_image_2d(&self, target: u32, level: i32, internal_format: i32, width: i32, height: i32, border: i32, format: u32, ty: u32, opt_data: AzOptionU8VecRefEnumWrapper) -> () {
        unsafe { mem::transmute(crate::AzGl_texImage2D(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(level),
            mem::transmute(internal_format),
            mem::transmute(width),
            mem::transmute(height),
            mem::transmute(border),
            mem::transmute(format),
            mem::transmute(ty),
            mem::transmute(opt_data),
        )) }
    }
    fn compressed_tex_image_2d(&self, target: u32, level: i32, internal_format: u32, width: i32, height: i32, border: i32, data: Vec<u8>) -> () {
        let data = pybytesref_to_vecu8_ref(&data);
        unsafe { mem::transmute(crate::AzGl_compressedTexImage2D(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(level),
            mem::transmute(internal_format),
            mem::transmute(width),
            mem::transmute(height),
            mem::transmute(border),
            mem::transmute(data),
        )) }
    }
    fn compressed_tex_sub_image_2d(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, data: Vec<u8>) -> () {
        let data = pybytesref_to_vecu8_ref(&data);
        unsafe { mem::transmute(crate::AzGl_compressedTexSubImage2D(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(level),
            mem::transmute(xoffset),
            mem::transmute(yoffset),
            mem::transmute(width),
            mem::transmute(height),
            mem::transmute(format),
            mem::transmute(data),
        )) }
    }
    fn tex_image_3d(&self, target: u32, level: i32, internal_format: i32, width: i32, height: i32, depth: i32, border: i32, format: u32, ty: u32, opt_data: AzOptionU8VecRefEnumWrapper) -> () {
        unsafe { mem::transmute(crate::AzGl_texImage3D(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(level),
            mem::transmute(internal_format),
            mem::transmute(width),
            mem::transmute(height),
            mem::transmute(depth),
            mem::transmute(border),
            mem::transmute(format),
            mem::transmute(ty),
            mem::transmute(opt_data),
        )) }
    }
    fn copy_tex_image_2d(&self, target: u32, level: i32, internal_format: u32, x: i32, y: i32, width: i32, height: i32, border: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_copyTexImage2D(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(level),
            mem::transmute(internal_format),
            mem::transmute(x),
            mem::transmute(y),
            mem::transmute(width),
            mem::transmute(height),
            mem::transmute(border),
        )) }
    }
    fn copy_tex_sub_image_2d(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, x: i32, y: i32, width: i32, height: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_copyTexSubImage2D(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(level),
            mem::transmute(xoffset),
            mem::transmute(yoffset),
            mem::transmute(x),
            mem::transmute(y),
            mem::transmute(width),
            mem::transmute(height),
        )) }
    }
    fn copy_tex_sub_image_3d(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, x: i32, y: i32, width: i32, height: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_copyTexSubImage3D(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(level),
            mem::transmute(xoffset),
            mem::transmute(yoffset),
            mem::transmute(zoffset),
            mem::transmute(x),
            mem::transmute(y),
            mem::transmute(width),
            mem::transmute(height),
        )) }
    }
    fn tex_sub_image_2d(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, ty: u32, data: Vec<u8>) -> () {
        let data = pybytesref_to_vecu8_ref(&data);
        unsafe { mem::transmute(crate::AzGl_texSubImage2D(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(level),
            mem::transmute(xoffset),
            mem::transmute(yoffset),
            mem::transmute(width),
            mem::transmute(height),
            mem::transmute(format),
            mem::transmute(ty),
            mem::transmute(data),
        )) }
    }
    fn tex_sub_image_2d_pbo(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, ty: u32, offset: usize) -> () {
        unsafe { mem::transmute(crate::AzGl_texSubImage2DPbo(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(level),
            mem::transmute(xoffset),
            mem::transmute(yoffset),
            mem::transmute(width),
            mem::transmute(height),
            mem::transmute(format),
            mem::transmute(ty),
            mem::transmute(offset),
        )) }
    }
    fn tex_sub_image_3d(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, width: i32, height: i32, depth: i32, format: u32, ty: u32, data: Vec<u8>) -> () {
        let data = pybytesref_to_vecu8_ref(&data);
        unsafe { mem::transmute(crate::AzGl_texSubImage3D(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(level),
            mem::transmute(xoffset),
            mem::transmute(yoffset),
            mem::transmute(zoffset),
            mem::transmute(width),
            mem::transmute(height),
            mem::transmute(depth),
            mem::transmute(format),
            mem::transmute(ty),
            mem::transmute(data),
        )) }
    }
    fn tex_sub_image_3d_pbo(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, width: i32, height: i32, depth: i32, format: u32, ty: u32, offset: usize) -> () {
        unsafe { mem::transmute(crate::AzGl_texSubImage3DPbo(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(level),
            mem::transmute(xoffset),
            mem::transmute(yoffset),
            mem::transmute(zoffset),
            mem::transmute(width),
            mem::transmute(height),
            mem::transmute(depth),
            mem::transmute(format),
            mem::transmute(ty),
            mem::transmute(offset),
        )) }
    }
    fn tex_storage_2d(&self, target: u32, levels: i32, internal_format: u32, width: i32, height: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_texStorage2D(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(levels),
            mem::transmute(internal_format),
            mem::transmute(width),
            mem::transmute(height),
        )) }
    }
    fn tex_storage_3d(&self, target: u32, levels: i32, internal_format: u32, width: i32, height: i32, depth: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_texStorage3D(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(levels),
            mem::transmute(internal_format),
            mem::transmute(width),
            mem::transmute(height),
            mem::transmute(depth),
        )) }
    }
    fn get_tex_image_into_buffer(&self, target: u32, level: i32, format: u32, ty: u32, mut output: Vec<u8>) -> () {
        let output = pybytesrefmut_to_vecu8refmut(&mut output);
        unsafe { mem::transmute(crate::AzGl_getTexImageIntoBuffer(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(level),
            mem::transmute(format),
            mem::transmute(ty),
            mem::transmute(output),
        )) }
    }
    fn copy_image_sub_data(&self, src_name: u32, src_target: u32, src_level: i32, src_x: i32, src_y: i32, src_z: i32, dst_name: u32, dst_target: u32, dst_level: i32, dst_x: i32, dst_y: i32, dst_z: i32, src_width: i32, src_height: i32, src_depth: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_copyImageSubData(
            mem::transmute(self),
            mem::transmute(src_name),
            mem::transmute(src_target),
            mem::transmute(src_level),
            mem::transmute(src_x),
            mem::transmute(src_y),
            mem::transmute(src_z),
            mem::transmute(dst_name),
            mem::transmute(dst_target),
            mem::transmute(dst_level),
            mem::transmute(dst_x),
            mem::transmute(dst_y),
            mem::transmute(dst_z),
            mem::transmute(src_width),
            mem::transmute(src_height),
            mem::transmute(src_depth),
        )) }
    }
    fn invalidate_framebuffer(&self, target: u32, attachments: AzGLenumVecRef) -> () {
        unsafe { mem::transmute(crate::AzGl_invalidateFramebuffer(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(attachments),
        )) }
    }
    fn invalidate_sub_framebuffer(&self, target: u32, attachments: AzGLenumVecRef, xoffset: i32, yoffset: i32, width: i32, height: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_invalidateSubFramebuffer(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(attachments),
            mem::transmute(xoffset),
            mem::transmute(yoffset),
            mem::transmute(width),
            mem::transmute(height),
        )) }
    }
    fn get_integer_v(&self, name: u32, mut result: Vec<i32>) -> () {
        let result = pylist_i32_to_rust(&mut result);
        unsafe { mem::transmute(crate::AzGl_getIntegerV(
            mem::transmute(self),
            mem::transmute(name),
            mem::transmute(result),
        )) }
    }
    fn get_integer_64v(&self, name: u32, mut result: Vec<i64>) -> () {
        let result = pylist_i64_to_rust(&mut result);
        unsafe { mem::transmute(crate::AzGl_getInteger64V(
            mem::transmute(self),
            mem::transmute(name),
            mem::transmute(result),
        )) }
    }
    fn get_integer_iv(&self, name: u32, index: u32, mut result: Vec<i32>) -> () {
        let result = pylist_i32_to_rust(&mut result);
        unsafe { mem::transmute(crate::AzGl_getIntegerIv(
            mem::transmute(self),
            mem::transmute(name),
            mem::transmute(index),
            mem::transmute(result),
        )) }
    }
    fn get_integer_64iv(&self, name: u32, index: u32, mut result: Vec<i64>) -> () {
        let result = pylist_i64_to_rust(&mut result);
        unsafe { mem::transmute(crate::AzGl_getInteger64Iv(
            mem::transmute(self),
            mem::transmute(name),
            mem::transmute(index),
            mem::transmute(result),
        )) }
    }
    fn get_boolean_v(&self, name: u32, mut result: Vec<u8>) -> () {
        let result = pylist_bool_to_rust(&mut result);
        unsafe { mem::transmute(crate::AzGl_getBooleanV(
            mem::transmute(self),
            mem::transmute(name),
            mem::transmute(result),
        )) }
    }
    fn get_float_v(&self, name: u32, mut result: Vec<f32>) -> () {
        let result = pylist_glfoat_to_rust(&mut result);
        unsafe { mem::transmute(crate::AzGl_getFloatV(
            mem::transmute(self),
            mem::transmute(name),
            mem::transmute(result),
        )) }
    }
    fn get_framebuffer_attachment_parameter_iv(&self, target: u32, attachment: u32, pname: u32) -> i32 {
        unsafe { mem::transmute(crate::AzGl_getFramebufferAttachmentParameterIv(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(attachment),
            mem::transmute(pname),
        )) }
    }
    fn get_renderbuffer_parameter_iv(&self, target: u32, pname: u32) -> i32 {
        unsafe { mem::transmute(crate::AzGl_getRenderbufferParameterIv(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(pname),
        )) }
    }
    fn get_tex_parameter_iv(&self, target: u32, name: u32) -> i32 {
        unsafe { mem::transmute(crate::AzGl_getTexParameterIv(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(name),
        )) }
    }
    fn get_tex_parameter_fv(&self, target: u32, name: u32) -> f32 {
        unsafe { mem::transmute(crate::AzGl_getTexParameterFv(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(name),
        )) }
    }
    fn tex_parameter_i(&self, target: u32, pname: u32, param: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_texParameterI(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(pname),
            mem::transmute(param),
        )) }
    }
    fn tex_parameter_f(&self, target: u32, pname: u32, param: f32) -> () {
        unsafe { mem::transmute(crate::AzGl_texParameterF(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(pname),
            mem::transmute(param),
        )) }
    }
    fn framebuffer_texture_2d(&self, target: u32, attachment: u32, textarget: u32, texture: u32, level: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_framebufferTexture2D(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(attachment),
            mem::transmute(textarget),
            mem::transmute(texture),
            mem::transmute(level),
        )) }
    }
    fn framebuffer_texture_layer(&self, target: u32, attachment: u32, texture: u32, level: i32, layer: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_framebufferTextureLayer(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(attachment),
            mem::transmute(texture),
            mem::transmute(level),
            mem::transmute(layer),
        )) }
    }
    fn blit_framebuffer(&self, src_x0: i32, src_y0: i32, src_x1: i32, src_y1: i32, dst_x0: i32, dst_y0: i32, dst_x1: i32, dst_y1: i32, mask: u32, filter: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_blitFramebuffer(
            mem::transmute(self),
            mem::transmute(src_x0),
            mem::transmute(src_y0),
            mem::transmute(src_x1),
            mem::transmute(src_y1),
            mem::transmute(dst_x0),
            mem::transmute(dst_y0),
            mem::transmute(dst_x1),
            mem::transmute(dst_y1),
            mem::transmute(mask),
            mem::transmute(filter),
        )) }
    }
    fn vertex_attrib_4f(&self, index: u32, x: f32, y: f32, z: f32, w: f32) -> () {
        unsafe { mem::transmute(crate::AzGl_vertexAttrib4F(
            mem::transmute(self),
            mem::transmute(index),
            mem::transmute(x),
            mem::transmute(y),
            mem::transmute(z),
            mem::transmute(w),
        )) }
    }
    fn vertex_attrib_pointer_f32(&self, index: u32, size: i32, normalized: bool, stride: i32, offset: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_vertexAttribPointerF32(
            mem::transmute(self),
            mem::transmute(index),
            mem::transmute(size),
            mem::transmute(normalized),
            mem::transmute(stride),
            mem::transmute(offset),
        )) }
    }
    fn vertex_attrib_pointer(&self, index: u32, size: i32, type_: u32, normalized: bool, stride: i32, offset: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_vertexAttribPointer(
            mem::transmute(self),
            mem::transmute(index),
            mem::transmute(size),
            mem::transmute(type_),
            mem::transmute(normalized),
            mem::transmute(stride),
            mem::transmute(offset),
        )) }
    }
    fn vertex_attrib_i_pointer(&self, index: u32, size: i32, type_: u32, stride: i32, offset: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_vertexAttribIPointer(
            mem::transmute(self),
            mem::transmute(index),
            mem::transmute(size),
            mem::transmute(type_),
            mem::transmute(stride),
            mem::transmute(offset),
        )) }
    }
    fn vertex_attrib_divisor(&self, index: u32, divisor: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_vertexAttribDivisor(
            mem::transmute(self),
            mem::transmute(index),
            mem::transmute(divisor),
        )) }
    }
    fn viewport(&self, x: i32, y: i32, width: i32, height: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_viewport(
            mem::transmute(self),
            mem::transmute(x),
            mem::transmute(y),
            mem::transmute(width),
            mem::transmute(height),
        )) }
    }
    fn scissor(&self, x: i32, y: i32, width: i32, height: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_scissor(
            mem::transmute(self),
            mem::transmute(x),
            mem::transmute(y),
            mem::transmute(width),
            mem::transmute(height),
        )) }
    }
    fn line_width(&self, width: f32) -> () {
        unsafe { mem::transmute(crate::AzGl_lineWidth(
            mem::transmute(self),
            mem::transmute(width),
        )) }
    }
    fn use_program(&self, program: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_useProgram(
            mem::transmute(self),
            mem::transmute(program),
        )) }
    }
    fn validate_program(&self, program: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_validateProgram(
            mem::transmute(self),
            mem::transmute(program),
        )) }
    }
    fn draw_arrays(&self, mode: u32, first: i32, count: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_drawArrays(
            mem::transmute(self),
            mem::transmute(mode),
            mem::transmute(first),
            mem::transmute(count),
        )) }
    }
    fn draw_arrays_instanced(&self, mode: u32, first: i32, count: i32, primcount: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_drawArraysInstanced(
            mem::transmute(self),
            mem::transmute(mode),
            mem::transmute(first),
            mem::transmute(count),
            mem::transmute(primcount),
        )) }
    }
    fn draw_elements(&self, mode: u32, count: i32, element_type: u32, indices_offset: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_drawElements(
            mem::transmute(self),
            mem::transmute(mode),
            mem::transmute(count),
            mem::transmute(element_type),
            mem::transmute(indices_offset),
        )) }
    }
    fn draw_elements_instanced(&self, mode: u32, count: i32, element_type: u32, indices_offset: u32, primcount: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_drawElementsInstanced(
            mem::transmute(self),
            mem::transmute(mode),
            mem::transmute(count),
            mem::transmute(element_type),
            mem::transmute(indices_offset),
            mem::transmute(primcount),
        )) }
    }
    fn blend_color(&self, r: f32, g: f32, b: f32, a: f32) -> () {
        unsafe { mem::transmute(crate::AzGl_blendColor(
            mem::transmute(self),
            mem::transmute(r),
            mem::transmute(g),
            mem::transmute(b),
            mem::transmute(a),
        )) }
    }
    fn blend_func(&self, sfactor: u32, dfactor: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_blendFunc(
            mem::transmute(self),
            mem::transmute(sfactor),
            mem::transmute(dfactor),
        )) }
    }
    fn blend_func_separate(&self, src_rgb: u32, dest_rgb: u32, src_alpha: u32, dest_alpha: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_blendFuncSeparate(
            mem::transmute(self),
            mem::transmute(src_rgb),
            mem::transmute(dest_rgb),
            mem::transmute(src_alpha),
            mem::transmute(dest_alpha),
        )) }
    }
    fn blend_equation(&self, mode: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_blendEquation(
            mem::transmute(self),
            mem::transmute(mode),
        )) }
    }
    fn blend_equation_separate(&self, mode_rgb: u32, mode_alpha: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_blendEquationSeparate(
            mem::transmute(self),
            mem::transmute(mode_rgb),
            mem::transmute(mode_alpha),
        )) }
    }
    fn color_mask(&self, r: bool, g: bool, b: bool, a: bool) -> () {
        unsafe { mem::transmute(crate::AzGl_colorMask(
            mem::transmute(self),
            mem::transmute(r),
            mem::transmute(g),
            mem::transmute(b),
            mem::transmute(a),
        )) }
    }
    fn cull_face(&self, mode: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_cullFace(
            mem::transmute(self),
            mem::transmute(mode),
        )) }
    }
    fn front_face(&self, mode: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_frontFace(
            mem::transmute(self),
            mem::transmute(mode),
        )) }
    }
    fn enable(&self, cap: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_enable(
            mem::transmute(self),
            mem::transmute(cap),
        )) }
    }
    fn disable(&self, cap: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_disable(
            mem::transmute(self),
            mem::transmute(cap),
        )) }
    }
    fn hint(&self, param_name: u32, param_val: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_hint(
            mem::transmute(self),
            mem::transmute(param_name),
            mem::transmute(param_val),
        )) }
    }
    fn is_enabled(&self, cap: u32) -> u8 {
        unsafe { mem::transmute(crate::AzGl_isEnabled(
            mem::transmute(self),
            mem::transmute(cap),
        )) }
    }
    fn is_shader(&self, shader: u32) -> u8 {
        unsafe { mem::transmute(crate::AzGl_isShader(
            mem::transmute(self),
            mem::transmute(shader),
        )) }
    }
    fn is_texture(&self, texture: u32) -> u8 {
        unsafe { mem::transmute(crate::AzGl_isTexture(
            mem::transmute(self),
            mem::transmute(texture),
        )) }
    }
    fn is_framebuffer(&self, framebuffer: u32) -> u8 {
        unsafe { mem::transmute(crate::AzGl_isFramebuffer(
            mem::transmute(self),
            mem::transmute(framebuffer),
        )) }
    }
    fn is_renderbuffer(&self, renderbuffer: u32) -> u8 {
        unsafe { mem::transmute(crate::AzGl_isRenderbuffer(
            mem::transmute(self),
            mem::transmute(renderbuffer),
        )) }
    }
    fn check_frame_buffer_status(&self, target: u32) -> u32 {
        unsafe { mem::transmute(crate::AzGl_checkFrameBufferStatus(
            mem::transmute(self),
            mem::transmute(target),
        )) }
    }
    fn enable_vertex_attrib_array(&self, index: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_enableVertexAttribArray(
            mem::transmute(self),
            mem::transmute(index),
        )) }
    }
    fn disable_vertex_attrib_array(&self, index: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_disableVertexAttribArray(
            mem::transmute(self),
            mem::transmute(index),
        )) }
    }
    fn uniform_1f(&self, location: i32, v0: f32) -> () {
        unsafe { mem::transmute(crate::AzGl_uniform1F(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(v0),
        )) }
    }
    fn uniform_1fv(&self, location: i32, values: Vec<f32>) -> () {
        let values = pylist_f32_to_rust(&values);
        unsafe { mem::transmute(crate::AzGl_uniform1Fv(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(values),
        )) }
    }
    fn uniform_1i(&self, location: i32, v0: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_uniform1I(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(v0),
        )) }
    }
    fn uniform_1iv(&self, location: i32, values: AzI32VecRef) -> () {
        unsafe { mem::transmute(crate::AzGl_uniform1Iv(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(values),
        )) }
    }
    fn uniform_1ui(&self, location: i32, v0: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_uniform1Ui(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(v0),
        )) }
    }
    fn uniform_2f(&self, location: i32, v0: f32, v1: f32) -> () {
        unsafe { mem::transmute(crate::AzGl_uniform2F(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(v0),
            mem::transmute(v1),
        )) }
    }
    fn uniform_2fv(&self, location: i32, values: Vec<f32>) -> () {
        let values = pylist_f32_to_rust(&values);
        unsafe { mem::transmute(crate::AzGl_uniform2Fv(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(values),
        )) }
    }
    fn uniform_2i(&self, location: i32, v0: i32, v1: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_uniform2I(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(v0),
            mem::transmute(v1),
        )) }
    }
    fn uniform_2iv(&self, location: i32, values: AzI32VecRef) -> () {
        unsafe { mem::transmute(crate::AzGl_uniform2Iv(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(values),
        )) }
    }
    fn uniform_2ui(&self, location: i32, v0: u32, v1: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_uniform2Ui(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(v0),
            mem::transmute(v1),
        )) }
    }
    fn uniform_3f(&self, location: i32, v0: f32, v1: f32, v2: f32) -> () {
        unsafe { mem::transmute(crate::AzGl_uniform3F(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(v0),
            mem::transmute(v1),
            mem::transmute(v2),
        )) }
    }
    fn uniform_3fv(&self, location: i32, values: Vec<f32>) -> () {
        let values = pylist_f32_to_rust(&values);
        unsafe { mem::transmute(crate::AzGl_uniform3Fv(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(values),
        )) }
    }
    fn uniform_3i(&self, location: i32, v0: i32, v1: i32, v2: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_uniform3I(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(v0),
            mem::transmute(v1),
            mem::transmute(v2),
        )) }
    }
    fn uniform_3iv(&self, location: i32, values: AzI32VecRef) -> () {
        unsafe { mem::transmute(crate::AzGl_uniform3Iv(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(values),
        )) }
    }
    fn uniform_3ui(&self, location: i32, v0: u32, v1: u32, v2: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_uniform3Ui(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(v0),
            mem::transmute(v1),
            mem::transmute(v2),
        )) }
    }
    fn uniform_4f(&self, location: i32, x: f32, y: f32, z: f32, w: f32) -> () {
        unsafe { mem::transmute(crate::AzGl_uniform4F(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(x),
            mem::transmute(y),
            mem::transmute(z),
            mem::transmute(w),
        )) }
    }
    fn uniform_4i(&self, location: i32, x: i32, y: i32, z: i32, w: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_uniform4I(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(x),
            mem::transmute(y),
            mem::transmute(z),
            mem::transmute(w),
        )) }
    }
    fn uniform_4iv(&self, location: i32, values: AzI32VecRef) -> () {
        unsafe { mem::transmute(crate::AzGl_uniform4Iv(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(values),
        )) }
    }
    fn uniform_4ui(&self, location: i32, x: u32, y: u32, z: u32, w: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_uniform4Ui(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(x),
            mem::transmute(y),
            mem::transmute(z),
            mem::transmute(w),
        )) }
    }
    fn uniform_4fv(&self, location: i32, values: Vec<f32>) -> () {
        let values = pylist_f32_to_rust(&values);
        unsafe { mem::transmute(crate::AzGl_uniform4Fv(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(values),
        )) }
    }
    fn uniform_matrix_2fv(&self, location: i32, transpose: bool, value: Vec<f32>) -> () {
        let value = pylist_f32_to_rust(&value);
        unsafe { mem::transmute(crate::AzGl_uniformMatrix2Fv(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(transpose),
            mem::transmute(value),
        )) }
    }
    fn uniform_matrix_3fv(&self, location: i32, transpose: bool, value: Vec<f32>) -> () {
        let value = pylist_f32_to_rust(&value);
        unsafe { mem::transmute(crate::AzGl_uniformMatrix3Fv(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(transpose),
            mem::transmute(value),
        )) }
    }
    fn uniform_matrix_4fv(&self, location: i32, transpose: bool, value: Vec<f32>) -> () {
        let value = pylist_f32_to_rust(&value);
        unsafe { mem::transmute(crate::AzGl_uniformMatrix4Fv(
            mem::transmute(self),
            mem::transmute(location),
            mem::transmute(transpose),
            mem::transmute(value),
        )) }
    }
    fn depth_mask(&self, flag: bool) -> () {
        unsafe { mem::transmute(crate::AzGl_depthMask(
            mem::transmute(self),
            mem::transmute(flag),
        )) }
    }
    fn depth_range(&self, near: f64, far: f64) -> () {
        unsafe { mem::transmute(crate::AzGl_depthRange(
            mem::transmute(self),
            mem::transmute(near),
            mem::transmute(far),
        )) }
    }
    fn get_active_attrib(&self, program: u32, index: u32) -> AzGetActiveAttribReturn {
        unsafe { mem::transmute(crate::AzGl_getActiveAttrib(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(index),
        )) }
    }
    fn get_active_uniform(&self, program: u32, index: u32) -> AzGetActiveUniformReturn {
        unsafe { mem::transmute(crate::AzGl_getActiveUniform(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(index),
        )) }
    }
    fn get_active_uniforms_iv(&self, program: u32, indices: AzGLuintVec, pname: u32) -> AzGLintVec {
        unsafe { mem::transmute(crate::AzGl_getActiveUniformsIv(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(indices),
            mem::transmute(pname),
        )) }
    }
    fn get_active_uniform_block_i(&self, program: u32, index: u32, pname: u32) -> i32 {
        unsafe { mem::transmute(crate::AzGl_getActiveUniformBlockI(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(index),
            mem::transmute(pname),
        )) }
    }
    fn get_active_uniform_block_iv(&self, program: u32, index: u32, pname: u32) -> AzGLintVec {
        unsafe { mem::transmute(crate::AzGl_getActiveUniformBlockIv(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(index),
            mem::transmute(pname),
        )) }
    }
    fn get_active_uniform_block_name(&self, program: u32, index: u32) -> String {
        az_string_to_py_string(unsafe { mem::transmute(crate::AzGl_getActiveUniformBlockName(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(index),
        )) })
    }
    fn get_attrib_location(&self, program: u32, name: &str) -> i32 {
        let name = pystring_to_refstr(&name);
        unsafe { mem::transmute(crate::AzGl_getAttribLocation(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(name),
        )) }
    }
    fn get_frag_data_location(&self, program: u32, name: &str) -> i32 {
        let name = pystring_to_refstr(&name);
        unsafe { mem::transmute(crate::AzGl_getFragDataLocation(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(name),
        )) }
    }
    fn get_uniform_location(&self, program: u32, name: &str) -> i32 {
        let name = pystring_to_refstr(&name);
        unsafe { mem::transmute(crate::AzGl_getUniformLocation(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(name),
        )) }
    }
    fn get_program_info_log(&self, program: u32) -> String {
        az_string_to_py_string(unsafe { mem::transmute(crate::AzGl_getProgramInfoLog(
            mem::transmute(self),
            mem::transmute(program),
        )) })
    }
    fn get_program_iv(&self, program: u32, pname: u32, mut result: Vec<i32>) -> () {
        let result = pylist_i32_to_rust(&mut result);
        unsafe { mem::transmute(crate::AzGl_getProgramIv(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(pname),
            mem::transmute(result),
        )) }
    }
    fn get_program_binary(&self, program: u32) -> AzGetProgramBinaryReturn {
        unsafe { mem::transmute(crate::AzGl_getProgramBinary(
            mem::transmute(self),
            mem::transmute(program),
        )) }
    }
    fn program_binary(&self, program: u32, format: u32, binary: Vec<u8>) -> () {
        let binary = pybytesref_to_vecu8_ref(&binary);
        unsafe { mem::transmute(crate::AzGl_programBinary(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(format),
            mem::transmute(binary),
        )) }
    }
    fn program_parameter_i(&self, program: u32, pname: u32, value: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_programParameterI(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(pname),
            mem::transmute(value),
        )) }
    }
    fn get_vertex_attrib_iv(&self, index: u32, pname: u32, mut result: Vec<i32>) -> () {
        let result = pylist_i32_to_rust(&mut result);
        unsafe { mem::transmute(crate::AzGl_getVertexAttribIv(
            mem::transmute(self),
            mem::transmute(index),
            mem::transmute(pname),
            mem::transmute(result),
        )) }
    }
    fn get_vertex_attrib_fv(&self, index: u32, pname: u32, mut result: Vec<f32>) -> () {
        let result = pylist_glfoat_to_rust(&mut result);
        unsafe { mem::transmute(crate::AzGl_getVertexAttribFv(
            mem::transmute(self),
            mem::transmute(index),
            mem::transmute(pname),
            mem::transmute(result),
        )) }
    }
    fn get_vertex_attrib_pointer_v(&self, index: u32, pname: u32) -> isize {
        unsafe { mem::transmute(crate::AzGl_getVertexAttribPointerV(
            mem::transmute(self),
            mem::transmute(index),
            mem::transmute(pname),
        )) }
    }
    fn get_buffer_parameter_iv(&self, target: u32, pname: u32) -> i32 {
        unsafe { mem::transmute(crate::AzGl_getBufferParameterIv(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(pname),
        )) }
    }
    fn get_shader_info_log(&self, shader: u32) -> String {
        az_string_to_py_string(unsafe { mem::transmute(crate::AzGl_getShaderInfoLog(
            mem::transmute(self),
            mem::transmute(shader),
        )) })
    }
    fn get_string(&self, which: u32) -> String {
        az_string_to_py_string(unsafe { mem::transmute(crate::AzGl_getString(
            mem::transmute(self),
            mem::transmute(which),
        )) })
    }
    fn get_string_i(&self, which: u32, index: u32) -> String {
        az_string_to_py_string(unsafe { mem::transmute(crate::AzGl_getStringI(
            mem::transmute(self),
            mem::transmute(which),
            mem::transmute(index),
        )) })
    }
    fn get_shader_iv(&self, shader: u32, pname: u32, mut result: Vec<i32>) -> () {
        let result = pylist_i32_to_rust(&mut result);
        unsafe { mem::transmute(crate::AzGl_getShaderIv(
            mem::transmute(self),
            mem::transmute(shader),
            mem::transmute(pname),
            mem::transmute(result),
        )) }
    }
    fn get_shader_precision_format(&self, shader_type: u32, precision_type: u32) -> AzGlShaderPrecisionFormatReturn {
        unsafe { mem::transmute(crate::AzGl_getShaderPrecisionFormat(
            mem::transmute(self),
            mem::transmute(shader_type),
            mem::transmute(precision_type),
        )) }
    }
    fn compile_shader(&self, shader: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_compileShader(
            mem::transmute(self),
            mem::transmute(shader),
        )) }
    }
    fn create_program(&self) -> u32 {
        unsafe { mem::transmute(crate::AzGl_createProgram(
            mem::transmute(self),
        )) }
    }
    fn delete_program(&self, program: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_deleteProgram(
            mem::transmute(self),
            mem::transmute(program),
        )) }
    }
    fn create_shader(&self, shader_type: u32) -> u32 {
        unsafe { mem::transmute(crate::AzGl_createShader(
            mem::transmute(self),
            mem::transmute(shader_type),
        )) }
    }
    fn delete_shader(&self, shader: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_deleteShader(
            mem::transmute(self),
            mem::transmute(shader),
        )) }
    }
    fn detach_shader(&self, program: u32, shader: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_detachShader(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(shader),
        )) }
    }
    fn link_program(&self, program: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_linkProgram(
            mem::transmute(self),
            mem::transmute(program),
        )) }
    }
    fn clear_color(&self, r: f32, g: f32, b: f32, a: f32) -> () {
        unsafe { mem::transmute(crate::AzGl_clearColor(
            mem::transmute(self),
            mem::transmute(r),
            mem::transmute(g),
            mem::transmute(b),
            mem::transmute(a),
        )) }
    }
    fn clear(&self, buffer_mask: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_clear(
            mem::transmute(self),
            mem::transmute(buffer_mask),
        )) }
    }
    fn clear_depth(&self, depth: f64) -> () {
        unsafe { mem::transmute(crate::AzGl_clearDepth(
            mem::transmute(self),
            mem::transmute(depth),
        )) }
    }
    fn clear_stencil(&self, s: i32) -> () {
        unsafe { mem::transmute(crate::AzGl_clearStencil(
            mem::transmute(self),
            mem::transmute(s),
        )) }
    }
    fn flush(&self) -> () {
        unsafe { mem::transmute(crate::AzGl_flush(
            mem::transmute(self),
        )) }
    }
    fn finish(&self) -> () {
        unsafe { mem::transmute(crate::AzGl_finish(
            mem::transmute(self),
        )) }
    }
    fn get_error(&self) -> u32 {
        unsafe { mem::transmute(crate::AzGl_getError(
            mem::transmute(self),
        )) }
    }
    fn stencil_mask(&self, mask: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_stencilMask(
            mem::transmute(self),
            mem::transmute(mask),
        )) }
    }
    fn stencil_mask_separate(&self, face: u32, mask: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_stencilMaskSeparate(
            mem::transmute(self),
            mem::transmute(face),
            mem::transmute(mask),
        )) }
    }
    fn stencil_func(&self, func: u32, ref_: i32, mask: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_stencilFunc(
            mem::transmute(self),
            mem::transmute(func),
            mem::transmute(ref_),
            mem::transmute(mask),
        )) }
    }
    fn stencil_func_separate(&self, face: u32, func: u32, ref_: i32, mask: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_stencilFuncSeparate(
            mem::transmute(self),
            mem::transmute(face),
            mem::transmute(func),
            mem::transmute(ref_),
            mem::transmute(mask),
        )) }
    }
    fn stencil_op(&self, sfail: u32, dpfail: u32, dppass: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_stencilOp(
            mem::transmute(self),
            mem::transmute(sfail),
            mem::transmute(dpfail),
            mem::transmute(dppass),
        )) }
    }
    fn stencil_op_separate(&self, face: u32, sfail: u32, dpfail: u32, dppass: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_stencilOpSeparate(
            mem::transmute(self),
            mem::transmute(face),
            mem::transmute(sfail),
            mem::transmute(dpfail),
            mem::transmute(dppass),
        )) }
    }
    fn egl_image_target_texture2d_oes(&self, target: u32, image: AzGlVoidPtrConst) -> () {
        unsafe { mem::transmute(crate::AzGl_eglImageTargetTexture2DOes(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(image),
        )) }
    }
    fn generate_mipmap(&self, target: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_generateMipmap(
            mem::transmute(self),
            mem::transmute(target),
        )) }
    }
    fn insert_event_marker_ext(&self, message: &str) -> () {
        let message = pystring_to_refstr(&message);
        unsafe { mem::transmute(crate::AzGl_insertEventMarkerExt(
            mem::transmute(self),
            mem::transmute(message),
        )) }
    }
    fn push_group_marker_ext(&self, message: &str) -> () {
        let message = pystring_to_refstr(&message);
        unsafe { mem::transmute(crate::AzGl_pushGroupMarkerExt(
            mem::transmute(self),
            mem::transmute(message),
        )) }
    }
    fn pop_group_marker_ext(&self) -> () {
        unsafe { mem::transmute(crate::AzGl_popGroupMarkerExt(
            mem::transmute(self),
        )) }
    }
    fn debug_message_insert_khr(&self, source: u32, type_: u32, id: u32, severity: u32, message: &str) -> () {
        let message = pystring_to_refstr(&message);
        unsafe { mem::transmute(crate::AzGl_debugMessageInsertKhr(
            mem::transmute(self),
            mem::transmute(source),
            mem::transmute(type_),
            mem::transmute(id),
            mem::transmute(severity),
            mem::transmute(message),
        )) }
    }
    fn push_debug_group_khr(&self, source: u32, id: u32, message: &str) -> () {
        let message = pystring_to_refstr(&message);
        unsafe { mem::transmute(crate::AzGl_pushDebugGroupKhr(
            mem::transmute(self),
            mem::transmute(source),
            mem::transmute(id),
            mem::transmute(message),
        )) }
    }
    fn pop_debug_group_khr(&self) -> () {
        unsafe { mem::transmute(crate::AzGl_popDebugGroupKhr(
            mem::transmute(self),
        )) }
    }
    fn fence_sync(&self, condition: u32, flags: u32) -> AzGLsyncPtr {
        unsafe { mem::transmute(crate::AzGl_fenceSync(
            mem::transmute(self),
            mem::transmute(condition),
            mem::transmute(flags),
        )) }
    }
    fn client_wait_sync(&self, sync: AzGLsyncPtr, flags: u32, timeout: u64) -> u32 {
        unsafe { mem::transmute(crate::AzGl_clientWaitSync(
            mem::transmute(self),
            mem::transmute(sync),
            mem::transmute(flags),
            mem::transmute(timeout),
        )) }
    }
    fn wait_sync(&self, sync: AzGLsyncPtr, flags: u32, timeout: u64) -> () {
        unsafe { mem::transmute(crate::AzGl_waitSync(
            mem::transmute(self),
            mem::transmute(sync),
            mem::transmute(flags),
            mem::transmute(timeout),
        )) }
    }
    fn delete_sync(&self, sync: AzGLsyncPtr) -> () {
        unsafe { mem::transmute(crate::AzGl_deleteSync(
            mem::transmute(self),
            mem::transmute(sync),
        )) }
    }
    fn texture_range_apple(&self, target: u32, data: Vec<u8>) -> () {
        let data = pybytesref_to_vecu8_ref(&data);
        unsafe { mem::transmute(crate::AzGl_textureRangeApple(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(data),
        )) }
    }
    fn gen_fences_apple(&self, n: i32) -> AzGLuintVec {
        unsafe { mem::transmute(crate::AzGl_genFencesApple(
            mem::transmute(self),
            mem::transmute(n),
        )) }
    }
    fn delete_fences_apple(&self, fences: Vec<u32>) -> () {
        let fences = pylist_u32_to_rust(&fences);
        unsafe { mem::transmute(crate::AzGl_deleteFencesApple(
            mem::transmute(self),
            mem::transmute(fences),
        )) }
    }
    fn set_fence_apple(&self, fence: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_setFenceApple(
            mem::transmute(self),
            mem::transmute(fence),
        )) }
    }
    fn finish_fence_apple(&self, fence: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_finishFenceApple(
            mem::transmute(self),
            mem::transmute(fence),
        )) }
    }
    fn test_fence_apple(&self, fence: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_testFenceApple(
            mem::transmute(self),
            mem::transmute(fence),
        )) }
    }
    fn test_object_apple(&self, object: u32, name: u32) -> u8 {
        unsafe { mem::transmute(crate::AzGl_testObjectApple(
            mem::transmute(self),
            mem::transmute(object),
            mem::transmute(name),
        )) }
    }
    fn finish_object_apple(&self, object: u32, name: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_finishObjectApple(
            mem::transmute(self),
            mem::transmute(object),
            mem::transmute(name),
        )) }
    }
    fn get_frag_data_index(&self, program: u32, name: &str) -> i32 {
        let name = pystring_to_refstr(&name);
        unsafe { mem::transmute(crate::AzGl_getFragDataIndex(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(name),
        )) }
    }
    fn blend_barrier_khr(&self) -> () {
        unsafe { mem::transmute(crate::AzGl_blendBarrierKhr(
            mem::transmute(self),
        )) }
    }
    fn bind_frag_data_location_indexed(&self, program: u32, color_number: u32, index: u32, name: &str) -> () {
        let name = pystring_to_refstr(&name);
        unsafe { mem::transmute(crate::AzGl_bindFragDataLocationIndexed(
            mem::transmute(self),
            mem::transmute(program),
            mem::transmute(color_number),
            mem::transmute(index),
            mem::transmute(name),
        )) }
    }
    fn get_debug_messages(&self) -> AzDebugMessageVec {
        unsafe { mem::transmute(crate::AzGl_getDebugMessages(
            mem::transmute(self),
        )) }
    }
    fn provoking_vertex_angle(&self, mode: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_provokingVertexAngle(
            mem::transmute(self),
            mem::transmute(mode),
        )) }
    }
    fn gen_vertex_arrays_apple(&self, n: i32) -> AzGLuintVec {
        unsafe { mem::transmute(crate::AzGl_genVertexArraysApple(
            mem::transmute(self),
            mem::transmute(n),
        )) }
    }
    fn bind_vertex_array_apple(&self, vao: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_bindVertexArrayApple(
            mem::transmute(self),
            mem::transmute(vao),
        )) }
    }
    fn delete_vertex_arrays_apple(&self, vertex_arrays: Vec<u32>) -> () {
        let vertex_arrays = pylist_u32_to_rust(&vertex_arrays);
        unsafe { mem::transmute(crate::AzGl_deleteVertexArraysApple(
            mem::transmute(self),
            mem::transmute(vertex_arrays),
        )) }
    }
    fn copy_texture_chromium(&self, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, internal_format: i32, dest_type: u32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8) -> () {
        unsafe { mem::transmute(crate::AzGl_copyTextureChromium(
            mem::transmute(self),
            mem::transmute(source_id),
            mem::transmute(source_level),
            mem::transmute(dest_target),
            mem::transmute(dest_id),
            mem::transmute(dest_level),
            mem::transmute(internal_format),
            mem::transmute(dest_type),
            mem::transmute(unpack_flip_y),
            mem::transmute(unpack_premultiply_alpha),
            mem::transmute(unpack_unmultiply_alpha),
        )) }
    }
    fn copy_sub_texture_chromium(&self, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, x_offset: i32, y_offset: i32, x: i32, y: i32, width: i32, height: i32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8) -> () {
        unsafe { mem::transmute(crate::AzGl_copySubTextureChromium(
            mem::transmute(self),
            mem::transmute(source_id),
            mem::transmute(source_level),
            mem::transmute(dest_target),
            mem::transmute(dest_id),
            mem::transmute(dest_level),
            mem::transmute(x_offset),
            mem::transmute(y_offset),
            mem::transmute(x),
            mem::transmute(y),
            mem::transmute(width),
            mem::transmute(height),
            mem::transmute(unpack_flip_y),
            mem::transmute(unpack_premultiply_alpha),
            mem::transmute(unpack_unmultiply_alpha),
        )) }
    }
    fn egl_image_target_renderbuffer_storage_oes(&self, target: u32, image: AzGlVoidPtrConst) -> () {
        unsafe { mem::transmute(crate::AzGl_eglImageTargetRenderbufferStorageOes(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(image),
        )) }
    }
    fn copy_texture_3d_angle(&self, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, internal_format: i32, dest_type: u32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8) -> () {
        unsafe { mem::transmute(crate::AzGl_copyTexture3DAngle(
            mem::transmute(self),
            mem::transmute(source_id),
            mem::transmute(source_level),
            mem::transmute(dest_target),
            mem::transmute(dest_id),
            mem::transmute(dest_level),
            mem::transmute(internal_format),
            mem::transmute(dest_type),
            mem::transmute(unpack_flip_y),
            mem::transmute(unpack_premultiply_alpha),
            mem::transmute(unpack_unmultiply_alpha),
        )) }
    }
    fn copy_sub_texture_3d_angle(&self, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, x_offset: i32, y_offset: i32, z_offset: i32, x: i32, y: i32, z: i32, width: i32, height: i32, depth: i32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8) -> () {
        unsafe { mem::transmute(crate::AzGl_copySubTexture3DAngle(
            mem::transmute(self),
            mem::transmute(source_id),
            mem::transmute(source_level),
            mem::transmute(dest_target),
            mem::transmute(dest_id),
            mem::transmute(dest_level),
            mem::transmute(x_offset),
            mem::transmute(y_offset),
            mem::transmute(z_offset),
            mem::transmute(x),
            mem::transmute(y),
            mem::transmute(z),
            mem::transmute(width),
            mem::transmute(height),
            mem::transmute(depth),
            mem::transmute(unpack_flip_y),
            mem::transmute(unpack_premultiply_alpha),
            mem::transmute(unpack_unmultiply_alpha),
        )) }
    }
    fn buffer_storage(&self, target: u32, size: isize, data: AzGlVoidPtrConst, flags: u32) -> () {
        unsafe { mem::transmute(crate::AzGl_bufferStorage(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(size),
            mem::transmute(data),
            mem::transmute(flags),
        )) }
    }
    fn flush_mapped_buffer_range(&self, target: u32, offset: isize, length: isize) -> () {
        unsafe { mem::transmute(crate::AzGl_flushMappedBufferRange(
            mem::transmute(self),
            mem::transmute(target),
            mem::transmute(offset),
            mem::transmute(length),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGl {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GlContextPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GlContextPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlShaderPrecisionFormatReturn {
    #[new]
    fn __new__(_0: i32, _1: i32, _2: i32) -> Self {
        Self {
            _0,
            _1,
            _2,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzGlShaderPrecisionFormatReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GlShaderPrecisionFormatReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GlShaderPrecisionFormatReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexAttributeTypeEnumWrapper {
    #[classattr]
    fn Float() -> AzVertexAttributeTypeEnumWrapper { AzVertexAttributeTypeEnumWrapper { inner: AzVertexAttributeType::Float } }
    #[classattr]
    fn Double() -> AzVertexAttributeTypeEnumWrapper { AzVertexAttributeTypeEnumWrapper { inner: AzVertexAttributeType::Double } }
    #[classattr]
    fn UnsignedByte() -> AzVertexAttributeTypeEnumWrapper { AzVertexAttributeTypeEnumWrapper { inner: AzVertexAttributeType::UnsignedByte } }
    #[classattr]
    fn UnsignedShort() -> AzVertexAttributeTypeEnumWrapper { AzVertexAttributeTypeEnumWrapper { inner: AzVertexAttributeType::UnsignedShort } }
    #[classattr]
    fn UnsignedInt() -> AzVertexAttributeTypeEnumWrapper { AzVertexAttributeTypeEnumWrapper { inner: AzVertexAttributeType::UnsignedInt } }
}

#[pyproto]
impl PyObjectProtocol for AzVertexAttributeTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::VertexAttributeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::VertexAttributeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzVertexAttributeTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzVertexAttribute {
    #[new]
    fn __new__(name: AzString, layout_location: AzOptionUsizeEnumWrapper, attribute_type: AzVertexAttributeTypeEnumWrapper, item_count: usize) -> Self {
        Self {
            name,
            layout_location,
            attribute_type,
            item_count,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzVertexAttribute {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::VertexAttribute = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::VertexAttribute = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexLayout {
    #[new]
    fn __new__(fields: AzVertexAttributeVec) -> Self {
        Self {
            fields,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzVertexLayout {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::VertexLayout = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::VertexLayout = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexArrayObject {
    #[new]
    fn new(vertex_layout: AzVertexLayout, vao_id: u32, gl_context: AzGl) -> AzVertexArrayObject {
        unsafe { mem::transmute(crate::AzVertexArrayObject_new(
            mem::transmute(vertex_layout),
            mem::transmute(vao_id),
            mem::transmute(gl_context),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVertexArrayObject {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::VertexArrayObject = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::VertexArrayObject = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIndexBufferFormatEnumWrapper {
    #[classattr]
    fn Points() -> AzIndexBufferFormatEnumWrapper { AzIndexBufferFormatEnumWrapper { inner: AzIndexBufferFormat::Points } }
    #[classattr]
    fn Lines() -> AzIndexBufferFormatEnumWrapper { AzIndexBufferFormatEnumWrapper { inner: AzIndexBufferFormat::Lines } }
    #[classattr]
    fn LineStrip() -> AzIndexBufferFormatEnumWrapper { AzIndexBufferFormatEnumWrapper { inner: AzIndexBufferFormat::LineStrip } }
    #[classattr]
    fn Triangles() -> AzIndexBufferFormatEnumWrapper { AzIndexBufferFormatEnumWrapper { inner: AzIndexBufferFormat::Triangles } }
    #[classattr]
    fn TriangleStrip() -> AzIndexBufferFormatEnumWrapper { AzIndexBufferFormatEnumWrapper { inner: AzIndexBufferFormat::TriangleStrip } }
    #[classattr]
    fn TriangleFan() -> AzIndexBufferFormatEnumWrapper { AzIndexBufferFormatEnumWrapper { inner: AzIndexBufferFormat::TriangleFan } }
}

#[pyproto]
impl PyObjectProtocol for AzIndexBufferFormatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::IndexBufferFormat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::IndexBufferFormat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzIndexBufferFormatEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzVertexBuffer {
    #[new]
    fn new(vertex_buffer_id: u32, vertex_buffer_len: usize, vao: AzVertexArrayObject, index_buffer_id: u32, index_buffer_len: usize, index_buffer_format: AzIndexBufferFormatEnumWrapper) -> AzVertexBuffer {
        unsafe { mem::transmute(crate::AzVertexBuffer_new(
            mem::transmute(vertex_buffer_id),
            mem::transmute(vertex_buffer_len),
            mem::transmute(vao),
            mem::transmute(index_buffer_id),
            mem::transmute(index_buffer_len),
            mem::transmute(index_buffer_format),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVertexBuffer {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::VertexBuffer = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::VertexBuffer = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlTypeEnumWrapper {
    #[classattr]
    fn Gl() -> AzGlTypeEnumWrapper { AzGlTypeEnumWrapper { inner: AzGlType::Gl } }
    #[classattr]
    fn Gles() -> AzGlTypeEnumWrapper { AzGlTypeEnumWrapper { inner: AzGlType::Gles } }
}

#[pyproto]
impl PyObjectProtocol for AzGlTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::AzGlType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::AzGlType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzGlTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzDebugMessage {
    #[new]
    fn __new__(message: AzString, source: u32, ty: u32, id: u32, severity: u32) -> Self {
        Self {
            message,
            source,
            ty,
            id,
            severity,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzDebugMessage {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::AzDebugMessage = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::AzDebugMessage = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU8VecRef {
}

#[pyproto]
impl PyObjectProtocol for AzU8VecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::U8VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::U8VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU8VecRefMut {
}

#[pyproto]
impl PyObjectProtocol for AzU8VecRefMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::U8VecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::U8VecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzF32VecRef {
}

#[pyproto]
impl PyObjectProtocol for AzF32VecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::F32VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::F32VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzI32VecRef {
}

#[pyproto]
impl PyObjectProtocol for AzI32VecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::I32VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::I32VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLuintVecRef {
}

#[pyproto]
impl PyObjectProtocol for AzGLuintVecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLuintVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLuintVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLenumVecRef {
}

#[pyproto]
impl PyObjectProtocol for AzGLenumVecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLenumVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLenumVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLintVecRefMut {
}

#[pyproto]
impl PyObjectProtocol for AzGLintVecRefMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLintVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLintVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLint64VecRefMut {
}

#[pyproto]
impl PyObjectProtocol for AzGLint64VecRefMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLint64VecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLint64VecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLbooleanVecRefMut {
}

#[pyproto]
impl PyObjectProtocol for AzGLbooleanVecRefMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLbooleanVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLbooleanVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLfloatVecRefMut {
}

#[pyproto]
impl PyObjectProtocol for AzGLfloatVecRefMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLfloatVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLfloatVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRefstrVecRef {
}

#[pyproto]
impl PyObjectProtocol for AzRefstrVecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::RefstrVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::RefstrVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRefstr {
}

#[pyproto]
impl PyObjectProtocol for AzRefstr {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::Refstr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::Refstr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGetProgramBinaryReturn {
    #[new]
    fn __new__(_0: AzU8Vec, _1: u32) -> Self {
        Self {
            _0,
            _1,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzGetProgramBinaryReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GetProgramBinaryReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GetProgramBinaryReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGetActiveAttribReturn {
    #[new]
    fn __new__(_0: i32, _1: u32, _2: AzString) -> Self {
        Self {
            _0,
            _1,
            _2,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzGetActiveAttribReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GetActiveAttribReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GetActiveAttribReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLsyncPtr {
}

#[pyproto]
impl PyObjectProtocol for AzGLsyncPtr {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLsyncPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLsyncPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGetActiveUniformReturn {
    #[new]
    fn __new__(_0: i32, _1: u32, _2: AzString) -> Self {
        Self {
            _0,
            _1,
            _2,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzGetActiveUniformReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GetActiveUniformReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GetActiveUniformReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextureFlags {
    #[staticmethod]
    fn default() -> AzTextureFlags {
        unsafe { mem::transmute(crate::AzTextureFlags_default()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextureFlags {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::TextureFlags = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::TextureFlags = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzImageRef {
    #[staticmethod]
    fn invalid(width: usize, height: usize, format: AzRawImageFormatEnumWrapper) -> AzImageRef {
        unsafe { mem::transmute(crate::AzImageRef_invalid(
            mem::transmute(width),
            mem::transmute(height),
            mem::transmute(format),
        )) }
    }
    #[staticmethod]
    fn raw_image(data: AzRawImage) -> Option<AzImageRef> {
        let m: AzOptionImageRef = unsafe { mem::transmute(crate::AzImageRef_rawImage(
            mem::transmute(data),
        )) };
        match m {
            AzOptionImageRef::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionImageRef::None => None,
        }

    }
    #[staticmethod]
    fn gl_texture(texture: AzTexture) -> AzImageRef {
        unsafe { mem::transmute(crate::AzImageRef_glTexture(
            mem::transmute(texture),
        )) }
    }
    fn clone_bytes(&self) -> AzImageRef {
        unsafe { mem::transmute(crate::AzImageRef_cloneBytes(
            mem::transmute(self),
        )) }
    }
    fn is_invalid(&self) -> bool {
        unsafe { mem::transmute(crate::AzImageRef_isInvalid(
            mem::transmute(self),
        )) }
    }
    fn is_gl_texture(&self) -> bool {
        unsafe { mem::transmute(crate::AzImageRef_isGlTexture(
            mem::transmute(self),
        )) }
    }
    fn is_raw_image(&self) -> bool {
        unsafe { mem::transmute(crate::AzImageRef_isRawImage(
            mem::transmute(self),
        )) }
    }
    fn is_callback(&self) -> bool {
        unsafe { mem::transmute(crate::AzImageRef_isCallback(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzImageRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::ImageRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::ImageRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRawImage {
    #[staticmethod]
    fn empty() -> AzRawImage {
        unsafe { mem::transmute(crate::AzRawImage_empty()) }
    }
    #[staticmethod]
    fn allocate_clip_mask(size: AzLayoutSize) -> AzRawImage {
        unsafe { mem::transmute(crate::AzRawImage_allocateClipMask(
            mem::transmute(size),
        )) }
    }
    #[staticmethod]
    fn decode_image_bytes_any(bytes: Vec<u8>) -> Result<AzRawImage, PyErr> {
        let bytes = pybytesref_to_vecu8_ref(&bytes);
        let m: AzResultRawImageDecodeImageError = unsafe { mem::transmute(crate::AzRawImage_decodeImageBytesAny(
            mem::transmute(bytes),
        )) };
        match m {
            AzResultRawImageDecodeImageError::Ok(o) => Ok(o.into()),
            AzResultRawImageDecodeImageError::Err(e) => Err(e.into()),
        }

    }
    fn draw_clip_mask(&mut self, node: AzSvgNodeEnumWrapper, style: AzSvgStyleEnumWrapper) -> bool {
        unsafe { mem::transmute(crate::AzRawImage_drawClipMask(
            mem::transmute(self),
            mem::transmute(node),
            mem::transmute(style),
        )) }
    }
    fn encode_bmp(&self) -> Result<Vec<u8>, PyErr> {
        let m: AzResultU8VecEncodeImageError = unsafe { mem::transmute(crate::AzRawImage_encodeBmp(
            mem::transmute(self),
        )) };
        match m {
            AzResultU8VecEncodeImageError::Ok(o) => Ok(o.into()),
            AzResultU8VecEncodeImageError::Err(e) => Err(e.into()),
        }

    }
    fn encode_png(&self) -> Result<Vec<u8>, PyErr> {
        let m: AzResultU8VecEncodeImageError = unsafe { mem::transmute(crate::AzRawImage_encodePng(
            mem::transmute(self),
        )) };
        match m {
            AzResultU8VecEncodeImageError::Ok(o) => Ok(o.into()),
            AzResultU8VecEncodeImageError::Err(e) => Err(e.into()),
        }

    }
    fn encode_jpeg(&self) -> Result<Vec<u8>, PyErr> {
        let m: AzResultU8VecEncodeImageError = unsafe { mem::transmute(crate::AzRawImage_encodeJpeg(
            mem::transmute(self),
        )) };
        match m {
            AzResultU8VecEncodeImageError::Ok(o) => Ok(o.into()),
            AzResultU8VecEncodeImageError::Err(e) => Err(e.into()),
        }

    }
    fn encode_tga(&self) -> Result<Vec<u8>, PyErr> {
        let m: AzResultU8VecEncodeImageError = unsafe { mem::transmute(crate::AzRawImage_encodeTga(
            mem::transmute(self),
        )) };
        match m {
            AzResultU8VecEncodeImageError::Ok(o) => Ok(o.into()),
            AzResultU8VecEncodeImageError::Err(e) => Err(e.into()),
        }

    }
    fn encode_pnm(&self) -> Result<Vec<u8>, PyErr> {
        let m: AzResultU8VecEncodeImageError = unsafe { mem::transmute(crate::AzRawImage_encodePnm(
            mem::transmute(self),
        )) };
        match m {
            AzResultU8VecEncodeImageError::Ok(o) => Ok(o.into()),
            AzResultU8VecEncodeImageError::Err(e) => Err(e.into()),
        }

    }
    fn encode_gif(&self) -> Result<Vec<u8>, PyErr> {
        let m: AzResultU8VecEncodeImageError = unsafe { mem::transmute(crate::AzRawImage_encodeGif(
            mem::transmute(self),
        )) };
        match m {
            AzResultU8VecEncodeImageError::Ok(o) => Ok(o.into()),
            AzResultU8VecEncodeImageError::Err(e) => Err(e.into()),
        }

    }
    fn encode_tiff(&self) -> Result<Vec<u8>, PyErr> {
        let m: AzResultU8VecEncodeImageError = unsafe { mem::transmute(crate::AzRawImage_encodeTiff(
            mem::transmute(self),
        )) };
        match m {
            AzResultU8VecEncodeImageError::Ok(o) => Ok(o.into()),
            AzResultU8VecEncodeImageError::Err(e) => Err(e.into()),
        }

    }
}

#[pyproto]
impl PyObjectProtocol for AzRawImage {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::RawImage = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::RawImage = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzImageMask {
    #[new]
    fn __new__(image: AzImageRef, rect: AzLogicalRect, repeat: bool) -> Self {
        Self {
            image,
            rect,
            repeat,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzImageMask {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::ImageMask = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::ImageMask = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRawImageFormatEnumWrapper {
    #[classattr]
    fn R8() -> AzRawImageFormatEnumWrapper { AzRawImageFormatEnumWrapper { inner: AzRawImageFormat::R8 } }
    #[classattr]
    fn RG8() -> AzRawImageFormatEnumWrapper { AzRawImageFormatEnumWrapper { inner: AzRawImageFormat::RG8 } }
    #[classattr]
    fn RGB8() -> AzRawImageFormatEnumWrapper { AzRawImageFormatEnumWrapper { inner: AzRawImageFormat::RGB8 } }
    #[classattr]
    fn RGBA8() -> AzRawImageFormatEnumWrapper { AzRawImageFormatEnumWrapper { inner: AzRawImageFormat::RGBA8 } }
    #[classattr]
    fn R16() -> AzRawImageFormatEnumWrapper { AzRawImageFormatEnumWrapper { inner: AzRawImageFormat::R16 } }
    #[classattr]
    fn RG16() -> AzRawImageFormatEnumWrapper { AzRawImageFormatEnumWrapper { inner: AzRawImageFormat::RG16 } }
    #[classattr]
    fn RGB16() -> AzRawImageFormatEnumWrapper { AzRawImageFormatEnumWrapper { inner: AzRawImageFormat::RGB16 } }
    #[classattr]
    fn RGBA16() -> AzRawImageFormatEnumWrapper { AzRawImageFormatEnumWrapper { inner: AzRawImageFormat::RGBA16 } }
    #[classattr]
    fn BGR8() -> AzRawImageFormatEnumWrapper { AzRawImageFormatEnumWrapper { inner: AzRawImageFormat::BGR8 } }
    #[classattr]
    fn BGRA8() -> AzRawImageFormatEnumWrapper { AzRawImageFormatEnumWrapper { inner: AzRawImageFormat::BGRA8 } }
}

#[pyproto]
impl PyObjectProtocol for AzRawImageFormatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::RawImageFormat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::RawImageFormat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzRawImageFormatEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzEncodeImageErrorEnumWrapper {
    #[classattr]
    fn EncoderNotAvailable() -> AzEncodeImageErrorEnumWrapper { AzEncodeImageErrorEnumWrapper { inner: AzEncodeImageError::EncoderNotAvailable } }
    #[classattr]
    fn InsufficientMemory() -> AzEncodeImageErrorEnumWrapper { AzEncodeImageErrorEnumWrapper { inner: AzEncodeImageError::InsufficientMemory } }
    #[classattr]
    fn DimensionError() -> AzEncodeImageErrorEnumWrapper { AzEncodeImageErrorEnumWrapper { inner: AzEncodeImageError::DimensionError } }
    #[classattr]
    fn InvalidData() -> AzEncodeImageErrorEnumWrapper { AzEncodeImageErrorEnumWrapper { inner: AzEncodeImageError::InvalidData } }
    #[classattr]
    fn Unknown() -> AzEncodeImageErrorEnumWrapper { AzEncodeImageErrorEnumWrapper { inner: AzEncodeImageError::Unknown } }
}

#[pyproto]
impl PyObjectProtocol for AzEncodeImageErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::encode::EncodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::encode::EncodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzEncodeImageErrorEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzDecodeImageErrorEnumWrapper {
    #[classattr]
    fn InsufficientMemory() -> AzDecodeImageErrorEnumWrapper { AzDecodeImageErrorEnumWrapper { inner: AzDecodeImageError::InsufficientMemory } }
    #[classattr]
    fn DimensionError() -> AzDecodeImageErrorEnumWrapper { AzDecodeImageErrorEnumWrapper { inner: AzDecodeImageError::DimensionError } }
    #[classattr]
    fn UnsupportedImageFormat() -> AzDecodeImageErrorEnumWrapper { AzDecodeImageErrorEnumWrapper { inner: AzDecodeImageError::UnsupportedImageFormat } }
    #[classattr]
    fn Unknown() -> AzDecodeImageErrorEnumWrapper { AzDecodeImageErrorEnumWrapper { inner: AzDecodeImageError::Unknown } }
}

#[pyproto]
impl PyObjectProtocol for AzDecodeImageErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::decode::DecodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::decode::DecodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzDecodeImageErrorEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzRawImageDataEnumWrapper {
    #[staticmethod]
    fn U8(v: AzU8Vec) -> AzRawImageDataEnumWrapper { AzRawImageDataEnumWrapper { inner: AzRawImageData::U8(v) } }
    #[staticmethod]
    fn U16(v: AzU16Vec) -> AzRawImageDataEnumWrapper { AzRawImageDataEnumWrapper { inner: AzRawImageData::U16(v) } }
    #[staticmethod]
    fn F32(v: AzF32Vec) -> AzRawImageDataEnumWrapper { AzRawImageDataEnumWrapper { inner: AzRawImageData::F32(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzRawImageData;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzRawImageData::U8(v) => Ok(vec!["U8".into_py(py), v.clone().into_py(py)]),
            AzRawImageData::U16(v) => Ok(vec!["U16".into_py(py), v.clone().into_py(py)]),
            AzRawImageData::F32(v) => Ok(vec!["F32".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRawImageDataEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::RawImageData = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::RawImageData = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFontMetrics {
}

#[pyproto]
impl PyObjectProtocol for AzFontMetrics {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::FontMetrics = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::FontMetrics = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFontSource {
    #[new]
    fn __new__(data: AzU8Vec, font_index: u32, parse_glyph_outlines: bool) -> Self {
        Self {
            data,
            font_index,
            parse_glyph_outlines,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzFontSource {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::LoadedFontSource = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::LoadedFontSource = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFontRef {
    #[staticmethod]
    fn parse(source: AzFontSource) -> Option<AzFontRef> {
        let m: AzOptionFontRef = unsafe { mem::transmute(crate::AzFontRef_parse(
            mem::transmute(source),
        )) };
        match m {
            AzOptionFontRef::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionFontRef::None => None,
        }

    }
    fn get_font_metrics(&self) -> AzFontMetrics {
        unsafe { mem::transmute(crate::AzFontRef_getFontMetrics(
            mem::transmute(self),
        )) }
    }
    fn shape_text(&self, text: &str, options: AzResolvedTextLayoutOptions) -> AzInlineText {
        let text = pystring_to_refstr(&text);
        unsafe { mem::transmute(crate::AzFontRef_shapeText(
            mem::transmute(self),
            mem::transmute(text),
            mem::transmute(options),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFontRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::FontRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::FontRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvg {
    #[staticmethod]
    fn from_string(svg_string: String, parse_options: AzSvgParseOptions) -> Result<AzSvg, PyErr> {
        let svg_string = pystring_to_azstring(&svg_string);
        let m: AzResultSvgSvgParseError = unsafe { mem::transmute(crate::AzSvg_fromString(
            mem::transmute(svg_string),
            mem::transmute(parse_options),
        )) };
        match m {
            AzResultSvgSvgParseError::Ok(o) => Ok(o.into()),
            AzResultSvgSvgParseError::Err(e) => Err(e.into()),
        }

    }
    #[staticmethod]
    fn from_bytes(svg_bytes: Vec<u8>, parse_options: AzSvgParseOptions) -> Result<AzSvg, PyErr> {
        let svg_bytes = pybytesref_to_vecu8_ref(&svg_bytes);
        let m: AzResultSvgSvgParseError = unsafe { mem::transmute(crate::AzSvg_fromBytes(
            mem::transmute(svg_bytes),
            mem::transmute(parse_options),
        )) };
        match m {
            AzResultSvgSvgParseError::Ok(o) => Ok(o.into()),
            AzResultSvgSvgParseError::Err(e) => Err(e.into()),
        }

    }
    fn get_root(&self) -> AzSvgXmlNode {
        unsafe { mem::transmute(crate::AzSvg_getRoot(
            mem::transmute(self),
        )) }
    }
    fn render(&self, options: AzSvgRenderOptions) -> Option<AzRawImage> {
        let m: AzOptionRawImage = unsafe { mem::transmute(crate::AzSvg_render(
            mem::transmute(self),
            mem::transmute(options),
        )) };
        match m {
            AzOptionRawImage::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionRawImage::None => None,
        }

    }
    fn to_string(&self, options: AzSvgStringFormatOptions) -> String {
        az_string_to_py_string(unsafe { mem::transmute(crate::AzSvg_toString(
            mem::transmute(self),
            mem::transmute(options),
        )) })
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvg {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::Svg = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::Svg = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgXmlNode {
    #[staticmethod]
    fn parse_from(svg_bytes: Vec<u8>, parse_options: AzSvgParseOptions) -> Result<AzSvgXmlNode, PyErr> {
        let svg_bytes = pybytesref_to_vecu8_ref(&svg_bytes);
        let m: AzResultSvgXmlNodeSvgParseError = unsafe { mem::transmute(crate::AzSvgXmlNode_parseFrom(
            mem::transmute(svg_bytes),
            mem::transmute(parse_options),
        )) };
        match m {
            AzResultSvgXmlNodeSvgParseError::Ok(o) => Ok(o.into()),
            AzResultSvgXmlNodeSvgParseError::Err(e) => Err(e.into()),
        }

    }
    fn render(&self, options: AzSvgRenderOptions) -> Option<AzRawImage> {
        let m: AzOptionRawImage = unsafe { mem::transmute(crate::AzSvgXmlNode_render(
            mem::transmute(self),
            mem::transmute(options),
        )) };
        match m {
            AzOptionRawImage::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionRawImage::None => None,
        }

    }
    fn to_string(&self, options: AzSvgStringFormatOptions) -> String {
        az_string_to_py_string(unsafe { mem::transmute(crate::AzSvgXmlNode_toString(
            mem::transmute(self),
            mem::transmute(options),
        )) })
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgXmlNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgXmlNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgXmlNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgMultiPolygon {
    #[new]
    fn __new__(rings: AzSvgPathVec) -> Self {
        Self {
            rings,
        }
    }

    fn tessellate_fill(&self, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode {
        unsafe { mem::transmute(crate::AzSvgMultiPolygon_tessellateFill(
            mem::transmute(self),
            mem::transmute(fill_style),
        )) }
    }
    fn tessellate_stroke(&self, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode {
        unsafe { mem::transmute(crate::AzSvgMultiPolygon_tessellateStroke(
            mem::transmute(self),
            mem::transmute(stroke_style),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgMultiPolygon {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgMultiPolygon = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgMultiPolygon = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgNodeEnumWrapper {
    #[staticmethod]
    fn MultiPolygonCollection(v: AzSvgMultiPolygonVec) -> AzSvgNodeEnumWrapper { AzSvgNodeEnumWrapper { inner: AzSvgNode::MultiPolygonCollection(v) } }
    #[staticmethod]
    fn MultiPolygon(v: AzSvgMultiPolygon) -> AzSvgNodeEnumWrapper { AzSvgNodeEnumWrapper { inner: AzSvgNode::MultiPolygon(v) } }
    #[staticmethod]
    fn Path(v: AzSvgPath) -> AzSvgNodeEnumWrapper { AzSvgNodeEnumWrapper { inner: AzSvgNode::Path(v) } }
    #[staticmethod]
    fn Circle(v: AzSvgCircle) -> AzSvgNodeEnumWrapper { AzSvgNodeEnumWrapper { inner: AzSvgNode::Circle(v) } }
    #[staticmethod]
    fn Rect(v: AzSvgRect) -> AzSvgNodeEnumWrapper { AzSvgNodeEnumWrapper { inner: AzSvgNode::Rect(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgNode;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgNode::MultiPolygonCollection(v) => Ok(vec!["MultiPolygonCollection".into_py(py), v.clone().into_py(py)]),
            AzSvgNode::MultiPolygon(v) => Ok(vec!["MultiPolygon".into_py(py), v.clone().into_py(py)]),
            AzSvgNode::Path(v) => Ok(vec!["Path".into_py(py), v.clone().into_py(py)]),
            AzSvgNode::Circle(v) => Ok(vec!["Circle".into_py(py), v.clone().into_py(py)]),
            AzSvgNode::Rect(v) => Ok(vec!["Rect".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgNodeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgNode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgNode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgStyledNode {
    #[new]
    fn __new__(geometry: AzSvgNodeEnumWrapper, style: AzSvgStyleEnumWrapper) -> Self {
        Self {
            geometry,
            style,
        }
    }

    fn tessellate(&self) -> AzTessellatedSvgNode {
        unsafe { mem::transmute(crate::AzSvgStyledNode_tessellate(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgStyledNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgStyledNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgStyledNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgCircle {
    #[new]
    fn __new__(center_x: f32, center_y: f32, radius: f32) -> Self {
        Self {
            center_x,
            center_y,
            radius,
        }
    }

    fn tessellate_fill(&self, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode {
        unsafe { mem::transmute(crate::AzSvgCircle_tessellateFill(
            mem::transmute(self),
            mem::transmute(fill_style),
        )) }
    }
    fn tessellate_stroke(&self, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode {
        unsafe { mem::transmute(crate::AzSvgCircle_tessellateStroke(
            mem::transmute(self),
            mem::transmute(stroke_style),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgCircle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgCircle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgCircle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPath {
    #[new]
    fn __new__(items: AzSvgPathElementVec) -> Self {
        Self {
            items,
        }
    }

    fn tessellate_fill(&self, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode {
        unsafe { mem::transmute(crate::AzSvgPath_tessellateFill(
            mem::transmute(self),
            mem::transmute(fill_style),
        )) }
    }
    fn tessellate_stroke(&self, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode {
        unsafe { mem::transmute(crate::AzSvgPath_tessellateStroke(
            mem::transmute(self),
            mem::transmute(stroke_style),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPath {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgPath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgPath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathElementEnumWrapper {
    #[staticmethod]
    fn Line(v: AzSvgLine) -> AzSvgPathElementEnumWrapper { AzSvgPathElementEnumWrapper { inner: AzSvgPathElement::Line(v) } }
    #[staticmethod]
    fn QuadraticCurve(v: AzSvgQuadraticCurve) -> AzSvgPathElementEnumWrapper { AzSvgPathElementEnumWrapper { inner: AzSvgPathElement::QuadraticCurve(v) } }
    #[staticmethod]
    fn CubicCurve(v: AzSvgCubicCurve) -> AzSvgPathElementEnumWrapper { AzSvgPathElementEnumWrapper { inner: AzSvgPathElement::CubicCurve(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgPathElement;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgPathElement::Line(v) => Ok(vec!["Line".into_py(py), v.clone().into_py(py)]),
            AzSvgPathElement::QuadraticCurve(v) => Ok(vec!["QuadraticCurve".into_py(py), v.clone().into_py(py)]),
            AzSvgPathElement::CubicCurve(v) => Ok(vec!["CubicCurve".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathElementEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgPathElement = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgPathElement = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgLine {
    #[new]
    fn __new__(start: AzSvgPoint, end: AzSvgPoint) -> Self {
        Self {
            start,
            end,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgLine {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgLine = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgLine = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPoint {
    #[new]
    fn __new__(x: f32, y: f32) -> Self {
        Self {
            x,
            y,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgPoint {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgPoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgPoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgQuadraticCurve {
    #[new]
    fn __new__(start: AzSvgPoint, ctrl: AzSvgPoint, end: AzSvgPoint) -> Self {
        Self {
            start,
            ctrl,
            end,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgQuadraticCurve {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgQuadraticCurve = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgQuadraticCurve = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgCubicCurve {
    #[new]
    fn __new__(start: AzSvgPoint, ctrl_1: AzSvgPoint, ctrl_2: AzSvgPoint, end: AzSvgPoint) -> Self {
        Self {
            start,
            ctrl_1,
            ctrl_2,
            end,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgCubicCurve {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgCubicCurve = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgCubicCurve = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgRect {
    #[new]
    fn __new__(width: f32, height: f32, x: f32, y: f32, radius_top_left: f32, radius_top_right: f32, radius_bottom_left: f32, radius_bottom_right: f32) -> Self {
        Self {
            width,
            height,
            x,
            y,
            radius_top_left,
            radius_top_right,
            radius_bottom_left,
            radius_bottom_right,
        }
    }

    fn tessellate_fill(&self, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode {
        unsafe { mem::transmute(crate::AzSvgRect_tessellateFill(
            mem::transmute(self),
            mem::transmute(fill_style),
        )) }
    }
    fn tessellate_stroke(&self, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode {
        unsafe { mem::transmute(crate::AzSvgRect_tessellateStroke(
            mem::transmute(self),
            mem::transmute(stroke_style),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgRect {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgVertex {
    #[new]
    fn __new__(x: f32, y: f32) -> Self {
        Self {
            x,
            y,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgVertex {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgVertex = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgVertex = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedSvgNode {
    #[staticmethod]
    fn empty() -> AzTessellatedSvgNode {
        unsafe { mem::transmute(crate::AzTessellatedSvgNode_empty()) }
    }
    #[staticmethod]
    fn from_nodes(nodes: AzTessellatedSvgNodeVecRef) -> AzTessellatedSvgNode {
        unsafe { mem::transmute(crate::AzTessellatedSvgNode_fromNodes(
            mem::transmute(nodes),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedSvgNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::TessellatedSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::TessellatedSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedSvgNodeVecRef {
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedSvgNodeVecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::TessellatedSvgNodeVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::TessellatedSvgNodeVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedGPUSvgNode {
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedGPUSvgNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::TessellatedGPUSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::TessellatedGPUSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgParseOptions {
    #[staticmethod]
    fn default() -> AzSvgParseOptions {
        unsafe { mem::transmute(crate::AzSvgParseOptions_default()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgParseOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgParseOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgParseOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapeRenderingEnumWrapper {
    #[classattr]
    fn OptimizeSpeed() -> AzShapeRenderingEnumWrapper { AzShapeRenderingEnumWrapper { inner: AzShapeRendering::OptimizeSpeed } }
    #[classattr]
    fn CrispEdges() -> AzShapeRenderingEnumWrapper { AzShapeRenderingEnumWrapper { inner: AzShapeRendering::CrispEdges } }
    #[classattr]
    fn GeometricPrecision() -> AzShapeRenderingEnumWrapper { AzShapeRenderingEnumWrapper { inner: AzShapeRendering::GeometricPrecision } }
}

#[pyproto]
impl PyObjectProtocol for AzShapeRenderingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::ShapeRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::ShapeRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzShapeRenderingEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzTextRenderingEnumWrapper {
    #[classattr]
    fn OptimizeSpeed() -> AzTextRenderingEnumWrapper { AzTextRenderingEnumWrapper { inner: AzTextRendering::OptimizeSpeed } }
    #[classattr]
    fn OptimizeLegibility() -> AzTextRenderingEnumWrapper { AzTextRenderingEnumWrapper { inner: AzTextRendering::OptimizeLegibility } }
    #[classattr]
    fn GeometricPrecision() -> AzTextRenderingEnumWrapper { AzTextRenderingEnumWrapper { inner: AzTextRendering::GeometricPrecision } }
}

#[pyproto]
impl PyObjectProtocol for AzTextRenderingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::TextRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::TextRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzTextRenderingEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzImageRenderingEnumWrapper {
    #[classattr]
    fn OptimizeQuality() -> AzImageRenderingEnumWrapper { AzImageRenderingEnumWrapper { inner: AzImageRendering::OptimizeQuality } }
    #[classattr]
    fn OptimizeSpeed() -> AzImageRenderingEnumWrapper { AzImageRenderingEnumWrapper { inner: AzImageRendering::OptimizeSpeed } }
}

#[pyproto]
impl PyObjectProtocol for AzImageRenderingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::ImageRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::ImageRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzImageRenderingEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzFontDatabaseEnumWrapper {
    #[classattr]
    fn Empty() -> AzFontDatabaseEnumWrapper { AzFontDatabaseEnumWrapper { inner: AzFontDatabase::Empty } }
    #[classattr]
    fn System() -> AzFontDatabaseEnumWrapper { AzFontDatabaseEnumWrapper { inner: AzFontDatabase::System } }
}

#[pyproto]
impl PyObjectProtocol for AzFontDatabaseEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::FontDatabase = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::FontDatabase = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzFontDatabaseEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSvgRenderOptions {
    #[staticmethod]
    fn default() -> AzSvgRenderOptions {
        unsafe { mem::transmute(crate::AzSvgRenderOptions_default()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgRenderOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgRenderOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgRenderOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgStringFormatOptions {
    #[new]
    fn __new__(use_single_quote: bool, indent: AzIndentEnumWrapper, attributes_indent: AzIndentEnumWrapper) -> Self {
        Self {
            use_single_quote,
            indent,
            attributes_indent,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgStringFormatOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgXmlOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgXmlOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIndentEnumWrapper {
    #[classattr]
    fn None() -> AzIndentEnumWrapper { AzIndentEnumWrapper { inner: AzIndent::None } }
    #[staticmethod]
    fn Spaces(v: u8) -> AzIndentEnumWrapper { AzIndentEnumWrapper { inner: AzIndent::Spaces(v) } }
    #[classattr]
    fn Tabs() -> AzIndentEnumWrapper { AzIndentEnumWrapper { inner: AzIndent::Tabs } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzIndent;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzIndent::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzIndent::Spaces(v) => Ok(vec!["Spaces".into_py(py), v.into_py(py)]),
            AzIndent::Tabs => Ok(vec!["Tabs".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIndentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::Indent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::Indent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgFitToEnumWrapper {
    #[classattr]
    fn Original() -> AzSvgFitToEnumWrapper { AzSvgFitToEnumWrapper { inner: AzSvgFitTo::Original } }
    #[staticmethod]
    fn Width(v: u32) -> AzSvgFitToEnumWrapper { AzSvgFitToEnumWrapper { inner: AzSvgFitTo::Width(v) } }
    #[staticmethod]
    fn Height(v: u32) -> AzSvgFitToEnumWrapper { AzSvgFitToEnumWrapper { inner: AzSvgFitTo::Height(v) } }
    #[staticmethod]
    fn Zoom(v: f32) -> AzSvgFitToEnumWrapper { AzSvgFitToEnumWrapper { inner: AzSvgFitTo::Zoom(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgFitTo;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgFitTo::Original => Ok(vec!["Original".into_py(py), ().into_py(py)]),
            AzSvgFitTo::Width(v) => Ok(vec!["Width".into_py(py), v.into_py(py)]),
            AzSvgFitTo::Height(v) => Ok(vec!["Height".into_py(py), v.into_py(py)]),
            AzSvgFitTo::Zoom(v) => Ok(vec!["Zoom".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgFitToEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgFitTo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgFitTo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgStyleEnumWrapper {
    #[staticmethod]
    fn Fill(v: AzSvgFillStyle) -> AzSvgStyleEnumWrapper { AzSvgStyleEnumWrapper { inner: AzSvgStyle::Fill(v) } }
    #[staticmethod]
    fn Stroke(v: AzSvgStrokeStyle) -> AzSvgStyleEnumWrapper { AzSvgStyleEnumWrapper { inner: AzSvgStyle::Stroke(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgStyle;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgStyle::Fill(v) => Ok(vec!["Fill".into_py(py), v.clone().into_py(py)]),
            AzSvgStyle::Stroke(v) => Ok(vec!["Stroke".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgStyleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgFillRuleEnumWrapper {
    #[classattr]
    fn Winding() -> AzSvgFillRuleEnumWrapper { AzSvgFillRuleEnumWrapper { inner: AzSvgFillRule::Winding } }
    #[classattr]
    fn EvenOdd() -> AzSvgFillRuleEnumWrapper { AzSvgFillRuleEnumWrapper { inner: AzSvgFillRule::EvenOdd } }
}

#[pyproto]
impl PyObjectProtocol for AzSvgFillRuleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgFillRule = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgFillRule = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzSvgFillRuleEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSvgTransform {
    #[new]
    fn __new__(sx: f32, kx: f32, ky: f32, sy: f32, tx: f32, ty: f32) -> Self {
        Self {
            sx,
            kx,
            ky,
            sy,
            tx,
            ty,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgTransform {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgTransform = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgTransform = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgFillStyle {
    #[staticmethod]
    fn default() -> AzSvgFillStyle {
        unsafe { mem::transmute(crate::AzSvgFillStyle_default()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgFillStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgFillStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgFillStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgStrokeStyle {
    #[staticmethod]
    fn default() -> AzSvgStrokeStyle {
        unsafe { mem::transmute(crate::AzSvgStrokeStyle_default()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgStrokeStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgStrokeStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgStrokeStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgLineJoinEnumWrapper {
    #[classattr]
    fn Miter() -> AzSvgLineJoinEnumWrapper { AzSvgLineJoinEnumWrapper { inner: AzSvgLineJoin::Miter } }
    #[classattr]
    fn MiterClip() -> AzSvgLineJoinEnumWrapper { AzSvgLineJoinEnumWrapper { inner: AzSvgLineJoin::MiterClip } }
    #[classattr]
    fn Round() -> AzSvgLineJoinEnumWrapper { AzSvgLineJoinEnumWrapper { inner: AzSvgLineJoin::Round } }
    #[classattr]
    fn Bevel() -> AzSvgLineJoinEnumWrapper { AzSvgLineJoinEnumWrapper { inner: AzSvgLineJoin::Bevel } }
}

#[pyproto]
impl PyObjectProtocol for AzSvgLineJoinEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgLineJoin = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgLineJoin = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzSvgLineJoinEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSvgLineCapEnumWrapper {
    #[classattr]
    fn Butt() -> AzSvgLineCapEnumWrapper { AzSvgLineCapEnumWrapper { inner: AzSvgLineCap::Butt } }
    #[classattr]
    fn Square() -> AzSvgLineCapEnumWrapper { AzSvgLineCapEnumWrapper { inner: AzSvgLineCap::Square } }
    #[classattr]
    fn Round() -> AzSvgLineCapEnumWrapper { AzSvgLineCapEnumWrapper { inner: AzSvgLineCap::Round } }
}

#[pyproto]
impl PyObjectProtocol for AzSvgLineCapEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgLineCap = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgLineCap = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzSvgLineCapEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSvgDashPattern {
    #[new]
    fn __new__(offset: f32, length_1: f32, gap_1: f32, length_2: f32, gap_2: f32, length_3: f32, gap_3: f32) -> Self {
        Self {
            offset,
            length_1,
            gap_1,
            length_2,
            gap_2,
            length_3,
            gap_3,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgDashPattern {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgDashPattern = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgDashPattern = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXml {
    #[staticmethod]
    fn from_str(xml_string: &str) -> Result<AzXml, PyErr> {
        let xml_string = pystring_to_refstr(&xml_string);
        let m: AzResultXmlXmlError = unsafe { mem::transmute(crate::AzXml_fromStr(
            mem::transmute(xml_string),
        )) };
        match m {
            AzResultXmlXmlError::Ok(o) => Ok(o.into()),
            AzResultXmlXmlError::Err(e) => Err(e.into()),
        }

    }
}

#[pyproto]
impl PyObjectProtocol for AzXml {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::Xml = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::Xml = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlNode {
    #[new]
    fn __new__(tag: AzString, attributes: AzStringPairVec, children: AzXmlNodeVec, text: AzOptionStringEnumWrapper) -> Self {
        Self {
            tag,
            attributes,
            children,
            text,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzXmlNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::XmlNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::XmlNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFile {
    #[staticmethod]
    fn open(path: String) -> Option<AzFile> {
        let path = pystring_to_azstring(&path);
        let m: AzOptionFile = unsafe { mem::transmute(crate::AzFile_open(
            mem::transmute(path),
        )) };
        match m {
            AzOptionFile::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionFile::None => None,
        }

    }
    #[staticmethod]
    fn create(path: String) -> Option<AzFile> {
        let path = pystring_to_azstring(&path);
        let m: AzOptionFile = unsafe { mem::transmute(crate::AzFile_create(
            mem::transmute(path),
        )) };
        match m {
            AzOptionFile::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionFile::None => None,
        }

    }
    fn read_to_string(&mut self) -> Option<String> {
        let m: AzOptionString = unsafe { mem::transmute(crate::AzFile_readToString(
            mem::transmute(self),
        )) };
        match m {
            AzOptionString::Some(s) => Some({ let s: AzString = unsafe { mem::transmute(s) }; s.into() }),
            AzOptionString::None => None,
        }

    }
    fn read_to_bytes(&mut self) -> Option<Vec<u8>> {
        let m: AzOptionU8Vec = unsafe { mem::transmute(crate::AzFile_readToBytes(
            mem::transmute(self),
        )) };
        match m {
            AzOptionU8Vec::Some(s) => Some({ let s: AzU8Vec = unsafe { mem::transmute(s) }; s.into() }),
            AzOptionU8Vec::None => None,
        }

    }
    fn write_string(&mut self, bytes: &str) -> bool {
        let bytes = pystring_to_refstr(&bytes);
        unsafe { mem::transmute(crate::AzFile_writeString(
            mem::transmute(self),
            mem::transmute(bytes),
        )) }
    }
    fn write_bytes(&mut self, bytes: Vec<u8>) -> bool {
        let bytes = pybytesref_to_vecu8_ref(&bytes);
        unsafe { mem::transmute(crate::AzFile_writeBytes(
            mem::transmute(self),
            mem::transmute(bytes),
        )) }
    }
    fn close(&mut self) -> () {
        unsafe { mem::transmute(crate::AzFile_close(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFile {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::file::File = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::file::File = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMsgBox {
    #[staticmethod]
    fn ok(icon: AzMsgBoxIconEnumWrapper, title: String, message: String) -> bool {
        let title = pystring_to_azstring(&title);
        let message = pystring_to_azstring(&message);
        unsafe { mem::transmute(crate::AzMsgBox_ok(
            mem::transmute(icon),
            mem::transmute(title),
            mem::transmute(message),
        )) }
    }
    #[staticmethod]
    fn info(message: String) -> bool {
        let message = pystring_to_azstring(&message);
        unsafe { mem::transmute(crate::AzMsgBox_info(
            mem::transmute(message),
        )) }
    }
    #[staticmethod]
    fn warning(message: String) -> bool {
        let message = pystring_to_azstring(&message);
        unsafe { mem::transmute(crate::AzMsgBox_warning(
            mem::transmute(message),
        )) }
    }
    #[staticmethod]
    fn error(message: String) -> bool {
        let message = pystring_to_azstring(&message);
        unsafe { mem::transmute(crate::AzMsgBox_error(
            mem::transmute(message),
        )) }
    }
    #[staticmethod]
    fn question(message: String) -> bool {
        let message = pystring_to_azstring(&message);
        unsafe { mem::transmute(crate::AzMsgBox_question(
            mem::transmute(message),
        )) }
    }
    #[staticmethod]
    fn ok_cancel(icon: AzMsgBoxIconEnumWrapper, title: String, message: String, default_value: AzMsgBoxOkCancelEnumWrapper) -> AzMsgBoxOkCancelEnumWrapper {
        let title = pystring_to_azstring(&title);
        let message = pystring_to_azstring(&message);
        unsafe { mem::transmute(crate::AzMsgBox_okCancel(
            mem::transmute(icon),
            mem::transmute(title),
            mem::transmute(message),
            mem::transmute(default_value),
        )) }
    }
    #[staticmethod]
    fn yes_no(icon: AzMsgBoxIconEnumWrapper, title: String, message: String, default_value: AzMsgBoxYesNoEnumWrapper) -> AzMsgBoxYesNoEnumWrapper {
        let title = pystring_to_azstring(&title);
        let message = pystring_to_azstring(&message);
        unsafe { mem::transmute(crate::AzMsgBox_yesNo(
            mem::transmute(icon),
            mem::transmute(title),
            mem::transmute(message),
            mem::transmute(default_value),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMsgBox {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dialogs::MsgBox = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dialogs::MsgBox = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMsgBoxIconEnumWrapper {
    #[classattr]
    fn Info() -> AzMsgBoxIconEnumWrapper { AzMsgBoxIconEnumWrapper { inner: AzMsgBoxIcon::Info } }
    #[classattr]
    fn Warning() -> AzMsgBoxIconEnumWrapper { AzMsgBoxIconEnumWrapper { inner: AzMsgBoxIcon::Warning } }
    #[classattr]
    fn Error() -> AzMsgBoxIconEnumWrapper { AzMsgBoxIconEnumWrapper { inner: AzMsgBoxIcon::Error } }
    #[classattr]
    fn Question() -> AzMsgBoxIconEnumWrapper { AzMsgBoxIconEnumWrapper { inner: AzMsgBoxIcon::Question } }
}

#[pyproto]
impl PyObjectProtocol for AzMsgBoxIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dialogs::MsgBoxIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dialogs::MsgBoxIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzMsgBoxIconEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzMsgBoxYesNoEnumWrapper {
    #[classattr]
    fn Yes() -> AzMsgBoxYesNoEnumWrapper { AzMsgBoxYesNoEnumWrapper { inner: AzMsgBoxYesNo::Yes } }
    #[classattr]
    fn No() -> AzMsgBoxYesNoEnumWrapper { AzMsgBoxYesNoEnumWrapper { inner: AzMsgBoxYesNo::No } }
}

#[pyproto]
impl PyObjectProtocol for AzMsgBoxYesNoEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dialogs::YesNo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dialogs::YesNo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzMsgBoxYesNoEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzMsgBoxOkCancelEnumWrapper {
    #[classattr]
    fn Ok() -> AzMsgBoxOkCancelEnumWrapper { AzMsgBoxOkCancelEnumWrapper { inner: AzMsgBoxOkCancel::Ok } }
    #[classattr]
    fn Cancel() -> AzMsgBoxOkCancelEnumWrapper { AzMsgBoxOkCancelEnumWrapper { inner: AzMsgBoxOkCancel::Cancel } }
}

#[pyproto]
impl PyObjectProtocol for AzMsgBoxOkCancelEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dialogs::OkCancel = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dialogs::OkCancel = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzMsgBoxOkCancelEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzFileDialog {
    #[staticmethod]
    fn select_file(title: String, default_path: AzOptionStringEnumWrapper, filter_list: AzOptionFileTypeListEnumWrapper) -> Option<String> {
        let title = pystring_to_azstring(&title);
        let m: AzOptionString = unsafe { mem::transmute(crate::AzFileDialog_selectFile(
            mem::transmute(title),
            mem::transmute(default_path),
            mem::transmute(filter_list),
        )) };
        match m {
            AzOptionString::Some(s) => Some({ let s: AzString = unsafe { mem::transmute(s) }; s.into() }),
            AzOptionString::None => None,
        }

    }
    #[staticmethod]
    fn select_multiple_files(title: String, default_path: AzOptionStringEnumWrapper, filter_list: AzOptionFileTypeListEnumWrapper) -> Option<AzStringVec> {
        let title = pystring_to_azstring(&title);
        let m: AzOptionStringVec = unsafe { mem::transmute(crate::AzFileDialog_selectMultipleFiles(
            mem::transmute(title),
            mem::transmute(default_path),
            mem::transmute(filter_list),
        )) };
        match m {
            AzOptionStringVec::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionStringVec::None => None,
        }

    }
    #[staticmethod]
    fn select_folder(title: String, default_path: AzOptionStringEnumWrapper) -> Option<String> {
        let title = pystring_to_azstring(&title);
        let m: AzOptionString = unsafe { mem::transmute(crate::AzFileDialog_selectFolder(
            mem::transmute(title),
            mem::transmute(default_path),
        )) };
        match m {
            AzOptionString::Some(s) => Some({ let s: AzString = unsafe { mem::transmute(s) }; s.into() }),
            AzOptionString::None => None,
        }

    }
    #[staticmethod]
    fn save_file(title: String, default_path: AzOptionStringEnumWrapper) -> Option<String> {
        let title = pystring_to_azstring(&title);
        let m: AzOptionString = unsafe { mem::transmute(crate::AzFileDialog_saveFile(
            mem::transmute(title),
            mem::transmute(default_path),
        )) };
        match m {
            AzOptionString::Some(s) => Some({ let s: AzString = unsafe { mem::transmute(s) }; s.into() }),
            AzOptionString::None => None,
        }

    }
}

#[pyproto]
impl PyObjectProtocol for AzFileDialog {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dialogs::FileDialog = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dialogs::FileDialog = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileTypeList {
    #[new]
    fn __new__(document_types: AzStringVec, document_descriptor: AzString) -> Self {
        Self {
            document_types,
            document_descriptor,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzFileTypeList {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dialogs::FileTypeList = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dialogs::FileTypeList = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorPickerDialog {
    #[staticmethod]
    fn open(title: String, default_color: AzOptionColorUEnumWrapper) -> Option<AzColorU> {
        let title = pystring_to_azstring(&title);
        let m: AzOptionColorU = unsafe { mem::transmute(crate::AzColorPickerDialog_open(
            mem::transmute(title),
            mem::transmute(default_color),
        )) };
        match m {
            AzOptionColorU::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionColorU::None => None,
        }

    }
}

#[pyproto]
impl PyObjectProtocol for AzColorPickerDialog {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dialogs::ColorPickerDialog = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dialogs::ColorPickerDialog = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemClipboard {
    #[staticmethod]
    fn new() -> Option<AzSystemClipboard> {
        let m: AzOptionSystemClipboard = unsafe { mem::transmute(crate::AzSystemClipboard_new()) };
        match m {
            AzOptionSystemClipboard::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionSystemClipboard::None => None,
        }

    }
    fn get_string_contents(&self) -> Option<String> {
        let m: AzOptionString = unsafe { mem::transmute(crate::AzSystemClipboard_getStringContents(
            mem::transmute(self),
        )) };
        match m {
            AzOptionString::Some(s) => Some({ let s: AzString = unsafe { mem::transmute(s) }; s.into() }),
            AzOptionString::None => None,
        }

    }
    fn set_string_contents(&mut self, contents: String) -> bool {
        let contents = pystring_to_azstring(&contents);
        unsafe { mem::transmute(crate::AzSystemClipboard_setStringContents(
            mem::transmute(self),
            mem::transmute(contents),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSystemClipboard {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::app::Clipboard = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::app::Clipboard = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInstantEnumWrapper {
    #[staticmethod]
    fn System(v: AzInstantPtr) -> AzInstantEnumWrapper { AzInstantEnumWrapper { inner: AzInstant::System(v) } }
    #[staticmethod]
    fn Tick(v: AzSystemTick) -> AzInstantEnumWrapper { AzInstantEnumWrapper { inner: AzInstant::Tick(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInstant;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInstant::System(v) => Ok(vec!["System".into_py(py), v.clone().into_py(py)]),
            AzInstant::Tick(v) => Ok(vec!["Tick".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInstantEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::Instant = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::Instant = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInstantPtr {
}

#[pyproto]
impl PyObjectProtocol for AzInstantPtr {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::AzInstantPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::AzInstantPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInstantPtrCloneFn {
}

#[pyproto]
impl PyObjectProtocol for AzInstantPtrCloneFn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::InstantPtrCloneCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::InstantPtrCloneCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInstantPtrDestructorFn {
}

#[pyproto]
impl PyObjectProtocol for AzInstantPtrDestructorFn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::InstantPtrDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::InstantPtrDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemTick {
    #[new]
    fn __new__(tick_counter: u64) -> Self {
        Self {
            tick_counter,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSystemTick {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::SystemTick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::SystemTick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDurationEnumWrapper {
    #[staticmethod]
    fn System(v: AzSystemTimeDiff) -> AzDurationEnumWrapper { AzDurationEnumWrapper { inner: AzDuration::System(v) } }
    #[staticmethod]
    fn Tick(v: AzSystemTickDiff) -> AzDurationEnumWrapper { AzDurationEnumWrapper { inner: AzDuration::Tick(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzDuration;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzDuration::System(v) => Ok(vec!["System".into_py(py), v.clone().into_py(py)]),
            AzDuration::Tick(v) => Ok(vec!["Tick".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDurationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::Duration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::Duration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemTimeDiff {
    #[new]
    fn __new__(secs: u64, nanos: u32) -> Self {
        Self {
            secs,
            nanos,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSystemTimeDiff {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::SystemTimeDiff = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::SystemTimeDiff = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemTickDiff {
    #[new]
    fn __new__(tick_diff: u64) -> Self {
        Self {
            tick_diff,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSystemTickDiff {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::SystemTickDiff = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::SystemTickDiff = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTimerId {
    #[new]
    fn __new__(id: usize) -> Self {
        Self {
            id,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzTimerId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::TimerId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::TimerId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTimer {
    fn with_delay(&self, delay: AzDurationEnumWrapper) -> AzTimer {
        unsafe { mem::transmute(crate::AzTimer_withDelay(
            mem::transmute(self),
            mem::transmute(delay),
        )) }
    }
    fn with_interval(&self, interval: AzDurationEnumWrapper) -> AzTimer {
        unsafe { mem::transmute(crate::AzTimer_withInterval(
            mem::transmute(self),
            mem::transmute(interval),
        )) }
    }
    fn with_timeout(&self, timeout: AzDurationEnumWrapper) -> AzTimer {
        unsafe { mem::transmute(crate::AzTimer_withTimeout(
            mem::transmute(self),
            mem::transmute(timeout),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTimer {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::Timer = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::Timer = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTerminateTimerEnumWrapper {
    #[classattr]
    fn Terminate() -> AzTerminateTimerEnumWrapper { AzTerminateTimerEnumWrapper { inner: AzTerminateTimer::Terminate } }
    #[classattr]
    fn Continue() -> AzTerminateTimerEnumWrapper { AzTerminateTimerEnumWrapper { inner: AzTerminateTimer::Continue } }
}

#[pyproto]
impl PyObjectProtocol for AzTerminateTimerEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::TerminateTimer = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::TerminateTimer = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzTerminateTimerEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzThreadId {
    #[new]
    fn __new__(id: usize) -> Self {
        Self {
            id,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzThreadId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThread {
}

#[pyproto]
impl PyObjectProtocol for AzThread {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::Thread = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::Thread = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadSender {
    fn send(&mut self, msg: AzThreadReceiveMsgEnumWrapper) -> bool {
        unsafe { mem::transmute(crate::AzThreadSender_send(
            mem::transmute(self),
            mem::transmute(msg),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzThreadSender {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadSender = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadSender = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadReceiver {
    fn receive(&mut self) -> Option<AzThreadSendMsgEnumWrapper> {
        let m: AzOptionThreadSendMsg = unsafe { mem::transmute(crate::AzThreadReceiver_receive(
            mem::transmute(self),
        )) };
        match m {
            AzOptionThreadSendMsg::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionThreadSendMsg::None => None,
        }

    }
}

#[pyproto]
impl PyObjectProtocol for AzThreadReceiver {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadReceiver = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadReceiver = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadSendMsgEnumWrapper {
    #[classattr]
    fn TerminateThread() -> AzThreadSendMsgEnumWrapper { AzThreadSendMsgEnumWrapper { inner: AzThreadSendMsg::TerminateThread } }
    #[classattr]
    fn Tick() -> AzThreadSendMsgEnumWrapper { AzThreadSendMsgEnumWrapper { inner: AzThreadSendMsg::Tick } }
    #[staticmethod]
    fn Custom(v: AzRefAny) -> AzThreadSendMsgEnumWrapper { AzThreadSendMsgEnumWrapper { inner: AzThreadSendMsg::Custom(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzThreadSendMsg;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzThreadSendMsg::TerminateThread => Ok(vec!["TerminateThread".into_py(py), ().into_py(py)]),
            AzThreadSendMsg::Tick => Ok(vec!["Tick".into_py(py), ().into_py(py)]),
            AzThreadSendMsg::Custom(v) => Ok(vec!["Custom".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzThreadSendMsgEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadSendMsg = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadSendMsg = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadReceiveMsgEnumWrapper {
    #[staticmethod]
    fn WriteBack(v: AzThreadWriteBackMsg) -> AzThreadReceiveMsgEnumWrapper { AzThreadReceiveMsgEnumWrapper { inner: AzThreadReceiveMsg::WriteBack(v) } }
    #[staticmethod]
    fn Update(v: AzUpdateEnumWrapper) -> AzThreadReceiveMsgEnumWrapper { AzThreadReceiveMsgEnumWrapper { inner: AzThreadReceiveMsg::Update(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzThreadReceiveMsg;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzThreadReceiveMsg::WriteBack(v) => Ok(vec!["WriteBack".into_py(py), v.clone().into_py(py)]),
            AzThreadReceiveMsg::Update(v) => Ok(vec!["Update".into_py(py), { let m: &AzUpdateEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzThreadReceiveMsgEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadReceiveMsg = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadReceiveMsg = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadWriteBackMsg {
    #[new]
    fn __new__(data: AzRefAny, callback: AzWriteBackCallback) -> Self {
        Self {
            data,
            callback,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzThreadWriteBackMsg {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadWriteBackMsg = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadWriteBackMsg = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCreateThreadFn {
}

#[pyproto]
impl PyObjectProtocol for AzCreateThreadFn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::CreateThreadCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::CreateThreadCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGetSystemTimeFn {
}

#[pyproto]
impl PyObjectProtocol for AzGetSystemTimeFn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::GetSystemTimeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::GetSystemTimeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckThreadFinishedFn {
}

#[pyproto]
impl PyObjectProtocol for AzCheckThreadFinishedFn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::CheckThreadFinishedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::CheckThreadFinishedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLibrarySendThreadMsgFn {
}

#[pyproto]
impl PyObjectProtocol for AzLibrarySendThreadMsgFn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::LibrarySendThreadMsgCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::LibrarySendThreadMsgCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLibraryReceiveThreadMsgFn {
}

#[pyproto]
impl PyObjectProtocol for AzLibraryReceiveThreadMsgFn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::LibraryReceiveThreadMsgCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::LibraryReceiveThreadMsgCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadRecvFn {
}

#[pyproto]
impl PyObjectProtocol for AzThreadRecvFn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadRecvCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadRecvCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadSendFn {
}

#[pyproto]
impl PyObjectProtocol for AzThreadSendFn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadSendCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadSendCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadDestructorFn {
}

#[pyproto]
impl PyObjectProtocol for AzThreadDestructorFn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadReceiverDestructorFn {
}

#[pyproto]
impl PyObjectProtocol for AzThreadReceiverDestructorFn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadReceiverDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadReceiverDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadSenderDestructorFn {
}

#[pyproto]
impl PyObjectProtocol for AzThreadSenderDestructorFn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadSenderDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::ThreadSenderDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFmtValueEnumWrapper {
    #[staticmethod]
    fn Bool(v: bool) -> AzFmtValueEnumWrapper { AzFmtValueEnumWrapper { inner: AzFmtValue::Bool(v) } }
    #[staticmethod]
    fn Uchar(v: u8) -> AzFmtValueEnumWrapper { AzFmtValueEnumWrapper { inner: AzFmtValue::Uchar(v) } }
    #[staticmethod]
    fn Schar(v: i8) -> AzFmtValueEnumWrapper { AzFmtValueEnumWrapper { inner: AzFmtValue::Schar(v) } }
    #[staticmethod]
    fn Ushort(v: u16) -> AzFmtValueEnumWrapper { AzFmtValueEnumWrapper { inner: AzFmtValue::Ushort(v) } }
    #[staticmethod]
    fn Sshort(v: i16) -> AzFmtValueEnumWrapper { AzFmtValueEnumWrapper { inner: AzFmtValue::Sshort(v) } }
    #[staticmethod]
    fn Uint(v: u32) -> AzFmtValueEnumWrapper { AzFmtValueEnumWrapper { inner: AzFmtValue::Uint(v) } }
    #[staticmethod]
    fn Sint(v: i32) -> AzFmtValueEnumWrapper { AzFmtValueEnumWrapper { inner: AzFmtValue::Sint(v) } }
    #[staticmethod]
    fn Ulong(v: u64) -> AzFmtValueEnumWrapper { AzFmtValueEnumWrapper { inner: AzFmtValue::Ulong(v) } }
    #[staticmethod]
    fn Slong(v: i64) -> AzFmtValueEnumWrapper { AzFmtValueEnumWrapper { inner: AzFmtValue::Slong(v) } }
    #[staticmethod]
    fn Isize(v: isize) -> AzFmtValueEnumWrapper { AzFmtValueEnumWrapper { inner: AzFmtValue::Isize(v) } }
    #[staticmethod]
    fn Usize(v: usize) -> AzFmtValueEnumWrapper { AzFmtValueEnumWrapper { inner: AzFmtValue::Usize(v) } }
    #[staticmethod]
    fn Float(v: f32) -> AzFmtValueEnumWrapper { AzFmtValueEnumWrapper { inner: AzFmtValue::Float(v) } }
    #[staticmethod]
    fn Double(v: f64) -> AzFmtValueEnumWrapper { AzFmtValueEnumWrapper { inner: AzFmtValue::Double(v) } }
    #[staticmethod]
    fn Str(v: AzString) -> AzFmtValueEnumWrapper { AzFmtValueEnumWrapper { inner: AzFmtValue::Str(v) } }
    #[staticmethod]
    fn StrVec(v: AzStringVec) -> AzFmtValueEnumWrapper { AzFmtValueEnumWrapper { inner: AzFmtValue::StrVec(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzFmtValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzFmtValue::Bool(v) => Ok(vec!["Bool".into_py(py), v.into_py(py)]),
            AzFmtValue::Uchar(v) => Ok(vec!["Uchar".into_py(py), v.into_py(py)]),
            AzFmtValue::Schar(v) => Ok(vec!["Schar".into_py(py), v.into_py(py)]),
            AzFmtValue::Ushort(v) => Ok(vec!["Ushort".into_py(py), v.into_py(py)]),
            AzFmtValue::Sshort(v) => Ok(vec!["Sshort".into_py(py), v.into_py(py)]),
            AzFmtValue::Uint(v) => Ok(vec!["Uint".into_py(py), v.into_py(py)]),
            AzFmtValue::Sint(v) => Ok(vec!["Sint".into_py(py), v.into_py(py)]),
            AzFmtValue::Ulong(v) => Ok(vec!["Ulong".into_py(py), v.into_py(py)]),
            AzFmtValue::Slong(v) => Ok(vec!["Slong".into_py(py), v.into_py(py)]),
            AzFmtValue::Isize(v) => Ok(vec!["Isize".into_py(py), v.into_py(py)]),
            AzFmtValue::Usize(v) => Ok(vec!["Usize".into_py(py), v.into_py(py)]),
            AzFmtValue::Float(v) => Ok(vec!["Float".into_py(py), v.into_py(py)]),
            AzFmtValue::Double(v) => Ok(vec!["Double".into_py(py), v.into_py(py)]),
            AzFmtValue::Str(v) => Ok(vec!["Str".into_py(py), v.clone().into_py(py)]),
            AzFmtValue::StrVec(v) => Ok(vec!["StrVec".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFmtValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::str::FmtValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::str::FmtValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFmtArg {
    #[new]
    fn __new__(key: AzString, value: AzFmtValueEnumWrapper) -> Self {
        Self {
            key,
            value,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzFmtArg {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::str::FmtArg = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::str::FmtArg = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzString {
    #[staticmethod]
    fn format(format: String, args: AzFmtArgVec) -> AzString {
        let format = pystring_to_azstring(&format);
        unsafe { mem::transmute(crate::AzString_format(
            mem::transmute(format),
            mem::transmute(args),
        )) }
    }
    fn trim(&self) -> String {
        az_string_to_py_string(unsafe { mem::transmute(crate::AzString_trim(
            mem::transmute(self),
        )) })
    }
}

#[pyproto]
impl PyObjectProtocol for AzString {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::AzString = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::AzString = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalRectVec {
    /// Creates a new `LogicalRectVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzLogicalRect>) -> Self {
        let m: azul_core::window::LogicalRectVec = azul_core::window::LogicalRectVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the LogicalRect as a Python array
    fn array(&self) -> Vec<AzLogicalRect> {
        let m: &azul_core::window::LogicalRectVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzLogicalRectVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LogicalRectVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LogicalRectVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeIdInfoMapVec {
    /// Creates a new `NodeTypeIdInfoMapVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNodeTypeIdInfoMap>) -> Self {
        let m: crate::widgets::node_graph::NodeTypeIdInfoMapVec = crate::widgets::node_graph::NodeTypeIdInfoMapVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the NodeTypeIdInfoMap as a Python array
    fn array(&self) -> Vec<AzNodeTypeIdInfoMap> {
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMapVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeIdInfoMapVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMapVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMapVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeIdInfoMapVec {
    /// Creates a new `InputOutputTypeIdInfoMapVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzInputOutputTypeIdInfoMap>) -> Self {
        let m: crate::widgets::node_graph::InputOutputTypeIdInfoMapVec = crate::widgets::node_graph::InputOutputTypeIdInfoMapVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the InputOutputTypeIdInfoMap as a Python array
    fn array(&self) -> Vec<AzInputOutputTypeIdInfoMap> {
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeIdInfoMapVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdNodeMapVec {
    /// Creates a new `NodeIdNodeMapVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNodeIdNodeMap>) -> Self {
        let m: crate::widgets::node_graph::NodeIdNodeMapVec = crate::widgets::node_graph::NodeIdNodeMapVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the NodeIdNodeMap as a Python array
    fn array(&self) -> Vec<AzNodeIdNodeMap> {
        let m: &crate::widgets::node_graph::NodeIdNodeMapVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeIdNodeMapVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeIdNodeMapVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeIdNodeMapVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeIdVec {
    /// Creates a new `InputOutputTypeIdVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzInputOutputTypeId>) -> Self {
        let m: crate::widgets::node_graph::InputOutputTypeIdVec = crate::widgets::node_graph::InputOutputTypeIdVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the InputOutputTypeId as a Python array
    fn array(&self) -> Vec<AzInputOutputTypeId> {
        let m: &crate::widgets::node_graph::InputOutputTypeIdVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeIdVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeFieldVec {
    /// Creates a new `NodeTypeFieldVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNodeTypeField>) -> Self {
        let m: crate::widgets::node_graph::NodeTypeFieldVec = crate::widgets::node_graph::NodeTypeFieldVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the NodeTypeField as a Python array
    fn array(&self) -> Vec<AzNodeTypeField> {
        let m: &crate::widgets::node_graph::NodeTypeFieldVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeFieldVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeFieldVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeFieldVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputConnectionVec {
    /// Creates a new `InputConnectionVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzInputConnection>) -> Self {
        let m: crate::widgets::node_graph::InputConnectionVec = crate::widgets::node_graph::InputConnectionVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the InputConnection as a Python array
    fn array(&self) -> Vec<AzInputConnection> {
        let m: &crate::widgets::node_graph::InputConnectionVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInputConnectionVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputConnectionVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputConnectionVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputNodeAndIndexVec {
    /// Creates a new `OutputNodeAndIndexVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzOutputNodeAndIndex>) -> Self {
        let m: crate::widgets::node_graph::OutputNodeAndIndexVec = crate::widgets::node_graph::OutputNodeAndIndexVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the OutputNodeAndIndex as a Python array
    fn array(&self) -> Vec<AzOutputNodeAndIndex> {
        let m: &crate::widgets::node_graph::OutputNodeAndIndexVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzOutputNodeAndIndexVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputNodeAndIndexVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputNodeAndIndexVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputConnectionVec {
    /// Creates a new `OutputConnectionVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzOutputConnection>) -> Self {
        let m: crate::widgets::node_graph::OutputConnectionVec = crate::widgets::node_graph::OutputConnectionVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the OutputConnection as a Python array
    fn array(&self) -> Vec<AzOutputConnection> {
        let m: &crate::widgets::node_graph::OutputConnectionVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzOutputConnectionVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputConnectionVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputConnectionVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputNodeAndIndexVec {
    /// Creates a new `InputNodeAndIndexVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzInputNodeAndIndex>) -> Self {
        let m: crate::widgets::node_graph::InputNodeAndIndexVec = crate::widgets::node_graph::InputNodeAndIndexVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the InputNodeAndIndex as a Python array
    fn array(&self) -> Vec<AzInputNodeAndIndex> {
        let m: &crate::widgets::node_graph::InputNodeAndIndexVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInputNodeAndIndexVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputNodeAndIndexVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputNodeAndIndexVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabVec {
    /// Creates a new `TabVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzTab>) -> Self {
        let m: crate::widgets::tabs::TabVec = crate::widgets::tabs::TabVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the Tab as a Python array
    fn array(&self) -> Vec<AzTab> {
        let m: &crate::widgets::tabs::TabVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzTabVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::tabs::TabVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::tabs::TabVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAccessibilityStateVec {
    /// Creates a new `AccessibilityStateEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzAccessibilityStateEnumWrapper>) -> Self {
        let m: azul_impl::dom::AccessibilityStateVec = azul_impl::dom::AccessibilityStateVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the AccessibilityStateEnumWrapper as a Python array
    fn array(&self) -> Vec<AzAccessibilityStateEnumWrapper> {
        let m: &azul_impl::dom::AccessibilityStateVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityStateVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::AccessibilityStateVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::AccessibilityStateVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuItemVec {
    /// Creates a new `MenuItemEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzMenuItemEnumWrapper>) -> Self {
        let m: azul_core::window::MenuItemVec = azul_core::window::MenuItemVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the MenuItemEnumWrapper as a Python array
    fn array(&self) -> Vec<AzMenuItemEnumWrapper> {
        let m: &azul_core::window::MenuItemVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzMenuItemVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MenuItemVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MenuItemVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedSvgNodeVec {
    /// Creates a new `TessellatedSvgNodeVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzTessellatedSvgNode>) -> Self {
        let m: azul_impl::svg::TessellatedSvgNodeVec = azul_impl::svg::TessellatedSvgNodeVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the TessellatedSvgNode as a Python array
    fn array(&self) -> Vec<AzTessellatedSvgNode> {
        let m: &azul_impl::svg::TessellatedSvgNodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

    fn as_ref_vec(&self) -> AzTessellatedSvgNodeVecRef {
        unsafe { mem::transmute(crate::AzTessellatedSvgNodeVec_asRefVec(
            mem::transmute(self),
        )) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedSvgNodeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::TessellatedSvgNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::TessellatedSvgNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontFamilyVec {
    /// Creates a new `StyleFontFamilyEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStyleFontFamilyEnumWrapper>) -> Self {
        let m: azul_impl::css::StyleFontFamilyVec = azul_impl::css::StyleFontFamilyVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the StyleFontFamilyEnumWrapper as a Python array
    fn array(&self) -> Vec<AzStyleFontFamilyEnumWrapper> {
        let m: &azul_impl::css::StyleFontFamilyVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleFontFamilyVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleFontFamilyVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleFontFamilyVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlNodeVec {
    /// Creates a new `XmlNodeVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzXmlNode>) -> Self {
        let m: azul_impl::xml::XmlNodeVec = azul_impl::xml::XmlNodeVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the XmlNode as a Python array
    fn array(&self) -> Vec<AzXmlNode> {
        let m: &azul_impl::xml::XmlNodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzXmlNodeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::XmlNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::XmlNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFmtArgVec {
    /// Creates a new `FmtArgVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzFmtArg>) -> Self {
        let m: azul_impl::str::FmtArgVec = azul_impl::str::FmtArgVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the FmtArg as a Python array
    fn array(&self) -> Vec<AzFmtArg> {
        let m: &azul_impl::str::FmtArgVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzFmtArgVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::str::FmtArgVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::str::FmtArgVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineLineVec {
    /// Creates a new `InlineLineVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzInlineLine>) -> Self {
        let m: azul_impl::callbacks::InlineLineVec = azul_impl::callbacks::InlineLineVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the InlineLine as a Python array
    fn array(&self) -> Vec<AzInlineLine> {
        let m: &azul_impl::callbacks::InlineLineVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInlineLineVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineLineVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineLineVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineWordVec {
    /// Creates a new `InlineWordEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzInlineWordEnumWrapper>) -> Self {
        let m: azul_impl::callbacks::InlineWordVec = azul_impl::callbacks::InlineWordVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the InlineWordEnumWrapper as a Python array
    fn array(&self) -> Vec<AzInlineWordEnumWrapper> {
        let m: &azul_impl::callbacks::InlineWordVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInlineWordVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineWordVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineWordVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineGlyphVec {
    /// Creates a new `InlineGlyphVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzInlineGlyph>) -> Self {
        let m: azul_impl::callbacks::InlineGlyphVec = azul_impl::callbacks::InlineGlyphVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the InlineGlyph as a Python array
    fn array(&self) -> Vec<AzInlineGlyph> {
        let m: &azul_impl::callbacks::InlineGlyphVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInlineGlyphVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineGlyphVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineGlyphVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineTextHitVec {
    /// Creates a new `InlineTextHitVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzInlineTextHit>) -> Self {
        let m: azul_impl::callbacks::InlineTextHitVec = azul_impl::callbacks::InlineTextHitVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the InlineTextHit as a Python array
    fn array(&self) -> Vec<AzInlineTextHit> {
        let m: &azul_impl::callbacks::InlineTextHitVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInlineTextHitVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineTextHitVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineTextHitVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMonitorVec {
    /// Creates a new `MonitorVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzMonitor>) -> Self {
        let m: azul_core::window::MonitorVec = azul_core::window::MonitorVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the Monitor as a Python array
    fn array(&self) -> Vec<AzMonitor> {
        let m: &azul_core::window::MonitorVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzMonitorVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MonitorVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MonitorVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVideoModeVec {
    /// Creates a new `VideoModeVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzVideoMode>) -> Self {
        let m: azul_core::window::VideoModeVec = azul_core::window::VideoModeVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the VideoMode as a Python array
    fn array(&self) -> Vec<AzVideoMode> {
        let m: &azul_core::window::VideoModeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzVideoModeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoModeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoModeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomVec {
    /// Creates a new `DomVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzDom>) -> Self {
        let m: azul_impl::dom::DomVec = azul_impl::dom::DomVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the Dom as a Python array
    fn array(&self) -> Vec<AzDom> {
        let m: &azul_impl::dom::DomVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzDomVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::DomVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::DomVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIdOrClassVec {
    /// Creates a new `IdOrClassEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzIdOrClassEnumWrapper>) -> Self {
        let m: azul_impl::dom::IdOrClassVec = azul_impl::dom::IdOrClassVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the IdOrClassEnumWrapper as a Python array
    fn array(&self) -> Vec<AzIdOrClassEnumWrapper> {
        let m: &azul_impl::dom::IdOrClassVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzIdOrClassVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::IdOrClassVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::IdOrClassVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataInlineCssPropertyVec {
    /// Creates a new `NodeDataInlineCssPropertyEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNodeDataInlineCssPropertyEnumWrapper>) -> Self {
        let m: azul_impl::dom::NodeDataInlineCssPropertyVec = azul_impl::dom::NodeDataInlineCssPropertyVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the NodeDataInlineCssPropertyEnumWrapper as a Python array
    fn array(&self) -> Vec<AzNodeDataInlineCssPropertyEnumWrapper> {
        let m: &azul_impl::dom::NodeDataInlineCssPropertyVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeDataInlineCssPropertyVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::NodeDataInlineCssPropertyVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::NodeDataInlineCssPropertyVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundContentVec {
    /// Creates a new `StyleBackgroundContentEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStyleBackgroundContentEnumWrapper>) -> Self {
        let m: azul_impl::css::StyleBackgroundContentVec = azul_impl::css::StyleBackgroundContentVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the StyleBackgroundContentEnumWrapper as a Python array
    fn array(&self) -> Vec<AzStyleBackgroundContentEnumWrapper> {
        let m: &azul_impl::css::StyleBackgroundContentVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundContentVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundContentVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundContentVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundPositionVec {
    /// Creates a new `StyleBackgroundPositionVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStyleBackgroundPosition>) -> Self {
        let m: azul_impl::css::StyleBackgroundPositionVec = azul_impl::css::StyleBackgroundPositionVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the StyleBackgroundPosition as a Python array
    fn array(&self) -> Vec<AzStyleBackgroundPosition> {
        let m: &azul_impl::css::StyleBackgroundPositionVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundPositionVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundPositionVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundPositionVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundRepeatVec {
    /// Creates a new `StyleBackgroundRepeatEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStyleBackgroundRepeatEnumWrapper>) -> Self {
        let m: azul_impl::css::StyleBackgroundRepeatVec = azul_impl::css::StyleBackgroundRepeatVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the StyleBackgroundRepeatEnumWrapper as a Python array
    fn array(&self) -> Vec<AzStyleBackgroundRepeatEnumWrapper> {
        let m: &azul_impl::css::StyleBackgroundRepeatVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundRepeatVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundRepeatVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundRepeatVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundSizeVec {
    /// Creates a new `StyleBackgroundSizeEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStyleBackgroundSizeEnumWrapper>) -> Self {
        let m: azul_impl::css::StyleBackgroundSizeVec = azul_impl::css::StyleBackgroundSizeVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the StyleBackgroundSizeEnumWrapper as a Python array
    fn array(&self) -> Vec<AzStyleBackgroundSizeEnumWrapper> {
        let m: &azul_impl::css::StyleBackgroundSizeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundSizeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundSizeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundSizeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformVec {
    /// Creates a new `StyleTransformEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStyleTransformEnumWrapper>) -> Self {
        let m: azul_impl::css::StyleTransformVec = azul_impl::css::StyleTransformVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the StyleTransformEnumWrapper as a Python array
    fn array(&self) -> Vec<AzStyleTransformEnumWrapper> {
        let m: &azul_impl::css::StyleTransformVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyVec {
    /// Creates a new `CssPropertyEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzCssPropertyEnumWrapper>) -> Self {
        let m: azul_impl::css::CssPropertyVec = azul_impl::css::CssPropertyVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the CssPropertyEnumWrapper as a Python array
    fn array(&self) -> Vec<AzCssPropertyEnumWrapper> {
        let m: &azul_impl::css::CssPropertyVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssPropertyVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssPropertyVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgMultiPolygonVec {
    /// Creates a new `SvgMultiPolygonVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzSvgMultiPolygon>) -> Self {
        let m: azul_impl::svg::SvgMultiPolygonVec = azul_impl::svg::SvgMultiPolygonVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the SvgMultiPolygon as a Python array
    fn array(&self) -> Vec<AzSvgMultiPolygon> {
        let m: &azul_impl::svg::SvgMultiPolygonVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgMultiPolygonVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgMultiPolygonVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgMultiPolygonVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathVec {
    /// Creates a new `SvgPathVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzSvgPath>) -> Self {
        let m: azul_impl::svg::SvgPathVec = azul_impl::svg::SvgPathVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the SvgPath as a Python array
    fn array(&self) -> Vec<AzSvgPath> {
        let m: &azul_impl::svg::SvgPathVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgPathVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgPathVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgPathVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexAttributeVec {
    /// Creates a new `VertexAttributeVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzVertexAttribute>) -> Self {
        let m: azul_impl::gl::VertexAttributeVec = azul_impl::gl::VertexAttributeVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the VertexAttribute as a Python array
    fn array(&self) -> Vec<AzVertexAttribute> {
        let m: &azul_impl::gl::VertexAttributeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzVertexAttributeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::VertexAttributeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::VertexAttributeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathElementVec {
    /// Creates a new `SvgPathElementEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzSvgPathElementEnumWrapper>) -> Self {
        let m: azul_impl::svg::SvgPathElementVec = azul_impl::svg::SvgPathElementVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the SvgPathElementEnumWrapper as a Python array
    fn array(&self) -> Vec<AzSvgPathElementEnumWrapper> {
        let m: &azul_impl::svg::SvgPathElementVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgPathElementVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgPathElementVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgPathElementVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgVertexVec {
    /// Creates a new `SvgVertexVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzSvgVertex>) -> Self {
        let m: azul_impl::svg::SvgVertexVec = azul_impl::svg::SvgVertexVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the SvgVertex as a Python array
    fn array(&self) -> Vec<AzSvgVertex> {
        let m: &azul_impl::svg::SvgVertexVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgVertexVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgVertexVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgVertexVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU32Vec {
    /// Creates a new `U32Vec` from a Python array
    #[new]
    fn __new__(input: Vec<AzU32>) -> Self {
        let m: azul_impl::css::U32Vec = azul_impl::css::U32Vec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the U32 as a Python array
    fn array(&self) -> Vec<AzU32> {
        let m: &azul_impl::css::U32Vec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzU32Vec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::U32Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::U32Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXWindowTypeVec {
    /// Creates a new `XWindowTypeEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzXWindowTypeEnumWrapper>) -> Self {
        let m: azul_core::window::XWindowTypeVec = azul_core::window::XWindowTypeVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the XWindowTypeEnumWrapper as a Python array
    fn array(&self) -> Vec<AzXWindowTypeEnumWrapper> {
        let m: &azul_core::window::XWindowTypeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzXWindowTypeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowTypeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowTypeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVirtualKeyCodeVec {
    /// Creates a new `VirtualKeyCodeEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzVirtualKeyCodeEnumWrapper>) -> Self {
        let m: azul_core::window::VirtualKeyCodeVec = azul_core::window::VirtualKeyCodeVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the VirtualKeyCodeEnumWrapper as a Python array
    fn array(&self) -> Vec<AzVirtualKeyCodeEnumWrapper> {
        let m: &azul_core::window::VirtualKeyCodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzVirtualKeyCodeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCascadeInfoVec {
    /// Creates a new `CascadeInfoVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzCascadeInfo>) -> Self {
        let m: azul_impl::style::CascadeInfoVec = azul_impl::style::CascadeInfoVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the CascadeInfo as a Python array
    fn array(&self) -> Vec<AzCascadeInfo> {
        let m: &azul_impl::style::CascadeInfoVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzCascadeInfoVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::style::CascadeInfoVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::style::CascadeInfoVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScanCodeVec {
    /// Creates a new `ScanCodeVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzScanCode>) -> Self {
        let m: azul_core::window::ScanCodeVec = azul_core::window::ScanCodeVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the ScanCode as a Python array
    fn array(&self) -> Vec<AzScanCode> {
        let m: &azul_core::window::ScanCodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzScanCodeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ScanCodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ScanCodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssDeclarationVec {
    /// Creates a new `CssDeclarationEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzCssDeclarationEnumWrapper>) -> Self {
        let m: azul_impl::css::CssDeclarationVec = azul_impl::css::CssDeclarationVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the CssDeclarationEnumWrapper as a Python array
    fn array(&self) -> Vec<AzCssDeclarationEnumWrapper> {
        let m: &azul_impl::css::CssDeclarationVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzCssDeclarationVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssDeclarationVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssDeclarationVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPathSelectorVec {
    /// Creates a new `CssPathSelectorEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzCssPathSelectorEnumWrapper>) -> Self {
        let m: azul_impl::css::CssPathSelectorVec = azul_impl::css::CssPathSelectorVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the CssPathSelectorEnumWrapper as a Python array
    fn array(&self) -> Vec<AzCssPathSelectorEnumWrapper> {
        let m: &azul_impl::css::CssPathSelectorVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzCssPathSelectorVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssPathSelectorVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssPathSelectorVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylesheetVec {
    /// Creates a new `StylesheetVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStylesheet>) -> Self {
        let m: azul_impl::css::StylesheetVec = azul_impl::css::StylesheetVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the Stylesheet as a Python array
    fn array(&self) -> Vec<AzStylesheet> {
        let m: &azul_impl::css::StylesheetVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStylesheetVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StylesheetVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StylesheetVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssRuleBlockVec {
    /// Creates a new `CssRuleBlockVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzCssRuleBlock>) -> Self {
        let m: azul_impl::css::CssRuleBlockVec = azul_impl::css::CssRuleBlockVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the CssRuleBlock as a Python array
    fn array(&self) -> Vec<AzCssRuleBlock> {
        let m: &azul_impl::css::CssRuleBlockVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzCssRuleBlockVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssRuleBlockVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssRuleBlockVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU16Vec {
    /// Creates a new `U16Vec` from a Python array
    #[new]
    fn __new__(input: Vec<AzU16>) -> Self {
        let m: azul_impl::css::U16Vec = azul_impl::css::U16Vec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the U16 as a Python array
    fn array(&self) -> Vec<AzU16> {
        let m: &azul_impl::css::U16Vec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzU16Vec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::U16Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::U16Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzF32Vec {
    /// Creates a new `F32Vec` from a Python array
    #[new]
    fn __new__(input: Vec<AzF32>) -> Self {
        let m: azul_impl::css::F32Vec = azul_impl::css::F32Vec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the F32 as a Python array
    fn array(&self) -> Vec<AzF32> {
        let m: &azul_impl::css::F32Vec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzF32Vec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::F32Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::F32Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU8Vec {
}

#[pyproto]
impl PyObjectProtocol for AzU8Vec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::U8Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::U8Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallbackDataVec {
    /// Creates a new `CallbackDataVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzCallbackData>) -> Self {
        let m: azul_impl::dom::CallbackDataVec = azul_impl::dom::CallbackDataVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the CallbackData as a Python array
    fn array(&self) -> Vec<AzCallbackData> {
        let m: &azul_impl::dom::CallbackDataVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzCallbackDataVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::CallbackDataVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::CallbackDataVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDebugMessageVec {
    /// Creates a new `DebugMessageVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzDebugMessage>) -> Self {
        let m: azul_impl::gl::AzDebugMessageVec = azul_impl::gl::AzDebugMessageVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the DebugMessage as a Python array
    fn array(&self) -> Vec<AzDebugMessage> {
        let m: &azul_impl::gl::AzDebugMessageVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzDebugMessageVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::AzDebugMessageVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::AzDebugMessageVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLuintVec {
    /// Creates a new `GLuintVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzGLuint>) -> Self {
        let m: azul_impl::gl::GLuintVec = azul_impl::gl::GLuintVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the GLuint as a Python array
    fn array(&self) -> Vec<AzGLuint> {
        let m: &azul_impl::gl::GLuintVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzGLuintVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLuintVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLuintVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLintVec {
    /// Creates a new `GLintVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzGLint>) -> Self {
        let m: azul_impl::gl::GLintVec = azul_impl::gl::GLintVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the GLint as a Python array
    fn array(&self) -> Vec<AzGLint> {
        let m: &azul_impl::gl::GLintVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzGLintVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLintVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLintVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringVec {
    /// Creates a new `StringVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzString>) -> Self {
        let m: azul_impl::css::StringVec = azul_impl::css::StringVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the String as a Python array
    fn array(&self) -> Vec<AzString> {
        let m: &azul_impl::css::StringVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStringVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StringVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StringVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringPairVec {
    /// Creates a new `StringPairVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStringPair>) -> Self {
        let m: azul_core::window::StringPairVec = azul_core::window::StringPairVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the StringPair as a Python array
    fn array(&self) -> Vec<AzStringPair> {
        let m: &azul_core::window::StringPairVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStringPairVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::StringPairVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::StringPairVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedLinearColorStopVec {
    /// Creates a new `NormalizedLinearColorStopVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNormalizedLinearColorStop>) -> Self {
        let m: azul_impl::css::NormalizedLinearColorStopVec = azul_impl::css::NormalizedLinearColorStopVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the NormalizedLinearColorStop as a Python array
    fn array(&self) -> Vec<AzNormalizedLinearColorStop> {
        let m: &azul_impl::css::NormalizedLinearColorStopVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNormalizedLinearColorStopVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::NormalizedLinearColorStopVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::NormalizedLinearColorStopVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedRadialColorStopVec {
    /// Creates a new `NormalizedRadialColorStopVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNormalizedRadialColorStop>) -> Self {
        let m: azul_impl::css::NormalizedRadialColorStopVec = azul_impl::css::NormalizedRadialColorStopVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the NormalizedRadialColorStop as a Python array
    fn array(&self) -> Vec<AzNormalizedRadialColorStop> {
        let m: &azul_impl::css::NormalizedRadialColorStopVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNormalizedRadialColorStopVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::NormalizedRadialColorStopVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::NormalizedRadialColorStopVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdVec {
    /// Creates a new `NodeIdVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNodeId>) -> Self {
        let m: azul_impl::styled_dom::NodeIdVec = azul_impl::styled_dom::NodeIdVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the NodeId as a Python array
    fn array(&self) -> Vec<AzNodeId> {
        let m: &azul_impl::styled_dom::NodeIdVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeIdVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::NodeIdVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::NodeIdVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeHierarchyItemVec {
    /// Creates a new `NodeHierarchyItemVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNodeHierarchyItem>) -> Self {
        let m: azul_impl::styled_dom::NodeHierarchyItemVec = azul_impl::styled_dom::NodeHierarchyItemVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the NodeHierarchyItem as a Python array
    fn array(&self) -> Vec<AzNodeHierarchyItem> {
        let m: &azul_impl::styled_dom::NodeHierarchyItemVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeHierarchyItemVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::NodeHierarchyItemVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::NodeHierarchyItemVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledNodeVec {
    /// Creates a new `StyledNodeVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStyledNode>) -> Self {
        let m: azul_impl::styled_dom::StyledNodeVec = azul_impl::styled_dom::StyledNodeVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the StyledNode as a Python array
    fn array(&self) -> Vec<AzStyledNode> {
        let m: &azul_impl::styled_dom::StyledNodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyledNodeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::StyledNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::StyledNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTagIdToNodeIdMappingVec {
    /// Creates a new `TagIdToNodeIdMappingVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzTagIdToNodeIdMapping>) -> Self {
        let m: azul_impl::styled_dom::TagIdToNodeIdMappingVec = azul_impl::styled_dom::TagIdToNodeIdMappingVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the TagIdToNodeIdMapping as a Python array
    fn array(&self) -> Vec<AzTagIdToNodeIdMapping> {
        let m: &azul_impl::styled_dom::TagIdToNodeIdMappingVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzTagIdToNodeIdMappingVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::TagIdToNodeIdMappingVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::TagIdToNodeIdMappingVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzParentWithNodeDepthVec {
    /// Creates a new `ParentWithNodeDepthVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzParentWithNodeDepth>) -> Self {
        let m: azul_impl::styled_dom::ParentWithNodeDepthVec = azul_impl::styled_dom::ParentWithNodeDepthVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the ParentWithNodeDepth as a Python array
    fn array(&self) -> Vec<AzParentWithNodeDepth> {
        let m: &azul_impl::styled_dom::ParentWithNodeDepthVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzParentWithNodeDepthVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::ParentWithNodeDepthVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::ParentWithNodeDepthVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataVec {
    /// Creates a new `NodeDataVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNodeData>) -> Self {
        let m: azul_impl::dom::NodeDataVec = azul_impl::dom::NodeDataVec::from_vec(unsafe { mem::transmute(input) }); unsafe { mem::transmute(m) }
    }
    
    /// Returns the NodeData as a Python array
    fn array(&self) -> Vec<AzNodeData> {
        let m: &azul_impl::dom::NodeDataVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeDataVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::NodeDataVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::NodeDataVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontFamilyVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleFontFamilyVecDestructorEnumWrapper { AzStyleFontFamilyVecDestructorEnumWrapper { inner: AzStyleFontFamilyVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzStyleFontFamilyVecDestructorEnumWrapper { AzStyleFontFamilyVecDestructorEnumWrapper { inner: AzStyleFontFamilyVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleFontFamilyVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFontFamilyVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontFamilyVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleFontFamilyVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleFontFamilyVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalRectVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzLogicalRectVecDestructorEnumWrapper { AzLogicalRectVecDestructorEnumWrapper { inner: AzLogicalRectVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzLogicalRectVecDestructorEnumWrapper { AzLogicalRectVecDestructorEnumWrapper { inner: AzLogicalRectVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLogicalRectVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLogicalRectVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzLogicalRectVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzLogicalRectVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLogicalRectVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LogicalRectVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LogicalRectVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeTypeIdInfoMapVecDestructorEnumWrapper { AzNodeTypeIdInfoMapVecDestructorEnumWrapper { inner: AzNodeTypeIdInfoMapVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzNodeTypeIdInfoMapVecDestructorEnumWrapper { AzNodeTypeIdInfoMapVecDestructorEnumWrapper { inner: AzNodeTypeIdInfoMapVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeTypeIdInfoMapVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeTypeIdInfoMapVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeTypeIdInfoMapVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeTypeIdInfoMapVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMapVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMapVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper { AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper { inner: AzInputOutputTypeIdInfoMapVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper { AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper { inner: AzInputOutputTypeIdInfoMapVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInputOutputTypeIdInfoMapVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInputOutputTypeIdInfoMapVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzInputOutputTypeIdInfoMapVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzInputOutputTypeIdInfoMapVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdNodeMapVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeIdNodeMapVecDestructorEnumWrapper { AzNodeIdNodeMapVecDestructorEnumWrapper { inner: AzNodeIdNodeMapVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzNodeIdNodeMapVecDestructorEnumWrapper { AzNodeIdNodeMapVecDestructorEnumWrapper { inner: AzNodeIdNodeMapVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeIdNodeMapVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeIdNodeMapVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeIdNodeMapVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeIdNodeMapVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeIdNodeMapVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeIdNodeMapVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeIdNodeMapVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeIdVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInputOutputTypeIdVecDestructorEnumWrapper { AzInputOutputTypeIdVecDestructorEnumWrapper { inner: AzInputOutputTypeIdVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzInputOutputTypeIdVecDestructorEnumWrapper { AzInputOutputTypeIdVecDestructorEnumWrapper { inner: AzInputOutputTypeIdVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInputOutputTypeIdVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInputOutputTypeIdVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzInputOutputTypeIdVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzInputOutputTypeIdVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeIdVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeFieldVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeTypeFieldVecDestructorEnumWrapper { AzNodeTypeFieldVecDestructorEnumWrapper { inner: AzNodeTypeFieldVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzNodeTypeFieldVecDestructorEnumWrapper { AzNodeTypeFieldVecDestructorEnumWrapper { inner: AzNodeTypeFieldVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeTypeFieldVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeTypeFieldVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeTypeFieldVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeTypeFieldVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeFieldVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeFieldVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeFieldVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputConnectionVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInputConnectionVecDestructorEnumWrapper { AzInputConnectionVecDestructorEnumWrapper { inner: AzInputConnectionVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzInputConnectionVecDestructorEnumWrapper { AzInputConnectionVecDestructorEnumWrapper { inner: AzInputConnectionVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInputConnectionVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInputConnectionVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzInputConnectionVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzInputConnectionVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputConnectionVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputConnectionVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputConnectionVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputNodeAndIndexVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzOutputNodeAndIndexVecDestructorEnumWrapper { AzOutputNodeAndIndexVecDestructorEnumWrapper { inner: AzOutputNodeAndIndexVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzOutputNodeAndIndexVecDestructorEnumWrapper { AzOutputNodeAndIndexVecDestructorEnumWrapper { inner: AzOutputNodeAndIndexVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOutputNodeAndIndexVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOutputNodeAndIndexVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzOutputNodeAndIndexVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzOutputNodeAndIndexVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOutputNodeAndIndexVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputNodeAndIndexVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputNodeAndIndexVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputConnectionVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzOutputConnectionVecDestructorEnumWrapper { AzOutputConnectionVecDestructorEnumWrapper { inner: AzOutputConnectionVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzOutputConnectionVecDestructorEnumWrapper { AzOutputConnectionVecDestructorEnumWrapper { inner: AzOutputConnectionVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOutputConnectionVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOutputConnectionVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzOutputConnectionVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzOutputConnectionVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOutputConnectionVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputConnectionVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputConnectionVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputNodeAndIndexVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInputNodeAndIndexVecDestructorEnumWrapper { AzInputNodeAndIndexVecDestructorEnumWrapper { inner: AzInputNodeAndIndexVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzInputNodeAndIndexVecDestructorEnumWrapper { AzInputNodeAndIndexVecDestructorEnumWrapper { inner: AzInputNodeAndIndexVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInputNodeAndIndexVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInputNodeAndIndexVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzInputNodeAndIndexVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzInputNodeAndIndexVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputNodeAndIndexVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputNodeAndIndexVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputNodeAndIndexVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzTabVecDestructorEnumWrapper { AzTabVecDestructorEnumWrapper { inner: AzTabVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzTabVecDestructorEnumWrapper { AzTabVecDestructorEnumWrapper { inner: AzTabVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzTabVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTabVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzTabVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzTabVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTabVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::tabs::TabVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::tabs::TabVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAccessibilityStateVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzAccessibilityStateVecDestructorEnumWrapper { AzAccessibilityStateVecDestructorEnumWrapper { inner: AzAccessibilityStateVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzAccessibilityStateVecDestructorEnumWrapper { AzAccessibilityStateVecDestructorEnumWrapper { inner: AzAccessibilityStateVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzAccessibilityStateVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAccessibilityStateVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzAccessibilityStateVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzAccessibilityStateVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityStateVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::AccessibilityStateVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::AccessibilityStateVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuItemVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzMenuItemVecDestructorEnumWrapper { AzMenuItemVecDestructorEnumWrapper { inner: AzMenuItemVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzMenuItemVecDestructorEnumWrapper { AzMenuItemVecDestructorEnumWrapper { inner: AzMenuItemVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzMenuItemVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzMenuItemVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzMenuItemVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzMenuItemVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MenuItemVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MenuItemVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedSvgNodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzTessellatedSvgNodeVecDestructorEnumWrapper { AzTessellatedSvgNodeVecDestructorEnumWrapper { inner: AzTessellatedSvgNodeVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzTessellatedSvgNodeVecDestructorEnumWrapper { AzTessellatedSvgNodeVecDestructorEnumWrapper { inner: AzTessellatedSvgNodeVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzTessellatedSvgNodeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTessellatedSvgNodeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzTessellatedSvgNodeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzTessellatedSvgNodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedSvgNodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::TessellatedSvgNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::TessellatedSvgNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlNodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzXmlNodeVecDestructorEnumWrapper { AzXmlNodeVecDestructorEnumWrapper { inner: AzXmlNodeVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzXmlNodeVecDestructorEnumWrapper { AzXmlNodeVecDestructorEnumWrapper { inner: AzXmlNodeVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzXmlNodeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlNodeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzXmlNodeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzXmlNodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlNodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::XmlNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::XmlNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFmtArgVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzFmtArgVecDestructorEnumWrapper { AzFmtArgVecDestructorEnumWrapper { inner: AzFmtArgVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzFmtArgVecDestructorEnumWrapper { AzFmtArgVecDestructorEnumWrapper { inner: AzFmtArgVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzFmtArgVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzFmtArgVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzFmtArgVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzFmtArgVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFmtArgVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::str::FmtArgVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::str::FmtArgVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineLineVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInlineLineVecDestructorEnumWrapper { AzInlineLineVecDestructorEnumWrapper { inner: AzInlineLineVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzInlineLineVecDestructorEnumWrapper { AzInlineLineVecDestructorEnumWrapper { inner: AzInlineLineVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInlineLineVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInlineLineVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzInlineLineVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzInlineLineVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineLineVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineLineVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineLineVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineWordVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInlineWordVecDestructorEnumWrapper { AzInlineWordVecDestructorEnumWrapper { inner: AzInlineWordVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzInlineWordVecDestructorEnumWrapper { AzInlineWordVecDestructorEnumWrapper { inner: AzInlineWordVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInlineWordVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInlineWordVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzInlineWordVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzInlineWordVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineWordVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineWordVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineWordVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineGlyphVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInlineGlyphVecDestructorEnumWrapper { AzInlineGlyphVecDestructorEnumWrapper { inner: AzInlineGlyphVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzInlineGlyphVecDestructorEnumWrapper { AzInlineGlyphVecDestructorEnumWrapper { inner: AzInlineGlyphVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInlineGlyphVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInlineGlyphVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzInlineGlyphVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzInlineGlyphVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineGlyphVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineGlyphVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineGlyphVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineTextHitVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInlineTextHitVecDestructorEnumWrapper { AzInlineTextHitVecDestructorEnumWrapper { inner: AzInlineTextHitVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzInlineTextHitVecDestructorEnumWrapper { AzInlineTextHitVecDestructorEnumWrapper { inner: AzInlineTextHitVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInlineTextHitVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInlineTextHitVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzInlineTextHitVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzInlineTextHitVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineTextHitVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineTextHitVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::InlineTextHitVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMonitorVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzMonitorVecDestructorEnumWrapper { AzMonitorVecDestructorEnumWrapper { inner: AzMonitorVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzMonitorVecDestructorEnumWrapper { AzMonitorVecDestructorEnumWrapper { inner: AzMonitorVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzMonitorVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzMonitorVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzMonitorVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzMonitorVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMonitorVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MonitorVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MonitorVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVideoModeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzVideoModeVecDestructorEnumWrapper { AzVideoModeVecDestructorEnumWrapper { inner: AzVideoModeVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzVideoModeVecDestructorEnumWrapper { AzVideoModeVecDestructorEnumWrapper { inner: AzVideoModeVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzVideoModeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzVideoModeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzVideoModeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzVideoModeVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVideoModeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoModeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoModeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzDomVecDestructorEnumWrapper { AzDomVecDestructorEnumWrapper { inner: AzDomVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzDomVecDestructorEnumWrapper { AzDomVecDestructorEnumWrapper { inner: AzDomVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzDomVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzDomVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzDomVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzDomVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDomVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::DomVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::DomVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIdOrClassVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzIdOrClassVecDestructorEnumWrapper { AzIdOrClassVecDestructorEnumWrapper { inner: AzIdOrClassVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzIdOrClassVecDestructorEnumWrapper { AzIdOrClassVecDestructorEnumWrapper { inner: AzIdOrClassVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzIdOrClassVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzIdOrClassVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzIdOrClassVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzIdOrClassVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIdOrClassVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::IdOrClassVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::IdOrClassVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeDataInlineCssPropertyVecDestructorEnumWrapper { AzNodeDataInlineCssPropertyVecDestructorEnumWrapper { inner: AzNodeDataInlineCssPropertyVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzNodeDataInlineCssPropertyVecDestructorEnumWrapper { AzNodeDataInlineCssPropertyVecDestructorEnumWrapper { inner: AzNodeDataInlineCssPropertyVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeDataInlineCssPropertyVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeDataInlineCssPropertyVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeDataInlineCssPropertyVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeDataInlineCssPropertyVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::NodeDataInlineCssPropertyVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::NodeDataInlineCssPropertyVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundContentVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleBackgroundContentVecDestructorEnumWrapper { AzStyleBackgroundContentVecDestructorEnumWrapper { inner: AzStyleBackgroundContentVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzStyleBackgroundContentVecDestructorEnumWrapper { AzStyleBackgroundContentVecDestructorEnumWrapper { inner: AzStyleBackgroundContentVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundContentVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundContentVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleBackgroundContentVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleBackgroundContentVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundContentVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundContentVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundContentVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundPositionVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleBackgroundPositionVecDestructorEnumWrapper { AzStyleBackgroundPositionVecDestructorEnumWrapper { inner: AzStyleBackgroundPositionVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzStyleBackgroundPositionVecDestructorEnumWrapper { AzStyleBackgroundPositionVecDestructorEnumWrapper { inner: AzStyleBackgroundPositionVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundPositionVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundPositionVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleBackgroundPositionVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleBackgroundPositionVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundPositionVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundPositionVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundPositionVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundRepeatVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleBackgroundRepeatVecDestructorEnumWrapper { AzStyleBackgroundRepeatVecDestructorEnumWrapper { inner: AzStyleBackgroundRepeatVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzStyleBackgroundRepeatVecDestructorEnumWrapper { AzStyleBackgroundRepeatVecDestructorEnumWrapper { inner: AzStyleBackgroundRepeatVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundRepeatVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundRepeatVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleBackgroundRepeatVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleBackgroundRepeatVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundRepeatVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundRepeatVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundRepeatVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundSizeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleBackgroundSizeVecDestructorEnumWrapper { AzStyleBackgroundSizeVecDestructorEnumWrapper { inner: AzStyleBackgroundSizeVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzStyleBackgroundSizeVecDestructorEnumWrapper { AzStyleBackgroundSizeVecDestructorEnumWrapper { inner: AzStyleBackgroundSizeVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundSizeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundSizeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSizeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSizeVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundSizeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundSizeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleBackgroundSizeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleTransformVecDestructorEnumWrapper { AzStyleTransformVecDestructorEnumWrapper { inner: AzStyleTransformVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzStyleTransformVecDestructorEnumWrapper { AzStyleTransformVecDestructorEnumWrapper { inner: AzStyleTransformVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTransformVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTransformVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleTransformVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleTransformVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StyleTransformVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCssPropertyVecDestructorEnumWrapper { AzCssPropertyVecDestructorEnumWrapper { inner: AzCssPropertyVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzCssPropertyVecDestructorEnumWrapper { AzCssPropertyVecDestructorEnumWrapper { inner: AzCssPropertyVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssPropertyVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPropertyVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCssPropertyVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCssPropertyVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssPropertyVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssPropertyVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgMultiPolygonVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgMultiPolygonVecDestructorEnumWrapper { AzSvgMultiPolygonVecDestructorEnumWrapper { inner: AzSvgMultiPolygonVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzSvgMultiPolygonVecDestructorEnumWrapper { AzSvgMultiPolygonVecDestructorEnumWrapper { inner: AzSvgMultiPolygonVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgMultiPolygonVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgMultiPolygonVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzSvgMultiPolygonVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzSvgMultiPolygonVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgMultiPolygonVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgMultiPolygonVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgMultiPolygonVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgPathVecDestructorEnumWrapper { AzSvgPathVecDestructorEnumWrapper { inner: AzSvgPathVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzSvgPathVecDestructorEnumWrapper { AzSvgPathVecDestructorEnumWrapper { inner: AzSvgPathVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgPathVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgPathVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzSvgPathVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzSvgPathVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgPathVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgPathVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexAttributeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzVertexAttributeVecDestructorEnumWrapper { AzVertexAttributeVecDestructorEnumWrapper { inner: AzVertexAttributeVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzVertexAttributeVecDestructorEnumWrapper { AzVertexAttributeVecDestructorEnumWrapper { inner: AzVertexAttributeVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzVertexAttributeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzVertexAttributeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzVertexAttributeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzVertexAttributeVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVertexAttributeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::VertexAttributeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::VertexAttributeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathElementVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgPathElementVecDestructorEnumWrapper { AzSvgPathElementVecDestructorEnumWrapper { inner: AzSvgPathElementVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzSvgPathElementVecDestructorEnumWrapper { AzSvgPathElementVecDestructorEnumWrapper { inner: AzSvgPathElementVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgPathElementVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgPathElementVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzSvgPathElementVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzSvgPathElementVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathElementVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgPathElementVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgPathElementVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgVertexVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgVertexVecDestructorEnumWrapper { AzSvgVertexVecDestructorEnumWrapper { inner: AzSvgVertexVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzSvgVertexVecDestructorEnumWrapper { AzSvgVertexVecDestructorEnumWrapper { inner: AzSvgVertexVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgVertexVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgVertexVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzSvgVertexVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzSvgVertexVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgVertexVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgVertexVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgVertexVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU32VecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzU32VecDestructorEnumWrapper { AzU32VecDestructorEnumWrapper { inner: AzU32VecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzU32VecDestructorEnumWrapper { AzU32VecDestructorEnumWrapper { inner: AzU32VecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzU32VecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzU32VecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzU32VecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzU32VecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzU32VecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::U32VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::U32VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXWindowTypeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzXWindowTypeVecDestructorEnumWrapper { AzXWindowTypeVecDestructorEnumWrapper { inner: AzXWindowTypeVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzXWindowTypeVecDestructorEnumWrapper { AzXWindowTypeVecDestructorEnumWrapper { inner: AzXWindowTypeVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzXWindowTypeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXWindowTypeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzXWindowTypeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzXWindowTypeVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXWindowTypeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowTypeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowTypeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVirtualKeyCodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzVirtualKeyCodeVecDestructorEnumWrapper { AzVirtualKeyCodeVecDestructorEnumWrapper { inner: AzVirtualKeyCodeVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzVirtualKeyCodeVecDestructorEnumWrapper { AzVirtualKeyCodeVecDestructorEnumWrapper { inner: AzVirtualKeyCodeVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzVirtualKeyCodeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzVirtualKeyCodeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzVirtualKeyCodeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzVirtualKeyCodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVirtualKeyCodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCascadeInfoVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCascadeInfoVecDestructorEnumWrapper { AzCascadeInfoVecDestructorEnumWrapper { inner: AzCascadeInfoVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzCascadeInfoVecDestructorEnumWrapper { AzCascadeInfoVecDestructorEnumWrapper { inner: AzCascadeInfoVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCascadeInfoVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCascadeInfoVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCascadeInfoVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCascadeInfoVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCascadeInfoVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::style::CascadeInfoVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::style::CascadeInfoVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScanCodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzScanCodeVecDestructorEnumWrapper { AzScanCodeVecDestructorEnumWrapper { inner: AzScanCodeVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzScanCodeVecDestructorEnumWrapper { AzScanCodeVecDestructorEnumWrapper { inner: AzScanCodeVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzScanCodeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzScanCodeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzScanCodeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzScanCodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzScanCodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ScanCodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ScanCodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssDeclarationVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCssDeclarationVecDestructorEnumWrapper { AzCssDeclarationVecDestructorEnumWrapper { inner: AzCssDeclarationVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzCssDeclarationVecDestructorEnumWrapper { AzCssDeclarationVecDestructorEnumWrapper { inner: AzCssDeclarationVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssDeclarationVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssDeclarationVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCssDeclarationVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCssDeclarationVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssDeclarationVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssDeclarationVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssDeclarationVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPathSelectorVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCssPathSelectorVecDestructorEnumWrapper { AzCssPathSelectorVecDestructorEnumWrapper { inner: AzCssPathSelectorVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzCssPathSelectorVecDestructorEnumWrapper { AzCssPathSelectorVecDestructorEnumWrapper { inner: AzCssPathSelectorVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssPathSelectorVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPathSelectorVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCssPathSelectorVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCssPathSelectorVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPathSelectorVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssPathSelectorVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssPathSelectorVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylesheetVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStylesheetVecDestructorEnumWrapper { AzStylesheetVecDestructorEnumWrapper { inner: AzStylesheetVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzStylesheetVecDestructorEnumWrapper { AzStylesheetVecDestructorEnumWrapper { inner: AzStylesheetVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStylesheetVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStylesheetVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStylesheetVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStylesheetVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStylesheetVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StylesheetVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StylesheetVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssRuleBlockVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCssRuleBlockVecDestructorEnumWrapper { AzCssRuleBlockVecDestructorEnumWrapper { inner: AzCssRuleBlockVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzCssRuleBlockVecDestructorEnumWrapper { AzCssRuleBlockVecDestructorEnumWrapper { inner: AzCssRuleBlockVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssRuleBlockVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssRuleBlockVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCssRuleBlockVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCssRuleBlockVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssRuleBlockVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssRuleBlockVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::CssRuleBlockVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzF32VecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzF32VecDestructorEnumWrapper { AzF32VecDestructorEnumWrapper { inner: AzF32VecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzF32VecDestructorEnumWrapper { AzF32VecDestructorEnumWrapper { inner: AzF32VecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzF32VecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzF32VecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzF32VecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzF32VecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzF32VecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::F32VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::F32VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU16VecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzU16VecDestructorEnumWrapper { AzU16VecDestructorEnumWrapper { inner: AzU16VecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzU16VecDestructorEnumWrapper { AzU16VecDestructorEnumWrapper { inner: AzU16VecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzU16VecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzU16VecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzU16VecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzU16VecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzU16VecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::U16VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::U16VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU8VecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzU8VecDestructorEnumWrapper { AzU8VecDestructorEnumWrapper { inner: AzU8VecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzU8VecDestructorEnumWrapper { AzU8VecDestructorEnumWrapper { inner: AzU8VecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzU8VecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzU8VecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzU8VecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzU8VecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzU8VecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::U8VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::U8VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallbackDataVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCallbackDataVecDestructorEnumWrapper { AzCallbackDataVecDestructorEnumWrapper { inner: AzCallbackDataVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzCallbackDataVecDestructorEnumWrapper { AzCallbackDataVecDestructorEnumWrapper { inner: AzCallbackDataVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCallbackDataVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCallbackDataVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCallbackDataVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCallbackDataVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCallbackDataVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::CallbackDataVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::CallbackDataVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDebugMessageVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzDebugMessageVecDestructorEnumWrapper { AzDebugMessageVecDestructorEnumWrapper { inner: AzDebugMessageVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzDebugMessageVecDestructorEnumWrapper { AzDebugMessageVecDestructorEnumWrapper { inner: AzDebugMessageVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzDebugMessageVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzDebugMessageVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzDebugMessageVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzDebugMessageVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDebugMessageVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::AzDebugMessageVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::AzDebugMessageVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLuintVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzGLuintVecDestructorEnumWrapper { AzGLuintVecDestructorEnumWrapper { inner: AzGLuintVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzGLuintVecDestructorEnumWrapper { AzGLuintVecDestructorEnumWrapper { inner: AzGLuintVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzGLuintVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzGLuintVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzGLuintVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzGLuintVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGLuintVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLuintVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLuintVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLintVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzGLintVecDestructorEnumWrapper { AzGLintVecDestructorEnumWrapper { inner: AzGLintVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzGLintVecDestructorEnumWrapper { AzGLintVecDestructorEnumWrapper { inner: AzGLintVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzGLintVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzGLintVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzGLintVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzGLintVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGLintVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLintVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::GLintVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStringVecDestructorEnumWrapper { AzStringVecDestructorEnumWrapper { inner: AzStringVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzStringVecDestructorEnumWrapper { AzStringVecDestructorEnumWrapper { inner: AzStringVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStringVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStringVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStringVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStringVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStringVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StringVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::StringVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringPairVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStringPairVecDestructorEnumWrapper { AzStringPairVecDestructorEnumWrapper { inner: AzStringPairVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzStringPairVecDestructorEnumWrapper { AzStringPairVecDestructorEnumWrapper { inner: AzStringPairVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStringPairVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStringPairVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStringPairVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStringPairVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStringPairVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::StringPairVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::StringPairVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedLinearColorStopVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNormalizedLinearColorStopVecDestructorEnumWrapper { AzNormalizedLinearColorStopVecDestructorEnumWrapper { inner: AzNormalizedLinearColorStopVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzNormalizedLinearColorStopVecDestructorEnumWrapper { AzNormalizedLinearColorStopVecDestructorEnumWrapper { inner: AzNormalizedLinearColorStopVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNormalizedLinearColorStopVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNormalizedLinearColorStopVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNormalizedLinearColorStopVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNormalizedLinearColorStopVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedLinearColorStopVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::NormalizedLinearColorStopVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::NormalizedLinearColorStopVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedRadialColorStopVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNormalizedRadialColorStopVecDestructorEnumWrapper { AzNormalizedRadialColorStopVecDestructorEnumWrapper { inner: AzNormalizedRadialColorStopVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzNormalizedRadialColorStopVecDestructorEnumWrapper { AzNormalizedRadialColorStopVecDestructorEnumWrapper { inner: AzNormalizedRadialColorStopVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNormalizedRadialColorStopVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNormalizedRadialColorStopVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNormalizedRadialColorStopVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNormalizedRadialColorStopVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedRadialColorStopVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::NormalizedRadialColorStopVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::NormalizedRadialColorStopVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeIdVecDestructorEnumWrapper { AzNodeIdVecDestructorEnumWrapper { inner: AzNodeIdVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzNodeIdVecDestructorEnumWrapper { AzNodeIdVecDestructorEnumWrapper { inner: AzNodeIdVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeIdVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeIdVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeIdVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeIdVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeIdVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::NodeIdVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::NodeIdVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeHierarchyItemVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeHierarchyItemVecDestructorEnumWrapper { AzNodeHierarchyItemVecDestructorEnumWrapper { inner: AzNodeHierarchyItemVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzNodeHierarchyItemVecDestructorEnumWrapper { AzNodeHierarchyItemVecDestructorEnumWrapper { inner: AzNodeHierarchyItemVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeHierarchyItemVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeHierarchyItemVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeHierarchyItemVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeHierarchyItemVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeHierarchyItemVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::NodeHierarchyItemVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::NodeHierarchyItemVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledNodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyledNodeVecDestructorEnumWrapper { AzStyledNodeVecDestructorEnumWrapper { inner: AzStyledNodeVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzStyledNodeVecDestructorEnumWrapper { AzStyledNodeVecDestructorEnumWrapper { inner: AzStyledNodeVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyledNodeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyledNodeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyledNodeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyledNodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyledNodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::StyledNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::StyledNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzTagIdToNodeIdMappingVecDestructorEnumWrapper { AzTagIdToNodeIdMappingVecDestructorEnumWrapper { inner: AzTagIdToNodeIdMappingVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzTagIdToNodeIdMappingVecDestructorEnumWrapper { AzTagIdToNodeIdMappingVecDestructorEnumWrapper { inner: AzTagIdToNodeIdMappingVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzTagIdToNodeIdMappingVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTagIdToNodeIdMappingVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzTagIdToNodeIdMappingVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzTagIdToNodeIdMappingVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::TagIdToNodeIdMappingVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::TagIdToNodeIdMappingVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzParentWithNodeDepthVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzParentWithNodeDepthVecDestructorEnumWrapper { AzParentWithNodeDepthVecDestructorEnumWrapper { inner: AzParentWithNodeDepthVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzParentWithNodeDepthVecDestructorEnumWrapper { AzParentWithNodeDepthVecDestructorEnumWrapper { inner: AzParentWithNodeDepthVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzParentWithNodeDepthVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzParentWithNodeDepthVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzParentWithNodeDepthVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzParentWithNodeDepthVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzParentWithNodeDepthVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::ParentWithNodeDepthVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::ParentWithNodeDepthVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeDataVecDestructorEnumWrapper { AzNodeDataVecDestructorEnumWrapper { inner: AzNodeDataVecDestructor::DefaultRust } }
    #[classattr]
    fn NoDestructor() -> AzNodeDataVecDestructorEnumWrapper { AzNodeDataVecDestructorEnumWrapper { inner: AzNodeDataVecDestructor::NoDestructor } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeDataVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeDataVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeDataVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeDataVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::NodeDataVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::NodeDataVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionDropDownOnChoiceChangeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionDropDownOnChoiceChangeEnumWrapper { AzOptionDropDownOnChoiceChangeEnumWrapper { inner: AzOptionDropDownOnChoiceChange::None } }
    #[staticmethod]
    fn Some(v: AzDropDownOnChoiceChange) -> AzOptionDropDownOnChoiceChangeEnumWrapper { AzOptionDropDownOnChoiceChangeEnumWrapper { inner: AzOptionDropDownOnChoiceChange::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionDropDownOnChoiceChange;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionDropDownOnChoiceChange::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionDropDownOnChoiceChange::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionDropDownOnChoiceChangeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::drop_down::OptionDropDownOnChoiceChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::drop_down::OptionDropDownOnChoiceChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionResolvedTextLayoutOptionsEnumWrapper {
    #[classattr]
    fn None() -> AzOptionResolvedTextLayoutOptionsEnumWrapper { AzOptionResolvedTextLayoutOptionsEnumWrapper { inner: AzOptionResolvedTextLayoutOptions::None } }
    #[staticmethod]
    fn Some(v: AzResolvedTextLayoutOptions) -> AzOptionResolvedTextLayoutOptionsEnumWrapper { AzOptionResolvedTextLayoutOptionsEnumWrapper { inner: AzOptionResolvedTextLayoutOptions::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionResolvedTextLayoutOptions;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionResolvedTextLayoutOptions::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionResolvedTextLayoutOptions::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionResolvedTextLayoutOptionsEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::ui_solver::OptionResolvedTextLayoutOptions = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::ui_solver::OptionResolvedTextLayoutOptions = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeGraphOnNodeAddedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeGraphOnNodeAddedEnumWrapper { AzOptionNodeGraphOnNodeAddedEnumWrapper { inner: AzOptionNodeGraphOnNodeAdded::None } }
    #[staticmethod]
    fn Some(v: AzNodeGraphOnNodeAdded) -> AzOptionNodeGraphOnNodeAddedEnumWrapper { AzOptionNodeGraphOnNodeAddedEnumWrapper { inner: AzOptionNodeGraphOnNodeAdded::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionNodeGraphOnNodeAdded;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeGraphOnNodeAdded::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNodeGraphOnNodeAdded::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeGraphOnNodeAddedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeAdded = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeAdded = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeGraphOnNodeRemovedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeGraphOnNodeRemovedEnumWrapper { AzOptionNodeGraphOnNodeRemovedEnumWrapper { inner: AzOptionNodeGraphOnNodeRemoved::None } }
    #[staticmethod]
    fn Some(v: AzNodeGraphOnNodeRemoved) -> AzOptionNodeGraphOnNodeRemovedEnumWrapper { AzOptionNodeGraphOnNodeRemovedEnumWrapper { inner: AzOptionNodeGraphOnNodeRemoved::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionNodeGraphOnNodeRemoved;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeGraphOnNodeRemoved::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNodeGraphOnNodeRemoved::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeGraphOnNodeRemovedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeRemoved = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeRemoved = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper { AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper { inner: AzOptionNodeGraphOnNodeGraphDragged::None } }
    #[staticmethod]
    fn Some(v: AzNodeGraphOnNodeGraphDragged) -> AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper { AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper { inner: AzOptionNodeGraphOnNodeGraphDragged::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionNodeGraphOnNodeGraphDragged;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeGraphOnNodeGraphDragged::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNodeGraphOnNodeGraphDragged::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeGraphDragged = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeGraphDragged = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeGraphOnNodeDraggedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeGraphOnNodeDraggedEnumWrapper { AzOptionNodeGraphOnNodeDraggedEnumWrapper { inner: AzOptionNodeGraphOnNodeDragged::None } }
    #[staticmethod]
    fn Some(v: AzNodeGraphOnNodeDragged) -> AzOptionNodeGraphOnNodeDraggedEnumWrapper { AzOptionNodeGraphOnNodeDraggedEnumWrapper { inner: AzOptionNodeGraphOnNodeDragged::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionNodeGraphOnNodeDragged;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeGraphOnNodeDragged::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNodeGraphOnNodeDragged::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeGraphOnNodeDraggedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeDragged = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeDragged = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeGraphOnNodeConnectedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeGraphOnNodeConnectedEnumWrapper { AzOptionNodeGraphOnNodeConnectedEnumWrapper { inner: AzOptionNodeGraphOnNodeConnected::None } }
    #[staticmethod]
    fn Some(v: AzNodeGraphOnNodeConnected) -> AzOptionNodeGraphOnNodeConnectedEnumWrapper { AzOptionNodeGraphOnNodeConnectedEnumWrapper { inner: AzOptionNodeGraphOnNodeConnected::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionNodeGraphOnNodeConnected;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeGraphOnNodeConnected::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNodeGraphOnNodeConnected::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeGraphOnNodeConnectedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeConnected = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeConnected = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper { AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper { inner: AzOptionNodeGraphOnNodeInputDisconnected::None } }
    #[staticmethod]
    fn Some(v: AzNodeGraphOnNodeInputDisconnected) -> AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper { AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper { inner: AzOptionNodeGraphOnNodeInputDisconnected::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionNodeGraphOnNodeInputDisconnected;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeGraphOnNodeInputDisconnected::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNodeGraphOnNodeInputDisconnected::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeInputDisconnected = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeInputDisconnected = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper { AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper { inner: AzOptionNodeGraphOnNodeOutputDisconnected::None } }
    #[staticmethod]
    fn Some(v: AzNodeGraphOnNodeOutputDisconnected) -> AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper { AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper { inner: AzOptionNodeGraphOnNodeOutputDisconnected::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionNodeGraphOnNodeOutputDisconnected;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeGraphOnNodeOutputDisconnected::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNodeGraphOnNodeOutputDisconnected::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeOutputDisconnected = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeOutputDisconnected = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeGraphOnNodeFieldEditedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeGraphOnNodeFieldEditedEnumWrapper { AzOptionNodeGraphOnNodeFieldEditedEnumWrapper { inner: AzOptionNodeGraphOnNodeFieldEdited::None } }
    #[staticmethod]
    fn Some(v: AzNodeGraphOnNodeFieldEdited) -> AzOptionNodeGraphOnNodeFieldEditedEnumWrapper { AzOptionNodeGraphOnNodeFieldEditedEnumWrapper { inner: AzOptionNodeGraphOnNodeFieldEdited::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionNodeGraphOnNodeFieldEdited;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeGraphOnNodeFieldEdited::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNodeGraphOnNodeFieldEdited::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeGraphOnNodeFieldEditedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeFieldEdited = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeFieldEdited = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionColorInputOnValueChangeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionColorInputOnValueChangeEnumWrapper { AzOptionColorInputOnValueChangeEnumWrapper { inner: AzOptionColorInputOnValueChange::None } }
    #[staticmethod]
    fn Some(v: AzColorInputOnValueChange) -> AzOptionColorInputOnValueChangeEnumWrapper { AzOptionColorInputOnValueChangeEnumWrapper { inner: AzOptionColorInputOnValueChange::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionColorInputOnValueChange;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionColorInputOnValueChange::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionColorInputOnValueChange::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionColorInputOnValueChangeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::color_input::OptionColorInputOnValueChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::color_input::OptionColorInputOnValueChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionButtonOnClickEnumWrapper {
    #[classattr]
    fn None() -> AzOptionButtonOnClickEnumWrapper { AzOptionButtonOnClickEnumWrapper { inner: AzOptionButtonOnClick::None } }
    #[staticmethod]
    fn Some(v: AzButtonOnClick) -> AzOptionButtonOnClickEnumWrapper { AzOptionButtonOnClickEnumWrapper { inner: AzOptionButtonOnClick::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionButtonOnClick;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionButtonOnClick::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionButtonOnClick::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionButtonOnClickEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::button::OptionButtonOnClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::button::OptionButtonOnClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionCheckBoxOnToggleEnumWrapper {
    #[classattr]
    fn None() -> AzOptionCheckBoxOnToggleEnumWrapper { AzOptionCheckBoxOnToggleEnumWrapper { inner: AzOptionCheckBoxOnToggle::None } }
    #[staticmethod]
    fn Some(v: AzCheckBoxOnToggle) -> AzOptionCheckBoxOnToggleEnumWrapper { AzOptionCheckBoxOnToggleEnumWrapper { inner: AzOptionCheckBoxOnToggle::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionCheckBoxOnToggle;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionCheckBoxOnToggle::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionCheckBoxOnToggle::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionCheckBoxOnToggleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::check_box::OptionCheckBoxOnToggle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::check_box::OptionCheckBoxOnToggle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextInputOnTextInputEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextInputOnTextInputEnumWrapper { AzOptionTextInputOnTextInputEnumWrapper { inner: AzOptionTextInputOnTextInput::None } }
    #[staticmethod]
    fn Some(v: AzTextInputOnTextInput) -> AzOptionTextInputOnTextInputEnumWrapper { AzOptionTextInputOnTextInputEnumWrapper { inner: AzOptionTextInputOnTextInput::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTextInputOnTextInput;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTextInputOnTextInput::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTextInputOnTextInput::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextInputOnTextInputEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OptionTextInputOnTextInput = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OptionTextInputOnTextInput = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextInputOnVirtualKeyDownEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextInputOnVirtualKeyDownEnumWrapper { AzOptionTextInputOnVirtualKeyDownEnumWrapper { inner: AzOptionTextInputOnVirtualKeyDown::None } }
    #[staticmethod]
    fn Some(v: AzTextInputOnVirtualKeyDown) -> AzOptionTextInputOnVirtualKeyDownEnumWrapper { AzOptionTextInputOnVirtualKeyDownEnumWrapper { inner: AzOptionTextInputOnVirtualKeyDown::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTextInputOnVirtualKeyDown;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTextInputOnVirtualKeyDown::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTextInputOnVirtualKeyDown::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextInputOnVirtualKeyDownEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OptionTextInputOnVirtualKeyDown = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OptionTextInputOnVirtualKeyDown = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextInputOnFocusLostEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextInputOnFocusLostEnumWrapper { AzOptionTextInputOnFocusLostEnumWrapper { inner: AzOptionTextInputOnFocusLost::None } }
    #[staticmethod]
    fn Some(v: AzTextInputOnFocusLost) -> AzOptionTextInputOnFocusLostEnumWrapper { AzOptionTextInputOnFocusLostEnumWrapper { inner: AzOptionTextInputOnFocusLost::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTextInputOnFocusLost;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTextInputOnFocusLost::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTextInputOnFocusLost::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextInputOnFocusLostEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OptionTextInputOnFocusLost = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OptionTextInputOnFocusLost = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextInputSelectionEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextInputSelectionEnumWrapper { AzOptionTextInputSelectionEnumWrapper { inner: AzOptionTextInputSelection::None } }
    #[staticmethod]
    fn Some(v: AzTextInputSelectionEnumWrapper) -> AzOptionTextInputSelectionEnumWrapper { AzOptionTextInputSelectionEnumWrapper { inner: AzOptionTextInputSelection::Some(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTextInputSelection;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTextInputSelection::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTextInputSelection::Some(v) => Ok(vec!["Some".into_py(py), { let m: &AzTextInputSelectionEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextInputSelectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OptionTextInputSelection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OptionTextInputSelection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNumberInputOnFocusLostEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNumberInputOnFocusLostEnumWrapper { AzOptionNumberInputOnFocusLostEnumWrapper { inner: AzOptionNumberInputOnFocusLost::None } }
    #[staticmethod]
    fn Some(v: AzNumberInputOnFocusLost) -> AzOptionNumberInputOnFocusLostEnumWrapper { AzOptionNumberInputOnFocusLostEnumWrapper { inner: AzOptionNumberInputOnFocusLost::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionNumberInputOnFocusLost;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNumberInputOnFocusLost::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNumberInputOnFocusLost::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNumberInputOnFocusLostEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::OptionNumberInputOnFocusLost = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::OptionNumberInputOnFocusLost = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNumberInputOnValueChangeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNumberInputOnValueChangeEnumWrapper { AzOptionNumberInputOnValueChangeEnumWrapper { inner: AzOptionNumberInputOnValueChange::None } }
    #[staticmethod]
    fn Some(v: AzNumberInputOnValueChange) -> AzOptionNumberInputOnValueChangeEnumWrapper { AzOptionNumberInputOnValueChangeEnumWrapper { inner: AzOptionNumberInputOnValueChange::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionNumberInputOnValueChange;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNumberInputOnValueChange::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNumberInputOnValueChange::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNumberInputOnValueChangeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::OptionNumberInputOnValueChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::OptionNumberInputOnValueChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMenuItemIconEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMenuItemIconEnumWrapper { AzOptionMenuItemIconEnumWrapper { inner: AzOptionMenuItemIcon::None } }
    #[staticmethod]
    fn Some(v: AzMenuItemIconEnumWrapper) -> AzOptionMenuItemIconEnumWrapper { AzOptionMenuItemIconEnumWrapper { inner: AzOptionMenuItemIcon::Some(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionMenuItemIcon;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMenuItemIcon::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMenuItemIcon::Some(v) => Ok(vec!["Some".into_py(py), { let m: &AzMenuItemIconEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMenuItemIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionMenuItemIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionMenuItemIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMenuCallbackEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMenuCallbackEnumWrapper { AzOptionMenuCallbackEnumWrapper { inner: AzOptionMenuCallback::None } }
    #[staticmethod]
    fn Some(v: AzMenuCallback) -> AzOptionMenuCallbackEnumWrapper { AzOptionMenuCallbackEnumWrapper { inner: AzOptionMenuCallback::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionMenuCallback;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMenuCallback::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMenuCallback::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMenuCallbackEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionMenuCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionMenuCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionVirtualKeyCodeComboEnumWrapper {
    #[classattr]
    fn None() -> AzOptionVirtualKeyCodeComboEnumWrapper { AzOptionVirtualKeyCodeComboEnumWrapper { inner: AzOptionVirtualKeyCodeCombo::None } }
    #[staticmethod]
    fn Some(v: AzVirtualKeyCodeCombo) -> AzOptionVirtualKeyCodeComboEnumWrapper { AzOptionVirtualKeyCodeComboEnumWrapper { inner: AzOptionVirtualKeyCodeCombo::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionVirtualKeyCodeCombo;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionVirtualKeyCodeCombo::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionVirtualKeyCodeCombo::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionVirtualKeyCodeComboEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionVirtualKeyCodeCombo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionVirtualKeyCodeCombo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionCssPropertyEnumWrapper {
    #[classattr]
    fn None() -> AzOptionCssPropertyEnumWrapper { AzOptionCssPropertyEnumWrapper { inner: AzOptionCssProperty::None } }
    #[staticmethod]
    fn Some(v: AzCssPropertyEnumWrapper) -> AzOptionCssPropertyEnumWrapper { AzOptionCssPropertyEnumWrapper { inner: AzOptionCssProperty::Some(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionCssProperty;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionCssProperty::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionCssProperty::Some(v) => Ok(vec!["Some".into_py(py), { let m: &AzCssPropertyEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionCssPropertyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionCssProperty = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionCssProperty = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionPositionInfoEnumWrapper {
    #[classattr]
    fn None() -> AzOptionPositionInfoEnumWrapper { AzOptionPositionInfoEnumWrapper { inner: AzOptionPositionInfo::None } }
    #[staticmethod]
    fn Some(v: AzPositionInfoEnumWrapper) -> AzOptionPositionInfoEnumWrapper { AzOptionPositionInfoEnumWrapper { inner: AzOptionPositionInfo::Some(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionPositionInfo;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionPositionInfo::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionPositionInfo::Some(v) => Ok(vec!["Some".into_py(py), { let m: &AzPositionInfoEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionPositionInfoEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::ui_solver::OptionPositionInfo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::ui_solver::OptionPositionInfo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTimerIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTimerIdEnumWrapper { AzOptionTimerIdEnumWrapper { inner: AzOptionTimerId::None } }
    #[staticmethod]
    fn Some(v: AzTimerId) -> AzOptionTimerIdEnumWrapper { AzOptionTimerIdEnumWrapper { inner: AzOptionTimerId::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTimerId;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTimerId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTimerId::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTimerIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::OptionTimerId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::OptionTimerId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionThreadIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionThreadIdEnumWrapper { AzOptionThreadIdEnumWrapper { inner: AzOptionThreadId::None } }
    #[staticmethod]
    fn Some(v: AzThreadId) -> AzOptionThreadIdEnumWrapper { AzOptionThreadIdEnumWrapper { inner: AzOptionThreadId::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionThreadId;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionThreadId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionThreadId::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionThreadIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::OptionThreadId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::OptionThreadId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionI16EnumWrapper {
    #[classattr]
    fn None() -> AzOptionI16EnumWrapper { AzOptionI16EnumWrapper { inner: AzOptionI16::None } }
    #[staticmethod]
    fn Some(v: i16) -> AzOptionI16EnumWrapper { AzOptionI16EnumWrapper { inner: AzOptionI16::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionI16;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionI16::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionI16::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionI16EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionI16 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionI16 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionU16EnumWrapper {
    #[classattr]
    fn None() -> AzOptionU16EnumWrapper { AzOptionU16EnumWrapper { inner: AzOptionU16::None } }
    #[staticmethod]
    fn Some(v: u16) -> AzOptionU16EnumWrapper { AzOptionU16EnumWrapper { inner: AzOptionU16::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionU16;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionU16::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionU16::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionU16EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionU16 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionU16 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionU32EnumWrapper {
    #[classattr]
    fn None() -> AzOptionU32EnumWrapper { AzOptionU32EnumWrapper { inner: AzOptionU32::None } }
    #[staticmethod]
    fn Some(v: u32) -> AzOptionU32EnumWrapper { AzOptionU32EnumWrapper { inner: AzOptionU32::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionU32;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionU32::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionU32::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionU32EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionU32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionU32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionImageRefEnumWrapper {
    #[classattr]
    fn None() -> AzOptionImageRefEnumWrapper { AzOptionImageRefEnumWrapper { inner: AzOptionImageRef::None } }
    #[staticmethod]
    fn Some(v: AzImageRef) -> AzOptionImageRefEnumWrapper { AzOptionImageRefEnumWrapper { inner: AzOptionImageRef::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionImageRef;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionImageRef::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionImageRef::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionImageRefEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::OptionImageRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::OptionImageRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionFontRefEnumWrapper {
    #[classattr]
    fn None() -> AzOptionFontRefEnumWrapper { AzOptionFontRefEnumWrapper { inner: AzOptionFontRef::None } }
    #[staticmethod]
    fn Some(v: AzFontRef) -> AzOptionFontRefEnumWrapper { AzOptionFontRefEnumWrapper { inner: AzOptionFontRef::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionFontRef;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionFontRef::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionFontRef::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionFontRefEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionFontRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionFontRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionSystemClipboardEnumWrapper {
    #[classattr]
    fn None() -> AzOptionSystemClipboardEnumWrapper { AzOptionSystemClipboardEnumWrapper { inner: AzOptionSystemClipboard::None } }
    #[staticmethod]
    fn Some(v: AzSystemClipboard) -> AzOptionSystemClipboardEnumWrapper { AzOptionSystemClipboardEnumWrapper { inner: AzOptionSystemClipboard::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionSystemClipboard;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionSystemClipboard::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionSystemClipboard::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionSystemClipboardEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::app::OptionClipboard = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::app::OptionClipboard = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionFileTypeListEnumWrapper {
    #[classattr]
    fn None() -> AzOptionFileTypeListEnumWrapper { AzOptionFileTypeListEnumWrapper { inner: AzOptionFileTypeList::None } }
    #[staticmethod]
    fn Some(v: AzFileTypeList) -> AzOptionFileTypeListEnumWrapper { AzOptionFileTypeListEnumWrapper { inner: AzOptionFileTypeList::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionFileTypeList;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionFileTypeList::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionFileTypeList::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionFileTypeListEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dialogs::OptionFileTypeList = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dialogs::OptionFileTypeList = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionWindowStateEnumWrapper {
    #[classattr]
    fn None() -> AzOptionWindowStateEnumWrapper { AzOptionWindowStateEnumWrapper { inner: AzOptionWindowState::None } }
    #[staticmethod]
    fn Some(v: AzWindowState) -> AzOptionWindowStateEnumWrapper { AzOptionWindowStateEnumWrapper { inner: AzOptionWindowState::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionWindowState;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionWindowState::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionWindowState::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionWindowStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWindowState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWindowState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMouseStateEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMouseStateEnumWrapper { AzOptionMouseStateEnumWrapper { inner: AzOptionMouseState::None } }
    #[staticmethod]
    fn Some(v: AzMouseState) -> AzOptionMouseStateEnumWrapper { AzOptionMouseStateEnumWrapper { inner: AzOptionMouseState::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionMouseState;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMouseState::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMouseState::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMouseStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionMouseState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionMouseState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionKeyboardStateEnumWrapper {
    #[classattr]
    fn None() -> AzOptionKeyboardStateEnumWrapper { AzOptionKeyboardStateEnumWrapper { inner: AzOptionKeyboardState::None } }
    #[staticmethod]
    fn Some(v: AzKeyboardState) -> AzOptionKeyboardStateEnumWrapper { AzOptionKeyboardStateEnumWrapper { inner: AzOptionKeyboardState::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionKeyboardState;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionKeyboardState::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionKeyboardState::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionKeyboardStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionKeyboardState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionKeyboardState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionStringVecEnumWrapper {
    #[classattr]
    fn None() -> AzOptionStringVecEnumWrapper { AzOptionStringVecEnumWrapper { inner: AzOptionStringVec::None } }
    #[staticmethod]
    fn Some(v: AzStringVec) -> AzOptionStringVecEnumWrapper { AzOptionStringVecEnumWrapper { inner: AzOptionStringVec::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionStringVec;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionStringVec::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionStringVec::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionStringVecEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionStringVec = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionStringVec = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionFileEnumWrapper {
    #[classattr]
    fn None() -> AzOptionFileEnumWrapper { AzOptionFileEnumWrapper { inner: AzOptionFile::None } }
    #[staticmethod]
    fn Some(v: AzFile) -> AzOptionFileEnumWrapper { AzOptionFileEnumWrapper { inner: AzOptionFile::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionFile;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionFile::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionFile::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionFileEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::file::OptionFile = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::file::OptionFile = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionGlEnumWrapper {
    #[classattr]
    fn None() -> AzOptionGlEnumWrapper { AzOptionGlEnumWrapper { inner: AzOptionGl::None } }
    #[staticmethod]
    fn Some(v: AzGl) -> AzOptionGlEnumWrapper { AzOptionGlEnumWrapper { inner: AzOptionGl::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionGl;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionGl::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionGl::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionGlEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::OptionGlContextPtr = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::OptionGlContextPtr = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionThreadReceiveMsgEnumWrapper {
    #[classattr]
    fn None() -> AzOptionThreadReceiveMsgEnumWrapper { AzOptionThreadReceiveMsgEnumWrapper { inner: AzOptionThreadReceiveMsg::None } }
    #[staticmethod]
    fn Some(v: AzThreadReceiveMsgEnumWrapper) -> AzOptionThreadReceiveMsgEnumWrapper { AzOptionThreadReceiveMsgEnumWrapper { inner: AzOptionThreadReceiveMsg::Some(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionThreadReceiveMsg;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionThreadReceiveMsg::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionThreadReceiveMsg::Some(v) => Ok(vec!["Some".into_py(py), { let m: &AzThreadReceiveMsgEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionThreadReceiveMsgEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::OptionThreadReceiveMsg = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::OptionThreadReceiveMsg = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionPercentageValueEnumWrapper {
    #[classattr]
    fn None() -> AzOptionPercentageValueEnumWrapper { AzOptionPercentageValueEnumWrapper { inner: AzOptionPercentageValue::None } }
    #[staticmethod]
    fn Some(v: AzPercentageValue) -> AzOptionPercentageValueEnumWrapper { AzOptionPercentageValueEnumWrapper { inner: AzOptionPercentageValue::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionPercentageValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionPercentageValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionPercentageValue::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionPercentageValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionPercentageValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionPercentageValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionAngleValueEnumWrapper {
    #[classattr]
    fn None() -> AzOptionAngleValueEnumWrapper { AzOptionAngleValueEnumWrapper { inner: AzOptionAngleValue::None } }
    #[staticmethod]
    fn Some(v: AzAngleValue) -> AzOptionAngleValueEnumWrapper { AzOptionAngleValueEnumWrapper { inner: AzOptionAngleValue::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionAngleValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionAngleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionAngleValue::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionAngleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionAngleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionAngleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionRendererOptionsEnumWrapper {
    #[classattr]
    fn None() -> AzOptionRendererOptionsEnumWrapper { AzOptionRendererOptionsEnumWrapper { inner: AzOptionRendererOptions::None } }
    #[staticmethod]
    fn Some(v: AzRendererOptions) -> AzOptionRendererOptionsEnumWrapper { AzOptionRendererOptionsEnumWrapper { inner: AzOptionRendererOptions::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionRendererOptions;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionRendererOptions::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionRendererOptions::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionRendererOptionsEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionRendererOptions = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionRendererOptions = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionCallbackEnumWrapper {
    #[classattr]
    fn None() -> AzOptionCallbackEnumWrapper { AzOptionCallbackEnumWrapper { inner: AzOptionCallback::None } }
    #[staticmethod]
    fn Some(v: AzCallback) -> AzOptionCallbackEnumWrapper { AzOptionCallbackEnumWrapper { inner: AzOptionCallback::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionCallback;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionCallback::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionCallback::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionCallbackEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::OptionCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::OptionCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionThreadSendMsgEnumWrapper {
    #[classattr]
    fn None() -> AzOptionThreadSendMsgEnumWrapper { AzOptionThreadSendMsgEnumWrapper { inner: AzOptionThreadSendMsg::None } }
    #[staticmethod]
    fn Some(v: AzThreadSendMsgEnumWrapper) -> AzOptionThreadSendMsgEnumWrapper { AzOptionThreadSendMsgEnumWrapper { inner: AzOptionThreadSendMsg::Some(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionThreadSendMsg;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionThreadSendMsg::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionThreadSendMsg::Some(v) => Ok(vec!["Some".into_py(py), { let m: &AzThreadSendMsgEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionThreadSendMsgEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::OptionThreadSendMsg = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::OptionThreadSendMsg = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLayoutRectEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLayoutRectEnumWrapper { AzOptionLayoutRectEnumWrapper { inner: AzOptionLayoutRect::None } }
    #[staticmethod]
    fn Some(v: AzLayoutRect) -> AzOptionLayoutRectEnumWrapper { AzOptionLayoutRectEnumWrapper { inner: AzOptionLayoutRect::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionLayoutRect;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLayoutRect::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLayoutRect::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLayoutRectEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionLayoutRect = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionLayoutRect = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionRefAnyEnumWrapper {
    #[classattr]
    fn None() -> AzOptionRefAnyEnumWrapper { AzOptionRefAnyEnumWrapper { inner: AzOptionRefAny::None } }
    #[staticmethod]
    fn Some(v: AzRefAny) -> AzOptionRefAnyEnumWrapper { AzOptionRefAnyEnumWrapper { inner: AzOptionRefAny::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionRefAny;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionRefAny::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionRefAny::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionRefAnyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::OptionRefAny = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::OptionRefAny = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionInlineTextEnumWrapper {
    #[classattr]
    fn None() -> AzOptionInlineTextEnumWrapper { AzOptionInlineTextEnumWrapper { inner: AzOptionInlineText::None } }
    #[staticmethod]
    fn Some(v: AzInlineText) -> AzOptionInlineTextEnumWrapper { AzOptionInlineTextEnumWrapper { inner: AzOptionInlineText::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionInlineText;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionInlineText::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionInlineText::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionInlineTextEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::OptionInlineText = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::OptionInlineText = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLayoutPointEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLayoutPointEnumWrapper { AzOptionLayoutPointEnumWrapper { inner: AzOptionLayoutPoint::None } }
    #[staticmethod]
    fn Some(v: AzLayoutPoint) -> AzOptionLayoutPointEnumWrapper { AzOptionLayoutPointEnumWrapper { inner: AzOptionLayoutPoint::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionLayoutPoint;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLayoutPoint::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLayoutPoint::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLayoutPointEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionLayoutPoint = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionLayoutPoint = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLayoutSizeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLayoutSizeEnumWrapper { AzOptionLayoutSizeEnumWrapper { inner: AzOptionLayoutSize::None } }
    #[staticmethod]
    fn Some(v: AzLayoutSize) -> AzOptionLayoutSizeEnumWrapper { AzOptionLayoutSizeEnumWrapper { inner: AzOptionLayoutSize::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionLayoutSize;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLayoutSize::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLayoutSize::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLayoutSizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionLayoutSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionLayoutSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionWindowThemeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionWindowThemeEnumWrapper { AzOptionWindowThemeEnumWrapper { inner: AzOptionWindowTheme::None } }
    #[staticmethod]
    fn Some(v: AzWindowThemeEnumWrapper) -> AzOptionWindowThemeEnumWrapper { AzOptionWindowThemeEnumWrapper { inner: AzOptionWindowTheme::Some(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionWindowTheme;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionWindowTheme::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionWindowTheme::Some(v) => Ok(vec!["Some".into_py(py), { let m: &AzWindowThemeEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionWindowThemeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWindowTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWindowTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeIdEnumWrapper { AzOptionNodeIdEnumWrapper { inner: AzOptionNodeId::None } }
    #[staticmethod]
    fn Some(v: AzNodeId) -> AzOptionNodeIdEnumWrapper { AzOptionNodeIdEnumWrapper { inner: AzOptionNodeId::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionNodeId;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNodeId::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::OptionNodeId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::OptionNodeId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionDomNodeIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionDomNodeIdEnumWrapper { AzOptionDomNodeIdEnumWrapper { inner: AzOptionDomNodeId::None } }
    #[staticmethod]
    fn Some(v: AzDomNodeId) -> AzOptionDomNodeIdEnumWrapper { AzOptionDomNodeIdEnumWrapper { inner: AzOptionDomNodeId::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionDomNodeId;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionDomNodeId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionDomNodeId::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionDomNodeIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::OptionDomNodeId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::callbacks::OptionDomNodeId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionColorUEnumWrapper {
    #[classattr]
    fn None() -> AzOptionColorUEnumWrapper { AzOptionColorUEnumWrapper { inner: AzOptionColorU::None } }
    #[staticmethod]
    fn Some(v: AzColorU) -> AzOptionColorUEnumWrapper { AzOptionColorUEnumWrapper { inner: AzOptionColorU::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionColorU;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionColorU::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionColorU::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionColorUEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionColorU = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionColorU = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionRawImageEnumWrapper {
    #[classattr]
    fn None() -> AzOptionRawImageEnumWrapper { AzOptionRawImageEnumWrapper { inner: AzOptionRawImage::None } }
    #[staticmethod]
    fn Some(v: AzRawImage) -> AzOptionRawImageEnumWrapper { AzOptionRawImageEnumWrapper { inner: AzOptionRawImage::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionRawImage;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionRawImage::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionRawImage::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionRawImageEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::OptionRawImage = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::OptionRawImage = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionSvgDashPatternEnumWrapper {
    #[classattr]
    fn None() -> AzOptionSvgDashPatternEnumWrapper { AzOptionSvgDashPatternEnumWrapper { inner: AzOptionSvgDashPattern::None } }
    #[staticmethod]
    fn Some(v: AzSvgDashPattern) -> AzOptionSvgDashPatternEnumWrapper { AzOptionSvgDashPatternEnumWrapper { inner: AzOptionSvgDashPattern::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionSvgDashPattern;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionSvgDashPattern::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionSvgDashPattern::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionSvgDashPatternEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::OptionSvgDashPattern = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::OptionSvgDashPattern = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionWaylandThemeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionWaylandThemeEnumWrapper { AzOptionWaylandThemeEnumWrapper { inner: AzOptionWaylandTheme::None } }
    #[staticmethod]
    fn Some(v: AzWaylandTheme) -> AzOptionWaylandThemeEnumWrapper { AzOptionWaylandThemeEnumWrapper { inner: AzOptionWaylandTheme::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionWaylandTheme;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionWaylandTheme::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionWaylandTheme::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionWaylandThemeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWaylandTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWaylandTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTaskBarIconEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTaskBarIconEnumWrapper { AzOptionTaskBarIconEnumWrapper { inner: AzOptionTaskBarIcon::None } }
    #[staticmethod]
    fn Some(v: AzTaskBarIcon) -> AzOptionTaskBarIconEnumWrapper { AzOptionTaskBarIconEnumWrapper { inner: AzOptionTaskBarIcon::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTaskBarIcon;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTaskBarIcon::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTaskBarIcon::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTaskBarIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionTaskBarIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionTaskBarIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionHwndHandleEnumWrapper {
    #[classattr]
    fn None() -> AzOptionHwndHandleEnumWrapper { AzOptionHwndHandleEnumWrapper { inner: AzOptionHwndHandle::None } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionHwndHandle;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionHwndHandle::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionHwndHandle::Some(v) => Ok(vec!["Some".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionHwndHandleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionHwndHandle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionHwndHandle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLogicalPositionEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLogicalPositionEnumWrapper { AzOptionLogicalPositionEnumWrapper { inner: AzOptionLogicalPosition::None } }
    #[staticmethod]
    fn Some(v: AzLogicalPosition) -> AzOptionLogicalPositionEnumWrapper { AzOptionLogicalPositionEnumWrapper { inner: AzOptionLogicalPosition::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionLogicalPosition;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLogicalPosition::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLogicalPosition::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLogicalPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionLogicalPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionLogicalPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionPhysicalPositionI32EnumWrapper {
    #[classattr]
    fn None() -> AzOptionPhysicalPositionI32EnumWrapper { AzOptionPhysicalPositionI32EnumWrapper { inner: AzOptionPhysicalPositionI32::None } }
    #[staticmethod]
    fn Some(v: AzPhysicalPositionI32) -> AzOptionPhysicalPositionI32EnumWrapper { AzOptionPhysicalPositionI32EnumWrapper { inner: AzOptionPhysicalPositionI32::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionPhysicalPositionI32;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionPhysicalPositionI32::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionPhysicalPositionI32::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionPhysicalPositionI32EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionPhysicalPositionI32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionPhysicalPositionI32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionWindowIconEnumWrapper {
    #[classattr]
    fn None() -> AzOptionWindowIconEnumWrapper { AzOptionWindowIconEnumWrapper { inner: AzOptionWindowIcon::None } }
    #[staticmethod]
    fn Some(v: AzWindowIconEnumWrapper) -> AzOptionWindowIconEnumWrapper { AzOptionWindowIconEnumWrapper { inner: AzOptionWindowIcon::Some(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionWindowIcon;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionWindowIcon::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionWindowIcon::Some(v) => Ok(vec!["Some".into_py(py), { let m: &AzWindowIconEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionWindowIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWindowIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWindowIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionStringEnumWrapper {
    #[classattr]
    fn None() -> AzOptionStringEnumWrapper { AzOptionStringEnumWrapper { inner: AzOptionString::None } }
    #[staticmethod]
    fn Some(v: AzString) -> AzOptionStringEnumWrapper { AzOptionStringEnumWrapper { inner: AzOptionString::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionString;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionString::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionString::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionStringEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionAzString = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionAzString = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionX11VisualEnumWrapper {
    #[classattr]
    fn None() -> AzOptionX11VisualEnumWrapper { AzOptionX11VisualEnumWrapper { inner: AzOptionX11Visual::None } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionX11Visual;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionX11Visual::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionX11Visual::Some(v) => Ok(vec!["Some".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionX11VisualEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionX11Visual = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionX11Visual = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionI32EnumWrapper {
    #[classattr]
    fn None() -> AzOptionI32EnumWrapper { AzOptionI32EnumWrapper { inner: AzOptionI32::None } }
    #[staticmethod]
    fn Some(v: i32) -> AzOptionI32EnumWrapper { AzOptionI32EnumWrapper { inner: AzOptionI32::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionI32;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionI32::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionI32::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionI32EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionI32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionI32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionF32EnumWrapper {
    #[classattr]
    fn None() -> AzOptionF32EnumWrapper { AzOptionF32EnumWrapper { inner: AzOptionF32::None } }
    #[staticmethod]
    fn Some(v: f32) -> AzOptionF32EnumWrapper { AzOptionF32EnumWrapper { inner: AzOptionF32::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionF32;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionF32::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionF32::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionF32EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionF32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionF32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMouseCursorTypeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMouseCursorTypeEnumWrapper { AzOptionMouseCursorTypeEnumWrapper { inner: AzOptionMouseCursorType::None } }
    #[staticmethod]
    fn Some(v: AzMouseCursorTypeEnumWrapper) -> AzOptionMouseCursorTypeEnumWrapper { AzOptionMouseCursorTypeEnumWrapper { inner: AzOptionMouseCursorType::Some(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionMouseCursorType;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMouseCursorType::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMouseCursorType::Some(v) => Ok(vec!["Some".into_py(py), { let m: &AzMouseCursorTypeEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMouseCursorTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionMouseCursorType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionMouseCursorType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLogicalSizeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLogicalSizeEnumWrapper { AzOptionLogicalSizeEnumWrapper { inner: AzOptionLogicalSize::None } }
    #[staticmethod]
    fn Some(v: AzLogicalSize) -> AzOptionLogicalSizeEnumWrapper { AzOptionLogicalSizeEnumWrapper { inner: AzOptionLogicalSize::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionLogicalSize;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLogicalSize::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLogicalSize::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLogicalSizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionLogicalSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionLogicalSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionCharEnumWrapper {
    #[classattr]
    fn None() -> AzOptionCharEnumWrapper { AzOptionCharEnumWrapper { inner: AzOptionChar::None } }
    #[staticmethod]
    fn Some(v: u32) -> AzOptionCharEnumWrapper { AzOptionCharEnumWrapper { inner: AzOptionChar::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionChar;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionChar::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionChar::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionCharEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionChar = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionChar = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionVirtualKeyCodeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionVirtualKeyCodeEnumWrapper { AzOptionVirtualKeyCodeEnumWrapper { inner: AzOptionVirtualKeyCode::None } }
    #[staticmethod]
    fn Some(v: AzVirtualKeyCodeEnumWrapper) -> AzOptionVirtualKeyCodeEnumWrapper { AzOptionVirtualKeyCodeEnumWrapper { inner: AzOptionVirtualKeyCode::Some(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionVirtualKeyCode;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionVirtualKeyCode::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionVirtualKeyCode::Some(v) => Ok(vec!["Some".into_py(py), { let m: &AzVirtualKeyCodeEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionVirtualKeyCodeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionVirtualKeyCode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionVirtualKeyCode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionDomEnumWrapper {
    #[classattr]
    fn None() -> AzOptionDomEnumWrapper { AzOptionDomEnumWrapper { inner: AzOptionDom::None } }
    #[staticmethod]
    fn Some(v: AzDom) -> AzOptionDomEnumWrapper { AzOptionDomEnumWrapper { inner: AzOptionDom::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionDom;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionDom::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionDom::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionDomEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::OptionDom = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::OptionDom = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextureEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextureEnumWrapper { AzOptionTextureEnumWrapper { inner: AzOptionTexture::None } }
    #[staticmethod]
    fn Some(v: AzTexture) -> AzOptionTextureEnumWrapper { AzOptionTextureEnumWrapper { inner: AzOptionTexture::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTexture;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTexture::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTexture::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextureEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::OptionTexture = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::OptionTexture = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionImageMaskEnumWrapper {
    #[classattr]
    fn None() -> AzOptionImageMaskEnumWrapper { AzOptionImageMaskEnumWrapper { inner: AzOptionImageMask::None } }
    #[staticmethod]
    fn Some(v: AzImageMask) -> AzOptionImageMaskEnumWrapper { AzOptionImageMaskEnumWrapper { inner: AzOptionImageMask::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionImageMask;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionImageMask::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionImageMask::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionImageMaskEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::OptionImageMask = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::OptionImageMask = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTabIndexEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTabIndexEnumWrapper { AzOptionTabIndexEnumWrapper { inner: AzOptionTabIndex::None } }
    #[staticmethod]
    fn Some(v: AzTabIndexEnumWrapper) -> AzOptionTabIndexEnumWrapper { AzOptionTabIndexEnumWrapper { inner: AzOptionTabIndex::Some(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTabIndex;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTabIndex::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTabIndex::Some(v) => Ok(vec!["Some".into_py(py), { let m: &AzTabIndexEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTabIndexEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::OptionTabIndex = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::dom::OptionTabIndex = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTagIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTagIdEnumWrapper { AzOptionTagIdEnumWrapper { inner: AzOptionTagId::None } }
    #[staticmethod]
    fn Some(v: AzTagId) -> AzOptionTagIdEnumWrapper { AzOptionTagIdEnumWrapper { inner: AzOptionTagId::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTagId;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTagId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTagId::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTagIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::OptionTagId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::styled_dom::OptionTagId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionDurationEnumWrapper {
    #[classattr]
    fn None() -> AzOptionDurationEnumWrapper { AzOptionDurationEnumWrapper { inner: AzOptionDuration::None } }
    #[staticmethod]
    fn Some(v: AzDurationEnumWrapper) -> AzOptionDurationEnumWrapper { AzOptionDurationEnumWrapper { inner: AzOptionDuration::Some(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionDuration;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionDuration::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionDuration::Some(v) => Ok(vec!["Some".into_py(py), { let m: &AzDurationEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionDurationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::OptionDuration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::OptionDuration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionInstantEnumWrapper {
    #[classattr]
    fn None() -> AzOptionInstantEnumWrapper { AzOptionInstantEnumWrapper { inner: AzOptionInstant::None } }
    #[staticmethod]
    fn Some(v: AzInstantEnumWrapper) -> AzOptionInstantEnumWrapper { AzOptionInstantEnumWrapper { inner: AzOptionInstant::Some(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionInstant;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionInstant::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionInstant::Some(v) => Ok(vec!["Some".into_py(py), { let m: &AzInstantEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionInstantEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::OptionInstant = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::task::OptionInstant = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionUsizeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionUsizeEnumWrapper { AzOptionUsizeEnumWrapper { inner: AzOptionUsize::None } }
    #[staticmethod]
    fn Some(v: usize) -> AzOptionUsizeEnumWrapper { AzOptionUsizeEnumWrapper { inner: AzOptionUsize::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionUsize;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionUsize::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionUsize::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionUsizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::OptionUsize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::OptionUsize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionU8VecEnumWrapper {
    #[classattr]
    fn None() -> AzOptionU8VecEnumWrapper { AzOptionU8VecEnumWrapper { inner: AzOptionU8Vec::None } }
    #[staticmethod]
    fn Some(v: AzU8Vec) -> AzOptionU8VecEnumWrapper { AzOptionU8VecEnumWrapper { inner: AzOptionU8Vec::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionU8Vec;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionU8Vec::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionU8Vec::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionU8VecEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionU8Vec = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::css::OptionU8Vec = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionU8VecRefEnumWrapper {
    #[classattr]
    fn None() -> AzOptionU8VecRefEnumWrapper { AzOptionU8VecRefEnumWrapper { inner: AzOptionU8VecRef::None } }
    #[staticmethod]
    fn Some(v: AzU8VecRef) -> AzOptionU8VecRefEnumWrapper { AzOptionU8VecRefEnumWrapper { inner: AzOptionU8VecRef::Some(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionU8VecRef;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionU8VecRef::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionU8VecRef::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionU8VecRefEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::OptionU8VecRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::gl::OptionU8VecRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultXmlXmlErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: AzXml) -> AzResultXmlXmlErrorEnumWrapper { AzResultXmlXmlErrorEnumWrapper { inner: AzResultXmlXmlError::Ok(v) } }
    #[staticmethod]
    fn Err(v: AzXmlErrorEnumWrapper) -> AzResultXmlXmlErrorEnumWrapper { AzResultXmlXmlErrorEnumWrapper { inner: AzResultXmlXmlError::Err(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzResultXmlXmlError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultXmlXmlError::Ok(v) => Ok(vec!["Ok".into_py(py), v.clone().into_py(py)]),
            AzResultXmlXmlError::Err(v) => Ok(vec!["Err".into_py(py), { let m: &AzXmlErrorEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultXmlXmlErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::ResultXmlXmlError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::ResultXmlXmlError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultRawImageDecodeImageErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: AzRawImage) -> AzResultRawImageDecodeImageErrorEnumWrapper { AzResultRawImageDecodeImageErrorEnumWrapper { inner: AzResultRawImageDecodeImageError::Ok(v) } }
    #[staticmethod]
    fn Err(v: AzDecodeImageErrorEnumWrapper) -> AzResultRawImageDecodeImageErrorEnumWrapper { AzResultRawImageDecodeImageErrorEnumWrapper { inner: AzResultRawImageDecodeImageError::Err(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzResultRawImageDecodeImageError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultRawImageDecodeImageError::Ok(v) => Ok(vec!["Ok".into_py(py), v.clone().into_py(py)]),
            AzResultRawImageDecodeImageError::Err(v) => Ok(vec!["Err".into_py(py), { let m: &AzDecodeImageErrorEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultRawImageDecodeImageErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::decode::ResultRawImageDecodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::decode::ResultRawImageDecodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultU8VecEncodeImageErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: AzU8Vec) -> AzResultU8VecEncodeImageErrorEnumWrapper { AzResultU8VecEncodeImageErrorEnumWrapper { inner: AzResultU8VecEncodeImageError::Ok(v) } }
    #[staticmethod]
    fn Err(v: AzEncodeImageErrorEnumWrapper) -> AzResultU8VecEncodeImageErrorEnumWrapper { AzResultU8VecEncodeImageErrorEnumWrapper { inner: AzResultU8VecEncodeImageError::Err(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzResultU8VecEncodeImageError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultU8VecEncodeImageError::Ok(v) => Ok(vec!["Ok".into_py(py), v.clone().into_py(py)]),
            AzResultU8VecEncodeImageError::Err(v) => Ok(vec!["Err".into_py(py), { let m: &AzEncodeImageErrorEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultU8VecEncodeImageErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::encode::ResultU8VecEncodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::resources::encode::ResultU8VecEncodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultSvgXmlNodeSvgParseErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: AzSvgXmlNode) -> AzResultSvgXmlNodeSvgParseErrorEnumWrapper { AzResultSvgXmlNodeSvgParseErrorEnumWrapper { inner: AzResultSvgXmlNodeSvgParseError::Ok(v) } }
    #[staticmethod]
    fn Err(v: AzSvgParseErrorEnumWrapper) -> AzResultSvgXmlNodeSvgParseErrorEnumWrapper { AzResultSvgXmlNodeSvgParseErrorEnumWrapper { inner: AzResultSvgXmlNodeSvgParseError::Err(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzResultSvgXmlNodeSvgParseError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultSvgXmlNodeSvgParseError::Ok(v) => Ok(vec!["Ok".into_py(py), v.clone().into_py(py)]),
            AzResultSvgXmlNodeSvgParseError::Err(v) => Ok(vec!["Err".into_py(py), { let m: &AzSvgParseErrorEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultSvgXmlNodeSvgParseErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::ResultSvgXmlNodeSvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::ResultSvgXmlNodeSvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultSvgSvgParseErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: AzSvg) -> AzResultSvgSvgParseErrorEnumWrapper { AzResultSvgSvgParseErrorEnumWrapper { inner: AzResultSvgSvgParseError::Ok(v) } }
    #[staticmethod]
    fn Err(v: AzSvgParseErrorEnumWrapper) -> AzResultSvgSvgParseErrorEnumWrapper { AzResultSvgSvgParseErrorEnumWrapper { inner: AzResultSvgSvgParseError::Err(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzResultSvgSvgParseError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultSvgSvgParseError::Ok(v) => Ok(vec!["Ok".into_py(py), v.clone().into_py(py)]),
            AzResultSvgSvgParseError::Err(v) => Ok(vec!["Err".into_py(py), { let m: &AzSvgParseErrorEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultSvgSvgParseErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::ResultSvgSvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::ResultSvgSvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgParseErrorEnumWrapper {
    #[classattr]
    fn NoParserAvailable() -> AzSvgParseErrorEnumWrapper { AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::NoParserAvailable } }
    #[classattr]
    fn InvalidFileSuffix() -> AzSvgParseErrorEnumWrapper { AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::InvalidFileSuffix } }
    #[classattr]
    fn FileOpenFailed() -> AzSvgParseErrorEnumWrapper { AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::FileOpenFailed } }
    #[classattr]
    fn NotAnUtf8Str() -> AzSvgParseErrorEnumWrapper { AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::NotAnUtf8Str } }
    #[classattr]
    fn MalformedGZip() -> AzSvgParseErrorEnumWrapper { AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::MalformedGZip } }
    #[classattr]
    fn InvalidSize() -> AzSvgParseErrorEnumWrapper { AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::InvalidSize } }
    #[staticmethod]
    fn ParsingFailed(v: AzXmlErrorEnumWrapper) -> AzSvgParseErrorEnumWrapper { AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::ParsingFailed(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgParseError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgParseError::NoParserAvailable => Ok(vec!["NoParserAvailable".into_py(py), ().into_py(py)]),
            AzSvgParseError::InvalidFileSuffix => Ok(vec!["InvalidFileSuffix".into_py(py), ().into_py(py)]),
            AzSvgParseError::FileOpenFailed => Ok(vec!["FileOpenFailed".into_py(py), ().into_py(py)]),
            AzSvgParseError::NotAnUtf8Str => Ok(vec!["NotAnUtf8Str".into_py(py), ().into_py(py)]),
            AzSvgParseError::MalformedGZip => Ok(vec!["MalformedGZip".into_py(py), ().into_py(py)]),
            AzSvgParseError::InvalidSize => Ok(vec!["InvalidSize".into_py(py), ().into_py(py)]),
            AzSvgParseError::ParsingFailed(v) => Ok(vec!["ParsingFailed".into_py(py), { let m: &AzXmlErrorEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgParseErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::svg::SvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlErrorEnumWrapper {
    #[classattr]
    fn NoParserAvailable() -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::NoParserAvailable } }
    #[staticmethod]
    fn InvalidXmlPrefixUri(v: AzSvgParseErrorPosition) -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidXmlPrefixUri(v) } }
    #[staticmethod]
    fn UnexpectedXmlUri(v: AzSvgParseErrorPosition) -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::UnexpectedXmlUri(v) } }
    #[staticmethod]
    fn UnexpectedXmlnsUri(v: AzSvgParseErrorPosition) -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::UnexpectedXmlnsUri(v) } }
    #[staticmethod]
    fn InvalidElementNamePrefix(v: AzSvgParseErrorPosition) -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidElementNamePrefix(v) } }
    #[staticmethod]
    fn DuplicatedNamespace(v: AzDuplicatedNamespaceError) -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::DuplicatedNamespace(v) } }
    #[staticmethod]
    fn UnknownNamespace(v: AzUnknownNamespaceError) -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::UnknownNamespace(v) } }
    #[staticmethod]
    fn UnexpectedCloseTag(v: AzUnexpectedCloseTagError) -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::UnexpectedCloseTag(v) } }
    #[staticmethod]
    fn UnexpectedEntityCloseTag(v: AzSvgParseErrorPosition) -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::UnexpectedEntityCloseTag(v) } }
    #[staticmethod]
    fn UnknownEntityReference(v: AzUnknownEntityReferenceError) -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::UnknownEntityReference(v) } }
    #[staticmethod]
    fn MalformedEntityReference(v: AzSvgParseErrorPosition) -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::MalformedEntityReference(v) } }
    #[staticmethod]
    fn EntityReferenceLoop(v: AzSvgParseErrorPosition) -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::EntityReferenceLoop(v) } }
    #[staticmethod]
    fn InvalidAttributeValue(v: AzSvgParseErrorPosition) -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidAttributeValue(v) } }
    #[staticmethod]
    fn DuplicatedAttribute(v: AzDuplicatedAttributeError) -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::DuplicatedAttribute(v) } }
    #[classattr]
    fn NoRootNode() -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::NoRootNode } }
    #[classattr]
    fn SizeLimit() -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::SizeLimit } }
    #[staticmethod]
    fn ParserError(v: AzXmlParseErrorEnumWrapper) -> AzXmlErrorEnumWrapper { AzXmlErrorEnumWrapper { inner: AzXmlError::ParserError(unsafe { mem::transmute(v) }) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzXmlError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlError::NoParserAvailable => Ok(vec!["NoParserAvailable".into_py(py), ().into_py(py)]),
            AzXmlError::InvalidXmlPrefixUri(v) => Ok(vec!["InvalidXmlPrefixUri".into_py(py), v.clone().into_py(py)]),
            AzXmlError::UnexpectedXmlUri(v) => Ok(vec!["UnexpectedXmlUri".into_py(py), v.clone().into_py(py)]),
            AzXmlError::UnexpectedXmlnsUri(v) => Ok(vec!["UnexpectedXmlnsUri".into_py(py), v.clone().into_py(py)]),
            AzXmlError::InvalidElementNamePrefix(v) => Ok(vec!["InvalidElementNamePrefix".into_py(py), v.clone().into_py(py)]),
            AzXmlError::DuplicatedNamespace(v) => Ok(vec!["DuplicatedNamespace".into_py(py), v.clone().into_py(py)]),
            AzXmlError::UnknownNamespace(v) => Ok(vec!["UnknownNamespace".into_py(py), v.clone().into_py(py)]),
            AzXmlError::UnexpectedCloseTag(v) => Ok(vec!["UnexpectedCloseTag".into_py(py), v.clone().into_py(py)]),
            AzXmlError::UnexpectedEntityCloseTag(v) => Ok(vec!["UnexpectedEntityCloseTag".into_py(py), v.clone().into_py(py)]),
            AzXmlError::UnknownEntityReference(v) => Ok(vec!["UnknownEntityReference".into_py(py), v.clone().into_py(py)]),
            AzXmlError::MalformedEntityReference(v) => Ok(vec!["MalformedEntityReference".into_py(py), v.clone().into_py(py)]),
            AzXmlError::EntityReferenceLoop(v) => Ok(vec!["EntityReferenceLoop".into_py(py), v.clone().into_py(py)]),
            AzXmlError::InvalidAttributeValue(v) => Ok(vec!["InvalidAttributeValue".into_py(py), v.clone().into_py(py)]),
            AzXmlError::DuplicatedAttribute(v) => Ok(vec!["DuplicatedAttribute".into_py(py), v.clone().into_py(py)]),
            AzXmlError::NoRootNode => Ok(vec!["NoRootNode".into_py(py), ().into_py(py)]),
            AzXmlError::SizeLimit => Ok(vec!["SizeLimit".into_py(py), ().into_py(py)]),
            AzXmlError::ParserError(v) => Ok(vec!["ParserError".into_py(py), { let m: &AzXmlParseErrorEnumWrapper = unsafe { mem::transmute(v) }; m.clone() }.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::XmlError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::XmlError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDuplicatedNamespaceError {
    #[new]
    fn __new__(ns: AzString, pos: AzSvgParseErrorPosition) -> Self {
        Self {
            ns,
            pos,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzDuplicatedNamespaceError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::DuplicatedNamespaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::DuplicatedNamespaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUnknownNamespaceError {
    #[new]
    fn __new__(ns: AzString, pos: AzSvgParseErrorPosition) -> Self {
        Self {
            ns,
            pos,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzUnknownNamespaceError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::UnknownNamespaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::UnknownNamespaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUnexpectedCloseTagError {
    #[new]
    fn __new__(expected: AzString, actual: AzString, pos: AzSvgParseErrorPosition) -> Self {
        Self {
            expected,
            actual,
            pos,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzUnexpectedCloseTagError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::UnexpectedCloseTagError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::UnexpectedCloseTagError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUnknownEntityReferenceError {
    #[new]
    fn __new__(entity: AzString, pos: AzSvgParseErrorPosition) -> Self {
        Self {
            entity,
            pos,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzUnknownEntityReferenceError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::UnknownEntityReferenceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::UnknownEntityReferenceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDuplicatedAttributeError {
    #[new]
    fn __new__(attribute: AzString, pos: AzSvgParseErrorPosition) -> Self {
        Self {
            attribute,
            pos,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzDuplicatedAttributeError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::DuplicatedAttributeError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::DuplicatedAttributeError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlParseErrorEnumWrapper {
    #[staticmethod]
    fn InvalidDeclaration(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper { AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidDeclaration(v) } }
    #[staticmethod]
    fn InvalidComment(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper { AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidComment(v) } }
    #[staticmethod]
    fn InvalidPI(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper { AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidPI(v) } }
    #[staticmethod]
    fn InvalidDoctype(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper { AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidDoctype(v) } }
    #[staticmethod]
    fn InvalidEntity(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper { AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidEntity(v) } }
    #[staticmethod]
    fn InvalidElement(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper { AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidElement(v) } }
    #[staticmethod]
    fn InvalidAttribute(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper { AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidAttribute(v) } }
    #[staticmethod]
    fn InvalidCdata(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper { AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidCdata(v) } }
    #[staticmethod]
    fn InvalidCharData(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper { AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidCharData(v) } }
    #[staticmethod]
    fn UnknownToken(v: AzSvgParseErrorPosition) -> AzXmlParseErrorEnumWrapper { AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::UnknownToken(v) } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzXmlParseError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlParseError::InvalidDeclaration(v) => Ok(vec!["InvalidDeclaration".into_py(py), v.clone().into_py(py)]),
            AzXmlParseError::InvalidComment(v) => Ok(vec!["InvalidComment".into_py(py), v.clone().into_py(py)]),
            AzXmlParseError::InvalidPI(v) => Ok(vec!["InvalidPI".into_py(py), v.clone().into_py(py)]),
            AzXmlParseError::InvalidDoctype(v) => Ok(vec!["InvalidDoctype".into_py(py), v.clone().into_py(py)]),
            AzXmlParseError::InvalidEntity(v) => Ok(vec!["InvalidEntity".into_py(py), v.clone().into_py(py)]),
            AzXmlParseError::InvalidElement(v) => Ok(vec!["InvalidElement".into_py(py), v.clone().into_py(py)]),
            AzXmlParseError::InvalidAttribute(v) => Ok(vec!["InvalidAttribute".into_py(py), v.clone().into_py(py)]),
            AzXmlParseError::InvalidCdata(v) => Ok(vec!["InvalidCdata".into_py(py), v.clone().into_py(py)]),
            AzXmlParseError::InvalidCharData(v) => Ok(vec!["InvalidCharData".into_py(py), v.clone().into_py(py)]),
            AzXmlParseError::UnknownToken(v) => Ok(vec!["UnknownToken".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlParseErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::XmlParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::XmlParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlTextError {
    #[new]
    fn __new__(stream_error: AzXmlStreamErrorEnumWrapper, pos: AzSvgParseErrorPosition) -> Self {
        Self {
            stream_error,
            pos,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzXmlTextError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::XmlTextError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::XmlTextError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlStreamErrorEnumWrapper {
    #[classattr]
    fn UnexpectedEndOfStream() -> AzXmlStreamErrorEnumWrapper { AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::UnexpectedEndOfStream } }
    #[classattr]
    fn InvalidName() -> AzXmlStreamErrorEnumWrapper { AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidName } }
    #[staticmethod]
    fn NonXmlChar(v: AzNonXmlCharError) -> AzXmlStreamErrorEnumWrapper { AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::NonXmlChar(v) } }
    #[staticmethod]
    fn InvalidChar(v: AzInvalidCharError) -> AzXmlStreamErrorEnumWrapper { AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidChar(v) } }
    #[staticmethod]
    fn InvalidCharMultiple(v: AzInvalidCharMultipleError) -> AzXmlStreamErrorEnumWrapper { AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidCharMultiple(v) } }
    #[staticmethod]
    fn InvalidQuote(v: AzInvalidQuoteError) -> AzXmlStreamErrorEnumWrapper { AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidQuote(v) } }
    #[staticmethod]
    fn InvalidSpace(v: AzInvalidSpaceError) -> AzXmlStreamErrorEnumWrapper { AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidSpace(v) } }
    #[staticmethod]
    fn InvalidString(v: AzInvalidStringError) -> AzXmlStreamErrorEnumWrapper { AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidString(v) } }
    #[classattr]
    fn InvalidReference() -> AzXmlStreamErrorEnumWrapper { AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidReference } }
    #[classattr]
    fn InvalidExternalID() -> AzXmlStreamErrorEnumWrapper { AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidExternalID } }
    #[classattr]
    fn InvalidCommentData() -> AzXmlStreamErrorEnumWrapper { AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidCommentData } }
    #[classattr]
    fn InvalidCommentEnd() -> AzXmlStreamErrorEnumWrapper { AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidCommentEnd } }
    #[classattr]
    fn InvalidCharacterData() -> AzXmlStreamErrorEnumWrapper { AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidCharacterData } }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzXmlStreamError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlStreamError::UnexpectedEndOfStream => Ok(vec!["UnexpectedEndOfStream".into_py(py), ().into_py(py)]),
            AzXmlStreamError::InvalidName => Ok(vec!["InvalidName".into_py(py), ().into_py(py)]),
            AzXmlStreamError::NonXmlChar(v) => Ok(vec!["NonXmlChar".into_py(py), v.clone().into_py(py)]),
            AzXmlStreamError::InvalidChar(v) => Ok(vec!["InvalidChar".into_py(py), v.clone().into_py(py)]),
            AzXmlStreamError::InvalidCharMultiple(v) => Ok(vec!["InvalidCharMultiple".into_py(py), v.clone().into_py(py)]),
            AzXmlStreamError::InvalidQuote(v) => Ok(vec!["InvalidQuote".into_py(py), v.clone().into_py(py)]),
            AzXmlStreamError::InvalidSpace(v) => Ok(vec!["InvalidSpace".into_py(py), v.clone().into_py(py)]),
            AzXmlStreamError::InvalidString(v) => Ok(vec!["InvalidString".into_py(py), v.clone().into_py(py)]),
            AzXmlStreamError::InvalidReference => Ok(vec!["InvalidReference".into_py(py), ().into_py(py)]),
            AzXmlStreamError::InvalidExternalID => Ok(vec!["InvalidExternalID".into_py(py), ().into_py(py)]),
            AzXmlStreamError::InvalidCommentData => Ok(vec!["InvalidCommentData".into_py(py), ().into_py(py)]),
            AzXmlStreamError::InvalidCommentEnd => Ok(vec!["InvalidCommentEnd".into_py(py), ().into_py(py)]),
            AzXmlStreamError::InvalidCharacterData => Ok(vec!["InvalidCharacterData".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlStreamErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::XmlStreamError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::XmlStreamError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNonXmlCharError {
    #[new]
    fn __new__(ch: u32, pos: AzSvgParseErrorPosition) -> Self {
        Self {
            ch,
            pos,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzNonXmlCharError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::NonXmlCharError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::NonXmlCharError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidCharError {
    #[new]
    fn __new__(expected: u8, got: u8, pos: AzSvgParseErrorPosition) -> Self {
        Self {
            expected,
            got,
            pos,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInvalidCharError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::InvalidCharError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::InvalidCharError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidCharMultipleError {
    #[new]
    fn __new__(expected: u8, got: AzU8Vec, pos: AzSvgParseErrorPosition) -> Self {
        Self {
            expected,
            got,
            pos,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInvalidCharMultipleError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::InvalidCharMultipleError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::InvalidCharMultipleError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidQuoteError {
    #[new]
    fn __new__(got: u8, pos: AzSvgParseErrorPosition) -> Self {
        Self {
            got,
            pos,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInvalidQuoteError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::InvalidQuoteError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::InvalidQuoteError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidSpaceError {
    #[new]
    fn __new__(got: u8, pos: AzSvgParseErrorPosition) -> Self {
        Self {
            got,
            pos,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInvalidSpaceError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::InvalidSpaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::InvalidSpaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidStringError {
    #[new]
    fn __new__(got: AzString, pos: AzSvgParseErrorPosition) -> Self {
        Self {
            got,
            pos,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzInvalidStringError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::InvalidStringError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::InvalidStringError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgParseErrorPosition {
    #[new]
    fn __new__(row: u32, col: u32) -> Self {
        Self {
            row,
            col,
        }
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgParseErrorPosition {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::XmlTextPos = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_impl::xml::XmlTextPos = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}


impl core::convert::From<AzDecodeImageError> for PyErr {
    fn from(err: AzDecodeImageError) -> PyErr {
        let r: azul_impl::resources::decode::DecodeImageError = unsafe { mem::transmute(err) };
        PyException::new_err(format!("{}", r))
    }
}

impl core::convert::From<AzEncodeImageError> for PyErr {
    fn from(err: AzEncodeImageError) -> PyErr {
        let r: azul_impl::resources::encode::EncodeImageError = unsafe { mem::transmute(err) };
        PyException::new_err(format!("{}", r))
    }
}

impl core::convert::From<AzSvgParseError> for PyErr {
    fn from(err: AzSvgParseError) -> PyErr {
        let r: azul_impl::svg::SvgParseError = unsafe { mem::transmute(err) };
        PyException::new_err(format!("{}", r))
    }
}

impl core::convert::From<AzXmlError> for PyErr {
    fn from(err: AzXmlError) -> PyErr {
        let r: azul_impl::xml::XmlError = unsafe { mem::transmute(err) };
        PyException::new_err(format!("{}", r))
    }
}

#[pymodule]
fn azul(py: Python, m: &PyModule) -> PyResult<()> {

    #[cfg(all(feature = "use_pyo3_logger", not(feature = "use_fern_logger")))] {
        let mut filter = log::LevelFilter ::Warn;

        if std::env::var("AZUL_PY_LOGLEVEL_ERROR").is_ok() { filter = log::LevelFilter ::Error; }
        if std::env::var("AZUL_PY_LOGLEVEL_WARN").is_ok() { filter = log::LevelFilter ::Warn; }
        if std::env::var("AZUL_PY_LOGLEVEL_INFO").is_ok() { filter = log::LevelFilter ::Info; }
        if std::env::var("AZUL_PY_LOGLEVEL_DEBUG").is_ok() { filter = log::LevelFilter ::Debug; }
        if std::env::var("AZUL_PY_LOGLEVEL_TRACE").is_ok() { filter = log::LevelFilter ::Trace; }
        if std::env::var("AZUL_PY_LOGLEVEL_OFF").is_ok() { filter = log::LevelFilter ::Off; }

    }

    m.add_class::<AzApp>()?;
    m.add_class::<AzAppConfig>()?;
    m.add_class::<AzAppLogLevelEnumWrapper>()?;
    m.add_class::<AzLayoutSolverEnumWrapper>()?;
    m.add_class::<AzSystemCallbacks>()?;

    m.add_class::<AzWindowCreateOptions>()?;
    m.add_class::<AzRendererOptions>()?;
    m.add_class::<AzVsyncEnumWrapper>()?;
    m.add_class::<AzSrgbEnumWrapper>()?;
    m.add_class::<AzHwAccelerationEnumWrapper>()?;
    m.add_class::<AzLayoutPoint>()?;
    m.add_class::<AzLayoutSize>()?;
    m.add_class::<AzLayoutRect>()?;
    m.add_class::<AzRawWindowHandleEnumWrapper>()?;
    m.add_class::<AzIOSHandle>()?;
    m.add_class::<AzMacOSHandle>()?;
    m.add_class::<AzXlibHandle>()?;
    m.add_class::<AzXcbHandle>()?;
    m.add_class::<AzWaylandHandle>()?;
    m.add_class::<AzWindowsHandle>()?;
    m.add_class::<AzWebHandle>()?;
    m.add_class::<AzAndroidHandle>()?;
    m.add_class::<AzXWindowTypeEnumWrapper>()?;
    m.add_class::<AzPhysicalPositionI32>()?;
    m.add_class::<AzPhysicalSizeU32>()?;
    m.add_class::<AzLogicalRect>()?;
    m.add_class::<AzLogicalPosition>()?;
    m.add_class::<AzLogicalSize>()?;
    m.add_class::<AzIconKey>()?;
    m.add_class::<AzSmallWindowIconBytes>()?;
    m.add_class::<AzLargeWindowIconBytes>()?;
    m.add_class::<AzWindowIconEnumWrapper>()?;
    m.add_class::<AzTaskBarIcon>()?;
    m.add_class::<AzVirtualKeyCodeEnumWrapper>()?;
    m.add_class::<AzAcceleratorKeyEnumWrapper>()?;
    m.add_class::<AzWindowSize>()?;
    m.add_class::<AzWindowFlags>()?;
    m.add_class::<AzWindowFrameEnumWrapper>()?;
    m.add_class::<AzDebugState>()?;
    m.add_class::<AzKeyboardState>()?;
    m.add_class::<AzMouseCursorTypeEnumWrapper>()?;
    m.add_class::<AzCursorPositionEnumWrapper>()?;
    m.add_class::<AzMouseState>()?;
    m.add_class::<AzPlatformSpecificOptions>()?;
    m.add_class::<AzWindowsWindowOptions>()?;
    m.add_class::<AzWaylandTheme>()?;
    m.add_class::<AzRendererTypeEnumWrapper>()?;
    m.add_class::<AzStringPair>()?;
    m.add_class::<AzLinuxWindowOptions>()?;
    m.add_class::<AzMacWindowOptions>()?;
    m.add_class::<AzWasmWindowOptions>()?;
    m.add_class::<AzFullScreenModeEnumWrapper>()?;
    m.add_class::<AzWindowThemeEnumWrapper>()?;
    m.add_class::<AzWindowPositionEnumWrapper>()?;
    m.add_class::<AzImePositionEnumWrapper>()?;
    m.add_class::<AzTouchState>()?;
    m.add_class::<AzMonitor>()?;
    m.add_class::<AzVideoMode>()?;
    m.add_class::<AzWindowState>()?;

    m.add_class::<AzLayoutCallbackEnumWrapper>()?;
    m.add_class::<AzMarshaledLayoutCallback>()?;
    m.add_class::<AzMarshaledLayoutCallbackInner>()?;
    m.add_class::<AzLayoutCallbackInner>()?;
    m.add_class::<AzCallback>()?;
    m.add_class::<AzCallbackInfo>()?;
    m.add_class::<AzUpdateImageTypeEnumWrapper>()?;
    m.add_class::<AzUpdateEnumWrapper>()?;
    m.add_class::<AzNodeId>()?;
    m.add_class::<AzDomId>()?;
    m.add_class::<AzDomNodeId>()?;
    m.add_class::<AzPositionInfoEnumWrapper>()?;
    m.add_class::<AzPositionInfoInner>()?;
    m.add_class::<AzHidpiAdjustedBounds>()?;
    m.add_class::<AzInlineText>()?;
    m.add_class::<AzInlineLine>()?;
    m.add_class::<AzInlineWordEnumWrapper>()?;
    m.add_class::<AzInlineTextContents>()?;
    m.add_class::<AzInlineGlyph>()?;
    m.add_class::<AzInlineTextHit>()?;
    m.add_class::<AzFocusTargetEnumWrapper>()?;
    m.add_class::<AzFocusTargetPath>()?;
    m.add_class::<AzResolvedTextLayoutOptions>()?;
    m.add_class::<AzAnimation>()?;
    m.add_class::<AzAnimationRepeatEnumWrapper>()?;
    m.add_class::<AzAnimationRepeatCountEnumWrapper>()?;
    m.add_class::<AzAnimationEasingEnumWrapper>()?;
    m.add_class::<AzIFrameCallback>()?;
    m.add_class::<AzIFrameCallbackInfo>()?;
    m.add_class::<AzIFrameCallbackReturn>()?;
    m.add_class::<AzRenderImageCallback>()?;
    m.add_class::<AzRenderImageCallbackInfo>()?;
    m.add_class::<AzTimerCallback>()?;
    m.add_class::<AzTimerCallbackInfo>()?;
    m.add_class::<AzTimerCallbackReturn>()?;
    m.add_class::<AzWriteBackCallback>()?;
    m.add_class::<AzThreadCallback>()?;
    m.add_class::<AzRefCount>()?;
    m.add_class::<AzRefAny>()?;
    m.add_class::<AzLayoutCallbackInfo>()?;

    m.add_class::<AzDom>()?;
    m.add_class::<AzIFrameNode>()?;
    m.add_class::<AzCallbackData>()?;
    m.add_class::<AzNodeData>()?;
    m.add_class::<AzNodeTypeEnumWrapper>()?;
    m.add_class::<AzOnEnumWrapper>()?;
    m.add_class::<AzEventFilterEnumWrapper>()?;
    m.add_class::<AzHoverEventFilterEnumWrapper>()?;
    m.add_class::<AzFocusEventFilterEnumWrapper>()?;
    m.add_class::<AzNotEventFilterEnumWrapper>()?;
    m.add_class::<AzWindowEventFilterEnumWrapper>()?;
    m.add_class::<AzComponentEventFilterEnumWrapper>()?;
    m.add_class::<AzApplicationEventFilterEnumWrapper>()?;
    m.add_class::<AzAccessibilityInfo>()?;
    m.add_class::<AzAccessibilityRoleEnumWrapper>()?;
    m.add_class::<AzAccessibilityStateEnumWrapper>()?;
    m.add_class::<AzTabIndexEnumWrapper>()?;
    m.add_class::<AzIdOrClassEnumWrapper>()?;
    m.add_class::<AzNodeDataInlineCssPropertyEnumWrapper>()?;

    m.add_class::<AzMenu>()?;
    m.add_class::<AzContextMenuMouseButtonEnumWrapper>()?;
    m.add_class::<AzMenuPopupPositionEnumWrapper>()?;
    m.add_class::<AzMenuItemEnumWrapper>()?;
    m.add_class::<AzStringMenuItem>()?;
    m.add_class::<AzVirtualKeyCodeCombo>()?;
    m.add_class::<AzMenuCallback>()?;
    m.add_class::<AzMenuItemIconEnumWrapper>()?;
    m.add_class::<AzMenuItemStateEnumWrapper>()?;

    m.add_class::<AzCssRuleBlock>()?;
    m.add_class::<AzCssDeclarationEnumWrapper>()?;
    m.add_class::<AzDynamicCssProperty>()?;
    m.add_class::<AzCssPath>()?;
    m.add_class::<AzCssPathSelectorEnumWrapper>()?;
    m.add_class::<AzNodeTypeKeyEnumWrapper>()?;
    m.add_class::<AzCssPathPseudoSelectorEnumWrapper>()?;
    m.add_class::<AzCssNthChildSelectorEnumWrapper>()?;
    m.add_class::<AzCssNthChildPattern>()?;
    m.add_class::<AzStylesheet>()?;
    m.add_class::<AzCss>()?;
    m.add_class::<AzCssPropertyTypeEnumWrapper>()?;
    m.add_class::<AzAnimationInterpolationFunctionEnumWrapper>()?;
    m.add_class::<AzInterpolateContext>()?;
    m.add_class::<AzColorU>()?;
    m.add_class::<AzSizeMetricEnumWrapper>()?;
    m.add_class::<AzFloatValue>()?;
    m.add_class::<AzPixelValue>()?;
    m.add_class::<AzPixelValueNoPercent>()?;
    m.add_class::<AzBoxShadowClipModeEnumWrapper>()?;
    m.add_class::<AzStyleBoxShadow>()?;
    m.add_class::<AzLayoutAlignContentEnumWrapper>()?;
    m.add_class::<AzLayoutAlignItemsEnumWrapper>()?;
    m.add_class::<AzLayoutBottom>()?;
    m.add_class::<AzLayoutBoxSizingEnumWrapper>()?;
    m.add_class::<AzLayoutFlexDirectionEnumWrapper>()?;
    m.add_class::<AzLayoutDisplayEnumWrapper>()?;
    m.add_class::<AzLayoutFlexGrow>()?;
    m.add_class::<AzLayoutFlexShrink>()?;
    m.add_class::<AzLayoutFloatEnumWrapper>()?;
    m.add_class::<AzLayoutHeight>()?;
    m.add_class::<AzLayoutJustifyContentEnumWrapper>()?;
    m.add_class::<AzLayoutLeft>()?;
    m.add_class::<AzLayoutMarginBottom>()?;
    m.add_class::<AzLayoutMarginLeft>()?;
    m.add_class::<AzLayoutMarginRight>()?;
    m.add_class::<AzLayoutMarginTop>()?;
    m.add_class::<AzLayoutMaxHeight>()?;
    m.add_class::<AzLayoutMaxWidth>()?;
    m.add_class::<AzLayoutMinHeight>()?;
    m.add_class::<AzLayoutMinWidth>()?;
    m.add_class::<AzLayoutPaddingBottom>()?;
    m.add_class::<AzLayoutPaddingLeft>()?;
    m.add_class::<AzLayoutPaddingRight>()?;
    m.add_class::<AzLayoutPaddingTop>()?;
    m.add_class::<AzLayoutPositionEnumWrapper>()?;
    m.add_class::<AzLayoutRight>()?;
    m.add_class::<AzLayoutTop>()?;
    m.add_class::<AzLayoutWidth>()?;
    m.add_class::<AzLayoutFlexWrapEnumWrapper>()?;
    m.add_class::<AzLayoutOverflowEnumWrapper>()?;
    m.add_class::<AzPercentageValue>()?;
    m.add_class::<AzAngleMetricEnumWrapper>()?;
    m.add_class::<AzAngleValue>()?;
    m.add_class::<AzNormalizedLinearColorStop>()?;
    m.add_class::<AzNormalizedRadialColorStop>()?;
    m.add_class::<AzDirectionCornerEnumWrapper>()?;
    m.add_class::<AzDirectionCorners>()?;
    m.add_class::<AzDirectionEnumWrapper>()?;
    m.add_class::<AzExtendModeEnumWrapper>()?;
    m.add_class::<AzLinearGradient>()?;
    m.add_class::<AzShapeEnumWrapper>()?;
    m.add_class::<AzRadialGradientSizeEnumWrapper>()?;
    m.add_class::<AzRadialGradient>()?;
    m.add_class::<AzConicGradient>()?;
    m.add_class::<AzStyleBackgroundContentEnumWrapper>()?;
    m.add_class::<AzBackgroundPositionHorizontalEnumWrapper>()?;
    m.add_class::<AzBackgroundPositionVerticalEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundPosition>()?;
    m.add_class::<AzStyleBackgroundRepeatEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundSizeEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomColor>()?;
    m.add_class::<AzStyleBorderBottomLeftRadius>()?;
    m.add_class::<AzStyleBorderBottomRightRadius>()?;
    m.add_class::<AzBorderStyleEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomStyle>()?;
    m.add_class::<AzLayoutBorderBottomWidth>()?;
    m.add_class::<AzStyleBorderLeftColor>()?;
    m.add_class::<AzStyleBorderLeftStyle>()?;
    m.add_class::<AzLayoutBorderLeftWidth>()?;
    m.add_class::<AzStyleBorderRightColor>()?;
    m.add_class::<AzStyleBorderRightStyle>()?;
    m.add_class::<AzLayoutBorderRightWidth>()?;
    m.add_class::<AzStyleBorderTopColor>()?;
    m.add_class::<AzStyleBorderTopLeftRadius>()?;
    m.add_class::<AzStyleBorderTopRightRadius>()?;
    m.add_class::<AzStyleBorderTopStyle>()?;
    m.add_class::<AzLayoutBorderTopWidth>()?;
    m.add_class::<AzScrollbarInfo>()?;
    m.add_class::<AzScrollbarStyle>()?;
    m.add_class::<AzStyleCursorEnumWrapper>()?;
    m.add_class::<AzStyleFontFamilyEnumWrapper>()?;
    m.add_class::<AzStyleFontSize>()?;
    m.add_class::<AzStyleLetterSpacing>()?;
    m.add_class::<AzStyleLineHeight>()?;
    m.add_class::<AzStyleTabWidth>()?;
    m.add_class::<AzStyleOpacity>()?;
    m.add_class::<AzStyleTransformOrigin>()?;
    m.add_class::<AzStylePerspectiveOrigin>()?;
    m.add_class::<AzStyleBackfaceVisibilityEnumWrapper>()?;
    m.add_class::<AzStyleTransformEnumWrapper>()?;
    m.add_class::<AzStyleTransformMatrix2D>()?;
    m.add_class::<AzStyleTransformMatrix3D>()?;
    m.add_class::<AzStyleTransformTranslate2D>()?;
    m.add_class::<AzStyleTransformTranslate3D>()?;
    m.add_class::<AzStyleTransformRotate3D>()?;
    m.add_class::<AzStyleTransformScale2D>()?;
    m.add_class::<AzStyleTransformScale3D>()?;
    m.add_class::<AzStyleTransformSkew2D>()?;
    m.add_class::<AzStyleTextAlignEnumWrapper>()?;
    m.add_class::<AzStyleTextColor>()?;
    m.add_class::<AzStyleWordSpacing>()?;
    m.add_class::<AzStyleBoxShadowValueEnumWrapper>()?;
    m.add_class::<AzLayoutAlignContentValueEnumWrapper>()?;
    m.add_class::<AzLayoutAlignItemsValueEnumWrapper>()?;
    m.add_class::<AzLayoutBottomValueEnumWrapper>()?;
    m.add_class::<AzLayoutBoxSizingValueEnumWrapper>()?;
    m.add_class::<AzLayoutFlexDirectionValueEnumWrapper>()?;
    m.add_class::<AzLayoutDisplayValueEnumWrapper>()?;
    m.add_class::<AzLayoutFlexGrowValueEnumWrapper>()?;
    m.add_class::<AzLayoutFlexShrinkValueEnumWrapper>()?;
    m.add_class::<AzLayoutFloatValueEnumWrapper>()?;
    m.add_class::<AzLayoutHeightValueEnumWrapper>()?;
    m.add_class::<AzLayoutJustifyContentValueEnumWrapper>()?;
    m.add_class::<AzLayoutLeftValueEnumWrapper>()?;
    m.add_class::<AzLayoutMarginBottomValueEnumWrapper>()?;
    m.add_class::<AzLayoutMarginLeftValueEnumWrapper>()?;
    m.add_class::<AzLayoutMarginRightValueEnumWrapper>()?;
    m.add_class::<AzLayoutMarginTopValueEnumWrapper>()?;
    m.add_class::<AzLayoutMaxHeightValueEnumWrapper>()?;
    m.add_class::<AzLayoutMaxWidthValueEnumWrapper>()?;
    m.add_class::<AzLayoutMinHeightValueEnumWrapper>()?;
    m.add_class::<AzLayoutMinWidthValueEnumWrapper>()?;
    m.add_class::<AzLayoutPaddingBottomValueEnumWrapper>()?;
    m.add_class::<AzLayoutPaddingLeftValueEnumWrapper>()?;
    m.add_class::<AzLayoutPaddingRightValueEnumWrapper>()?;
    m.add_class::<AzLayoutPaddingTopValueEnumWrapper>()?;
    m.add_class::<AzLayoutPositionValueEnumWrapper>()?;
    m.add_class::<AzLayoutRightValueEnumWrapper>()?;
    m.add_class::<AzLayoutTopValueEnumWrapper>()?;
    m.add_class::<AzLayoutWidthValueEnumWrapper>()?;
    m.add_class::<AzLayoutFlexWrapValueEnumWrapper>()?;
    m.add_class::<AzLayoutOverflowValueEnumWrapper>()?;
    m.add_class::<AzScrollbarStyleValueEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundContentVecValueEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundPositionVecValueEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundRepeatVecValueEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundSizeVecValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomColorValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomLeftRadiusValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomRightRadiusValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomStyleValueEnumWrapper>()?;
    m.add_class::<AzLayoutBorderBottomWidthValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderLeftColorValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderLeftStyleValueEnumWrapper>()?;
    m.add_class::<AzLayoutBorderLeftWidthValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderRightColorValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderRightStyleValueEnumWrapper>()?;
    m.add_class::<AzLayoutBorderRightWidthValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderTopColorValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderTopLeftRadiusValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderTopRightRadiusValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderTopStyleValueEnumWrapper>()?;
    m.add_class::<AzLayoutBorderTopWidthValueEnumWrapper>()?;
    m.add_class::<AzStyleCursorValueEnumWrapper>()?;
    m.add_class::<AzStyleFontFamilyVecValueEnumWrapper>()?;
    m.add_class::<AzStyleFontSizeValueEnumWrapper>()?;
    m.add_class::<AzStyleLetterSpacingValueEnumWrapper>()?;
    m.add_class::<AzStyleLineHeightValueEnumWrapper>()?;
    m.add_class::<AzStyleTabWidthValueEnumWrapper>()?;
    m.add_class::<AzStyleTextAlignValueEnumWrapper>()?;
    m.add_class::<AzStyleTextColorValueEnumWrapper>()?;
    m.add_class::<AzStyleWordSpacingValueEnumWrapper>()?;
    m.add_class::<AzStyleOpacityValueEnumWrapper>()?;
    m.add_class::<AzStyleTransformVecValueEnumWrapper>()?;
    m.add_class::<AzStyleTransformOriginValueEnumWrapper>()?;
    m.add_class::<AzStylePerspectiveOriginValueEnumWrapper>()?;
    m.add_class::<AzStyleBackfaceVisibilityValueEnumWrapper>()?;
    m.add_class::<AzCssPropertyEnumWrapper>()?;

    m.add_class::<AzButton>()?;
    m.add_class::<AzButtonOnClick>()?;
    m.add_class::<AzCheckBox>()?;
    m.add_class::<AzCheckBoxStateWrapper>()?;
    m.add_class::<AzCheckBoxOnToggle>()?;
    m.add_class::<AzCheckBoxOnToggleCallback>()?;
    m.add_class::<AzCheckBoxState>()?;
    m.add_class::<AzLabel>()?;
    m.add_class::<AzColorInput>()?;
    m.add_class::<AzColorInputStateWrapper>()?;
    m.add_class::<AzColorInputState>()?;
    m.add_class::<AzColorInputOnValueChange>()?;
    m.add_class::<AzColorInputOnValueChangeCallback>()?;
    m.add_class::<AzTextInput>()?;
    m.add_class::<AzTextInputStateWrapper>()?;
    m.add_class::<AzTextInputState>()?;
    m.add_class::<AzTextInputSelectionEnumWrapper>()?;
    m.add_class::<AzTextInputSelectionRange>()?;
    m.add_class::<AzTextInputOnTextInput>()?;
    m.add_class::<AzTextInputOnTextInputCallback>()?;
    m.add_class::<AzTextInputOnVirtualKeyDown>()?;
    m.add_class::<AzTextInputOnVirtualKeyDownCallback>()?;
    m.add_class::<AzTextInputOnFocusLost>()?;
    m.add_class::<AzTextInputOnFocusLostCallback>()?;
    m.add_class::<AzOnTextInputReturn>()?;
    m.add_class::<AzTextInputValidEnumWrapper>()?;
    m.add_class::<AzNumberInput>()?;
    m.add_class::<AzNumberInputStateWrapper>()?;
    m.add_class::<AzNumberInputState>()?;
    m.add_class::<AzNumberInputOnValueChange>()?;
    m.add_class::<AzNumberInputOnValueChangeCallback>()?;
    m.add_class::<AzNumberInputOnFocusLost>()?;
    m.add_class::<AzNumberInputOnFocusLostCallback>()?;
    m.add_class::<AzProgressBar>()?;
    m.add_class::<AzProgressBarState>()?;
    m.add_class::<AzTabContainer>()?;
    m.add_class::<AzTab>()?;
    m.add_class::<AzFrame>()?;
    m.add_class::<AzNodeGraph>()?;
    m.add_class::<AzNodeTypeIdInfoMap>()?;
    m.add_class::<AzInputOutputTypeIdInfoMap>()?;
    m.add_class::<AzNodeIdNodeMap>()?;
    m.add_class::<AzNodeGraphStyleEnumWrapper>()?;
    m.add_class::<AzNodeGraphCallbacks>()?;
    m.add_class::<AzNodeGraphOnNodeAddedCallback>()?;
    m.add_class::<AzNodeGraphOnNodeAdded>()?;
    m.add_class::<AzNodeGraphOnNodeRemovedCallback>()?;
    m.add_class::<AzNodeGraphOnNodeRemoved>()?;
    m.add_class::<AzNodeGraphOnNodeGraphDraggedCallback>()?;
    m.add_class::<AzNodeGraphOnNodeGraphDragged>()?;
    m.add_class::<AzNodeGraphOnNodeDraggedCallback>()?;
    m.add_class::<AzNodeGraphOnNodeDragged>()?;
    m.add_class::<AzNodeGraphOnNodeConnectedCallback>()?;
    m.add_class::<AzNodeGraphOnNodeConnected>()?;
    m.add_class::<AzNodeGraphOnNodeInputDisconnectedCallback>()?;
    m.add_class::<AzNodeGraphOnNodeInputDisconnected>()?;
    m.add_class::<AzNodeGraphOnNodeOutputDisconnectedCallback>()?;
    m.add_class::<AzNodeGraphOnNodeOutputDisconnected>()?;
    m.add_class::<AzNodeGraphOnNodeFieldEditedCallback>()?;
    m.add_class::<AzNodeGraphOnNodeFieldEdited>()?;
    m.add_class::<AzInputOutputTypeId>()?;
    m.add_class::<AzNodeTypeId>()?;
    m.add_class::<AzNodeGraphNodeId>()?;
    m.add_class::<AzNode>()?;
    m.add_class::<AzNodeTypeField>()?;
    m.add_class::<AzNodeTypeFieldValueEnumWrapper>()?;
    m.add_class::<AzInputConnection>()?;
    m.add_class::<AzOutputNodeAndIndex>()?;
    m.add_class::<AzOutputConnection>()?;
    m.add_class::<AzInputNodeAndIndex>()?;
    m.add_class::<AzNodeTypeInfo>()?;
    m.add_class::<AzInputOutputInfo>()?;
    m.add_class::<AzNodePosition>()?;
    m.add_class::<AzGraphDragAmount>()?;
    m.add_class::<AzNodeDragAmount>()?;
    m.add_class::<AzListView>()?;
    m.add_class::<AzTreeView>()?;
    m.add_class::<AzDropDown>()?;
    m.add_class::<AzDropDownOnChoiceChangeCallback>()?;
    m.add_class::<AzDropDownOnChoiceChange>()?;

    m.add_class::<AzNodeHierarchyItem>()?;
    m.add_class::<AzCascadeInfo>()?;
    m.add_class::<AzCssPropertySourceEnumWrapper>()?;
    m.add_class::<AzStyledNodeState>()?;
    m.add_class::<AzStyledNode>()?;
    m.add_class::<AzTagId>()?;
    m.add_class::<AzTagIdToNodeIdMapping>()?;
    m.add_class::<AzParentWithNodeDepth>()?;
    m.add_class::<AzCssPropertyCache>()?;
    m.add_class::<AzStyledDom>()?;

    m.add_class::<AzTexture>()?;
    m.add_class::<AzGlVoidPtrConst>()?;
    m.add_class::<AzGlVoidPtrMut>()?;
    m.add_class::<AzGl>()?;
    m.add_class::<AzGlShaderPrecisionFormatReturn>()?;
    m.add_class::<AzVertexAttributeTypeEnumWrapper>()?;
    m.add_class::<AzVertexAttribute>()?;
    m.add_class::<AzVertexLayout>()?;
    m.add_class::<AzVertexArrayObject>()?;
    m.add_class::<AzIndexBufferFormatEnumWrapper>()?;
    m.add_class::<AzVertexBuffer>()?;
    m.add_class::<AzGlTypeEnumWrapper>()?;
    m.add_class::<AzDebugMessage>()?;
    m.add_class::<AzU8VecRef>()?;
    m.add_class::<AzU8VecRefMut>()?;
    m.add_class::<AzF32VecRef>()?;
    m.add_class::<AzI32VecRef>()?;
    m.add_class::<AzGLuintVecRef>()?;
    m.add_class::<AzGLenumVecRef>()?;
    m.add_class::<AzGLintVecRefMut>()?;
    m.add_class::<AzGLint64VecRefMut>()?;
    m.add_class::<AzGLbooleanVecRefMut>()?;
    m.add_class::<AzGLfloatVecRefMut>()?;
    m.add_class::<AzRefstrVecRef>()?;
    m.add_class::<AzRefstr>()?;
    m.add_class::<AzGetProgramBinaryReturn>()?;
    m.add_class::<AzGetActiveAttribReturn>()?;
    m.add_class::<AzGLsyncPtr>()?;
    m.add_class::<AzGetActiveUniformReturn>()?;
    m.add_class::<AzTextureFlags>()?;

    m.add_class::<AzImageRef>()?;
    m.add_class::<AzRawImage>()?;
    m.add_class::<AzImageMask>()?;
    m.add_class::<AzRawImageFormatEnumWrapper>()?;
    m.add_class::<AzEncodeImageErrorEnumWrapper>()?;
    m.add_class::<AzDecodeImageErrorEnumWrapper>()?;
    m.add_class::<AzRawImageDataEnumWrapper>()?;

    m.add_class::<AzFontMetrics>()?;
    m.add_class::<AzFontSource>()?;
    m.add_class::<AzFontRef>()?;

    m.add_class::<AzSvg>()?;
    m.add_class::<AzSvgXmlNode>()?;
    m.add_class::<AzSvgMultiPolygon>()?;
    m.add_class::<AzSvgNodeEnumWrapper>()?;
    m.add_class::<AzSvgStyledNode>()?;
    m.add_class::<AzSvgCircle>()?;
    m.add_class::<AzSvgPath>()?;
    m.add_class::<AzSvgPathElementEnumWrapper>()?;
    m.add_class::<AzSvgLine>()?;
    m.add_class::<AzSvgPoint>()?;
    m.add_class::<AzSvgQuadraticCurve>()?;
    m.add_class::<AzSvgCubicCurve>()?;
    m.add_class::<AzSvgRect>()?;
    m.add_class::<AzSvgVertex>()?;
    m.add_class::<AzTessellatedSvgNode>()?;
    m.add_class::<AzTessellatedSvgNodeVecRef>()?;
    m.add_class::<AzTessellatedGPUSvgNode>()?;
    m.add_class::<AzSvgParseOptions>()?;
    m.add_class::<AzShapeRenderingEnumWrapper>()?;
    m.add_class::<AzTextRenderingEnumWrapper>()?;
    m.add_class::<AzImageRenderingEnumWrapper>()?;
    m.add_class::<AzFontDatabaseEnumWrapper>()?;
    m.add_class::<AzSvgRenderOptions>()?;
    m.add_class::<AzSvgStringFormatOptions>()?;
    m.add_class::<AzIndentEnumWrapper>()?;
    m.add_class::<AzSvgFitToEnumWrapper>()?;
    m.add_class::<AzSvgStyleEnumWrapper>()?;
    m.add_class::<AzSvgFillRuleEnumWrapper>()?;
    m.add_class::<AzSvgTransform>()?;
    m.add_class::<AzSvgFillStyle>()?;
    m.add_class::<AzSvgStrokeStyle>()?;
    m.add_class::<AzSvgLineJoinEnumWrapper>()?;
    m.add_class::<AzSvgLineCapEnumWrapper>()?;
    m.add_class::<AzSvgDashPattern>()?;

    m.add_class::<AzXml>()?;
    m.add_class::<AzXmlNode>()?;

    m.add_class::<AzFile>()?;

    m.add_class::<AzMsgBox>()?;
    m.add_class::<AzMsgBoxIconEnumWrapper>()?;
    m.add_class::<AzMsgBoxYesNoEnumWrapper>()?;
    m.add_class::<AzMsgBoxOkCancelEnumWrapper>()?;
    m.add_class::<AzFileDialog>()?;
    m.add_class::<AzFileTypeList>()?;
    m.add_class::<AzColorPickerDialog>()?;

    m.add_class::<AzSystemClipboard>()?;

    m.add_class::<AzInstantEnumWrapper>()?;
    m.add_class::<AzInstantPtr>()?;
    m.add_class::<AzInstantPtrCloneFn>()?;
    m.add_class::<AzInstantPtrDestructorFn>()?;
    m.add_class::<AzSystemTick>()?;
    m.add_class::<AzDurationEnumWrapper>()?;
    m.add_class::<AzSystemTimeDiff>()?;
    m.add_class::<AzSystemTickDiff>()?;

    m.add_class::<AzTimerId>()?;
    m.add_class::<AzTimer>()?;
    m.add_class::<AzTerminateTimerEnumWrapper>()?;
    m.add_class::<AzThreadId>()?;
    m.add_class::<AzThread>()?;
    m.add_class::<AzThreadSender>()?;
    m.add_class::<AzThreadReceiver>()?;
    m.add_class::<AzThreadSendMsgEnumWrapper>()?;
    m.add_class::<AzThreadReceiveMsgEnumWrapper>()?;
    m.add_class::<AzThreadWriteBackMsg>()?;
    m.add_class::<AzCreateThreadFn>()?;
    m.add_class::<AzGetSystemTimeFn>()?;
    m.add_class::<AzCheckThreadFinishedFn>()?;
    m.add_class::<AzLibrarySendThreadMsgFn>()?;
    m.add_class::<AzLibraryReceiveThreadMsgFn>()?;
    m.add_class::<AzThreadRecvFn>()?;
    m.add_class::<AzThreadSendFn>()?;
    m.add_class::<AzThreadDestructorFn>()?;
    m.add_class::<AzThreadReceiverDestructorFn>()?;
    m.add_class::<AzThreadSenderDestructorFn>()?;

    m.add_class::<AzFmtValueEnumWrapper>()?;
    m.add_class::<AzFmtArg>()?;
    m.add_class::<AzString>()?;

    m.add_class::<AzLogicalRectVec>()?;
    m.add_class::<AzNodeTypeIdInfoMapVec>()?;
    m.add_class::<AzInputOutputTypeIdInfoMapVec>()?;
    m.add_class::<AzNodeIdNodeMapVec>()?;
    m.add_class::<AzInputOutputTypeIdVec>()?;
    m.add_class::<AzNodeTypeFieldVec>()?;
    m.add_class::<AzInputConnectionVec>()?;
    m.add_class::<AzOutputNodeAndIndexVec>()?;
    m.add_class::<AzOutputConnectionVec>()?;
    m.add_class::<AzInputNodeAndIndexVec>()?;
    m.add_class::<AzTabVec>()?;
    m.add_class::<AzAccessibilityStateVec>()?;
    m.add_class::<AzMenuItemVec>()?;
    m.add_class::<AzTessellatedSvgNodeVec>()?;
    m.add_class::<AzStyleFontFamilyVec>()?;
    m.add_class::<AzXmlNodeVec>()?;
    m.add_class::<AzFmtArgVec>()?;
    m.add_class::<AzInlineLineVec>()?;
    m.add_class::<AzInlineWordVec>()?;
    m.add_class::<AzInlineGlyphVec>()?;
    m.add_class::<AzInlineTextHitVec>()?;
    m.add_class::<AzMonitorVec>()?;
    m.add_class::<AzVideoModeVec>()?;
    m.add_class::<AzDomVec>()?;
    m.add_class::<AzIdOrClassVec>()?;
    m.add_class::<AzNodeDataInlineCssPropertyVec>()?;
    m.add_class::<AzStyleBackgroundContentVec>()?;
    m.add_class::<AzStyleBackgroundPositionVec>()?;
    m.add_class::<AzStyleBackgroundRepeatVec>()?;
    m.add_class::<AzStyleBackgroundSizeVec>()?;
    m.add_class::<AzStyleTransformVec>()?;
    m.add_class::<AzCssPropertyVec>()?;
    m.add_class::<AzSvgMultiPolygonVec>()?;
    m.add_class::<AzSvgPathVec>()?;
    m.add_class::<AzVertexAttributeVec>()?;
    m.add_class::<AzSvgPathElementVec>()?;
    m.add_class::<AzSvgVertexVec>()?;
    m.add_class::<AzU32Vec>()?;
    m.add_class::<AzXWindowTypeVec>()?;
    m.add_class::<AzVirtualKeyCodeVec>()?;
    m.add_class::<AzCascadeInfoVec>()?;
    m.add_class::<AzScanCodeVec>()?;
    m.add_class::<AzCssDeclarationVec>()?;
    m.add_class::<AzCssPathSelectorVec>()?;
    m.add_class::<AzStylesheetVec>()?;
    m.add_class::<AzCssRuleBlockVec>()?;
    m.add_class::<AzU16Vec>()?;
    m.add_class::<AzF32Vec>()?;
    m.add_class::<AzU8Vec>()?;
    m.add_class::<AzCallbackDataVec>()?;
    m.add_class::<AzDebugMessageVec>()?;
    m.add_class::<AzGLuintVec>()?;
    m.add_class::<AzGLintVec>()?;
    m.add_class::<AzStringVec>()?;
    m.add_class::<AzStringPairVec>()?;
    m.add_class::<AzNormalizedLinearColorStopVec>()?;
    m.add_class::<AzNormalizedRadialColorStopVec>()?;
    m.add_class::<AzNodeIdVec>()?;
    m.add_class::<AzNodeHierarchyItemVec>()?;
    m.add_class::<AzStyledNodeVec>()?;
    m.add_class::<AzTagIdToNodeIdMappingVec>()?;
    m.add_class::<AzParentWithNodeDepthVec>()?;
    m.add_class::<AzNodeDataVec>()?;
    m.add_class::<AzStyleFontFamilyVecDestructorEnumWrapper>()?;
    m.add_class::<AzLogicalRectVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeTypeIdInfoMapVecDestructorEnumWrapper>()?;
    m.add_class::<AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeIdNodeMapVecDestructorEnumWrapper>()?;
    m.add_class::<AzInputOutputTypeIdVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeTypeFieldVecDestructorEnumWrapper>()?;
    m.add_class::<AzInputConnectionVecDestructorEnumWrapper>()?;
    m.add_class::<AzOutputNodeAndIndexVecDestructorEnumWrapper>()?;
    m.add_class::<AzOutputConnectionVecDestructorEnumWrapper>()?;
    m.add_class::<AzInputNodeAndIndexVecDestructorEnumWrapper>()?;
    m.add_class::<AzTabVecDestructorEnumWrapper>()?;
    m.add_class::<AzAccessibilityStateVecDestructorEnumWrapper>()?;
    m.add_class::<AzMenuItemVecDestructorEnumWrapper>()?;
    m.add_class::<AzTessellatedSvgNodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzXmlNodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzFmtArgVecDestructorEnumWrapper>()?;
    m.add_class::<AzInlineLineVecDestructorEnumWrapper>()?;
    m.add_class::<AzInlineWordVecDestructorEnumWrapper>()?;
    m.add_class::<AzInlineGlyphVecDestructorEnumWrapper>()?;
    m.add_class::<AzInlineTextHitVecDestructorEnumWrapper>()?;
    m.add_class::<AzMonitorVecDestructorEnumWrapper>()?;
    m.add_class::<AzVideoModeVecDestructorEnumWrapper>()?;
    m.add_class::<AzDomVecDestructorEnumWrapper>()?;
    m.add_class::<AzIdOrClassVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeDataInlineCssPropertyVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundContentVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundPositionVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundRepeatVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundSizeVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleTransformVecDestructorEnumWrapper>()?;
    m.add_class::<AzCssPropertyVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgMultiPolygonVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgPathVecDestructorEnumWrapper>()?;
    m.add_class::<AzVertexAttributeVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgPathElementVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgVertexVecDestructorEnumWrapper>()?;
    m.add_class::<AzU32VecDestructorEnumWrapper>()?;
    m.add_class::<AzXWindowTypeVecDestructorEnumWrapper>()?;
    m.add_class::<AzVirtualKeyCodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzCascadeInfoVecDestructorEnumWrapper>()?;
    m.add_class::<AzScanCodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzCssDeclarationVecDestructorEnumWrapper>()?;
    m.add_class::<AzCssPathSelectorVecDestructorEnumWrapper>()?;
    m.add_class::<AzStylesheetVecDestructorEnumWrapper>()?;
    m.add_class::<AzCssRuleBlockVecDestructorEnumWrapper>()?;
    m.add_class::<AzF32VecDestructorEnumWrapper>()?;
    m.add_class::<AzU16VecDestructorEnumWrapper>()?;
    m.add_class::<AzU8VecDestructorEnumWrapper>()?;
    m.add_class::<AzCallbackDataVecDestructorEnumWrapper>()?;
    m.add_class::<AzDebugMessageVecDestructorEnumWrapper>()?;
    m.add_class::<AzGLuintVecDestructorEnumWrapper>()?;
    m.add_class::<AzGLintVecDestructorEnumWrapper>()?;
    m.add_class::<AzStringVecDestructorEnumWrapper>()?;
    m.add_class::<AzStringPairVecDestructorEnumWrapper>()?;
    m.add_class::<AzNormalizedLinearColorStopVecDestructorEnumWrapper>()?;
    m.add_class::<AzNormalizedRadialColorStopVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeIdVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeHierarchyItemVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyledNodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzTagIdToNodeIdMappingVecDestructorEnumWrapper>()?;
    m.add_class::<AzParentWithNodeDepthVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeDataVecDestructorEnumWrapper>()?;

    m.add_class::<AzOptionDropDownOnChoiceChangeEnumWrapper>()?;
    m.add_class::<AzOptionResolvedTextLayoutOptionsEnumWrapper>()?;
    m.add_class::<AzOptionNodeGraphOnNodeAddedEnumWrapper>()?;
    m.add_class::<AzOptionNodeGraphOnNodeRemovedEnumWrapper>()?;
    m.add_class::<AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper>()?;
    m.add_class::<AzOptionNodeGraphOnNodeDraggedEnumWrapper>()?;
    m.add_class::<AzOptionNodeGraphOnNodeConnectedEnumWrapper>()?;
    m.add_class::<AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper>()?;
    m.add_class::<AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper>()?;
    m.add_class::<AzOptionNodeGraphOnNodeFieldEditedEnumWrapper>()?;
    m.add_class::<AzOptionColorInputOnValueChangeEnumWrapper>()?;
    m.add_class::<AzOptionButtonOnClickEnumWrapper>()?;
    m.add_class::<AzOptionCheckBoxOnToggleEnumWrapper>()?;
    m.add_class::<AzOptionTextInputOnTextInputEnumWrapper>()?;
    m.add_class::<AzOptionTextInputOnVirtualKeyDownEnumWrapper>()?;
    m.add_class::<AzOptionTextInputOnFocusLostEnumWrapper>()?;
    m.add_class::<AzOptionTextInputSelectionEnumWrapper>()?;
    m.add_class::<AzOptionNumberInputOnFocusLostEnumWrapper>()?;
    m.add_class::<AzOptionNumberInputOnValueChangeEnumWrapper>()?;
    m.add_class::<AzOptionMenuItemIconEnumWrapper>()?;
    m.add_class::<AzOptionMenuCallbackEnumWrapper>()?;
    m.add_class::<AzOptionVirtualKeyCodeComboEnumWrapper>()?;
    m.add_class::<AzOptionCssPropertyEnumWrapper>()?;
    m.add_class::<AzOptionPositionInfoEnumWrapper>()?;
    m.add_class::<AzOptionTimerIdEnumWrapper>()?;
    m.add_class::<AzOptionThreadIdEnumWrapper>()?;
    m.add_class::<AzOptionI16EnumWrapper>()?;
    m.add_class::<AzOptionU16EnumWrapper>()?;
    m.add_class::<AzOptionU32EnumWrapper>()?;
    m.add_class::<AzOptionImageRefEnumWrapper>()?;
    m.add_class::<AzOptionFontRefEnumWrapper>()?;
    m.add_class::<AzOptionSystemClipboardEnumWrapper>()?;
    m.add_class::<AzOptionFileTypeListEnumWrapper>()?;
    m.add_class::<AzOptionWindowStateEnumWrapper>()?;
    m.add_class::<AzOptionMouseStateEnumWrapper>()?;
    m.add_class::<AzOptionKeyboardStateEnumWrapper>()?;
    m.add_class::<AzOptionStringVecEnumWrapper>()?;
    m.add_class::<AzOptionFileEnumWrapper>()?;
    m.add_class::<AzOptionGlEnumWrapper>()?;
    m.add_class::<AzOptionThreadReceiveMsgEnumWrapper>()?;
    m.add_class::<AzOptionPercentageValueEnumWrapper>()?;
    m.add_class::<AzOptionAngleValueEnumWrapper>()?;
    m.add_class::<AzOptionRendererOptionsEnumWrapper>()?;
    m.add_class::<AzOptionCallbackEnumWrapper>()?;
    m.add_class::<AzOptionThreadSendMsgEnumWrapper>()?;
    m.add_class::<AzOptionLayoutRectEnumWrapper>()?;
    m.add_class::<AzOptionRefAnyEnumWrapper>()?;
    m.add_class::<AzOptionInlineTextEnumWrapper>()?;
    m.add_class::<AzOptionLayoutPointEnumWrapper>()?;
    m.add_class::<AzOptionLayoutSizeEnumWrapper>()?;
    m.add_class::<AzOptionWindowThemeEnumWrapper>()?;
    m.add_class::<AzOptionNodeIdEnumWrapper>()?;
    m.add_class::<AzOptionDomNodeIdEnumWrapper>()?;
    m.add_class::<AzOptionColorUEnumWrapper>()?;
    m.add_class::<AzOptionRawImageEnumWrapper>()?;
    m.add_class::<AzOptionSvgDashPatternEnumWrapper>()?;
    m.add_class::<AzOptionWaylandThemeEnumWrapper>()?;
    m.add_class::<AzOptionTaskBarIconEnumWrapper>()?;
    m.add_class::<AzOptionHwndHandleEnumWrapper>()?;
    m.add_class::<AzOptionLogicalPositionEnumWrapper>()?;
    m.add_class::<AzOptionPhysicalPositionI32EnumWrapper>()?;
    m.add_class::<AzOptionWindowIconEnumWrapper>()?;
    m.add_class::<AzOptionStringEnumWrapper>()?;
    m.add_class::<AzOptionX11VisualEnumWrapper>()?;
    m.add_class::<AzOptionI32EnumWrapper>()?;
    m.add_class::<AzOptionF32EnumWrapper>()?;
    m.add_class::<AzOptionMouseCursorTypeEnumWrapper>()?;
    m.add_class::<AzOptionLogicalSizeEnumWrapper>()?;
    m.add_class::<AzOptionCharEnumWrapper>()?;
    m.add_class::<AzOptionVirtualKeyCodeEnumWrapper>()?;
    m.add_class::<AzOptionDomEnumWrapper>()?;
    m.add_class::<AzOptionTextureEnumWrapper>()?;
    m.add_class::<AzOptionImageMaskEnumWrapper>()?;
    m.add_class::<AzOptionTabIndexEnumWrapper>()?;
    m.add_class::<AzOptionTagIdEnumWrapper>()?;
    m.add_class::<AzOptionDurationEnumWrapper>()?;
    m.add_class::<AzOptionInstantEnumWrapper>()?;
    m.add_class::<AzOptionUsizeEnumWrapper>()?;
    m.add_class::<AzOptionU8VecEnumWrapper>()?;
    m.add_class::<AzOptionU8VecRefEnumWrapper>()?;

    m.add_class::<AzResultXmlXmlErrorEnumWrapper>()?;
    m.add_class::<AzResultRawImageDecodeImageErrorEnumWrapper>()?;
    m.add_class::<AzResultU8VecEncodeImageErrorEnumWrapper>()?;
    m.add_class::<AzResultSvgXmlNodeSvgParseErrorEnumWrapper>()?;
    m.add_class::<AzResultSvgSvgParseErrorEnumWrapper>()?;
    m.add_class::<AzSvgParseErrorEnumWrapper>()?;
    m.add_class::<AzXmlErrorEnumWrapper>()?;
    m.add_class::<AzDuplicatedNamespaceError>()?;
    m.add_class::<AzUnknownNamespaceError>()?;
    m.add_class::<AzUnexpectedCloseTagError>()?;
    m.add_class::<AzUnknownEntityReferenceError>()?;
    m.add_class::<AzDuplicatedAttributeError>()?;
    m.add_class::<AzXmlParseErrorEnumWrapper>()?;
    m.add_class::<AzXmlTextError>()?;
    m.add_class::<AzXmlStreamErrorEnumWrapper>()?;
    m.add_class::<AzNonXmlCharError>()?;
    m.add_class::<AzInvalidCharError>()?;
    m.add_class::<AzInvalidCharMultipleError>()?;
    m.add_class::<AzInvalidQuoteError>()?;
    m.add_class::<AzInvalidSpaceError>()?;
    m.add_class::<AzInvalidStringError>()?;
    m.add_class::<AzSvgParseErrorPosition>()?;

    Ok(())
}

