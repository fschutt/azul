//! DOM Reconciliation Module
//!
//! This module provides the reconciliation algorithm that compares two DOM trees
//! and generates lifecycle events. It uses stable keys and content hashing to
//! identify moves vs. mounts/unmounts.
//!
//! The reconciliation strategy is:
//! 1. **Stable Key Match:** If `.with_key()` is used, it's an absolute match (O(1)).
//! 2. **Hash Match (Content Match):** If no key, check if there is an unused node in the old
//!    list with the exact same `DomNodeHash`. This enables "automagic" reordering detection.
//! 3. **Fallback:** Anything not matched is a `Mount` (new) or `Unmount` (old leftovers).

use alloc::{collections::VecDeque, vec::Vec};

use crate::{
    dom::{DomId, DomNodeHash, DomNodeId, NodeData},
    events::{
        ComponentEventFilter, EventData, EventFilter, EventPhase, EventSource, EventType,
        LifecycleEventData, LifecycleReason, SyntheticEvent,
    },
    geom::LogicalRect,
    id::NodeId,
    styled_dom::NodeHierarchyItemId,
    task::Instant,
    FastHashMap,
};

/// Represents a mapping between a node in the old DOM and the new DOM.
#[derive(Debug, Clone, Copy)]
pub struct NodeMove {
    /// The NodeId in the old DOM array
    pub old_node_id: NodeId,
    /// The NodeId in the new DOM array
    pub new_node_id: NodeId,
}

/// The result of a DOM diff, containing lifecycle events and node mappings.
#[derive(Debug, Clone)]
pub struct DiffResult {
    /// Lifecycle events generated by the diff (Mount, Unmount, Resize, Update)
    pub events: Vec<SyntheticEvent>,
    /// Maps Old NodeId -> New NodeId for state migration (focus, scroll, etc.)
    pub node_moves: Vec<NodeMove>,
}

impl Default for DiffResult {
    fn default() -> Self {
        Self {
            events: Vec::new(),
            node_moves: Vec::new(),
        }
    }
}

/// Calculates the difference between two DOM frames and generates lifecycle events.
///
/// This is the main entry point for DOM reconciliation. It compares the old and new
/// DOM trees and produces:
/// - Mount events for new nodes
/// - Unmount events for removed nodes
/// - Resize events for nodes whose bounds changed
/// - Update events for nodes whose content changed (when matched by key)
///
/// # Arguments
/// * `old_node_data` - Node data from the previous frame
/// * `new_node_data` - Node data from the current frame
/// * `old_layout` - Layout bounds from the previous frame
/// * `new_layout` - Layout bounds from the current frame
/// * `dom_id` - The DOM identifier
/// * `timestamp` - Current timestamp for events
pub fn reconcile_dom(
    old_node_data: &[NodeData],
    new_node_data: &[NodeData],
    old_layout: &FastHashMap<NodeId, LogicalRect>,
    new_layout: &FastHashMap<NodeId, LogicalRect>,
    dom_id: DomId,
    timestamp: Instant,
) -> DiffResult {
    let mut result = DiffResult::default();

    // --- STEP 1: INDEX THE OLD DOM ---
    // Create lookups to find old nodes by Key or by Hash.

    let mut old_keyed: FastHashMap<u64, NodeId> = FastHashMap::default();
    let mut old_hashed: FastHashMap<DomNodeHash, VecDeque<NodeId>> = FastHashMap::default();
    let mut old_nodes_consumed = vec![false; old_node_data.len()];

    for (idx, node) in old_node_data.iter().enumerate() {
        let id = NodeId::new(idx);

        if let Some(key) = node.get_key() {
            // Priority 1: Explicit Key
            old_keyed.insert(key, id);
        } else {
            // Priority 2: Content Hash
            let hash = node.calculate_node_data_hash();
            old_hashed.entry(hash).or_default().push_back(id);
        }
    }

    // --- STEP 2: ITERATE NEW DOM AND CLAIM MATCHES ---

    for (new_idx, new_node) in new_node_data.iter().enumerate() {
        let new_id = NodeId::new(new_idx);
        let mut matched_old_id = None;

        // A. Try Match by Key
        if let Some(key) = new_node.get_key() {
            if let Some(&old_id) = old_keyed.get(&key) {
                if !old_nodes_consumed[old_id.index()] {
                    matched_old_id = Some(old_id);
                }
            }
        }
        // B. Try Match by Content Hash (The "Automagic" Reordering)
        else {
            let hash = new_node.calculate_node_data_hash();

            // Get the queue of old nodes with this identical content
            if let Some(queue) = old_hashed.get_mut(&hash) {
                // Find first non-consumed node in queue
                while let Some(old_id) = queue.front() {
                    if !old_nodes_consumed[old_id.index()] {
                        matched_old_id = Some(*old_id);
                        queue.pop_front();
                        break;
                    } else {
                        queue.pop_front();
                    }
                }
            }
        }

        // --- STEP 3: PROCESS MATCH OR MOUNT ---

        if let Some(old_id) = matched_old_id {
            // FOUND A MATCH (It might be at a different index, but it's the "same" node)

            old_nodes_consumed[old_id.index()] = true;
            result.node_moves.push(NodeMove {
                old_node_id: old_id,
                new_node_id: new_id,
            });

            // Check for Resize
            let old_rect = old_layout.get(&old_id).copied().unwrap_or(LogicalRect::zero());
            let new_rect = new_layout.get(&new_id).copied().unwrap_or(LogicalRect::zero());

            if old_rect.size != new_rect.size {
                // Fire Resize Event
                if has_resize_callback(new_node) {
                    result.events.push(create_lifecycle_event(
                        EventType::Resize,
                        new_id,
                        dom_id,
                        &timestamp,
                        LifecycleEventData {
                            reason: LifecycleReason::Resize,
                            previous_bounds: Some(old_rect),
                            current_bounds: new_rect,
                        },
                    ));
                }
            }

            // If matched by Key, the content might have changed, so we should check hash equality.
            if new_node.get_key().is_some() {
                let old_hash = old_node_data[old_id.index()].calculate_node_data_hash();
                let new_hash = new_node.calculate_node_data_hash();

                if old_hash != new_hash && has_update_callback(new_node) {
                    result.events.push(create_lifecycle_event(
                        EventType::Update,
                        new_id,
                        dom_id,
                        &timestamp,
                        LifecycleEventData {
                            reason: LifecycleReason::Update,
                            previous_bounds: Some(old_rect),
                            current_bounds: new_rect,
                        },
                    ));
                }
            }
        } else {
            // NO MATCH FOUND -> MOUNT (New Node)
            if has_mount_callback(new_node) {
                let bounds = new_layout.get(&new_id).copied().unwrap_or(LogicalRect::zero());
                result.events.push(create_lifecycle_event(
                    EventType::Mount,
                    new_id,
                    dom_id,
                    &timestamp,
                    LifecycleEventData {
                        reason: LifecycleReason::InitialMount,
                        previous_bounds: None,
                        current_bounds: bounds,
                    },
                ));
            }
        }
    }

    // --- STEP 4: CLEANUP (UNMOUNTS) ---
    // Any old node that wasn't claimed is effectively destroyed.

    for (old_idx, consumed) in old_nodes_consumed.iter().enumerate() {
        if !consumed {
            let old_id = NodeId::new(old_idx);
            let old_node = &old_node_data[old_idx];

            if has_unmount_callback(old_node) {
                let bounds = old_layout.get(&old_id).copied().unwrap_or(LogicalRect::zero());
                result.events.push(create_lifecycle_event(
                    EventType::Unmount,
                    old_id,
                    dom_id,
                    &timestamp,
                    LifecycleEventData {
                        reason: LifecycleReason::InitialMount, // Context implies unmount
                        previous_bounds: Some(bounds),
                        current_bounds: LogicalRect::zero(),
                    },
                ));
            }
        }
    }

    result
}

/// Creates a lifecycle event with all necessary fields.
fn create_lifecycle_event(
    event_type: EventType,
    node_id: NodeId,
    dom_id: DomId,
    timestamp: &Instant,
    data: LifecycleEventData,
) -> SyntheticEvent {
    let dom_node_id = DomNodeId {
        dom: dom_id,
        node: NodeHierarchyItemId::from_crate_internal(Some(node_id)),
    };
    SyntheticEvent {
        event_type,
        source: EventSource::Lifecycle,
        phase: EventPhase::Target,
        target: dom_node_id,
        current_target: dom_node_id,
        timestamp: timestamp.clone(),
        data: EventData::Lifecycle(data),
        stopped: false,
        stopped_immediate: false,
        prevented_default: false,
    }
}

/// Check if the node has an AfterMount callback registered.
fn has_mount_callback(node: &NodeData) -> bool {
    node.get_callbacks().iter().any(|cb| {
        matches!(
            cb.event,
            EventFilter::Component(ComponentEventFilter::AfterMount)
        )
    })
}

/// Check if the node has a BeforeUnmount callback registered.
fn has_unmount_callback(node: &NodeData) -> bool {
    node.get_callbacks().iter().any(|cb| {
        matches!(
            cb.event,
            EventFilter::Component(ComponentEventFilter::BeforeUnmount)
        )
    })
}

/// Check if the node has a NodeResized callback registered.
fn has_resize_callback(node: &NodeData) -> bool {
    node.get_callbacks().iter().any(|cb| {
        matches!(
            cb.event,
            EventFilter::Component(ComponentEventFilter::NodeResized)
        )
    })
}

/// Check if the node has any lifecycle callback that would respond to updates.
fn has_update_callback(node: &NodeData) -> bool {
    // For now, we use Selected as a placeholder for "update" events
    // This could be extended to a dedicated UpdateCallback in the future
    node.get_callbacks().iter().any(|cb| {
        matches!(
            cb.event,
            EventFilter::Component(ComponentEventFilter::Selected)
        )
    })
}

/// Migrate state (focus, scroll, etc.) from old node IDs to new node IDs.
///
/// This function should be called after reconciliation to update any state
/// that references old NodeIds to use the new NodeIds.
///
/// # Example
/// ```rust
/// let diff = reconcile_dom(...);
/// let migration_map = create_migration_map(&diff.node_moves);
/// 
/// // Migrate focus
/// if let Some(current_focus) = focus_manager.focused_node {
///     if let Some(&new_id) = migration_map.get(&current_focus) {
///         focus_manager.focused_node = Some(new_id);
///     } else {
///         // Focused node was unmounted, clear focus
///         focus_manager.focused_node = None;
///     }
/// }
/// ```
pub fn create_migration_map(node_moves: &[NodeMove]) -> FastHashMap<NodeId, NodeId> {
    let mut map = FastHashMap::default();
    for m in node_moves {
        map.insert(m.old_node_id, m.new_node_id);
    }
    map
}

/// Executes state migration between the old DOM and the new DOM based on diff results.
///
/// This iterates through matched nodes. If a match has BOTH a merge callback AND a dataset,
/// it executes the callback to transfer state from the old node to the new node.
///
/// This must be called **before** the old DOM is dropped, because we need to access its data.
///
/// # Arguments
/// * `old_node_data` - Mutable reference to the old DOM's node data (source of heavy state)
/// * `new_node_data` - Mutable reference to the new DOM's node data (target for heavy state)
/// * `node_moves` - The matched nodes from the reconciliation diff
///
/// # Example
/// ```rust,ignore
/// let diff_result = reconcile_dom(&old_data, &new_data, ...);
/// 
/// // Execute state migration BEFORE old_dom is dropped
/// transfer_states(&mut old_data, &mut new_data, &diff_result.node_moves);
/// 
/// // Now safe to drop old_dom - heavy resources have been transferred
/// drop(old_dom);
/// ```
pub fn transfer_states(
    old_node_data: &mut [NodeData],
    new_node_data: &mut [NodeData],
    node_moves: &[NodeMove],
) {
    use crate::refany::OptionRefAny;

    for movement in node_moves {
        let old_idx = movement.old_node_id.index();
        let new_idx = movement.new_node_id.index();

        // Bounds check
        if old_idx >= old_node_data.len() || new_idx >= new_node_data.len() {
            continue;
        }

        // 1. Check if the NEW node has requested a merge callback
        let merge_callback = match new_node_data[new_idx].get_merge_callback() {
            Some(cb) => cb,
            None => continue, // No merge callback, skip
        };

        // 2. Check if BOTH nodes have datasets
        // We need to temporarily take the datasets to satisfy borrow checker
        let old_dataset = core::mem::replace(
            &mut old_node_data[old_idx].dataset, 
            OptionRefAny::None
        );
        let new_dataset = core::mem::replace(
            &mut new_node_data[new_idx].dataset, 
            OptionRefAny::None
        );

        match (new_dataset, old_dataset) {
            (OptionRefAny::Some(new_data), OptionRefAny::Some(old_data)) => {
                // 3. EXECUTE THE MERGE CALLBACK
                // The callback receives both datasets and returns the merged result
                let merged = (merge_callback.cb)(new_data, old_data);
                
                // 4. Store the merged result back in the new node
                new_node_data[new_idx].dataset = OptionRefAny::Some(merged);
            }
            (new_ds, old_ds) => {
                // One or both datasets missing - restore what we had
                new_node_data[new_idx].dataset = new_ds;
                old_node_data[old_idx].dataset = old_ds;
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::dom::NodeData;

    #[test]
    fn test_simple_mount() {
        let old_data: Vec<NodeData> = vec![];
        let new_data = vec![NodeData::create_div()];
        
        let old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // No mount event because no callback is registered
        assert!(result.events.is_empty());
        assert!(result.node_moves.is_empty());
    }

    #[test]
    fn test_identical_nodes_match() {
        let div = NodeData::create_div();
        let old_data = vec![div.clone()];
        let new_data = vec![div.clone()];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should match by hash, no lifecycle events
        assert!(result.events.is_empty());
        assert_eq!(result.node_moves.len(), 1);
        assert_eq!(result.node_moves[0].old_node_id, NodeId::new(0));
        assert_eq!(result.node_moves[0].new_node_id, NodeId::new(0));
    }

    #[test]
    fn test_reorder_by_hash() {
        use azul_css::AzString;
        
        let mut div_a = NodeData::create_div();
        div_a.add_class(AzString::from("a"));
        let mut div_b = NodeData::create_div();
        div_b.add_class(AzString::from("b"));
        
        // Old: [A, B], New: [B, A]
        let old_data = vec![div_a.clone(), div_b.clone()];
        let new_data = vec![div_b.clone(), div_a.clone()];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        old_layout.insert(NodeId::new(1), LogicalRect::zero());
        
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        new_layout.insert(NodeId::new(1), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Both should match by hash (reorder detected)
        assert!(result.events.is_empty());
        assert_eq!(result.node_moves.len(), 2);
        
        // B (old index 1) -> B (new index 0)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(0)
        ));
        // A (old index 0) -> A (new index 1)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(1)
        ));
    }

    // ========== EDGE CASE TESTS ==========

    #[test]
    fn test_empty_to_empty() {
        let old_data: Vec<NodeData> = vec![];
        let new_data: Vec<NodeData> = vec![];
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &FastHashMap::default(),
            &FastHashMap::default(),
            DomId { inner: 0 },
            Instant::now(),
        );
        
        assert!(result.events.is_empty());
        assert!(result.node_moves.is_empty());
    }

    #[test]
    fn test_all_nodes_removed() {
        let old_data = vec![
            NodeData::create_div(),
            NodeData::create_div(),
            NodeData::create_div(),
        ];
        let new_data: Vec<NodeData> = vec![];
        
        let mut old_layout = FastHashMap::default();
        for i in 0..3 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &FastHashMap::default(),
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // No events because no callbacks, but no node moves either
        assert!(result.events.is_empty());
        assert!(result.node_moves.is_empty());
    }

    #[test]
    fn test_all_nodes_added() {
        let old_data: Vec<NodeData> = vec![];
        let new_data = vec![
            NodeData::create_div(),
            NodeData::create_div(),
            NodeData::create_div(),
        ];
        
        let mut new_layout = FastHashMap::default();
        for i in 0..3 {
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &FastHashMap::default(),
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // No events because no callbacks, but no node moves (all are new)
        assert!(result.events.is_empty());
        assert!(result.node_moves.is_empty());
    }

    #[test]
    fn test_keyed_node_match() {
        // Create two nodes with the same key but different content
        let mut old_node = NodeData::create_div();
        old_node.set_key("my-key");
        
        let mut new_node = NodeData::create_div();
        new_node.set_key("my-key");
        new_node.add_class(azul_css::AzString::from("updated"));
        
        let old_data = vec![old_node];
        let new_data = vec![new_node];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should match by key even though hash is different
        assert_eq!(result.node_moves.len(), 1);
        assert_eq!(result.node_moves[0].old_node_id, NodeId::new(0));
        assert_eq!(result.node_moves[0].new_node_id, NodeId::new(0));
    }

    #[test]
    fn test_keyed_reorder() {
        let mut node_a = NodeData::create_div();
        node_a.set_key("key-a");
        let mut node_b = NodeData::create_div();
        node_b.set_key("key-b");
        let mut node_c = NodeData::create_div();
        node_c.set_key("key-c");
        
        // Old: [A, B, C], New: [C, B, A]
        let old_data = vec![node_a.clone(), node_b.clone(), node_c.clone()];
        let new_data = vec![node_c.clone(), node_b.clone(), node_a.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..3 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        assert_eq!(result.node_moves.len(), 3);
        
        // C: old[2] -> new[0]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(2) && m.new_node_id == NodeId::new(0)
        ));
        // B: old[1] -> new[1] (unchanged position)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(1)
        ));
        // A: old[0] -> new[2]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(2)
        ));
    }

    #[test]
    fn test_identical_nodes_fifo() {
        // 5 identical divs - should match FIFO
        let div = NodeData::create_div();
        let old_data = vec![div.clone(), div.clone(), div.clone()];
        let new_data = vec![div.clone(), div.clone()]; // Remove last one
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..3 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        for i in 0..2 {
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // First two should match (FIFO), third is unmounted
        assert_eq!(result.node_moves.len(), 2);
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(0)
        ));
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(1)
        ));
    }

    #[test]
    fn test_insert_at_beginning() {
        use azul_css::AzString;
        
        let mut div_a = NodeData::create_div();
        div_a.add_class(AzString::from("a"));
        let mut div_b = NodeData::create_div();
        div_b.add_class(AzString::from("b"));
        let mut div_new = NodeData::create_div();
        div_new.add_class(AzString::from("new"));
        
        // Old: [A, B], New: [NEW, A, B]
        let old_data = vec![div_a.clone(), div_b.clone()];
        let new_data = vec![div_new.clone(), div_a.clone(), div_b.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..2 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        for i in 0..3 {
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // A and B should be matched (moved), NEW is mounted (but no callback)
        assert_eq!(result.node_moves.len(), 2);
        
        // A: old[0] -> new[1]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(1)
        ));
        // B: old[1] -> new[2]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(2)
        ));
    }

    #[test]
    fn test_insert_in_middle() {
        use azul_css::AzString;
        
        let mut div_a = NodeData::create_div();
        div_a.add_class(AzString::from("a"));
        let mut div_b = NodeData::create_div();
        div_b.add_class(AzString::from("b"));
        let mut div_new = NodeData::create_div();
        div_new.add_class(AzString::from("new"));
        
        // Old: [A, B], New: [A, NEW, B]
        let old_data = vec![div_a.clone(), div_b.clone()];
        let new_data = vec![div_a.clone(), div_new.clone(), div_b.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..2 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        for i in 0..3 {
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        assert_eq!(result.node_moves.len(), 2);
        
        // A: old[0] -> new[0] (same position)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(0)
        ));
        // B: old[1] -> new[2]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(2)
        ));
    }

    #[test]
    fn test_remove_from_middle() {
        use azul_css::AzString;
        
        let mut div_a = NodeData::create_div();
        div_a.add_class(AzString::from("a"));
        let mut div_b = NodeData::create_div();
        div_b.add_class(AzString::from("b"));
        let mut div_c = NodeData::create_div();
        div_c.add_class(AzString::from("c"));
        
        // Old: [A, B, C], New: [A, C]
        let old_data = vec![div_a.clone(), div_b.clone(), div_c.clone()];
        let new_data = vec![div_a.clone(), div_c.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..3 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        for i in 0..2 {
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // A and C matched, B unmounted (no callback so no event)
        assert_eq!(result.node_moves.len(), 2);
        
        // A: old[0] -> new[0]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(0)
        ));
        // C: old[2] -> new[1]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(2) && m.new_node_id == NodeId::new(1)
        ));
    }

    #[test]
    fn test_mixed_keyed_and_unkeyed() {
        use azul_css::AzString;
        
        let mut keyed = NodeData::create_div();
        keyed.set_key("my-key");
        keyed.add_class(AzString::from("keyed"));
        
        let mut unkeyed = NodeData::create_div();
        unkeyed.add_class(AzString::from("unkeyed"));
        
        // Old: [keyed, unkeyed], New: [unkeyed, keyed]
        let old_data = vec![keyed.clone(), unkeyed.clone()];
        let new_data = vec![unkeyed.clone(), keyed.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..2 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        assert_eq!(result.node_moves.len(), 2);
        
        // keyed: old[0] -> new[1] (matched by key)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(1)
        ));
        // unkeyed: old[1] -> new[0] (matched by hash)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(0)
        ));
    }

    #[test]
    fn test_duplicate_keys() {
        // Two nodes with the same key - first one wins
        let mut node1 = NodeData::create_div();
        node1.set_key("duplicate");
        node1.add_class(azul_css::AzString::from("first"));
        
        let mut node2 = NodeData::create_div();
        node2.set_key("duplicate");
        node2.add_class(azul_css::AzString::from("second"));
        
        let old_data = vec![node1.clone()];
        let new_data = vec![node2.clone()];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should match by key
        assert_eq!(result.node_moves.len(), 1);
    }

    #[test]
    fn test_key_not_in_old() {
        // New node has a key that didn't exist in old
        let old_div = NodeData::create_div();
        
        let mut new_div = NodeData::create_div();
        new_div.set_key("new-key");
        
        let old_data = vec![old_div];
        let new_data = vec![new_div];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Key doesn't match, so new keyed node is mount, old unkeyed is unmount
        // No events because no callbacks
        assert!(result.node_moves.is_empty()); // No match by key or hash
    }

    #[test]
    fn test_large_list_reorder() {
        use azul_css::AzString;
        
        // Create 100 unique nodes
        let nodes: Vec<NodeData> = (0..100).map(|i| {
            let mut node = NodeData::create_div();
            node.add_class(AzString::from(format!("item-{}", i)));
            node
        }).collect();
        
        // Reverse the order
        let old_data = nodes.clone();
        let new_data: Vec<NodeData> = nodes.into_iter().rev().collect();
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..100 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // All 100 nodes should be matched (just reordered)
        assert_eq!(result.node_moves.len(), 100);
        assert!(result.events.is_empty());
    }

    #[test]
    fn test_migration_map() {
        use azul_css::AzString;
        
        let mut div_a = NodeData::create_div();
        div_a.add_class(AzString::from("a"));
        let mut div_b = NodeData::create_div();
        div_b.add_class(AzString::from("b"));
        
        let old_data = vec![div_a.clone(), div_b.clone()];
        let new_data = vec![div_b.clone(), div_a.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..2 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        let migration = create_migration_map(&result.node_moves);
        
        // old[0] (A) -> new[1]
        assert_eq!(migration.get(&NodeId::new(0)), Some(&NodeId::new(1)));
        // old[1] (B) -> new[0]
        assert_eq!(migration.get(&NodeId::new(1)), Some(&NodeId::new(0)));
    }

    #[test]
    fn test_different_node_types() {
        // Different node types should not match by hash
        let div = NodeData::create_div();
        let span = NodeData::create_node(crate::dom::NodeType::Span);
        
        let old_data = vec![div];
        let new_data = vec![span];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should not match (different types = different hashes)
        assert!(result.node_moves.is_empty());
    }

    #[test]
    fn test_text_nodes() {
        use azul_css::AzString;
        
        let text_a = NodeData::create_text(AzString::from("Hello"));
        let text_b = NodeData::create_text(AzString::from("World"));
        let text_a_copy = NodeData::create_text(AzString::from("Hello"));
        
        // Old: ["Hello", "World"], New: ["World", "Hello"]
        let old_data = vec![text_a.clone(), text_b.clone()];
        let new_data = vec![text_b.clone(), text_a_copy.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..2 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should match by content hash
        assert_eq!(result.node_moves.len(), 2);
    }

    #[test]
    fn test_shuffle_three() {
        use azul_css::AzString;
        
        let mut a = NodeData::create_div();
        a.add_class(AzString::from("a"));
        let mut b = NodeData::create_div();
        b.add_class(AzString::from("b"));
        let mut c = NodeData::create_div();
        c.add_class(AzString::from("c"));
        
        // Old: [A, B, C], New: [B, C, A]
        let old_data = vec![a.clone(), b.clone(), c.clone()];
        let new_data = vec![b.clone(), c.clone(), a.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..3 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        assert_eq!(result.node_moves.len(), 3);
        
        // A: old[0] -> new[2]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(2)
        ));
        // B: old[1] -> new[0]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(0)
        ));
        // C: old[2] -> new[1]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(2) && m.new_node_id == NodeId::new(1)
        ));
    }

    // =========================================================================
    // MERGE CALLBACK / STATE MIGRATION TESTS
    // =========================================================================

    use crate::refany::{RefAny, OptionRefAny};
    use crate::dom::DatasetMergeCallbackType;
    use alloc::sync::Arc;
    use core::cell::RefCell;
    
    /// Test data simulating a video player with a heavy decoder handle
    struct VideoPlayerState {
        url: alloc::string::String,
        decoder_handle: Option<u64>, // Simulates heavy resource (e.g., FFmpeg handle)
    }

    /// Simple merge callback that transfers decoder_handle from old to new
    extern "C" fn merge_video_state(mut new_data: RefAny, mut old_data: RefAny) -> RefAny {
        // Get mutable access to new, immutable to old
        if let Some(mut new_guard) = new_data.downcast_mut::<VideoPlayerState>() {
            if let Some(old_guard) = old_data.downcast_ref::<VideoPlayerState>() {
                // Transfer heavy resource
                new_guard.decoder_handle = old_guard.decoder_handle;
            }
        }
        new_data
    }

    #[test]
    fn test_transfer_states_basic() {
        // Scenario: Video player moves from index 0 to index 1
        // The decoder handle should be preserved
        
        let old_state = VideoPlayerState {
            url: "movie.mp4".into(),
            decoder_handle: Some(12345),
        };
        let new_state = VideoPlayerState {
            url: "movie.mp4".into(),
            decoder_handle: None, // Fresh state, no handle yet
        };
        
        let mut old_node = NodeData::create_div();
        old_node.dataset = OptionRefAny::Some(RefAny::new(old_state));
        
        let mut new_node = NodeData::create_div();
        new_node.dataset = OptionRefAny::Some(RefAny::new(new_state));
        new_node.set_merge_callback(merge_video_state as DatasetMergeCallbackType);
        
        let mut old_data = vec![old_node];
        let mut new_data = vec![new_node];
        
        let moves = vec![NodeMove {
            old_node_id: NodeId::new(0),
            new_node_id: NodeId::new(0),
        }];
        
        // Execute state migration
        transfer_states(&mut old_data, &mut new_data, &moves);
        
        // Verify the handle was transferred
        if let OptionRefAny::Some(ref mut dataset) = new_data[0].dataset {
            let guard = dataset.downcast_ref::<VideoPlayerState>().unwrap();
            assert_eq!(guard.decoder_handle, Some(12345));
        } else {
            panic!("Dataset should exist");
        }
    }

    #[test]
    fn test_transfer_states_no_callback_no_transfer() {
        // If no merge callback is set, nothing should happen
        
        let old_state = VideoPlayerState {
            url: "movie.mp4".into(),
            decoder_handle: Some(99999),
        };
        let new_state = VideoPlayerState {
            url: "movie.mp4".into(),
            decoder_handle: None,
        };
        
        let mut old_node = NodeData::create_div();
        old_node.dataset = OptionRefAny::Some(RefAny::new(old_state));
        
        let mut new_node = NodeData::create_div();
        new_node.dataset = OptionRefAny::Some(RefAny::new(new_state));
        // NO merge callback set!
        
        let mut old_data = vec![old_node];
        let mut new_data = vec![new_node];
        
        let moves = vec![NodeMove {
            old_node_id: NodeId::new(0),
            new_node_id: NodeId::new(0),
        }];
        
        transfer_states(&mut old_data, &mut new_data, &moves);
        
        // Handle should NOT be transferred (no callback)
        if let OptionRefAny::Some(ref mut dataset) = new_data[0].dataset {
            let guard = dataset.downcast_ref::<VideoPlayerState>().unwrap();
            assert_eq!(guard.decoder_handle, None); // Still None!
        } else {
            panic!("Dataset should exist");
        }
    }

    #[test]
    fn test_transfer_states_no_old_dataset() {
        // If old node has no dataset, merge should not crash
        
        let new_state = VideoPlayerState {
            url: "movie.mp4".into(),
            decoder_handle: None,
        };
        
        let old_node = NodeData::create_div(); // No dataset
        
        let mut new_node = NodeData::create_div();
        new_node.dataset = OptionRefAny::Some(RefAny::new(new_state));
        new_node.set_merge_callback(merge_video_state as DatasetMergeCallbackType);
        
        let mut old_data = vec![old_node];
        let mut new_data = vec![new_node];
        
        let moves = vec![NodeMove {
            old_node_id: NodeId::new(0),
            new_node_id: NodeId::new(0),
        }];
        
        // Should not panic
        transfer_states(&mut old_data, &mut new_data, &moves);
        
        // New node should still have its dataset (unmodified)
        if let OptionRefAny::Some(ref mut dataset) = new_data[0].dataset {
            let guard = dataset.downcast_ref::<VideoPlayerState>().unwrap();
            assert_eq!(guard.decoder_handle, None);
        } else {
            panic!("Dataset should still exist");
        }
    }

    #[test]
    fn test_transfer_states_no_new_dataset() {
        // If new node has merge callback but no dataset, nothing should happen
        
        let old_state = VideoPlayerState {
            url: "movie.mp4".into(),
            decoder_handle: Some(77777),
        };
        
        let mut old_node = NodeData::create_div();
        old_node.dataset = OptionRefAny::Some(RefAny::new(old_state));
        
        let mut new_node = NodeData::create_div();
        // No dataset on new node!
        new_node.set_merge_callback(merge_video_state as DatasetMergeCallbackType);
        
        let mut old_data = vec![old_node];
        let mut new_data = vec![new_node];
        
        let moves = vec![NodeMove {
            old_node_id: NodeId::new(0),
            new_node_id: NodeId::new(0),
        }];
        
        // Should not panic
        transfer_states(&mut old_data, &mut new_data, &moves);
        
        // New node should still have no dataset
        assert!(matches!(new_data[0].dataset, OptionRefAny::None));
    }

    #[test]
    fn test_transfer_states_reorder_preserves_handles() {
        // Scenario: Two video players swap positions
        // Each should keep its own decoder handle
        
        let state_a = VideoPlayerState { url: "a.mp4".into(), decoder_handle: Some(111) };
        let state_b = VideoPlayerState { url: "b.mp4".into(), decoder_handle: Some(222) };
        
        let mut old_a = NodeData::create_div();
        old_a.set_key("player-a");
        old_a.dataset = OptionRefAny::Some(RefAny::new(state_a));
        
        let mut old_b = NodeData::create_div();
        old_b.set_key("player-b");
        old_b.dataset = OptionRefAny::Some(RefAny::new(state_b));
        
        // New order: B, A (swapped)
        let new_state_b = VideoPlayerState { url: "b.mp4".into(), decoder_handle: None };
        let new_state_a = VideoPlayerState { url: "a.mp4".into(), decoder_handle: None };
        
        let mut new_b = NodeData::create_div();
        new_b.set_key("player-b");
        new_b.dataset = OptionRefAny::Some(RefAny::new(new_state_b));
        new_b.set_merge_callback(merge_video_state as DatasetMergeCallbackType);
        
        let mut new_a = NodeData::create_div();
        new_a.set_key("player-a");
        new_a.dataset = OptionRefAny::Some(RefAny::new(new_state_a));
        new_a.set_merge_callback(merge_video_state as DatasetMergeCallbackType);
        
        let mut old_data = vec![old_a, old_b];  // [A@0, B@1]
        let mut new_data = vec![new_b, new_a];  // [B@0, A@1]
        
        // Moves from reconciliation: old_a(0)->new(1), old_b(1)->new(0)
        let moves = vec![
            NodeMove { old_node_id: NodeId::new(0), new_node_id: NodeId::new(1) }, // A
            NodeMove { old_node_id: NodeId::new(1), new_node_id: NodeId::new(0) }, // B
        ];
        
        transfer_states(&mut old_data, &mut new_data, &moves);
        
        // new[0] should be B with handle 222
        if let OptionRefAny::Some(ref mut ds) = new_data[0].dataset {
            let guard = ds.downcast_ref::<VideoPlayerState>().unwrap();
            assert_eq!(guard.url, "b.mp4");
            assert_eq!(guard.decoder_handle, Some(222));
        } else {
            panic!("B dataset missing");
        }
        
        // new[1] should be A with handle 111
        if let OptionRefAny::Some(ref mut ds) = new_data[1].dataset {
            let guard = ds.downcast_ref::<VideoPlayerState>().unwrap();
            assert_eq!(guard.url, "a.mp4");
            assert_eq!(guard.decoder_handle, Some(111));
        } else {
            panic!("A dataset missing");
        }
    }

    #[test]
    fn test_transfer_states_out_of_bounds() {
        // Invalid node moves should be skipped gracefully
        
        let state = VideoPlayerState { url: "test.mp4".into(), decoder_handle: Some(123) };
        
        let mut old_node = NodeData::create_div();
        old_node.dataset = OptionRefAny::Some(RefAny::new(state));
        
        let mut old_data = vec![old_node];
        let mut new_data: Vec<NodeData> = vec![]; // Empty!
        
        let moves = vec![NodeMove {
            old_node_id: NodeId::new(0),
            new_node_id: NodeId::new(999), // Out of bounds
        }];
        
        // Should not panic
        transfer_states(&mut old_data, &mut new_data, &moves);
    }

    /// Test with a more complex type that uses interior mutability
    struct WebGLContext {
        texture_ids: alloc::vec::Vec<u32>,
        shader_program: Option<u32>,
    }

    extern "C" fn merge_webgl_context(mut new_data: RefAny, mut old_data: RefAny) -> RefAny {
        if let Some(mut new_guard) = new_data.downcast_mut::<WebGLContext>() {
            if let Some(old_guard) = old_data.downcast_ref::<WebGLContext>() {
                // Transfer all GL resources
                new_guard.texture_ids = old_guard.texture_ids.clone();
                new_guard.shader_program = old_guard.shader_program;
            }
        }
        new_data
    }

    #[test]
    fn test_transfer_states_complex_type() {
        let old_ctx = WebGLContext {
            texture_ids: vec![1, 2, 3, 4, 5],
            shader_program: Some(42),
        };
        let new_ctx = WebGLContext {
            texture_ids: vec![],
            shader_program: None,
        };
        
        let mut old_node = NodeData::create_div();
        old_node.dataset = OptionRefAny::Some(RefAny::new(old_ctx));
        
        let mut new_node = NodeData::create_div();
        new_node.dataset = OptionRefAny::Some(RefAny::new(new_ctx));
        new_node.set_merge_callback(merge_webgl_context as DatasetMergeCallbackType);
        
        let mut old_data = vec![old_node];
        let mut new_data = vec![new_node];
        
        let moves = vec![NodeMove {
            old_node_id: NodeId::new(0),
            new_node_id: NodeId::new(0),
        }];
        
        transfer_states(&mut old_data, &mut new_data, &moves);
        
        if let OptionRefAny::Some(ref mut ds) = new_data[0].dataset {
            let guard = ds.downcast_ref::<WebGLContext>().unwrap();
            assert_eq!(guard.texture_ids, vec![1, 2, 3, 4, 5]);
            assert_eq!(guard.shader_program, Some(42));
        } else {
            panic!("Dataset missing");
        }
    }

    #[test]
    fn test_transfer_states_callback_returns_old_data() {
        // Test that callback can choose to return old_data instead of new_data
        
        struct Counter {
            value: u32,
        }
        
        extern "C" fn prefer_old(_new_data: RefAny, old_data: RefAny) -> RefAny {
            // Return old_data to preserve the old state entirely
            old_data
        }
        
        let old_counter = Counter { value: 100 };
        let new_counter = Counter { value: 0 };
        
        let mut old_node = NodeData::create_div();
        old_node.dataset = OptionRefAny::Some(RefAny::new(old_counter));
        
        let mut new_node = NodeData::create_div();
        new_node.dataset = OptionRefAny::Some(RefAny::new(new_counter));
        new_node.set_merge_callback(prefer_old as DatasetMergeCallbackType);
        
        let mut old_data = vec![old_node];
        let mut new_data = vec![new_node];
        
        let moves = vec![NodeMove {
            old_node_id: NodeId::new(0),
            new_node_id: NodeId::new(0),
        }];
        
        transfer_states(&mut old_data, &mut new_data, &moves);
        
        // The callback returned old_data, so new node should have value=100
        if let OptionRefAny::Some(ref mut ds) = new_data[0].dataset {
            let guard = ds.downcast_ref::<Counter>().unwrap();
            assert_eq!(guard.value, 100);
        } else {
            panic!("Dataset missing");
        }
    }

    #[test]
    fn test_transfer_states_multiple_nodes_partial_callbacks() {
        // Scenario: 3 nodes, only middle one has merge callback
        
        struct Simple { val: u32 }
        
        extern "C" fn merge_simple(mut new_data: RefAny, mut old_data: RefAny) -> RefAny {
            if let Some(mut new_g) = new_data.downcast_mut::<Simple>() {
                if let Some(old_g) = old_data.downcast_ref::<Simple>() {
                    new_g.val = old_g.val;
                }
            }
            new_data
        }
        
        let mut old_nodes = vec![
            {
                let mut n = NodeData::create_div();
                n.dataset = OptionRefAny::Some(RefAny::new(Simple { val: 1 }));
                n
            },
            {
                let mut n = NodeData::create_div();
                n.dataset = OptionRefAny::Some(RefAny::new(Simple { val: 2 }));
                n
            },
            {
                let mut n = NodeData::create_div();
                n.dataset = OptionRefAny::Some(RefAny::new(Simple { val: 3 }));
                n
            },
        ];
        
        let mut new_nodes = vec![
            {
                let mut n = NodeData::create_div();
                n.dataset = OptionRefAny::Some(RefAny::new(Simple { val: 10 }));
                // NO callback
                n
            },
            {
                let mut n = NodeData::create_div();
                n.dataset = OptionRefAny::Some(RefAny::new(Simple { val: 20 }));
                n.set_merge_callback(merge_simple as DatasetMergeCallbackType); // HAS callback
                n
            },
            {
                let mut n = NodeData::create_div();
                n.dataset = OptionRefAny::Some(RefAny::new(Simple { val: 30 }));
                // NO callback
                n
            },
        ];
        
        let moves = vec![
            NodeMove { old_node_id: NodeId::new(0), new_node_id: NodeId::new(0) },
            NodeMove { old_node_id: NodeId::new(1), new_node_id: NodeId::new(1) },
            NodeMove { old_node_id: NodeId::new(2), new_node_id: NodeId::new(2) },
        ];
        
        transfer_states(&mut old_nodes, &mut new_nodes, &moves);
        
        // Node 0: no callback, should keep val=10
        if let OptionRefAny::Some(ref mut ds) = new_nodes[0].dataset {
            let g = ds.downcast_ref::<Simple>().unwrap();
            assert_eq!(g.val, 10);
        }
        
        // Node 1: has callback, should get val=2 from old
        if let OptionRefAny::Some(ref mut ds) = new_nodes[1].dataset {
            let g = ds.downcast_ref::<Simple>().unwrap();
            assert_eq!(g.val, 2);
        }
        
        // Node 2: no callback, should keep val=30
        if let OptionRefAny::Some(ref mut ds) = new_nodes[2].dataset {
            let g = ds.downcast_ref::<Simple>().unwrap();
            assert_eq!(g.val, 30);
        }
    }

    #[test]
    fn test_transfer_states_empty_moves() {
        // No moves = no transfers
        let mut old_data: Vec<NodeData> = vec![];
        let mut new_data: Vec<NodeData> = vec![];
        let moves: Vec<NodeMove> = vec![];
        
        // Should not panic
        transfer_states(&mut old_data, &mut new_data, &moves);
    }

    #[test]
    fn test_reconcile_then_transfer_integration() {
        // Full integration test: reconcile DOM, then transfer states
        
        struct AppState { 
            name: alloc::string::String, 
            heavy_handle: Option<u64> 
        }
        
        extern "C" fn merge_app(mut new_data: RefAny, mut old_data: RefAny) -> RefAny {
            if let Some(mut new_g) = new_data.downcast_mut::<AppState>() {
                if let Some(old_g) = old_data.downcast_ref::<AppState>() {
                    new_g.heavy_handle = old_g.heavy_handle;
                }
            }
            new_data
        }
        
        // OLD DOM: one node with key "main" and handle=999
        let old_state = AppState { name: "old".into(), heavy_handle: Some(999) };
        let mut old_node = NodeData::create_div();
        old_node.set_key("main");
        old_node.dataset = OptionRefAny::Some(RefAny::new(old_state));
        
        // NEW DOM: same key, new state, needs merge
        let new_state = AppState { name: "new".into(), heavy_handle: None };
        let mut new_node = NodeData::create_div();
        new_node.set_key("main");
        new_node.dataset = OptionRefAny::Some(RefAny::new(new_state));
        new_node.set_merge_callback(merge_app as DatasetMergeCallbackType);
        
        let mut old_data = vec![old_node];
        let mut new_data = vec![new_node];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        // Step 1: Reconcile
        let diff = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should match by key
        assert_eq!(diff.node_moves.len(), 1);
        assert_eq!(diff.node_moves[0].old_node_id, NodeId::new(0));
        assert_eq!(diff.node_moves[0].new_node_id, NodeId::new(0));
        
        // Step 2: Transfer states
        transfer_states(&mut old_data, &mut new_data, &diff.node_moves);
        
        // Verify: name should be "new", handle should be 999
        if let OptionRefAny::Some(ref mut ds) = new_data[0].dataset {
            let g = ds.downcast_ref::<AppState>().unwrap();
            assert_eq!(g.name, "new");
            assert_eq!(g.heavy_handle, Some(999));
        } else {
            panic!("Dataset missing");
        }
    }
}
