//! DOM Reconciliation Module
//!
//! This module provides the reconciliation algorithm that compares two DOM trees
//! and generates lifecycle events. It uses stable keys and content hashing to
//! identify moves vs. mounts/unmounts.
//!
//! The reconciliation strategy is:
//! 1. **Stable Key Match:** If `.with_key()` is used, it's an absolute match (O(1)).
//! 2. **CSS ID Match:** If no key, use the CSS ID as key.
//! 3. **Structural Key Match:** nth-of-type-within-parent + parent's key (recursive).
//! 4. **Hash Match (Content Match):** Check for identical `DomNodeHash`.
//! 5. **Structural Hash Match:** For text nodes, match by structural hash (ignoring content).
//! 6. **Fallback:** Anything not matched is a `Mount` (new) or `Unmount` (old leftovers).

use alloc::{collections::VecDeque, vec::Vec};
use core::hash::Hash;

use crate::{
    dom::{DomId, DomNodeHash, DomNodeId, NodeData, IdOrClass},
    events::{
        ComponentEventFilter, EventData, EventFilter, EventPhase, EventSource, EventType,
        LifecycleEventData, LifecycleReason, SyntheticEvent,
    },
    geom::LogicalRect,
    id::NodeId,
    styled_dom::{NodeHierarchyItemId, NodeHierarchyItem},
    task::Instant,
    FastHashMap,
};

/// Represents a mapping between a node in the old DOM and the new DOM.
#[derive(Debug, Clone, Copy)]
pub struct NodeMove {
    /// The NodeId in the old DOM array
    pub old_node_id: NodeId,
    /// The NodeId in the new DOM array
    pub new_node_id: NodeId,
}

/// The result of a DOM diff, containing lifecycle events and node mappings.
#[derive(Debug, Clone)]
pub struct DiffResult {
    /// Lifecycle events generated by the diff (Mount, Unmount, Resize, Update)
    pub events: Vec<SyntheticEvent>,
    /// Maps Old NodeId -> New NodeId for state migration (focus, scroll, etc.)
    pub node_moves: Vec<NodeMove>,
}

impl Default for DiffResult {
    fn default() -> Self {
        Self {
            events: Vec::new(),
            node_moves: Vec::new(),
        }
    }
}

/// Calculate the reconciliation key for a node using the priority hierarchy:
/// 1. Explicit key (set via `.with_key()`)
/// 2. CSS ID (set via `.with_id("my-id")`)
/// 3. Structural key: nth-of-type-within-parent + parent's reconciliation key
///
/// The structural key prevents incorrect matching when nodes are inserted
/// before existing nodes (e.g., prepending items to a list).
///
/// # Arguments
/// * `node_data` - Slice of all node data
/// * `hierarchy` - Slice of node hierarchy (parent/child relationships)
/// * `node_id` - The node to calculate the key for
///
/// # Returns
/// A 64-bit key that uniquely identifies this node's logical position in the tree.
pub fn calculate_reconciliation_key(
    node_data: &[NodeData],
    hierarchy: &[NodeHierarchyItem],
    node_id: NodeId,
) -> u64 {
    use highway::{HighwayHash, HighwayHasher, Key};
    
    let node = &node_data[node_id.index()];
    
    // Priority 1: Explicit key
    if let Some(key) = node.get_key() {
        return key;
    }
    
    // Priority 2: CSS ID
    for id_or_class in node.ids_and_classes.as_ref().iter() {
        if let IdOrClass::Id(id) = id_or_class {
            let mut hasher = HighwayHasher::new(Key([0; 4]));
            id.as_str().hash(&mut hasher);
            return hasher.finalize64();
        }
    }
    
    // Priority 3: Structural key = nth-of-type-within-parent + parent key
    let mut hasher = HighwayHasher::new(Key([0; 4]));
    
    // Hash node type discriminant and classes (nth-of-type logic)
    core::mem::discriminant(node.get_node_type()).hash(&mut hasher);
    for id_or_class in node.ids_and_classes.as_ref().iter() {
        if let IdOrClass::Class(class) = id_or_class {
            class.as_str().hash(&mut hasher);
        }
    }
    
    // Calculate sibling index (nth-of-type within parent)
    if let Some(hierarchy_item) = hierarchy.get(node_id.index()) {
        if let Some(parent_id) = hierarchy_item.parent_id() {
            // Count siblings of same type before this node
            let mut sibling_index: usize = 0;
            let parent_hierarchy = &hierarchy[parent_id.index()];
            
            // Walk siblings from first child to this node
            let mut current = parent_hierarchy.first_child_id(parent_id);
            while let Some(sibling_id) = current {
                if sibling_id == node_id {
                    break;
                }
                // Check if sibling has same type/classes
                let sibling = &node_data[sibling_id.index()];
                if core::mem::discriminant(sibling.get_node_type()) 
                    == core::mem::discriminant(node.get_node_type()) 
                {
                    sibling_index += 1;
                }
                current = hierarchy[sibling_id.index()].next_sibling_id();
            }
            
            sibling_index.hash(&mut hasher);
            
            // Recursively include parent's key
            let parent_key = calculate_reconciliation_key(node_data, hierarchy, parent_id);
            parent_key.hash(&mut hasher);
        }
    }
    
    hasher.finalize64()
}

/// Precompute reconciliation keys for all nodes in a DOM tree.
///
/// This should be called once before reconciliation to compute stable keys
/// for all nodes. Keys are computed using the hierarchy:
/// 1. Explicit key → 2. CSS ID → 3. Structural key (nth-of-type + parent key)
///
/// # Returns
/// A map from NodeId to its reconciliation key.
pub fn precompute_reconciliation_keys(
    node_data: &[NodeData],
    hierarchy: &[NodeHierarchyItem],
) -> FastHashMap<NodeId, u64> {
    let mut keys = FastHashMap::default();
    for idx in 0..node_data.len() {
        let node_id = NodeId::new(idx);
        let key = calculate_reconciliation_key(node_data, hierarchy, node_id);
        keys.insert(node_id, key);
    }
    keys
}

/// Calculates the difference between two DOM frames and generates lifecycle events.
///
/// This is the main entry point for DOM reconciliation. It compares the old and new
/// DOM trees and produces:
/// - Mount events for new nodes
/// - Unmount events for removed nodes
/// - Resize events for nodes whose bounds changed
/// - Update events for nodes whose content changed (when matched by key)
///
/// # Arguments
/// * `old_node_data` - Node data from the previous frame
/// * `new_node_data` - Node data from the current frame
/// * `old_layout` - Layout bounds from the previous frame
/// * `new_layout` - Layout bounds from the current frame
/// * `dom_id` - The DOM identifier
/// * `timestamp` - Current timestamp for events
pub fn reconcile_dom(
    old_node_data: &[NodeData],
    new_node_data: &[NodeData],
    old_layout: &FastHashMap<NodeId, LogicalRect>,
    new_layout: &FastHashMap<NodeId, LogicalRect>,
    dom_id: DomId,
    timestamp: Instant,
) -> DiffResult {
    let mut result = DiffResult::default();

    // --- STEP 1: INDEX THE OLD DOM ---
    // Create lookups to find old nodes by Key or by Hash.
    // 
    // IMPORTANT: We use TWO hash indexes:
    // 1. Content Hash (calculate_node_data_hash) - for exact matching including text content
    // 2. Structural Hash (calculate_structural_hash) - for text nodes where content may change
    //
    // This allows Text("Hello") to match Text("Hello World") as a structural match,
    // preserving cursor/selection state during text editing.

    let mut old_keyed: FastHashMap<u64, NodeId> = FastHashMap::default();
    let mut old_hashed: FastHashMap<DomNodeHash, VecDeque<NodeId>> = FastHashMap::default();
    let mut old_structural: FastHashMap<DomNodeHash, VecDeque<NodeId>> = FastHashMap::default();
    let mut old_nodes_consumed = vec![false; old_node_data.len()];

    for (idx, node) in old_node_data.iter().enumerate() {
        let id = NodeId::new(idx);

        if let Some(key) = node.get_key() {
            // Priority 1: Explicit Key
            old_keyed.insert(key, id);
        } else {
            // Priority 2: Content Hash (exact match)
            let hash = node.calculate_node_data_hash();
            old_hashed.entry(hash).or_default().push_back(id);
            
            // Priority 3: Structural Hash (for text node matching)
            let structural_hash = node.calculate_structural_hash();
            old_structural.entry(structural_hash).or_default().push_back(id);
        }
    }

    // --- STEP 2: ITERATE NEW DOM AND CLAIM MATCHES ---

    for (new_idx, new_node) in new_node_data.iter().enumerate() {
        let new_id = NodeId::new(new_idx);
        let mut matched_old_id = None;

        // A. Try Match by Key
        if let Some(key) = new_node.get_key() {
            if let Some(&old_id) = old_keyed.get(&key) {
                if !old_nodes_consumed[old_id.index()] {
                    matched_old_id = Some(old_id);
                }
            }
        }
        // B. Try Match by Content Hash first (exact match - The "Automagic" Reordering)
        else {
            let hash = new_node.calculate_node_data_hash();

            // Get the queue of old nodes with this identical content
            if let Some(queue) = old_hashed.get_mut(&hash) {
                // Find first non-consumed node in queue
                while let Some(old_id) = queue.front() {
                    if !old_nodes_consumed[old_id.index()] {
                        matched_old_id = Some(*old_id);
                        queue.pop_front();
                        break;
                    } else {
                        queue.pop_front();
                    }
                }
            }
            
            // C. If no exact match, try Structural Hash (for text nodes with changed content)
            if matched_old_id.is_none() {
                let structural_hash = new_node.calculate_structural_hash();
                if let Some(queue) = old_structural.get_mut(&structural_hash) {
                    while let Some(old_id) = queue.front() {
                        if !old_nodes_consumed[old_id.index()] {
                            matched_old_id = Some(*old_id);
                            queue.pop_front();
                            break;
                        } else {
                            queue.pop_front();
                        }
                    }
                }
            }
        }

        // --- STEP 3: PROCESS MATCH OR MOUNT ---

        if let Some(old_id) = matched_old_id {
            // FOUND A MATCH (It might be at a different index, but it's the "same" node)

            old_nodes_consumed[old_id.index()] = true;
            result.node_moves.push(NodeMove {
                old_node_id: old_id,
                new_node_id: new_id,
            });

            // Check for Resize
            let old_rect = old_layout.get(&old_id).copied().unwrap_or(LogicalRect::zero());
            let new_rect = new_layout.get(&new_id).copied().unwrap_or(LogicalRect::zero());

            if old_rect.size != new_rect.size {
                // Fire Resize Event
                if has_resize_callback(new_node) {
                    result.events.push(create_lifecycle_event(
                        EventType::Resize,
                        new_id,
                        dom_id,
                        &timestamp,
                        LifecycleEventData {
                            reason: LifecycleReason::Resize,
                            previous_bounds: Some(old_rect),
                            current_bounds: new_rect,
                        },
                    ));
                }
            }

            // If matched by Key, the content might have changed, so we should check hash equality.
            if new_node.get_key().is_some() {
                let old_hash = old_node_data[old_id.index()].calculate_node_data_hash();
                let new_hash = new_node.calculate_node_data_hash();

                if old_hash != new_hash && has_update_callback(new_node) {
                    result.events.push(create_lifecycle_event(
                        EventType::Update,
                        new_id,
                        dom_id,
                        &timestamp,
                        LifecycleEventData {
                            reason: LifecycleReason::Update,
                            previous_bounds: Some(old_rect),
                            current_bounds: new_rect,
                        },
                    ));
                }
            }
        } else {
            // NO MATCH FOUND -> MOUNT (New Node)
            if has_mount_callback(new_node) {
                let bounds = new_layout.get(&new_id).copied().unwrap_or(LogicalRect::zero());
                result.events.push(create_lifecycle_event(
                    EventType::Mount,
                    new_id,
                    dom_id,
                    &timestamp,
                    LifecycleEventData {
                        reason: LifecycleReason::InitialMount,
                        previous_bounds: None,
                        current_bounds: bounds,
                    },
                ));
            }
        }
    }

    // --- STEP 4: CLEANUP (UNMOUNTS) ---
    // Any old node that wasn't claimed is effectively destroyed.

    for (old_idx, consumed) in old_nodes_consumed.iter().enumerate() {
        if !consumed {
            let old_id = NodeId::new(old_idx);
            let old_node = &old_node_data[old_idx];

            if has_unmount_callback(old_node) {
                let bounds = old_layout.get(&old_id).copied().unwrap_or(LogicalRect::zero());
                result.events.push(create_lifecycle_event(
                    EventType::Unmount,
                    old_id,
                    dom_id,
                    &timestamp,
                    LifecycleEventData {
                        reason: LifecycleReason::InitialMount, // Context implies unmount
                        previous_bounds: Some(bounds),
                        current_bounds: LogicalRect::zero(),
                    },
                ));
            }
        }
    }

    result
}

/// Creates a lifecycle event with all necessary fields.
fn create_lifecycle_event(
    event_type: EventType,
    node_id: NodeId,
    dom_id: DomId,
    timestamp: &Instant,
    data: LifecycleEventData,
) -> SyntheticEvent {
    let dom_node_id = DomNodeId {
        dom: dom_id,
        node: NodeHierarchyItemId::from_crate_internal(Some(node_id)),
    };
    SyntheticEvent {
        event_type,
        source: EventSource::Lifecycle,
        phase: EventPhase::Target,
        target: dom_node_id,
        current_target: dom_node_id,
        timestamp: timestamp.clone(),
        data: EventData::Lifecycle(data),
        stopped: false,
        stopped_immediate: false,
        prevented_default: false,
    }
}

/// Check if the node has an AfterMount callback registered.
fn has_mount_callback(node: &NodeData) -> bool {
    node.get_callbacks().iter().any(|cb| {
        matches!(
            cb.event,
            EventFilter::Component(ComponentEventFilter::AfterMount)
        )
    })
}

/// Check if the node has a BeforeUnmount callback registered.
fn has_unmount_callback(node: &NodeData) -> bool {
    node.get_callbacks().iter().any(|cb| {
        matches!(
            cb.event,
            EventFilter::Component(ComponentEventFilter::BeforeUnmount)
        )
    })
}

/// Check if the node has a NodeResized callback registered.
fn has_resize_callback(node: &NodeData) -> bool {
    node.get_callbacks().iter().any(|cb| {
        matches!(
            cb.event,
            EventFilter::Component(ComponentEventFilter::NodeResized)
        )
    })
}

/// Check if the node has any lifecycle callback that would respond to updates.
fn has_update_callback(node: &NodeData) -> bool {
    // For now, we use Selected as a placeholder for "update" events
    // This could be extended to a dedicated UpdateCallback in the future
    node.get_callbacks().iter().any(|cb| {
        matches!(
            cb.event,
            EventFilter::Component(ComponentEventFilter::Selected)
        )
    })
}

/// Migrate state (focus, scroll, etc.) from old node IDs to new node IDs.
///
/// This function should be called after reconciliation to update any state
/// that references old NodeIds to use the new NodeIds.
///
/// # Example
/// ```rust
/// let diff = reconcile_dom(...);
/// let migration_map = create_migration_map(&diff.node_moves);
/// 
/// // Migrate focus
/// if let Some(current_focus) = focus_manager.focused_node {
///     if let Some(&new_id) = migration_map.get(&current_focus) {
///         focus_manager.focused_node = Some(new_id);
///     } else {
///         // Focused node was unmounted, clear focus
///         focus_manager.focused_node = None;
///     }
/// }
/// ```
pub fn create_migration_map(node_moves: &[NodeMove]) -> FastHashMap<NodeId, NodeId> {
    let mut map = FastHashMap::default();
    for m in node_moves {
        map.insert(m.old_node_id, m.new_node_id);
    }
    map
}

/// Executes state migration between the old DOM and the new DOM based on diff results.
///
/// This iterates through matched nodes. If a match has BOTH a merge callback AND a dataset,
/// it executes the callback to transfer state from the old node to the new node.
///
/// This must be called **before** the old DOM is dropped, because we need to access its data.
///
/// # Arguments
/// * `old_node_data` - Mutable reference to the old DOM's node data (source of heavy state)
/// * `new_node_data` - Mutable reference to the new DOM's node data (target for heavy state)
/// * `node_moves` - The matched nodes from the reconciliation diff
///
/// # Example
/// ```rust,ignore
/// let diff_result = reconcile_dom(&old_data, &new_data, ...);
/// 
/// // Execute state migration BEFORE old_dom is dropped
/// transfer_states(&mut old_data, &mut new_data, &diff_result.node_moves);
/// 
/// // Now safe to drop old_dom - heavy resources have been transferred
/// drop(old_dom);
/// ```
pub fn transfer_states(
    old_node_data: &mut [NodeData],
    new_node_data: &mut [NodeData],
    node_moves: &[NodeMove],
) {
    use crate::refany::OptionRefAny;

    for movement in node_moves {
        let old_idx = movement.old_node_id.index();
        let new_idx = movement.new_node_id.index();

        // Bounds check
        if old_idx >= old_node_data.len() || new_idx >= new_node_data.len() {
            continue;
        }

        // 1. Check if the NEW node has requested a merge callback
        let merge_callback = match new_node_data[new_idx].get_merge_callback() {
            Some(cb) => cb,
            None => continue, // No merge callback, skip
        };

        // 2. Check if BOTH nodes have datasets
        // We need to temporarily take the datasets to satisfy borrow checker
        let old_dataset = core::mem::replace(
            &mut old_node_data[old_idx].dataset, 
            OptionRefAny::None
        );
        let new_dataset = core::mem::replace(
            &mut new_node_data[new_idx].dataset, 
            OptionRefAny::None
        );

        match (new_dataset, old_dataset) {
            (OptionRefAny::Some(new_data), OptionRefAny::Some(old_data)) => {
                // 3. EXECUTE THE MERGE CALLBACK
                // The callback receives both datasets and returns the merged result
                let merged = (merge_callback.cb)(new_data, old_data);
                
                // 4. Store the merged result back in the new node
                new_node_data[new_idx].dataset = OptionRefAny::Some(merged);
            }
            (new_ds, old_ds) => {
                // One or both datasets missing - restore what we had
                new_node_data[new_idx].dataset = new_ds;
                old_node_data[old_idx].dataset = old_ds;
            }
        }
    }
}

/// Calculate a stable key for a contenteditable node using the hierarchy:
///
/// 1. **Explicit Key** - If `.with_key()` was called, use that
/// 2. **CSS ID** - If the node has a CSS ID (e.g., `#my-editor`), hash that
/// 3. **Structural Key** - Hash of `(nth-of-type, parent_key)` recursively
///
/// The structural key prevents shifting when elements are inserted before siblings.
/// For example, in `<div><p>A</p><p contenteditable>B</p></div>`, if we insert
/// a new `<p>` at the start, the contenteditable `<p>` becomes nth-child(3) but
/// its nth-of-type stays stable (it's still the 2nd `<p>`).
///
/// # Arguments
/// * `node_data` - All nodes in the DOM
/// * `hierarchy` - Parent-child relationships
/// * `node_id` - The node to calculate the key for
///
/// # Returns
/// A stable u64 key for the node
pub fn calculate_contenteditable_key(
    node_data: &[NodeData],
    hierarchy: &[crate::styled_dom::NodeHierarchyItem],
    node_id: NodeId,
) -> u64 {
    use highway::{HighwayHash, HighwayHasher, Key};
    use crate::dom::IdOrClass;
    
    let node = &node_data[node_id.index()];
    
    // Priority 1: Explicit key (from .with_key())
    if let Some(explicit_key) = node.get_key() {
        return explicit_key;
    }
    
    // Priority 2: CSS ID
    for id_or_class in node.get_ids_and_classes().as_ref().iter() {
        if let IdOrClass::Id(id) = id_or_class {
            let mut hasher = HighwayHasher::new(Key([1; 4])); // Different seed for ID keys
            hasher.append(id.as_str().as_bytes());
            return hasher.finalize64();
        }
    }
    
    // Priority 3: Structural key = (nth-of-type, classes, parent_key)
    let mut hasher = HighwayHasher::new(Key([2; 4])); // Different seed for structural keys
    
    // Get parent and calculate its key recursively
    let parent_key = if let Some(parent_id) = hierarchy.get(node_id.index()).and_then(|h| h.parent_id()) {
        calculate_contenteditable_key(node_data, hierarchy, parent_id)
    } else {
        0u64 // Root node
    };
    hasher.append(&parent_key.to_le_bytes());
    
    // Calculate nth-of-type (count siblings of same node type before this one)
    // We compare discriminants directly without hashing
    let node_discriminant = core::mem::discriminant(node.get_node_type());
    let nth_of_type = if let Some(parent_id) = hierarchy.get(node_id.index()).and_then(|h| h.parent_id()) {
        // Count siblings with same node type that come before this node
        let mut count = 0u32;
        let mut sibling_id = hierarchy.get(parent_id.index()).and_then(|h| h.first_child_id(parent_id));
        while let Some(sib_id) = sibling_id {
            if sib_id == node_id {
                break;
            }
            let sibling_discriminant = core::mem::discriminant(node_data[sib_id.index()].get_node_type());
            if sibling_discriminant == node_discriminant {
                count += 1;
            }
            sibling_id = hierarchy.get(sib_id.index()).and_then(|h| h.next_sibling_id());
        }
        count
    } else {
        0
    };
    
    hasher.append(&nth_of_type.to_le_bytes());
    
    // Hash the node type using its Debug representation as a stable identifier
    // This works because NodeType implements Debug
    #[cfg(feature = "std")]
    {
        let type_str = format!("{:?}", node_discriminant);
        hasher.append(type_str.as_bytes());
    }
    #[cfg(not(feature = "std"))]
    {
        // For no_std, use the memory representation of the discriminant
        // NodeType variants are numbered 0..N, and discriminant stores this
        let discriminant_bytes: [u8; core::mem::size_of::<core::mem::Discriminant<crate::dom::NodeType>>()] = 
            unsafe { core::mem::transmute(node_discriminant) };
        hasher.append(&discriminant_bytes);
    }
    
    // Also hash the classes for additional stability
    for id_or_class in node.get_ids_and_classes().as_ref().iter() {
        if let IdOrClass::Class(class) = id_or_class {
            hasher.append(class.as_str().as_bytes());
        }
    }
    
    hasher.finalize64()
}

/// Reconcile cursor byte position when text content changes.
///
/// This function maps a cursor position from old text to new text, preserving
/// the cursor's logical position as much as possible:
///
/// 1. If cursor is in unchanged prefix → stays at same byte offset
/// 2. If cursor is in unchanged suffix → adjusts by length difference
/// 3. If cursor is in changed region → places at end of new content
///
/// # Arguments
/// * `old_text` - The previous text content
/// * `new_text` - The new text content
/// * `old_cursor_byte` - Cursor byte offset in old text
///
/// # Returns
/// The reconciled cursor byte offset in new text
///
/// # Example
/// ```rust,ignore
/// let old_text = "Hello";
/// let new_text = "Hello World";
/// let old_cursor = 5; // cursor at end of "Hello"
/// let new_cursor = reconcile_cursor_position(old_text, new_text, old_cursor);
/// assert_eq!(new_cursor, 5); // cursor stays at same position (prefix unchanged)
/// ```
pub fn reconcile_cursor_position(
    old_text: &str,
    new_text: &str,
    old_cursor_byte: usize,
) -> usize {
    // If texts are equal, cursor is unchanged
    if old_text == new_text {
        return old_cursor_byte;
    }
    
    // Empty old text - place cursor at end of new text
    if old_text.is_empty() {
        return new_text.len();
    }
    
    // Empty new text - place cursor at 0
    if new_text.is_empty() {
        return 0;
    }
    
    // Find common prefix (how many bytes from the start are identical)
    let common_prefix_bytes = old_text
        .bytes()
        .zip(new_text.bytes())
        .take_while(|(a, b)| a == b)
        .count();
    
    // If cursor was in the unchanged prefix, it stays at the same byte offset
    if old_cursor_byte <= common_prefix_bytes {
        return old_cursor_byte.min(new_text.len());
    }
    
    // Find common suffix (how many bytes from the end are identical)
    let common_suffix_bytes = old_text
        .bytes()
        .rev()
        .zip(new_text.bytes().rev())
        .take_while(|(a, b)| a == b)
        .count();
    
    // Calculate where the suffix starts in old and new text
    let old_suffix_start = old_text.len().saturating_sub(common_suffix_bytes);
    let new_suffix_start = new_text.len().saturating_sub(common_suffix_bytes);
    
    // If cursor was in the unchanged suffix, adjust by length difference
    if old_cursor_byte >= old_suffix_start {
        let offset_from_end = old_text.len() - old_cursor_byte;
        return new_text.len().saturating_sub(offset_from_end);
    }
    
    // Cursor was in the changed region - place at end of inserted content
    // This handles insertions (cursor moves with new text) and deletions (cursor at edit point)
    new_suffix_start
}

/// Get the text content from a NodeData if it's a Text node.
///
/// Returns the text string if the node is `NodeType::Text`, otherwise `None`.
pub fn get_node_text_content(node: &NodeData) -> Option<&str> {
    if let crate::dom::NodeType::Text(ref text) = node.get_node_type() {
        Some(text.as_str())
    } else {
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::dom::NodeData;

    #[test]
    fn test_simple_mount() {
        let old_data: Vec<NodeData> = vec![];
        let new_data = vec![NodeData::create_div()];
        
        let old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // No mount event because no callback is registered
        assert!(result.events.is_empty());
        assert!(result.node_moves.is_empty());
    }

    #[test]
    fn test_identical_nodes_match() {
        let div = NodeData::create_div();
        let old_data = vec![div.clone()];
        let new_data = vec![div.clone()];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should match by hash, no lifecycle events
        assert!(result.events.is_empty());
        assert_eq!(result.node_moves.len(), 1);
        assert_eq!(result.node_moves[0].old_node_id, NodeId::new(0));
        assert_eq!(result.node_moves[0].new_node_id, NodeId::new(0));
    }

    #[test]
    fn test_reorder_by_hash() {
        use azul_css::AzString;
        
        let mut div_a = NodeData::create_div();
        div_a.add_class(AzString::from("a"));
        let mut div_b = NodeData::create_div();
        div_b.add_class(AzString::from("b"));
        
        // Old: [A, B], New: [B, A]
        let old_data = vec![div_a.clone(), div_b.clone()];
        let new_data = vec![div_b.clone(), div_a.clone()];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        old_layout.insert(NodeId::new(1), LogicalRect::zero());
        
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        new_layout.insert(NodeId::new(1), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Both should match by hash (reorder detected)
        assert!(result.events.is_empty());
        assert_eq!(result.node_moves.len(), 2);
        
        // B (old index 1) -> B (new index 0)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(0)
        ));
        // A (old index 0) -> A (new index 1)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(1)
        ));
    }

    // ========== EDGE CASE TESTS ==========

    #[test]
    fn test_empty_to_empty() {
        let old_data: Vec<NodeData> = vec![];
        let new_data: Vec<NodeData> = vec![];
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &FastHashMap::default(),
            &FastHashMap::default(),
            DomId { inner: 0 },
            Instant::now(),
        );
        
        assert!(result.events.is_empty());
        assert!(result.node_moves.is_empty());
    }

    #[test]
    fn test_all_nodes_removed() {
        let old_data = vec![
            NodeData::create_div(),
            NodeData::create_div(),
            NodeData::create_div(),
        ];
        let new_data: Vec<NodeData> = vec![];
        
        let mut old_layout = FastHashMap::default();
        for i in 0..3 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &FastHashMap::default(),
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // No events because no callbacks, but no node moves either
        assert!(result.events.is_empty());
        assert!(result.node_moves.is_empty());
    }

    #[test]
    fn test_all_nodes_added() {
        let old_data: Vec<NodeData> = vec![];
        let new_data = vec![
            NodeData::create_div(),
            NodeData::create_div(),
            NodeData::create_div(),
        ];
        
        let mut new_layout = FastHashMap::default();
        for i in 0..3 {
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &FastHashMap::default(),
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // No events because no callbacks, but no node moves (all are new)
        assert!(result.events.is_empty());
        assert!(result.node_moves.is_empty());
    }

    #[test]
    fn test_keyed_node_match() {
        // Create two nodes with the same key but different content
        let mut old_node = NodeData::create_div();
        old_node.set_key("my-key");
        
        let mut new_node = NodeData::create_div();
        new_node.set_key("my-key");
        new_node.add_class(azul_css::AzString::from("updated"));
        
        let old_data = vec![old_node];
        let new_data = vec![new_node];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should match by key even though hash is different
        assert_eq!(result.node_moves.len(), 1);
        assert_eq!(result.node_moves[0].old_node_id, NodeId::new(0));
        assert_eq!(result.node_moves[0].new_node_id, NodeId::new(0));
    }

    #[test]
    fn test_keyed_reorder() {
        let mut node_a = NodeData::create_div();
        node_a.set_key("key-a");
        let mut node_b = NodeData::create_div();
        node_b.set_key("key-b");
        let mut node_c = NodeData::create_div();
        node_c.set_key("key-c");
        
        // Old: [A, B, C], New: [C, B, A]
        let old_data = vec![node_a.clone(), node_b.clone(), node_c.clone()];
        let new_data = vec![node_c.clone(), node_b.clone(), node_a.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..3 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        assert_eq!(result.node_moves.len(), 3);
        
        // C: old[2] -> new[0]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(2) && m.new_node_id == NodeId::new(0)
        ));
        // B: old[1] -> new[1] (unchanged position)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(1)
        ));
        // A: old[0] -> new[2]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(2)
        ));
    }

    #[test]
    fn test_identical_nodes_fifo() {
        // 5 identical divs - should match FIFO
        let div = NodeData::create_div();
        let old_data = vec![div.clone(), div.clone(), div.clone()];
        let new_data = vec![div.clone(), div.clone()]; // Remove last one
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..3 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        for i in 0..2 {
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // First two should match (FIFO), third is unmounted
        assert_eq!(result.node_moves.len(), 2);
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(0)
        ));
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(1)
        ));
    }

    #[test]
    fn test_insert_at_beginning() {
        use azul_css::AzString;
        
        let mut div_a = NodeData::create_div();
        div_a.add_class(AzString::from("a"));
        let mut div_b = NodeData::create_div();
        div_b.add_class(AzString::from("b"));
        let mut div_new = NodeData::create_div();
        div_new.add_class(AzString::from("new"));
        
        // Old: [A, B], New: [NEW, A, B]
        let old_data = vec![div_a.clone(), div_b.clone()];
        let new_data = vec![div_new.clone(), div_a.clone(), div_b.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..2 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        for i in 0..3 {
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // A and B should be matched (moved), NEW is mounted (but no callback)
        assert_eq!(result.node_moves.len(), 2);
        
        // A: old[0] -> new[1]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(1)
        ));
        // B: old[1] -> new[2]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(2)
        ));
    }

    #[test]
    fn test_insert_in_middle() {
        use azul_css::AzString;
        
        let mut div_a = NodeData::create_div();
        div_a.add_class(AzString::from("a"));
        let mut div_b = NodeData::create_div();
        div_b.add_class(AzString::from("b"));
        let mut div_new = NodeData::create_div();
        div_new.add_class(AzString::from("new"));
        
        // Old: [A, B], New: [A, NEW, B]
        let old_data = vec![div_a.clone(), div_b.clone()];
        let new_data = vec![div_a.clone(), div_new.clone(), div_b.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..2 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        for i in 0..3 {
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        assert_eq!(result.node_moves.len(), 2);
        
        // A: old[0] -> new[0] (same position)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(0)
        ));
        // B: old[1] -> new[2]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(2)
        ));
    }

    #[test]
    fn test_remove_from_middle() {
        use azul_css::AzString;
        
        let mut div_a = NodeData::create_div();
        div_a.add_class(AzString::from("a"));
        let mut div_b = NodeData::create_div();
        div_b.add_class(AzString::from("b"));
        let mut div_c = NodeData::create_div();
        div_c.add_class(AzString::from("c"));
        
        // Old: [A, B, C], New: [A, C]
        let old_data = vec![div_a.clone(), div_b.clone(), div_c.clone()];
        let new_data = vec![div_a.clone(), div_c.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..3 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        for i in 0..2 {
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // A and C matched, B unmounted (no callback so no event)
        assert_eq!(result.node_moves.len(), 2);
        
        // A: old[0] -> new[0]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(0)
        ));
        // C: old[2] -> new[1]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(2) && m.new_node_id == NodeId::new(1)
        ));
    }

    #[test]
    fn test_mixed_keyed_and_unkeyed() {
        use azul_css::AzString;
        
        let mut keyed = NodeData::create_div();
        keyed.set_key("my-key");
        keyed.add_class(AzString::from("keyed"));
        
        let mut unkeyed = NodeData::create_div();
        unkeyed.add_class(AzString::from("unkeyed"));
        
        // Old: [keyed, unkeyed], New: [unkeyed, keyed]
        let old_data = vec![keyed.clone(), unkeyed.clone()];
        let new_data = vec![unkeyed.clone(), keyed.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..2 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        assert_eq!(result.node_moves.len(), 2);
        
        // keyed: old[0] -> new[1] (matched by key)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(1)
        ));
        // unkeyed: old[1] -> new[0] (matched by hash)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(0)
        ));
    }

    #[test]
    fn test_duplicate_keys() {
        // Two nodes with the same key - first one wins
        let mut node1 = NodeData::create_div();
        node1.set_key("duplicate");
        node1.add_class(azul_css::AzString::from("first"));
        
        let mut node2 = NodeData::create_div();
        node2.set_key("duplicate");
        node2.add_class(azul_css::AzString::from("second"));
        
        let old_data = vec![node1.clone()];
        let new_data = vec![node2.clone()];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should match by key
        assert_eq!(result.node_moves.len(), 1);
    }

    #[test]
    fn test_key_not_in_old() {
        // New node has a key that didn't exist in old
        let old_div = NodeData::create_div();
        
        let mut new_div = NodeData::create_div();
        new_div.set_key("new-key");
        
        let old_data = vec![old_div];
        let new_data = vec![new_div];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Key doesn't match, so new keyed node is mount, old unkeyed is unmount
        // No events because no callbacks
        assert!(result.node_moves.is_empty()); // No match by key or hash
    }

    #[test]
    fn test_large_list_reorder() {
        use azul_css::AzString;
        
        // Create 100 unique nodes
        let nodes: Vec<NodeData> = (0..100).map(|i| {
            let mut node = NodeData::create_div();
            node.add_class(AzString::from(format!("item-{}", i)));
            node
        }).collect();
        
        // Reverse the order
        let old_data = nodes.clone();
        let new_data: Vec<NodeData> = nodes.into_iter().rev().collect();
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..100 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // All 100 nodes should be matched (just reordered)
        assert_eq!(result.node_moves.len(), 100);
        assert!(result.events.is_empty());
    }

    #[test]
    fn test_migration_map() {
        use azul_css::AzString;
        
        let mut div_a = NodeData::create_div();
        div_a.add_class(AzString::from("a"));
        let mut div_b = NodeData::create_div();
        div_b.add_class(AzString::from("b"));
        
        let old_data = vec![div_a.clone(), div_b.clone()];
        let new_data = vec![div_b.clone(), div_a.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..2 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        let migration = create_migration_map(&result.node_moves);
        
        // old[0] (A) -> new[1]
        assert_eq!(migration.get(&NodeId::new(0)), Some(&NodeId::new(1)));
        // old[1] (B) -> new[0]
        assert_eq!(migration.get(&NodeId::new(1)), Some(&NodeId::new(0)));
    }

    #[test]
    fn test_different_node_types() {
        // Different node types should not match by hash
        let div = NodeData::create_div();
        let span = NodeData::create_node(crate::dom::NodeType::Span);
        
        let old_data = vec![div];
        let new_data = vec![span];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should not match (different types = different hashes)
        assert!(result.node_moves.is_empty());
    }

    #[test]
    fn test_text_nodes() {
        use azul_css::AzString;
        
        let text_a = NodeData::create_text(AzString::from("Hello"));
        let text_b = NodeData::create_text(AzString::from("World"));
        let text_a_copy = NodeData::create_text(AzString::from("Hello"));
        
        // Old: ["Hello", "World"], New: ["World", "Hello"]
        let old_data = vec![text_a.clone(), text_b.clone()];
        let new_data = vec![text_b.clone(), text_a_copy.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..2 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should match by content hash
        assert_eq!(result.node_moves.len(), 2);
    }

    #[test]
    fn test_shuffle_three() {
        use azul_css::AzString;
        
        let mut a = NodeData::create_div();
        a.add_class(AzString::from("a"));
        let mut b = NodeData::create_div();
        b.add_class(AzString::from("b"));
        let mut c = NodeData::create_div();
        c.add_class(AzString::from("c"));
        
        // Old: [A, B, C], New: [B, C, A]
        let old_data = vec![a.clone(), b.clone(), c.clone()];
        let new_data = vec![b.clone(), c.clone(), a.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..3 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        assert_eq!(result.node_moves.len(), 3);
        
        // A: old[0] -> new[2]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(2)
        ));
        // B: old[1] -> new[0]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(0)
        ));
        // C: old[2] -> new[1]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(2) && m.new_node_id == NodeId::new(1)
        ));
    }

    // =========================================================================
    // MERGE CALLBACK / STATE MIGRATION TESTS
    // =========================================================================

    use crate::refany::{RefAny, OptionRefAny};
    use crate::dom::DatasetMergeCallbackType;
    use alloc::sync::Arc;
    use core::cell::RefCell;
    
    /// Test data simulating a video player with a heavy decoder handle
    struct VideoPlayerState {
        url: alloc::string::String,
        decoder_handle: Option<u64>, // Simulates heavy resource (e.g., FFmpeg handle)
    }

    /// Simple merge callback that transfers decoder_handle from old to new
    extern "C" fn merge_video_state(mut new_data: RefAny, mut old_data: RefAny) -> RefAny {
        // Get mutable access to new, immutable to old
        if let Some(mut new_guard) = new_data.downcast_mut::<VideoPlayerState>() {
            if let Some(old_guard) = old_data.downcast_ref::<VideoPlayerState>() {
                // Transfer heavy resource
                new_guard.decoder_handle = old_guard.decoder_handle;
            }
        }
        new_data
    }

    #[test]
    fn test_transfer_states_basic() {
        // Scenario: Video player moves from index 0 to index 1
        // The decoder handle should be preserved
        
        let old_state = VideoPlayerState {
            url: "movie.mp4".into(),
            decoder_handle: Some(12345),
        };
        let new_state = VideoPlayerState {
            url: "movie.mp4".into(),
            decoder_handle: None, // Fresh state, no handle yet
        };
        
        let mut old_node = NodeData::create_div();
        old_node.dataset = OptionRefAny::Some(RefAny::new(old_state));
        
        let mut new_node = NodeData::create_div();
        new_node.dataset = OptionRefAny::Some(RefAny::new(new_state));
        new_node.set_merge_callback(merge_video_state as DatasetMergeCallbackType);
        
        let mut old_data = vec![old_node];
        let mut new_data = vec![new_node];
        
        let moves = vec![NodeMove {
            old_node_id: NodeId::new(0),
            new_node_id: NodeId::new(0),
        }];
        
        // Execute state migration
        transfer_states(&mut old_data, &mut new_data, &moves);
        
        // Verify the handle was transferred
        if let OptionRefAny::Some(ref mut dataset) = new_data[0].dataset {
            let guard = dataset.downcast_ref::<VideoPlayerState>().unwrap();
            assert_eq!(guard.decoder_handle, Some(12345));
        } else {
            panic!("Dataset should exist");
        }
    }

    #[test]
    fn test_transfer_states_no_callback_no_transfer() {
        // If no merge callback is set, nothing should happen
        
        let old_state = VideoPlayerState {
            url: "movie.mp4".into(),
            decoder_handle: Some(99999),
        };
        let new_state = VideoPlayerState {
            url: "movie.mp4".into(),
            decoder_handle: None,
        };
        
        let mut old_node = NodeData::create_div();
        old_node.dataset = OptionRefAny::Some(RefAny::new(old_state));
        
        let mut new_node = NodeData::create_div();
        new_node.dataset = OptionRefAny::Some(RefAny::new(new_state));
        // NO merge callback set!
        
        let mut old_data = vec![old_node];
        let mut new_data = vec![new_node];
        
        let moves = vec![NodeMove {
            old_node_id: NodeId::new(0),
            new_node_id: NodeId::new(0),
        }];
        
        transfer_states(&mut old_data, &mut new_data, &moves);
        
        // Handle should NOT be transferred (no callback)
        if let OptionRefAny::Some(ref mut dataset) = new_data[0].dataset {
            let guard = dataset.downcast_ref::<VideoPlayerState>().unwrap();
            assert_eq!(guard.decoder_handle, None); // Still None!
        } else {
            panic!("Dataset should exist");
        }
    }

    #[test]
    fn test_transfer_states_no_old_dataset() {
        // If old node has no dataset, merge should not crash
        
        let new_state = VideoPlayerState {
            url: "movie.mp4".into(),
            decoder_handle: None,
        };
        
        let old_node = NodeData::create_div(); // No dataset
        
        let mut new_node = NodeData::create_div();
        new_node.dataset = OptionRefAny::Some(RefAny::new(new_state));
        new_node.set_merge_callback(merge_video_state as DatasetMergeCallbackType);
        
        let mut old_data = vec![old_node];
        let mut new_data = vec![new_node];
        
        let moves = vec![NodeMove {
            old_node_id: NodeId::new(0),
            new_node_id: NodeId::new(0),
        }];
        
        // Should not panic
        transfer_states(&mut old_data, &mut new_data, &moves);
        
        // New node should still have its dataset (unmodified)
        if let OptionRefAny::Some(ref mut dataset) = new_data[0].dataset {
            let guard = dataset.downcast_ref::<VideoPlayerState>().unwrap();
            assert_eq!(guard.decoder_handle, None);
        } else {
            panic!("Dataset should still exist");
        }
    }

    #[test]
    fn test_transfer_states_no_new_dataset() {
        // If new node has merge callback but no dataset, nothing should happen
        
        let old_state = VideoPlayerState {
            url: "movie.mp4".into(),
            decoder_handle: Some(77777),
        };
        
        let mut old_node = NodeData::create_div();
        old_node.dataset = OptionRefAny::Some(RefAny::new(old_state));
        
        let mut new_node = NodeData::create_div();
        // No dataset on new node!
        new_node.set_merge_callback(merge_video_state as DatasetMergeCallbackType);
        
        let mut old_data = vec![old_node];
        let mut new_data = vec![new_node];
        
        let moves = vec![NodeMove {
            old_node_id: NodeId::new(0),
            new_node_id: NodeId::new(0),
        }];
        
        // Should not panic
        transfer_states(&mut old_data, &mut new_data, &moves);
        
        // New node should still have no dataset
        assert!(matches!(new_data[0].dataset, OptionRefAny::None));
    }

    #[test]
    fn test_transfer_states_reorder_preserves_handles() {
        // Scenario: Two video players swap positions
        // Each should keep its own decoder handle
        
        let state_a = VideoPlayerState { url: "a.mp4".into(), decoder_handle: Some(111) };
        let state_b = VideoPlayerState { url: "b.mp4".into(), decoder_handle: Some(222) };
        
        let mut old_a = NodeData::create_div();
        old_a.set_key("player-a");
        old_a.dataset = OptionRefAny::Some(RefAny::new(state_a));
        
        let mut old_b = NodeData::create_div();
        old_b.set_key("player-b");
        old_b.dataset = OptionRefAny::Some(RefAny::new(state_b));
        
        // New order: B, A (swapped)
        let new_state_b = VideoPlayerState { url: "b.mp4".into(), decoder_handle: None };
        let new_state_a = VideoPlayerState { url: "a.mp4".into(), decoder_handle: None };
        
        let mut new_b = NodeData::create_div();
        new_b.set_key("player-b");
        new_b.dataset = OptionRefAny::Some(RefAny::new(new_state_b));
        new_b.set_merge_callback(merge_video_state as DatasetMergeCallbackType);
        
        let mut new_a = NodeData::create_div();
        new_a.set_key("player-a");
        new_a.dataset = OptionRefAny::Some(RefAny::new(new_state_a));
        new_a.set_merge_callback(merge_video_state as DatasetMergeCallbackType);
        
        let mut old_data = vec![old_a, old_b];  // [A@0, B@1]
        let mut new_data = vec![new_b, new_a];  // [B@0, A@1]
        
        // Moves from reconciliation: old_a(0)->new(1), old_b(1)->new(0)
        let moves = vec![
            NodeMove { old_node_id: NodeId::new(0), new_node_id: NodeId::new(1) }, // A
            NodeMove { old_node_id: NodeId::new(1), new_node_id: NodeId::new(0) }, // B
        ];
        
        transfer_states(&mut old_data, &mut new_data, &moves);
        
        // new[0] should be B with handle 222
        if let OptionRefAny::Some(ref mut ds) = new_data[0].dataset {
            let guard = ds.downcast_ref::<VideoPlayerState>().unwrap();
            assert_eq!(guard.url, "b.mp4");
            assert_eq!(guard.decoder_handle, Some(222));
        } else {
            panic!("B dataset missing");
        }
        
        // new[1] should be A with handle 111
        if let OptionRefAny::Some(ref mut ds) = new_data[1].dataset {
            let guard = ds.downcast_ref::<VideoPlayerState>().unwrap();
            assert_eq!(guard.url, "a.mp4");
            assert_eq!(guard.decoder_handle, Some(111));
        } else {
            panic!("A dataset missing");
        }
    }

    #[test]
    fn test_transfer_states_out_of_bounds() {
        // Invalid node moves should be skipped gracefully
        
        let state = VideoPlayerState { url: "test.mp4".into(), decoder_handle: Some(123) };
        
        let mut old_node = NodeData::create_div();
        old_node.dataset = OptionRefAny::Some(RefAny::new(state));
        
        let mut old_data = vec![old_node];
        let mut new_data: Vec<NodeData> = vec![]; // Empty!
        
        let moves = vec![NodeMove {
            old_node_id: NodeId::new(0),
            new_node_id: NodeId::new(999), // Out of bounds
        }];
        
        // Should not panic
        transfer_states(&mut old_data, &mut new_data, &moves);
    }

    /// Test with a more complex type that uses interior mutability
    struct WebGLContext {
        texture_ids: alloc::vec::Vec<u32>,
        shader_program: Option<u32>,
    }

    extern "C" fn merge_webgl_context(mut new_data: RefAny, mut old_data: RefAny) -> RefAny {
        if let Some(mut new_guard) = new_data.downcast_mut::<WebGLContext>() {
            if let Some(old_guard) = old_data.downcast_ref::<WebGLContext>() {
                // Transfer all GL resources
                new_guard.texture_ids = old_guard.texture_ids.clone();
                new_guard.shader_program = old_guard.shader_program;
            }
        }
        new_data
    }

    #[test]
    fn test_transfer_states_complex_type() {
        let old_ctx = WebGLContext {
            texture_ids: vec![1, 2, 3, 4, 5],
            shader_program: Some(42),
        };
        let new_ctx = WebGLContext {
            texture_ids: vec![],
            shader_program: None,
        };
        
        let mut old_node = NodeData::create_div();
        old_node.dataset = OptionRefAny::Some(RefAny::new(old_ctx));
        
        let mut new_node = NodeData::create_div();
        new_node.dataset = OptionRefAny::Some(RefAny::new(new_ctx));
        new_node.set_merge_callback(merge_webgl_context as DatasetMergeCallbackType);
        
        let mut old_data = vec![old_node];
        let mut new_data = vec![new_node];
        
        let moves = vec![NodeMove {
            old_node_id: NodeId::new(0),
            new_node_id: NodeId::new(0),
        }];
        
        transfer_states(&mut old_data, &mut new_data, &moves);
        
        if let OptionRefAny::Some(ref mut ds) = new_data[0].dataset {
            let guard = ds.downcast_ref::<WebGLContext>().unwrap();
            assert_eq!(guard.texture_ids, vec![1, 2, 3, 4, 5]);
            assert_eq!(guard.shader_program, Some(42));
        } else {
            panic!("Dataset missing");
        }
    }

    #[test]
    fn test_transfer_states_callback_returns_old_data() {
        // Test that callback can choose to return old_data instead of new_data
        
        struct Counter {
            value: u32,
        }
        
        extern "C" fn prefer_old(_new_data: RefAny, old_data: RefAny) -> RefAny {
            // Return old_data to preserve the old state entirely
            old_data
        }
        
        let old_counter = Counter { value: 100 };
        let new_counter = Counter { value: 0 };
        
        let mut old_node = NodeData::create_div();
        old_node.dataset = OptionRefAny::Some(RefAny::new(old_counter));
        
        let mut new_node = NodeData::create_div();
        new_node.dataset = OptionRefAny::Some(RefAny::new(new_counter));
        new_node.set_merge_callback(prefer_old as DatasetMergeCallbackType);
        
        let mut old_data = vec![old_node];
        let mut new_data = vec![new_node];
        
        let moves = vec![NodeMove {
            old_node_id: NodeId::new(0),
            new_node_id: NodeId::new(0),
        }];
        
        transfer_states(&mut old_data, &mut new_data, &moves);
        
        // The callback returned old_data, so new node should have value=100
        if let OptionRefAny::Some(ref mut ds) = new_data[0].dataset {
            let guard = ds.downcast_ref::<Counter>().unwrap();
            assert_eq!(guard.value, 100);
        } else {
            panic!("Dataset missing");
        }
    }

    #[test]
    fn test_transfer_states_multiple_nodes_partial_callbacks() {
        // Scenario: 3 nodes, only middle one has merge callback
        
        struct Simple { val: u32 }
        
        extern "C" fn merge_simple(mut new_data: RefAny, mut old_data: RefAny) -> RefAny {
            if let Some(mut new_g) = new_data.downcast_mut::<Simple>() {
                if let Some(old_g) = old_data.downcast_ref::<Simple>() {
                    new_g.val = old_g.val;
                }
            }
            new_data
        }
        
        let mut old_nodes = vec![
            {
                let mut n = NodeData::create_div();
                n.dataset = OptionRefAny::Some(RefAny::new(Simple { val: 1 }));
                n
            },
            {
                let mut n = NodeData::create_div();
                n.dataset = OptionRefAny::Some(RefAny::new(Simple { val: 2 }));
                n
            },
            {
                let mut n = NodeData::create_div();
                n.dataset = OptionRefAny::Some(RefAny::new(Simple { val: 3 }));
                n
            },
        ];
        
        let mut new_nodes = vec![
            {
                let mut n = NodeData::create_div();
                n.dataset = OptionRefAny::Some(RefAny::new(Simple { val: 10 }));
                // NO callback
                n
            },
            {
                let mut n = NodeData::create_div();
                n.dataset = OptionRefAny::Some(RefAny::new(Simple { val: 20 }));
                n.set_merge_callback(merge_simple as DatasetMergeCallbackType); // HAS callback
                n
            },
            {
                let mut n = NodeData::create_div();
                n.dataset = OptionRefAny::Some(RefAny::new(Simple { val: 30 }));
                // NO callback
                n
            },
        ];
        
        let moves = vec![
            NodeMove { old_node_id: NodeId::new(0), new_node_id: NodeId::new(0) },
            NodeMove { old_node_id: NodeId::new(1), new_node_id: NodeId::new(1) },
            NodeMove { old_node_id: NodeId::new(2), new_node_id: NodeId::new(2) },
        ];
        
        transfer_states(&mut old_nodes, &mut new_nodes, &moves);
        
        // Node 0: no callback, should keep val=10
        if let OptionRefAny::Some(ref mut ds) = new_nodes[0].dataset {
            let g = ds.downcast_ref::<Simple>().unwrap();
            assert_eq!(g.val, 10);
        }
        
        // Node 1: has callback, should get val=2 from old
        if let OptionRefAny::Some(ref mut ds) = new_nodes[1].dataset {
            let g = ds.downcast_ref::<Simple>().unwrap();
            assert_eq!(g.val, 2);
        }
        
        // Node 2: no callback, should keep val=30
        if let OptionRefAny::Some(ref mut ds) = new_nodes[2].dataset {
            let g = ds.downcast_ref::<Simple>().unwrap();
            assert_eq!(g.val, 30);
        }
    }

    #[test]
    fn test_transfer_states_empty_moves() {
        // No moves = no transfers
        let mut old_data: Vec<NodeData> = vec![];
        let mut new_data: Vec<NodeData> = vec![];
        let moves: Vec<NodeMove> = vec![];
        
        // Should not panic
        transfer_states(&mut old_data, &mut new_data, &moves);
    }

    #[test]
    fn test_reconcile_then_transfer_integration() {
        // Full integration test: reconcile DOM, then transfer states
        
        struct AppState { 
            name: alloc::string::String, 
            heavy_handle: Option<u64> 
        }
        
        extern "C" fn merge_app(mut new_data: RefAny, mut old_data: RefAny) -> RefAny {
            if let Some(mut new_g) = new_data.downcast_mut::<AppState>() {
                if let Some(old_g) = old_data.downcast_ref::<AppState>() {
                    new_g.heavy_handle = old_g.heavy_handle;
                }
            }
            new_data
        }
        
        // OLD DOM: one node with key "main" and handle=999
        let old_state = AppState { name: "old".into(), heavy_handle: Some(999) };
        let mut old_node = NodeData::create_div();
        old_node.set_key("main");
        old_node.dataset = OptionRefAny::Some(RefAny::new(old_state));
        
        // NEW DOM: same key, new state, needs merge
        let new_state = AppState { name: "new".into(), heavy_handle: None };
        let mut new_node = NodeData::create_div();
        new_node.set_key("main");
        new_node.dataset = OptionRefAny::Some(RefAny::new(new_state));
        new_node.set_merge_callback(merge_app as DatasetMergeCallbackType);
        
        let mut old_data = vec![old_node];
        let mut new_data = vec![new_node];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        // Step 1: Reconcile
        let diff = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should match by key
        assert_eq!(diff.node_moves.len(), 1);
        assert_eq!(diff.node_moves[0].old_node_id, NodeId::new(0));
        assert_eq!(diff.node_moves[0].new_node_id, NodeId::new(0));
        
        // Step 2: Transfer states
        transfer_states(&mut old_data, &mut new_data, &diff.node_moves);
        
        // Verify: name should be "new", handle should be 999
        if let OptionRefAny::Some(ref mut ds) = new_data[0].dataset {
            let g = ds.downcast_ref::<AppState>().unwrap();
            assert_eq!(g.name, "new");
            assert_eq!(g.heavy_handle, Some(999));
        } else {
            panic!("Dataset missing");
        }
    }
    
    // ========== CURSOR RECONCILIATION TESTS ==========
    
    #[test]
    fn test_cursor_reconcile_identical_text() {
        let result = reconcile_cursor_position("Hello", "Hello", 3);
        assert_eq!(result, 3);
    }
    
    #[test]
    fn test_cursor_reconcile_text_appended() {
        // Cursor at end of "Hello", text becomes "Hello World"
        let result = reconcile_cursor_position("Hello", "Hello World", 5);
        assert_eq!(result, 5); // Cursor stays at same position (in prefix)
    }
    
    #[test]
    fn test_cursor_reconcile_text_prepended() {
        // Cursor at "H|ello", text becomes "Say Hello"
        // The "H" is no longer at position 1, so cursor goes to changed region end
        let result = reconcile_cursor_position("Hello", "Say Hello", 1);
        assert_eq!(result, 4); // End of inserted content
    }
    
    #[test]
    fn test_cursor_reconcile_suffix_preserved() {
        // Text: "Hello World" -> "Hi World", cursor at "World" (position 6)
        // "World" is in suffix, so cursor should adjust
        let result = reconcile_cursor_position("Hello World", "Hi World", 6);
        // In old text: "Hello World" (11 chars), cursor at 6
        // Suffix " World" (6 chars) is preserved
        // Old suffix starts at 5 (11-6), new suffix starts at 2 (8-6)
        // Cursor is at 6, which is in suffix (>= 5)
        // Offset from end: 11-6 = 5, new position: 8-5 = 3
        assert_eq!(result, 3);
    }
    
    #[test]
    fn test_cursor_reconcile_empty_to_text() {
        let result = reconcile_cursor_position("", "Hello", 0);
        assert_eq!(result, 5); // Cursor at end of new text
    }
    
    #[test]
    fn test_cursor_reconcile_text_to_empty() {
        let result = reconcile_cursor_position("Hello", "", 3);
        assert_eq!(result, 0); // Cursor at 0
    }
    
    #[test]
    fn test_cursor_reconcile_insert_at_cursor() {
        // Typing 'X' at cursor position 3 in "Hello" -> "HelXlo"
        let result = reconcile_cursor_position("Hello", "HelXlo", 3);
        // Common prefix: "Hel" (3 bytes), cursor is at 3 (at end of prefix)
        // Should stay at 3
        assert_eq!(result, 3);
    }
    
    #[test]
    fn test_structural_hash_text_nodes_match() {
        use azul_css::AzString;
        
        // Two text nodes with different content should have same structural hash
        let text_a = NodeData::create_text(AzString::from("Hello"));
        let text_b = NodeData::create_text(AzString::from("Hello World"));
        
        // Content hash should be different
        assert_ne!(text_a.calculate_node_data_hash(), text_b.calculate_node_data_hash());
        
        // Structural hash should be the same (both are Text nodes)
        assert_eq!(text_a.calculate_structural_hash(), text_b.calculate_structural_hash());
    }
    
    #[test]
    fn test_structural_hash_different_types() {
        use azul_css::AzString;
        
        // Div and Text should have different structural hashes
        let div = NodeData::create_div();
        let text = NodeData::create_text(AzString::from("Hello"));
        
        assert_ne!(div.calculate_structural_hash(), text.calculate_structural_hash());
    }
    
    #[test]
    fn test_text_nodes_match_by_structural_hash() {
        use azul_css::AzString;
        
        // Old DOM has Text("Hello"), new DOM has Text("Hello World")
        // They should match by structural hash
        let old_data = vec![NodeData::create_text(AzString::from("Hello"))];
        let new_data = vec![NodeData::create_text(AzString::from("Hello World"))];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should match by structural hash (same node, just different text content)
        assert_eq!(result.node_moves.len(), 1);
        assert_eq!(result.node_moves[0].old_node_id, NodeId::new(0));
        assert_eq!(result.node_moves[0].new_node_id, NodeId::new(0));
    }
}