//! DOM Reconciliation Module
//!
//! This module provides the reconciliation algorithm that compares two DOM trees
//! and generates lifecycle events. It uses stable keys and content hashing to
//! identify moves vs. mounts/unmounts.
//!
//! The reconciliation strategy is:
//! 1. **Stable Key Match:** If `.with_key()` is used, it's an absolute match (O(1)).
//! 2. **Hash Match (Content Match):** If no key, check if there is an unused node in the old
//!    list with the exact same `DomNodeHash`. This enables "automagic" reordering detection.
//! 3. **Fallback:** Anything not matched is a `Mount` (new) or `Unmount` (old leftovers).

use alloc::{collections::VecDeque, vec::Vec};

use crate::{
    dom::{DomId, DomNodeHash, DomNodeId, NodeData},
    events::{
        ComponentEventFilter, EventData, EventFilter, EventPhase, EventSource, EventType,
        LifecycleEventData, LifecycleReason, SyntheticEvent,
    },
    geom::LogicalRect,
    id::NodeId,
    styled_dom::NodeHierarchyItemId,
    task::Instant,
    FastHashMap,
};

/// Represents a mapping between a node in the old DOM and the new DOM.
#[derive(Debug, Clone, Copy)]
pub struct NodeMove {
    /// The NodeId in the old DOM array
    pub old_node_id: NodeId,
    /// The NodeId in the new DOM array
    pub new_node_id: NodeId,
}

/// The result of a DOM diff, containing lifecycle events and node mappings.
#[derive(Debug, Clone)]
pub struct DiffResult {
    /// Lifecycle events generated by the diff (Mount, Unmount, Resize, Update)
    pub events: Vec<SyntheticEvent>,
    /// Maps Old NodeId -> New NodeId for state migration (focus, scroll, etc.)
    pub node_moves: Vec<NodeMove>,
}

impl Default for DiffResult {
    fn default() -> Self {
        Self {
            events: Vec::new(),
            node_moves: Vec::new(),
        }
    }
}

/// Calculates the difference between two DOM frames and generates lifecycle events.
///
/// This is the main entry point for DOM reconciliation. It compares the old and new
/// DOM trees and produces:
/// - Mount events for new nodes
/// - Unmount events for removed nodes
/// - Resize events for nodes whose bounds changed
/// - Update events for nodes whose content changed (when matched by key)
///
/// # Arguments
/// * `old_node_data` - Node data from the previous frame
/// * `new_node_data` - Node data from the current frame
/// * `old_layout` - Layout bounds from the previous frame
/// * `new_layout` - Layout bounds from the current frame
/// * `dom_id` - The DOM identifier
/// * `timestamp` - Current timestamp for events
pub fn reconcile_dom(
    old_node_data: &[NodeData],
    new_node_data: &[NodeData],
    old_layout: &FastHashMap<NodeId, LogicalRect>,
    new_layout: &FastHashMap<NodeId, LogicalRect>,
    dom_id: DomId,
    timestamp: Instant,
) -> DiffResult {
    let mut result = DiffResult::default();

    // --- STEP 1: INDEX THE OLD DOM ---
    // Create lookups to find old nodes by Key or by Hash.

    let mut old_keyed: FastHashMap<u64, NodeId> = FastHashMap::default();
    let mut old_hashed: FastHashMap<DomNodeHash, VecDeque<NodeId>> = FastHashMap::default();
    let mut old_nodes_consumed = vec![false; old_node_data.len()];

    for (idx, node) in old_node_data.iter().enumerate() {
        let id = NodeId::new(idx);

        if let Some(key) = node.get_key() {
            // Priority 1: Explicit Key
            old_keyed.insert(key, id);
        } else {
            // Priority 2: Content Hash
            let hash = node.calculate_node_data_hash();
            old_hashed.entry(hash).or_default().push_back(id);
        }
    }

    // --- STEP 2: ITERATE NEW DOM AND CLAIM MATCHES ---

    for (new_idx, new_node) in new_node_data.iter().enumerate() {
        let new_id = NodeId::new(new_idx);
        let mut matched_old_id = None;

        // A. Try Match by Key
        if let Some(key) = new_node.get_key() {
            if let Some(&old_id) = old_keyed.get(&key) {
                if !old_nodes_consumed[old_id.index()] {
                    matched_old_id = Some(old_id);
                }
            }
        }
        // B. Try Match by Content Hash (The "Automagic" Reordering)
        else {
            let hash = new_node.calculate_node_data_hash();

            // Get the queue of old nodes with this identical content
            if let Some(queue) = old_hashed.get_mut(&hash) {
                // Find first non-consumed node in queue
                while let Some(old_id) = queue.front() {
                    if !old_nodes_consumed[old_id.index()] {
                        matched_old_id = Some(*old_id);
                        queue.pop_front();
                        break;
                    } else {
                        queue.pop_front();
                    }
                }
            }
        }

        // --- STEP 3: PROCESS MATCH OR MOUNT ---

        if let Some(old_id) = matched_old_id {
            // FOUND A MATCH (It might be at a different index, but it's the "same" node)

            old_nodes_consumed[old_id.index()] = true;
            result.node_moves.push(NodeMove {
                old_node_id: old_id,
                new_node_id: new_id,
            });

            // Check for Resize
            let old_rect = old_layout.get(&old_id).copied().unwrap_or(LogicalRect::zero());
            let new_rect = new_layout.get(&new_id).copied().unwrap_or(LogicalRect::zero());

            if old_rect.size != new_rect.size {
                // Fire Resize Event
                if has_resize_callback(new_node) {
                    result.events.push(create_lifecycle_event(
                        EventType::Resize,
                        new_id,
                        dom_id,
                        &timestamp,
                        LifecycleEventData {
                            reason: LifecycleReason::Resize,
                            previous_bounds: Some(old_rect),
                            current_bounds: new_rect,
                        },
                    ));
                }
            }

            // If matched by Key, the content might have changed, so we should check hash equality.
            if new_node.get_key().is_some() {
                let old_hash = old_node_data[old_id.index()].calculate_node_data_hash();
                let new_hash = new_node.calculate_node_data_hash();

                if old_hash != new_hash && has_update_callback(new_node) {
                    result.events.push(create_lifecycle_event(
                        EventType::Update,
                        new_id,
                        dom_id,
                        &timestamp,
                        LifecycleEventData {
                            reason: LifecycleReason::Update,
                            previous_bounds: Some(old_rect),
                            current_bounds: new_rect,
                        },
                    ));
                }
            }
        } else {
            // NO MATCH FOUND -> MOUNT (New Node)
            if has_mount_callback(new_node) {
                let bounds = new_layout.get(&new_id).copied().unwrap_or(LogicalRect::zero());
                result.events.push(create_lifecycle_event(
                    EventType::Mount,
                    new_id,
                    dom_id,
                    &timestamp,
                    LifecycleEventData {
                        reason: LifecycleReason::InitialMount,
                        previous_bounds: None,
                        current_bounds: bounds,
                    },
                ));
            }
        }
    }

    // --- STEP 4: CLEANUP (UNMOUNTS) ---
    // Any old node that wasn't claimed is effectively destroyed.

    for (old_idx, consumed) in old_nodes_consumed.iter().enumerate() {
        if !consumed {
            let old_id = NodeId::new(old_idx);
            let old_node = &old_node_data[old_idx];

            if has_unmount_callback(old_node) {
                let bounds = old_layout.get(&old_id).copied().unwrap_or(LogicalRect::zero());
                result.events.push(create_lifecycle_event(
                    EventType::Unmount,
                    old_id,
                    dom_id,
                    &timestamp,
                    LifecycleEventData {
                        reason: LifecycleReason::InitialMount, // Context implies unmount
                        previous_bounds: Some(bounds),
                        current_bounds: LogicalRect::zero(),
                    },
                ));
            }
        }
    }

    result
}

/// Creates a lifecycle event with all necessary fields.
fn create_lifecycle_event(
    event_type: EventType,
    node_id: NodeId,
    dom_id: DomId,
    timestamp: &Instant,
    data: LifecycleEventData,
) -> SyntheticEvent {
    let dom_node_id = DomNodeId {
        dom: dom_id,
        node: NodeHierarchyItemId::from_crate_internal(Some(node_id)),
    };
    SyntheticEvent {
        event_type,
        source: EventSource::Lifecycle,
        phase: EventPhase::Target,
        target: dom_node_id,
        current_target: dom_node_id,
        timestamp: timestamp.clone(),
        data: EventData::Lifecycle(data),
        stopped: false,
        stopped_immediate: false,
        prevented_default: false,
    }
}

/// Check if the node has an AfterMount callback registered.
fn has_mount_callback(node: &NodeData) -> bool {
    node.get_callbacks().iter().any(|cb| {
        matches!(
            cb.event,
            EventFilter::Component(ComponentEventFilter::AfterMount)
        )
    })
}

/// Check if the node has a BeforeUnmount callback registered.
fn has_unmount_callback(node: &NodeData) -> bool {
    node.get_callbacks().iter().any(|cb| {
        matches!(
            cb.event,
            EventFilter::Component(ComponentEventFilter::BeforeUnmount)
        )
    })
}

/// Check if the node has a NodeResized callback registered.
fn has_resize_callback(node: &NodeData) -> bool {
    node.get_callbacks().iter().any(|cb| {
        matches!(
            cb.event,
            EventFilter::Component(ComponentEventFilter::NodeResized)
        )
    })
}

/// Check if the node has any lifecycle callback that would respond to updates.
fn has_update_callback(node: &NodeData) -> bool {
    // For now, we use Selected as a placeholder for "update" events
    // This could be extended to a dedicated UpdateCallback in the future
    node.get_callbacks().iter().any(|cb| {
        matches!(
            cb.event,
            EventFilter::Component(ComponentEventFilter::Selected)
        )
    })
}

/// Migrate state (focus, scroll, etc.) from old node IDs to new node IDs.
///
/// This function should be called after reconciliation to update any state
/// that references old NodeIds to use the new NodeIds.
///
/// # Example
/// ```rust
/// let diff = reconcile_dom(...);
/// let migration_map = create_migration_map(&diff.node_moves);
/// 
/// // Migrate focus
/// if let Some(current_focus) = focus_manager.focused_node {
///     if let Some(&new_id) = migration_map.get(&current_focus) {
///         focus_manager.focused_node = Some(new_id);
///     } else {
///         // Focused node was unmounted, clear focus
///         focus_manager.focused_node = None;
///     }
/// }
/// ```
pub fn create_migration_map(node_moves: &[NodeMove]) -> FastHashMap<NodeId, NodeId> {
    let mut map = FastHashMap::default();
    for m in node_moves {
        map.insert(m.old_node_id, m.new_node_id);
    }
    map
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::dom::NodeData;

    #[test]
    fn test_simple_mount() {
        let old_data: Vec<NodeData> = vec![];
        let new_data = vec![NodeData::create_div()];
        
        let old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // No mount event because no callback is registered
        assert!(result.events.is_empty());
        assert!(result.node_moves.is_empty());
    }

    #[test]
    fn test_identical_nodes_match() {
        let div = NodeData::create_div();
        let old_data = vec![div.clone()];
        let new_data = vec![div.clone()];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should match by hash, no lifecycle events
        assert!(result.events.is_empty());
        assert_eq!(result.node_moves.len(), 1);
        assert_eq!(result.node_moves[0].old_node_id, NodeId::new(0));
        assert_eq!(result.node_moves[0].new_node_id, NodeId::new(0));
    }

    #[test]
    fn test_reorder_by_hash() {
        use azul_css::AzString;
        
        let mut div_a = NodeData::create_div();
        div_a.add_class(AzString::from("a"));
        let mut div_b = NodeData::create_div();
        div_b.add_class(AzString::from("b"));
        
        // Old: [A, B], New: [B, A]
        let old_data = vec![div_a.clone(), div_b.clone()];
        let new_data = vec![div_b.clone(), div_a.clone()];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        old_layout.insert(NodeId::new(1), LogicalRect::zero());
        
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        new_layout.insert(NodeId::new(1), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Both should match by hash (reorder detected)
        assert!(result.events.is_empty());
        assert_eq!(result.node_moves.len(), 2);
        
        // B (old index 1) -> B (new index 0)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(0)
        ));
        // A (old index 0) -> A (new index 1)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(1)
        ));
    }

    // ========== EDGE CASE TESTS ==========

    #[test]
    fn test_empty_to_empty() {
        let old_data: Vec<NodeData> = vec![];
        let new_data: Vec<NodeData> = vec![];
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &FastHashMap::default(),
            &FastHashMap::default(),
            DomId { inner: 0 },
            Instant::now(),
        );
        
        assert!(result.events.is_empty());
        assert!(result.node_moves.is_empty());
    }

    #[test]
    fn test_all_nodes_removed() {
        let old_data = vec![
            NodeData::create_div(),
            NodeData::create_div(),
            NodeData::create_div(),
        ];
        let new_data: Vec<NodeData> = vec![];
        
        let mut old_layout = FastHashMap::default();
        for i in 0..3 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &FastHashMap::default(),
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // No events because no callbacks, but no node moves either
        assert!(result.events.is_empty());
        assert!(result.node_moves.is_empty());
    }

    #[test]
    fn test_all_nodes_added() {
        let old_data: Vec<NodeData> = vec![];
        let new_data = vec![
            NodeData::create_div(),
            NodeData::create_div(),
            NodeData::create_div(),
        ];
        
        let mut new_layout = FastHashMap::default();
        for i in 0..3 {
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &FastHashMap::default(),
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // No events because no callbacks, but no node moves (all are new)
        assert!(result.events.is_empty());
        assert!(result.node_moves.is_empty());
    }

    #[test]
    fn test_keyed_node_match() {
        // Create two nodes with the same key but different content
        let mut old_node = NodeData::create_div();
        old_node.set_key("my-key");
        
        let mut new_node = NodeData::create_div();
        new_node.set_key("my-key");
        new_node.add_class(azul_css::AzString::from("updated"));
        
        let old_data = vec![old_node];
        let new_data = vec![new_node];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should match by key even though hash is different
        assert_eq!(result.node_moves.len(), 1);
        assert_eq!(result.node_moves[0].old_node_id, NodeId::new(0));
        assert_eq!(result.node_moves[0].new_node_id, NodeId::new(0));
    }

    #[test]
    fn test_keyed_reorder() {
        let mut node_a = NodeData::create_div();
        node_a.set_key("key-a");
        let mut node_b = NodeData::create_div();
        node_b.set_key("key-b");
        let mut node_c = NodeData::create_div();
        node_c.set_key("key-c");
        
        // Old: [A, B, C], New: [C, B, A]
        let old_data = vec![node_a.clone(), node_b.clone(), node_c.clone()];
        let new_data = vec![node_c.clone(), node_b.clone(), node_a.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..3 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        assert_eq!(result.node_moves.len(), 3);
        
        // C: old[2] -> new[0]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(2) && m.new_node_id == NodeId::new(0)
        ));
        // B: old[1] -> new[1] (unchanged position)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(1)
        ));
        // A: old[0] -> new[2]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(2)
        ));
    }

    #[test]
    fn test_identical_nodes_fifo() {
        // 5 identical divs - should match FIFO
        let div = NodeData::create_div();
        let old_data = vec![div.clone(), div.clone(), div.clone()];
        let new_data = vec![div.clone(), div.clone()]; // Remove last one
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..3 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        for i in 0..2 {
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // First two should match (FIFO), third is unmounted
        assert_eq!(result.node_moves.len(), 2);
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(0)
        ));
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(1)
        ));
    }

    #[test]
    fn test_insert_at_beginning() {
        use azul_css::AzString;
        
        let mut div_a = NodeData::create_div();
        div_a.add_class(AzString::from("a"));
        let mut div_b = NodeData::create_div();
        div_b.add_class(AzString::from("b"));
        let mut div_new = NodeData::create_div();
        div_new.add_class(AzString::from("new"));
        
        // Old: [A, B], New: [NEW, A, B]
        let old_data = vec![div_a.clone(), div_b.clone()];
        let new_data = vec![div_new.clone(), div_a.clone(), div_b.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..2 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        for i in 0..3 {
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // A and B should be matched (moved), NEW is mounted (but no callback)
        assert_eq!(result.node_moves.len(), 2);
        
        // A: old[0] -> new[1]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(1)
        ));
        // B: old[1] -> new[2]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(2)
        ));
    }

    #[test]
    fn test_insert_in_middle() {
        use azul_css::AzString;
        
        let mut div_a = NodeData::create_div();
        div_a.add_class(AzString::from("a"));
        let mut div_b = NodeData::create_div();
        div_b.add_class(AzString::from("b"));
        let mut div_new = NodeData::create_div();
        div_new.add_class(AzString::from("new"));
        
        // Old: [A, B], New: [A, NEW, B]
        let old_data = vec![div_a.clone(), div_b.clone()];
        let new_data = vec![div_a.clone(), div_new.clone(), div_b.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..2 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        for i in 0..3 {
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        assert_eq!(result.node_moves.len(), 2);
        
        // A: old[0] -> new[0] (same position)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(0)
        ));
        // B: old[1] -> new[2]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(2)
        ));
    }

    #[test]
    fn test_remove_from_middle() {
        use azul_css::AzString;
        
        let mut div_a = NodeData::create_div();
        div_a.add_class(AzString::from("a"));
        let mut div_b = NodeData::create_div();
        div_b.add_class(AzString::from("b"));
        let mut div_c = NodeData::create_div();
        div_c.add_class(AzString::from("c"));
        
        // Old: [A, B, C], New: [A, C]
        let old_data = vec![div_a.clone(), div_b.clone(), div_c.clone()];
        let new_data = vec![div_a.clone(), div_c.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..3 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        for i in 0..2 {
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // A and C matched, B unmounted (no callback so no event)
        assert_eq!(result.node_moves.len(), 2);
        
        // A: old[0] -> new[0]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(0)
        ));
        // C: old[2] -> new[1]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(2) && m.new_node_id == NodeId::new(1)
        ));
    }

    #[test]
    fn test_mixed_keyed_and_unkeyed() {
        use azul_css::AzString;
        
        let mut keyed = NodeData::create_div();
        keyed.set_key("my-key");
        keyed.add_class(AzString::from("keyed"));
        
        let mut unkeyed = NodeData::create_div();
        unkeyed.add_class(AzString::from("unkeyed"));
        
        // Old: [keyed, unkeyed], New: [unkeyed, keyed]
        let old_data = vec![keyed.clone(), unkeyed.clone()];
        let new_data = vec![unkeyed.clone(), keyed.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..2 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        assert_eq!(result.node_moves.len(), 2);
        
        // keyed: old[0] -> new[1] (matched by key)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(1)
        ));
        // unkeyed: old[1] -> new[0] (matched by hash)
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(0)
        ));
    }

    #[test]
    fn test_duplicate_keys() {
        // Two nodes with the same key - first one wins
        let mut node1 = NodeData::create_div();
        node1.set_key("duplicate");
        node1.add_class(azul_css::AzString::from("first"));
        
        let mut node2 = NodeData::create_div();
        node2.set_key("duplicate");
        node2.add_class(azul_css::AzString::from("second"));
        
        let old_data = vec![node1.clone()];
        let new_data = vec![node2.clone()];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should match by key
        assert_eq!(result.node_moves.len(), 1);
    }

    #[test]
    fn test_key_not_in_old() {
        // New node has a key that didn't exist in old
        let old_div = NodeData::create_div();
        
        let mut new_div = NodeData::create_div();
        new_div.set_key("new-key");
        
        let old_data = vec![old_div];
        let new_data = vec![new_div];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Key doesn't match, so new keyed node is mount, old unkeyed is unmount
        // No events because no callbacks
        assert!(result.node_moves.is_empty()); // No match by key or hash
    }

    #[test]
    fn test_large_list_reorder() {
        use azul_css::AzString;
        
        // Create 100 unique nodes
        let nodes: Vec<NodeData> = (0..100).map(|i| {
            let mut node = NodeData::create_div();
            node.add_class(AzString::from(format!("item-{}", i)));
            node
        }).collect();
        
        // Reverse the order
        let old_data = nodes.clone();
        let new_data: Vec<NodeData> = nodes.into_iter().rev().collect();
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..100 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // All 100 nodes should be matched (just reordered)
        assert_eq!(result.node_moves.len(), 100);
        assert!(result.events.is_empty());
    }

    #[test]
    fn test_migration_map() {
        use azul_css::AzString;
        
        let mut div_a = NodeData::create_div();
        div_a.add_class(AzString::from("a"));
        let mut div_b = NodeData::create_div();
        div_b.add_class(AzString::from("b"));
        
        let old_data = vec![div_a.clone(), div_b.clone()];
        let new_data = vec![div_b.clone(), div_a.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..2 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        let migration = create_migration_map(&result.node_moves);
        
        // old[0] (A) -> new[1]
        assert_eq!(migration.get(&NodeId::new(0)), Some(&NodeId::new(1)));
        // old[1] (B) -> new[0]
        assert_eq!(migration.get(&NodeId::new(1)), Some(&NodeId::new(0)));
    }

    #[test]
    fn test_different_node_types() {
        // Different node types should not match by hash
        let div = NodeData::create_div();
        let span = NodeData::create_node(crate::dom::NodeType::Span);
        
        let old_data = vec![div];
        let new_data = vec![span];
        
        let mut old_layout = FastHashMap::default();
        old_layout.insert(NodeId::new(0), LogicalRect::zero());
        let mut new_layout = FastHashMap::default();
        new_layout.insert(NodeId::new(0), LogicalRect::zero());
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should not match (different types = different hashes)
        assert!(result.node_moves.is_empty());
    }

    #[test]
    fn test_text_nodes() {
        use azul_css::AzString;
        
        let text_a = NodeData::create_text(AzString::from("Hello"));
        let text_b = NodeData::create_text(AzString::from("World"));
        let text_a_copy = NodeData::create_text(AzString::from("Hello"));
        
        // Old: ["Hello", "World"], New: ["World", "Hello"]
        let old_data = vec![text_a.clone(), text_b.clone()];
        let new_data = vec![text_b.clone(), text_a_copy.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..2 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        // Should match by content hash
        assert_eq!(result.node_moves.len(), 2);
    }

    #[test]
    fn test_shuffle_three() {
        use azul_css::AzString;
        
        let mut a = NodeData::create_div();
        a.add_class(AzString::from("a"));
        let mut b = NodeData::create_div();
        b.add_class(AzString::from("b"));
        let mut c = NodeData::create_div();
        c.add_class(AzString::from("c"));
        
        // Old: [A, B, C], New: [B, C, A]
        let old_data = vec![a.clone(), b.clone(), c.clone()];
        let new_data = vec![b.clone(), c.clone(), a.clone()];
        
        let mut old_layout = FastHashMap::default();
        let mut new_layout = FastHashMap::default();
        for i in 0..3 {
            old_layout.insert(NodeId::new(i), LogicalRect::zero());
            new_layout.insert(NodeId::new(i), LogicalRect::zero());
        }
        
        let result = reconcile_dom(
            &old_data,
            &new_data,
            &old_layout,
            &new_layout,
            DomId { inner: 0 },
            Instant::now(),
        );
        
        assert_eq!(result.node_moves.len(), 3);
        
        // A: old[0] -> new[2]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(0) && m.new_node_id == NodeId::new(2)
        ));
        // B: old[1] -> new[0]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(1) && m.new_node_id == NodeId::new(0)
        ));
        // C: old[2] -> new[1]
        assert!(result.node_moves.iter().any(|m| 
            m.old_node_id == NodeId::new(2) && m.new_node_id == NodeId::new(1)
        ));
    }
}
