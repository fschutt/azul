//! solver3/layout_tree.rs
//!
//! Layout tree generation and anonymous box handling

use std::{
    collections::BTreeMap,
    hash::{Hash, Hasher},
    sync::Arc,
};

use azul_core::{
    dom::{FormattingContext, NodeId, NodeType},
    geom::{LogicalPosition, LogicalRect, LogicalSize},
    styled_dom::StyledDom,
    ui_solver::ResolvedOffsets,
};
use azul_css::{
    corety::LayoutDebugMessage,
    css::CssPropertyValue,
    format_rust_code::GetHash,
    props::{
        layout::{LayoutDisplay, LayoutFloat, LayoutOverflow, LayoutPosition},
        property::CssProperty,
    },
};
use taffy::{Cache as TaffyCache, Layout, LayoutInput, LayoutOutput};

use crate::{
    font::parsed::ParsedFont,
    solver3::{
        geometry::{BoxProps, IntrinsicSizes, PositionedRectangle},
        getters::{get_float, get_overflow_x, get_overflow_y, get_position},
        scrollbar::ScrollbarInfo,
        LayoutContext, Result,
    },
    text3::cache::{FontLoaderTrait, ParsedFontTrait, UnifiedLayout},
};

/// Represents the invalidation state of a layout node.
///
/// The states are ordered by severity, allowing for easy "upgrading" of the dirty state.
/// A node marked for `Layout` does not also need to be marked for `Paint`.
///
/// Because this enum derives `PartialOrd` and `Ord`, you can directly compare variants:
///
/// - `DirtyFlag::Layout > DirtyFlag::Paint` is `true`
/// - `DirtyFlag::Paint >= DirtyFlag::None` is `true`
/// - `DirtyFlag::Paint < DirtyFlag::Layout` is `true`
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Default)]
pub enum DirtyFlag {
    /// The node's layout is valid and no repaint is needed. This is the "clean" state.
    #[default]
    None,
    /// The node's geometry is valid, but its appearance (e.g., color) has changed.
    /// Requires a display list update only.
    Paint,
    /// The node's geometry (size or position) is invalid.
    /// Requires a full layout pass and a display list update.
    Layout,
}

/// A hash that represents the content and style of a node PLUS all of its descendants.
/// If two SubtreeHashes are equal, their entire subtrees are considered identical for layout
/// purposes.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Hash)]
pub struct SubtreeHash(pub u64);

/// A layout tree node representing the CSS box model
///
/// Note: An absolute position is a final paint-time value and shouldn't be
/// cached on the node itself, as it can change even if the node's
/// layout is clean (e.g., if a sibling changes size). We will calculate
/// it in a separate map.
#[derive(Debug, Clone)]
pub struct LayoutNode<T: ParsedFontTrait> {
    /// Reference back to the original DOM node (None for anonymous boxes)
    pub dom_node_id: Option<NodeId>,
    /// Whether this is an anonymous box generated by the layout engine
    pub is_anonymous: bool,
    /// Type of anonymous box (if applicable)
    pub anonymous_type: Option<AnonymousBoxType>,
    /// Children indices in the layout tree
    pub children: Vec<usize>,
    /// Parent index (None for root)
    pub parent: Option<usize>,
    /// Dirty flags to track what needs recalculation.
    pub dirty_flag: DirtyFlag,
    /// The resolved box model properties (margin, border, padding)
    /// in logical pixels.
    pub box_props: BoxProps,
    /// Cache for Taffy layout computations for this node.
    pub taffy_cache: TaffyCache, // NEW FIELD
    /// A hash of this node's data (style, text content, etc.) used for
    /// fast reconciliation.
    pub node_data_hash: u64,
    /// A hash of this node's data and all of its descendants. Used for
    /// fast reconciliation.
    pub subtree_hash: SubtreeHash,
    /// The formatting context this node establishes or participates in.
    pub formatting_context: FormattingContext,
    /// Cached intrinsic sizes (min-content, max-content, etc.)
    pub intrinsic_sizes: Option<IntrinsicSizes>,
    /// The size used during the last layout pass.
    pub used_size: Option<LogicalSize>,
    /// The position of this node *relative to its parent's content box*.
    pub relative_position: Option<LogicalPosition>,
    /// The baseline of this box, if applicable, measured from its content-box top edge.
    pub baseline: Option<f32>,
    /// Optional layouted text that this layout node carries
    pub inline_layout_result: Option<Arc<UnifiedLayout<T>>>,
    /// Escaped top margin (CSS 2.1 margin collapsing)
    /// If this BFC's first child's top margin "escaped" the BFC, this contains
    /// the collapsed margin that should be applied by the parent.
    pub escaped_top_margin: Option<f32>,
    /// Escaped bottom margin (CSS 2.1 margin collapsing)  
    /// If this BFC's last child's bottom margin "escaped" the BFC, this contains
    /// the collapsed margin that should be applied by the parent.
    pub escaped_bottom_margin: Option<f32>,
    /// Cached scrollbar information (calculated during layout)
    /// Used to determine if scrollbars appeared/disappeared requiring reflow
    pub scrollbar_info: Option<ScrollbarInfo>,
}

/// Types of anonymous boxes that can be generated
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum AnonymousBoxType {
    /// Anonymous block box wrapping inline content
    InlineWrapper,
    /// Anonymous box for a list item marker (bullet or number)
    ListItemMarker,
    /// Anonymous table wrapper
    TableWrapper,
    /// Anonymous table row group (tbody)
    TableRowGroup,
    /// Anonymous table row
    TableRow,
    /// Anonymous table cell
    TableCell,
}

/// The complete layout tree structure
#[derive(Debug, Clone)]
pub struct LayoutTree<T: ParsedFontTrait> {
    /// Arena-style storage for layout nodes
    pub nodes: Vec<LayoutNode<T>>,
    /// Root node index
    pub root: usize,
    /// Mapping from DOM node IDs to layout node indices
    pub dom_to_layout: BTreeMap<NodeId, Vec<usize>>,
}

impl<T: ParsedFontTrait> LayoutTree<T> {
    pub fn get(&self, index: usize) -> Option<&LayoutNode<T>> {
        self.nodes.get(index)
    }

    pub fn get_mut(&mut self, index: usize) -> Option<&mut LayoutNode<T>> {
        self.nodes.get_mut(index)
    }

    pub fn root_node(&self) -> &LayoutNode<T> {
        &self.nodes[self.root]
    }

    /// Marks a node and its ancestors as dirty with the given flag.
    ///
    /// The dirty state is "upgraded" if the new flag is more severe than the
    /// existing one (e.g., upgrading from `Paint` to `Layout`). Propagation stops
    /// if an ancestor is already marked with an equal or more severe flag.
    pub fn mark_dirty(&mut self, start_index: usize, flag: DirtyFlag) {
        // A "None" flag is a no-op for marking dirty.
        if flag == DirtyFlag::None {
            return;
        }

        let mut current_index = Some(start_index);
        while let Some(index) = current_index {
            if let Some(node) = self.get_mut(index) {
                // If the node's current flag is already as dirty or dirtier,
                // then all ancestors are also sufficiently marked, so we can stop.
                if node.dirty_flag >= flag {
                    break;
                }

                // Upgrade the flag to the new, more severe state.
                node.dirty_flag = flag;
                current_index = node.parent;
            } else {
                break;
            }
        }
    }

    /// Marks a node and its entire subtree of descendants with the given dirty flag.
    ///
    /// This is used for inherited CSS properties. Each node in the subtree
    /// will be upgraded to at least the new flag's severity.
    pub fn mark_subtree_dirty(&mut self, start_index: usize, flag: DirtyFlag) {
        // A "None" flag is a no-op.
        if flag == DirtyFlag::None {
            return;
        }

        // Using a stack for an iterative traversal to avoid deep recursion on large subtrees.
        let mut stack = vec![start_index];
        while let Some(index) = stack.pop() {
            if let Some(node) = self.get_mut(index) {
                // Only update if the new flag is an upgrade.
                if node.dirty_flag < flag {
                    node.dirty_flag = flag;
                }
                // Add all children to be processed.
                stack.extend_from_slice(&node.children);
            }
        }
    }

    /// Resets the dirty flags of all nodes in the tree to `None` after layout is complete.
    pub fn clear_all_dirty_flags(&mut self) {
        for node in &mut self.nodes {
            node.dirty_flag = DirtyFlag::None;
        }
    }
}

/// Generate layout tree from styled DOM with proper anonymous box generation
pub fn generate_layout_tree<T: ParsedFontTrait, Q: FontLoaderTrait<T>>(
    ctx: &mut LayoutContext<T, Q>,
) -> Result<LayoutTree<T>> {
    let mut builder = LayoutTreeBuilder::new();
    let root_id = ctx
        .styled_dom
        .root
        .into_crate_internal()
        .unwrap_or(NodeId::ZERO);
    let root_index = builder.process_node(ctx.styled_dom, root_id, None, &mut ctx.debug_messages)?;
    let layout_tree = builder.build(root_index);

    ctx.debug_log(&format!(
        "Generated layout tree with {} nodes (incl. anonymous)",
        layout_tree.nodes.len()
    ));

    Ok(layout_tree)
}

pub struct LayoutTreeBuilder<T: ParsedFontTrait> {
    nodes: Vec<LayoutNode<T>>,
    dom_to_layout: BTreeMap<NodeId, Vec<usize>>,
}

impl<T: ParsedFontTrait> LayoutTreeBuilder<T> {
    pub fn new() -> Self {
        Self {
            nodes: Vec::new(),
            dom_to_layout: BTreeMap::new(),
        }
    }

    pub fn get(&self, index: usize) -> Option<&LayoutNode<T>> {
        self.nodes.get(index)
    }

    pub fn get_mut(&mut self, index: usize) -> Option<&mut LayoutNode<T>> {
        self.nodes.get_mut(index)
    }

    /// Main entry point for recursively building the layout tree.
    /// This function dispatches to specialized handlers based on the node's
    /// `display` property to correctly generate anonymous boxes.
    pub fn process_node(
        &mut self,
        styled_dom: &StyledDom,
        dom_id: NodeId,
        parent_idx: Option<usize>,
        debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
    ) -> Result<usize> {
        let node_data = &styled_dom.node_data.as_container()[dom_id];
        eprintln!(
            "DEBUG process_node: dom_id={:?}, node_type={:?}, parent_idx={:?}",
            dom_id,
            node_data.get_node_type(),
            parent_idx
        );

        let node_idx = self.create_node_from_dom(styled_dom, dom_id, parent_idx, debug_messages)?;
        let display_type = get_display_type(styled_dom, dom_id);

        eprintln!(
            "DEBUG process_node: created layout_node at index={}, display_type={:?}",
            node_idx, display_type
        );

        // If this is a list-item, inject an anonymous marker box as its first child
        if display_type == LayoutDisplay::ListItem {
            self.create_anonymous_node(
                node_idx,
                AnonymousBoxType::ListItemMarker,
                FormattingContext::Inline, // The marker itself contains inline text
            );
        }

        match display_type {
            LayoutDisplay::Block | LayoutDisplay::InlineBlock | LayoutDisplay::FlowRoot | LayoutDisplay::ListItem => {
                self.process_block_children(styled_dom, dom_id, node_idx, debug_messages)?
            }
            LayoutDisplay::Table => self.process_table_children(styled_dom, dom_id, node_idx, debug_messages)?,
            LayoutDisplay::TableRowGroup => {
                self.process_table_row_group_children(styled_dom, dom_id, node_idx, debug_messages)?
            }
            LayoutDisplay::TableRow => {
                self.process_table_row_children(styled_dom, dom_id, node_idx, debug_messages)?
            }
            // Inline, TableCell, etc., have their children processed as part of their
            // formatting context layout and don't require anonymous box generation at this stage.
            _ => {
                let children: Vec<NodeId> = dom_id
                    .az_children(&styled_dom.node_hierarchy.as_container())
                    .collect();

                for child_dom_id in children {
                    self.process_node(styled_dom, child_dom_id, Some(node_idx), debug_messages)?;
                }
            }
        }
        Ok(node_idx)
    }

    /// Handles children of a block-level element, creating anonymous block
    /// wrappers for consecutive runs of inline-level children if necessary.
    fn process_block_children(
        &mut self,
        styled_dom: &StyledDom,
        parent_dom_id: NodeId,
        parent_idx: usize,
        debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
    ) -> Result<()> {
        let children: Vec<NodeId> = parent_dom_id
            .az_children(&styled_dom.node_hierarchy.as_container())
            .collect();

        let has_block_child = children.iter().any(|&id| is_block_level(styled_dom, id));

        if !has_block_child {
            // All children are inline, no anonymous boxes needed.
            for child_id in children {
                self.process_node(styled_dom, child_id, Some(parent_idx), debug_messages)?;
            }
            return Ok(());
        }

        // Mixed block and inline content requires anonymous wrappers.
        let mut inline_run = Vec::new();

        for child_id in children {
            if is_block_level(styled_dom, child_id) {
                // End the current inline run
                if !inline_run.is_empty() {
                    let anon_idx = self.create_anonymous_node(
                        parent_idx,
                        AnonymousBoxType::InlineWrapper,
                        FormattingContext::Block {
                            establishes_new_context: true, // Anonymous wrappers are BFC roots
                        },
                    );
                    for inline_child_id in inline_run.drain(..) {
                        self.process_node(styled_dom, inline_child_id, Some(anon_idx), debug_messages)?;
                    }
                }
                // Process the block-level child directly
                self.process_node(styled_dom, child_id, Some(parent_idx), debug_messages)?;
            } else {
                inline_run.push(child_id);
            }
        }
        // Process any remaining inline children at the end
        if !inline_run.is_empty() {
            let anon_idx = self.create_anonymous_node(
                parent_idx,
                AnonymousBoxType::InlineWrapper,
                FormattingContext::Block {
                    establishes_new_context: true, // Anonymous wrappers are BFC roots
                },
            );
            for inline_child_id in inline_run {
                self.process_node(styled_dom, inline_child_id, Some(anon_idx), debug_messages)?;
            }
        }

        Ok(())
    }

    /// CSS 2.2 Section 17.2.1 - Anonymous box generation for tables:
    /// "Generate missing child wrappers. If a child C of a table-row parent P is not a 
    /// table-cell, then generate an anonymous table-cell box around C and all consecutive 
    /// siblings of C that are not table-cells."
    ///
    /// Handles children of a `display: table`, inserting anonymous `table-row`
    /// wrappers for any direct `table-cell` children.
    ///
    /// Per CSS 2.2 Section 17.2.1, Stage 2 & 3:
    /// - Stage 2: Wrap consecutive table-cell children in anonymous table-rows
    /// - Stage 1 (implemented here): Skip whitespace-only text nodes
    fn process_table_children(
        &mut self,
        styled_dom: &StyledDom,
        parent_dom_id: NodeId,
        parent_idx: usize,
        debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
    ) -> Result<()> {
        let parent_display = get_display_type(styled_dom, parent_dom_id);
        let mut row_children = Vec::new();
        
        for child_id in parent_dom_id.az_children(&styled_dom.node_hierarchy.as_container()) {
            // CSS 2.2 Section 17.2.1, Stage 1: Skip whitespace-only text nodes
            // "Remove all irrelevant boxes. These are boxes that do not contain table-related 
            // boxes and do not themselves have 'display' set to a table-related value."
            if should_skip_for_table_structure(styled_dom, child_id, parent_display) {
                eprintln!("  DEBUG: Skipping whitespace-only text node in table structure");
                continue;
            }
            
            let child_display = get_display_type(styled_dom, child_id);
            
            // CSS 2.2 Section 17.2.1, Stage 2:
            // "Generate missing child wrappers"
            if child_display == LayoutDisplay::TableCell {
                // Accumulate consecutive table-cell children
                row_children.push(child_id);
            } else {
                // CSS 2.2 Section 17.2.1, Stage 2:
                // If we have accumulated cells, wrap them in an anonymous table-row
                if !row_children.is_empty() {
                    let anon_row_idx = self.create_anonymous_node(
                        parent_idx,
                        AnonymousBoxType::TableRow,
                        FormattingContext::TableRow,
                    );
                    eprintln!("  DEBUG: Created anonymous table-row at index {} for {} cells", 
                             anon_row_idx, row_children.len());
                    
                    for cell_id in row_children.drain(..) {
                        self.process_node(styled_dom, cell_id, Some(anon_row_idx), debug_messages)?;
                    }
                }
                
                // Process non-cell child (could be row, row-group, caption, etc.)
                self.process_node(styled_dom, child_id, Some(parent_idx), debug_messages)?;
            }
        }
        
        // CSS 2.2 Section 17.2.1, Stage 2:
        // Flush any remaining accumulated cells
        if !row_children.is_empty() {
            let anon_row_idx = self.create_anonymous_node(
                parent_idx,
                AnonymousBoxType::TableRow,
                FormattingContext::TableRow,
            );
            eprintln!("  DEBUG: Created anonymous table-row at index {} for {} trailing cells", 
                     anon_row_idx, row_children.len());
            
            for cell_id in row_children {
                self.process_node(styled_dom, cell_id, Some(anon_row_idx), debug_messages)?;
            }
        }
        
        Ok(())
    }

    /// CSS 2.2 Section 17.2.1 - Anonymous box generation:
    /// Handles children of a `display: table-row-group`, `table-header-group`, 
    /// or `table-footer-group`, inserting anonymous `table-row` wrappers as needed.
    ///
    /// The logic is identical to process_table_children per CSS 2.2 Section 17.2.1:
    /// "If a child C of a table-row-group parent P is not a table-row, then generate 
    /// an anonymous table-row box around C and all consecutive siblings of C that are 
    /// not table-rows."
    fn process_table_row_group_children(
        &mut self,
        styled_dom: &StyledDom,
        parent_dom_id: NodeId,
        parent_idx: usize,
        debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
    ) -> Result<()> {
        // CSS 2.2 Section 17.2.1: Row groups need the same anonymous box generation
        // as tables (wrapping consecutive non-row children in anonymous rows)
        self.process_table_children(styled_dom, parent_dom_id, parent_idx, debug_messages)
    }

    /// CSS 2.2 Section 17.2.1 - Anonymous box generation, Stage 2:
    /// "Generate missing child wrappers. If a child C of a table-row parent P is not a 
    /// table-cell, then generate an anonymous table-cell box around C and all consecutive 
    /// siblings of C that are not table-cells."
    ///
    /// Handles children of a `display: table-row`, inserting anonymous `table-cell` wrappers
    /// for any non-cell children.
    fn process_table_row_children(
        &mut self,
        styled_dom: &StyledDom,
        parent_dom_id: NodeId,
        parent_idx: usize,
        debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
    ) -> Result<()> {
        let parent_display = get_display_type(styled_dom, parent_dom_id);
        
        for child_id in parent_dom_id.az_children(&styled_dom.node_hierarchy.as_container()) {
            // CSS 2.2 Section 17.2.1, Stage 1: Skip whitespace-only text nodes
            if should_skip_for_table_structure(styled_dom, child_id, parent_display) {
                eprintln!("  DEBUG: Skipping whitespace-only text node in table-row");
                continue;
            }
            
            let child_display = get_display_type(styled_dom, child_id);
            
            // CSS 2.2 Section 17.2.1, Stage 2:
            // "If a child C of a table-row parent P is not a table-cell, then generate 
            // an anonymous table-cell box around C"
            if child_display == LayoutDisplay::TableCell {
                // Normal table cell - process directly
                self.process_node(styled_dom, child_id, Some(parent_idx), debug_messages)?;
            } else {
                // CSS 2.2 Section 17.2.1, Stage 2:
                // Non-cell child must be wrapped in an anonymous table-cell
                let anon_cell_idx = self.create_anonymous_node(
                    parent_idx,
                    AnonymousBoxType::TableCell,
                    FormattingContext::Block {
                        establishes_new_context: true,
                    },
                );
                eprintln!("  DEBUG: Created anonymous table-cell at index {} for non-cell child", 
                         anon_cell_idx);
                
                self.process_node(styled_dom, child_id, Some(anon_cell_idx), debug_messages)?;
            }
        }
        
        Ok(())
    }    /// CSS 2.2 Section 17.2.1 - Anonymous box generation:
    /// "In this process, inline-level boxes are wrapped in anonymous boxes as needed 
    /// to satisfy the constraints of the table model."
    ///
    /// Helper to create an anonymous node in the tree.
    /// Anonymous boxes don't have a corresponding DOM node and are used to enforce
    /// the CSS box model structure (e.g., wrapping inline content in blocks,
    /// or creating missing table structural elements).
    fn create_anonymous_node(
        &mut self,
        parent: usize,
        anon_type: AnonymousBoxType,
        fc: FormattingContext,
    ) -> usize {
        let index = self.nodes.len();
        
        eprintln!("  DEBUG: Creating anonymous box type {:?} at index {} with parent {}", 
                 anon_type, index, parent);
        
        // CSS 2.2 Section 17.2.1: Anonymous boxes inherit properties from their 
        // enclosing non-anonymous box
        self.nodes.push(LayoutNode {
            dom_node_id: None,  // Anonymous boxes have no DOM correspondence
            parent: Some(parent),
            formatting_context: fc,
            box_props: BoxProps::default(),  // Anonymous boxes inherit from parent
            taffy_cache: TaffyCache::new(),
            is_anonymous: true,
            anonymous_type: Some(anon_type),
            children: Vec::new(),
            dirty_flag: DirtyFlag::Layout,
            node_data_hash: 0, // Anonymous boxes don't have style/data
            subtree_hash: SubtreeHash(0),
            intrinsic_sizes: None,
            used_size: None,
            relative_position: None,
            baseline: None,
            inline_layout_result: None,
            escaped_top_margin: None,
            escaped_bottom_margin: None,
            scrollbar_info: None,
        });
        
        self.nodes[parent].children.push(index);
        index
    }

    pub fn create_node_from_dom(
        &mut self,
        styled_dom: &StyledDom,
        dom_id: NodeId,
        parent: Option<usize>,
        debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
    ) -> Result<usize> {
        let index = self.nodes.len();
        self.nodes.push(LayoutNode {
            dom_node_id: Some(dom_id),
            parent,
            formatting_context: determine_formatting_context(styled_dom, dom_id),
            box_props: resolve_box_props(styled_dom, dom_id, debug_messages),
            taffy_cache: TaffyCache::new(),
            is_anonymous: false,
            anonymous_type: None,
            children: Vec::new(),
            dirty_flag: DirtyFlag::Layout,
            node_data_hash: hash_node_data(styled_dom, dom_id),
            subtree_hash: SubtreeHash(0),
            intrinsic_sizes: None,
            used_size: None,
            relative_position: None,
            baseline: None,
            inline_layout_result: None,
            escaped_top_margin: None,
            escaped_bottom_margin: None,
            scrollbar_info: None,
        });
        if let Some(p) = parent {
            self.nodes[p].children.push(index);
        }
        self.dom_to_layout.entry(dom_id).or_default().push(index);
        Ok(index)
    }

    pub fn clone_node_from_old(
        &mut self,
        old_node: &LayoutNode<T>,
        parent: Option<usize>,
    ) -> usize {
        let index = self.nodes.len();
        let mut new_node = old_node.clone();
        new_node.parent = parent;
        new_node.children = Vec::new();
        new_node.dirty_flag = DirtyFlag::None;
        self.nodes.push(new_node);
        if let Some(p) = parent {
            self.nodes[p].children.push(index);
        }
        if let Some(dom_id) = old_node.dom_node_id {
            self.dom_to_layout.entry(dom_id).or_default().push(index);
        }
        index
    }

    pub fn build(self, root_idx: usize) -> LayoutTree<T> {
        LayoutTree {
            nodes: self.nodes,
            root: root_idx,
            dom_to_layout: self.dom_to_layout,
        }
    }
}

fn is_block_level(styled_dom: &StyledDom, node_id: NodeId) -> bool {
    matches!(
        get_display_type(styled_dom, node_id),
        LayoutDisplay::Block
            | LayoutDisplay::FlowRoot
            | LayoutDisplay::Table
            | LayoutDisplay::TableRow
            | LayoutDisplay::TableRowGroup
            | LayoutDisplay::ListItem
    )
}

/// Checks if a node is inline-level (including text nodes).
/// According to CSS spec, inline-level content includes:
/// - Elements with display: inline, inline-block, inline-table, inline-flex, inline-grid
/// - Text nodes
/// - Generated content
fn is_inline_level(styled_dom: &StyledDom, node_id: NodeId) -> bool {
    use azul_core::dom::NodeType;

    // Text nodes are always inline-level
    let node_data = &styled_dom.node_data.as_container()[node_id];
    if matches!(node_data.get_node_type(), NodeType::Text(_)) {
        return true;
    }

    // Check the display property
    matches!(
        get_display_type(styled_dom, node_id),
        LayoutDisplay::Inline
            | LayoutDisplay::InlineBlock
            | LayoutDisplay::InlineTable
            | LayoutDisplay::InlineFlex
            | LayoutDisplay::InlineGrid
    )
}

/// Checks if a block container has only inline-level children.
/// According to CSS 2.2 Section 9.4.2: "An inline formatting context is established
/// by a block container box that contains no block-level boxes."
fn has_only_inline_children(styled_dom: &StyledDom, node_id: NodeId) -> bool {
    let hierarchy = styled_dom.node_hierarchy.as_container();
    let node_hier = match hierarchy.get(node_id) {
        Some(n) => n,
        None => {
            eprintln!("[has_only_inline_children] NodeId({:?}) not found in hierarchy", node_id);
            return false;
        }
    };

    // Get the first child
    let mut current_child = node_hier.first_child_id(node_id);

    // If there are no children, it's not an IFC (it's empty)
    if current_child.is_none() {
        eprintln!("[has_only_inline_children] NodeId({:?}) has no children", node_id);
        return false;
    }

    eprintln!("[has_only_inline_children] Checking NodeId({:?})", node_id);

    // Check all children
    while let Some(child_id) = current_child {
        let is_inline = is_inline_level(styled_dom, child_id);
        eprintln!("  Child NodeId({:?}): is_inline={}", child_id, is_inline);
        
        if !is_inline {
            // Found a block-level child
            eprintln!("[has_only_inline_children] NodeId({:?}) has block-level child NodeId({:?}) -> BLOCK FC", 
                node_id, child_id);
            return false;
        }

        // Move to next sibling
        if let Some(child_hier) = hierarchy.get(child_id) {
            current_child = child_hier.next_sibling_id();
        } else {
            break;
        }
    }

    // All children are inline-level
    eprintln!("[has_only_inline_children] NodeId({:?}) has only inline children -> INLINE FC", node_id);
    true
}

fn hash_node_data(dom: &StyledDom, node_id: NodeId) -> u64 {
    let mut hasher = std::hash::DefaultHasher::new();
    // Use node_state flags and node_type as a reasonable surrogate for now.
    if let Some(styled_node) = dom.node_data.as_container().get(node_id) {
        styled_node.get_hash().hash(&mut hasher);
    }
    hasher.finish()
}

fn resolve_box_props(styled_dom: &StyledDom, dom_id: NodeId, debug_messages: &mut Option<Vec<LayoutDebugMessage>>) -> BoxProps {
    use crate::solver3::getters::*;
    use azul_css::props::basic::PixelValue;
    
    let node_data = &styled_dom.node_data.as_container()[dom_id];
    
    // Get styled node state
    let node_state = styled_dom
        .styled_nodes
        .as_container()
        .get(dom_id)
        .map(|n| &n.state)
        .cloned()
        .unwrap_or_default();
    
    // Helper to extract pixel value from MultiValue<PixelValue>
    let to_pixels = |mv: crate::solver3::getters::MultiValue<PixelValue>| -> f32 {
        match mv {
            crate::solver3::getters::MultiValue::Exact(pv) => {
                pv.to_pixels_no_percent().unwrap_or(0.0)
            }
            _ => 0.0,
        }
    };
    
    // Read margin, padding, border from styled_dom
    let margin_top_mv = get_css_margin_top(styled_dom, dom_id, &node_state);
    let margin_right_mv = get_css_margin_right(styled_dom, dom_id, &node_state);
    let margin_bottom_mv = get_css_margin_bottom(styled_dom, dom_id, &node_state);
    let margin_left_mv = get_css_margin_left(styled_dom, dom_id, &node_state);
    
    let margin = crate::solver3::geometry::EdgeSizes {
        top: to_pixels(margin_top_mv),
        right: to_pixels(margin_right_mv),
        bottom: to_pixels(margin_bottom_mv),
        left: to_pixels(margin_left_mv),
    };
    
    // Debug for Body nodes
    if matches!(node_data.node_type, azul_core::dom::NodeType::Body) {
        if let Some(msgs) = debug_messages.as_mut() {
            msgs.push(LayoutDebugMessage::box_props(format!(
                "Body margin resolved: top={:.2}, right={:.2}, bottom={:.2}, left={:.2}",
                margin.top, margin.right, margin.bottom, margin.left
            )));
        }
    }
    
    let padding = crate::solver3::geometry::EdgeSizes {
        top: to_pixels(get_css_padding_top(styled_dom, dom_id, &node_state)),
        right: to_pixels(get_css_padding_right(styled_dom, dom_id, &node_state)),
        bottom: to_pixels(get_css_padding_bottom(styled_dom, dom_id, &node_state)),
        left: to_pixels(get_css_padding_left(styled_dom, dom_id, &node_state)),
    };
    
    let border = crate::solver3::geometry::EdgeSizes {
        top: to_pixels(get_css_border_top_width(styled_dom, dom_id, &node_state)),
        right: to_pixels(get_css_border_right_width(styled_dom, dom_id, &node_state)),
        bottom: to_pixels(get_css_border_bottom_width(styled_dom, dom_id, &node_state)),
        left: to_pixels(get_css_border_left_width(styled_dom, dom_id, &node_state)),
    };
    
    BoxProps {
        margin,
        padding,
        border,
    }
}

/// CSS 2.2 Section 17.2.1 - Anonymous box generation, Stage 1:
/// "Remove all irrelevant boxes. These are boxes that do not contain table-related boxes
/// and do not themselves have 'display' set to a table-related value. In this context,
/// 'irrelevant boxes' means anonymous inline boxes that contain only white space."
///
/// Checks if a DOM node is whitespace-only text (for table anonymous box generation).
/// Returns true if the node is a text node containing only whitespace characters.
fn is_whitespace_only_text(styled_dom: &StyledDom, node_id: NodeId) -> bool {
    use azul_core::dom::NodeType;
    
    let binding = styled_dom.node_data.as_container();
    let node_data = binding.get(node_id);
    if let Some(data) = node_data {
        if let NodeType::Text(text) = data.get_node_type() {
            // Check if the text contains only whitespace characters
            // Per CSS 2.2 Section 17.2.1: whitespace-only anonymous boxes are irrelevant
            return text.chars().all(|c| c.is_whitespace());
        }
    }
    
    false
}

/// CSS 2.2 Section 17.2.1 - Anonymous box generation, Stage 1:
/// Determines if a node should be skipped in table structure generation.
/// Whitespace-only text nodes are "irrelevant" and should not generate boxes
/// when they appear between table-related elements.
///
/// Returns true if the node should be skipped (i.e., it's whitespace-only text
/// and the parent is a table structural element).
fn should_skip_for_table_structure(
    styled_dom: &StyledDom,
    node_id: NodeId,
    parent_display: LayoutDisplay,
) -> bool {
    // CSS 2.2 Section 17.2.1: Only skip whitespace text nodes when parent is 
    // a table structural element (table, row group, row)
    matches!(
        parent_display,
        LayoutDisplay::Table
            | LayoutDisplay::TableRowGroup
            | LayoutDisplay::TableHeaderGroup
            | LayoutDisplay::TableFooterGroup
            | LayoutDisplay::TableRow
    ) && is_whitespace_only_text(styled_dom, node_id)
}

/// CSS 2.2 Section 17.2.1 - Anonymous box generation, Stage 3:
/// "Generate missing parents. For each table-cell box C in a sequence of consecutive 
/// table-cell boxes (that are not part of a table-row), an anonymous table-row box 
/// is generated around C and its consecutive table-cell siblings.
/// 
/// For each proper table child C in a sequence of consecutive proper table children 
/// that are misparented (i.e., their parent is not a table element), an anonymous 
/// table box is generated around C and its consecutive siblings."
///
/// This function checks if a node needs a parent wrapper and returns the appropriate
/// anonymous box type, or None if no wrapper is needed.
fn needs_table_parent_wrapper(
    styled_dom: &StyledDom,
    node_id: NodeId,
    parent_display: LayoutDisplay,
) -> Option<AnonymousBoxType> {
    let child_display = get_display_type(styled_dom, node_id);
    
    eprintln!("  [needs_table_parent_wrapper] child={:?}, parent={:?}", 
             child_display, parent_display);
    
    // CSS 2.2 Section 17.2.1, Stage 3:
    // If we have a table-cell but parent is not a table-row, need anonymous row
    if child_display == LayoutDisplay::TableCell {
        match parent_display {
            LayoutDisplay::TableRow 
            | LayoutDisplay::TableRowGroup 
            | LayoutDisplay::TableHeaderGroup 
            | LayoutDisplay::TableFooterGroup => {
                // Parent can contain cells directly or via rows - no wrapper needed
                None
            }
            _ => {
                eprintln!("  [needs_table_parent_wrapper] table-cell needs anonymous row wrapper");
                Some(AnonymousBoxType::TableRow)
            }
        }
    }
    // If we have a table-row but parent is not a table/row-group, need anonymous table
    else if matches!(child_display, LayoutDisplay::TableRow) {
        match parent_display {
            LayoutDisplay::Table 
            | LayoutDisplay::TableRowGroup 
            | LayoutDisplay::TableHeaderGroup 
            | LayoutDisplay::TableFooterGroup => {
                None // Parent is correct
            }
            _ => {
                eprintln!("  [needs_table_parent_wrapper] table-row needs anonymous table wrapper");
                Some(AnonymousBoxType::TableWrapper)
            }
        }
    }
    // If we have a row-group but parent is not a table, need anonymous table
    else if matches!(
        child_display,
        LayoutDisplay::TableRowGroup 
        | LayoutDisplay::TableHeaderGroup 
        | LayoutDisplay::TableFooterGroup
    ) {
        match parent_display {
            LayoutDisplay::Table => None,
            _ => {
                eprintln!("  [needs_table_parent_wrapper] row-group needs anonymous table wrapper");
                Some(AnonymousBoxType::TableWrapper)
            }
        }
    } else {
        None
    }
}

// Determines the display type of a node based on its tag and CSS properties.
pub fn get_display_type(styled_dom: &StyledDom, node_id: NodeId) -> LayoutDisplay {
    if let Some(_styled_node) = styled_dom.styled_nodes.as_container().get(node_id) {
        let node_data = &styled_dom.node_data.as_container()[node_id];
        let node_state = &styled_dom.styled_nodes.as_container()[node_id].state;
        
        // 1. Check author CSS first
        if let Some(d) = styled_dom
            .css_property_cache
            .ptr
            .get_display(node_data, &node_id, node_state)
            .and_then(|v| v.get_property().copied())
        {
            return d;
        }
        
        // 2. Check User Agent CSS (always returns a value for display)
        let node_type = &styled_dom.node_data.as_container()[node_id].node_type;
        if let Some(ua_prop) = azul_core::ua_css::get_ua_property(node_type, azul_css::props::property::CssPropertyType::Display) {
            if let azul_css::props::property::CssProperty::Display(azul_css::css::CssPropertyValue::Exact(d)) = ua_prop {
                return *d;
            }
        }
    }

    // 3. Final fallback (should never be reached since UA CSS always provides display)
    // Inline is the safest default per CSS spec
    LayoutDisplay::Inline
}

/// **Corrected:** Checks for all conditions that create a new Block Formatting Context.
/// A BFC contains floats and prevents margin collapse.
fn establishes_new_block_formatting_context(styled_dom: &StyledDom, node_id: NodeId) -> bool {
    let display = get_display_type(styled_dom, node_id);
    if matches!(
        display,
        LayoutDisplay::InlineBlock | LayoutDisplay::TableCell | LayoutDisplay::FlowRoot
    ) {
        return true;
    }

    if let Some(styled_node) = styled_dom.styled_nodes.as_container().get(node_id) {
        // `overflow` other than `visible`

        let overflow_x = get_overflow_x(styled_dom, node_id, &styled_node.state);
        if !overflow_x.is_visible_or_clip() {
            return true;
        }

        let overflow_y = get_overflow_y(styled_dom, node_id, &styled_node.state);
        if !overflow_y.is_visible_or_clip() {
            return true;
        }

        // `position: absolute` or `position: fixed`
        let position = get_position(styled_dom, node_id, &styled_node.state);

        if position.is_absolute_or_fixed() {
            return true;
        }

        // `float` is not `none`
        let float = get_float(styled_dom, node_id, &styled_node.state);
        if !float.is_none() {
            return true;
        }
    }

    // The root element (<html>) also establishes a BFC.
    if styled_dom.root.into_crate_internal() == Some(node_id) {
        return true;
    }

    false
}

/// The logic now correctly identifies all BFC roots.
fn determine_formatting_context(styled_dom: &StyledDom, node_id: NodeId) -> FormattingContext {
    // Special case: Text nodes should be treated as inline content.
    // They participate in their parent's inline formatting context.
    use azul_core::dom::NodeType;
    let node_data = &styled_dom.node_data.as_container()[node_id];
    
    eprintln!("[determine_formatting_context] NodeId({:?}), node_type={:?}", node_id, node_data.get_node_type());
    
    if matches!(node_data.get_node_type(), NodeType::Text(_)) {
        // Text nodes are inline-level content within their parent's IFC
        eprintln!("  -> TEXT NODE, returning Inline FC");
        return FormattingContext::Inline;
    }

    let display_type = get_display_type(styled_dom, node_id);
    eprintln!("  display_type={:?}", display_type);

    match display_type {
        LayoutDisplay::Inline => FormattingContext::Inline,

        // CSS 2.2 Section 9.4.2: "An inline formatting context is established by a
        // block container box that contains no block-level boxes."
        // Check if this block container has only inline-level children.
        LayoutDisplay::Block | LayoutDisplay::FlowRoot | LayoutDisplay::ListItem => {
            if has_only_inline_children(styled_dom, node_id) {
                // This block container should establish an IFC for its inline children
                eprintln!("  -> BLOCK/ListItem with only inline children, returning Inline FC");
                FormattingContext::Inline
            } else {
                // Normal BFC
                eprintln!("  -> BLOCK/ListItem with block-level children, returning Block FC");
                FormattingContext::Block {
                    establishes_new_context: establishes_new_block_formatting_context(
                        styled_dom, node_id,
                    ),
                }
            }
        }
        LayoutDisplay::InlineBlock => FormattingContext::InlineBlock,
        LayoutDisplay::Table | LayoutDisplay::InlineTable => FormattingContext::Table,
        LayoutDisplay::TableRowGroup
        | LayoutDisplay::TableHeaderGroup
        | LayoutDisplay::TableFooterGroup => FormattingContext::TableRowGroup,
        LayoutDisplay::TableRow => FormattingContext::TableRow,
        LayoutDisplay::TableCell => FormattingContext::TableCell,
        LayoutDisplay::None => FormattingContext::None,
        LayoutDisplay::Flex | LayoutDisplay::InlineFlex => FormattingContext::Flex,
        LayoutDisplay::TableColumnGroup => FormattingContext::TableColumnGroup,
        LayoutDisplay::TableCaption => FormattingContext::TableCaption,
        LayoutDisplay::Grid | LayoutDisplay::InlineGrid => FormattingContext::Grid,
        
        // These less common display types default to block behavior
        LayoutDisplay::TableColumn
        | LayoutDisplay::RunIn
        | LayoutDisplay::Marker => FormattingContext::Block {
            establishes_new_context: true,
        },
    }
}
