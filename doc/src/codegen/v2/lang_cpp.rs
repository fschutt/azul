//! C++ header generator
//!
//! Generates C++ header files from the IR, including:
//! - Class definitions with constructors/destructors
//! - Proper C++ types and RAII patterns
//! - Method wrappers around C functions

use anyhow::Result;

use super::config::*;
use super::generator::{CodeBuilder, LanguageGenerator};
use super::ir::*;

// ============================================================================
// C++ Generator
// ============================================================================

pub struct CppGenerator {
    standard: CppStandard,
}

impl CppGenerator {
    pub fn new(standard: CppStandard) -> Self {
        Self { standard }
    }
}

impl LanguageGenerator for CppGenerator {
    fn generate(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // File header
        builder.line("/*");
        builder.line(" * Auto-generated by azul-doc codegen v2");
        builder.line(" * DO NOT EDIT MANUALLY");
        builder.line(&format!(" * C++ Standard: {:?}", self.standard));
        builder.line(" */");
        builder.blank();

        // Include guards (using pragma once for modern C++)
        builder.line("#pragma once");
        builder.blank();

        // Standard includes
        for include in &config.imports {
            builder.line(include);
        }
        builder.line("#include <utility>  // std::move");
        if !config.imports.is_empty() {
            builder.blank();
        }

        // Include the C header for the underlying functions
        builder.line("// Include C API");
        builder.line("#include \"azul.h\"");
        builder.blank();

        // Namespace
        builder.line("namespace azul {");
        builder.blank();

        // Forward declarations
        builder.line("// Forward declarations");
        self.generate_forward_declarations(&mut builder, ir, config);
        builder.blank();

        // Type definitions
        let types = self.generate_types(ir, config)?;
        builder.raw(&types);

        // Close namespace
        builder.line("} // namespace azul");

        Ok(builder.finish())
    }

    fn generate_types(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // Classes for structs
        builder.line("// Class definitions");
        for struct_def in &ir.structs {
            if !config.should_include_type(&struct_def.name) {
                continue;
            }
            self.generate_class(&mut builder, struct_def, ir, config);
        }

        // Enum classes
        builder.line("// Enum definitions");
        for enum_def in &ir.enums {
            if !config.should_include_type(&enum_def.name) {
                continue;
            }
            self.generate_enum_class(&mut builder, enum_def, config);
        }

        Ok(builder.finish())
    }

    fn generate_functions(&self, _ir: &CodegenIR, _config: &CodegenConfig) -> Result<String> {
        // C++ wraps functions as class methods
        Ok(String::new())
    }

    fn generate_trait_impls(&self, _ir: &CodegenIR, _config: &CodegenConfig) -> Result<String> {
        // C++ implements these as class methods
        Ok(String::new())
    }
}

// ============================================================================
// Helper functions
// ============================================================================

impl CppGenerator {
    fn generate_forward_declarations(
        &self,
        builder: &mut CodeBuilder,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        for struct_def in &ir.structs {
            if !config.should_include_type(&struct_def.name) {
                continue;
            }
            builder.line(&format!("class {};", struct_def.name));
        }
    }

    fn generate_class(
        &self,
        builder: &mut CodeBuilder,
        struct_def: &StructDef,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        // TODO: Generate C++ class wrapping the C struct
        // TODO: Generate constructor, destructor, copy/move semantics
        // TODO: Generate method wrappers
        
        let class_name = &struct_def.name;
        let c_name = config.apply_prefix(class_name);

        // Doc comment
        if config.generate_docs && !struct_def.doc.is_empty() {
            builder.line("/**");
            for line in &struct_def.doc {
                builder.line(&format!(" * {}", line));
            }
            builder.line(" */");
        }

        builder.line(&format!("class {} {{", class_name));
        builder.line("private:");
        builder.indent();
        builder.line(&format!("{} inner;", c_name));
        builder.dedent();
        builder.blank();

        builder.line("public:");
        builder.indent();

        // Default constructor (deleted if no Default trait)
        if struct_def.traits.is_default {
            builder.line(&format!(
                "{}() : inner({}_default()) {{}}",
                class_name, c_name
            ));
        } else {
            builder.line(&format!("{}() = delete;", class_name));
        }
        builder.blank();

        // Constructor from C struct
        builder.line(&format!(
            "explicit {}({} inner) : inner(inner) {{}}",
            class_name, c_name
        ));
        builder.blank();

        // Destructor
        if struct_def.traits.needs_delete() {
            builder.line(&format!("~{}() {{ {}_delete(&inner); }}", class_name, c_name));
        } else {
            builder.line(&format!("~{}() = default;", class_name));
        }
        builder.blank();

        // Copy constructor and assignment
        if struct_def.traits.is_clone && !struct_def.traits.is_copy {
            builder.line(&format!(
                "{}(const {}& other) : inner({}_deepCopy(&other.inner)) {{}}",
                class_name, class_name, c_name
            ));
            builder.line(&format!(
                "{}& operator=(const {}& other) {{",
                class_name, class_name
            ));
            builder.indent();
            builder.line("if (this != &other) {");
            builder.indent();
            if struct_def.traits.needs_delete() {
                builder.line(&format!("{}_delete(&inner);", c_name));
            }
            builder.line(&format!("inner = {}_deepCopy(&other.inner);", c_name));
            builder.dedent();
            builder.line("}");
            builder.line("return *this;");
            builder.dedent();
            builder.line("}");
        } else if struct_def.traits.is_copy {
            builder.line(&format!("{}(const {}& other) = default;", class_name, class_name));
            builder.line(&format!("{}& operator=(const {}& other) = default;", class_name, class_name));
        } else {
            builder.line(&format!("{}(const {}& other) = delete;", class_name, class_name));
            builder.line(&format!("{}& operator=(const {}& other) = delete;", class_name, class_name));
        }
        builder.blank();

        // Move constructor and assignment
        builder.line(&format!(
            "{}({}&& other) noexcept : inner(other.inner) {{",
            class_name, class_name
        ));
        builder.indent();
        builder.line("// Prevent double-free by zeroing moved-from object");
        builder.line(&format!("other.inner = {{}};  // Zero-init"));
        builder.dedent();
        builder.line("}");
        
        builder.line(&format!(
            "{}& operator=({}&& other) noexcept {{",
            class_name, class_name
        ));
        builder.indent();
        builder.line("if (this != &other) {");
        builder.indent();
        if struct_def.traits.needs_delete() {
            builder.line(&format!("{}_delete(&inner);", c_name));
        }
        builder.line("inner = other.inner;");
        builder.line("other.inner = {};");
        builder.dedent();
        builder.line("}");
        builder.line("return *this;");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // Method wrappers
        // TODO: Find functions for this class and generate method wrappers
        self.generate_method_wrappers(builder, struct_def, ir, config);

        // Comparison operators
        if struct_def.traits.is_partial_eq {
            builder.line(&format!(
                "bool operator==(const {}& other) const {{ return {}_partialEq(&inner, &other.inner); }}",
                class_name, c_name
            ));
            builder.line(&format!(
                "bool operator!=(const {}& other) const {{ return !(*this == other); }}",
                class_name
            ));
            builder.blank();
        }

        // Access to underlying C struct
        builder.line(&format!("const {}& c_inner() const {{ return inner; }}", c_name));
        builder.line(&format!("{}& c_inner() {{ return inner; }}", c_name));

        builder.dedent();
        builder.line("};");
        builder.blank();
    }

    fn generate_method_wrappers(
        &self,
        builder: &mut CodeBuilder,
        struct_def: &StructDef,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        // TODO: Find all functions for this class and generate C++ method wrappers
        // For now, just add a comment
        
        builder.line("// Methods");
        
        for func in ir.functions_for_class(&struct_def.name) {
            // Skip trait functions (handled as operators/special members)
            if func.kind.is_trait_function() {
                continue;
            }

            // Skip constructors (handled separately)
            if matches!(func.kind, FunctionKind::Constructor) {
                continue;
            }

            // Generate method wrapper
            let return_type = func.return_type.as_ref()
                .map(|r| self.rust_type_to_cpp(r))
                .unwrap_or_else(|| "void".to_string());

            let const_qualifier = if func.is_const { " const" } else { "" };

            // Skip first argument (self)
            let args: Vec<String> = func.args.iter().skip(1).map(|arg| {
                format!("{} {}", self.rust_type_to_cpp(&arg.type_name), arg.name)
            }).collect();

            let c_name = config.apply_prefix(&struct_def.name);
            let c_func = &func.c_name;
            
            // Call arguments for the C function
            let call_args: Vec<String> = std::iter::once("&inner".to_string())
                .chain(func.args.iter().skip(1).map(|arg| arg.name.clone()))
                .collect();

            builder.line(&format!(
                "{} {}({}){} {{ return {}({}); }}",
                return_type,
                func.method_name,
                args.join(", "),
                const_qualifier,
                c_func,
                call_args.join(", ")
            ));
        }
        builder.blank();
    }

    fn generate_enum_class(
        &self,
        builder: &mut CodeBuilder,
        enum_def: &EnumDef,
        config: &CodegenConfig,
    ) {
        // TODO: Generate C++ enum class
        
        let enum_name = &enum_def.name;

        // Doc comment
        if config.generate_docs && !enum_def.doc.is_empty() {
            builder.line("/**");
            for line in &enum_def.doc {
                builder.line(&format!(" * {}", line));
            }
            builder.line(" */");
        }

        if enum_def.is_union {
            // Tagged union - just use the C type with a wrapper
            builder.line(&format!("// {} is a tagged union - use C API directly", enum_name));
            builder.line(&format!("using {} = Az{};", enum_name, enum_name));
        } else {
            // Simple enum
            builder.line(&format!("enum class {} : uint8_t {{", enum_name));
            builder.indent();
            for variant in &enum_def.variants {
                builder.line(&format!("{},", variant.name));
            }
            builder.dedent();
            builder.line("};");
        }
        builder.blank();
    }

    fn rust_type_to_cpp(&self, rust_type: &str) -> String {
        // TODO: Implement full type mapping
        match rust_type {
            "bool" => "bool".to_string(),
            "u8" => "uint8_t".to_string(),
            "u16" => "uint16_t".to_string(),
            "u32" => "uint32_t".to_string(),
            "u64" => "uint64_t".to_string(),
            "usize" => "size_t".to_string(),
            "i8" => "int8_t".to_string(),
            "i16" => "int16_t".to_string(),
            "i32" => "int32_t".to_string(),
            "i64" => "int64_t".to_string(),
            "isize" => "ptrdiff_t".to_string(),
            "f32" => "float".to_string(),
            "f64" => "double".to_string(),
            "c_void" | "()" => "void".to_string(),
            _ => rust_type.to_string(),
        }
    }
}
