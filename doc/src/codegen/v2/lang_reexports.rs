//! Re-export generator
//!
//! Generates a file that re-exports all `Az*` prefixed types from `crate::ffi`
//! as unprefixed types organized into submodules.
//!
//! Output: `target/codegen/v2/reexports.rs`
//!
//! Example output:
//! ```rust
//! pub mod app {
//!     #[doc(inline)]
//!     pub use crate::ffi::dll::AzApp as App;
//!     #[doc(inline)]
//!     pub use crate::ffi::dll::AzAppConfig as AppConfig;
//! }
//! ```

use anyhow::Result;
use std::collections::BTreeMap;

use super::generator::CodeBuilder;
use super::ir::*;

/// Configuration for re-export generation
pub struct ReexportConfig {
    /// Whether to generate top-level doc comments (//!)
    /// Set to false when the file is include!()'d into another file
    pub generate_top_level_comments: bool,
}

impl Default for ReexportConfig {
    fn default() -> Self {
        Self {
            generate_top_level_comments: true,
        }
    }
}

impl ReexportConfig {
    /// Config for include!() - no top-level comments
    pub fn for_include() -> Self {
        Self {
            generate_top_level_comments: false,
        }
    }
}

/// Generate re-exports file
pub fn generate_reexports(ir: &CodegenIR) -> Result<String> {
    generate_reexports_with_config(ir, &ReexportConfig::for_include())
}

/// Generate re-exports file with configuration
pub fn generate_reexports_with_config(ir: &CodegenIR, config: &ReexportConfig) -> Result<String> {
    let mut builder = CodeBuilder::new("    ");

    // File header (only if top-level comments are enabled)
    if config.generate_top_level_comments {
        builder.line("//! Auto-generated re-exports for the Azul public API");
        builder.line("//!");
        builder.line("//! This file re-exports `Az*` prefixed types from `crate::ffi::dll`");
        builder.line("//! as unprefixed types organized into submodules.");
        builder.line("//!");
        builder.line("//! Generated by: cd doc && cargo run --release -- codegen all");
        builder.line("//! DO NOT EDIT MANUALLY");
        builder.blank();
    } else {
        // Regular comments for include!() files
        builder.line("// Auto-generated re-exports for the Azul public API");
        builder.line("// This file re-exports `Az*` prefixed types from `crate::ffi::dll`");
        builder.line("// as unprefixed types organized into submodules.");
        builder.line("// Generated by: cd doc && cargo run --release -- codegen all");
        builder.line("// DO NOT EDIT MANUALLY");
        builder.blank();
    }

    // Group types by module
    let mut modules: BTreeMap<String, Vec<TypeExport>> = BTreeMap::new();

    // Add structs
    for struct_def in &ir.structs {
        let module = normalize_module_name(&struct_def.module);
        let export = TypeExport {
            az_name: format!("Az{}", struct_def.name),
            public_name: struct_def.name.clone(),
            doc: struct_def.doc.first().cloned(),
            is_generic: !struct_def.generic_params.is_empty(),
        };
        modules.entry(module).or_default().push(export);
    }

    // Add enums
    for enum_def in &ir.enums {
        let module = normalize_module_name(&enum_def.module);
        let export = TypeExport {
            az_name: format!("Az{}", enum_def.name),
            public_name: enum_def.name.clone(),
            doc: enum_def.doc.first().cloned(),
            is_generic: !enum_def.generic_params.is_empty(),
        };
        modules.entry(module).or_default().push(export);
    }

    // Add type aliases (but skip primitive aliases like GLuint)
    for type_alias in &ir.type_aliases {
        // Skip primitive type aliases that are already defined in ffi
        if is_primitive_alias(&type_alias.name) {
            continue;
        }
        let module = normalize_module_name(&type_alias.module);
        let export = TypeExport {
            az_name: format!("Az{}", type_alias.name),
            public_name: type_alias.name.clone(),
            doc: type_alias.doc.first().cloned(),
            is_generic: false,
        };
        modules.entry(module).or_default().push(export);
    }

    // Add callback typedefs
    for callback in &ir.callback_typedefs {
        let module = normalize_module_name(&callback.module);
        let export = TypeExport {
            az_name: format!("Az{}", callback.name),
            public_name: callback.name.clone(),
            doc: callback.doc.first().cloned(),
            is_generic: false,
        };
        modules.entry(module).or_default().push(export);
    }

    // Generate module structure
    for (module_name, exports) in &modules {
        // Skip empty modules
        if exports.is_empty() {
            continue;
        }

        // Skip generic types for now (they need special handling)
        let non_generic_exports: Vec<_> = exports.iter().filter(|e| !e.is_generic).collect();

        if non_generic_exports.is_empty() {
            continue;
        }

        // Module doc comment
        builder.line(&format!("/// Types from the `{}` module", module_name));
        builder.line(&format!("pub mod {} {{", module_name));
        builder.indent();

        for export in non_generic_exports {
            // Doc comment if available
            if let Some(doc) = &export.doc {
                builder.line(&format!("/// {}", doc));
            }
            builder.line("#[doc(inline)]");
            builder.line(&format!(
                "pub use crate::ffi::dll::{} as {};",
                export.az_name, export.public_name
            ));
        }

        builder.dedent();
        builder.line("}");
        builder.blank();
    }

    // Generate a prelude module with the most commonly used types
    generate_prelude(&mut builder, &modules);

    Ok(builder.finish())
}

/// A type to be exported
struct TypeExport {
    /// The Az-prefixed name (e.g., "AzApp")
    az_name: String,
    /// The public name without prefix (e.g., "App")
    public_name: String,
    /// First line of documentation
    doc: Option<String>,
    /// Whether this type has generic parameters
    is_generic: bool,
}

/// Normalize module name to a valid Rust identifier
fn normalize_module_name(module: &str) -> String {
    // Convert to snake_case and handle special cases
    let name = module.replace("::", "_").replace("-", "_").to_lowercase();

    // Handle empty module names
    if name.is_empty() {
        return "types".to_string();
    }

    name
}

/// Check if a type alias is a primitive (GL types, etc.)
fn is_primitive_alias(name: &str) -> bool {
    matches!(
        name,
        "GLuint"
            | "GLint"
            | "GLenum"
            | "GLboolean"
            | "GLbitfield"
            | "GLbyte"
            | "GLshort"
            | "GLsizei"
            | "GLubyte"
            | "GLushort"
            | "GLfloat"
            | "GLclampf"
            | "GLdouble"
            | "GLclampd"
            | "GLintptr"
            | "GLsizeiptr"
            | "GLint64"
            | "GLuint64"
            | "c_void"
            | "c_char"
    )
}

/// Generate the prelude module with commonly used types
///
/// This function searches for types across ALL modules, so you only need to
/// specify the type name - the module is automatically determined from where
/// the type actually exists in the generated code.
fn generate_prelude(builder: &mut CodeBuilder, modules: &BTreeMap<String, Vec<TypeExport>>) {
    builder.line("/// Prelude module - import commonly used types with `use azul::prelude::*`");
    builder.line("pub mod prelude {");
    builder.indent();

    // List of commonly used types to include in prelude
    // NOTE: Module is automatically determined - just list the type names
    let prelude_types: &[&str] = &[
        // Core application types
        "App",
        "AppConfig",
        // DOM types
        "Dom",
        "NodeData",
        "DomVec",
        "NodeType",
        "On",
        "Callback",
        // Callbacks - includes VirtualizedViewCallbackInfo, RefAny, Update
        "LayoutCallback",
        "LayoutCallbackInfo",
        "CallbackInfo",
        "VirtualizedViewCallback",
        "VirtualizedViewCallbackInfo",
        "VirtualizedViewCallbackReturn",
        "WriteBackCallback",
        "TimerCallback",
        "TimerCallbackInfo",
        "TimerCallbackReturn",
        "RefAny",
        "Update",
        // CSS types - includes EventFilter types and StyledDom
        "Css",
        "CssProperty",
        "StyledDom",
        "EventFilter",
        "HoverEventFilter",
        "FocusEventFilter",
        "WindowEventFilter",
        "ApplicationEventFilter",
        "ComponentEventFilter",
        "NotEventFilter",
        "LogicalSize",
        "LogicalPosition",
        "LayoutSize",
        "LayoutPoint",
        "LogicalRect",
        "LayoutRect",
        // Option types
        "OptionStyledDom",
        "OptionLogicalPosition",
        // Window types
        "WindowCreateOptions",
        "WindowState",
        // Widgets
        "Button",
        "Label",
        "TextInput",
        "CheckBox",
        "NumberInput",
        "ProgressBar",
        "ColorInput",
        "FileInput",
        // Task / Threading
        "Thread",
        "ThreadId",
        "ThreadSender",
        "ThreadReceiver",
        "ThreadSendMsg",
        "ThreadReceiveMsg",
        "ThreadWriteBackMsg",
        // Time
        "TimerId",
        "Timer",
        "Duration",
        "Instant",
        // NOTE: String is intentionally NOT included in prelude to avoid conflicts with std::string::String
        // Users should use azul::str::String explicitly or .into() for conversions
    ];

    // Search for each type across all modules
    for type_name in prelude_types {
        // Find which module contains this type
        let mut found = false;
        for (_module_name, exports) in modules.iter() {
            if exports
                .iter()
                .any(|e| e.public_name == *type_name && !e.is_generic)
            {
                builder.line("#[doc(inline)]");
                builder.line(&format!(
                    "pub use crate::ffi::dll::Az{} as {};",
                    type_name, type_name
                ));
                found = true;
                break; // Type found, no need to check other modules
            }
        }
        if !found {
            // Emit a compile-time warning comment for missing types
            builder.line(&format!(
                "// WARNING: Type '{}' not found in any module",
                type_name
            ));
        }
    }

    builder.dedent();
    builder.line("}");
}
