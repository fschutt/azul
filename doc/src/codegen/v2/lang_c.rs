//! C header generator
//!
//! Generates C header files from the IR, including:
//! - Struct and enum type definitions
//! - Function declarations
//! - Proper C types (no Rust-specific features)

use anyhow::Result;

use super::config::*;
use super::generator::{CodeBuilder, LanguageGenerator};
use super::ir::*;

// ============================================================================
// C Generator
// ============================================================================

pub struct CGenerator;

impl LanguageGenerator for CGenerator {
    fn generate(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // File header
        builder.line("/*");
        builder.line(" * Auto-generated by azul-doc codegen v2");
        builder.line(" * DO NOT EDIT MANUALLY");
        builder.line(" */");
        builder.blank();

        // Include guards
        builder.line("#ifndef AZUL_H");
        builder.line("#define AZUL_H");
        builder.blank();

        // Standard includes
        for include in &config.imports {
            builder.line(include);
        }
        if !config.imports.is_empty() {
            builder.blank();
        }

        // Platform-specific DLL export/import macros
        self.generate_dll_macros(&mut builder);

        // Forward declarations
        builder.line("/* Forward declarations */");
        self.generate_forward_declarations(&mut builder, ir, config);
        builder.blank();

        // Type definitions
        let types = self.generate_types(ir, config)?;
        builder.raw(&types);

        // Function declarations
        let functions = self.generate_functions(ir, config)?;
        builder.raw(&functions);

        // Close include guards
        builder.line("#endif /* AZUL_H */");

        Ok(builder.finish())
    }

    fn generate_types(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // Type aliases
        builder.line("/* Type aliases */");
        for type_alias in &ir.type_aliases {
            if !config.should_include_type(&type_alias.name) {
                continue;
            }
            self.generate_type_alias(&mut builder, type_alias, config);
        }
        builder.blank();

        // Callback typedefs (function pointers)
        builder.line("/* Callback function pointers */");
        for callback in &ir.callback_typedefs {
            if !config.should_include_type(&callback.name) {
                continue;
            }
            self.generate_callback_typedef(&mut builder, callback, config);
        }
        builder.blank();

        // Enums first (they may be used by structs)
        builder.line("/* Enums */");
        for enum_def in &ir.enums {
            if !config.should_include_type(&enum_def.name) {
                continue;
            }
            self.generate_enum(&mut builder, enum_def, config);
        }
        builder.blank();

        // Structs
        builder.line("/* Structs */");
        for struct_def in &ir.structs {
            if !config.should_include_type(&struct_def.name) {
                continue;
            }
            self.generate_struct(&mut builder, struct_def, config);
        }
        builder.blank();

        Ok(builder.finish())
    }

    fn generate_functions(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        builder.line("/* Functions */");
        builder.blank();

        for func in &ir.functions {
            if !config.should_include_type(&func.class_name) {
                continue;
            }
            self.generate_function_declaration(&mut builder, func, config);
        }

        Ok(builder.finish())
    }

    fn generate_trait_impls(&self, _ir: &CodegenIR, _config: &CodegenConfig) -> Result<String> {
        // C doesn't have traits
        Ok(String::new())
    }
}

// ============================================================================
// Helper functions
// ============================================================================

impl CGenerator {
    fn generate_dll_macros(&self, builder: &mut CodeBuilder) {
        builder.line("/* DLL import/export macros */");
        builder.line("#ifdef _WIN32");
        builder.line("    #ifdef AZUL_EXPORTS");
        builder.line("        #define DLLIMPORT __declspec(dllexport)");
        builder.line("    #else");
        builder.line("        #define DLLIMPORT __declspec(dllimport)");
        builder.line("    #endif");
        builder.line("#else");
        builder.line("    #define DLLIMPORT");
        builder.line("#endif");
        builder.blank();
    }

    fn generate_forward_declarations(
        &self,
        builder: &mut CodeBuilder,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        // TODO: Generate forward declarations for all struct types
        for struct_def in &ir.structs {
            if !config.should_include_type(&struct_def.name) {
                continue;
            }
            let name = config.apply_prefix(&struct_def.name);
            builder.line(&format!("typedef struct {} {};", name, name));
        }
    }

    fn generate_type_alias(
        &self,
        builder: &mut CodeBuilder,
        type_alias: &TypeAliasDef,
        config: &CodegenConfig,
    ) {
        // TODO: Convert Rust type to C type
        let name = config.apply_prefix(&type_alias.name);
        let c_type = self.rust_type_to_c(&type_alias.target);
        builder.line(&format!("typedef {} {};", c_type, name));
    }

    fn generate_callback_typedef(
        &self,
        builder: &mut CodeBuilder,
        callback: &CallbackTypedefDef,
        config: &CodegenConfig,
    ) {
        // TODO: Generate C function pointer typedef
        let name = config.apply_prefix(&callback.name);
        
        let args: Vec<String> = callback.args.iter().map(|arg| {
            let c_type = self.rust_type_to_c(&arg.type_name);
            format!("{} {}", c_type, arg.name)
        }).collect();
        
        let return_type = callback.return_type.as_ref()
            .map(|r| self.rust_type_to_c(r))
            .unwrap_or_else(|| "void".to_string());

        builder.line(&format!(
            "typedef {} (*{})({});",
            return_type,
            name,
            if args.is_empty() { "void".to_string() } else { args.join(", ") }
        ));
    }

    fn generate_struct(
        &self,
        builder: &mut CodeBuilder,
        struct_def: &StructDef,
        config: &CodegenConfig,
    ) {
        // TODO: Generate C struct with proper field types
        let name = config.apply_prefix(&struct_def.name);

        // Doc comment
        if config.generate_docs && !struct_def.doc.is_empty() {
            builder.line("/**");
            for line in &struct_def.doc {
                builder.line(&format!(" * {}", line));
            }
            builder.line(" */");
        }

        if struct_def.fields.is_empty() {
            // Empty struct - use a dummy field for C compatibility
            builder.line(&format!("struct {} {{", name));
            builder.line("    uint8_t _dummy;");
            builder.line("};");
        } else {
            builder.line(&format!("struct {} {{", name));
            builder.indent();
            
            for field in &struct_def.fields {
                let c_type = self.rust_type_to_c_with_prefix(&field.type_name, config);
                builder.line(&format!("{} {};", c_type, field.name));
            }
            
            builder.dedent();
            builder.line("};");
        }
        builder.blank();
    }

    fn generate_enum(
        &self,
        builder: &mut CodeBuilder,
        enum_def: &EnumDef,
        config: &CodegenConfig,
    ) {
        // TODO: Generate C enum or tagged union
        let name = config.apply_prefix(&enum_def.name);

        // Doc comment
        if config.generate_docs && !enum_def.doc.is_empty() {
            builder.line("/**");
            for line in &enum_def.doc {
                builder.line(&format!(" * {}", line));
            }
            builder.line(" */");
        }

        if enum_def.is_union {
            // Tagged union: generate tag enum + union struct
            self.generate_tagged_union(builder, enum_def, config);
        } else {
            // Simple enum
            builder.line(&format!("enum {} {{", name));
            builder.indent();
            
            for (i, variant) in enum_def.variants.iter().enumerate() {
                let variant_name = format!("{}_{}", name, variant.name);
                if i < enum_def.variants.len() - 1 {
                    builder.line(&format!("{},", variant_name));
                } else {
                    builder.line(&format!("{}", variant_name));
                }
            }
            
            builder.dedent();
            builder.line("};");
        }
        builder.blank();
    }

    fn generate_tagged_union(
        &self,
        builder: &mut CodeBuilder,
        enum_def: &EnumDef,
        config: &CodegenConfig,
    ) {
        // TODO: Generate proper tagged union for C
        // This is complex - need to generate:
        // 1. Tag enum
        // 2. Union of variant data
        // 3. Combined struct
        
        let name = config.apply_prefix(&enum_def.name);
        
        // Tag enum
        builder.line(&format!("enum {}_Tag {{", name));
        builder.indent();
        for variant in &enum_def.variants {
            builder.line(&format!("{}_{},", name, variant.name));
        }
        builder.dedent();
        builder.line("};");
        builder.blank();

        // Variant structs (for variants with data)
        for variant in &enum_def.variants {
            match &variant.kind {
                EnumVariantKind::Tuple(types) if !types.is_empty() => {
                    builder.line(&format!("struct {}_Variant_{} {{", name, variant.name));
                    builder.indent();
                    for (i, type_name) in types.iter().enumerate() {
                        let c_type = self.rust_type_to_c_with_prefix(type_name, config);
                        builder.line(&format!("{} payload_{};", c_type, i));
                    }
                    builder.dedent();
                    builder.line("};");
                    builder.blank();
                }
                EnumVariantKind::Struct(fields) if !fields.is_empty() => {
                    builder.line(&format!("struct {}_Variant_{} {{", name, variant.name));
                    builder.indent();
                    for field in fields {
                        let c_type = self.rust_type_to_c_with_prefix(&field.type_name, config);
                        builder.line(&format!("{} {};", c_type, field.name));
                    }
                    builder.dedent();
                    builder.line("};");
                    builder.blank();
                }
                _ => {}
            }
        }

        // Main union struct
        builder.line(&format!("struct {} {{", name));
        builder.indent();
        builder.line(&format!("enum {}_Tag tag;", name));
        builder.line("union {");
        builder.indent();
        for variant in &enum_def.variants {
            match &variant.kind {
                EnumVariantKind::Unit => {}
                EnumVariantKind::Tuple(types) if !types.is_empty() => {
                    builder.line(&format!(
                        "struct {}_Variant_{} {};",
                        name, variant.name, variant.name
                    ));
                }
                EnumVariantKind::Struct(fields) if !fields.is_empty() => {
                    builder.line(&format!(
                        "struct {}_Variant_{} {};",
                        name, variant.name, variant.name
                    ));
                }
                _ => {}
            }
        }
        builder.dedent();
        builder.line("} payload;");
        builder.dedent();
        builder.line("};");
    }

    fn generate_function_declaration(
        &self,
        builder: &mut CodeBuilder,
        func: &FunctionDef,
        config: &CodegenConfig,
    ) {
        // TODO: Generate C function declaration
        
        let args: Vec<String> = func.args.iter().map(|arg| {
            let c_type = self.rust_type_to_c_with_prefix(&arg.type_name, config);
            let (ptr_prefix, ptr_suffix) = match arg.ref_kind {
                ArgRefKind::Owned => ("", ""),
                ArgRefKind::Ref => ("const ", "*"),
                ArgRefKind::RefMut | ArgRefKind::PtrMut => ("", "*"),
                ArgRefKind::Ptr => ("const ", "*"),
            };
            format!("{}{}{} {}", ptr_prefix, c_type, ptr_suffix, arg.name)
        }).collect();

        let return_type = func.return_type.as_ref()
            .map(|r| self.rust_type_to_c_with_prefix(r, config))
            .unwrap_or_else(|| "void".to_string());

        builder.line(&format!(
            "extern DLLIMPORT {} {}({});",
            return_type,
            func.c_name,
            if args.is_empty() { "void".to_string() } else { args.join(", ") }
        ));
    }

    /// Convert Rust type to C type
    fn rust_type_to_c(&self, rust_type: &str) -> String {
        // TODO: Implement full type mapping
        match rust_type {
            "bool" => "bool".to_string(),
            "u8" => "uint8_t".to_string(),
            "u16" => "uint16_t".to_string(),
            "u32" => "uint32_t".to_string(),
            "u64" => "uint64_t".to_string(),
            "usize" => "size_t".to_string(),
            "i8" => "int8_t".to_string(),
            "i16" => "int16_t".to_string(),
            "i32" => "int32_t".to_string(),
            "i64" => "int64_t".to_string(),
            "isize" => "ssize_t".to_string(),
            "f32" => "float".to_string(),
            "f64" => "double".to_string(),
            "c_void" | "()" => "void".to_string(),
            _ => rust_type.to_string(),
        }
    }

    /// Convert Rust type to C type with prefix
    fn rust_type_to_c_with_prefix(&self, rust_type: &str, config: &CodegenConfig) -> String {
        let c_type = self.rust_type_to_c(rust_type);
        
        // If it's a primitive, don't add prefix
        let primitives = [
            "bool", "uint8_t", "uint16_t", "uint32_t", "uint64_t",
            "int8_t", "int16_t", "int32_t", "int64_t",
            "size_t", "ssize_t", "float", "double", "void"
        ];
        
        if primitives.contains(&c_type.as_str()) {
            c_type
        } else {
            config.apply_prefix(&c_type)
        }
    }
}
