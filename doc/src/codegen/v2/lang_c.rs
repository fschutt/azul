//! C header generator
//!
//! Generates C header files from the IR, including:
//! - Struct and enum type definitions
//! - Function declarations
//! - Proper C types (no Rust-specific features)

use anyhow::Result;

use super::config::*;
use super::generator::{CodeBuilder, LanguageGenerator};
use super::ir::*;

/// C++ reserved keywords that need to be escaped in C headers for C++ compatibility
const CPP_RESERVED_KEYWORDS: &[&str] = &[
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "auto",
    "bitand",
    "bitor",
    "bool",
    "break",
    "case",
    "catch",
    "char",
    "char8_t",
    "char16_t",
    "char32_t",
    "class",
    "compl",
    "concept",
    "const",
    "consteval",
    "constexpr",
    "constinit",
    "const_cast",
    "continue",
    "co_await",
    "co_return",
    "co_yield",
    "decltype",
    "default",
    "delete",
    "do",
    "double",
    "dynamic_cast",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "float",
    "for",
    "friend",
    "goto",
    "if",
    "inline",
    "int",
    "long",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast",
    "requires",
    "return",
    "short",
    "signed",
    "sizeof",
    "static",
    "static_assert",
    "static_cast",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "unsigned",
    "using",
    "virtual",
    "void",
    "volatile",
    "wchar_t",
    "while",
    "xor",
    "xor_eq",
];

/// Escape C++ reserved keywords by appending an underscore
/// This ensures C headers can be included from C++ code
fn escape_cpp_keyword_for_c(name: &str) -> String {
    if CPP_RESERVED_KEYWORDS.contains(&name) {
        format!("{}_", name)
    } else {
        name.to_string()
    }
}

// ============================================================================
// C Generator
// ============================================================================

pub struct CGenerator;

impl LanguageGenerator for CGenerator {
    fn generate(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // File header
        builder.line("/*");
        builder.line(" * Auto-generated by azul-doc codegen v2");
        builder.line(" * DO NOT EDIT MANUALLY");
        builder.line(" */");
        builder.blank();

        // Include guards
        builder.line("#ifndef AZUL_H");
        builder.line("#define AZUL_H");
        builder.blank();

        // Standard includes
        for include in &config.imports {
            builder.line(include);
        }
        if !config.imports.is_empty() {
            builder.blank();
        }

        // Platform-specific DLL export/import macros
        self.generate_dll_macros(&mut builder);

        // Forward declarations
        builder.line("/* Forward declarations */");
        self.generate_forward_declarations(&mut builder, ir, config);
        builder.blank();

        // Type definitions
        let types = self.generate_types(ir, config)?;
        builder.raw(&types);

        // Constants (#define macros)
        self.generate_constants(&mut builder, ir, config);

        // Function declarations
        let functions = self.generate_functions(ir, config)?;
        builder.raw(&functions);

        // Enum variant checker functions (is{Variant}())
        self.generate_enum_variant_checkers(&mut builder, ir, config);

        // Union match helper functions
        self.generate_union_match_helpers(&mut builder, ir, config);

        // Vec_empty macros (must come before capi_patch which uses them)
        self.generate_vec_empty_macros(&mut builder, ir, config);

        // C-API patch (additional macros)
        self.generate_capi_patch(&mut builder);

        // Close C++ extern "C" wrapper
        builder.line("/* End C++ compatibility wrapper */");
        builder.line("#ifdef __cplusplus");
        builder.line("}");
        builder.line("#endif");
        builder.blank();

        // Close include guards
        builder.line("#endif /* AZUL_H */");

        Ok(builder.finish())
    }

    fn generate_types(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // Merge all types into a single list sorted by sort_order
        // The IR builder has already computed sort_order for each type
        // Type aliases with monomorphized_def are treated as real types
        #[derive(Clone)]
        enum SortedType<'a> {
            Struct(&'a StructDef),
            Enum(&'a EnumDef),
            Callback(&'a CallbackTypedefDef),
            TypeAlias(&'a TypeAliasDef),
        }

        let mut all_types: Vec<SortedType> = Vec::new();

        for s in &ir.structs {
            // Skip generic types
            if !s.generic_params.is_empty() {
                continue;
            }
            if config.should_include_type(&s.name) {
                all_types.push(SortedType::Struct(s));
            }
        }

        for e in &ir.enums {
            // Skip generic types
            if !e.generic_params.is_empty() {
                continue;
            }
            if config.should_include_type(&e.name) {
                all_types.push(SortedType::Enum(e));
            }
        }

        for c in &ir.callback_typedefs {
            if config.should_include_type(&c.name) {
                all_types.push(SortedType::Callback(c));
            }
        }

        // Add type aliases (both simple and monomorphized)
        for t in &ir.type_aliases {
            if config.should_include_type(&t.name) {
                all_types.push(SortedType::TypeAlias(t));
            }
        }

        // Sort by the sort_order computed in IR builder
        all_types.sort_by_key(|t| match t {
            SortedType::Struct(s) => s.sort_order,
            SortedType::Enum(e) => e.sort_order,
            SortedType::Callback(c) => c.sort_order,
            SortedType::TypeAlias(t) => t.sort_order,
        });

        builder.line("/* Types (topologically sorted by dependencies) */");
        for sorted_type in &all_types {
            match sorted_type {
                SortedType::Struct(struct_def) => {
                    self.generate_struct(&mut builder, struct_def, config);
                }
                SortedType::Enum(enum_def) => {
                    self.generate_enum(&mut builder, enum_def, config);
                }
                SortedType::Callback(callback) => {
                    self.generate_callback_typedef(&mut builder, callback, config);
                }
                SortedType::TypeAlias(type_alias) => {
                    self.generate_type_alias(&mut builder, type_alias, config);
                }
            }
        }
        builder.blank();

        Ok(builder.finish())
    }

    fn generate_functions(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        builder.line("/* Functions */");
        builder.blank();

        // Build a map of callback wrapper types for quick lookup
        // Maps: "IFrameCallback" -> "IFrameCallbackType"
        let callback_wrappers: std::collections::HashMap<&str, &str> = ir
            .structs
            .iter()
            .filter_map(|s| {
                s.callback_wrapper_info
                    .as_ref()
                    .map(|info| (s.name.as_str(), info.callback_typedef_name.as_str()))
            })
            .collect();

        for func in &ir.functions {
            if !config.should_include_type(&func.class_name) {
                continue;
            }
            self.generate_function_declaration(&mut builder, func, config, &callback_wrappers);
        }

        Ok(builder.finish())
    }

    fn generate_trait_impls(&self, _ir: &CodegenIR, _config: &CodegenConfig) -> Result<String> {
        // C doesn't have traits
        Ok(String::new())
    }
}

// ============================================================================
// Helper functions
// ============================================================================

impl CGenerator {
    /// Generate the compatibility preamble with all necessary macros
    /// for cross-platform and cross-compiler support
    fn generate_preamble(&self, builder: &mut CodeBuilder) {
        // C89 restrict keyword portability
        builder.line("/* C89 port for \"restrict\" keyword from C99 */");
        builder.line("#if __STDC__ != 1");
        builder.line("#    define restrict __restrict");
        builder.line("#else");
        builder.line("#    ifndef __STDC_VERSION__");
        builder.line("#        define restrict __restrict");
        builder.line("#    else");
        builder.line("#        if __STDC_VERSION__ < 199901L");
        builder.line("#            define restrict __restrict");
        builder.line("#        endif");
        builder.line("#    endif");
        builder.line("#endif");
        builder.blank();

        // Cross-platform ssize_t definition
        builder.line("/* cross-platform define for ssize_t (signed size_t) */");
        builder.line("#ifdef _WIN32");
        builder.line("    #include <windows.h>");
        builder.line("    #ifdef _MSC_VER");
        builder.line("        typedef SSIZE_T ssize_t;");
        builder.line("    #endif");
        builder.line("#else");
        builder.line("    #include <sys/types.h>");
        builder.line("#endif");
        builder.blank();

        // DLL import/export macros
        builder.line("/* cross-platform define for __declspec(dllimport) */");
        builder.line("#ifdef _WIN32");
        builder.line("    #ifdef AZUL_EXPORTS");
        builder.line("        #define DLLIMPORT __declspec(dllexport)");
        builder.line("    #else");
        builder.line("        #define DLLIMPORT __declspec(dllimport)");
        builder.line("    #endif");
        builder.line("#else");
        builder.line("    #define DLLIMPORT");
        builder.line("#endif");
        builder.blank();

        // Portable _Alignof macro for pre-C11 compilers
        builder.line("/* Portable _Alignof macro for pre-C11 compilers */");
        builder.line("#ifndef AZ_ALIGNOF");
        builder.line("#  if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L");
        builder.line("#    define AZ_ALIGNOF(type) _Alignof(type)");
        builder.line("#  elif defined(__cplusplus) && __cplusplus >= 201103L");
        builder.line("#    define AZ_ALIGNOF(type) alignof(type)");
        builder.line("#  elif defined(__GNUC__) || defined(__clang__)");
        builder.line("#    define AZ_ALIGNOF(type) __alignof__(type)");
        builder.line("#  elif defined(_MSC_VER)");
        builder.line("#    define AZ_ALIGNOF(type) __alignof(type)");
        builder.line("#  else");
        builder.line("#    define AZ_ALIGNOF(type) offsetof(struct { char c; type t; }, t)");
        builder.line("#  endif");
        builder.line("#endif");
        builder.blank();

        // C++ extern "C" wrapper opening
        builder.line("/* C++ compatibility wrapper */");
        builder.line("#ifdef __cplusplus");
        builder.line("extern \"C\" {");
        builder.line("#endif");
        builder.blank();
    }

    fn generate_dll_macros(&self, builder: &mut CodeBuilder) {
        // Now just calls generate_preamble which includes DLL macros
        self.generate_preamble(builder);
    }

    fn generate_forward_declarations(
        &self,
        builder: &mut CodeBuilder,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        // Phase 1: Struct forward declarations (valid in both C and C++)
        builder.line("/* Struct forward declarations */");
        for struct_def in &ir.structs {
            if !config.should_include_type(&struct_def.name) {
                continue;
            }
            // Skip generic types - they need to be monomorphized
            if !struct_def.generic_params.is_empty() {
                continue;
            }
            let name = config.apply_prefix(&struct_def.name);
            builder.line(&format!("struct {};", name));
            builder.line(&format!("typedef struct {} {};", name, name));
        }
        builder.blank();

        // Phase 2: Union forward declarations (for tagged unions)
        builder.line("/* Union forward declarations (tagged enums) */");
        for enum_def in &ir.enums {
            if !config.should_include_type(&enum_def.name) {
                continue;
            }
            // Skip generic types - they need to be monomorphized
            if !enum_def.generic_params.is_empty() {
                continue;
            }
            if enum_def.is_union {
                let name = config.apply_prefix(&enum_def.name);
                builder.line(&format!("union {};", name));
                builder.line(&format!("typedef union {} {};", name, name));
            }
        }

        // Phase 3: Forward declarations for monomorphized type aliases (tagged unions)
        for type_alias in &ir.type_aliases {
            if !config.should_include_type(&type_alias.name) {
                continue;
            }
            if let Some(ref mono_def) = type_alias.monomorphized_def {
                if matches!(mono_def.kind, MonomorphizedKind::TaggedUnion { .. }) {
                    let name = config.apply_prefix(&type_alias.name);
                    builder.line(&format!("union {};", name));
                    builder.line(&format!("typedef union {} {};", name, name));
                }
            }
        }
        builder.blank();

        // Note: Simple enum forward declarations are not valid in C++ without a base type,
        // so we generate full enum definitions before they're used (in generate_types)
    }

    fn generate_type_alias(
        &self,
        builder: &mut CodeBuilder,
        type_alias: &TypeAliasDef,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&type_alias.name);

        // If this type alias has a monomorphized definition, generate it as a full type
        if let Some(ref mono_def) = type_alias.monomorphized_def {
            self.generate_monomorphized_type(builder, &name, mono_def, config);
            return;
        }

        let target = &type_alias.target;

        // Skip generic type aliases without monomorphized def
        if target.contains('<') || target.contains('>') {
            return;
        }

        // Handle pointer types (*const T, *mut T)
        if target.starts_with("*const ") {
            let inner_type = target.strip_prefix("*const ").unwrap().trim();
            let c_inner = self.rust_type_to_c_with_prefix(inner_type, config);
            builder.line(&format!("typedef const {}* {};", c_inner, name));
            return;
        }
        if target.starts_with("*mut ") {
            let inner_type = target.strip_prefix("*mut ").unwrap().trim();
            let c_inner = self.rust_type_to_c_with_prefix(inner_type, config);
            builder.line(&format!("typedef {}* {};", c_inner, name));
            return;
        }

        // Regular type alias
        let c_type = self.rust_type_to_c_with_prefix(target, config);
        builder.line(&format!("typedef {} {};", c_type, name));
    }

    /// Generate a monomorphized type definition
    /// This handles generic type aliases that have been instantiated with concrete types
    fn generate_monomorphized_type(
        &self,
        builder: &mut CodeBuilder,
        name: &str,
        mono_def: &MonomorphizedTypeDef,
        config: &CodegenConfig,
    ) {
        match &mono_def.kind {
            MonomorphizedKind::TaggedUnion { repr, variants } => {
                let is_u8_repr = repr.as_ref().map(|r| r.contains("u8")).unwrap_or(false);

                // Generate tag enum
                builder.line(&format!("enum {}_Tag {{", name));
                builder.indent();
                for variant in variants {
                    builder.line(&format!("{}_Tag_{},", name, variant.name));
                }
                if is_u8_repr {
                    builder.line(&format!("{}_Tag__Force8Bit = 0xFF,", name));
                }
                builder.dedent();
                builder.line("};");
                builder.line(&format!("typedef enum {}_Tag {}_Tag;", name, name));
                builder.blank();

                // Generate variant structs
                for variant in variants {
                    builder.line(&format!("struct {}Variant_{} {{", name, variant.name));
                    builder.indent();
                    builder.line(&format!("{}_Tag tag;", name));

                    if let Some(ref payload_type) = variant.payload_type {
                        let c_type = self.rust_type_to_c_with_prefix(payload_type, config);
                        let (ptr_prefix, ptr_suffix) = self.ref_kind_to_c_syntax(&variant.payload_ref_kind);
                        builder.line(&format!("{}{}{} payload;", ptr_prefix, c_type, ptr_suffix));
                    }

                    builder.dedent();
                    builder.line("};");
                    builder.line(&format!(
                        "typedef struct {}Variant_{} {}Variant_{};",
                        name, variant.name, name, variant.name
                    ));
                    builder.blank();
                }

                // Generate union
                builder.line(&format!("union {} {{", name));
                builder.indent();
                for variant in variants {
                    builder.line(&format!(
                        "{}Variant_{} {};",
                        name, variant.name, variant.name
                    ));
                }
                builder.dedent();
                builder.line("};");
                builder.blank();
            }

            MonomorphizedKind::SimpleEnum { repr, variants } => {
                let is_u8_repr = repr.as_ref().map(|r| r.contains("u8")).unwrap_or(false);

                builder.line(&format!("enum {} {{", name));
                builder.indent();
                for variant in variants {
                    builder.line(&format!("{}_{},", name, variant));
                }
                if is_u8_repr {
                    builder.line(&format!("{}_Force8Bit = 0xFF,", name));
                }
                builder.dedent();
                builder.line("};");
                builder.line(&format!("typedef enum {} {};", name, name));
                builder.blank();
            }

            MonomorphizedKind::Struct { fields } => {
                builder.line(&format!("struct {} {{", name));
                builder.indent();
                for field in fields {
                    let c_type = self.rust_type_to_c_with_prefix(&field.type_name, config);
                    let (ptr_prefix, ptr_suffix) = self.ref_kind_to_c_syntax(&field.ref_kind);
                    builder.line(&format!(
                        "{}{}{} {};",
                        ptr_prefix, c_type, ptr_suffix, field.name
                    ));
                }
                builder.dedent();
                builder.line("};");
                builder.line(&format!("typedef struct {} {};", name, name));
                builder.blank();
            }
        }
    }

    fn generate_callback_typedef(
        &self,
        builder: &mut CodeBuilder,
        callback: &CallbackTypedefDef,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&callback.name);

        let args: Vec<String> = callback
            .args
            .iter()
            .map(|arg| {
                let c_type = self.rust_type_to_c_with_prefix(&arg.type_name, config);
                // Apply ref_kind for pointer types
                let (ptr_prefix, ptr_suffix) = match arg.ref_kind {
                    ArgRefKind::Owned => ("", ""),
                    ArgRefKind::Ref => ("const ", "*"),
                    ArgRefKind::RefMut | ArgRefKind::PtrMut => ("", "* restrict"),
                    ArgRefKind::Ptr => ("const ", "*"),
                };
                format!("{}{}{}", ptr_prefix, c_type, ptr_suffix)
            })
            .collect();

        let return_type = callback
            .return_type
            .as_ref()
            .map(|r| self.rust_type_to_c_with_prefix(r, config))
            .unwrap_or_else(|| "void".to_string());

        builder.line(&format!(
            "typedef {} (*{})({});",
            return_type,
            name,
            if args.is_empty() {
                "void".to_string()
            } else {
                args.join(", ")
            }
        ));
    }

    fn generate_struct(
        &self,
        builder: &mut CodeBuilder,
        struct_def: &StructDef,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&struct_def.name);

        // Doc comment
        if config.generate_docs && !struct_def.doc.is_empty() {
            builder.line("/**");
            for line in &struct_def.doc {
                builder.line(&format!(" * {}", line));
            }
            builder.line(" */");
        }

        if struct_def.fields.is_empty() {
            // Empty struct - use a dummy field for C compatibility
            builder.line(&format!("struct {} {{", name));
            builder.line("    uint8_t _dummy;");
            builder.line("};");
        } else {
            builder.line(&format!("struct {} {{", name));
            builder.indent();

            for field in &struct_def.fields {
                // Extract array info from type (e.g., "[u8; 4]" -> "u8" + "[4]")
                let (base_type, array_suffix) = self.extract_array_from_type(&field.type_name);
                let c_type = self.rust_type_to_c_with_prefix(&base_type, config);

                // Apply ref_kind for pointer types
                let (ptr_prefix, ptr_suffix) = self.ref_kind_to_c_syntax(&field.ref_kind);

                builder.line(&format!(
                    "{}{}{} {}{};",
                    ptr_prefix, c_type, ptr_suffix, field.name, array_suffix
                ));
            }

            builder.dedent();
            builder.line("};");
        }
        builder.blank();
    }

    fn generate_enum(&self, builder: &mut CodeBuilder, enum_def: &EnumDef, config: &CodegenConfig) {
        let name = config.apply_prefix(&enum_def.name);

        // Doc comment
        if config.generate_docs && !enum_def.doc.is_empty() {
            builder.line("/**");
            for line in &enum_def.doc {
                builder.line(&format!(" * {}", line));
            }
            builder.line(" */");
        }

        if enum_def.is_union {
            // Tagged union: generate tag enum + union struct
            self.generate_tagged_union(builder, enum_def, config);
        } else {
            // Simple enum
            // Check if this enum has a u8 repr (for size enforcement)
            let is_u8_repr = enum_def
                .repr
                .as_ref()
                .map(|r| r.contains("u8"))
                .unwrap_or(false);

            builder.line(&format!("enum {} {{", name));
            builder.indent();

            for variant in &enum_def.variants {
                let variant_name = format!("{}_{}", name, variant.name);
                builder.line(&format!("{},", variant_name));
            }

            // Add sentinel value to force enum size for u8 repr
            if is_u8_repr {
                builder.line(&format!("{}_Force8Bit = 0xFF,", name));
            }

            builder.dedent();
            builder.line("};");

            // Add typedef so we can use "AzFoo" instead of "enum AzFoo"
            builder.line(&format!("typedef enum {} {};", name, name));
        }
        builder.blank();
    }

    fn generate_tagged_union(
        &self,
        builder: &mut CodeBuilder,
        enum_def: &EnumDef,
        config: &CodegenConfig,
    ) {
        // Generate tagged union for C:
        // 1. Tag enum with _Tag suffix
        // 2. Variant structs with tag + payload
        // 3. Main union type

        let name = config.apply_prefix(&enum_def.name);

        // Check if this enum has a u8 repr
        let is_u8_repr = enum_def
            .repr
            .as_ref()
            .map(|r| r.contains("u8"))
            .unwrap_or(false);

        // Tag enum with _Tag suffix
        builder.line(&format!("enum {}_Tag {{", name));
        builder.indent();
        for variant in &enum_def.variants {
            builder.line(&format!("{}_Tag_{},", name, variant.name));
        }
        // Add sentinel value to force enum size for u8 repr
        if is_u8_repr {
            builder.line(&format!("{}_Tag__Force8Bit = 0xFF,", name));
        }
        builder.dedent();
        builder.line("};");
        builder.line(&format!("typedef enum {}_Tag {}_Tag;", name, name));
        builder.blank();

        // Variant structs (with tag field in each variant)
        for variant in &enum_def.variants {
            let has_payload = match &variant.kind {
                EnumVariantKind::Tuple(types) => !types.is_empty(),
                EnumVariantKind::Struct(fields) => !fields.is_empty(),
                EnumVariantKind::Unit => false,
            };

            builder.line(&format!("struct {}Variant_{} {{", name, variant.name));
            builder.indent();
            // Use uint8_t for tag if repr is u8, otherwise use the enum type
            if is_u8_repr {
                builder.line("uint8_t tag;");
            } else {
                builder.line(&format!("{}_Tag tag;", name));
            }

            match &variant.kind {
                EnumVariantKind::Tuple(types) if !types.is_empty() => {
                    // Single payload field (Rust enum tuple variants typically have one element)
                    for (i, (type_name, ref_kind)) in types.iter().enumerate() {
                        let c_type = self.rust_type_to_c_with_prefix(type_name, config);
                        let (ptr_prefix, ptr_suffix) = self.ref_kind_to_c_syntax(ref_kind);
                        if types.len() == 1 {
                            builder.line(&format!("{}{}{} payload;", ptr_prefix, c_type, ptr_suffix));
                        } else {
                            builder.line(&format!("{}{}{} payload_{};", ptr_prefix, c_type, ptr_suffix, i));
                        }
                    }
                }
                EnumVariantKind::Struct(fields) if !fields.is_empty() => {
                    for field in fields {
                        let c_type = self.rust_type_to_c_with_prefix(&field.type_name, config);
                        builder.line(&format!("{} {};", c_type, field.name));
                    }
                }
                _ => {}
            }

            builder.dedent();
            builder.line("};");
            builder.line(&format!(
                "typedef struct {}Variant_{} {}Variant_{};",
                name, variant.name, name, variant.name
            ));
            builder.blank();
        }

        // Main union type
        builder.line(&format!("union {} {{", name));
        builder.indent();
        for variant in &enum_def.variants {
            builder.line(&format!(
                "{}Variant_{} {};",
                name, variant.name, variant.name
            ));
        }
        builder.dedent();
        builder.line("};");
        // Note: typedef for union already done in forward declarations
    }

    fn generate_function_declaration(
        &self,
        builder: &mut CodeBuilder,
        func: &FunctionDef,
        config: &CodegenConfig,
        callback_wrappers: &std::collections::HashMap<&str, &str>,
    ) {
        // Only apply callback wrapper substitution for API functions (Constructor, Method, etc.)
        // NOT for trait functions (Delete, DeepCopy, PartialEq, etc.) which operate on the
        // callback wrapper struct itself
        // NOT for EnumVariantConstructor because enum variants need the exact type (e.g.,
        // OptionCallback::Some needs Callback, not CallbackType)
        let should_substitute_callbacks = matches!(
            func.kind,
            FunctionKind::Constructor
                | FunctionKind::StaticMethod
                | FunctionKind::Method
                | FunctionKind::MethodMut
        );

        let args: Vec<String> = func
            .args
            .iter()
            .map(|arg| {
                // Don't substitute callback wrappers for 'self' parameter or for the class's own type
                // (e.g., Callback::to_core takes self which IS a Callback, not a CallbackType)
                let is_self_or_own_type = arg.name == "self"
                    || arg.name == "instance"
                    || arg.type_name == func.class_name;

                // Check if this type is a callback wrapper - if so, use the raw fn pointer type instead
                // This allows C users to pass function pointers directly without wrapping in a struct
                let type_name = if should_substitute_callbacks && !is_self_or_own_type {
                    if let Some(callback_type) = callback_wrappers.get(arg.type_name.as_str()) {
                        (*callback_type).to_string()
                    } else {
                        arg.type_name.clone()
                    }
                } else {
                    arg.type_name.clone()
                };

                let c_type = self.rust_type_to_c_with_prefix(&type_name, config);
                let (ptr_prefix, ptr_suffix) = match arg.ref_kind {
                    ArgRefKind::Owned => ("", ""),
                    ArgRefKind::Ref => ("const ", "*"),
                    ArgRefKind::RefMut | ArgRefKind::PtrMut => ("", "*"),
                    ArgRefKind::Ptr => ("const ", "*"),
                };
                // Escape C++ keywords in parameter names
                let escaped_name = escape_cpp_keyword_for_c(&arg.name);
                format!("{}{}{} {}", ptr_prefix, c_type, ptr_suffix, escaped_name)
            })
            .collect();

        let return_type = func
            .return_type
            .as_ref()
            .map(|r| self.rust_type_to_c_with_prefix(r, config))
            .unwrap_or_else(|| "void".to_string());

        builder.line(&format!(
            "extern DLLIMPORT {} {}({});",
            return_type,
            func.c_name,
            if args.is_empty() {
                "void".to_string()
            } else {
                args.join(", ")
            }
        ));
    }

    /// Convert Rust type to C type
    fn rust_type_to_c(&self, rust_type: &str) -> String {
        let trimmed = rust_type.trim();

        // Handle pointer types first
        if trimmed.starts_with("*const ") {
            let inner = trimmed.strip_prefix("*const ").unwrap().trim();
            let c_inner = self.rust_type_to_c(inner);
            return format!("const {}*", c_inner);
        }
        if trimmed.starts_with("*mut ") {
            let inner = trimmed.strip_prefix("*mut ").unwrap().trim();
            let c_inner = self.rust_type_to_c(inner);
            return format!("{}*", c_inner);
        }

        // Handle basic type mappings
        match trimmed {
            "bool" => "bool".to_string(),
            "u8" => "uint8_t".to_string(),
            "u16" => "uint16_t".to_string(),
            "u32" => "uint32_t".to_string(),
            "u64" => "uint64_t".to_string(),
            "usize" => "size_t".to_string(),
            "i8" => "int8_t".to_string(),
            "i16" => "int16_t".to_string(),
            "i32" => "int32_t".to_string(),
            "i64" => "int64_t".to_string(),
            "isize" => "ssize_t".to_string(),
            "f32" => "float".to_string(),
            "f64" => "double".to_string(),
            "c_void" | "()" => "void".to_string(),
            // C FFI types
            "c_char" => "char".to_string(),
            "c_uchar" => "unsigned char".to_string(),
            "c_short" => "short".to_string(),
            "c_ushort" => "unsigned short".to_string(),
            "c_int" => "int".to_string(),
            "c_uint" => "unsigned int".to_string(),
            "c_long" => "long".to_string(),
            "c_ulong" => "unsigned long".to_string(),
            "c_longlong" => "long long".to_string(),
            "c_ulonglong" => "unsigned long long".to_string(),
            "c_float" => "float".to_string(),
            "c_double" => "double".to_string(),
            _ => trimmed.to_string(),
        }
    }

    /// Convert Rust type to C type with prefix
    fn rust_type_to_c_with_prefix(&self, rust_type: &str, config: &CodegenConfig) -> String {
        let trimmed = rust_type.trim();

        // Handle pointer types - only add prefix to the base type
        if trimmed.starts_with("*const ") {
            let inner = trimmed.strip_prefix("*const ").unwrap().trim();
            let c_inner = self.rust_type_to_c_with_prefix(inner, config);
            return format!("const {}*", c_inner);
        }
        if trimmed.starts_with("*mut ") {
            let inner = trimmed.strip_prefix("*mut ").unwrap().trim();
            let c_inner = self.rust_type_to_c_with_prefix(inner, config);
            return format!("{}*", c_inner);
        }

        let c_type = self.rust_type_to_c(rust_type);

        // If it's a primitive, don't add prefix
        let primitives = [
            "bool",
            "uint8_t",
            "uint16_t",
            "uint32_t",
            "uint64_t",
            "int8_t",
            "int16_t",
            "int32_t",
            "int64_t",
            "size_t",
            "ssize_t",
            "float",
            "double",
            "void",
            "c_void", // Also check original Rust name
            // C FFI types
            "char",
            "unsigned char",
            "short",
            "unsigned short",
            "int",
            "unsigned int",
            "long",
            "unsigned long",
            "long long",
            "unsigned long long",
            "c_char",
            "c_uchar",
            "c_short",
            "c_ushort",
            "c_int",
            "c_uint",
            "c_long",
            "c_ulong",
            "c_longlong",
            "c_ulonglong",
            "c_float",
            "c_double",
        ];

        if primitives.contains(&c_type.as_str()) || primitives.contains(&trimmed) {
            c_type
        } else {
            config.apply_prefix(&c_type)
        }
    }

    /// Extract array info from a type string for code generation
    /// Returns (base_type, c_array_suffix) where c_array_suffix is like "[4]" for arrays
    fn extract_array_from_type(&self, type_str: &str) -> (String, String) {
        let trimmed = type_str.trim();

        // Check if it's an array type: [T; N]
        if trimmed.starts_with('[') && trimmed.ends_with(']') {
            let inner = &trimmed[1..trimmed.len() - 1];
            if let Some(semicolon_pos) = inner.rfind(';') {
                let base_type = inner[..semicolon_pos].trim().to_string();
                let size_str = inner[semicolon_pos + 1..].trim();
                if size_str.parse::<usize>().is_ok() {
                    return (base_type, format!("[{}]", size_str));
                }
            }
        }

        (trimmed.to_string(), String::new())
    }

    /// Convert a FieldRefKind to C pointer syntax (prefix, suffix)
    /// Returns (prefix, suffix) where:
    /// - prefix: e.g., "const " for const pointers
    /// - suffix: e.g., "*" for pointers, "* restrict" for restrict pointers
    fn ref_kind_to_c_syntax(&self, ref_kind: &FieldRefKind) -> (&'static str, &'static str) {
        match ref_kind {
            FieldRefKind::Ref => ("const ", "*"),
            FieldRefKind::RefMut => ("", "* restrict"),
            FieldRefKind::Ptr => ("const ", "*"),
            FieldRefKind::PtrMut => ("", "*"),
            FieldRefKind::Owned => ("", ""),
            FieldRefKind::Boxed | FieldRefKind::OptionBoxed => ("", "*"),
        }
    }

    /// Generate constant definitions as #define macros
    fn generate_constants(
        &self,
        builder: &mut CodeBuilder,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        if ir.constants.is_empty() {
            return;
        }

        builder.line("/* CONSTANTS */");
        builder.blank();

        for constant in &ir.constants {
            let name = config.apply_prefix(&constant.name);
            builder.line(&format!("#define {} {}", name, constant.value));
        }
        builder.blank();
    }

    /// Generate is{Variant}() helper functions for all enums (both simple and tagged unions)
    /// These provide a cleaner API for checking enum variants in C:
    ///   if (AzOptionJson_isSome(&opt)) { ... }
    ///   if (AzOptionJson_isNone(&opt)) { ... }
    fn generate_enum_variant_checkers(
        &self,
        builder: &mut CodeBuilder,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        builder.line("/* Enum variant checker functions */");
        builder.blank();

        for enum_def in &ir.enums {
            if !config.should_include_type(&enum_def.name) {
                continue;
            }
            // Skip generic enums - they need to be monomorphized first
            if !enum_def.generic_params.is_empty() {
                continue;
            }

            let name = config.apply_prefix(&enum_def.name);
            
            // Get the first variant name to access the tag for unions
            // (all variants share the same tag at the same offset due to repr(C, u8))
            let first_variant_name = enum_def.variants.first().map(|v| &v.name);

            for variant in &enum_def.variants {
                // Generate is{Variant}() function
                // For unions, we check the tag via the first variant's struct
                // (the tag is at the same offset in all variant structs)
                // For simple enums, we compare the value directly
                if enum_def.is_union {
                    if let Some(first_name) = first_variant_name {
                        builder.line(&format!(
                            "#define {}_is{}(value) ((value)->{}.tag == {}_Tag_{})",
                            name, variant.name, first_name, name, variant.name
                        ));
                    }
                } else {
                    builder.line(&format!(
                        "#define {}_is{}(value) (*(value) == {}_{})",
                        name, variant.name, name, variant.name
                    ));
                }
            }
            builder.blank();
        }
    }

    /// Generate union match helper functions for tagged unions
    /// These help with pattern matching in C:
    /// - matchRef: immutable pattern match, returns pointer to payload
    /// - matchMut: mutable pattern match, returns mutable pointer to payload
    fn generate_union_match_helpers(
        &self,
        builder: &mut CodeBuilder,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        builder.line("/* Union helpers */");
        builder.blank();

        for enum_def in &ir.enums {
            if !config.should_include_type(&enum_def.name) {
                continue;
            }
            if !enum_def.is_union {
                continue;
            }
            // Skip generic enums - they need to be monomorphized first
            if !enum_def.generic_params.is_empty() {
                continue;
            }

            let name = config.apply_prefix(&enum_def.name);

            for variant in &enum_def.variants {
                // Get the payload type(s) for this variant
                let payload_types: Vec<String> = match &variant.kind {
                    EnumVariantKind::Tuple(types) => types.iter().map(|(t, _)| t.clone()).collect(),
                    EnumVariantKind::Struct(_) => continue, // Skip struct variants for now
                    EnumVariantKind::Unit => continue,      // Skip unit variants
                };

                if payload_types.is_empty() {
                    continue;
                }

                // Only handle single-element tuple variants for now
                if payload_types.len() != 1 {
                    continue;
                }

                let payload_type = &payload_types[0];

                // Skip array types - they require different handling
                if payload_type.starts_with('[') {
                    continue;
                }

                let c_payload_type = self.rust_type_to_c_with_prefix(payload_type, config);

                // Generate matchRef helper (immutable)
                builder.line(&format!(
                    "bool {}_matchRef{}(const {}* value, const {}** restrict out) {{",
                    name, variant.name, name, c_payload_type
                ));
                builder.line(&format!(
                    "    const {}Variant_{}* casted = (const {}Variant_{}*)value;",
                    name, variant.name, name, variant.name
                ));
                builder.line(&format!(
                    "    bool valid = casted->tag == {}_Tag_{};",
                    name, variant.name
                ));
                builder.line("    if (valid) { *out = &casted->payload; } else { *out = 0; }");
                builder.line("    return valid;");
                builder.line("}");
                builder.blank();

                // Generate matchMut helper (mutable)
                builder.line(&format!(
                    "bool {}_matchMut{}({}* restrict value, {}* restrict * restrict out) {{",
                    name, variant.name, name, c_payload_type
                ));
                builder.line(&format!(
                    "    {}Variant_{}* restrict casted = ({}Variant_{}* restrict)value;",
                    name, variant.name, name, variant.name
                ));
                builder.line(&format!(
                    "    bool valid = casted->tag == {}_Tag_{};",
                    name, variant.name
                ));
                builder.line("    if (valid) { *out = &casted->payload; } else { *out = 0; }");
                builder.line("    return valid;");
                builder.line("}");
                builder.blank();
            }
        }
    }

    /// Generate empty Vec initializer macros for all Vec types
    /// These allow convenient compile-time initialization of empty vectors in C99
    fn generate_vec_empty_macros(
        &self,
        builder: &mut CodeBuilder,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        builder.line("/* Empty Vec initializer macros - C99 designated initializers */");
        builder.line("#ifndef __cplusplus");
        builder.blank();

        for struct_def in &ir.structs {
            // Skip if not included in config
            if !config.should_include_type(&struct_def.name) {
                continue;
            }

            // Check if this is a Vec type
            if !matches!(struct_def.category, TypeCategory::Vec) {
                continue;
            }

            // Find the destructor field to get its type
            let destructor_field = struct_def.fields.iter().find(|f| f.name == "destructor");
            let has_run_destructor = false; // run_destructor field has been removed, destructor enum now uses AlreadyDestroyed variant

            if let Some(destr_field) = destructor_field {
                let prefixed_name = config.apply_prefix(&struct_def.name);
                let destructor_type = config.apply_prefix(&destr_field.type_name);

                if has_run_destructor {
                    // Vec with run_destructor field (e.g., FmtArgVec)
                    builder.line(&format!(
                        "#define {}_empty {{ \\",
                        prefixed_name
                    ));
                    builder.line("    .ptr = 0, \\");
                    builder.line("    .len = 0, \\");
                    builder.line("    .cap = 0, \\");
                    builder.line(&format!(
                        "    .destructor = {{ .NoDestructor = {{ .tag = {}_Tag_NoDestructor }} }}, \\",
                        destructor_type
                    ));
                    builder.line("    .run_destructor = false \\");
                    builder.line("}");
                } else {
                    // Standard Vec without run_destructor
                    builder.line(&format!(
                        "#define {}_empty {{ \\",
                        prefixed_name
                    ));
                    builder.line("    .ptr = 0, \\");
                    builder.line("    .len = 0, \\");
                    builder.line("    .cap = 0, \\");
                    builder.line(&format!(
                        "    .destructor = {{ .NoDestructor = {{ .tag = {}_Tag_NoDestructor }} }} \\",
                        destructor_type
                    ));
                    builder.line("}");
                }
                builder.blank();
            }
        }

        builder.line("#endif /* __cplusplus - end of Vec_empty macros */");
        builder.blank();
    }

    /// Generate the C-API patch (additional macros for convenience)
    fn generate_capi_patch(&self, builder: &mut CodeBuilder) {
        // NOTE: Most compile-time initializer macros (AzNodeData_new, AzDom_newStatic, 
        // AzAppConfig_default) were REMOVED because they can easily get out of sync 
        // with the actual Rust struct definitions.
        //
        // Users MUST call the corresponding _create() or _new() functions instead:
        // - AzNodeData_createDiv() etc.
        // - AzDom_createDiv() etc.
        // - AzAppConfig_create()
        //
        // These functions properly initialize all fields via the Rust runtime and
        // will always stay in sync with the struct definitions.
        //
        // EXCEPTION: AzString_fromConstStr is kept because it's only used internally
        // by the AZ_REFLECT macro for type name debugging strings.

        builder.line("/* C99 Designated Initializers - only available in C, not C++ */");
        builder.line("#ifndef __cplusplus");
        builder.blank();

        // AzString_fromConstStr macro - kept for AZ_REFLECT macro only
        builder.line("/* Macro to turn a compile-time string into a compile-time AzString");
        builder.line(" * WARNING: Only use this for compile-time constant strings!");
        builder.line(" * For runtime strings, use AzString_copyFromBytes() instead.");
        builder.line(" *");
        builder.line(" * static AzString foo = AzString_fromConstStr(\"MyString\");");
        builder.line(" */");
        builder.line("#define AzString_fromConstStr(s) { \\");
        builder.line("    .vec = { \\");
        builder.line("        .ptr = (const uint8_t*)(s), \\");
        builder.line("        .len = sizeof(s) - 1, \\");
        builder.line("        .cap = sizeof(s) - 1, \\");
        builder.line("        .destructor = { .NoDestructor = { .tag = AzU8VecDestructor_Tag_NoDestructor } }, \\");
        builder.line("    } \\");
        builder.line("}");
        builder.blank();

        builder.line("#endif /* __cplusplus - end of C99 designated initializer macros */");
        builder.blank();

        // AZ_REFLECT macro for user-defined types
        self.generate_az_reflect_macro(builder);
    }

    /// Generate the AZ_REFLECT macro for user-defined type reflection
    fn generate_az_reflect_macro(&self, builder: &mut CodeBuilder) {
        builder.line("/* C-only reflection macro - uses C99 designated initializers */");
        builder.line("#ifndef __cplusplus");
        builder.blank();

        builder.line("/* Macro to generate reflection metadata for a given struct - for a \"structName\" of \"foo\", generates:");
        builder.line(" *");
        builder.line(" * constants:");
        builder.line(" * - a foo_RttiTypeId, which serves as the \"type ID\" for that struct");
        builder.line(" * - a foo_RttiString, a compile-time string that identifies the class");
        builder.line(" *");
        builder.line(" * structs:");
        builder.line(" * - struct fooRef(): immutable reference to a RefAny<foo>");
        builder.line(" * - struct fooRefMut(): mutable reference to a RefAny<foo>");
        builder.line(" *");
        builder.line(" * functions:");
        builder
            .line(" * - AzRefAny foo_upcast(myStructInstance): upcasts a #structName to a RefAny");
        builder.line(" *");
        builder.line(" * - fooRef_create(AzRefAny): creates a new fooRef, but does not yet downcast it (.ptr is set to nullptr)");
        builder.line(" * - fooRefMut_create(AzRefAny): creates a new fooRefMut, but does not yet downcast it (.ptr is set to nullptr)");
        builder.line(" *");
        builder.line(" * - bool foo_downcastRef(AzRefAny, fooRef* restrict): downcasts the RefAny immutably, if true is returned then the fooRef is properly initialized");
        builder.line(" * - bool foo_downcastMut(AzRefAny, fooRefMut* restrict): downcasts the RefAny mutably, if true is returned then the fooRef is properly initialized");
        builder.line(" *");
        builder.line(" * - void fooRef_delete(fooRef): disposes of the fooRef and decreases the immutable reference count");
        builder.line(" * - void fooRefMut_delete(fooRefMut): disposes of the fooRefMut and decreases the mutable reference count");
        builder.line(" * - bool fooRefAny_delete(AzRefAny): disposes of the AzRefAny type, returns false if the AzRefAny is not of type RefAny<foo>");
        builder.line(" *");
        builder.line(" * USAGE:");
        builder.line(" *");
        builder.line(" *     typedef struct { } foo;");
        builder.line(" *");
        builder.line(
            " *     // -- destructor of foo, azul will call this function once the refcount hits 0",
        );
        builder.line(" *     // note: the function expects a void*, but you can just use a foo*");
        builder.line(" *     void fooDestructor(foo* restrict destructorPtr) { }");
        builder.line(" *");
        builder.line(" *     AZ_REFLECT(foo, fooDestructor)");
        builder.line("*/");

        // The actual macro definition - basic version without JSON support
        builder.line("#define AZ_REFLECT(structName, destructor) \\");
        builder.line("    AZ_REFLECT_FULL(structName, destructor, 0, 0)");
        builder.line("");
        
        // Full macro with JSON support
        builder.line("/* Full reflection with optional JSON support */");
        builder.line("#define AZ_REFLECT_JSON(structName, destructor, toJsonFn, fromJsonFn) \\");
        builder.line("    AZ_REFLECT_FULL(structName, destructor, (uintptr_t)(toJsonFn), (uintptr_t)(fromJsonFn))");
        builder.line("");
        
        // Internal macro with all parameters
        builder.line("/* Internal macro with all parameters */");
        builder.line("#define AZ_REFLECT_FULL(structName, destructor, serializeFn, deserializeFn) \\");
        builder.line("    /* in C all statics are guaranteed to have a unique address, use that address as a TypeId */ \\");
        builder.line("    static uint64_t const structName##_RttiTypePtrId = 0; \\");
        builder.line("    static uint64_t const structName##_RttiTypeId = (uint64_t)(&structName##_RttiTypePtrId); \\");
        builder.line("    static AzString const structName##_Type_RttiString = AzString_fromConstStr(#structName); \\");
        builder.line("    \\");
        builder.line("    AzRefAny structName##_upcast(structName const s) { \\");
        builder.line("        AzGlVoidPtrConst ptr_wrapper = { .ptr = (const void*)&s }; \\");
        builder.line("        return AzRefAny_newC(ptr_wrapper, sizeof(structName), AZ_ALIGNOF(structName), structName##_RttiTypeId, structName##_Type_RttiString, destructor, serializeFn, deserializeFn); \\");
        builder.line("    } \\");
        builder.line("    \\");
        builder.line("    /* generate structNameRef and structNameRefMut structs*/ \\");
        builder.line("    typedef struct { const structName* ptr; AzRefCount sharing_info; } structName##Ref; \\");
        builder.line("    typedef struct { structName* restrict ptr; AzRefCount sharing_info; } structName##RefMut; \\");
        builder.line("    \\");
        builder.line("    structName##Ref structName##Ref_create(AzRefAny* const refany) { \\");
        builder.line("        structName##Ref val = { .ptr = 0, .sharing_info = AzRefCount_clone(&refany->sharing_info) };    \\");
        builder.line("        return val;    \\");
        builder.line("    } \\");
        builder.line("    \\");
        builder
            .line("    structName##RefMut structName##RefMut_create(AzRefAny* const refany) { \\");
        builder.line("        structName##RefMut val = { .ptr = 0, .sharing_info = AzRefCount_clone(&refany->sharing_info), };    \\");
        builder.line("        return val;    \\");
        builder.line("    } \\");
        builder.line("    \\");
        builder.line("    /* if downcastRef returns true, the downcast worked */ \\");
        builder.line("    bool structName##_downcastRef(AzRefAny* restrict refany, structName##Ref * restrict result) { \\");
        builder.line("        if (!AzRefAny_isType(refany, structName##_RttiTypeId)) { return false; } else { \\");
        builder.line("            if (!AzRefCount_canBeShared(&refany->sharing_info)) { return false; } else {\\");
        builder.line("                AzRefCount_increaseRef(&refany->sharing_info); \\");
        builder
            .line("                result->ptr = (structName* const)(AzRefAny_getDataPtr(refany)); \\");
        builder.line("                return true; \\");
        builder.line("            } \\");
        builder.line("        } \\");
        builder.line("    } \\");
        builder.line("    \\");
        builder.line("    /* if downcastRefMut returns true, the mutable downcast worked */ \\");
        builder.line("    bool structName##_downcastMut(AzRefAny* restrict refany, structName##RefMut * restrict result) { \\");
        builder.line("        if (!AzRefAny_isType(refany, structName##_RttiTypeId)) { return false; } else { \\");
        builder.line("            if (!AzRefCount_canBeSharedMut(&refany->sharing_info)) { return false; }  else {\\");
        builder.line("                AzRefCount_increaseRefmut(&refany->sharing_info); \\");
        builder.line(
            "                result->ptr = (structName* restrict)(AzRefAny_getDataPtr(refany)); \\",
        );
        builder.line("                return true; \\");
        builder.line("            } \\");
        builder.line("        } \\");
        builder.line("    } \\");
        builder.line("    \\");
        builder.line("    /* releases a structNameRef (decreases the RefCount) */ \\");
        builder.line("    void structName##Ref_delete(structName##Ref* restrict value) { \\");
        builder.line("        AzRefCount_decreaseRef(&value->sharing_info); \\");
        builder.line("        AzRefCount_delete(&value->sharing_info); \\");
        builder.line("    }\\");
        builder.line("    \\");
        builder.line("    /* releases a structNameRefMut (decreases the mutable RefCount) */ \\");
        builder.line("    void structName##RefMut_delete(structName##RefMut* restrict value) { \\");
        builder.line("        AzRefCount_decreaseRefmut(&value->sharing_info); \\");
        builder.line("        AzRefCount_delete(&value->sharing_info); \\");
        builder.line("    }\\");
        builder.line("    /* releases a structNameRefAny (checks if the RefCount is 0 and calls the destructor) */ \\");
        builder.line("    bool structName##RefAny_delete(AzRefAny* restrict refany) { \\");
        builder.line(
            "        if (!AzRefAny_isType(refany, structName##_RttiTypeId)) { return false; } \\",
        );
        builder.line("        AzRefAny_delete(refany); \\");
        builder.line("        return true; \\");
        builder.line("    }");
        builder.blank();

        builder.line("#endif /* __cplusplus - end of C-only reflection macro */");
        builder.blank();
    }
}
