//! Rust code generator
//!
//! Generates Rust code from the IR, including:
//! - Struct and enum definitions
//! - C-ABI function definitions or declarations
//! - Trait implementations using transmute

use anyhow::Result;
use std::collections::BTreeSet;

use super::config::*;
use super::generator::{CodeBuilder, LanguageGenerator};
use super::ir::*;
use super::transmute_helpers::{generate_transmuted_fn_body, parse_arg_type};

// ============================================================================
// Rust Generator
// ============================================================================

pub struct RustGenerator;

impl LanguageGenerator for RustGenerator {
    fn generate(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // File header
        builder.line("// Auto-generated by azul-doc codegen v2");
        builder.line("// DO NOT EDIT MANUALLY");
        builder.blank();

        // Check if this is a "simple" config (no module wrapper, no prefix)
        // Used for rust_public_api which generates flat type definitions
        let is_simple_mode = config.module_wrapper.is_none() && config.type_prefix.is_empty();
        
        if is_simple_mode {
            // Simple mode: just generate types directly, no nested modules
            return self.generate_simple_rust_api(ir, config);
        }

        // Generate inner module wrapper (using the same structure as existing dll_api.rs)
        // The structure is: pub mod __dll_api_inner { pub mod dll { ... } }
        builder.line("pub mod __dll_api_inner {");
        builder.indent();
        builder.line("pub mod dll {");
        builder.indent();

        // Imports
        for import in &config.imports {
            builder.line(import);
        }
        if !config.imports.is_empty() {
            builder.blank();
        }

        // GL type aliases first
        builder.line("// --- GL Type Aliases ---");
        self.generate_gl_type_aliases(&mut builder);
        builder.blank();

        // Primitive type aliases
        builder.line("// --- Primitive Type Aliases ---");
        self.generate_primitive_aliases(&mut builder);
        builder.blank();

        // Type definitions (structs and enums)
        if config.struct_mode != StructMode::None {
            builder.line("// --- Type Definitions ---");
            let types = self.generate_types(ir, config)?;
            builder.raw(&types);
        }

        // Trait implementations
        builder.line("// --- Trait Implementations ---");
        let trait_impls = self.generate_trait_impls(ir, config)?;
        builder.raw(&trait_impls);

        // Methods (impl blocks for Rust API)
        builder.line("// --- Method Implementations ---");
        let impl_blocks = self.generate_impl_blocks(ir, config)?;
        builder.raw(&impl_blocks);

        // Rust-only generic methods (not part of C-ABI)
        builder.line("// --- Rust-Only Generic Methods ---");
        let rust_only = self.generate_rust_only_impls(config)?;
        builder.raw(&rust_only);

        // Functions
        builder.line("// --- C-ABI Functions ---");
        let functions = self.generate_functions(ir, config)?;
        builder.raw(&functions);

        // End module wrappers
        builder.dedent();
        builder.line("} // mod dll");
        builder.dedent();
        builder.line("} // mod __dll_api_inner");

        // Re-exports at the end
        builder.blank();
        self.generate_reexports(&mut builder, "__dll_api_inner");

        // Generate tests if enabled
        if config.generate_tests {
            builder.blank();
            let tests = self.generate_tests(ir, config)?;
            builder.raw(&tests);
        }

        Ok(builder.finish())
    }

    fn generate_types(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // Type aliases first
        for type_alias in &ir.type_aliases {
            if !config.should_include_type(&type_alias.name) {
                continue;
            }
            self.generate_type_alias(&mut builder, type_alias, config);
        }

        // Callback typedefs
        for callback in &ir.callback_typedefs {
            if !config.should_include_type(&callback.name) {
                continue;
            }
            self.generate_callback_typedef(&mut builder, callback, config);
        }

        // Structs
        for struct_def in &ir.structs {
            if !config.should_include_type(&struct_def.name) {
                continue;
            }
            self.generate_struct(&mut builder, struct_def, ir, config);
        }

        // Enums
        for enum_def in &ir.enums {
            if !config.should_include_type(&enum_def.name) {
                continue;
            }
            self.generate_enum(&mut builder, enum_def, ir, config);
        }

        Ok(builder.finish())
    }

    fn generate_functions(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // When using transmute-based trait impls, we don't need C-ABI trait functions
        // because traits are implemented directly using transmute, not via C-ABI calls.
        // HOWEVER: When building the DLL (no_mangle = true), we MUST export all trait
        // functions because C/C++/Python need to call them for destructors (_delete),
        // cloning (_deepCopy), etc. The trait impls inside Rust can use transmute,
        // but we still need the exported C-ABI functions for FFI.
        let skip_trait_functions = matches!(
            config.trait_impl_mode,
            TraitImplMode::UsingTransmute { .. } | TraitImplMode::UsingDerive
        );

        match &config.cabi_functions {
            CAbiFunctionMode::InternalBindings { no_mangle } => {
                for func in &ir.functions {
                    if !config.should_include_type(&func.class_name) {
                        continue;
                    }
                    // Skip trait functions when using transmute impls ONLY for internal use.
                    // When no_mangle is true (DLL build), we need to export all functions
                    // for C/C++/Python bindings to call _delete, _deepCopy, etc.
                    if skip_trait_functions && !*no_mangle && func.kind.is_trait_function() {
                        continue;
                    }
                    self.generate_function_definition(&mut builder, func, ir, config, *no_mangle);
                }
            }
            CAbiFunctionMode::ExternalBindings { link_library } => {
                builder.line(&format!("#[link(name = \"{}\")]", link_library));
                builder.line("extern \"C\" {");
                builder.indent();
                
                for func in &ir.functions {
                    if !config.should_include_type(&func.class_name) {
                        continue;
                    }
                    if skip_trait_functions && func.kind.is_trait_function() {
                        continue;
                    }
                    self.generate_function_declaration(&mut builder, func, config);
                }
                
                builder.dedent();
                builder.line("}");
            }
            CAbiFunctionMode::None => {}
        }

        Ok(builder.finish())
    }

    fn generate_trait_impls(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        match &config.trait_impl_mode {
            TraitImplMode::UsingDerive => {
                // Derives are handled in struct/enum generation
            }
            TraitImplMode::UsingTransmute { external_crate } => {
                // Generate trait impls using transmute
                for struct_def in &ir.structs {
                    if !config.should_include_type(&struct_def.name) {
                        continue;
                    }
                    self.generate_transmute_trait_impls(&mut builder, struct_def, config, external_crate);
                }
                for enum_def in &ir.enums {
                    if !config.should_include_type(&enum_def.name) {
                        continue;
                    }
                    self.generate_transmute_trait_impls_enum(&mut builder, enum_def, config, external_crate);
                }
            }
            TraitImplMode::UsingCAPI => {
                for struct_def in &ir.structs {
                    if !config.should_include_type(&struct_def.name) {
                        continue;
                    }
                    self.generate_capi_trait_impls(&mut builder, struct_def, config);
                }
                for enum_def in &ir.enums {
                    if !config.should_include_type(&enum_def.name) {
                        continue;
                    }
                    self.generate_capi_trait_impls_enum(&mut builder, enum_def, config);
                }
            }
            TraitImplMode::None => {}
        }

        Ok(builder.finish())
    }
}

// ============================================================================
// Helper Methods - Impl Blocks for Rust API
// ============================================================================

impl RustGenerator {
    /// Generate Rust-only generic methods that can't be exposed via C-ABI
    /// 
    /// These include:
    /// - RefAny::new<T>() - construct RefAny from any Rust type
    /// - RefAny::downcast_ref<T>() / downcast_mut<T>() - get typed references
    /// 
    /// For internal bindings (build-dll/link-static): implemented via transmute to core type.
    /// For external bindings (link-dynamic): these methods are NOT available because
    /// they require access to internal types that aren't exposed through the C-ABI.
    fn generate_rust_only_impls(&self, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);
        
        let prefix = &config.type_prefix;
        
        // Check if we're using external bindings (link-dynamic)
        // In that case, we can't use transmute because we don't have azul_core
        let is_external_bindings = matches!(
            &config.cabi_functions,
            CAbiFunctionMode::ExternalBindings { .. }
        );
        
        if is_external_bindings {
            // For link-dynamic: RefAny::new and downcast are NOT available
            // Users must use the pre-built DLL which doesn't support generic Rust types
            // Don't generate an empty impl block - just skip RefAny generic methods entirely
            builder.blank();
        } else {
            // For internal bindings (build-dll/link-static): use transmute to azul_core
            
            // RefAny generic methods - implemented via transmute to core type
            builder.line(&format!("impl {}RefAny {{", prefix));
            builder.indent();
            
            // new<T>
            builder.line("/// Creates a new type-erased RefAny containing the given value.");
            builder.line("pub fn new<T: 'static>(value: T) -> Self {");
            builder.indent();
            builder.line("use core::mem::transmute;");
            builder.line("unsafe {");
            builder.indent();
            builder.line("transmute(azul_core::refany::RefAny::new(value))");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
            
            // downcast_ref<T> - using guards, must return wrapped type
            builder.line("/// Returns a RAII guard to the inner value if types match.");
            builder.line("/// ");
            builder.line("/// The guard holds a shared borrow; drop it when done.");
            builder.line(&format!("pub fn downcast_ref<T: 'static>(&mut self) -> Option<azul_core::refany::Ref<'_, T>> {{"));
            builder.indent();
            builder.line("use core::mem::transmute;");
            builder.line("unsafe {");
            builder.indent();
            builder.line("let core_ref: &mut azul_core::refany::RefAny = transmute(self);");
            builder.line("core_ref.downcast_ref::<T>()");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
            
            // downcast_mut<T> - using guards, must return wrapped type
            builder.line("/// Returns a RAII guard to mutably borrow the inner value if types match.");
            builder.line("/// ");
            builder.line("/// The guard holds an exclusive borrow; drop it when done.");
            builder.line(&format!("pub fn downcast_mut<T: 'static>(&mut self) -> Option<azul_core::refany::RefMut<'_, T>> {{"));
            builder.indent();
            builder.line("use core::mem::transmute;");
            builder.line("unsafe {");
            builder.indent();
            builder.line("let core_ref: &mut azul_core::refany::RefAny = transmute(self);");
            builder.line("core_ref.downcast_mut::<T>()");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
        
        // String conversions - implement From<&str> and From<String> for AzString
        // Only generate for bindings (static-link or dynamic-link), NOT for DLL build
        // DLL build has no_mangle=true and doesn't need these user-facing conversions
        let is_dll_build = matches!(
            &config.cabi_functions,
            CAbiFunctionMode::InternalBindings { no_mangle: true }
        );
        
        if !is_dll_build {
            // For bindings, use the C-ABI function AzString_copyFromBytes
            builder.line(&format!("impl From<&str> for {}String {{", prefix));
            builder.indent();
            builder.line("fn from(s: &str) -> Self {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}String_copyFromBytes(s.as_ptr(), 0, s.len()) }}", prefix));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
            
            builder.line(&format!("impl From<alloc::string::String> for {}String {{", prefix));
            builder.indent();
            builder.line("fn from(s: alloc::string::String) -> Self {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}String_copyFromBytes(s.as_ptr(), 0, s.len()) }}", prefix));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
        
        Ok(builder.finish())
    }

    /// Generate impl blocks with methods for each type
    fn generate_impl_blocks(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        use std::collections::BTreeSet;
        
        let mut builder = CodeBuilder::new(&config.indent);
        
        // Collect all unique class names
        let class_names: BTreeSet<&str> = ir.functions.iter()
            .filter(|f| !f.kind.is_trait_function()) // Skip trait functions
            .map(|f| f.class_name.as_str())
            .collect();
        
        for class_name in class_names {
            if !config.should_include_type(class_name) {
                continue;
            }
            
            let prefixed_name = config.apply_prefix(class_name);
            let methods: Vec<_> = ir.functions_for_class(class_name)
                .filter(|f| !f.kind.is_trait_function())
                .collect();
            
            if methods.is_empty() {
                continue;
            }
            
            builder.line(&format!("impl {} {{", prefixed_name));
            builder.indent();
            
            for func in methods {
                self.generate_method(&mut builder, func, ir, config);
            }
            
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
        
        Ok(builder.finish())
    }

    /// Generate a single method within an impl block
    fn generate_method(
        &self,
        builder: &mut CodeBuilder,
        func: &FunctionDef,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        let method_name = escape_rust_keyword(&to_snake_case(&func.method_name));
        
        // Types that should use Into<T> for ergonomic API
        // Currently only AzString, but designed to be extended
        let into_types: &[&str] = &["String"];
        
        // Build a map of callback wrapper types for quick lookup
        // Maps: "IFrameCallback" -> ("IFrameCallbackType", "cb", "ctx")
        let callback_wrappers: std::collections::HashMap<&str, (&str, &str, &str)> = ir.structs.iter()
            .filter_map(|s| {
                s.callback_wrapper_info.as_ref().map(|info| {
                    (s.name.as_str(), (
                        info.callback_typedef_name.as_str(), 
                        info.callback_field_name.as_str(),
                        info.context_field_name.as_str(),
                    ))
                })
            })
            .collect();
        
        // Build argument list
        let mut args = Vec::new();
        let mut call_args = Vec::new();
        let mut self_arg: Option<String> = None;
        let mut generic_params: Vec<String> = Vec::new();
        let mut generic_counter = 0u8;
        
        // The lowercase class name is used as the self parameter name in C-ABI
        let self_param_name = func.class_name.to_lowercase();
        
        for arg in &func.args {
            // An argument is "self" if:
            // 1. Its name is "self", OR
            // 2. Its name is the lowercase class name AND its type matches the class name, OR
            // 3. Its name is "object" AND its type matches the class name
            let is_self = arg.name == "self" || 
                         (arg.name == self_param_name && arg.type_name == func.class_name) ||
                         (arg.name == "object" && arg.type_name == func.class_name);
            
            if is_self {
                // Store self argument to insert at the beginning
                let self_str = match arg.ref_kind {
                    ArgRefKind::Owned => "self".to_string(),
                    ArgRefKind::Ref | ArgRefKind::Ptr => "&self".to_string(),
                    ArgRefKind::RefMut | ArgRefKind::PtrMut => "&mut self".to_string(),
                };
                self_arg = Some(self_str);
                call_args.push("self".to_string());
            } else {
                let arg_type = config.apply_prefix(&arg.type_name);
                
                // Check if this type is a callback wrapper
                // If so, accept the CallbackType (fn pointer) and build the wrapper in the call
                // BUT: Don't apply this transformation when we're in a method of the callback wrapper itself
                // (e.g., deep_copy on IFrameCallback should take &IFrameCallback, not IFrameCallbackType)
                let is_method_of_this_callback = arg.type_name == func.class_name;
                
                if !is_method_of_this_callback {
                    if let Some((callback_type_name, callback_field_name, context_field_name)) = callback_wrappers.get(arg.type_name.as_str()) {
                        let fn_ptr_type = config.apply_prefix(callback_type_name);
                        let wrapper_type = &arg_type;
                        args.push(format!("{}: {}", arg.name, fn_ptr_type));
                        // Build the wrapper: AzIFrameCallback { cb: callback, ctx: AzOptionRefAny::None }
                        call_args.push(format!(
                            "{} {{ {}: {}, {}: {}OptionRefAny::None }}",
                            wrapper_type,
                            callback_field_name,
                            arg.name,
                            context_field_name,
                            config.type_prefix
                        ));
                        continue;
                    }
                }
                
                // Check if this type should use Into<T>
                let use_into = into_types.iter().any(|t| config.apply_prefix(t) == arg_type);
                
                if use_into && matches!(arg.ref_kind, ArgRefKind::Owned) {
                    // Use a generic parameter like I0, I1, I2...
                    let generic_name = format!("I{}", generic_counter);
                    generic_counter += 1;
                    generic_params.push(format!("{}: Into<{}>", generic_name, arg_type));
                    args.push(format!("{}: {}", arg.name, generic_name));
                    call_args.push(format!("{}.into()", arg.name));
                } else {
                    let arg_str = match arg.ref_kind {
                        ArgRefKind::Owned => format!("{}: {}", arg.name, arg_type),
                        ArgRefKind::Ref | ArgRefKind::Ptr => format!("{}: &{}", arg.name, arg_type),
                        ArgRefKind::RefMut | ArgRefKind::PtrMut => format!("{}: &mut {}", arg.name, arg_type),
                    };
                    args.push(arg_str);
                    call_args.push(arg.name.clone());
                }
            }
        }
        
        // Insert self at the beginning if present
        if let Some(self_str) = self_arg {
            args.insert(0, self_str);
        }
        
        let return_type = func.return_type.as_ref()
            .map(|r| format!(" -> {}", config.apply_prefix(r)))
            .unwrap_or_default();
        
        let c_func_name = &func.c_name;
        
        // Build generics string if we have any generic parameters
        let generics = if generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", generic_params.join(", "))
        };
        
        // Generate the method
        builder.line(&format!(
            "pub fn {}{}({}){} {{ unsafe {{ {}({}) }} }}",
            method_name,
            generics,
            args.join(", "),
            return_type,
            c_func_name,
            call_args.join(", ")
        ));
    }
}

// ============================================================================
// Helper Methods - Type Aliases
// ============================================================================

impl RustGenerator {
    fn generate_gl_type_aliases(&self, builder: &mut CodeBuilder) {
        // GL type aliases as seen in the existing dll_api.rs
        builder.line("pub type GLenum = u32;");
        builder.line("pub type GLboolean = u8;");
        builder.line("pub type GLbitfield = u32;");
        builder.line("pub type GLbyte = i8;");
        builder.line("pub type GLshort = i16;");
        builder.line("pub type GLint = i32;");
        builder.line("pub type GLsizei = i32;");
        builder.line("pub type GLubyte = u8;");
        builder.line("pub type GLushort = u16;");
        builder.line("pub type GLuint = u32;");
        builder.line("pub type GLfloat = f32;");
        builder.line("pub type GLclampf = f32;");
        builder.line("pub type GLdouble = f64;");
        builder.line("pub type GLclampd = f64;");
        builder.line("pub type GLintptr = isize;");
        builder.line("pub type GLsizeiptr = isize;");
        builder.line("pub type GLint64 = i64;");
        builder.line("pub type GLuint64 = u64;");
    }

    fn generate_primitive_aliases(&self, builder: &mut CodeBuilder) {
        // c_void is already imported via `use core::ffi::c_void;`
        // so we don't need to define it as a type alias
    }

    fn generate_reexports(&self, builder: &mut CodeBuilder, inner_module: &str) {
        builder.line(&format!("pub use {}::dll::*;", inner_module));
    }

    /// Generate simple Rust API without module wrappers
    /// Used for rust_public_api which generates flat type definitions
    fn generate_simple_rust_api(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // File header
        builder.line("// Auto-generated by azul-doc codegen v2");
        builder.line("// DO NOT EDIT MANUALLY");
        builder.blank();

        // Imports
        for import in &config.imports {
            builder.line(import);
        }
        if !config.imports.is_empty() {
            builder.blank();
        }

        // GL type aliases
        builder.line("// --- GL Type Aliases ---");
        self.generate_gl_type_aliases(&mut builder);
        builder.blank();

        // Type definitions
        if config.struct_mode != StructMode::None {
            builder.line("// --- Type Definitions ---");
            let types = self.generate_types(ir, config)?;
            builder.raw(&types);
        }

        // Trait implementations (if using derive, they're already on types)
        if !matches!(config.trait_impl_mode, TraitImplMode::UsingDerive) {
            builder.line("// --- Trait Implementations ---");
            let trait_impls = self.generate_trait_impls(ir, config)?;
            builder.raw(&trait_impls);
        }

        // Method implementations (impl blocks)
        builder.line("// --- Method Implementations ---");
        let impl_blocks = self.generate_impl_blocks(ir, config)?;
        builder.raw(&impl_blocks);

        // Rust-only generic methods (not part of C-ABI)
        builder.line("// --- Rust-Only Generic Methods ---");
        let rust_only = self.generate_rust_only_impls(config)?;
        builder.raw(&rust_only);

        Ok(builder.finish())
    }
}

// ============================================================================
// Type Generation
// ============================================================================

impl RustGenerator {
    fn generate_type_alias(
        &self,
        builder: &mut CodeBuilder,
        type_alias: &TypeAliasDef,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&type_alias.name);
        
        // Target types should also be prefixed if they're not primitives
        let target_base = if is_primitive_type(&type_alias.target) || type_alias.target.contains("::") {
            type_alias.target.clone()
        } else {
            config.apply_prefix(&type_alias.target)
        };
        
        // Build the full target type including generic arguments
        let target = if type_alias.generic_args.is_empty() {
            target_base
        } else {
            // Apply prefix to each generic argument
            let prefixed_args: Vec<String> = type_alias.generic_args.iter()
                .map(|arg| {
                    if is_primitive_type(arg) || arg.contains("::") {
                        arg.clone()
                    } else {
                        config.apply_prefix(arg)
                    }
                })
                .collect();
            format!("{}<{}>", target_base, prefixed_args.join(", "))
        };
        
        builder.line(&format!("pub type {} = {};", name, target));
        builder.blank();
    }

    fn generate_callback_typedef(
        &self,
        builder: &mut CodeBuilder,
        callback: &CallbackTypedefDef,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&callback.name);

        if config.callback_typedef_use_external {
            if let Some(ref external) = callback.external_path {
                builder.line(&format!("pub type {} = {};", name, external));
                builder.blank();
                return;
            }
        }

        // Generate function pointer signature
        // Note: For type aliases, we only need types, not names: fn(Type1, Type2) -> Return
        let args: Vec<String> = callback.args.iter().map(|arg| {
            let type_name = config.apply_prefix(&arg.type_name);
            let ref_prefix = match arg.ref_kind {
                ArgRefKind::Owned => "",
                ArgRefKind::Ref => "&",
                ArgRefKind::RefMut => "&mut ",
                ArgRefKind::Ptr => "*const ",
                ArgRefKind::PtrMut => "*mut ",
            };
            format!("{}{}", ref_prefix, type_name)
        }).collect();
        
        let return_str = callback.return_type.as_ref()
            .map(|r| format!(" -> {}", config.apply_prefix(r)))
            .unwrap_or_default();

        builder.line(&format!(
            "pub type {} = extern \"C\" fn({}){};",
            name,
            args.join(", "),
            return_str
        ));
        builder.blank();
    }

    fn generate_struct(
        &self,
        builder: &mut CodeBuilder,
        struct_def: &StructDef,
        _ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&struct_def.name);
        
        // Add generic parameters if present
        let generics = if struct_def.generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", struct_def.generic_params.join(", "))
        };
        let full_name = format!("{}{}", name, generics);

        // Doc comment
        if !struct_def.doc.is_empty() {
            for doc_line in &struct_def.doc {
                builder.line(&format!("/// {}", doc_line));
            }
        } else {
            builder.line(&format!("/// `{}` struct", name));
        }

        // Repr attribute
        if let Some(ref repr) = struct_def.repr {
            builder.line(&format!("#[repr({})]", repr));
        } else {
            builder.line("#[repr(C)]");
        }

        // Struct definition
        if struct_def.fields.is_empty() {
            builder.line(&format!("pub struct {};", full_name));
        } else {
            builder.line(&format!("pub struct {} {{", full_name));
            builder.indent();
            for field in &struct_def.fields {
                let field_type = self.format_field_type(&field.type_name, &field.ref_kind, config);
                let visibility = if field.is_public { "pub " } else { "pub(crate) " };
                builder.line(&format!("{}{}: {},", visibility, field.name, field_type));
            }
            builder.dedent();
            builder.line("}");
        }
        builder.blank();
    }

    fn generate_enum(
        &self,
        builder: &mut CodeBuilder,
        enum_def: &EnumDef,
        _ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&enum_def.name);
        
        // Add generic parameters if present
        let generics = if enum_def.generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", enum_def.generic_params.join(", "))
        };
        let full_name = format!("{}{}", name, generics);

        // Doc comment
        if !enum_def.doc.is_empty() {
            for doc_line in &enum_def.doc {
                builder.line(&format!("/// {}", doc_line));
            }
        } else {
            builder.line(&format!("/// `{}` struct", name));
        }

        // Repr attribute - automatically determine based on whether enum has variant data
        // Enums with variant data (tagged unions) need repr(C, u8) for proper C ABI
        // We ignore api.json "repr" field for enums - it's always implicitly calculable
        if enum_def.is_union {
            builder.line("#[repr(C, u8)]");
        } else {
            builder.line("#[repr(C)]");
        }

        // Enum definition
        builder.line(&format!("pub enum {} {{", full_name));
        builder.indent();
        for variant in &enum_def.variants {
            match &variant.kind {
                EnumVariantKind::Unit => {
                    builder.line(&format!("{},", variant.name));
                }
                EnumVariantKind::Tuple(types) => {
                    let types_str: Vec<String> = types.iter()
                        .map(|t| config.apply_prefix(t))
                        .collect();
                    builder.line(&format!("{}({}),", variant.name, types_str.join(", ")));
                }
                EnumVariantKind::Struct(fields) => {
                    builder.line(&format!("{} {{", variant.name));
                    builder.indent();
                    for field in fields {
                        let field_type = config.apply_prefix(&field.type_name);
                        builder.line(&format!("{}: {},", field.name, field_type));
                    }
                    builder.dedent();
                    builder.line("},");
                }
            }
        }
        builder.dedent();
        builder.line("}");
        builder.blank();
    }

    fn format_field_type(&self, type_name: &str, ref_kind: &FieldRefKind, config: &CodegenConfig) -> String {
        let prefixed = config.apply_prefix(type_name);
        match ref_kind {
            FieldRefKind::Owned => prefixed,
            FieldRefKind::Ref => format!("&{}", prefixed),
            FieldRefKind::RefMut => format!("&mut {}", prefixed),
            FieldRefKind::Ptr => format!("*const {}", prefixed),
            FieldRefKind::PtrMut => format!("*mut {}", prefixed),
            FieldRefKind::Boxed => format!("Box<{}>", prefixed),
            FieldRefKind::OptionBoxed => format!("Option<Box<{}>>", prefixed),
        }
    }
}

// ============================================================================
// Trait Implementation Generation - Using Transmute
// ============================================================================

impl RustGenerator {
    fn generate_transmute_trait_impls(
        &self,
        builder: &mut CodeBuilder,
        struct_def: &StructDef,
        config: &CodegenConfig,
        _external_crate: &str,
    ) {
        let name = config.apply_prefix(&struct_def.name);
        
        // Build generics string: "<T>" or "<T, U>" etc.
        let generics = if struct_def.generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", struct_def.generic_params.join(", "))
        };
        
        // Build impl generics: "impl<T>" or "impl<T: Clone>"
        let impl_generics = if struct_def.generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", struct_def.generic_params.join(", "))
        };
        
        let full_name = format!("{}{}", name, generics);
        
        let external_path = struct_def.external_path.as_ref()
            .map(|p| config.transform_external_path(p))
            .unwrap_or_else(|| format!("crate::{}", struct_def.name));

        // Clone impl - generate for:
        // 1. Types with is_clone trait explicitly set
        // 2. Types with external_path (can clone via transmute to external type)
        // Skip for generic types (can't transmute dependent-sized types)
        let should_gen_clone = struct_def.generic_params.is_empty() 
            && (struct_def.traits.is_clone || struct_def.external_path.is_some());
        
        if should_gen_clone {
            builder.line(&format!("impl Clone for {} {{", full_name));
            builder.indent();
            builder.line("fn clone(&self) -> Self {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ core::mem::transmute::<{}, {}>((*(self as *const {} as *const {})).clone()) }}",
                external_path, full_name, full_name, external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Debug impl - skip for generic types
        if struct_def.generic_params.is_empty() {
            builder.line(&format!("impl core::fmt::Debug for {} {{", full_name));
            builder.indent();
            builder.line("fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {");
            builder.indent();
            builder.line(&format!("f.debug_struct(\"{}\").finish()", name));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Default impl (if has_default) - skip for generic types
        if struct_def.traits.is_default && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl Default for {} {{", full_name));
            builder.indent();
            builder.line("fn default() -> Self {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ core::mem::transmute::<{}, {}>({}::default()) }}",
                external_path, full_name, external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // PartialEq impl - using byte comparison via transmute
        // Skip for generic types - size_of::<Self>() doesn't work in const context for generics
        if struct_def.traits.is_partial_eq && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl PartialEq for {} {{", full_name));
            builder.indent();
            builder.line("fn eq(&self, other: &Self) -> bool {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self) == core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Eq impl
        // Skip for generic types
        if struct_def.traits.is_eq && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl Eq for {} {{ }}", full_name));
            builder.blank();
        }

        // PartialOrd impl
        // Skip for generic types
        if struct_def.traits.is_partial_ord && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl PartialOrd for {} {{", full_name));
            builder.indent();
            builder.line("fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {");
            builder.indent();
            builder.line("Some(unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).cmp(core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other)) })");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Ord impl
        // Skip for generic types
        if struct_def.traits.is_ord && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl Ord for {} {{", full_name));
            builder.indent();
            builder.line("fn cmp(&self, other: &Self) -> core::cmp::Ordering {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).cmp(core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other)) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Hash impl
        // Skip for generic types
        if struct_def.traits.is_hash && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl core::hash::Hash for {} {{", full_name));
            builder.indent();
            builder.line("fn hash<H: core::hash::Hasher>(&self, state: &mut H) {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).hash(state) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }

    fn generate_transmute_trait_impls_enum(
        &self,
        builder: &mut CodeBuilder,
        enum_def: &EnumDef,
        config: &CodegenConfig,
        _external_crate: &str,
    ) {
        // Skip generic enums entirely - can't transmute dependent-sized types
        if !enum_def.generic_params.is_empty() {
            return;
        }
        
        let name = config.apply_prefix(&enum_def.name);
        let full_name = name.clone(); // No generics since we skip generic enums
        
        let external_path = enum_def.external_path.as_ref()
            .map(|p| config.transform_external_path(p))
            .unwrap_or_else(|| format!("crate::{}", enum_def.name));

        // Clone impl - generate for:
        // 1. Types with is_clone trait explicitly set
        // 2. Types with external_path (can clone via transmute to external type)
        let should_gen_clone = enum_def.traits.is_clone || enum_def.external_path.is_some();
        
        if should_gen_clone {
            builder.line(&format!("impl Clone for {} {{", full_name));
            builder.indent();
            builder.line("fn clone(&self) -> Self {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ core::mem::transmute::<{}, {}>((*(self as *const {} as *const {})).clone()) }}",
                external_path, full_name, full_name, external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Debug impl
        builder.line(&format!("impl core::fmt::Debug for {} {{", full_name));
        builder.indent();
        builder.line("fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {");
        builder.indent();
        builder.line(&format!("f.debug_struct(\"{}\").finish()", name));
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // PartialEq impl
        // Skip for generic types - size_of::<Self>() doesn't work in const context for generics
        if enum_def.traits.is_partial_eq && enum_def.generic_params.is_empty() {
            builder.line(&format!("impl PartialEq for {} {{", full_name));
            builder.indent();
            builder.line("fn eq(&self, other: &Self) -> bool {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self) == core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Eq impl - Skip for generic types
        if enum_def.traits.is_eq && enum_def.generic_params.is_empty() {
            builder.line(&format!("impl Eq for {} {{ }}", full_name));
            builder.blank();
        }

        // PartialOrd impl - Skip for generic types
        if enum_def.traits.is_partial_ord && enum_def.generic_params.is_empty() {
            builder.line(&format!("impl PartialOrd for {} {{", full_name));
            builder.indent();
            builder.line("fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {");
            builder.indent();
            builder.line("Some(unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).cmp(core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other)) })");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Ord impl - Skip for generic types
        if enum_def.traits.is_ord && enum_def.generic_params.is_empty() {
            builder.line(&format!("impl Ord for {} {{", full_name));
            builder.indent();
            builder.line("fn cmp(&self, other: &Self) -> core::cmp::Ordering {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).cmp(core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other)) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Hash impl - Skip for generic types
        if enum_def.traits.is_hash && enum_def.generic_params.is_empty() {
            builder.line(&format!("impl core::hash::Hash for {} {{", full_name));
            builder.indent();
            builder.line("fn hash<H: core::hash::Hasher>(&self, state: &mut H) {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).hash(state) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }
}

// ============================================================================
// Trait Implementation Generation - Using C-ABI
// ============================================================================

impl RustGenerator {
    fn generate_capi_trait_impls(
        &self,
        builder: &mut CodeBuilder,
        struct_def: &StructDef,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&struct_def.name);

        // Clone impl calling C-ABI function
        if struct_def.traits.is_clone && !struct_def.traits.is_copy {
            let deep_copy_fn = format!("{}_deepCopy", name);
            builder.line(&format!("impl Clone for {} {{", name));
            builder.indent();
            builder.line("fn clone(&self) -> Self {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self) }}", deep_copy_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Drop impl calling C-ABI function
        if struct_def.traits.needs_delete() {
            let delete_fn = format!("{}_delete", name);
            builder.line(&format!("impl Drop for {} {{", name));
            builder.indent();
            builder.line("fn drop(&mut self) {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self) }}", delete_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }

    fn generate_capi_trait_impls_enum(
        &self,
        builder: &mut CodeBuilder,
        enum_def: &EnumDef,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&enum_def.name);

        // Clone impl calling C-ABI function
        if enum_def.traits.is_clone && !enum_def.traits.is_copy {
            let deep_copy_fn = format!("{}_deepCopy", name);
            builder.line(&format!("impl Clone for {} {{", name));
            builder.indent();
            builder.line("fn clone(&self) -> Self {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self) }}", deep_copy_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Drop impl calling C-ABI function
        if enum_def.traits.needs_delete() {
            let delete_fn = format!("{}_delete", name);
            builder.line(&format!("impl Drop for {} {{", name));
            builder.indent();
            builder.line("fn drop(&mut self) {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self) }}", delete_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }
}

// ============================================================================
// Function Generation
// ============================================================================

impl RustGenerator {
    fn generate_function_definition(
        &self,
        builder: &mut CodeBuilder,
        func: &FunctionDef,
        ir: &CodegenIR,
        config: &CodegenConfig,
        no_mangle: bool,
    ) {
        // Attributes
        builder.line("#[allow(unused_variables)]");
        if no_mangle {
            builder.line("#[no_mangle]");
        }

        let args = self.format_function_args(func, config);
        let return_str = func.return_type.as_ref()
            .map(|r| format!(" -> {}", config.apply_prefix(r)))
            .unwrap_or_default();

        let body = self.generate_function_body(func, ir, config);
        
        // Single-line or multi-line based on body
        builder.line(&format!(
            "pub unsafe extern \"C\" fn {}({}){} {}",
            func.c_name,
            args,
            return_str,
            body
        ));
    }

    fn generate_function_body(
        &self,
        func: &FunctionDef,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) -> String {
        let prefixed_name = config.apply_prefix(&func.class_name);
        
        // Get external path for this type, transforming if needed
        let external_path = ir.type_to_external.get(&func.class_name)
            .map(|p| config.transform_external_path(p))
            .unwrap_or_else(|| format!("crate::{}", func.class_name));

        // Generate body based on function kind
        match func.kind {
            FunctionKind::Delete => {
                // For delete, we call drop_in_place to run the destructor.
                // The type is passed by pointer, so we need to dereference and drop it.
                // This works for both stack-allocated (repr(C)) and heap-allocated types.
                let arg_name = func.args.first().map(|a| a.name.as_str()).unwrap_or("instance");
                format!("{{ core::ptr::drop_in_place({} as *mut {} as *mut {}); }}", 
                    arg_name, prefixed_name, external_path)
            }
            FunctionKind::DeepCopy => {
                let arg_name = func.args.first().map(|a| a.name.as_str()).unwrap_or("object");
                format!(
                    "{{ core::mem::transmute::<{}, {}>((*({}  as *const {} as *const {})).clone()) }}",
                    external_path, prefixed_name, arg_name, prefixed_name, external_path
                )
            }
            FunctionKind::PartialEq => {
                format!(
                    "{{ (*(a as *const {} as *const {})) == (*(b as *const {} as *const {})) }}",
                    prefixed_name, external_path, prefixed_name, external_path
                )
            }
            FunctionKind::PartialCmp => {
                format!(
                    "{{ match (*(a as *const {} as *const {})).partial_cmp(&*(b as *const {} as *const {})) {{
        Some(core::cmp::Ordering::Less) => 0,
        Some(core::cmp::Ordering::Equal) => 1,
        Some(core::cmp::Ordering::Greater) => 2,
        None => 255,
    }} }}",
                    prefixed_name, external_path, prefixed_name, external_path
                )
            }
            FunctionKind::Cmp => {
                format!(
                    "{{ match (*(a as *const {} as *const {})).cmp(&*(b as *const {} as *const {})) {{
        core::cmp::Ordering::Less => 0,
        core::cmp::Ordering::Equal => 1,
        core::cmp::Ordering::Greater => 2,
    }} }}",
                    prefixed_name, external_path, prefixed_name, external_path
                )
            }
            FunctionKind::Hash => {
                let arg_name = func.args.first().map(|a| a.name.as_str()).unwrap_or("object");
                format!(
                    "{{ {{
        use core::hash::{{Hash, Hasher}};
        let mut hasher = std::collections::hash_map::DefaultHasher::new();
        (*({} as *const {} as *const {})).hash(&mut hasher);
        hasher.finish()
    }} }}",
                    arg_name, prefixed_name, external_path
                )
            }
            FunctionKind::Default => {
                format!(
                    "{{ core::mem::transmute::<{}, {}>({}::default()) }}",
                    external_path, prefixed_name, external_path
                )
            }
            FunctionKind::Constructor | FunctionKind::StaticMethod |
            FunctionKind::Method | FunctionKind::MethodMut |
            FunctionKind::EnumVariantConstructor => {
                // For regular API functions, use the fn_body from api.json 
                // and transform it using generate_transmuted_fn_body
                if let Some(ref body) = func.fn_body {
                    // Build the type_to_external map for this function
                    let type_to_external: std::collections::BTreeMap<String, String> = 
                        ir.type_to_external.iter()
                            .map(|(k, v)| (config.apply_prefix(k), v.clone()))
                            .collect();
                    
                    // Format fn_args as the old generator expects: "arg1: Type1, arg2: Type2"
                    let fn_args = self.format_function_args(func, config);
                    
                    // Determine return type with prefix
                    let return_type = func.return_type.as_ref()
                        .map(|r| config.apply_prefix(r))
                        .unwrap_or_default();
                    
                    // Use the existing transmuted fn_body generator
                    // EnumVariantConstructor counts as a constructor for fn_body transformation
                    let is_constructor = matches!(
                        func.kind,
                        FunctionKind::Constructor | FunctionKind::StaticMethod | FunctionKind::EnumVariantConstructor
                    );
                    generate_transmuted_fn_body(
                        body,
                        &func.class_name,
                        is_constructor,
                        &return_type,
                        &config.type_prefix,
                        &type_to_external,
                        &fn_args,
                        true, // is_for_dll
                        false, // keep_self_name
                        false, // force_clone_self
                        &BTreeSet::new(), // skip_args
                    )
                } else {
                    // No fn_body - generate error or stub
                    format!("{{ /* ERROR: No fn_body for {} */ unimplemented!() }}", func.c_name)
                }
            }
        }
    }

    fn generate_method_body(
        &self,
        func: &FunctionDef,
        ir: &CodegenIR,
        config: &CodegenConfig,
        external_path: &str,
        prefixed_name: &str,
    ) -> String {
        // Generate transmute calls for each argument
        let mut lines = Vec::new();
        lines.push("{".to_string());

        // Get the self argument name if this is a method
        let self_arg_name = match func.kind {
            FunctionKind::Method | FunctionKind::MethodMut => {
                func.args.first().map(|a| a.name.clone())
            }
            _ => None,
        };

        // Transmute each argument
        for arg in &func.args {
            let ext_type = ir.type_to_external.get(&arg.type_name)
                .cloned()
                .unwrap_or_else(|| {
                    // For primitive types, just use the type directly
                    if is_primitive_type(&arg.type_name) {
                        arg.type_name.clone()
                    } else {
                        format!("crate::{}", arg.type_name)
                    }
                });

            let transmute_expr = match arg.ref_kind {
                ArgRefKind::Ref => format!(
                    "    let {}: &{} = core::mem::transmute({});",
                    arg.name, ext_type, arg.name
                ),
                ArgRefKind::RefMut => format!(
                    "    let {}: &mut {} = core::mem::transmute({});",
                    arg.name, ext_type, arg.name
                ),
                ArgRefKind::Owned => {
                    if is_primitive_type(&arg.type_name) {
                        format!("    let {}: {} = {};", arg.name, ext_type, arg.name)
                    } else {
                        format!(
                            "    let {}: {} = core::mem::transmute({});",
                            arg.name, ext_type, arg.name
                        )
                    }
                }
                ArgRefKind::Ptr | ArgRefKind::PtrMut => format!(
                    "    let {}: {} = core::mem::transmute({});",
                    arg.name, ext_type, arg.name
                ),
            };
            lines.push(transmute_expr);
        }

        // Generate the call
        let args_for_call: Vec<String> = func.args.iter()
            .skip(if self_arg_name.is_some() { 1 } else { 0 })
            .map(|a| a.name.clone())
            .collect();

        let call = if let Some(ref self_name) = self_arg_name {
            // Instance method call
            format!("    let __result = {}.{}({});", self_name, func.method_name, args_for_call.join(", "))
        } else {
            // Static method or constructor
            format!("    let __result: {} = {}::{}({});", 
                external_path, external_path, func.method_name, args_for_call.join(", "))
        };
        lines.push(call);

        // Transmute result back if needed
        if let Some(ref ret_type) = func.return_type {
            let ret_prefixed = config.apply_prefix(ret_type);
            let ret_external = ir.type_to_external.get(ret_type)
                .cloned()
                .unwrap_or_else(|| {
                    if is_primitive_type(ret_type) {
                        ret_type.clone()
                    } else {
                        format!("crate::{}", ret_type)
                    }
                });
            if is_primitive_type(ret_type) {
                lines.push("    __result".to_string());
            } else {
                lines.push(format!("    core::mem::transmute::<{}, {}>(__result)", ret_external, ret_prefixed));
            }
        } else {
            // No return, discard result
            lines.push("    let _ = __result;".to_string());
        }

        lines.push("}".to_string());
        lines.join("\n")
    }

    fn generate_function_declaration(
        &self,
        builder: &mut CodeBuilder,
        func: &FunctionDef,
        config: &CodegenConfig,
    ) {
        let args = self.format_function_args(func, config);
        let return_str = func.return_type.as_ref()
            .map(|r| format!(" -> {}", config.apply_prefix(r)))
            .unwrap_or_default();

        builder.line(&format!("pub fn {}({}){};", func.c_name, args, return_str));
    }

    fn format_function_args(&self, func: &FunctionDef, config: &CodegenConfig) -> String {
        func.args.iter().map(|arg| {
            let type_name = config.apply_prefix(&arg.type_name);
            let formatted = match arg.ref_kind {
                ArgRefKind::Owned => type_name,
                ArgRefKind::Ref => format!("&{}", type_name),
                ArgRefKind::RefMut => format!("&mut {}", type_name),
                ArgRefKind::Ptr => format!("*const {}", type_name),
                ArgRefKind::PtrMut => format!("*mut {}", type_name),
            };
            format!("{}: {}", arg.name, formatted)
        }).collect::<Vec<_>>().join(", ")
    }

    /// Generate test module with size/alignment verification tests
    fn generate_tests(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        builder.line("#[cfg(test)]");
        builder.line("mod generated_tests {");
        builder.indent();
        builder.line("use super::*;");
        builder.line("use super::__dll_api_inner::dll;");
        builder.line("use core::mem;");
        builder.blank();

        // Generate size/alignment tests for each struct
        for struct_def in &ir.structs {
            if !config.should_include_type(&struct_def.name) {
                continue;
            }
            // Skip generic types - can't test size at compile time
            if !struct_def.generic_params.is_empty() {
                continue;
            }
            // Need external_path to compare sizes
            let Some(external_path) = &struct_def.external_path else {
                continue;
            };
            
            // Skip if external path contains generic parameters (like <T>)
            if external_path.contains('<') {
                continue;
            }
            
            let external_path = config.transform_external_path(external_path);
            let generated_type = format!("dll::Az{}", struct_def.name);
            let test_name = format!("test_size_align_{}", struct_def.name.to_lowercase());

            builder.line("#[test]");
            builder.line(&format!("fn {}() {{", test_name));
            builder.indent();
            builder.line(&format!("let gen_size = mem::size_of::<{}>();", generated_type));
            builder.line(&format!("let ext_size = mem::size_of::<{}>();", external_path));
            builder.line(&format!("let gen_align = mem::align_of::<{}>();", generated_type));
            builder.line(&format!("let ext_align = mem::align_of::<{}>();", external_path));
            builder.line(&format!("assert_eq!(gen_size, ext_size, \"Size mismatch for {}\");", struct_def.name));
            builder.line(&format!("assert_eq!(gen_align, ext_align, \"Align mismatch for {}\");", struct_def.name));
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Generate size/alignment tests for each enum
        for enum_def in &ir.enums {
            if !config.should_include_type(&enum_def.name) {
                continue;
            }
            // Skip generic types - can't test size at compile time
            if !enum_def.generic_params.is_empty() {
                continue;
            }
            // Need external_path to compare sizes
            let Some(external_path) = &enum_def.external_path else {
                continue;
            };
            
            // Skip if external path contains generic parameters (like <T>)
            if external_path.contains('<') {
                continue;
            }
            
            let external_path = config.transform_external_path(external_path);
            let generated_type = format!("dll::Az{}", enum_def.name);
            let test_name = format!("test_size_align_{}", enum_def.name.to_lowercase());

            builder.line("#[test]");
            builder.line(&format!("fn {}() {{", test_name));
            builder.indent();
            builder.line(&format!("let gen_size = mem::size_of::<{}>();", generated_type));
            builder.line(&format!("let ext_size = mem::size_of::<{}>();", external_path));
            builder.line(&format!("let gen_align = mem::align_of::<{}>();", generated_type));
            builder.line(&format!("let ext_align = mem::align_of::<{}>();", external_path));
            builder.line(&format!("assert_eq!(gen_size, ext_size, \"Size mismatch for {}\");", enum_def.name));
            builder.line(&format!("assert_eq!(gen_align, ext_align, \"Align mismatch for {}\");", enum_def.name));
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        builder.dedent();
        builder.line("} // mod generated_tests");

        Ok(builder.finish())
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

fn is_primitive_type(type_name: &str) -> bool {
    matches!(type_name, 
        "bool" | "i8" | "i16" | "i32" | "i64" | "i128" | "isize" |
        "u8" | "u16" | "u32" | "u64" | "u128" | "usize" |
        "f32" | "f64" | "char" | "()" |
        "c_void"
        // NOTE: "String" is NOT a primitive - it's AzString in Azul, not std::string::String
    )
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }
    result
}

/// Escape Rust keywords by prepending r#
fn escape_rust_keyword(s: &str) -> String {
    const RUST_KEYWORDS: &[&str] = &[
        "as", "async", "await", "break", "const", "continue", "crate", "dyn",
        "else", "enum", "extern", "false", "fn", "for", "if", "impl", "in",
        "let", "loop", "match", "mod", "move", "mut", "pub", "ref", "return",
        "self", "Self", "static", "struct", "super", "trait", "true", "type",
        "unsafe", "use", "where", "while", "abstract", "become", "box", "do",
        "final", "macro", "override", "priv", "typeof", "unsized", "virtual",
        "yield", "try",
    ];
    
    if RUST_KEYWORDS.contains(&s) {
        format!("r#{}", s)
    } else {
        s.to_string()
    }
}
