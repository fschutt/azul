//! Rust code generator
//!
//! Generates Rust code from the IR, including:
//! - Struct and enum definitions
//! - C-ABI function definitions or declarations
//! - Trait implementations using transmute

use anyhow::Result;
use std::collections::BTreeSet;

use super::config::*;
use super::generator::{CodeBuilder, LanguageGenerator};
use super::ir::*;
use super::transmute_helpers::{generate_transmuted_fn_body, parse_arg_type};

// ============================================================================
// Rust Generator
// ============================================================================

pub struct RustGenerator;

impl LanguageGenerator for RustGenerator {
    fn generate(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // File header
        builder.line("// Auto-generated by azul-doc codegen v2");
        builder.line("// DO NOT EDIT MANUALLY");
        builder.blank();

        // Check if this is a "simple" config (no module wrapper, no prefix)
        // Used for rust_public_api which generates flat type definitions
        let is_simple_mode = config.module_wrapper.is_none() && config.type_prefix.is_empty();
        
        if is_simple_mode {
            // Simple mode: just generate types directly, no nested modules
            return self.generate_simple_rust_api(ir, config);
        }

        // Generate inner module wrapper (using the same structure as existing dll_api.rs)
        // The structure is: pub mod __dll_api_inner { pub mod dll { ... } }
        builder.line("pub mod __dll_api_inner {");
        builder.indent();
        builder.line("pub mod dll {");
        builder.indent();

        // Imports
        for import in &config.imports {
            builder.line(import);
        }
        if !config.imports.is_empty() {
            builder.blank();
        }

        // GL type aliases first
        builder.line("// --- GL Type Aliases ---");
        self.generate_gl_type_aliases(&mut builder);
        builder.blank();

        // Primitive type aliases
        builder.line("// --- Primitive Type Aliases ---");
        self.generate_primitive_aliases(&mut builder);
        builder.blank();

        // Type definitions (structs and enums)
        if config.struct_mode != StructMode::None {
            builder.line("// --- Type Definitions ---");
            let types = self.generate_types(ir, config)?;
            builder.raw(&types);
        }

        // Trait implementations
        builder.line("// --- Trait Implementations ---");
        let trait_impls = self.generate_trait_impls(ir, config)?;
        builder.raw(&trait_impls);

        // Functions
        builder.line("// --- C-ABI Functions ---");
        let functions = self.generate_functions(ir, config)?;
        builder.raw(&functions);

        // End module wrappers
        builder.dedent();
        builder.line("} // mod dll");
        builder.dedent();
        builder.line("} // mod __dll_api_inner");

        // Re-exports at the end
        builder.blank();
        self.generate_reexports(&mut builder, "__dll_api_inner");

        // Generate tests if enabled
        if config.generate_tests {
            builder.blank();
            let tests = self.generate_tests(ir, config)?;
            builder.raw(&tests);
        }

        Ok(builder.finish())
    }

    fn generate_types(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // Type aliases first
        for type_alias in &ir.type_aliases {
            if !config.should_include_type(&type_alias.name) {
                continue;
            }
            self.generate_type_alias(&mut builder, type_alias, config);
        }

        // Callback typedefs
        for callback in &ir.callback_typedefs {
            if !config.should_include_type(&callback.name) {
                continue;
            }
            self.generate_callback_typedef(&mut builder, callback, config);
        }

        // Structs
        for struct_def in &ir.structs {
            if !config.should_include_type(&struct_def.name) {
                continue;
            }
            self.generate_struct(&mut builder, struct_def, ir, config);
        }

        // Enums
        for enum_def in &ir.enums {
            if !config.should_include_type(&enum_def.name) {
                continue;
            }
            self.generate_enum(&mut builder, enum_def, ir, config);
        }

        Ok(builder.finish())
    }

    fn generate_functions(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // When using transmute-based trait impls, we don't need C-ABI trait functions
        // because traits are implemented directly using transmute, not via C-ABI calls
        let skip_trait_functions = matches!(
            config.trait_impl_mode,
            TraitImplMode::UsingTransmute { .. } | TraitImplMode::UsingDerive
        );

        match &config.cabi_functions {
            CAbiFunctionMode::InternalBindings { no_mangle } => {
                for func in &ir.functions {
                    if !config.should_include_type(&func.class_name) {
                        continue;
                    }
                    // Skip trait functions when using transmute impls
                    if skip_trait_functions && func.kind.is_trait_function() {
                        continue;
                    }
                    self.generate_function_definition(&mut builder, func, ir, config, *no_mangle);
                }
            }
            CAbiFunctionMode::ExternalBindings { link_library } => {
                builder.line(&format!("#[link(name = \"{}\")]", link_library));
                builder.line("extern \"C\" {");
                builder.indent();
                
                for func in &ir.functions {
                    if !config.should_include_type(&func.class_name) {
                        continue;
                    }
                    if skip_trait_functions && func.kind.is_trait_function() {
                        continue;
                    }
                    self.generate_function_declaration(&mut builder, func, config);
                }
                
                builder.dedent();
                builder.line("}");
            }
            CAbiFunctionMode::None => {}
        }

        Ok(builder.finish())
    }

    fn generate_trait_impls(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        match &config.trait_impl_mode {
            TraitImplMode::UsingDerive => {
                // Derives are handled in struct/enum generation
            }
            TraitImplMode::UsingTransmute { external_crate } => {
                // Generate trait impls using transmute
                for struct_def in &ir.structs {
                    if !config.should_include_type(&struct_def.name) {
                        continue;
                    }
                    self.generate_transmute_trait_impls(&mut builder, struct_def, config, external_crate);
                }
                for enum_def in &ir.enums {
                    if !config.should_include_type(&enum_def.name) {
                        continue;
                    }
                    self.generate_transmute_trait_impls_enum(&mut builder, enum_def, config, external_crate);
                }
            }
            TraitImplMode::UsingCAPI => {
                for struct_def in &ir.structs {
                    if !config.should_include_type(&struct_def.name) {
                        continue;
                    }
                    self.generate_capi_trait_impls(&mut builder, struct_def, config);
                }
                for enum_def in &ir.enums {
                    if !config.should_include_type(&enum_def.name) {
                        continue;
                    }
                    self.generate_capi_trait_impls_enum(&mut builder, enum_def, config);
                }
            }
            TraitImplMode::None => {}
        }

        Ok(builder.finish())
    }
}

// ============================================================================
// Helper Methods - Type Aliases
// ============================================================================

impl RustGenerator {
    fn generate_gl_type_aliases(&self, builder: &mut CodeBuilder) {
        // GL type aliases as seen in the existing dll_api.rs
        builder.line("pub type GLenum = u32;");
        builder.line("pub type GLboolean = u8;");
        builder.line("pub type GLbitfield = u32;");
        builder.line("pub type GLbyte = i8;");
        builder.line("pub type GLshort = i16;");
        builder.line("pub type GLint = i32;");
        builder.line("pub type GLsizei = i32;");
        builder.line("pub type GLubyte = u8;");
        builder.line("pub type GLushort = u16;");
        builder.line("pub type GLuint = u32;");
        builder.line("pub type GLfloat = f32;");
        builder.line("pub type GLclampf = f32;");
        builder.line("pub type GLdouble = f64;");
        builder.line("pub type GLclampd = f64;");
        builder.line("pub type GLintptr = isize;");
        builder.line("pub type GLsizeiptr = isize;");
        builder.line("pub type GLint64 = i64;");
        builder.line("pub type GLuint64 = u64;");
    }

    fn generate_primitive_aliases(&self, builder: &mut CodeBuilder) {
        // c_void is already imported via `use core::ffi::c_void;`
        // so we don't need to define it as a type alias
    }

    fn generate_reexports(&self, builder: &mut CodeBuilder, inner_module: &str) {
        builder.line(&format!("pub use {}::dll::*;", inner_module));
    }

    /// Generate simple Rust API without module wrappers
    /// Used for rust_public_api which generates flat type definitions
    fn generate_simple_rust_api(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // File header
        builder.line("// Auto-generated by azul-doc codegen v2");
        builder.line("// DO NOT EDIT MANUALLY");
        builder.blank();

        // Imports
        for import in &config.imports {
            builder.line(import);
        }
        if !config.imports.is_empty() {
            builder.blank();
        }

        // GL type aliases
        builder.line("// --- GL Type Aliases ---");
        self.generate_gl_type_aliases(&mut builder);
        builder.blank();

        // Type definitions
        if config.struct_mode != StructMode::None {
            builder.line("// --- Type Definitions ---");
            let types = self.generate_types(ir, config)?;
            builder.raw(&types);
        }

        // Trait implementations (if using derive, they're already on types)
        if !matches!(config.trait_impl_mode, TraitImplMode::UsingDerive) {
            builder.line("// --- Trait Implementations ---");
            let trait_impls = self.generate_trait_impls(ir, config)?;
            builder.raw(&trait_impls);
        }

        Ok(builder.finish())
    }
}

// ============================================================================
// Type Generation
// ============================================================================

impl RustGenerator {
    fn generate_type_alias(
        &self,
        builder: &mut CodeBuilder,
        type_alias: &TypeAliasDef,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&type_alias.name);
        
        // Target types should also be prefixed if they're not primitives
        let target_base = if is_primitive_type(&type_alias.target) || type_alias.target.contains("::") {
            type_alias.target.clone()
        } else {
            config.apply_prefix(&type_alias.target)
        };
        
        // Build the full target type including generic arguments
        let target = if type_alias.generic_args.is_empty() {
            target_base
        } else {
            // Apply prefix to each generic argument
            let prefixed_args: Vec<String> = type_alias.generic_args.iter()
                .map(|arg| {
                    if is_primitive_type(arg) || arg.contains("::") {
                        arg.clone()
                    } else {
                        config.apply_prefix(arg)
                    }
                })
                .collect();
            format!("{}<{}>", target_base, prefixed_args.join(", "))
        };
        
        builder.line(&format!("pub type {} = {};", name, target));
        builder.blank();
    }

    fn generate_callback_typedef(
        &self,
        builder: &mut CodeBuilder,
        callback: &CallbackTypedefDef,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&callback.name);

        if config.callback_typedef_use_external {
            if let Some(ref external) = callback.external_path {
                builder.line(&format!("pub type {} = {};", name, external));
                builder.blank();
                return;
            }
        }

        // Generate function pointer signature
        // Note: For type aliases, we only need types, not names: fn(Type1, Type2) -> Return
        let args: Vec<String> = callback.args.iter().map(|arg| {
            let type_name = config.apply_prefix(&arg.type_name);
            let ref_prefix = match arg.ref_kind {
                ArgRefKind::Owned => "",
                ArgRefKind::Ref => "&",
                ArgRefKind::RefMut => "&mut ",
                ArgRefKind::Ptr => "*const ",
                ArgRefKind::PtrMut => "*mut ",
            };
            format!("{}{}", ref_prefix, type_name)
        }).collect();
        
        let return_str = callback.return_type.as_ref()
            .map(|r| format!(" -> {}", config.apply_prefix(r)))
            .unwrap_or_default();

        builder.line(&format!(
            "pub type {} = extern \"C\" fn({}){};",
            name,
            args.join(", "),
            return_str
        ));
        builder.blank();
    }

    fn generate_struct(
        &self,
        builder: &mut CodeBuilder,
        struct_def: &StructDef,
        _ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&struct_def.name);
        
        // Add generic parameters if present
        let generics = if struct_def.generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", struct_def.generic_params.join(", "))
        };
        let full_name = format!("{}{}", name, generics);

        // Doc comment
        if !struct_def.doc.is_empty() {
            for doc_line in &struct_def.doc {
                builder.line(&format!("/// {}", doc_line));
            }
        } else {
            builder.line(&format!("/// `{}` struct", name));
        }

        // Repr attribute
        if let Some(ref repr) = struct_def.repr {
            builder.line(&format!("#[repr({})]", repr));
        } else {
            builder.line("#[repr(C)]");
        }

        // Struct definition
        if struct_def.fields.is_empty() {
            builder.line(&format!("pub struct {};", full_name));
        } else {
            builder.line(&format!("pub struct {} {{", full_name));
            builder.indent();
            for field in &struct_def.fields {
                let field_type = self.format_field_type(&field.type_name, &field.ref_kind, config);
                let visibility = if field.is_public { "pub " } else { "pub(crate) " };
                builder.line(&format!("{}{}: {},", visibility, field.name, field_type));
            }
            builder.dedent();
            builder.line("}");
        }
        builder.blank();
    }

    fn generate_enum(
        &self,
        builder: &mut CodeBuilder,
        enum_def: &EnumDef,
        _ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&enum_def.name);
        
        // Add generic parameters if present
        let generics = if enum_def.generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", enum_def.generic_params.join(", "))
        };
        let full_name = format!("{}{}", name, generics);

        // Doc comment
        if !enum_def.doc.is_empty() {
            for doc_line in &enum_def.doc {
                builder.line(&format!("/// {}", doc_line));
            }
        } else {
            builder.line(&format!("/// `{}` struct", name));
        }

        // Repr attribute - automatically determine based on whether enum has variant data
        // Enums with variant data (tagged unions) need repr(C, u8) for proper C ABI
        // We ignore api.json "repr" field for enums - it's always implicitly calculable
        if enum_def.is_union {
            builder.line("#[repr(C, u8)]");
        } else {
            builder.line("#[repr(C)]");
        }

        // Enum definition
        builder.line(&format!("pub enum {} {{", full_name));
        builder.indent();
        for variant in &enum_def.variants {
            match &variant.kind {
                EnumVariantKind::Unit => {
                    builder.line(&format!("{},", variant.name));
                }
                EnumVariantKind::Tuple(types) => {
                    let types_str: Vec<String> = types.iter()
                        .map(|t| config.apply_prefix(t))
                        .collect();
                    builder.line(&format!("{}({}),", variant.name, types_str.join(", ")));
                }
                EnumVariantKind::Struct(fields) => {
                    builder.line(&format!("{} {{", variant.name));
                    builder.indent();
                    for field in fields {
                        let field_type = config.apply_prefix(&field.type_name);
                        builder.line(&format!("{}: {},", field.name, field_type));
                    }
                    builder.dedent();
                    builder.line("},");
                }
            }
        }
        builder.dedent();
        builder.line("}");
        builder.blank();
    }

    fn format_field_type(&self, type_name: &str, ref_kind: &FieldRefKind, config: &CodegenConfig) -> String {
        let prefixed = config.apply_prefix(type_name);
        match ref_kind {
            FieldRefKind::Owned => prefixed,
            FieldRefKind::Ref => format!("&{}", prefixed),
            FieldRefKind::RefMut => format!("&mut {}", prefixed),
            FieldRefKind::Ptr => format!("*const {}", prefixed),
            FieldRefKind::PtrMut => format!("*mut {}", prefixed),
            FieldRefKind::Boxed => format!("Box<{}>", prefixed),
            FieldRefKind::OptionBoxed => format!("Option<Box<{}>>", prefixed),
        }
    }
}

// ============================================================================
// Trait Implementation Generation - Using Transmute
// ============================================================================

impl RustGenerator {
    fn generate_transmute_trait_impls(
        &self,
        builder: &mut CodeBuilder,
        struct_def: &StructDef,
        config: &CodegenConfig,
        _external_crate: &str,
    ) {
        let name = config.apply_prefix(&struct_def.name);
        
        // Build generics string: "<T>" or "<T, U>" etc.
        let generics = if struct_def.generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", struct_def.generic_params.join(", "))
        };
        
        // Build impl generics: "impl<T>" or "impl<T: Clone>"
        let impl_generics = if struct_def.generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", struct_def.generic_params.join(", "))
        };
        
        let full_name = format!("{}{}", name, generics);
        
        let external_path = struct_def.external_path.as_ref()
            .map(|p| config.transform_external_path(p))
            .unwrap_or_else(|| format!("crate::{}", struct_def.name));

        // Clone impl - generate for:
        // 1. Types with is_clone trait explicitly set
        // 2. Types with external_path (can clone via transmute to external type)
        // Skip for generic types (can't transmute dependent-sized types)
        let should_gen_clone = struct_def.generic_params.is_empty() 
            && (struct_def.traits.is_clone || struct_def.external_path.is_some());
        
        if should_gen_clone {
            builder.line(&format!("impl Clone for {} {{", full_name));
            builder.indent();
            builder.line("fn clone(&self) -> Self {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ core::mem::transmute::<{}, {}>((*(self as *const {} as *const {})).clone()) }}",
                external_path, full_name, full_name, external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Debug impl - skip for generic types
        if struct_def.generic_params.is_empty() {
            builder.line(&format!("impl core::fmt::Debug for {} {{", full_name));
            builder.indent();
            builder.line("fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {");
            builder.indent();
            builder.line(&format!("f.debug_struct(\"{}\").finish()", name));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Default impl (if has_default) - skip for generic types
        if struct_def.traits.is_default && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl Default for {} {{", full_name));
            builder.indent();
            builder.line("fn default() -> Self {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ core::mem::transmute::<{}, {}>({}::default()) }}",
                external_path, full_name, external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // PartialEq impl - using byte comparison via transmute
        // Skip for generic types - size_of::<Self>() doesn't work in const context for generics
        if struct_def.traits.is_partial_eq && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl PartialEq for {} {{", full_name));
            builder.indent();
            builder.line("fn eq(&self, other: &Self) -> bool {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self) == core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Eq impl
        // Skip for generic types
        if struct_def.traits.is_eq && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl Eq for {} {{ }}", full_name));
            builder.blank();
        }

        // PartialOrd impl
        // Skip for generic types
        if struct_def.traits.is_partial_ord && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl PartialOrd for {} {{", full_name));
            builder.indent();
            builder.line("fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {");
            builder.indent();
            builder.line("Some(unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).cmp(core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other)) })");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Ord impl
        // Skip for generic types
        if struct_def.traits.is_ord && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl Ord for {} {{", full_name));
            builder.indent();
            builder.line("fn cmp(&self, other: &Self) -> core::cmp::Ordering {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).cmp(core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other)) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Hash impl
        // Skip for generic types
        if struct_def.traits.is_hash && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl core::hash::Hash for {} {{", full_name));
            builder.indent();
            builder.line("fn hash<H: core::hash::Hasher>(&self, state: &mut H) {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).hash(state) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }

    fn generate_transmute_trait_impls_enum(
        &self,
        builder: &mut CodeBuilder,
        enum_def: &EnumDef,
        config: &CodegenConfig,
        _external_crate: &str,
    ) {
        // Skip generic enums entirely - can't transmute dependent-sized types
        if !enum_def.generic_params.is_empty() {
            return;
        }
        
        let name = config.apply_prefix(&enum_def.name);
        let full_name = name.clone(); // No generics since we skip generic enums
        
        let external_path = enum_def.external_path.as_ref()
            .map(|p| config.transform_external_path(p))
            .unwrap_or_else(|| format!("crate::{}", enum_def.name));

        // Clone impl - generate for:
        // 1. Types with is_clone trait explicitly set
        // 2. Types with external_path (can clone via transmute to external type)
        let should_gen_clone = enum_def.traits.is_clone || enum_def.external_path.is_some();
        
        if should_gen_clone {
            builder.line(&format!("impl Clone for {} {{", full_name));
            builder.indent();
            builder.line("fn clone(&self) -> Self {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ core::mem::transmute::<{}, {}>((*(self as *const {} as *const {})).clone()) }}",
                external_path, full_name, full_name, external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Debug impl
        builder.line(&format!("impl core::fmt::Debug for {} {{", full_name));
        builder.indent();
        builder.line("fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {");
        builder.indent();
        builder.line(&format!("f.debug_struct(\"{}\").finish()", name));
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // PartialEq impl
        // Skip for generic types - size_of::<Self>() doesn't work in const context for generics
        if enum_def.traits.is_partial_eq && enum_def.generic_params.is_empty() {
            builder.line(&format!("impl PartialEq for {} {{", full_name));
            builder.indent();
            builder.line("fn eq(&self, other: &Self) -> bool {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self) == core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Eq impl - Skip for generic types
        if enum_def.traits.is_eq && enum_def.generic_params.is_empty() {
            builder.line(&format!("impl Eq for {} {{ }}", full_name));
            builder.blank();
        }

        // PartialOrd impl - Skip for generic types
        if enum_def.traits.is_partial_ord && enum_def.generic_params.is_empty() {
            builder.line(&format!("impl PartialOrd for {} {{", full_name));
            builder.indent();
            builder.line("fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {");
            builder.indent();
            builder.line("Some(unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).cmp(core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other)) })");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Ord impl - Skip for generic types
        if enum_def.traits.is_ord && enum_def.generic_params.is_empty() {
            builder.line(&format!("impl Ord for {} {{", full_name));
            builder.indent();
            builder.line("fn cmp(&self, other: &Self) -> core::cmp::Ordering {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).cmp(core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other)) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Hash impl - Skip for generic types
        if enum_def.traits.is_hash && enum_def.generic_params.is_empty() {
            builder.line(&format!("impl core::hash::Hash for {} {{", full_name));
            builder.indent();
            builder.line("fn hash<H: core::hash::Hasher>(&self, state: &mut H) {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).hash(state) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }
}

// ============================================================================
// Trait Implementation Generation - Using C-ABI
// ============================================================================

impl RustGenerator {
    fn generate_capi_trait_impls(
        &self,
        builder: &mut CodeBuilder,
        struct_def: &StructDef,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&struct_def.name);

        // Clone impl calling C-ABI function
        if struct_def.traits.is_clone && !struct_def.traits.is_copy {
            let deep_copy_fn = format!("{}_deepCopy", name);
            builder.line(&format!("impl Clone for {} {{", name));
            builder.indent();
            builder.line("fn clone(&self) -> Self {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self) }}", deep_copy_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Drop impl calling C-ABI function
        if struct_def.traits.needs_delete() {
            let delete_fn = format!("{}_delete", name);
            builder.line(&format!("impl Drop for {} {{", name));
            builder.indent();
            builder.line("fn drop(&mut self) {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self) }}", delete_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }

    fn generate_capi_trait_impls_enum(
        &self,
        builder: &mut CodeBuilder,
        enum_def: &EnumDef,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&enum_def.name);

        // Clone impl calling C-ABI function
        if enum_def.traits.is_clone && !enum_def.traits.is_copy {
            let deep_copy_fn = format!("{}_deepCopy", name);
            builder.line(&format!("impl Clone for {} {{", name));
            builder.indent();
            builder.line("fn clone(&self) -> Self {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self) }}", deep_copy_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Drop impl calling C-ABI function
        if enum_def.traits.needs_delete() {
            let delete_fn = format!("{}_delete", name);
            builder.line(&format!("impl Drop for {} {{", name));
            builder.indent();
            builder.line("fn drop(&mut self) {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self) }}", delete_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }
}

// ============================================================================
// Function Generation
// ============================================================================

impl RustGenerator {
    fn generate_function_definition(
        &self,
        builder: &mut CodeBuilder,
        func: &FunctionDef,
        ir: &CodegenIR,
        config: &CodegenConfig,
        no_mangle: bool,
    ) {
        // Attributes
        builder.line("#[allow(unused_variables)]");
        if no_mangle {
            builder.line("#[no_mangle]");
        }

        let args = self.format_function_args(func, config);
        let return_str = func.return_type.as_ref()
            .map(|r| format!(" -> {}", config.apply_prefix(r)))
            .unwrap_or_default();

        let body = self.generate_function_body(func, ir, config);
        
        // Single-line or multi-line based on body
        builder.line(&format!(
            "pub unsafe extern \"C\" fn {}({}){} {}",
            func.c_name,
            args,
            return_str,
            body
        ));
    }

    fn generate_function_body(
        &self,
        func: &FunctionDef,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) -> String {
        let prefixed_name = config.apply_prefix(&func.class_name);
        
        // Get external path for this type, transforming if needed
        let external_path = ir.type_to_external.get(&func.class_name)
            .map(|p| config.transform_external_path(p))
            .unwrap_or_else(|| format!("crate::{}", func.class_name));

        // Generate body based on function kind
        match func.kind {
            FunctionKind::Delete => {
                // For delete, we just let the value drop
                format!("{{ core::mem::drop(core::mem::transmute::<&mut {}, Box<{}>>({} as *mut {} as *mut _)); }}", 
                    prefixed_name, external_path, 
                    func.args.first().map(|a| a.name.as_str()).unwrap_or("object"),
                    prefixed_name)
            }
            FunctionKind::DeepCopy => {
                let arg_name = func.args.first().map(|a| a.name.as_str()).unwrap_or("object");
                format!(
                    "{{ core::mem::transmute::<{}, {}>((*({}  as *const {} as *const {})).clone()) }}",
                    external_path, prefixed_name, arg_name, prefixed_name, external_path
                )
            }
            FunctionKind::PartialEq => {
                format!(
                    "{{ (*(a as *const {} as *const {})) == (*(b as *const {} as *const {})) }}",
                    prefixed_name, external_path, prefixed_name, external_path
                )
            }
            FunctionKind::PartialCmp => {
                format!(
                    "{{ match (*(a as *const {} as *const {})).partial_cmp(&*(b as *const {} as *const {})) {{
        Some(core::cmp::Ordering::Less) => 0,
        Some(core::cmp::Ordering::Equal) => 1,
        Some(core::cmp::Ordering::Greater) => 2,
        None => 255,
    }} }}",
                    prefixed_name, external_path, prefixed_name, external_path
                )
            }
            FunctionKind::Cmp => {
                format!(
                    "{{ match (*(a as *const {} as *const {})).cmp(&*(b as *const {} as *const {})) {{
        core::cmp::Ordering::Less => 0,
        core::cmp::Ordering::Equal => 1,
        core::cmp::Ordering::Greater => 2,
    }} }}",
                    prefixed_name, external_path, prefixed_name, external_path
                )
            }
            FunctionKind::Hash => {
                let arg_name = func.args.first().map(|a| a.name.as_str()).unwrap_or("object");
                format!(
                    "{{ {{
        use core::hash::{{Hash, Hasher}};
        let mut hasher = std::collections::hash_map::DefaultHasher::new();
        (*({} as *const {} as *const {})).hash(&mut hasher);
        hasher.finish()
    }} }}",
                    arg_name, prefixed_name, external_path
                )
            }
            FunctionKind::Constructor | FunctionKind::StaticMethod |
            FunctionKind::Method | FunctionKind::MethodMut => {
                // For regular API functions, use the fn_body from api.json 
                // and transform it using generate_transmuted_fn_body
                if let Some(ref body) = func.fn_body {
                    // Build the type_to_external map for this function
                    let type_to_external: std::collections::BTreeMap<String, String> = 
                        ir.type_to_external.iter()
                            .map(|(k, v)| (config.apply_prefix(k), v.clone()))
                            .collect();
                    
                    // Format fn_args as the old generator expects: "arg1: Type1, arg2: Type2"
                    let fn_args = self.format_function_args(func, config);
                    
                    // Determine return type with prefix
                    let return_type = func.return_type.as_ref()
                        .map(|r| config.apply_prefix(r))
                        .unwrap_or_default();
                    
                    // Use the existing transmuted fn_body generator
                    generate_transmuted_fn_body(
                        body,
                        &func.class_name,
                        func.kind == FunctionKind::Constructor || func.kind == FunctionKind::StaticMethod,
                        &return_type,
                        &config.type_prefix,
                        &type_to_external,
                        &fn_args,
                        true, // is_for_dll
                        false, // keep_self_name
                        false, // force_clone_self
                        &BTreeSet::new(), // skip_args
                    )
                } else {
                    // No fn_body - generate error or stub
                    format!("{{ /* ERROR: No fn_body for {} */ unimplemented!() }}", func.c_name)
                }
            }
        }
    }

    fn generate_method_body(
        &self,
        func: &FunctionDef,
        ir: &CodegenIR,
        config: &CodegenConfig,
        external_path: &str,
        prefixed_name: &str,
    ) -> String {
        // Generate transmute calls for each argument
        let mut lines = Vec::new();
        lines.push("{".to_string());

        // Get the self argument name if this is a method
        let self_arg_name = match func.kind {
            FunctionKind::Method | FunctionKind::MethodMut => {
                func.args.first().map(|a| a.name.clone())
            }
            _ => None,
        };

        // Transmute each argument
        for arg in &func.args {
            let ext_type = ir.type_to_external.get(&arg.type_name)
                .cloned()
                .unwrap_or_else(|| {
                    // For primitive types, just use the type directly
                    if is_primitive_type(&arg.type_name) {
                        arg.type_name.clone()
                    } else {
                        format!("crate::{}", arg.type_name)
                    }
                });

            let transmute_expr = match arg.ref_kind {
                ArgRefKind::Ref => format!(
                    "    let {}: &{} = core::mem::transmute({});",
                    arg.name, ext_type, arg.name
                ),
                ArgRefKind::RefMut => format!(
                    "    let {}: &mut {} = core::mem::transmute({});",
                    arg.name, ext_type, arg.name
                ),
                ArgRefKind::Owned => {
                    if is_primitive_type(&arg.type_name) {
                        format!("    let {}: {} = {};", arg.name, ext_type, arg.name)
                    } else {
                        format!(
                            "    let {}: {} = core::mem::transmute({});",
                            arg.name, ext_type, arg.name
                        )
                    }
                }
                ArgRefKind::Ptr | ArgRefKind::PtrMut => format!(
                    "    let {}: {} = core::mem::transmute({});",
                    arg.name, ext_type, arg.name
                ),
            };
            lines.push(transmute_expr);
        }

        // Generate the call
        let args_for_call: Vec<String> = func.args.iter()
            .skip(if self_arg_name.is_some() { 1 } else { 0 })
            .map(|a| a.name.clone())
            .collect();

        let call = if let Some(ref self_name) = self_arg_name {
            // Instance method call
            format!("    let __result = {}.{}({});", self_name, func.method_name, args_for_call.join(", "))
        } else {
            // Static method or constructor
            format!("    let __result: {} = {}::{}({});", 
                external_path, external_path, func.method_name, args_for_call.join(", "))
        };
        lines.push(call);

        // Transmute result back if needed
        if let Some(ref ret_type) = func.return_type {
            let ret_prefixed = config.apply_prefix(ret_type);
            let ret_external = ir.type_to_external.get(ret_type)
                .cloned()
                .unwrap_or_else(|| {
                    if is_primitive_type(ret_type) {
                        ret_type.clone()
                    } else {
                        format!("crate::{}", ret_type)
                    }
                });
            if is_primitive_type(ret_type) {
                lines.push("    __result".to_string());
            } else {
                lines.push(format!("    core::mem::transmute::<{}, {}>(__result)", ret_external, ret_prefixed));
            }
        } else {
            // No return, discard result
            lines.push("    let _ = __result;".to_string());
        }

        lines.push("}".to_string());
        lines.join("\n")
    }

    fn generate_function_declaration(
        &self,
        builder: &mut CodeBuilder,
        func: &FunctionDef,
        config: &CodegenConfig,
    ) {
        let args = self.format_function_args(func, config);
        let return_str = func.return_type.as_ref()
            .map(|r| format!(" -> {}", config.apply_prefix(r)))
            .unwrap_or_default();

        builder.line(&format!("pub fn {}({}){};", func.c_name, args, return_str));
    }

    fn format_function_args(&self, func: &FunctionDef, config: &CodegenConfig) -> String {
        func.args.iter().map(|arg| {
            let type_name = config.apply_prefix(&arg.type_name);
            let formatted = match arg.ref_kind {
                ArgRefKind::Owned => type_name,
                ArgRefKind::Ref => format!("&{}", type_name),
                ArgRefKind::RefMut => format!("&mut {}", type_name),
                ArgRefKind::Ptr => format!("*const {}", type_name),
                ArgRefKind::PtrMut => format!("*mut {}", type_name),
            };
            format!("{}: {}", arg.name, formatted)
        }).collect::<Vec<_>>().join(", ")
    }

    /// Generate test module with size/alignment verification tests
    fn generate_tests(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        builder.line("#[cfg(test)]");
        builder.line("mod generated_tests {");
        builder.indent();
        builder.line("use super::*;");
        builder.line("use super::__dll_api_inner::dll;");
        builder.line("use core::mem;");
        builder.blank();

        // Generate size/alignment tests for each struct
        for struct_def in &ir.structs {
            if !config.should_include_type(&struct_def.name) {
                continue;
            }
            // Skip generic types - can't test size at compile time
            if !struct_def.generic_params.is_empty() {
                continue;
            }
            // Need external_path to compare sizes
            let Some(external_path) = &struct_def.external_path else {
                continue;
            };
            
            // Skip if external path contains generic parameters (like <T>)
            if external_path.contains('<') {
                continue;
            }
            
            let external_path = config.transform_external_path(external_path);
            let generated_type = format!("dll::Az{}", struct_def.name);
            let test_name = format!("test_size_align_{}", struct_def.name.to_lowercase());

            builder.line("#[test]");
            builder.line(&format!("fn {}() {{", test_name));
            builder.indent();
            builder.line(&format!("let gen_size = mem::size_of::<{}>();", generated_type));
            builder.line(&format!("let ext_size = mem::size_of::<{}>();", external_path));
            builder.line(&format!("let gen_align = mem::align_of::<{}>();", generated_type));
            builder.line(&format!("let ext_align = mem::align_of::<{}>();", external_path));
            builder.line(&format!("assert_eq!(gen_size, ext_size, \"Size mismatch for {}\");", struct_def.name));
            builder.line(&format!("assert_eq!(gen_align, ext_align, \"Align mismatch for {}\");", struct_def.name));
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Generate size/alignment tests for each enum
        for enum_def in &ir.enums {
            if !config.should_include_type(&enum_def.name) {
                continue;
            }
            // Skip generic types - can't test size at compile time
            if !enum_def.generic_params.is_empty() {
                continue;
            }
            // Need external_path to compare sizes
            let Some(external_path) = &enum_def.external_path else {
                continue;
            };
            
            // Skip if external path contains generic parameters (like <T>)
            if external_path.contains('<') {
                continue;
            }
            
            let external_path = config.transform_external_path(external_path);
            let generated_type = format!("dll::Az{}", enum_def.name);
            let test_name = format!("test_size_align_{}", enum_def.name.to_lowercase());

            builder.line("#[test]");
            builder.line(&format!("fn {}() {{", test_name));
            builder.indent();
            builder.line(&format!("let gen_size = mem::size_of::<{}>();", generated_type));
            builder.line(&format!("let ext_size = mem::size_of::<{}>();", external_path));
            builder.line(&format!("let gen_align = mem::align_of::<{}>();", generated_type));
            builder.line(&format!("let ext_align = mem::align_of::<{}>();", external_path));
            builder.line(&format!("assert_eq!(gen_size, ext_size, \"Size mismatch for {}\");", enum_def.name));
            builder.line(&format!("assert_eq!(gen_align, ext_align, \"Align mismatch for {}\");", enum_def.name));
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        builder.dedent();
        builder.line("} // mod generated_tests");

        Ok(builder.finish())
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

fn is_primitive_type(type_name: &str) -> bool {
    matches!(type_name, 
        "bool" | "i8" | "i16" | "i32" | "i64" | "i128" | "isize" |
        "u8" | "u16" | "u32" | "u64" | "u128" | "usize" |
        "f32" | "f64" | "char" | "()" |
        "c_void"
        // NOTE: "String" is NOT a primitive - it's AzString in Azul, not std::string::String
    )
}
