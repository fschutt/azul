//! Rust code generator
//!
//! Generates Rust code from the IR, including:
//! - Struct and enum definitions
//! - C-ABI function definitions or declarations
//! - Trait implementations using transmute

use anyhow::Result;
use std::collections::BTreeSet;

use super::config::*;
use super::generator::{CodeBuilder, LanguageGenerator};
use super::ir::*;
use super::transmute_helpers::{generate_transmuted_fn_body, parse_arg_type};

// ============================================================================
// Rust Generator
// ============================================================================

pub struct RustGenerator;

impl LanguageGenerator for RustGenerator {
    fn generate(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // File header
        builder.line("// Auto-generated by azul-doc codegen v2");
        builder.line("// DO NOT EDIT MANUALLY");
        builder.blank();

        // Check if this is a "simple" config (no module wrapper, no prefix)
        // Used for rust_public_api which generates flat type definitions
        let is_simple_mode = config.module_wrapper.is_none() && config.type_prefix.is_empty();

        if is_simple_mode {
            // Simple mode: just generate types directly, no nested modules
            return self.generate_simple_rust_api(ir, config);
        }

        // Generate inner module wrapper (using the same structure as existing dll_api.rs)
        // The structure is: pub mod __dll_api_inner { pub mod dll { ... } }
        builder.line("pub mod __dll_api_inner {");
        builder.indent();
        builder.line("pub mod dll {");
        builder.indent();

        // Imports
        for import in &config.imports {
            builder.line(import);
        }
        if !config.imports.is_empty() {
            builder.blank();
        }

        // GL type aliases first
        builder.line("// --- GL Type Aliases ---");
        self.generate_gl_type_aliases(&mut builder);
        builder.blank();

        // Primitive type aliases
        builder.line("// --- Primitive Type Aliases ---");
        self.generate_primitive_aliases(&mut builder);
        builder.blank();

        // Type definitions (structs and enums)
        if config.struct_mode != StructMode::None {
            builder.line("// --- Type Definitions ---");
            let types = self.generate_types(ir, config)?;
            builder.raw(&types);
        }

        // Trait implementations
        builder.line("// --- Trait Implementations ---");
        let trait_impls = self.generate_trait_impls(ir, config)?;
        builder.raw(&trait_impls);

        // Methods (impl blocks for Rust API)
        // Only generate if we have C-ABI functions to call
        // When CAbiFunctionMode::None, the impl blocks would call non-existent functions
        if !matches!(config.cabi_functions, CAbiFunctionMode::None) {
            builder.line("// --- Method Implementations ---");
            let impl_blocks = self.generate_impl_blocks(ir, config)?;
            builder.raw(&impl_blocks);

            // Rust-only generic methods (not part of C-ABI)
            builder.line("// --- Rust-Only Generic Methods ---");
            let rust_only = self.generate_rust_only_impls(ir, config)?;
            builder.raw(&rust_only);
        }

        // Functions
        builder.line("// --- C-ABI Functions ---");
        let functions = self.generate_functions(ir, config)?;
        builder.raw(&functions);

        // End module wrappers
        builder.dedent();
        builder.line("} // mod dll");
        builder.dedent();
        builder.line("} // mod __dll_api_inner");

        // Re-exports at the end
        builder.blank();
        self.generate_reexports(&mut builder, "__dll_api_inner");

        // Generate tests if enabled
        if config.generate_tests {
            builder.blank();
            let tests = self.generate_tests(ir, config)?;
            builder.raw(&tests);
        }

        Ok(builder.finish())
    }

    fn generate_types(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // Type aliases first
        for type_alias in &ir.type_aliases {
            if !config.should_include_type(&type_alias.name) {
                continue;
            }
            self.generate_type_alias(&mut builder, type_alias, config);
        }

        // Callback typedefs
        for callback in &ir.callback_typedefs {
            if !config.should_include_type(&callback.name) {
                continue;
            }
            self.generate_callback_typedef(&mut builder, callback, config);
        }

        // Structs
        for struct_def in &ir.structs {
            if !config.should_include_type(&struct_def.name) {
                continue;
            }
            self.generate_struct(&mut builder, struct_def, ir, config);
        }

        // Enums
        for enum_def in &ir.enums {
            if !config.should_include_type(&enum_def.name) {
                continue;
            }
            self.generate_enum(&mut builder, enum_def, ir, config);
        }

        Ok(builder.finish())
    }

    fn generate_functions(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // When using transmute-based trait impls, we don't need C-ABI trait functions
        // because traits are implemented directly using transmute, not via C-ABI calls.
        // HOWEVER: When building the DLL (no_mangle = true), we MUST export all trait
        // functions because C/C++/Python need to call them for destructors (_delete),
        // cloning (_deepCopy), etc. The trait impls inside Rust can use transmute,
        // but we still need the exported C-ABI functions for FFI.
        let skip_trait_functions = matches!(
            config.trait_impl_mode,
            TraitImplMode::UsingTransmute { .. } | TraitImplMode::UsingDerive
        );

        match &config.cabi_functions {
            CAbiFunctionMode::InternalBindings { no_mangle } => {
                for func in &ir.functions {
                    if !config.should_include_type(&func.class_name) {
                        continue;
                    }
                    // Skip trait functions when using transmute impls ONLY for internal use.
                    // When no_mangle is true (DLL build), we need to export all functions
                    // for C/C++/Python bindings to call _delete, _deepCopy, etc.
                    if skip_trait_functions && !*no_mangle && func.kind.is_trait_function() {
                        continue;
                    }
                    self.generate_function_definition(&mut builder, func, ir, config, *no_mangle);
                }
            }
            CAbiFunctionMode::ExternalBindings { link_library } => {
                builder.line(&format!("#[link(name = \"{}\")]", link_library));
                builder.line("extern \"C\" {");
                builder.indent();

                for func in &ir.functions {
                    if !config.should_include_type(&func.class_name) {
                        continue;
                    }
                    if skip_trait_functions && func.kind.is_trait_function() {
                        continue;
                    }
                    self.generate_function_declaration(&mut builder, func, ir, config);
                }

                builder.dedent();
                builder.line("}");
            }
            CAbiFunctionMode::None => {}
        }

        Ok(builder.finish())
    }

    fn generate_trait_impls(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        match &config.trait_impl_mode {
            TraitImplMode::UsingDerive => {
                // Derives are handled in struct/enum generation
            }
            TraitImplMode::UsingTransmute { external_crate } => {
                // Generate trait impls using transmute
                for struct_def in &ir.structs {
                    if !config.should_include_type(&struct_def.name) {
                        continue;
                    }
                    self.generate_transmute_trait_impls(
                        &mut builder,
                        struct_def,
                        config,
                        external_crate,
                    );
                }
                for enum_def in &ir.enums {
                    if !config.should_include_type(&enum_def.name) {
                        continue;
                    }
                    self.generate_transmute_trait_impls_enum(
                        &mut builder,
                        enum_def,
                        config,
                        external_crate,
                    );
                }
            }
            TraitImplMode::UsingCAPI => {
                for struct_def in &ir.structs {
                    if !config.should_include_type(&struct_def.name) {
                        continue;
                    }
                    self.generate_capi_trait_impls(&mut builder, struct_def, config);
                }
                for enum_def in &ir.enums {
                    if !config.should_include_type(&enum_def.name) {
                        continue;
                    }
                    self.generate_capi_trait_impls_enum(&mut builder, enum_def, config);
                }
            }
            TraitImplMode::None => {}
        }

        Ok(builder.finish())
    }
}

// ============================================================================
// Helper Methods - Impl Blocks for Rust API
// ============================================================================

impl RustGenerator {
    /// Generate Rust-only generic methods that can't be exposed via C-ABI
    ///
    /// These include:
    /// - RefAny::new<T>() - construct RefAny from any Rust type
    /// - RefAny::downcast_ref<T>() / downcast_mut<T>() - get typed references
    ///
    /// For internal bindings (build-dll/link-static): implemented via transmute to core type.
    /// For external bindings (link-dynamic): these methods are NOT available because
    /// they require access to internal types that aren't exposed through the C-ABI.
    fn generate_rust_only_impls(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        let prefix = &config.type_prefix;

        // Check if we're using external bindings (link-dynamic)
        // In that case, we can't use transmute because we don't have azul_core
        let is_external_bindings = matches!(
            &config.cabi_functions,
            CAbiFunctionMode::ExternalBindings { .. }
        );

        if is_external_bindings {
            // For link-dynamic: RefAny::new and downcast are NOT available
            // Users must use the pre-built DLL which doesn't support generic Rust types
            // Don't generate an empty impl block - just skip RefAny generic methods entirely
            builder.blank();
        } else {
            // For internal bindings (build-dll/link-static): use transmute to azul_core

            // RefAny generic methods - implemented via transmute to core type
            builder.line(&format!("impl {}RefAny {{", prefix));
            builder.indent();

            // new<T>
            builder.line("/// Creates a new type-erased RefAny containing the given value.");
            builder.line("pub fn new<T: 'static>(value: T) -> Self {");
            builder.indent();
            builder.line("use core::mem::transmute;");
            builder.line("unsafe {");
            builder.indent();
            builder.line("transmute(azul_core::refany::RefAny::new(value))");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();

            // downcast_ref<T> - using guards, must return wrapped type
            builder.line("/// Returns a RAII guard to the inner value if types match.");
            builder.line("/// ");
            builder.line("/// The guard holds a shared borrow; drop it when done.");
            builder.line(&format!("pub fn downcast_ref<T: 'static>(&mut self) -> Option<azul_core::refany::Ref<'_, T>> {{"));
            builder.indent();
            builder.line("use core::mem::transmute;");
            builder.line("unsafe {");
            builder.indent();
            builder.line("let core_ref: &mut azul_core::refany::RefAny = transmute(self);");
            builder.line("core_ref.downcast_ref::<T>()");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();

            // downcast_mut<T> - using guards, must return wrapped type
            builder
                .line("/// Returns a RAII guard to mutably borrow the inner value if types match.");
            builder.line("/// ");
            builder.line("/// The guard holds an exclusive borrow; drop it when done.");
            builder.line(&format!("pub fn downcast_mut<T: 'static>(&mut self) -> Option<azul_core::refany::RefMut<'_, T>> {{"));
            builder.indent();
            builder.line("use core::mem::transmute;");
            builder.line("unsafe {");
            builder.indent();
            builder.line("let core_ref: &mut azul_core::refany::RefAny = transmute(self);");
            builder.line("core_ref.downcast_mut::<T>()");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");

            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // String conversions - implement From<&str> and From<String> for AzString
        // Generate for ALL builds - always use AzString_copyFromBytes to avoid leaking struct details

        // From<&str> for AzString
        builder.line(&format!("impl From<&str> for {}String {{", prefix));
        builder.indent();
        builder.line("fn from(s: &str) -> Self {");
        builder.indent();
        builder.line(&format!(
            "unsafe {{ {}String_copyFromBytes(s.as_ptr(), 0, s.len()) }}",
            prefix
        ));
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // From<String> for AzString
        builder.line(&format!(
            "impl From<alloc::string::String> for {}String {{",
            prefix
        ));
        builder.indent();
        builder.line("fn from(s: alloc::string::String) -> Self {");
        builder.indent();
        builder.line(&format!(
            "unsafe {{ {}String_copyFromBytes(s.as_ptr(), 0, s.len()) }}",
            prefix
        ));
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // AzString convenience methods for ergonomic API - generate for ALL builds
        builder.line(&format!("impl {}String {{", prefix));
        builder.indent();

        // as_str() - returns &str by reinterpreting the bytes
        builder.line("/// Returns the string as a `&str` slice.");
        builder.line("#[inline]");
        builder.line("pub fn as_str(&self) -> &str {");
        builder.indent();
        builder.line("unsafe {");
        builder.indent();
        builder.line("core::str::from_utf8_unchecked(core::slice::from_raw_parts(self.vec.ptr, self.vec.len))");
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // into_string() - converts to owned String
        builder.line("/// Converts the AzString into an owned `String`.");
        builder.line("/// ");
        builder.line("/// If the memory was library-allocated, takes ownership without copying.");
        builder.line("/// Otherwise clones the memory.");
        builder.line("#[inline]");
        builder.line("pub fn into_string(self) -> alloc::string::String {");
        builder.indent();
        builder.line("self.as_str().to_string()");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // as_bytes() - returns byte slice
        builder.line("/// Returns the raw bytes of the string.");
        builder.line("#[inline]");
        builder.line("pub fn as_bytes(&self) -> &[u8] {");
        builder.indent();
        builder.line("unsafe { core::slice::from_raw_parts(self.vec.ptr, self.vec.len) }");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // len() - returns length
        builder.line("/// Returns the length of the string in bytes.");
        builder.line("#[inline]");
        builder.line("pub fn len(&self) -> usize {");
        builder.indent();
        builder.line("self.vec.len");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // is_empty() - checks if empty
        builder.line("/// Returns true if the string is empty.");
        builder.line("#[inline]");
        builder.line("pub fn is_empty(&self) -> bool {");
        builder.indent();
        builder.line("self.vec.len == 0");
        builder.dedent();
        builder.line("}");

        builder.dedent();
        builder.line("}");
        builder.blank();

        // AsRef<str> implementation
        builder.line(&format!("impl AsRef<str> for {}String {{", prefix));
        builder.indent();
        builder.line("fn as_ref(&self) -> &str {");
        builder.indent();
        builder.line("self.as_str()");
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // Display implementation
        builder.line(&format!("impl core::fmt::Display for {}String {{", prefix));
        builder.indent();
        builder.line("fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {");
        builder.indent();
        builder.line("self.as_str().fmt(f)");
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // Into<String> implementation
        builder.line(&format!(
            "impl Into<alloc::string::String> for {}String {{",
            prefix
        ));
        builder.indent();
        builder.line("fn into(self) -> alloc::string::String {");
        builder.indent();
        builder.line("self.into_string()");
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // AsRef<[u8]> implementation
        builder.line(&format!("impl AsRef<[u8]> for {}String {{", prefix));
        builder.indent();
        builder.line("fn as_ref(&self) -> &[u8] {");
        builder.indent();
        builder.line("self.as_bytes()");
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // PartialEq<str> implementation
        builder.line(&format!("impl PartialEq<str> for {}String {{", prefix));
        builder.indent();
        builder.line("fn eq(&self, other: &str) -> bool {");
        builder.indent();
        builder.line("self.as_str() == other");
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // PartialEq<&str> implementation
        builder.line(&format!("impl PartialEq<&str> for {}String {{", prefix));
        builder.indent();
        builder.line("fn eq(&self, other: &&str) -> bool {");
        builder.indent();
        builder.line("self.as_str() == *other");
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // PartialEq<String> implementation
        builder.line(&format!(
            "impl PartialEq<alloc::string::String> for {}String {{",
            prefix
        ));
        builder.indent();
        builder.line("fn eq(&self, other: &alloc::string::String) -> bool {");
        builder.indent();
        builder.line("self.as_str() == other.as_str()");
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // Deref to str implementation
        builder.line(&format!("impl core::ops::Deref for {}String {{", prefix));
        builder.indent();
        builder.line("type Target = str;");
        builder.line("fn deref(&self) -> &Self::Target {");
        builder.indent();
        builder.line("self.as_str()");
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // Generate automatic From<A> for B when A::method(self) -> B exists
        self.generate_auto_from_impls(&mut builder, ir, config);

        // Generate Option<T> convenience methods (into_option)
        self.generate_option_convenience_methods(&mut builder, ir, config);

        // Generate Vec<T> convenience methods
        self.generate_vec_convenience_methods(&mut builder, ir, config);

        // Generate VecRef<T> convenience methods (From<&[T]>, From<&Vec<T>>)
        self.generate_vec_ref_convenience_methods(&mut builder, ir, config);

        // Generate serde support for RefAny (optional, requires "serde" feature)
        self.generate_serde_support(&mut builder, config);

        Ok(builder.finish())
    }

    /// Generate serde-json support for RefAny.
    ///
    /// This generates `RefAny::new_serde<T>()` which creates a RefAny with
    /// JSON serialization/deserialization callbacks. Uses Rust monomorphization
    /// to generate type-specific trampolines - no wrapper struct needed.
    ///
    /// The generated code is gated behind `#[cfg(feature = "serde-json")]`.
    /// Requires both `serde` and `serde_json` dependencies.
    fn generate_serde_support(&self, builder: &mut CodeBuilder, config: &CodegenConfig) {
        let prefix = &config.type_prefix;

        // Check if we're using external bindings (link-dynamic)
        // serde support requires internal bindings for transmute
        let is_external_bindings = matches!(
            &config.cabi_functions,
            CAbiFunctionMode::ExternalBindings { .. }
        );

        if is_external_bindings {
            // For link-dynamic: serde support is not available
            return;
        }

        builder.line("// --- Serde-JSON Support for RefAny ---");
        builder.line(&format!("#[cfg(feature = \"serde-json\")]"));
        builder.line(&format!("impl {}RefAny {{", prefix));
        builder.indent();

        // new_serde<T> - main entry point
        builder.line("/// Creates a new RefAny with JSON serialization support.");
        builder.line("///");
        builder.line("/// Unlike `new()`, this version stores function pointers for");
        builder.line("/// serializing/deserializing the value to/from JSON. This enables");
        builder.line("/// the debug HTTP API to inspect and modify app state.");
        builder.line("///");
        builder.line("/// Requires the `serde-json` feature and `T: Serialize + DeserializeOwned`.");
        builder.line("///");
        builder.line("/// # Example");
        builder.line("///");
        builder.line("/// ```ignore");
        builder.line("/// use azul::RefAny;");
        builder.line("///");
        builder.line("/// #[derive(serde::Serialize, serde::Deserialize)]");
        builder.line("/// struct AppState { counter: i32 }");
        builder.line("///");
        builder.line("/// let state = AppState { counter: 0 };");
        builder.line("/// let refany = RefAny::new_serde(state);");
        builder.line("/// ```");
        builder.line("pub fn new_serde<T>(value: T) -> Self");
        builder.line("where");
        builder.indent();
        builder.line("T: serde::Serialize + serde::de::DeserializeOwned + 'static,");
        builder.dedent();
        builder.line("{");
        builder.indent();

        // Serialize trampoline - monomorphized for type T
        builder.line("// Serialize trampoline - compiler generates one per T");
        builder.line(&format!("extern \"C\" fn serialize<U: serde::Serialize + 'static>(mut refany: {}RefAny) -> {}Json {{", prefix, prefix));
        builder.indent();
        builder.line("match refany.downcast_ref::<U>() {");
        builder.indent();
        builder.line("Some(val) => {");
        builder.indent();
        builder.line("match serde_json::to_string(&*val) {");
        builder.indent();
        builder.line(&format!("Ok(s) => match {}Json::parse(s.as_str()) {{", prefix));
        builder.indent();
        builder.line(&format!("{}ResultJsonJsonParseError::Ok(json) => json,", prefix));
        builder.line(&format!("{}ResultJsonJsonParseError::Err(_) => {}Json::null(),", prefix, prefix));
        builder.dedent();
        builder.line("},");
        builder.line(&format!("Err(_) => {}Json::null(),", prefix));
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.line(&format!("None => {}Json::null(),", prefix));
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // Deserialize trampoline - monomorphized for type T
        builder.line("// Deserialize trampoline - compiler generates one per T");
        builder.line(&format!("extern \"C\" fn deserialize<U: serde::Serialize + serde::de::DeserializeOwned + 'static>(json: {}Json) -> {}ResultRefAnyString {{", prefix, prefix));
        builder.indent();
        builder.line("let json_str = json.to_string();");
        builder.line("match serde_json::from_str::<U>(json_str.as_str()) {");
        builder.indent();
        builder.line("Ok(value) => {");
        builder.indent();
        builder.line("// Recursively create with serde support so re-serialization works");
        builder.line(&format!("let refany = {}RefAny::new_serde(value);", prefix));
        builder.line(&format!("{}ResultRefAnyString::Ok(refany)", prefix));
        builder.dedent();
        builder.line("}");
        builder.line(&format!("Err(e) => {}ResultRefAnyString::Err({}String::from(e.to_string())),", prefix, prefix));
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // Create RefAny with the trampolines
        builder.line("// Create RefAny using internal new() then set the function pointers");
        builder.line("let mut refany = Self::new(value);");
        builder.line("refany.set_serialize_fn(serialize::<T> as usize);");
        builder.line("refany.set_deserialize_fn(deserialize::<T> as usize);");
        builder.line("refany");

        builder.dedent();
        builder.line("}");

        builder.dedent();
        builder.line("}");
        builder.blank();
    }

    /// Generate automatic From<A> for B implementations when A::method(self) -> B exists
    ///
    /// This finds all methods that:
    /// 1. Take owned self (consume the value)
    /// 2. Return a different type than the class they belong to
    ///
    /// For each such method, we generate:
    /// ```ignore
    /// impl From<A> for B {
    ///     fn from(v: A) -> B {
    ///         v.method_name()
    ///     }
    /// }
    /// ```
    ///
    /// This allows ergonomic conversions like: `let dom: Dom = button.into();`
    fn generate_auto_from_impls(
        &self,
        builder: &mut CodeBuilder,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        use std::collections::{HashMap, HashSet};

        let prefix = &config.type_prefix;

        // Track which From impls we've already generated to avoid duplicates
        // Key: (from_type, to_type)
        let mut generated_from_impls: HashSet<(String, String)> = HashSet::new();

        // For each conversion pair, track which method to use
        // If multiple methods exist for the same conversion, we use the first one found
        let mut conversion_methods: HashMap<(String, String), &str> = HashMap::new();

        // Find all methods that take owned self and return a different type
        for func in &ir.functions {
            // Skip constructors, static methods, and trait functions
            if matches!(
                func.kind,
                FunctionKind::Constructor
                    | FunctionKind::StaticMethod
                    | FunctionKind::EnumVariantConstructor
            ) || func.kind.is_trait_function()
            {
                continue;
            }

            // Check if this function takes owned self
            let takes_owned_self = func.args.iter().any(|arg| {
                let is_self = arg.name == "self"
                    || (arg.name == to_snake_case(&func.class_name)
                        && arg.type_name == func.class_name)
                    || (arg.name == "object" && arg.type_name == func.class_name);
                is_self && matches!(arg.ref_kind, ArgRefKind::Owned)
            });

            if !takes_owned_self {
                continue;
            }

            // Check if there are any other arguments besides self
            let other_args_count = func
                .args
                .iter()
                .filter(|arg| {
                    let is_self = arg.name == "self"
                        || (arg.name == to_snake_case(&func.class_name)
                            && arg.type_name == func.class_name)
                        || (arg.name == "object" && arg.type_name == func.class_name);
                    !is_self
                })
                .count();

            // Only generate From if there are no other arguments
            // (methods like `fn dom(self, extra_arg: X) -> Dom` shouldn't become From impls)
            if other_args_count != 0 {
                continue;
            }

            // Check if return type exists and is different from class_name
            let return_type = match &func.return_type {
                Some(rt) if rt != &func.class_name => rt.clone(),
                _ => continue,
            };

            let from_type = func.class_name.clone();
            let key = (from_type.clone(), return_type.clone());

            // Only use the first method for each conversion pair
            if !conversion_methods.contains_key(&key) {
                conversion_methods.insert(key, &func.method_name);
            }
        }

        // Generate the From impls
        for ((from_type, to_type), method_name) in &conversion_methods {
            let key = (from_type.clone(), to_type.clone());
            if generated_from_impls.contains(&key) {
                continue;
            }
            generated_from_impls.insert(key);

            let prefixed_from = config.apply_prefix(from_type);
            let prefixed_to = config.apply_prefix(to_type);
            let method = to_snake_case(method_name);

            builder.line(&format!(
                "impl From<{}> for {} {{",
                prefixed_from, prefixed_to
            ));
            builder.indent();
            builder.line(&format!(
                "fn from(v: {}) -> {} {{",
                prefixed_from, prefixed_to
            ));
            builder.indent();
            builder.line(&format!("v.{}()", method));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }

    /// Generate convenience methods for Option types (into_option, is_some, is_none, etc.)
    fn generate_option_convenience_methods(
        &self,
        builder: &mut CodeBuilder,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        let prefix = &config.type_prefix;

        // Find all Option types in the IR
        for enum_def in &ir.enums {
            // Check if this is an Option type (has Some and None variants)
            let has_some = enum_def.variants.iter().any(|v| v.name == "Some");
            let has_none = enum_def.variants.iter().any(|v| v.name == "None");

            if !has_some || !has_none {
                continue;
            }

            // Get the inner type from the Some variant
            let some_variant = enum_def.variants.iter().find(|v| v.name == "Some").unwrap();
            let inner_type = match &some_variant.kind {
                EnumVariantKind::Tuple(types) if types.len() == 1 => &types[0].0,
                _ => continue, // Skip if Some doesn't have exactly one field
            };

            let prefixed_name = config.apply_prefix(&enum_def.name);
            let prefixed_inner = config.apply_prefix(inner_type);
            
            // Check if this type derives Copy - if so, we don't need forget
            let is_copy = enum_def.derives.contains(&"Copy".to_string());

            builder.line(&format!("impl {} {{", prefixed_name));
            builder.indent();

            // into_option() - converts to std Option<T>
            builder.line(&format!(
                "/// Converts to a Rust `Option<{}>`, consuming self.",
                prefixed_inner
            ));
            builder.line("#[inline]");
            builder.line(&format!(
                "pub fn into_option(self) -> Option<{}> {{",
                prefixed_inner
            ));
            builder.indent();
            builder.line("match &self {");
            builder.indent();
            builder.line(&format!("{}::Some(val) => {{", prefixed_name));
            builder.indent();
            builder.line("let v = unsafe { core::ptr::read(val) };");
            // For Copy types, forget does nothing and generates a warning
            // For non-Copy types, we need forget to prevent double-drop
            if is_copy {
                builder.line("let _ = self;");
            } else {
                builder.line("core::mem::forget(self);");
            }
            builder.line("Some(v)");
            builder.dedent();
            builder.line("}");
            builder.line(&format!("{}::None => None,", prefixed_name));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();

            // is_some()
            builder.line("/// Returns `true` if the option is a `Some` value.");
            builder.line("#[inline]");
            builder.line("pub fn is_some(&self) -> bool {");
            builder.indent();
            builder.line(&format!("matches!(self, {}::Some(_))", prefixed_name));
            builder.dedent();
            builder.line("}");
            builder.blank();

            // is_none()
            builder.line("/// Returns `true` if the option is a `None` value.");
            builder.line("#[inline]");
            builder.line("pub fn is_none(&self) -> bool {");
            builder.indent();
            builder.line(&format!("matches!(self, {}::None)", prefixed_name));
            builder.dedent();
            builder.line("}");

            builder.dedent();
            builder.line("}");
            builder.blank();

            // From<Option<T>> for OptionT
            builder.line(&format!(
                "impl From<Option<{}>> for {} {{",
                prefixed_inner, prefixed_name
            ));
            builder.indent();
            builder.line(&format!(
                "fn from(o: Option<{}>) -> Self {{",
                prefixed_inner
            ));
            builder.indent();
            builder.line("match o {");
            builder.indent();
            builder.line(&format!("Some(v) => {}::Some(v),", prefixed_name));
            builder.line(&format!("None => {}::None,", prefixed_name));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();

            // Into<Option<T>> for OptionT
            builder.line(&format!(
                "impl Into<Option<{}>> for {} {{",
                prefixed_inner, prefixed_name
            ));
            builder.indent();
            builder.line(&format!("fn into(self) -> Option<{}> {{", prefixed_inner));
            builder.indent();
            builder.line("self.into_option()");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();

            // Default implementation (returns None)
            builder.line(&format!("impl Default for {} {{", prefixed_name));
            builder.indent();
            builder.line("fn default() -> Self {");
            builder.indent();
            builder.line(&format!("{}::None", prefixed_name));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }

    /// Generate convenience methods for Vec types (into_vec, as_slice, len, is_empty, iter, etc.)
    fn generate_vec_convenience_methods(
        &self,
        builder: &mut CodeBuilder,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        let _prefix = &config.type_prefix;

        // Find all Vec types in the IR (structs ending with "Vec" that have ptr, len, cap fields)
        for struct_def in &ir.structs {
            // Check if this looks like a Vec type
            if !struct_def.name.ends_with("Vec") {
                continue;
            }

            // Check for ptr, len, cap fields
            let has_ptr = struct_def.fields.iter().any(|f| f.name == "ptr");
            let has_len = struct_def.fields.iter().any(|f| f.name == "len");
            let has_cap = struct_def.fields.iter().any(|f| f.name == "cap");

            if !has_ptr || !has_len || !has_cap {
                continue;
            }

            // Get the inner type from the ptr field
            // The type_name contains the base type, and ref_kind tells us if it's a pointer
            let ptr_field = struct_def.fields.iter().find(|f| f.name == "ptr").unwrap();

            // Only process if it's actually a pointer type
            if ptr_field.ref_kind != FieldRefKind::Ptr && ptr_field.ref_kind != FieldRefKind::PtrMut
            {
                continue;
            }

            let inner_type = &ptr_field.type_name;

            let prefixed_name = config.apply_prefix(&struct_def.name);
            let prefixed_inner = config.apply_prefix(inner_type);

            builder.line(&format!("impl {} {{", prefixed_name));
            builder.indent();

            // as_slice() - returns &[T]
            builder.line(&format!(
                "/// Returns the vec as a `&[{}]` slice.",
                prefixed_inner
            ));
            builder.line("#[inline]");
            builder.line(&format!(
                "pub fn as_slice(&self) -> &[{}] {{",
                prefixed_inner
            ));
            builder.indent();
            builder
                .line("unsafe { core::slice::from_raw_parts(self.ptr, self.len) }");
            builder.dedent();
            builder.line("}");
            builder.blank();

            // as_slice_mut() - returns &mut [T]
            builder.line(&format!(
                "/// Returns the vec as a `&mut [{}]` slice.",
                prefixed_inner
            ));
            builder.line("#[inline]");
            builder.line(&format!(
                "pub fn as_slice_mut(&mut self) -> &mut [{}] {{",
                prefixed_inner
            ));
            builder.indent();
            builder
                .line("unsafe { core::slice::from_raw_parts_mut(self.ptr as *mut _, self.len) }");
            builder.dedent();
            builder.line("}");
            builder.blank();

            // NOTE: len(), capacity(), is_empty(), get() are now generated via C-API wrappers
            // from api.json and implemented in impl_vec! macro. We only generate methods here
            // that are NOT part of the C-API (as_slice_mut, get_mut, iter, iter_mut, etc.)

            // get_mut()
            builder.line(&format!("/// Returns a mutable reference to an element at the given index, or `None` if out of bounds."));
            builder.line("#[inline]");
            builder.line(&format!(
                "pub fn get_mut(&mut self, index: usize) -> Option<&mut {}> {{",
                prefixed_inner
            ));
            builder.indent();
            builder.line("self.as_slice_mut().get_mut(index)");
            builder.dedent();
            builder.line("}");
            builder.blank();

            // iter_mut()
            builder.line(&format!(
                "/// Returns a mutable iterator over the elements."
            ));
            builder.line("#[inline]");
            builder.line(&format!(
                "pub fn iter_mut(&mut self) -> core::slice::IterMut<'_, {}> {{",
                prefixed_inner
            ));
            builder.indent();
            builder.line("self.as_slice_mut().iter_mut()");
            builder.dedent();
            builder.line("}");

            builder.dedent();
            builder.line("}");
            builder.blank();

            // AsRef<[T]> implementation
            builder.line(&format!(
                "impl AsRef<[{}]> for {} {{",
                prefixed_inner, prefixed_name
            ));
            builder.indent();
            builder.line(&format!("fn as_ref(&self) -> &[{}] {{", prefixed_inner));
            builder.indent();
            builder.line("self.as_slice()");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();

            // Deref to [T] implementation
            builder.line(&format!("impl core::ops::Deref for {} {{", prefixed_name));
            builder.indent();
            builder.line(&format!("type Target = [{}];", prefixed_inner));
            builder.line("fn deref(&self) -> &Self::Target {");
            builder.indent();
            builder.line("self.as_slice()");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();

            // DerefMut implementation
            builder.line(&format!(
                "impl core::ops::DerefMut for {} {{",
                prefixed_name
            ));
            builder.indent();
            builder.line("fn deref_mut(&mut self) -> &mut Self::Target {");
            builder.indent();
            builder.line("self.as_slice_mut()");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();

            // Index implementation
            builder.line(&format!(
                "impl core::ops::Index<usize> for {} {{",
                prefixed_name
            ));
            builder.indent();
            builder.line(&format!("type Output = {};", prefixed_inner));
            builder.line("fn index(&self, index: usize) -> &Self::Output {");
            builder.indent();
            builder.line("&self.as_slice()[index]");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();

            // IndexMut implementation
            builder.line(&format!(
                "impl core::ops::IndexMut<usize> for {} {{",
                prefixed_name
            ));
            builder.indent();
            builder.line("fn index_mut(&mut self, index: usize) -> &mut Self::Output {");
            builder.indent();
            builder.line("&mut self.as_slice_mut()[index]");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();

            // IntoIterator for &Vec
            builder.line(&format!(
                "impl<'a> IntoIterator for &'a {} {{",
                prefixed_name
            ));
            builder.indent();
            builder.line(&format!("type Item = &'a {};", prefixed_inner));
            builder.line(&format!(
                "type IntoIter = core::slice::Iter<'a, {}>;",
                prefixed_inner
            ));
            builder.line("fn into_iter(self) -> Self::IntoIter {");
            builder.indent();
            builder.line("self.as_slice().iter()");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();

            // IntoIterator for &mut Vec
            builder.line(&format!(
                "impl<'a> IntoIterator for &'a mut {} {{",
                prefixed_name
            ));
            builder.indent();
            builder.line(&format!("type Item = &'a mut {};", prefixed_inner));
            builder.line(&format!(
                "type IntoIter = core::slice::IterMut<'a, {}>;",
                prefixed_inner
            ));
            builder.line("fn into_iter(self) -> Self::IntoIter {");
            builder.indent();
            builder.line("self.as_slice_mut().iter_mut()");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();

            // From<Vec<T>> for AzVec<T> - allows easy conversion from std Vec
            // This requires the Vec type to have a destructor field
            //
            // IMPORTANT: We use External destructor with a custom drop function because:
            // - The Vec was allocated by the BINARY's allocator (user code)
            // - The library might use a DIFFERENT allocator
            // - DefaultRust would tell the library to free with its allocator = CRASH
            // - External(fn_ptr) calls back into the binary to free with the correct allocator
            let has_destructor = struct_def.fields.iter().any(|f| f.name == "destructor");
            if has_destructor {
                // Get the destructor type name (should end with "Destructor")
                let destructor_field = struct_def.fields.iter().find(|f| f.name == "destructor");
                if let Some(destructor_field) = destructor_field {
                    let prefixed_destructor = config.apply_prefix(&destructor_field.type_name);
                    // The destructor type should be VecDestructorType (function pointer type)
                    // e.g., DomVecDestructor -> DomVecDestructorType
                    let destructor_fn_type = format!("{}Type", prefixed_destructor);

                    // Generate the drop function that will be called to free the Vec
                    // This function runs in the BINARY context, using the BINARY allocator
                    // Note: We use *mut T (raw pointer) to match the C-ABI destructor signature
                    let drop_fn_name = format!("{}_external_drop", prefixed_name.to_lowercase());
                    builder.line(&format!(
                        "extern \"C\" fn {}(v: *mut {}) {{",
                        drop_fn_name, prefixed_name
                    ));
                    builder.indent();
                    builder.line("let v = unsafe { &mut *v };");
                    builder.line(&format!("match v.destructor {{ {}::AlreadyDestroyed | {}::NoDestructor => return, _ => {{ }} }}", prefixed_destructor, prefixed_destructor));
                    builder.line(&format!("v.destructor = {}::AlreadyDestroyed;", prefixed_destructor));
                    builder.line("if v.ptr.is_null() || v.cap == 0 { return; }");
                    builder.line("unsafe {");
                    builder.indent();
                    builder.line(&format!(
                        "let _ = alloc::vec::Vec::from_raw_parts(v.ptr as *mut {}, v.len, v.cap);",
                        prefixed_inner
                    ));
                    builder.dedent();
                    builder.line("}");
                    builder.line("v.ptr = core::ptr::null();");
                    builder.line("v.len = 0;");
                    builder.line("v.cap = 0;");
                    builder.dedent();
                    builder.line("}");
                    builder.blank();

                    builder.line(&format!(
                        "impl From<alloc::vec::Vec<{}>> for {} {{",
                        prefixed_inner, prefixed_name
                    ));
                    builder.indent();
                    builder.line(&format!(
                        "fn from(v: alloc::vec::Vec<{}>) -> Self {{",
                        prefixed_inner
                    ));
                    builder.indent();
                    builder.line("let ptr = v.as_ptr();");
                    builder.line("let len = v.len();");
                    builder.line("let cap = v.capacity();");
                    builder.line("core::mem::forget(v);");
                    builder.line("Self {");
                    builder.indent();
                    builder.line("ptr,");
                    builder.line("len,");
                    builder.line("cap,");
                    builder.line(&format!(
                        "destructor: {}::External({} as {}),",
                        prefixed_destructor, drop_fn_name, destructor_fn_type
                    ));
                    builder.dedent();
                    builder.line("}");
                    builder.dedent();
                    builder.line("}");
                    builder.dedent();
                    builder.line("}");
                    builder.blank();
                }
            }
        }
    }

    /// Generate convenience methods for VecRef types (From<&[T]>, From<&Vec<T>>, as_slice)
    /// VecRef types are used for passing slices across the C-ABI boundary.
    fn generate_vec_ref_convenience_methods(
        &self,
        builder: &mut CodeBuilder,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        let _prefix = &config.type_prefix;

        // Find all VecRef types in the IR (structs ending with "VecRef" that have ptr, len fields but NO cap)
        for struct_def in &ir.structs {
            // Check if this looks like a VecRef type
            if !struct_def.name.ends_with("VecRef") {
                continue;
            }

            // Check for ptr, len fields (but NOT cap - that's a Vec, not a VecRef)
            let has_ptr = struct_def.fields.iter().any(|f| f.name == "ptr");
            let has_len = struct_def.fields.iter().any(|f| f.name == "len");
            let has_cap = struct_def.fields.iter().any(|f| f.name == "cap");

            if !has_ptr || !has_len || has_cap {
                continue;
            }

            // Derive the inner type from the VecRef name
            // e.g., "TessellatedSvgNodeVecRef" -> "TessellatedSvgNode"
            let inner_type = match struct_def.name.strip_suffix("VecRef") {
                Some(inner) => inner.to_string(),
                None => continue,
            };

            // Check if the inner type actually exists in the IR
            let inner_type_exists = ir.structs.iter().any(|s| s.name == inner_type)
                || ir.enums.iter().any(|e| e.name == inner_type);

            // Map primitive VecRef names to Rust primitive types
            let rust_inner_type = match inner_type.as_str() {
                "U8" => Some("u8"),
                "U16" => Some("u16"),
                "U32" => Some("u32"),
                "U64" => Some("u64"),
                "I8" => Some("i8"),
                "I16" => Some("i16"),
                "I32" => Some("i32"),
                "I64" => Some("i64"),
                "F32" => Some("f32"),
                "F64" => Some("f64"),
                "Usize" => Some("usize"),
                "Isize" => Some("isize"),
                "GLuint" => Some("GLuint"),
                "GLint" => Some("GLint"),
                "GLfloat" => Some("GLfloat"),
                _ => None,
            };

            if !inner_type_exists && rust_inner_type.is_none() {
                continue;
            }

            // Use the Rust primitive type if available, otherwise use the prefixed inner type
            let prefixed_name = config.apply_prefix(&struct_def.name);
            let prefixed_inner = if let Some(primitive) = rust_inner_type {
                primitive.to_string()
            } else {
                config.apply_prefix(&inner_type)
            };

            // Derive the corresponding Vec type name (remove "Ref" suffix)
            let vec_type_name = format!("{}Vec", inner_type);
            let prefixed_vec = config.apply_prefix(&vec_type_name);

            // as_slice() method
            builder.line(&format!("impl {} {{", prefixed_name));
            builder.indent();

            builder.line(&format!(
                "/// Returns the vec ref as a `&[{}]` slice.",
                prefixed_inner
            ));
            builder.line("#[inline]");
            builder.line(&format!(
                "pub fn as_slice(&self) -> &[{}] {{",
                prefixed_inner
            ));
            builder.indent();
            builder.line("if self.ptr.is_null() || self.len == 0 {");
            builder.indent();
            builder.line("&[]");
            builder.dedent();
            builder.line("} else {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ core::slice::from_raw_parts(self.ptr as *const {}, self.len) }}",
                prefixed_inner
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();

            builder.line("/// Returns the number of elements.");
            builder.line("#[inline]");
            builder.line("pub fn len(&self) -> usize {");
            builder.indent();
            builder.line("self.len");
            builder.dedent();
            builder.line("}");
            builder.blank();

            builder.line("/// Returns `true` if empty.");
            builder.line("#[inline]");
            builder.line("pub fn is_empty(&self) -> bool {");
            builder.indent();
            builder.line("self.len == 0");
            builder.dedent();
            builder.line("}");

            builder.dedent();
            builder.line("}");
            builder.blank();

            // From<&[T]> for VecRef
            builder.line(&format!(
                "impl<'a> From<&'a [{}]> for {} {{",
                prefixed_inner, prefixed_name
            ));
            builder.indent();
            builder.line(&format!(
                "fn from(slice: &'a [{}]) -> Self {{",
                prefixed_inner
            ));
            builder.indent();
            builder.line("Self {");
            builder.indent();
            builder.line("ptr: slice.as_ptr() as *const _,");
            builder.line("len: slice.len(),");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();

            // From<&Vec<T>> for VecRef (if a corresponding Vec type exists)
            // Check if the Vec type exists in the IR
            let vec_exists = ir.structs.iter().any(|s| s.name == vec_type_name);
            if vec_exists {
                builder.line(&format!(
                    "impl<'a> From<&'a {}> for {} {{",
                    prefixed_vec, prefixed_name
                ));
                builder.indent();
                builder.line(&format!("fn from(vec: &'a {}) -> Self {{", prefixed_vec));
                builder.indent();
                builder.line("Self {");
                builder.indent();
                builder.line("ptr: vec.ptr as *const _,");
                builder.line("len: vec.len,");
                builder.dedent();
                builder.line("}");
                builder.dedent();
                builder.line("}");
                builder.dedent();
                builder.line("}");
                builder.blank();
            }

            // AsRef<[T]> implementation
            builder.line(&format!(
                "impl AsRef<[{}]> for {} {{",
                prefixed_inner, prefixed_name
            ));
            builder.indent();
            builder.line(&format!("fn as_ref(&self) -> &[{}] {{", prefixed_inner));
            builder.indent();
            builder.line("self.as_slice()");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }

    /// Generate impl blocks with methods for each type
    fn generate_impl_blocks(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        use std::collections::BTreeSet;

        let mut builder = CodeBuilder::new(&config.indent);

        // Collect all unique class names
        let class_names: BTreeSet<&str> = ir.functions.iter()
            .filter(|f| !f.kind.is_trait_function()) // Skip trait functions
            .map(|f| f.class_name.as_str())
            .collect();

        for class_name in class_names {
            if !config.should_include_type(class_name) {
                continue;
            }

            let prefixed_name = config.apply_prefix(class_name);
            let methods: Vec<_> = ir
                .functions_for_class(class_name)
                .filter(|f| !f.kind.is_trait_function())
                .collect();

            if methods.is_empty() {
                continue;
            }

            builder.line(&format!("impl {} {{", prefixed_name));
            builder.indent();

            for func in methods {
                self.generate_method(&mut builder, func, ir, config);
            }

            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        Ok(builder.finish())
    }

    /// Generate a single method within an impl block
    fn generate_method(
        &self,
        builder: &mut CodeBuilder,
        func: &FunctionDef,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        let method_name = escape_rust_keyword(&to_snake_case(&func.method_name));

        // Build a map of callback wrapper types for quick lookup
        // Maps: "IFrameCallback" -> ("IFrameCallbackType", "cb", "ctx")
        let callback_wrappers: std::collections::HashMap<&str, (&str, &str, &str)> = ir
            .structs
            .iter()
            .filter_map(|s| {
                s.callback_wrapper_info.as_ref().map(|info| {
                    (
                        s.name.as_str(),
                        (
                            info.callback_typedef_name.as_str(),
                            info.callback_field_name.as_str(),
                            info.context_field_name.as_str(),
                        ),
                    )
                })
            })
            .collect();

        // Build a set of callback typedef names (function pointer types) to exclude from Into generics
        let callback_typedefs: std::collections::HashSet<&str> = ir
            .callback_typedefs
            .iter()
            .map(|cb| cb.name.as_str())
            .collect();

        // Build argument list
        let mut args = Vec::new();
        let mut call_args = Vec::new();
        let mut self_arg: Option<String> = None;
        let mut generic_params: Vec<String> = Vec::new();
        let mut generic_counter = 0u8;

        // The snake_case class name is used as the self parameter name in C-ABI
        let self_param_name = to_snake_case(&func.class_name);

        for arg in &func.args {
            // An argument is "self" if:
            // 1. Its name is "self", OR
            // 2. Its name is the lowercase class name AND its type matches the class name, OR
            // 3. Its name is "object" AND its type matches the class name
            let is_self = arg.name == "self"
                || (arg.name == self_param_name && arg.type_name == func.class_name)
                || (arg.name == "object" && arg.type_name == func.class_name);

            if is_self {
                // Store self argument to insert at the beginning
                let self_str = match arg.ref_kind {
                    ArgRefKind::Owned => "self".to_string(),
                    ArgRefKind::Ref | ArgRefKind::Ptr => "&self".to_string(),
                    ArgRefKind::RefMut | ArgRefKind::PtrMut => "&mut self".to_string(),
                };
                self_arg = Some(self_str);
                call_args.push("self".to_string());
            } else {
                let arg_type = config.apply_prefix(&arg.type_name);

                // Check if this type is a callback wrapper
                // If so, accept the CallbackType (fn pointer) and pass it directly
                // (The C-ABI function now accepts CallbackType directly, not the wrapper struct)
                // BUT: Don't apply this transformation when:
                // - we're in a method of the callback wrapper itself (e.g., deep_copy on IFrameCallback)
                // - this is an EnumVariantConstructor (e.g., OptionCallback::Some needs Callback, not CallbackType)
                let is_method_of_this_callback = arg.type_name == func.class_name;
                let is_enum_variant_constructor =
                    matches!(func.kind, FunctionKind::EnumVariantConstructor);

                if !is_method_of_this_callback && !is_enum_variant_constructor {
                    if let Some((callback_type_name, _callback_field_name, _context_field_name)) =
                        callback_wrappers.get(arg.type_name.as_str())
                    {
                        let fn_ptr_type = config.apply_prefix(callback_type_name);
                        args.push(format!("{}: {}", arg.name, fn_ptr_type));
                        // The C-ABI function now expects the fn pointer type directly
                        call_args.push(arg.name.clone());
                        continue;
                    }
                }

                // Check if this type should use Into<T>
                // Use Into for all non-primitive types that are passed by value
                // EXCEPT:
                // - callback typedefs (function pointers) and callback wrappers
                // - Ref types (e.g. U8VecRef) - slice references shouldn't use Into
                //
                // Vec types (e.g. StyleTransformVec) DO support Into:
                //   fn append_children(children: impl Into<DomVec>) allows vec![...] directly
                //
                // This allows ergonomic API like:
                //   Dom::create_text("hello")  where &str: Into<AzString>
                //   Dom::append(button)  where button: Button (if Button: Into<Dom>)
                //   Dom::append_children(vec![child1, child2])  where Vec<Dom>: Into<DomVec>
                let is_callback_type = callback_typedefs.contains(arg.type_name.as_str())
                    || callback_wrappers.contains_key(arg.type_name.as_str());
                let is_ref_type =
                    arg.type_name.ends_with("Ref") || arg.type_name.ends_with("RefMut");
                let use_into =
                    !is_primitive_type(&arg.type_name) && !is_callback_type && !is_ref_type;

                if use_into && matches!(arg.ref_kind, ArgRefKind::Owned) {
                    // Use a generic parameter like I0, I1, I2...
                    let generic_name = format!("I{}", generic_counter);
                    generic_counter += 1;
                    generic_params.push(format!("{}: Into<{}>", generic_name, arg_type));
                    args.push(format!("{}: {}", arg.name, generic_name));
                    call_args.push(format!("{}.into()", arg.name));
                } else {
                    let arg_str = match arg.ref_kind {
                        ArgRefKind::Owned => format!("{}: {}", arg.name, arg_type),
                        ArgRefKind::Ref | ArgRefKind::Ptr => format!("{}: &{}", arg.name, arg_type),
                        ArgRefKind::RefMut | ArgRefKind::PtrMut => {
                            format!("{}: &mut {}", arg.name, arg_type)
                        }
                    };
                    args.push(arg_str);
                    call_args.push(arg.name.clone());
                }
            }
        }

        // Insert self at the beginning if present
        if let Some(self_str) = self_arg {
            args.insert(0, self_str);
        }

        let return_type = func
            .return_type
            .as_ref()
            .map(|r| format!(" -> {}", config.apply_prefix(r)))
            .unwrap_or_default();

        let c_func_name = &func.c_name;

        // Build generics string if we have any generic parameters
        let generics = if generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", generic_params.join(", "))
        };

        // Generate the method
        builder.line(&format!(
            "pub fn {}{}({}){} {{ unsafe {{ {}({}) }} }}",
            method_name,
            generics,
            args.join(", "),
            return_type,
            c_func_name,
            call_args.join(", ")
        ));
    }
}

// ============================================================================
// Helper Methods - Type Aliases
// ============================================================================

impl RustGenerator {
    fn generate_gl_type_aliases(&self, builder: &mut CodeBuilder) {
        // GL type aliases as seen in the existing dll_api.rs
        builder.line("pub type GLenum = u32;");
        builder.line("pub type GLboolean = u8;");
        builder.line("pub type GLbitfield = u32;");
        builder.line("pub type GLbyte = i8;");
        builder.line("pub type GLshort = i16;");
        builder.line("pub type GLint = i32;");
        builder.line("pub type GLsizei = i32;");
        builder.line("pub type GLubyte = u8;");
        builder.line("pub type GLushort = u16;");
        builder.line("pub type GLuint = u32;");
        builder.line("pub type GLfloat = f32;");
        builder.line("pub type GLclampf = f32;");
        builder.line("pub type GLdouble = f64;");
        builder.line("pub type GLclampd = f64;");
        builder.line("pub type GLintptr = isize;");
        builder.line("pub type GLsizeiptr = isize;");
        builder.line("pub type GLint64 = i64;");
        builder.line("pub type GLuint64 = u64;");
    }

    fn generate_primitive_aliases(&self, builder: &mut CodeBuilder) {
        // c_void is already imported via `use core::ffi::c_void;`
        // so we don't need to define it as a type alias
    }

    fn generate_reexports(&self, builder: &mut CodeBuilder, inner_module: &str) {
        builder.line(&format!("pub use {}::dll::*;", inner_module));
    }

    /// Generate simple Rust API without module wrappers
    /// Used for rust_public_api which generates flat type definitions
    fn generate_simple_rust_api(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // File header
        builder.line("// Auto-generated by azul-doc codegen v2");
        builder.line("// DO NOT EDIT MANUALLY");
        builder.blank();

        // Imports
        for import in &config.imports {
            builder.line(import);
        }
        if !config.imports.is_empty() {
            builder.blank();
        }

        // GL type aliases
        builder.line("// --- GL Type Aliases ---");
        self.generate_gl_type_aliases(&mut builder);
        builder.blank();

        // Type definitions
        if config.struct_mode != StructMode::None {
            builder.line("// --- Type Definitions ---");
            let types = self.generate_types(ir, config)?;
            builder.raw(&types);
        }

        // Trait implementations (if using derive, they're already on types)
        if !matches!(config.trait_impl_mode, TraitImplMode::UsingDerive) {
            builder.line("// --- Trait Implementations ---");
            let trait_impls = self.generate_trait_impls(ir, config)?;
            builder.raw(&trait_impls);
        }

        // Method implementations (impl blocks)
        builder.line("// --- Method Implementations ---");
        let impl_blocks = self.generate_impl_blocks(ir, config)?;
        builder.raw(&impl_blocks);

        // Rust-only generic methods (not part of C-ABI)
        builder.line("// --- Rust-Only Generic Methods ---");
        let rust_only = self.generate_rust_only_impls(ir, config)?;
        builder.raw(&rust_only);

        Ok(builder.finish())
    }
}

// ============================================================================
// Type Generation
// ============================================================================

impl RustGenerator {
    fn generate_type_alias(
        &self,
        builder: &mut CodeBuilder,
        type_alias: &TypeAliasDef,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&type_alias.name);

        // Target types should also be prefixed if they're not primitives
        let target_base =
            if is_primitive_type(&type_alias.target) || type_alias.target.contains("::") {
                type_alias.target.clone()
            } else {
                config.apply_prefix(&type_alias.target)
            };

        // Build the full target type including generic arguments
        let target = if type_alias.generic_args.is_empty() {
            target_base
        } else {
            // Apply prefix to each generic argument
            let prefixed_args: Vec<String> = type_alias
                .generic_args
                .iter()
                .map(|arg| {
                    if is_primitive_type(arg) || arg.contains("::") {
                        arg.clone()
                    } else {
                        config.apply_prefix(arg)
                    }
                })
                .collect();
            format!("{}<{}>", target_base, prefixed_args.join(", "))
        };

        builder.line(&format!("pub type {} = {};", name, target));
        builder.blank();
    }

    fn generate_callback_typedef(
        &self,
        builder: &mut CodeBuilder,
        callback: &CallbackTypedefDef,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&callback.name);

        if config.callback_typedef_use_external {
            if let Some(ref external) = callback.external_path {
                builder.line(&format!("pub type {} = {};", name, external));
                builder.blank();
                return;
            }
        }

        // Generate function pointer signature
        // Note: For type aliases, we only need types, not names: fn(Type1, Type2) -> Return
        let args: Vec<String> = callback
            .args
            .iter()
            .map(|arg| {
                let type_name = config.apply_prefix(&arg.type_name);
                let ref_prefix = match arg.ref_kind {
                    ArgRefKind::Owned => "",
                    ArgRefKind::Ref => "&",
                    ArgRefKind::RefMut => "&mut ",
                    ArgRefKind::Ptr => "*const ",
                    ArgRefKind::PtrMut => "*mut ",
                };
                format!("{}{}", ref_prefix, type_name)
            })
            .collect();

        let return_str = callback
            .return_type
            .as_ref()
            .map(|r| format!(" -> {}", config.apply_prefix(r)))
            .unwrap_or_default();

        builder.line(&format!(
            "pub type {} = extern \"C\" fn({}){};",
            name,
            args.join(", "),
            return_str
        ));
        builder.blank();
    }

    fn generate_struct(
        &self,
        builder: &mut CodeBuilder,
        struct_def: &StructDef,
        _ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&struct_def.name);

        // Add generic parameters if present
        let generics = if struct_def.generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", struct_def.generic_params.join(", "))
        };
        let full_name = format!("{}{}", name, generics);

        // Doc comment
        if !struct_def.doc.is_empty() {
            for doc_line in &struct_def.doc {
                builder.line(&format!("/// {}", doc_line));
            }
        } else {
            builder.line(&format!("/// `{}` struct", name));
        }

        // Copy is a marker trait that cannot be implemented manually or via transmute
        // If the source type explicitly derives Copy, we must derive it here too
        // Note: Copy requires Clone, so Copy types must also derive Clone
        if struct_def.traits.is_copy {
            builder.line("#[derive(Copy)]");
        }
        // Derive Clone if:
        // 1. The type is Copy (Copy requires Clone as supertrait), OR
        // 2. clone_is_derived is true AND we're NOT using C-API trait impls
        // When using UsingCAPI for non-Copy types, Clone is implemented via C-ABI function calls
        let clone_via_capi = matches!(config.trait_impl_mode, TraitImplMode::UsingCAPI);
        let need_derive_clone = struct_def.traits.is_copy
            || (struct_def.traits.clone_is_derived && !clone_via_capi);
        if need_derive_clone {
            builder.line("#[derive(Clone)]");
        }

        // Repr attribute
        if let Some(ref repr) = struct_def.repr {
            builder.line(&format!("#[repr({})]", repr));
        } else {
            builder.line("#[repr(C)]");
        }

        // Struct definition
        if struct_def.fields.is_empty() {
            builder.line(&format!("pub struct {};", full_name));
        } else {
            builder.line(&format!("pub struct {} {{", full_name));
            builder.indent();
            for field in &struct_def.fields {
                let field_type = self.format_field_type(&field.type_name, &field.ref_kind, config);
                let visibility = if field.is_public {
                    "pub "
                } else {
                    "pub(crate) "
                };
                builder.line(&format!("{}{}: {},", visibility, field.name, field_type));
            }
            builder.dedent();
            builder.line("}");
        }
        builder.blank();
    }

    fn generate_enum(
        &self,
        builder: &mut CodeBuilder,
        enum_def: &EnumDef,
        _ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&enum_def.name);

        // Add generic parameters if present
        let generics = if enum_def.generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", enum_def.generic_params.join(", "))
        };
        let full_name = format!("{}{}", name, generics);

        // Doc comment
        if !enum_def.doc.is_empty() {
            for doc_line in &enum_def.doc {
                builder.line(&format!("/// {}", doc_line));
            }
        } else {
            builder.line(&format!("/// `{}` struct", name));
        }

        // Copy is a marker trait that cannot be implemented manually or via transmute
        // If the source type explicitly derives Copy, we must derive it here too
        // Note: Copy requires Clone, so Copy types must also derive Clone
        if enum_def.traits.is_copy {
            builder.line("#[derive(Copy)]");
        }
        // Derive Clone if:
        // 1. The type is Copy (Copy requires Clone as supertrait), OR
        // 2. clone_is_derived is true AND we're NOT using C-API trait impls
        // When using UsingCAPI for non-Copy types, Clone is implemented via C-ABI function calls
        let clone_via_capi = matches!(config.trait_impl_mode, TraitImplMode::UsingCAPI);
        let need_derive_clone = enum_def.traits.is_copy
            || (enum_def.traits.clone_is_derived && !clone_via_capi);
        if need_derive_clone {
            builder.line("#[derive(Clone)]");
        }

        // Repr attribute - automatically determine based on whether enum has variant data
        // Enums with variant data (tagged unions) need repr(C, u8) for proper C ABI
        // We ignore api.json "repr" field for enums - it's always implicitly calculable
        if enum_def.is_union {
            builder.line("#[repr(C, u8)]");
        } else {
            builder.line("#[repr(C)]");
        }

        // Enum definition
        builder.line(&format!("pub enum {} {{", full_name));
        builder.indent();
        for variant in &enum_def.variants {
            match &variant.kind {
                EnumVariantKind::Unit => {
                    builder.line(&format!("{},", variant.name));
                }
                EnumVariantKind::Tuple(types) => {
                    let types_str: Vec<String> =
                        types.iter().map(|(t, rk)| self.format_field_type(t, rk, config)).collect();
                    builder.line(&format!("{}({}),", variant.name, types_str.join(", ")));
                }
                EnumVariantKind::Struct(fields) => {
                    builder.line(&format!("{} {{", variant.name));
                    builder.indent();
                    for field in fields {
                        let field_type = config.apply_prefix(&field.type_name);
                        builder.line(&format!("{}: {},", field.name, field_type));
                    }
                    builder.dedent();
                    builder.line("},");
                }
            }
        }
        builder.dedent();
        builder.line("}");
        builder.blank();
    }

    fn format_field_type(
        &self,
        type_name: &str,
        ref_kind: &FieldRefKind,
        config: &CodegenConfig,
    ) -> String {
        let prefixed = config.apply_prefix(type_name);
        match ref_kind {
            FieldRefKind::Owned => prefixed,
            FieldRefKind::Ref => format!("&{}", prefixed),
            FieldRefKind::RefMut => format!("&mut {}", prefixed),
            FieldRefKind::Ptr => format!("*const {}", prefixed),
            FieldRefKind::PtrMut => format!("*mut {}", prefixed),
            FieldRefKind::Boxed => format!("Box<{}>", prefixed),
            FieldRefKind::OptionBoxed => format!("Option<Box<{}>>", prefixed),
        }
    }
}

// ============================================================================
// Trait Implementation Generation - Using Transmute
// ============================================================================

impl RustGenerator {
    fn generate_transmute_trait_impls(
        &self,
        builder: &mut CodeBuilder,
        struct_def: &StructDef,
        config: &CodegenConfig,
        _external_crate: &str,
    ) {
        let name = config.apply_prefix(&struct_def.name);

        // Build generics string: "<T>" or "<T, U>" etc.
        let generics = if struct_def.generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", struct_def.generic_params.join(", "))
        };

        // Build impl generics: "impl<T>" or "impl<T: Clone>"
        let impl_generics = if struct_def.generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", struct_def.generic_params.join(", "))
        };

        let full_name = format!("{}{}", name, generics);

        let external_path = struct_def
            .external_path
            .as_ref()
            .map(|p| config.transform_external_path(p))
            .unwrap_or_else(|| format!("crate::{}", struct_def.name));

        // Clone impl - generate via transmute only if Clone is in custom_impls (not derived)
        // Types with clone_is_derived get Clone via #[derive(Clone)] in generate_struct
        // Skip for generic types (can't transmute dependent-sized types)
        if struct_def.traits.is_clone
            && !struct_def.traits.clone_is_derived
            && struct_def.generic_params.is_empty()
        {
            builder.line(&format!("impl Clone for {} {{", full_name));
            builder.indent();
            builder.line("fn clone(&self) -> Self {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ core::mem::transmute::<{}, {}>((*(self as *const {} as *const {})).clone()) }}",
                external_path, full_name, full_name, external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Debug impl - skip for generic types
        if struct_def.generic_params.is_empty() {
            builder.line(&format!("impl core::fmt::Debug for {} {{", full_name));
            builder.indent();
            builder.line("fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {");
            builder.indent();
            builder.line(&format!("f.debug_struct(\"{}\").finish()", name));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Default impl (if has_default) - skip for generic types
        if struct_def.traits.is_default && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl Default for {} {{", full_name));
            builder.indent();
            builder.line("fn default() -> Self {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ core::mem::transmute::<{}, {}>({}::default()) }}",
                external_path, full_name, external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // PartialEq impl - using byte comparison via transmute
        // Skip for generic types - size_of::<Self>() doesn't work in const context for generics
        if struct_def.traits.is_partial_eq && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl PartialEq for {} {{", full_name));
            builder.indent();
            builder.line("fn eq(&self, other: &Self) -> bool {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self) == core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Eq impl
        // Skip for generic types
        if struct_def.traits.is_eq && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl Eq for {} {{ }}", full_name));
            builder.blank();
        }

        // PartialOrd impl
        // Skip for generic types
        if struct_def.traits.is_partial_ord && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl PartialOrd for {} {{", full_name));
            builder.indent();
            builder.line("fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {");
            builder.indent();
            builder.line("Some(unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).cmp(core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other)) })");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Ord impl
        // Skip for generic types
        if struct_def.traits.is_ord && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl Ord for {} {{", full_name));
            builder.indent();
            builder.line("fn cmp(&self, other: &Self) -> core::cmp::Ordering {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).cmp(core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other)) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Hash impl
        // Skip for generic types
        if struct_def.traits.is_hash && struct_def.generic_params.is_empty() {
            builder.line(&format!("impl core::hash::Hash for {} {{", full_name));
            builder.indent();
            builder.line("fn hash<H: core::hash::Hasher>(&self, state: &mut H) {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).hash(state) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }

    fn generate_transmute_trait_impls_enum(
        &self,
        builder: &mut CodeBuilder,
        enum_def: &EnumDef,
        config: &CodegenConfig,
        _external_crate: &str,
    ) {
        // Skip generic enums entirely - can't transmute dependent-sized types
        if !enum_def.generic_params.is_empty() {
            return;
        }

        let name = config.apply_prefix(&enum_def.name);
        let full_name = name.clone(); // No generics since we skip generic enums

        let external_path = enum_def
            .external_path
            .as_ref()
            .map(|p| config.transform_external_path(p))
            .unwrap_or_else(|| format!("crate::{}", enum_def.name));

        // Clone impl - generate via transmute only if Clone is in custom_impls (not derived)
        // Types with clone_is_derived get Clone via #[derive(Clone)] in generate_enum
        if enum_def.traits.is_clone && !enum_def.traits.clone_is_derived {
            builder.line(&format!("impl Clone for {} {{", full_name));
            builder.indent();
            builder.line("fn clone(&self) -> Self {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ core::mem::transmute::<{}, {}>((*(self as *const {} as *const {})).clone()) }}",
                external_path, full_name, full_name, external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Debug impl
        builder.line(&format!("impl core::fmt::Debug for {} {{", full_name));
        builder.indent();
        builder.line("fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {");
        builder.indent();
        builder.line(&format!("f.debug_struct(\"{}\").finish()", name));
        builder.dedent();
        builder.line("}");
        builder.dedent();
        builder.line("}");
        builder.blank();

        // PartialEq impl
        // Skip for generic types - size_of::<Self>() doesn't work in const context for generics
        if enum_def.traits.is_partial_eq && enum_def.generic_params.is_empty() {
            builder.line(&format!("impl PartialEq for {} {{", full_name));
            builder.indent();
            builder.line("fn eq(&self, other: &Self) -> bool {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self) == core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Eq impl - Skip for generic types
        if enum_def.traits.is_eq && enum_def.generic_params.is_empty() {
            builder.line(&format!("impl Eq for {} {{ }}", full_name));
            builder.blank();
        }

        // PartialOrd impl - Skip for generic types
        if enum_def.traits.is_partial_ord && enum_def.generic_params.is_empty() {
            builder.line(&format!("impl PartialOrd for {} {{", full_name));
            builder.indent();
            builder.line("fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {");
            builder.indent();
            builder.line("Some(unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).cmp(core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other)) })");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Ord impl - Skip for generic types
        if enum_def.traits.is_ord && enum_def.generic_params.is_empty() {
            builder.line(&format!("impl Ord for {} {{", full_name));
            builder.indent();
            builder.line("fn cmp(&self, other: &Self) -> core::cmp::Ordering {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).cmp(core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(other)) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Hash impl - Skip for generic types
        if enum_def.traits.is_hash && enum_def.generic_params.is_empty() {
            builder.line(&format!("impl core::hash::Hash for {} {{", full_name));
            builder.indent();
            builder.line("fn hash<H: core::hash::Hasher>(&self, state: &mut H) {");
            builder.indent();
            builder.line("unsafe { core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self).hash(state) }");
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }
}

// ============================================================================
// Trait Implementation Generation - Using C-ABI
// ============================================================================

impl RustGenerator {
    fn generate_capi_trait_impls(
        &self,
        builder: &mut CodeBuilder,
        struct_def: &StructDef,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&struct_def.name);

        // Clone impl calling C-ABI function
        if struct_def.traits.is_clone && !struct_def.traits.is_copy {
            let deep_copy_fn = format!("{}_clone", name);
            builder.line(&format!("impl Clone for {} {{", name));
            builder.indent();
            builder.line("fn clone(&self) -> Self {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self) }}", deep_copy_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Drop impl calling C-ABI function
        if struct_def.traits.needs_delete() {
            let delete_fn = format!("{}_delete", name);
            builder.line(&format!("impl Drop for {} {{", name));
            builder.indent();
            builder.line("fn drop(&mut self) {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self) }}", delete_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }

    fn generate_capi_trait_impls_enum(
        &self,
        builder: &mut CodeBuilder,
        enum_def: &EnumDef,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&enum_def.name);

        // Clone impl calling C-ABI function
        if enum_def.traits.is_clone && !enum_def.traits.is_copy {
            let deep_copy_fn = format!("{}_clone", name);
            builder.line(&format!("impl Clone for {} {{", name));
            builder.indent();
            builder.line("fn clone(&self) -> Self {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self) }}", deep_copy_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Drop impl calling C-ABI function
        if enum_def.traits.needs_delete() {
            let delete_fn = format!("{}_delete", name);
            builder.line(&format!("impl Drop for {} {{", name));
            builder.indent();
            builder.line("fn drop(&mut self) {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self) }}", delete_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }
}

// ============================================================================
// Function Generation
// ============================================================================

impl RustGenerator {
    fn generate_function_definition(
        &self,
        builder: &mut CodeBuilder,
        func: &FunctionDef,
        ir: &CodegenIR,
        config: &CodegenConfig,
        no_mangle: bool,
    ) {
        // Attributes
        builder.line("#[allow(unused_variables)]");
        if no_mangle {
            builder.line("#[no_mangle]");
        }

        // Apply callback wrapper substitution for API functions (Constructor, Method, etc.)
        // NOT for trait functions (Delete, DeepCopy, etc.) which operate on the callback wrapper itself
        // NOT for EnumVariantConstructor - enum variants like OptionCallback::Some need exact types
        // for easier C code generation
        let should_substitute_callbacks = matches!(
            func.kind,
            FunctionKind::Constructor
                | FunctionKind::StaticMethod
                | FunctionKind::Method
                | FunctionKind::MethodMut
        );

        let args = if should_substitute_callbacks {
            self.format_function_args_for_cabi(func, ir, config)
        } else {
            self.format_function_args(func, config)
        };
        let return_str = func
            .return_type
            .as_ref()
            .map(|r| format!(" -> {}", config.apply_prefix(r)))
            .unwrap_or_default();

        let body = self.generate_function_body(func, ir, config);

        // Single-line or multi-line based on body
        builder.line(&format!(
            "pub unsafe extern \"C\" fn {}({}){} {}",
            func.c_name, args, return_str, body
        ));
    }

    fn generate_function_body(
        &self,
        func: &FunctionDef,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) -> String {
        let prefixed_name = config.apply_prefix(&func.class_name);

        // Get external path for this type, transforming if needed
        let external_path = ir
            .type_to_external
            .get(&func.class_name)
            .map(|p| config.transform_external_path(p))
            .unwrap_or_else(|| format!("crate::{}", func.class_name));

        // Generate body based on function kind
        match func.kind {
            FunctionKind::Delete => {
                // For delete, we call drop_in_place to run the destructor.
                // The type is passed by pointer, so we need to dereference and drop it.
                // This works for both stack-allocated (repr(C)) and heap-allocated types.
                let arg_name = func
                    .args
                    .first()
                    .map(|a| a.name.as_str())
                    .unwrap_or("instance");
                format!(
                    "{{ core::ptr::drop_in_place({} as *mut {} as *mut {}); }}",
                    arg_name, prefixed_name, external_path
                )
            }
            FunctionKind::DeepCopy => {
                let arg_name = func
                    .args
                    .first()
                    .map(|a| a.name.as_str())
                    .unwrap_or("object");
                format!(
                    "{{ core::mem::transmute::<{}, {}>((*({}  as *const {} as *const {})).clone()) }}",
                    external_path, prefixed_name, arg_name, prefixed_name, external_path
                )
            }
            FunctionKind::PartialEq => {
                format!(
                    "{{ (*(a as *const {} as *const {})) == (*(b as *const {} as *const {})) }}",
                    prefixed_name, external_path, prefixed_name, external_path
                )
            }
            FunctionKind::PartialCmp => {
                format!(
                    "{{ match (*(a as *const {} as *const {})).partial_cmp(&*(b as *const {} as *const {})) {{
        Some(core::cmp::Ordering::Less) => 0,
        Some(core::cmp::Ordering::Equal) => 1,
        Some(core::cmp::Ordering::Greater) => 2,
        None => 255,
    }} }}",
                    prefixed_name, external_path, prefixed_name, external_path
                )
            }
            FunctionKind::Cmp => {
                format!(
                    "{{ match (*(a as *const {} as *const {})).cmp(&*(b as *const {} as *const {})) {{
        core::cmp::Ordering::Less => 0,
        core::cmp::Ordering::Equal => 1,
        core::cmp::Ordering::Greater => 2,
    }} }}",
                    prefixed_name, external_path, prefixed_name, external_path
                )
            }
            FunctionKind::Hash => {
                let arg_name = func
                    .args
                    .first()
                    .map(|a| a.name.as_str())
                    .unwrap_or("object");
                format!(
                    "{{ {{
        use core::hash::{{Hash, Hasher}};
        let mut hasher = std::collections::hash_map::DefaultHasher::new();
        (*({} as *const {} as *const {})).hash(&mut hasher);
        hasher.finish()
    }} }}",
                    arg_name, prefixed_name, external_path
                )
            }
            FunctionKind::Default => {
                format!(
                    "{{ core::mem::transmute::<{}, {}>({}::default()) }}",
                    external_path, prefixed_name, external_path
                )
            }
            FunctionKind::DebugToString => {
                let arg_name = func
                    .args
                    .first()
                    .map(|a| a.name.as_str())
                    .unwrap_or("instance");
                format!(
                    "{{ let s = format!(\"{{:#?}}\", *({} as *const {} as *const {})); {}String::from(s.as_str()) }}",
                    arg_name, prefixed_name, external_path, config.type_prefix
                )
            }
            FunctionKind::Constructor
            | FunctionKind::StaticMethod
            | FunctionKind::Method
            | FunctionKind::MethodMut
            | FunctionKind::EnumVariantConstructor => {
                // For regular API functions, use the fn_body from api.json
                // and transform it using generate_transmuted_fn_body
                if let Some(ref body) = func.fn_body {
                    // Build the type_to_external map for this function
                    let type_to_external: std::collections::BTreeMap<String, String> = ir
                        .type_to_external
                        .iter()
                        .map(|(k, v)| (config.apply_prefix(k), v.clone()))
                        .collect();

                    // Format fn_args - for EnumVariantConstructor, use the regular version
                    // (no callback wrapper substitution) because enum variants need exact types.
                    // For other functions, use the CABI version which replaces callback wrappers
                    // with their raw fn pointer types.
                    let fn_args = if matches!(func.kind, FunctionKind::EnumVariantConstructor) {
                        self.format_function_args(func, config)
                    } else {
                        self.format_function_args_for_cabi(func, ir, config)
                    };

                    // Determine return type with prefix
                    let return_type = func
                        .return_type
                        .as_ref()
                        .map(|r| config.apply_prefix(r))
                        .unwrap_or_default();

                    // Use the existing transmuted fn_body generator
                    // EnumVariantConstructor counts as a constructor for fn_body transformation
                    let is_constructor = matches!(
                        func.kind,
                        FunctionKind::Constructor
                            | FunctionKind::StaticMethod
                            | FunctionKind::EnumVariantConstructor
                    );
                    generate_transmuted_fn_body(
                        body,
                        &func.class_name,
                        is_constructor,
                        &return_type,
                        &config.type_prefix,
                        &type_to_external,
                        &fn_args,
                        true,             // is_for_dll
                        false,            // keep_self_name
                        false,            // force_clone_self
                        &BTreeSet::new(), // skip_args - empty, we want to transmute all args
                    )
                } else {
                    // No fn_body - generate error or stub
                    format!(
                        "{{ /* ERROR: No fn_body for {} */ unimplemented!() }}",
                        func.c_name
                    )
                }
            }
        }
    }

    fn generate_method_body(
        &self,
        func: &FunctionDef,
        ir: &CodegenIR,
        config: &CodegenConfig,
        external_path: &str,
        prefixed_name: &str,
    ) -> String {
        // Generate transmute calls for each argument
        let mut lines = Vec::new();
        lines.push("{".to_string());

        // Get the self argument name if this is a method
        let self_arg_name = match func.kind {
            FunctionKind::Method | FunctionKind::MethodMut => {
                func.args.first().map(|a| a.name.clone())
            }
            _ => None,
        };

        // Transmute each argument
        for arg in &func.args {
            let ext_type = ir
                .type_to_external
                .get(&arg.type_name)
                .cloned()
                .unwrap_or_else(|| {
                    // For primitive types, just use the type directly
                    if is_primitive_type(&arg.type_name) {
                        arg.type_name.clone()
                    } else {
                        format!("crate::{}", arg.type_name)
                    }
                });

            let transmute_expr = match arg.ref_kind {
                ArgRefKind::Ref => format!(
                    "    let {}: &{} = core::mem::transmute({});",
                    arg.name, ext_type, arg.name
                ),
                ArgRefKind::RefMut => format!(
                    "    let {}: &mut {} = core::mem::transmute({});",
                    arg.name, ext_type, arg.name
                ),
                ArgRefKind::Owned => {
                    if is_primitive_type(&arg.type_name) {
                        format!("    let {}: {} = {};", arg.name, ext_type, arg.name)
                    } else {
                        format!(
                            "    let {}: {} = core::mem::transmute({});",
                            arg.name, ext_type, arg.name
                        )
                    }
                }
                ArgRefKind::Ptr | ArgRefKind::PtrMut => format!(
                    "    let {}: {} = core::mem::transmute({});",
                    arg.name, ext_type, arg.name
                ),
            };
            lines.push(transmute_expr);
        }

        // Generate the call
        let args_for_call: Vec<String> = func
            .args
            .iter()
            .skip(if self_arg_name.is_some() { 1 } else { 0 })
            .map(|a| a.name.clone())
            .collect();

        let call = if let Some(ref self_name) = self_arg_name {
            // Instance method call
            format!(
                "    let __result = {}.{}({});",
                self_name,
                func.method_name,
                args_for_call.join(", ")
            )
        } else {
            // Static method or constructor
            format!(
                "    let __result: {} = {}::{}({});",
                external_path,
                external_path,
                func.method_name,
                args_for_call.join(", ")
            )
        };
        lines.push(call);

        // Transmute result back if needed
        if let Some(ref ret_type) = func.return_type {
            let ret_prefixed = config.apply_prefix(ret_type);
            let ret_external = ir
                .type_to_external
                .get(ret_type)
                .cloned()
                .unwrap_or_else(|| {
                    if is_primitive_type(ret_type) {
                        ret_type.clone()
                    } else {
                        format!("crate::{}", ret_type)
                    }
                });
            if is_primitive_type(ret_type) {
                lines.push("    __result".to_string());
            } else {
                lines.push(format!(
                    "    core::mem::transmute::<{}, {}>(__result)",
                    ret_external, ret_prefixed
                ));
            }
        } else {
            // No return, discard result
            lines.push("    let _ = __result;".to_string());
        }

        lines.push("}".to_string());
        lines.join("\n")
    }

    fn generate_function_declaration(
        &self,
        builder: &mut CodeBuilder,
        func: &FunctionDef,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) {
        // Use format_function_args_for_cabi for API functions (substitutes callback wrappers with fn pointers)
        // Use format_function_args for EnumVariantConstructor (keeps Callback structs for easier C code)
        let should_substitute_callbacks = matches!(
            func.kind,
            FunctionKind::Constructor
                | FunctionKind::StaticMethod
                | FunctionKind::Method
                | FunctionKind::MethodMut
        );
        let args = if should_substitute_callbacks {
            self.format_function_args_for_cabi(func, ir, config)
        } else {
            self.format_function_args(func, config)
        };
        let return_str = func
            .return_type
            .as_ref()
            .map(|r| format!(" -> {}", config.apply_prefix(r)))
            .unwrap_or_default();

        builder.line(&format!("pub fn {}({}){};", func.c_name, args, return_str));
    }

    fn format_function_args(&self, func: &FunctionDef, config: &CodegenConfig) -> String {
        func.args
            .iter()
            .map(|arg| {
                let type_name = config.apply_prefix(&arg.type_name);
                let formatted = match arg.ref_kind {
                    ArgRefKind::Owned => type_name,
                    ArgRefKind::Ref => format!("&{}", type_name),
                    ArgRefKind::RefMut => format!("&mut {}", type_name),
                    ArgRefKind::Ptr => format!("*const {}", type_name),
                    ArgRefKind::PtrMut => format!("*mut {}", type_name),
                };
                format!("{}: {}", arg.name, formatted)
            })
            .collect::<Vec<_>>()
            .join(", ")
    }

    /// Format function arguments for C-ABI functions.
    /// This replaces callback wrapper types (like TimerCallback) with their
    /// raw function pointer types (like TimerCallbackType) so that C/C++ users
    /// can pass function pointers directly without wrapping in a struct.
    /// The underlying Rust function uses `T: Into<Callback>` so the raw fn pointer
    /// is automatically converted via the From impl.
    fn format_function_args_for_cabi(
        &self,
        func: &FunctionDef,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) -> String {
        // Build a map of callback wrapper types for quick lookup
        // Maps: "IFrameCallback" -> "IFrameCallbackType"
        let callback_wrappers: std::collections::HashMap<&str, &str> = ir
            .structs
            .iter()
            .filter_map(|s| {
                s.callback_wrapper_info
                    .as_ref()
                    .map(|info| (s.name.as_str(), info.callback_typedef_name.as_str()))
            })
            .collect();

        func.args
            .iter()
            .map(|arg| {
                // Don't substitute callback wrappers for 'self' parameter or for the class's own type
                // (e.g., Callback::to_core takes self which IS a Callback, not a CallbackType)
                let is_self_or_own_type = arg.name == "self"
                    || arg.name == "instance"
                    || arg.type_name == func.class_name;

                // Check if this type is a callback wrapper - if so, use the raw fn pointer type
                let base_type = if !is_self_or_own_type {
                    if let Some(callback_type) = callback_wrappers.get(arg.type_name.as_str()) {
                        (*callback_type).to_string()
                    } else {
                        arg.type_name.clone()
                    }
                } else {
                    arg.type_name.clone()
                };

                let type_name = config.apply_prefix(&base_type);
                let formatted = match arg.ref_kind {
                    ArgRefKind::Owned => type_name,
                    ArgRefKind::Ref => format!("&{}", type_name),
                    ArgRefKind::RefMut => format!("&mut {}", type_name),
                    ArgRefKind::Ptr => format!("*const {}", type_name),
                    ArgRefKind::PtrMut => format!("*mut {}", type_name),
                };
                format!("{}: {}", arg.name, formatted)
            })
            .collect::<Vec<_>>()
            .join(", ")
    }

    /// Generate test module with size/alignment verification tests
    fn generate_tests(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        builder.line("#[cfg(test)]");
        builder.line("mod generated_tests {");
        builder.indent();
        builder.line("use super::*;");
        builder.line("use super::__dll_api_inner::dll;");
        builder.line("use core::mem;");
        builder.blank();

        // Generate size/alignment tests for each struct
        for struct_def in &ir.structs {
            if !config.should_include_type(&struct_def.name) {
                continue;
            }
            // Skip generic types - can't test size at compile time
            if !struct_def.generic_params.is_empty() {
                continue;
            }
            // Need external_path to compare sizes
            let Some(external_path) = &struct_def.external_path else {
                continue;
            };

            // Skip if external path contains generic parameters (like <T>)
            if external_path.contains('<') {
                continue;
            }

            let external_path = config.transform_external_path(external_path);
            let generated_type = format!("dll::Az{}", struct_def.name);
            let test_name = format!("test_size_align_{}", struct_def.name.to_lowercase());

            builder.line("#[test]");
            builder.line(&format!("fn {}() {{", test_name));
            builder.indent();
            builder.line(&format!(
                "let gen_size = mem::size_of::<{}>();",
                generated_type
            ));
            builder.line(&format!(
                "let ext_size = mem::size_of::<{}>();",
                external_path
            ));
            builder.line(&format!(
                "let gen_align = mem::align_of::<{}>();",
                generated_type
            ));
            builder.line(&format!(
                "let ext_align = mem::align_of::<{}>();",
                external_path
            ));
            builder.line(&format!(
                "assert_eq!(gen_size, ext_size, \"Size mismatch for {}\");",
                struct_def.name
            ));
            builder.line(&format!(
                "assert_eq!(gen_align, ext_align, \"Align mismatch for {}\");",
                struct_def.name
            ));
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Generate size/alignment tests for each enum
        for enum_def in &ir.enums {
            if !config.should_include_type(&enum_def.name) {
                continue;
            }
            // Skip generic types - can't test size at compile time
            if !enum_def.generic_params.is_empty() {
                continue;
            }
            // Need external_path to compare sizes
            let Some(external_path) = &enum_def.external_path else {
                continue;
            };

            // Skip if external path contains generic parameters (like <T>)
            if external_path.contains('<') {
                continue;
            }

            let external_path = config.transform_external_path(external_path);
            let generated_type = format!("dll::Az{}", enum_def.name);
            let test_name = format!("test_size_align_{}", enum_def.name.to_lowercase());

            builder.line("#[test]");
            builder.line(&format!("fn {}() {{", test_name));
            builder.indent();
            builder.line(&format!(
                "let gen_size = mem::size_of::<{}>();",
                generated_type
            ));
            builder.line(&format!(
                "let ext_size = mem::size_of::<{}>();",
                external_path
            ));
            builder.line(&format!(
                "let gen_align = mem::align_of::<{}>();",
                generated_type
            ));
            builder.line(&format!(
                "let ext_align = mem::align_of::<{}>();",
                external_path
            ));
            builder.line(&format!(
                "assert_eq!(gen_size, ext_size, \"Size mismatch for {}\");",
                enum_def.name
            ));
            builder.line(&format!(
                "assert_eq!(gen_align, ext_align, \"Align mismatch for {}\");",
                enum_def.name
            ));
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        builder.dedent();
        builder.line("} // mod generated_tests");

        Ok(builder.finish())
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

fn is_primitive_type(type_name: &str) -> bool {
    matches!(
        type_name,
        "bool"
            | "i8"
            | "i16"
            | "i32"
            | "i64"
            | "i128"
            | "isize"
            | "u8"
            | "u16"
            | "u32"
            | "u64"
            | "u128"
            | "usize"
            | "f32"
            | "f64"
            | "char"
            | "()"
            | "c_void"
            | "c_int"
            | "c_uint"
            | "c_long"
            | "c_ulong"
            | "c_char" // NOTE: "String" is NOT a primitive - it's AzString in Azul, not std::string::String
    )
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }
    result
}

/// Escape Rust keywords by prepending r#
fn escape_rust_keyword(s: &str) -> String {
    const RUST_KEYWORDS: &[&str] = &[
        "as", "async", "await", "break", "const", "continue", "crate", "dyn", "else", "enum",
        "extern", "false", "fn", "for", "if", "impl", "in", "let", "loop", "match", "mod", "move",
        "mut", "pub", "ref", "return", "self", "Self", "static", "struct", "super", "trait",
        "true", "type", "unsafe", "use", "where", "while", "abstract", "become", "box", "do",
        "final", "macro", "override", "priv", "typeof", "unsized", "virtual", "yield", "try",
    ];

    if RUST_KEYWORDS.contains(&s) {
        format!("r#{}", s)
    } else {
        s.to_string()
    }
}
