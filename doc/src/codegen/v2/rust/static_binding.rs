//! Static binding Rust generator
//!
//! Generates standalone Rust code with native function implementations.
//! This is used when statically linking the Azul library into your application.
//!
//! The generated code does NOT depend on the C-API. Instead, functions have
//! real implementations that call directly into the internal azul_core types
//! using transmute for ABI compatibility.
//!
//! Output: `target/codegen/v2/rust-binding-static.rs`
//! Usage: `include!("rust-binding-static.rs")` with `feature = "static"`

use anyhow::Result;

use crate::codegen::v2::config::*;
use crate::codegen::v2::generator::{CodeBuilder, LanguageGenerator};
use crate::codegen::v2::ir::*;

use super::shared;

// Re-use the existing transmute fn_body generation logic
use crate::codegen::memtest::{generate_transmuted_fn_body, parse_arg_type};

// ============================================================================
// Static Binding Generator
// ============================================================================

pub struct RustStaticGenerator;

impl LanguageGenerator for RustStaticGenerator {
    fn generate(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // File header
        builder.line("// Auto-generated by azul-doc codegen v2 (static binding)");
        builder.line("// DO NOT EDIT MANUALLY");
        builder.line("//");
        builder.line("// This file contains the static Rust API with native implementations.");
        builder.line("// Functions call directly into azul_core types using transmute.");
        builder.blank();

        // Generate module structure: pub mod __dll_api_inner { pub mod dll { ... } }
        builder.line("pub mod __dll_api_inner {");
        builder.indent();
        builder.line("pub mod dll {");
        builder.indent();

        // Imports
        for import in &config.imports {
            builder.line(import);
        }
        if !config.imports.is_empty() {
            builder.blank();
        }

        // GL type aliases
        shared::generate_gl_type_aliases(&mut builder);

        // Type definitions
        if config.struct_mode != StructMode::None {
            let types = self.generate_types(ir, config)?;
            builder.raw(&types);
        }

        // Trait implementations using transmute
        let trait_impls = self.generate_trait_impls(ir, config)?;
        builder.raw(&trait_impls);

        // C-ABI functions with bodies (using transmute to/from internal types)
        let functions = self.generate_functions(ir, config)?;
        builder.raw(&functions);

        // End module wrappers
        builder.dedent();
        builder.line("} // mod dll");
        builder.dedent();
        builder.line("} // mod __dll_api_inner");

        // Re-exports at crate root
        builder.blank();
        builder.line("pub use __dll_api_inner::dll::*;");

        // Generate tests if enabled
        if config.generate_tests {
            builder.blank();
            Self::generate_tests_impl(&mut builder, ir, config)?;
        }

        Ok(builder.finish())
    }

    fn generate_types(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);
        shared::generate_types(&mut builder, ir, config);
        Ok(builder.finish())
    }

    fn generate_functions(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);
        
        builder.line("// --- C-ABI Functions ---");
        builder.blank();

        // Skip trait functions when using transmute (traits are implemented directly)
        let skip_trait_functions = matches!(
            config.trait_impl_mode,
            TraitImplMode::UsingTransmute { .. }
        );

        for func in &ir.functions {
            if !config.should_include_type(&func.class_name) {
                continue;
            }
            // Skip trait functions if we're implementing traits via transmute
            if skip_trait_functions && func.kind.is_trait_function() {
                continue;
            }
            Self::generate_function_with_body(&mut builder, func, config)?;
        }

        Ok(builder.finish())
    }

    fn generate_trait_impls(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);
        
        builder.line("// --- Trait Implementations ---");
        builder.blank();

        match &config.trait_impl_mode {
            TraitImplMode::UsingTransmute { external_crate } => {
                for struct_def in &ir.structs {
                    if !config.should_include_type(&struct_def.name) {
                        continue;
                    }
                    Self::generate_transmute_trait_impls(&mut builder, struct_def, config, external_crate);
                }
                for enum_def in &ir.enums {
                    if !config.should_include_type(&enum_def.name) {
                        continue;
                    }
                    Self::generate_transmute_trait_impls_enum(&mut builder, enum_def, config, external_crate);
                }
            }
            TraitImplMode::UsingDerive => {
                // With derive, traits are already on the type definitions
            }
            TraitImplMode::UsingCAPI | TraitImplMode::None => {
                // These modes don't apply to static binding
            }
        }

        Ok(builder.finish())
    }
}

impl RustStaticGenerator {
    /// Generate transmute-based trait impls for a struct
    fn generate_transmute_trait_impls(
        builder: &mut CodeBuilder,
        struct_def: &StructDef,
        config: &CodegenConfig,
        _external_crate: &str,
    ) {
        let name = config.apply_prefix(&struct_def.name);
        
        // Build generics string
        let generics = if struct_def.generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", struct_def.generic_params.join(", "))
        };
        let full_name = format!("{}{}", name, generics);

        // Get external path
        let Some(external_path) = &struct_def.external_path else {
            return;
        };
        let external_path = config.transform_external_path(external_path);

        // Clone trait
        if struct_def.traits.is_clone {
            builder.line(&format!("impl{} Clone for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn clone(&self) -> Self {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ transmute((transmute::<_, &{}>(&self)).clone()) }}",
                external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Drop trait (if has custom destructor)
        if struct_def.traits.has_custom_drop {
            builder.line(&format!("impl{} Drop for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn drop(&mut self) {");
            builder.indent();
            builder.line(&format!(
                "let _ = unsafe {{ transmute::<_, {}>(*transmute::<_, &{}>(self)) }};",
                external_path, external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // PartialEq, Hash, PartialOrd, Ord, Eq as needed
        Self::generate_comparison_traits(builder, &full_name, &generics, &external_path, &struct_def.traits);
    }

    /// Generate transmute-based trait impls for an enum
    fn generate_transmute_trait_impls_enum(
        builder: &mut CodeBuilder,
        enum_def: &EnumDef,
        config: &CodegenConfig,
        _external_crate: &str,
    ) {
        let name = config.apply_prefix(&enum_def.name);
        
        let generics = if enum_def.generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", enum_def.generic_params.join(", "))
        };
        let full_name = format!("{}{}", name, generics);

        let Some(external_path) = &enum_def.external_path else {
            return;
        };
        let external_path = config.transform_external_path(external_path);

        // Clone trait
        if enum_def.traits.is_clone {
            builder.line(&format!("impl{} Clone for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn clone(&self) -> Self {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ transmute((transmute::<_, &{}>(&self)).clone()) }}",
                external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Drop trait
        if enum_def.traits.has_custom_drop {
            builder.line(&format!("impl{} Drop for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn drop(&mut self) {");
            builder.indent();
            builder.line(&format!(
                "let _ = unsafe {{ transmute::<_, {}>(*transmute::<_, &{}>(self)) }};",
                external_path, external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        Self::generate_comparison_traits(builder, &full_name, &generics, &external_path, &enum_def.traits);
    }

    /// Generate comparison traits (PartialEq, Hash, PartialOrd, Ord, Eq)
    fn generate_comparison_traits(
        builder: &mut CodeBuilder,
        full_name: &str,
        generics: &str,
        external_path: &str,
        traits: &TypeTraits,
    ) {
        // PartialEq
        if traits.is_partial_eq {
            builder.line(&format!("impl{} PartialEq for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn eq(&self, other: &Self) -> bool {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ transmute::<_, &{}>(&self) == transmute::<_, &{}>(&other) }}",
                external_path, external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Eq
        if traits.is_eq {
            builder.line(&format!("impl{} Eq for {} {{}}", generics, full_name));
            builder.blank();
        }

        // Hash
        if traits.is_hash {
            builder.line(&format!("impl{} core::hash::Hash for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn hash<H: core::hash::Hasher>(&self, state: &mut H) {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ transmute::<_, &{}>(&self).hash(state) }}",
                external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // PartialOrd
        if traits.is_partial_ord {
            builder.line(&format!("impl{} PartialOrd for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ transmute::<_, &{}>(&self).partial_cmp(transmute::<_, &{}>(&other)) }}",
                external_path, external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Ord
        if traits.is_ord {
            builder.line(&format!("impl{} Ord for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn cmp(&self, other: &Self) -> core::cmp::Ordering {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ transmute::<_, &{}>(&self).cmp(transmute::<_, &{}>(&other)) }}",
                external_path, external_path
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }

    /// Generate a single function with its transmute-based body
    fn generate_function_with_body(
        builder: &mut CodeBuilder,
        func: &FunctionDef,
        config: &CodegenConfig,
    ) -> Result<()> {
        // Doc comment
        if !func.doc.is_empty() {
            for doc_line in &func.doc {
                builder.line(&format!("/// {}", doc_line));
            }
        }

        // #[no_mangle] attribute if configured
        if let CAbiFunctionMode::InternalBindings { no_mangle: true } = &config.cabi_functions {
            builder.line("#[no_mangle]");
            builder.line("#[inline]");
        }

        // Function signature
        let fn_name = &func.c_name;
        let args = Self::format_fn_args(&func.args, config);
        let return_type = func.return_type.as_ref()
            .map(|r| format!(" -> {}", config.apply_prefix(r)))
            .unwrap_or_default();

        builder.line(&format!(
            "pub extern \"C\" fn {}({}){} {{",
            fn_name, args, return_type
        ));
        builder.indent();

        // Generate function body using transmute
        if let Some(ref fn_body) = func.fn_body {
            // Use the fn_body from api.json
            for line in fn_body.lines() {
                builder.line(line);
            }
        } else {
            // Generate placeholder body
            builder.line("unimplemented!()");
        }

        builder.dedent();
        builder.line("}");
        builder.blank();

        Ok(())
    }

    /// Format function arguments for signature
    fn format_fn_args(args: &[FunctionArg], config: &CodegenConfig) -> String {
        args.iter()
            .map(|arg| {
                let type_name = config.apply_prefix(&arg.type_name);
                let ref_prefix = match arg.ref_kind {
                    ArgRefKind::Owned => "",
                    ArgRefKind::Ref => "&",
                    ArgRefKind::RefMut => "&mut ",
                    ArgRefKind::Ptr => "*const ",
                    ArgRefKind::PtrMut => "*mut ",
                };
                format!("{}: {}{}", arg.name, ref_prefix, type_name)
            })
            .collect::<Vec<_>>()
            .join(", ")
    }

    /// Generate test functions
    fn generate_tests_impl(
        builder: &mut CodeBuilder,
        ir: &CodegenIR,
        config: &CodegenConfig,
    ) -> Result<()> {
        builder.line("#[cfg(test)]");
        builder.line("mod generated_tests {");
        builder.indent();
        builder.line("use super::dll;");
        builder.line("use core::mem;");
        builder.blank();

        // Generate size/alignment tests for structs and enums
        for struct_def in &ir.structs {
            if !config.should_include_type(&struct_def.name) {
                continue;
            }
            if !struct_def.generic_params.is_empty() {
                continue;
            }
            let Some(external_path) = &struct_def.external_path else {
                continue;
            };
            if external_path.contains('<') {
                continue;
            }
            
            let external_path = config.transform_external_path(external_path);
            let generated_type = format!("dll::Az{}", struct_def.name);
            let test_name = format!("test_size_align_{}", struct_def.name.to_lowercase());

            builder.line("#[test]");
            builder.line(&format!("fn {}() {{", test_name));
            builder.indent();
            builder.line(&format!("assert_eq!(mem::size_of::<{}>(), mem::size_of::<{}>());", generated_type, external_path));
            builder.line(&format!("assert_eq!(mem::align_of::<{}>(), mem::align_of::<{}>());", generated_type, external_path));
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        builder.dedent();
        builder.line("} // mod generated_tests");

        Ok(())
    }
}
