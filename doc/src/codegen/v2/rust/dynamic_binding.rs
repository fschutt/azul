//! Dynamic binding Rust generator
//!
//! Generates Rust code that calls extern "C" functions from a pre-compiled DLL.
//! This is used when dynamically linking against the Azul shared library.
//!
//! The generated code uses `extern "C"` declarations with `#[link(name = "azul")]`
//! to call into the DLL at runtime. Trait implementations call these C-ABI functions.
//!
//! Output: `target/codegen/v2/rust-binding-dynamic.rs`
//! Usage: `include!("rust-binding-dynamic.rs")` with `feature = "dynamic"`

use anyhow::Result;

use crate::codegen::v2::config::*;
use crate::codegen::v2::generator::{CodeBuilder, LanguageGenerator};
use crate::codegen::v2::ir::*;

use super::shared;

// ============================================================================
// Dynamic Binding Generator
// ============================================================================

pub struct RustDynamicGenerator;

impl LanguageGenerator for RustDynamicGenerator {
    fn generate(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        // File header
        builder.line("// Auto-generated by azul-doc codegen v2 (dynamic binding)");
        builder.line("// DO NOT EDIT MANUALLY");
        builder.line("//");
        builder.line("// This file contains the dynamic Rust API that calls into the Azul DLL.");
        builder.line("// Functions are declared as extern \"C\" and linked at runtime.");
        builder.blank();

        // Generate module structure
        builder.line("pub mod __dll_api_inner {");
        builder.indent();
        builder.line("pub mod dll {");
        builder.indent();

        // Imports
        for import in &config.imports {
            builder.line(import);
        }
        if !config.imports.is_empty() {
            builder.blank();
        }

        // GL type aliases
        shared::generate_gl_type_aliases(&mut builder);

        // Type definitions
        if config.struct_mode != StructMode::None {
            let types = self.generate_types(ir, config)?;
            builder.raw(&types);
        }

        // Trait implementations using C-API calls
        let trait_impls = self.generate_trait_impls(ir, config)?;
        builder.raw(&trait_impls);

        // Extern "C" function declarations
        let functions = self.generate_functions(ir, config)?;
        builder.raw(&functions);

        // End module wrappers
        builder.dedent();
        builder.line("} // mod dll");
        builder.dedent();
        builder.line("} // mod __dll_api_inner");

        // Re-exports at crate root
        builder.blank();
        builder.line("pub use __dll_api_inner::dll::*;");

        Ok(builder.finish())
    }

    fn generate_types(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);
        shared::generate_types(&mut builder, ir, config);
        Ok(builder.finish())
    }

    fn generate_functions(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        builder.line("// --- Extern C Function Declarations ---");
        builder.blank();

        // Get link library name
        let link_library = match &config.cabi_functions {
            CAbiFunctionMode::ExternalBindings { link_library } => link_library.clone(),
            _ => "azul".to_string(),
        };

        builder.line(&format!("#[link(name = \"{}\")]", link_library));
        builder.line("extern \"C\" {");
        builder.indent();

        for func in &ir.functions {
            if !config.should_include_type(&func.class_name) {
                continue;
            }
            Self::generate_extern_declaration(&mut builder, func, config)?;
        }

        builder.dedent();
        builder.line("}");
        builder.blank();

        Ok(builder.finish())
    }

    fn generate_trait_impls(&self, ir: &CodegenIR, config: &CodegenConfig) -> Result<String> {
        let mut builder = CodeBuilder::new(&config.indent);

        builder.line("// --- Trait Implementations ---");
        builder.blank();

        // Only generate C-API based trait impls if configured
        if !matches!(config.trait_impl_mode, TraitImplMode::UsingCAPI) {
            return Ok(builder.finish());
        }

        for struct_def in &ir.structs {
            if !config.should_include_type(&struct_def.name) {
                continue;
            }
            Self::generate_capi_trait_impls(&mut builder, struct_def, config);
        }

        for enum_def in &ir.enums {
            if !config.should_include_type(&enum_def.name) {
                continue;
            }
            Self::generate_capi_trait_impls_enum(&mut builder, enum_def, config);
        }

        Ok(builder.finish())
    }
}

impl RustDynamicGenerator {
    /// Generate C-API based trait impls for a struct
    fn generate_capi_trait_impls(
        builder: &mut CodeBuilder,
        struct_def: &StructDef,
        config: &CodegenConfig,
    ) {
        let name = config.apply_prefix(&struct_def.name);

        let generics = if struct_def.generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", struct_def.generic_params.join(", "))
        };
        let full_name = format!("{}{}", name, generics);

        // Clone trait - calls Az{Type}_clone
        if struct_def.traits.is_clone {
            let clone_fn = format!("{}_clone", name);
            builder.line(&format!("impl{} Clone for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn clone(&self) -> Self {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self) }}", clone_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Drop trait - calls Az{Type}_delete
        if struct_def.traits.has_custom_drop {
            let delete_fn = format!("{}_delete", name);
            builder.line(&format!("impl{} Drop for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn drop(&mut self) {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self); }}", delete_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // PartialEq - calls Az{Type}_partialEq
        if struct_def.traits.is_partial_eq {
            let eq_fn = format!("{}_partialEq", name);
            builder.line(&format!("impl{} PartialEq for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn eq(&self, other: &Self) -> bool {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self, other) }}", eq_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Eq
        if struct_def.traits.is_eq {
            builder.line(&format!("impl{} Eq for {} {{}}", generics, full_name));
            builder.blank();
        }

        // Hash - calls Az{Type}_hash
        if struct_def.traits.is_hash {
            let hash_fn = format!("{}_hash", name);
            builder.line(&format!(
                "impl{} core::hash::Hash for {} {{",
                generics, full_name
            ));
            builder.indent();
            builder.line("fn hash<H: core::hash::Hasher>(&self, state: &mut H) {");
            builder.indent();
            builder.line(&format!("state.write_u64(unsafe {{ {}(self) }})", hash_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // PartialOrd - calls Az{Type}_partialCmp
        if struct_def.traits.is_partial_ord {
            let cmp_fn = format!("{}_partialCmp", name);
            builder.line(&format!("impl{} PartialOrd for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ {}(self, other).into_option() }}",
                cmp_fn
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        // Ord - calls Az{Type}_cmp
        if struct_def.traits.is_ord {
            let cmp_fn = format!("{}_cmp", name);
            builder.line(&format!("impl{} Ord for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn cmp(&self, other: &Self) -> core::cmp::Ordering {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ {}(self, other).into_ordering() }}",
                cmp_fn
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }

    /// Generate C-API based trait impls for an enum
    fn generate_capi_trait_impls_enum(
        builder: &mut CodeBuilder,
        enum_def: &EnumDef,
        config: &CodegenConfig,
    ) {
        // Same logic as structs - enums have the same trait functions
        let name = config.apply_prefix(&enum_def.name);

        let generics = if enum_def.generic_params.is_empty() {
            String::new()
        } else {
            format!("<{}>", enum_def.generic_params.join(", "))
        };
        let full_name = format!("{}{}", name, generics);

        if enum_def.traits.is_clone {
            let clone_fn = format!("{}_clone", name);
            builder.line(&format!("impl{} Clone for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn clone(&self) -> Self {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self) }}", clone_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        if enum_def.traits.has_custom_drop {
            let delete_fn = format!("{}_delete", name);
            builder.line(&format!("impl{} Drop for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn drop(&mut self) {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self); }}", delete_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        if enum_def.traits.is_partial_eq {
            let eq_fn = format!("{}_partialEq", name);
            builder.line(&format!("impl{} PartialEq for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn eq(&self, other: &Self) -> bool {");
            builder.indent();
            builder.line(&format!("unsafe {{ {}(self, other) }}", eq_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        if enum_def.traits.is_eq {
            builder.line(&format!("impl{} Eq for {} {{}}", generics, full_name));
            builder.blank();
        }

        if enum_def.traits.is_hash {
            let hash_fn = format!("{}_hash", name);
            builder.line(&format!(
                "impl{} core::hash::Hash for {} {{",
                generics, full_name
            ));
            builder.indent();
            builder.line("fn hash<H: core::hash::Hasher>(&self, state: &mut H) {");
            builder.indent();
            builder.line(&format!("state.write_u64(unsafe {{ {}(self) }})", hash_fn));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        if enum_def.traits.is_partial_ord {
            let cmp_fn = format!("{}_partialCmp", name);
            builder.line(&format!("impl{} PartialOrd for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ {}(self, other).into_option() }}",
                cmp_fn
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }

        if enum_def.traits.is_ord {
            let cmp_fn = format!("{}_cmp", name);
            builder.line(&format!("impl{} Ord for {} {{", generics, full_name));
            builder.indent();
            builder.line("fn cmp(&self, other: &Self) -> core::cmp::Ordering {");
            builder.indent();
            builder.line(&format!(
                "unsafe {{ {}(self, other).into_ordering() }}",
                cmp_fn
            ));
            builder.dedent();
            builder.line("}");
            builder.dedent();
            builder.line("}");
            builder.blank();
        }
    }

    /// Generate a single extern "C" function declaration
    fn generate_extern_declaration(
        builder: &mut CodeBuilder,
        func: &FunctionDef,
        config: &CodegenConfig,
    ) -> Result<()> {
        let fn_name = &func.c_name;
        let args = Self::format_fn_args(&func.args, config);
        let return_type = func
            .return_type
            .as_ref()
            .map(|r| format!(" -> {}", config.apply_prefix(r)))
            .unwrap_or_default();

        builder.line(&format!("pub fn {}({}){};", fn_name, args, return_type));

        Ok(())
    }

    /// Format function arguments for signature
    fn format_fn_args(args: &[FunctionArg], config: &CodegenConfig) -> String {
        args.iter()
            .map(|arg| {
                let type_name = config.apply_prefix(&arg.type_name);
                let ref_prefix = match arg.ref_kind {
                    ArgRefKind::Owned => "",
                    ArgRefKind::Ref => "&",
                    ArgRefKind::RefMut => "&mut ",
                    ArgRefKind::Ptr => "*const ",
                    ArgRefKind::PtrMut => "*mut ",
                };
                format!("{}: {}{}", arg.name, ref_prefix, type_name)
            })
            .collect::<Vec<_>>()
            .join(", ")
    }
}
