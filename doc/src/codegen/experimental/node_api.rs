use indexmap::IndexMap;
use crate::{
    api::{ApiData, ClassData, FunctionData},
    utils::analyze::{analyze_type, is_primitive_arg},
    utils::string::snake_case_to_lower_camel,
};

const PREFIX: &str = "Az";

/*
// Generating a native Node.js addon involves a specific setup using npm and cargo.

azul-node/
├── Cargo.toml
├── build.rs
├── package.json
├── npm/                 <-- Binary distribution folders (generated by CLI)
└── src/
    ├── lib.rs           <-- Your generated code goes here
    └── sys.rs           <-- Your raw C bindings (bindgen or generated C-API)
*/

/*
// Crucially, you must use the cdylib crate type so it compiles to a dynamic library (.dll/.so/.dylib), which Node.js loads.

[package]
name = "azul-node"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
# The magic crate for Node bindings
napi = { version = "2.10", features = ["napi4"] }
napi-derive = "2.10"

# Link to your main Azul crate (or use build.rs to link the C-lib)
# azul = { path = "../azul" } 

[build-dependencies]
napi-build = "2.0"
*/

/*

// build.rs

extern crate napi_build;

fn main() {
    napi_build::setup();
    // Link against azul C library
    println!("cargo:rustc-link-lib=azul");
    println!("cargo:rustc-link-search=native=./lib"); // Path to libazul.so
}

*/

// You need the @napi-rs/cli to orchestrate the build.

/*
{
  "name": "azul-node",
  "version": "0.1.0",
  "main": "index.js",
  "napi": {
    "name": "azul-node",
    "triples": {
      "defaults": true,
      "additional": []
    }
  },
  "scripts": {
    "build": "napi build --platform --release",
    "build:debug": "napi build --platform",
    "test": "node test.js"
  },
  "devDependencies": {
    "@napi-rs/cli": "^2.16.0"
  }
}
*/

// Final usage:
/*
    // test.js
    const { AzWindowCreateOptions, AzApp } = require('./index.js');

    // Calls Rust: AzWindowCreateOptions::new()
    const opts = new AzWindowCreateOptions();
    opts.setTitle("Hello from Node.js");

    const app = new AzApp(null, {});
    app.run(opts);
*/

/*

Important Note on Function Pointers

Node.js (V8) moves memory around (Garbage Collection). C function pointers 
expect stable memory addresses. Passing a JS function to a C callback 
(Azul -> C -> Rust -> Node) is the hardest part of N-API.

The generator I provided skips functions with Callback arguments. To support 
them, you need a Trampoline:

- Store the JS function in a napi::threadsafe_function.
- Create a static C function (the trampoline).
- Pass the static C function to Azul.
- When Azul calls the C function, the C function calls into the Napi 
  threadsafe handle to invoke the JS function.

This logic is too complex to auto-generate purely from JSON without a 
handwritten Rust runtime helper.

*/

/// Maps Rust/C types to Rust types compatible with Napi
/// Napi handles automatic conversion for: u32, i32, String, bool, f64, etc.
fn map_to_napi_rust_type(ty: &str) -> String {
    // Check for pointers
    if ty.contains('*') {
        // Raw pointers cannot be exposed to JS directly safely.
        // We usually wrap them in `External` or BigInt, but for this generator,
        // we will assume they are opaque handles managed by the wrapper classes.
        if ty.contains("char") {
            return "String".to_string();
        }
        return "u64".to_string(); // Treat pointer addresses as BigInt/Numbers in JS if needed
    }

    match ty {
        "void" | "c_void" | "GLvoid" => "()".to_string(),
        "bool" | "GLboolean" => "bool".to_string(),
        // Napi prefers u32/i32. u64 -> BigInt automatically
        "u8" | "i8" | "u16" | "i16" | "u32" | "i32" | "GLuint" | "GLint" => "u32".to_string(), 
        "usize" | "isize" => "u32".to_string(), // JS numbers are doubles, strict integers > 2^53 are messy
        "u64" | "i64" => "u64".to_string(), // Maps to BigInt in JS
        "f32" | "f64" | "GLfloat" | "GLdouble" => "f64".to_string(), // JS numbers are f64
        "AzString" => "String".to_string(),
        // If it starts with Az, it's one of our classes
        s if s.starts_with(PREFIX) => s.to_string(), 
        _ => ty.to_string(), 
    }
}

pub fn generate_node_api(api_data: &ApiData, version: &str) -> String {
    let mut code = String::new();
    let version_data = api_data.get_version(version).unwrap();

    // 1. Header and Imports
    code.push_str("#![allow(dead_code)]\n");
    code.push_str("#![allow(non_snake_case)]\n");
    code.push_str("#![allow(non_camel_case_types)]\n\n");
    
    code.push_str("use napi_derive::napi;\n");
    code.push_str("use napi::bindgen_prelude::*;\n");
    code.push_str("use std::ffi::{c_void, CString};\n");
    code.push_str("\n");
    
    // We assume the C-API functions are available via an `unsafe extern "C"` block
    // or linked via a sys-crate. For this generation, we assume a sys module exists.
    code.push_str("// Import generated C function definitions\n");
    code.push_str("use crate::sys::*;\n\n");

    // 2. Generate Enums
    for (module_name, module) in &version_data.api {
        for (class_name, class_data) in &module.classes {
            let full_name = format!("{}{}", PREFIX, class_name);

            if let Some(enum_fields) = &class_data.enum_fields {
                // Simple integer enum
                let is_simple = enum_fields.iter().all(|m| m.values().all(|v| v.r#type.is_none()));
                
                if is_simple {
                    code.push_str("#[napi]\n");
                    code.push_str(&format!("pub enum {} {{\n", full_name));
                    for variant_map in enum_fields {
                        for (variant_name, _) in variant_map {
                            code.push_str(&format!("    {},\n", variant_name));
                        }
                    }
                    code.push_str("}\n\n");
                } else {
                    // Tagged unions: Napi doesn't support complex Rust enums directly.
                    // We must map them to a Struct or a Class.
                    // Here we treat them as an opaque class.
                    code.push_str("#[napi]\n");
                    code.push_str(&format!("pub struct {} {{\n", full_name));
                    code.push_str("    // Opaque union storage handled internally\n");
                    code.push_str("}\n\n");
                }
            }
        }
    }

    // 3. Generate Structs (Classes)
    for (module_name, module) in &version_data.api {
        for (class_name, class_data) in &module.classes {
            let full_name = format!("{}{}", PREFIX, class_name);

            if let Some(struct_fields) = &class_data.struct_fields {
                code.push_str("#[napi]\n");
                // If it has a pointer to C memory, we wrap it.
                // If it's pure data (like Color), we can make it an object.
                // For this example, we treat everything as a Class wrapper around a C pointer.
                code.push_str(&format!("pub struct {} {{\n", full_name));
                code.push_str("    // Internal C pointer\n");
                code.push_str(&format!("    pub(crate) inner: *mut {},\n", full_name));
                code.push_str("    // Owned indicates if JS should free this memory on GC\n");
                code.push_str("    pub(crate) owned: bool,\n");
                code.push_str("}\n\n");

                // Implementation Block
                code.push_str("#[napi]\n");
                code.push_str(&format!("impl {} {{\n", full_name));

                // Fields (Getters/Setters)
                for field_map in struct_fields {
                    for (field_name, field_data) in field_map {
                         let napi_type = map_to_napi_rust_type(&field_data.r#type);
                         let camel_field = snake_case_to_lower_camel(field_name);
                         
                         // Getter
                         code.push_str("#[napi(getter)]\n");
                         code.push_str(&format!("    pub fn get_{}(&self) -> {} {{\n", camel_field, napi_type));
                         code.push_str(&format!("        unsafe {{ (*self.inner).{} as {} }}\n", field_name, napi_type));
                         code.push_str("    }\n");

                         // Setter
                         code.push_str("#[napi(setter)]\n");
                         code.push_str(&format!("    pub fn set_{}(&mut self, val: {}) {{\n", camel_field, napi_type));
                         code.push_str(&format!("        unsafe {{ (*self.inner).{} = val as _; }}\n", field_name));
                         code.push_str("    }\n");
                    }
                }

                // Methods
                if let Some(functions) = &class_data.functions {
                    for (fn_name, fn_data) in functions {
                         generate_napi_method(&mut code, &full_name, fn_name, fn_data);
                    }
                }
                
                // Constructors (Static Factories)
                if let Some(constructors) = &class_data.constructors {
                    for (fn_name, fn_data) in constructors {
                        // In JS, you usually have one 'new Class()', but Rust has multiple static factories.
                        // We map 'new' to constructor, others to static methods.
                        generate_napi_constructor(&mut code, &full_name, fn_name, fn_data);
                    }
                }

                code.push_str("}\n\n");
                
                // Implement Drop to clean up C memory if owned
                code.push_str(&format!("impl Drop for {} {{\n", full_name));
                code.push_str("    fn drop(&mut self) {\n");
                code.push_str("        if self.owned && !self.inner.is_null() {\n");
                code.push_str(&format!("            unsafe {{ {}_delete(self.inner) }};\n", full_name));
                code.push_str("        }\n");
                code.push_str("    }\n");
                code.push_str("}\n\n");
            }
        }
    }

    code
}

fn generate_napi_method(code: &mut String, class_name: &str, fn_name: &str, data: &FunctionData) {
    // Skip complex args for basic binding generation
    if data.fn_args.iter().any(|m| m.values().any(|t| t.contains("Callback"))) {
        code.push_str(&format!("    // Method {} skipped (callbacks not supported in auto-gen)\n", fn_name));
        return;
    }

    let camel_name = snake_case_to_lower_camel(fn_name);
    let c_func_name = format!("{}_{}", class_name, camel_name);

    code.push_str("#[napi]\n");
    code.push_str(&format!("    pub fn {}(&self", camel_name));

    // Arguments
    for arg_map in &data.fn_args {
        for (arg_name, arg_type) in arg_map {
            if arg_name == "self" { continue; }
            let napi_type = map_to_napi_rust_type(arg_type);
            // If the argument is a Class, we usually take `&Class`
            let final_type = if arg_type.starts_with(PREFIX) {
                format!("&{}", napi_type)
            } else {
                napi_type
            };
            code.push_str(&format!(", {}: {}", arg_name, final_type));
        }
    }

    // Return type
    let (rust_ret, _is_class) = if let Some(ret) = &data.returns {
        let ty = map_to_napi_rust_type(&ret.r#type);
        (format!(" -> {}", ty), ty.starts_with(PREFIX))
    } else {
        ("".to_string(), false)
    };

    code.push_str(&format!("){} {{\n", rust_ret));
    
    // Call C function
    code.push_str(&format!("        unsafe {{ {} (self.inner, ", c_func_name));
    
    for arg_map in &data.fn_args {
        for (arg_name, arg_type) in arg_map {
            if arg_name == "self" { continue; }
            if arg_type.starts_with(PREFIX) {
                // It's a class wrapper, extract inner pointer
                code.push_str(&format!("{}.inner, ", arg_name));
            } else {
                code.push_str(&format!("{}, ", arg_name));
            }
        }
    }
    // Handle return logic (if returning class, wrap pointer)
    code.push_str(") }\n"); 
    
    code.push_str("    }\n");
}

fn generate_napi_constructor(code: &mut String, class_name: &str, fn_name: &str, data: &FunctionData) {
     if data.fn_args.iter().any(|m| m.values().any(|t| t.contains("Callback"))) { return; }

     let c_func_name = format!("{}_{}", class_name, snake_case_to_lower_camel(fn_name));
     
     if fn_name == "new" {
        code.push_str("#[napi(constructor)]\n");
        code.push_str("    pub fn new(");
     } else {
        code.push_str("#[napi(factory)]\n");
        code.push_str(&format!("    pub fn {}(", fn_name));
     }

     // Args... (similar logic to method)
     let mut arg_vars = Vec::new();
     for arg_map in &data.fn_args {
        for (arg_name, arg_type) in arg_map {
            let napi_type = map_to_napi_rust_type(arg_type);
            code.push_str(&format!("{}: {}, ", arg_name, napi_type));
            arg_vars.push(arg_name.clone());
        }
     }
     code.push_str(&format!(") -> Self {{\n"));
     
     code.push_str(&format!("        let ptr = unsafe {{ {}(", c_func_name));
     for v in arg_vars { code.push_str(&format!("{}, ", v)); }
     code.push_str(") };\n");
     
     code.push_str("        Self { inner: ptr, owned: true }\n");
     code.push_str("    }\n");
}