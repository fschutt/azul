use std::collections::BTreeMap;
use crate::{
    api::{ApiData, ClassData, EnumVariantData, StructFieldData},
    utils::analyze::{analyze_type, is_primitive_arg},
};

/*

azul-rb/
├── lib/
│   ├── azul.rb          <-- The file generated by the Rust code above
│   └── azul/            
│       └── libazul.so   <-- (Optional) You can bundle the binary here
├── azul.gemspec
└── Gemfile

*/

/*
    # In the generated Ruby file:
    lib_path = File.expand_path(__dir__ + '/azul/libazul.so')
    ffi_lib [lib_path]
*/

/*
require 'azul'

# Create a layout callback (FFI allows defining callbacks in Ruby)
# Note: You need to define the callback signature in the generator or manually
# CallbackType = FFI::Function.new(:pointer, [:pointer, :pointer])

layout_func = FFI::Function.new(:pointer, [:pointer, :pointer]) do |ref_any, info|
  # ... Ruby logic ...
  return Azul::AzStyledDom.new.pointer
end

# Call C constructor
opts = Azul.AzWindowCreateOptions_new(layout_func)

# Access struct fields
opts[:title] = FFI::MemoryPointer.from_string("Hello Ruby")

# Run app
app = Azul.AzApp_new(nil, Azul::AzAppConfig.new)
Azul.AzApp_run(app, opts)
*/

const PREFIX: &str = "Az";

// azul.gemspec - Create this file in the root of the ruby folder.
pub fn get_rb_gemspec() -> String {
    format!("
Gem::Specification.new do |s|
  s.name        = 'azul'
  s.version     = '1.0.0'
  s.date        = '2023-10-27'
  s.summary     = "Ruby bindings for the Azul GUI toolkit"
  s.description = "FFI bindings generated from api.json for Azul"
  s.authors     = ["Your Name"]
  s.email       = 'you@example.com'
  s.files       = ["lib/azul.rb"]
  s.homepage    = 'https://azul.rs'
  s.license     = 'MIT'
  
  # This is the magic dependency
  s.add_runtime_dependency 'ffi', '~> 1.15'
end
    ").trim().to_string()
}

/// Maps C/Rust types to Ruby FFI types
fn map_to_ruby_type(ty: &str, prefix: &str) -> String {
    // Handle pointers
    if ty.contains('*') || ty.contains('&') {
        if ty.contains("char") {
            return ":string".to_string();
        }
        return ":pointer".to_string();
    }

    // Handle arrays [T; N] -> FFI doesn't support array args directly, usually passed as pointers
    // But inside structs, they are handled differently.
    if ty.starts_with('[') {
        // Simple heuristic: treat array fields as inline structs or pointers depending on context
        // For arguments, usually pointers. For struct fields, we handle in generate_struct.
        return ":pointer".to_string();
    }

    match ty {
        "void" | "c_void" | "GLvoid" => ":void".to_string(),
        "bool" | "GLboolean" => ":bool".to_string(),
        "char" => ":char".to_string(),
        "u8" => ":uint8".to_string(),
        "i8" => ":int8".to_string(),
        "u16" | "AzU16" => ":uint16".to_string(),
        "i16" => ":int16".to_string(),
        "u32" | "GLuint" | "AzU32" | "AzScanCode" | "GLenum" | "GLbitfield" => ":uint32".to_string(),
        "i32" | "GLint" | "GLsizei" => ":int32".to_string(),
        "u64" | "GLuint64" => ":uint64".to_string(),
        "i64" | "GLint64" => ":int64".to_string(),
        "f32" | "GLfloat" | "GLclampf" | "AzF32" => ":float".to_string(),
        "f64" | "GLdouble" | "GLclampd" => ":double".to_string(),
        "usize" | "uintptr_t" | "size_t" => ":size_t".to_string(),
        "isize" | "intptr_t" | "ssize_t" => ":long".to_string(), // roughly
        // If it starts with the prefix (Az), it's one of our structs/enums
        s if s.starts_with(prefix) => {
            // In Ruby FFI, passing a struct by value is done via .by_value
            // But usually C APIs pass pointers. 
            // If this is a raw struct type (not pointer), we assume it's an enum (int)
            // or a struct passed by value (which requires .by_value).
            // For safety in auto-generation, treating unknown non-pointers as enums (:int)
            // is often safe for simple bindings, or we use the specific class name.
            format!("{}", s) // Return class name, logic below handles context
        }
        _ => ":pointer".to_string(), // Fallback
    }
}

pub fn generate_ruby_api(api_data: &ApiData, version: &str) -> String {
    let mut code = String::new();
    let version_data = api_data.get_version(version).unwrap();
    
    // 1. Header
    code.push_str("# frozen_string_literal: true\n");
    code.push_str("require 'ffi'\n\n");
    code.push_str("module Azul\n");
    code.push_str("  extend FFI::Library\n");
    
    // Logic to find the library file (libazul.so / azul.dll)
    code.push_str("  ffi_lib ['azul', 'libazul.so', 'azul.dll']\n\n");

    // 2. Enums
    // Ruby FFI defines enums as :name, [ :key, val, ... ]
    code.push_str("  # --- Enums ---\n");
    for (module_name, module) in &version_data.api {
        for (class_name, class_data) in &module.classes {
            if let Some(enum_fields) = &class_data.enum_fields {
                let full_name = format!("{}{}", PREFIX, class_name);
                
                // Check if simple enum (integers)
                let is_simple = enum_fields.iter().all(|m| m.values().all(|v| v.r#type.is_none()));
                
                if is_simple {
                    code.push_str(&format!("  enum :{}, [\n", full_name));
                    let mut idx = 0;
                    for variant_map in enum_fields {
                        for (variant_name, _) in variant_map {
                            code.push_str(&format!("    :{}, {},\n", variant_name, idx));
                            idx += 1;
                        }
                    }
                    code.push_str("  ]\n\n");
                } else {
                    // Tagged Unions are mapped as FFI::Union later
                }
            }
        }
    }

    // 3. Struct/Union Definitions (Phase 1: Forward Declarations)
    // We define classes first so they can be referenced
    code.push_str("  # --- Forward Declarations ---\n");
    for (module_name, module) in &version_data.api {
        for (class_name, class_data) in &module.classes {
            let full_name = format!("{}{}", PREFIX, class_name);
            let is_union = class_data.enum_fields.as_ref().map_or(false, |f| 
                f.iter().any(|m| m.values().any(|v| v.r#type.is_some()))
            );

            if is_union {
                code.push_str(&format!("  class {} < FFI::Union; end\n", full_name));
            } else if class_data.struct_fields.is_some() {
                code.push_str(&format!("  class {} < FFI::Struct; end\n", full_name));
            }
        }
    }
    code.push_str("\n");

    // 4. Struct Layouts
    code.push_str("  # --- Struct Layouts ---\n");
    for (module_name, module) in &version_data.api {
        for (class_name, class_data) in &module.classes {
            let full_name = format!("{}{}", PREFIX, class_name);

            if let Some(struct_fields) = &class_data.struct_fields {
                code.push_str(&format!("  class {}\n", full_name));
                code.push_str("    layout(\n");
                
                for field_map in struct_fields {
                    for (field_name, field_data) in field_map {
                        let rb_type = map_to_ruby_type(&field_data.r#type, PREFIX);
                        
                        // Handle struct-by-value fields
                        let final_type = if !rb_type.starts_with(':') {
                            // It returned a struct name (e.g. "AzWindowFlags")
                            format!("{}.by_value", rb_type)
                        } else {
                            rb_type
                        };

                        code.push_str(&format!("      :{}, {},\n", field_name, final_type));
                    }
                }
                code.push_str("    )\n");
                code.push_str("  end\n\n");
            }
        }
    }

    // 5. Functions
    code.push_str("  # --- Functions ---\n");
    for (module_name, module) in &version_data.api {
        for (class_name, class_data) in &module.classes {
            // Helpers to generate attach_function lines
            let generate_fn = |fn_raw_name: &str, fn_data: &crate::api::FunctionData, is_ctor: bool| -> String {
                // C Name: AzDom_new
                let c_func_name = if is_ctor {
                     format!("{}{}_{}", PREFIX, class_name, crate::utils::string::snake_case_to_lower_camel(fn_raw_name))
                } else {
                     format!("{}{}_{}", PREFIX, class_name, crate::utils::string::snake_case_to_lower_camel(fn_raw_name))
                };
                
                let ruby_method_name = c_func_name.clone(); // Keep mapping 1:1 for raw API

                let mut args_str = String::new();
                
                // Methods have explicit self in C
                if !is_ctor {
                    args_str.push_str(":pointer, "); // self pointer
                }

                for arg in &fn_data.fn_args {
                     for (name, ty) in arg {
                         if name == "self" { continue; }
                         let rb_ty = map_to_ruby_type(ty, PREFIX);
                         // Function args are usually pointers or primitives
                         let arg_ty = if !rb_ty.starts_with(':') { ":pointer" } else { &rb_ty };
                         args_str.push_str(&format!("{}, ", arg_ty));
                     }
                }
                
                // Remove trailing comma
                if args_str.ends_with(", ") { args_str.truncate(args_str.len() - 2); }

                let ret_type = if let Some(ret) = &fn_data.returns {
                     let t = map_to_ruby_type(&ret.r#type, PREFIX);
                     if !t.starts_with(':') {
                         format!("{}.by_value", t) // Return struct by value
                     } else {
                         t
                     }
                } else {
                    ":void".to_string()
                };

                format!("  attach_function :{}, [{}], {}\n", ruby_method_name, args_str, ret_type)
            };

            if let Some(constructors) = &class_data.constructors {
                for (name, data) in constructors {
                    code.push_str(&generate_fn(name, data, true));
                }
            }
            if let Some(functions) = &class_data.functions {
                for (name, data) in functions {
                    code.push_str(&generate_fn(name, data, false));
                }
            }
            
            // Destructor
            if class_data.custom_destructor.unwrap_or(false) || class_data.is_boxed_object {
                 let c_name = format!("{}{}_delete", PREFIX, class_name);
                 code.push_str(&format!("  attach_function :{}, [:pointer], :void\n", c_name));
            }
        }
    }

    code.push_str("end\n");
    code
}