use indexmap::IndexMap;
use crate::{
    api::{ApiData, ClassData, FunctionData, EnumVariantData, StructFieldData},
    utils::analyze::{analyze_type, is_primitive_arg},
    utils::string::snake_case_to_lower_camel,
};

const PREFIX: &str = "Az";
const DLL_NAME: &str = "azul";

/*

File Layout for Build:

You need to place your compiled Rust libraries in the standard NuGet 
RID (Runtime Identifier) structure:

azul-net/
├── Azul.csproj
├── Azul.cs              <-- Generated by Rust
└── runtimes/
    ├── win-x64/native/azul.dll
    ├── linux-x64/native/libazul.so
    └── osx-x64/native/libazul.dylib
*/

/*

The build with:

dotnet pack -c Release

This creates Azul.Net.1.0.0.nupkg.
*/

/*
    Important C# Specific Details

    - DllImport Search Path: The .csproj setup above (runtimes/...) relies 
    on .NET Core / .NET 5+ convention. If you support old .NET Framework, 
    you need a .targets file to copy the DLLs, but for modern C# this is automatic.
    - Callbacks: If your API uses function pointers (callbacks), you must generate 
    C# delegates.
    - Rust Generator Update: If arg_type is a callback typedef, map it to a C# delegate.
    - GC Issue: When passing a C# delegate to C, the Garbage Collector might move 
      or collect it while C holds the pointer. You must use GC.KeepAlive(delegate) or 
      store the delegate in a static field to prevent crashes. The generator above 
      creates wrappers, but managing callback lifetime usually requires manual "Glue" 
      code in the generated wrapper classes.
*/

/*

Usage in C#:

When a user adds your NuGet package, .NET automatically loads the 
correct .dll/.so based on their OS.

---

using Azul;

class Program {
    static void Main() {
        // C# wrapper manages the C pointer automatically
        using (var config = new AzAppConfig()) 
        {
            // Set properties if setters generated
            // config.SetLogLevel(...) 
            
            using (var app = new AzApp(IntPtr.Zero, config)) 
            {
                // Call methods
                var monitors = app.GetMonitors();
                // ...
            } 
            // app.Dispose() called here, freeing C memory via AzApp_delete
        }
    }
}

*/

// Create this file. It instructs the build system to 
// include the Rust library as a native asset.
pub fn get_azul_csproj() -> String {
    format!("
<Project Sdk=\"Microsoft.NET.Sdk\">

  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
    <Version>1.0.0</Version>
    <Description>C# Bindings for Azul GUI</Description>
    <PackageId>Azul.Net</PackageId>
  </PropertyGroup>

  <!-- The generated C# code -->
  <ItemGroup>
    <Compile Include=\"Azul.cs\" />
  </ItemGroup>

  <!-- Packaging the Native Library -->
  <ItemGroup>
    <!-- Windows -->
    <None Include=\"runtimes/win-x64/native/azul.dll\">
      <Pack>true</Pack>
      <PackagePath>runtimes/win-x64/native/</PackagePath>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
    
    <!-- Linux -->
    <None Include=\"runtimes/linux-x64/native/libazul.so\">
      <Pack>true</Pack>
      <PackagePath>runtimes/linux-x64/native/</PackagePath>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
    
    <!-- MacOS -->
    <None Include=\"runtimes/osx-x64/native/libazul.dylib\">
      <Pack>true</Pack>
      <PackagePath>runtimes/osx-x64/native/</PackagePath>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>

</Project>
    ").trim().to_string()
}

/// Map Rust/C types to C# types
fn map_to_csharp_type(ty: &str, is_return: bool) -> String {
    // Pointers
    if ty.contains('*') {
        if ty.contains("char") {
            // Strings in C# P/Invoke are automatically marshalled if defined as string
            return "string".to_string(); 
        }
        return "IntPtr".to_string();
    }

    match ty {
        "void" | "c_void" | "GLvoid" => "void".to_string(),
        "bool" | "GLboolean" => "bool".to_string(), // Requires [MarshalAs(UnmanagedType.I1)] usually
        "char" => "byte".to_string(),
        "u8" => "byte".to_string(),
        "i8" => "sbyte".to_string(),
        "u16" | "AzU16" => "ushort".to_string(),
        "i16" => "short".to_string(),
        "u32" | "GLuint" | "AzU32" | "AzScanCode" | "GLenum" | "GLbitfield" => "uint".to_string(),
        "i32" | "GLint" | "GLsizei" => "int".to_string(),
        "u64" | "GLuint64" => "ulong".to_string(),
        "i64" | "GLint64" => "long".to_string(),
        "f32" | "GLfloat" | "GLclampf" | "AzF32" => "float".to_string(),
        "f64" | "GLdouble" | "GLclampd" => "double".to_string(),
        "usize" | "uintptr_t" | "size_t" => "UIntPtr".to_string(),
        "isize" | "intptr_t" | "ssize_t" | "GLsizeiptr" | "GLintptr" => "IntPtr".to_string(),
        "AzString" => "IntPtr".to_string(), // Structs passed by value often need IntPtr in signatures unless blittable
        s if s.starts_with(PREFIX) => {
            // If it's a struct return by value, C# needs the struct definition.
            // If it's an object handle (opaque pointer), it should be IntPtr in the Native layer
            // and the Wrapper class in the high level layer.
            // For this generator, we assume the Raw API uses the Struct name if it's a value type,
            // or IntPtr if it's an opaque handle.
            s.to_string() 
        }
        _ => "IntPtr".to_string(),
    }
}

pub fn generate_csharp_api(api_data: &ApiData, version: &str) -> String {
    let mut code = String::new();
    let version_data = api_data.get_version(version).unwrap();

    // 1. Header
    code.push_str("using System;\n");
    code.push_str("using System.Runtime.InteropServices;\n");
    code.push_str("using System.Text;\n\n");
    code.push_str("namespace Azul {\n\n");

    // 2. Enums
    for (module_name, module) in &version_data.api {
        for (class_name, class_data) in &module.classes {
            let full_name = format!("{}{}", PREFIX, class_name);
            
            if let Some(enum_fields) = &class_data.enum_fields {
                let is_simple = enum_fields.iter().all(|m| m.values().all(|v| v.r#type.is_none()));
                
                if is_simple {
                    code.push_str(&format!("    public enum {} : uint {{\n", full_name));
                    for variant_map in enum_fields {
                        for (variant_name, _) in variant_map {
                            code.push_str(&format!("        {} = {}_{},\n", 
                                variant_name, full_name, variant_name)); // Value mapping logic needed ideally
                        }
                    }
                    code.push_str("    }\n\n");
                } else {
                    // Tagged unions handled as explicit structs below
                }
            }
        }
    }

    // 3. Structs & Unions
    for (module_name, module) in &version_data.api {
        for (class_name, class_data) in &module.classes {
            let full_name = format!("{}{}", PREFIX, class_name);

            // Logic to determine if it's a struct (Sequential) or Union (Explicit)
            let is_union = class_data.enum_fields.as_ref().map_or(false, |f| 
                f.iter().any(|m| m.values().any(|v| v.r#type.is_some()))
            );

            if let Some(struct_fields) = &class_data.struct_fields {
                code.push_str("    [StructLayout(LayoutKind.Sequential)]\n");
                code.push_str(&format!("    public struct {} {{\n", full_name));
                for field_map in struct_fields {
                    for (field_name, field_data) in field_map {
                         let cs_type = map_to_csharp_type(&field_data.r#type, false);
                         // Handle strings in structs (Must be IntPtr usually)
                         let final_type = if cs_type == "string" { "IntPtr" } else { &cs_type };
                         code.push_str(&format!("        public {} {};\n", final_type, field_name));
                    }
                }
                code.push_str("    }\n\n");
            } else if is_union {
                // Generate C-style Union using Explicit Layout
                code.push_str("    [StructLayout(LayoutKind.Explicit)]\n");
                code.push_str(&format!("    public struct {} {{\n", full_name));
                // We need the tag first, then the data at offset 0 (or aligned after tag)
                // This is complex to gen automatically without size info.
                // Simplified: treat as opaque for now or just generate the Tag enum part.
                code.push_str("        // Union layout generation requires explicit offsets\n");
                code.push_str("    }\n\n");
            }
        }
    }

    // 4. Native Methods Class
    code.push_str("    internal static class NativeMethods {\n");
    code.push_str(&format!("        const string DllName = \"{}\";\n\n", DLL_NAME));

    for (module_name, module) in &version_data.api {
        for (class_name, class_data) in &module.classes {
            let class_c_name = format!("{}{}", PREFIX, class_name);

            // Function generator helper
            let mut emit_func = |fn_raw_name: &str, fn_data: &FunctionData, is_ctor: bool| {
                let c_symbol = if is_ctor {
                     format!("{}_{}", class_c_name, crate::utils::string::snake_case_to_lower_camel(fn_raw_name))
                } else {
                     format!("{}_{}", class_c_name, crate::utils::string::snake_case_to_lower_camel(fn_raw_name))
                };

                let ret_type = if let Some(ret) = &fn_data.returns {
                     map_to_csharp_type(&ret.r#type, true)
                } else {
                    "void".to_string()
                };

                // Prepare args
                let mut args = Vec::new();
                if !is_ctor {
                    // Self pointer
                    args.push(format!("IntPtr instance")); 
                }

                for arg_map in &fn_data.fn_args {
                    for (name, ty) in arg_map {
                        if name == "self" { continue; }
                        args.push(format!("{} {}", map_to_csharp_type(ty, false), name));
                    }
                }

                code.push_str(&format!("        [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]\n"));
                // Handle Bool marshalling if needed
                if ret_type == "bool" { code.push_str("        [return: MarshalAs(UnmanagedType.I1)]\n"); }
                
                code.push_str(&format!("        public static extern {} {}({});\n\n", 
                    ret_type, c_symbol, args.join(", ")));
            };

            if let Some(ctors) = &class_data.constructors {
                for (name, data) in ctors { emit_func(name, data, true); }
            }
            if let Some(fns) = &class_data.functions {
                for (name, data) in fns { emit_func(name, data, false); }
            }
            
            // Destructor
            if class_data.custom_destructor.unwrap_or(false) || class_data.is_boxed_object {
                code.push_str(&format!("        [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]\n"));
                code.push_str(&format!("        public static extern void {}_delete(IntPtr instance);\n\n", class_c_name));
            }
        }
    }
    code.push_str("    }\n\n");

    // 5. High Level Wrapper Classes (IDisposable)
    for (module_name, module) in &version_data.api {
        for (class_name, class_data) in &module.classes {
            // Only generate wrappers for "Opaque" objects (those with destructors or hidden layouts)
            let is_opaque = class_data.struct_fields.is_none() && class_data.enum_fields.is_none();
            let has_dtor = class_data.custom_destructor.unwrap_or(false) || class_data.is_boxed_object;
            
            if is_opaque || has_dtor {
                let full_name = format!("{}{}", PREFIX, class_name);
                
                code.push_str(&format!("    public class {} : IDisposable {{\n", full_name));
                code.push_str("        internal IntPtr Handle;\n");
                code.push_str("        private bool _disposed;\n\n");
                
                code.push_str(&format!("        internal {}(IntPtr handle) {{ Handle = handle; }}\n\n", full_name));

                // Constructors
                if let Some(ctors) = &class_data.constructors {
                    for (fn_name, fn_data) in ctors {
                        if fn_name == "new" {
                            // public AzWindow(...)
                            code.push_str(&format!("        public {}(", full_name));
                        } else {
                            // public static AzWindow Create(...)
                            code.push_str(&format!("        public static {} {}(", full_name, crate::utils::string::snake_case_to_lower_camel(fn_name)));
                        }

                        // Args
                        let mut call_args = Vec::new();
                        let mut def_args = Vec::new();
                        for arg_map in &fn_data.fn_args {
                             for (name, ty) in arg_map {
                                 let cs_type = map_to_csharp_type(ty, false);
                                 def_args.push(format!("{} {}", cs_type, name));
                                 call_args.push(name.clone());
                             }
                        }
                        
                        if fn_name == "new" {
                            code.push_str(&format!("{}) {{\n", def_args.join(", ")));
                            let c_sym = format!("{}_new", full_name); // Simplified mapping
                            code.push_str(&format!("            Handle = NativeMethods.{}({});\n", c_sym, call_args.join(", ")));
                            code.push_str("        }\n\n");
                        } else {
                            code.push_str(&format!("{}) {{\n", def_args.join(", ")));
                            let c_sym = format!("{}_{}", full_name, crate::utils::string::snake_case_to_lower_camel(fn_name));
                            code.push_str(&format!("            var ptr = NativeMethods.{}({});\n", c_sym, call_args.join(", ")));
                            code.push_str(&format!("            return new {}(ptr);\n", full_name));
                            code.push_str("        }\n\n");
                        }
                    }
                }
                
                // Methods
                if let Some(fns) = &class_data.functions {
                    for (fn_name, fn_data) in fns {
                        let camel_name = crate::utils::string::snake_case_to_lower_camel(fn_name);
                        let ret_type = fn_data.returns.as_ref().map_or("void".to_string(), |r| map_to_csharp_type(&r.r#type, true));
                        
                        code.push_str(&format!("        public {} {}(", ret_type, camel_name));
                        
                        let mut call_args = vec!["Handle".to_string()]; // Pass self
                        let mut def_args = Vec::new();
                        
                        for arg_map in &fn_data.fn_args {
                             for (name, ty) in arg_map {
                                 if name == "self" { continue; }
                                 def_args.push(format!("{} {}", map_to_csharp_type(ty, false), name));
                                 call_args.push(name.clone());
                             }
                        }
                        code.push_str(&format!("{}) {{\n", def_args.join(", ")));
                        code.push_str("            if (_disposed) throw new ObjectDisposedException(nameof(Handle));\n");
                        
                        let c_sym = format!("{}_{}", full_name, camel_name);
                        let call = format!("NativeMethods.{}({})", c_sym, call_args.join(", "));
                        
                        if ret_type == "void" {
                            code.push_str(&format!("            {};\n", call));
                        } else {
                            code.push_str(&format!("            return {};\n", call));
                        }
                        code.push_str("        }\n\n");
                    }
                }

                // IDisposable
                code.push_str("        ~" /*Destructor*/); code.push_str(&full_name); code.push_str("() { Dispose(false); }\n");
                code.push_str("        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }\n");
                code.push_str("        protected virtual void Dispose(bool disposing) {\n");
                code.push_str("            if (!_disposed) {\n");
                if has_dtor {
                    code.push_str(&format!("                NativeMethods.{}_delete(Handle);\n", full_name));
                }
                code.push_str("                Handle = IntPtr.Zero;\n");
                code.push_str("                _disposed = true;\n");
                code.push_str("            }\n");
                code.push_str("        }\n");
                
                code.push_str("    }\n\n");
            }
        }
    }

    code.push_str("}\n");
    code
}