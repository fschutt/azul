//! Type Index V2 - Core type definitions and indexing
//!
//! This module provides the new architecture for type discovery:
//! - Parse files with syn
//! - Skip `use` re-exports entirely (they are NOT definitions)
//! - Expand impl_vec!, impl_option!, impl_vec_debug! macros during indexing
//! - Build a fast lookup index

use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::fs;
use std::sync::Arc;

use anyhow::Result;
use indexmap::IndexMap;
use rayon::prelude::*;
use syn::{File, Item, UseTree};
use quote::ToTokens;

// ============================================================================
// DATA STRUCTURES
// ============================================================================

/// A type definition discovered from parsing source files.
/// This is NOT created for `use` re-exports - only actual definitions.
#[derive(Debug, Clone)]
pub struct TypeDefinition {
    /// Full path: "azul_core::resources::FontCache"
    pub full_path: String,
    /// Simple name: "FontCache"
    pub type_name: String,
    /// Source file where defined
    pub file_path: PathBuf,
    /// Module path within crate: "resources"
    pub module_path: String,
    /// Crate name: "azul_core"
    pub crate_name: String,
    /// Kind of type with all metadata
    pub kind: TypeDefKind,
    /// Source code of the definition
    pub source_code: String,
}

/// The kind of type definition
#[derive(Debug, Clone)]
pub enum TypeDefKind {
    Struct {
        fields: IndexMap<String, FieldDef>,
        has_repr_c: bool,
        generic_params: Vec<String>,
        derives: Vec<String>,
    },
    Enum {
        variants: IndexMap<String, VariantDef>,
        has_repr_c: bool,
        generic_params: Vec<String>,
        derives: Vec<String>,
    },
    TypeAlias {
        target: String,
    },
    CallbackTypedef {
        args: Vec<CallbackArg>,
        returns: Option<String>,
    },
    /// Type generated by a macro like impl_vec!
    MacroGenerated {
        source_macro: String,
        base_type: String,
        kind: MacroGeneratedKind,
    },
}

/// Kind of macro-generated type
#[derive(Debug, Clone)]
pub enum MacroGeneratedKind {
    /// FooVec from impl_vec!(Foo, FooVec, ...)
    Vec,
    /// FooVecDestructor from impl_vec!(Foo, FooVec, FooVecDestructor)
    VecDestructor,
    /// FooVecDestructorType - the callback_typedef for extern "C" fn(*mut FooVec)
    /// Generated from impl_vec! as the External variant's function pointer type
    VecDestructorType,
    /// OptionFoo from impl_option!(Foo, OptionFoo, ...)
    Option,
    /// OptionFooEnumWrapper from impl_option!(Foo, OptionFoo, OptionFooEnumWrapper)
    OptionEnumWrapper,
    /// ResultFooBar from impl_result!(Foo, Bar, ResultFooBar, ...)
    Result,
    /// CallbackWrapper from impl_callback!(CallbackWrapper, Option, CallbackValue, CallbackType)
    CallbackWrapper,
    /// CallbackValue from impl_callback!(CallbackWrapper, Option, CallbackValue, CallbackType)
    CallbackValue,
}

/// Field definition in a struct
#[derive(Debug, Clone)]
pub struct FieldDef {
    pub name: String,
    pub ty: String,
    pub doc: String,
}

/// Variant definition in an enum
#[derive(Debug, Clone)]
pub struct VariantDef {
    pub name: String,
    pub ty: Option<String>,
    pub doc: String,
}

/// Argument in a callback typedef
#[derive(Debug, Clone)]
pub struct CallbackArg {
    pub name: Option<String>,
    pub ty: String,
}

// ============================================================================
// TYPE INDEX
// ============================================================================

/// Fast lookup index for type definitions
#[derive(Debug, Default)]
pub struct TypeIndex {
    /// Map from simple type name to all definitions with that name
    by_name: HashMap<String, Vec<Arc<TypeDefinition>>>,
    /// Map from full path to definition
    by_path: HashMap<String, Arc<TypeDefinition>>,
    /// Errors encountered during indexing
    pub errors: Vec<String>,
}

impl TypeIndex {
    pub fn new() -> Self {
        Self::default()
    }

    /// Build the type index from a workspace root
    pub fn build(workspace_root: &Path, verbose: bool) -> Result<Self> {
        let mut index = Self::new();

        // Crate directories to scan
        let crate_dirs = [
            ("azul_core", "core/src"),
            ("azul_css", "css/src"),
            ("azul_layout", "layout/src"),
            ("azul_dll", "dll/src"),
        ];

        // Collect all .rs files
        let mut all_files: Vec<(String, PathBuf)> = Vec::new();

        for (crate_name, src_path) in &crate_dirs {
            let src_dir = workspace_root.join(src_path);
            if src_dir.exists() {
                collect_rust_files(&mut all_files, crate_name, &src_dir);
            }
        }

        if verbose {
            eprintln!("[TypeIndex] Found {} Rust files to parse", all_files.len());
        }

        // Parse files in parallel
        let results: Vec<_> = all_files
            .par_iter()
            .map(|(crate_name, file_path)| {
                parse_file_for_types(crate_name, file_path)
            })
            .collect();

        // Merge results
        for result in results {
            match result {
                Ok(types) => {
                    for typedef in types {
                        index.add_type(typedef);
                    }
                }
                Err(e) => {
                    index.errors.push(e);
                }
            }
        }

        if verbose {
            eprintln!(
                "[TypeIndex] Indexed {} unique type names, {} total paths",
                index.by_name.len(),
                index.by_path.len()
            );
        }

        Ok(index)
    }

    /// Add a type definition to the index
    fn add_type(&mut self, typedef: TypeDefinition) {
        let type_name = typedef.type_name.clone();
        let full_path = typedef.full_path.clone();
        let arc = Arc::new(typedef);

        self.by_name
            .entry(type_name)
            .or_default()
            .push(Arc::clone(&arc));
        self.by_path.insert(full_path, arc);
    }

    /// Find the best match for a type name, preferring certain crates
    pub fn resolve(&self, type_name: &str, preferred_crate: Option<&str>) -> Option<&TypeDefinition> {
        let candidates = self.by_name.get(type_name)?;

        if candidates.is_empty() {
            return None;
        }

        if candidates.len() == 1 {
            return Some(&candidates[0]);
        }

        // Score candidates
        let mut best: Option<&Arc<TypeDefinition>> = None;
        let mut best_score = i32::MIN;

        for candidate in candidates {
            let mut score = 0;

            // Prefer matching crate - this should take priority
            if let Some(pref) = preferred_crate {
                if candidate.crate_name == pref {
                    score += 200;
                }
            }

            // Prefer azul_core over others (but lower priority than explicit preference)
            if candidate.crate_name == "azul_core" {
                score += 100;
            } else if candidate.crate_name == "azul_css" {
                score += 80;
            } else if candidate.crate_name == "azul_layout" {
                score += 60;
            }

            // Prefer non-macro-generated
            if !matches!(candidate.kind, TypeDefKind::MacroGenerated { .. }) {
                score += 10;
            }

            // Prefer types with repr(C)
            match &candidate.kind {
                TypeDefKind::Struct { has_repr_c: true, .. } |
                TypeDefKind::Enum { has_repr_c: true, .. } => {
                    score += 20;
                }
                _ => {}
            }

            if score > best_score {
                best_score = score;
                best = Some(candidate);
            }
        }

        best.map(|arc| arc.as_ref())
    }

    /// Get a type by its full path
    pub fn get_by_path(&self, full_path: &str) -> Option<&TypeDefinition> {
        self.by_path.get(full_path).map(|arc| arc.as_ref())
    }

    /// Get all definitions for a type name
    pub fn get_all_by_name(&self, type_name: &str) -> Option<&Vec<Arc<TypeDefinition>>> {
        self.by_name.get(type_name)
    }

    /// Check if a type name is a primitive
    pub fn is_primitive(type_name: &str) -> bool {
        const PRIMITIVES: &[&str] = &[
            "i8", "i16", "i32", "i64", "i128", "isize",
            "u8", "u16", "u32", "u64", "u128", "usize",
            "f32", "f64", "bool", "char", "()", "c_void",
        ];
        
        let trimmed = type_name.trim();
        
        // Direct primitive check
        if PRIMITIVES.contains(&trimmed) {
            return true;
        }

        // Pointer types
        if trimmed.starts_with("*const ") || trimmed.starts_with("*mut ") {
            return true;
        }

        // References
        if trimmed.starts_with('&') {
            return true;
        }

        // Arrays
        if trimmed.starts_with('[') && trimmed.ends_with(']') {
            return true;
        }

        false
    }

    /// Get all type names in the index
    pub fn all_type_names(&self) -> impl Iterator<Item = &String> {
        self.by_name.keys()
    }

    /// Get the number of unique type names
    pub fn type_count(&self) -> usize {
        self.by_name.len()
    }

    /// Add a type definition for testing purposes
    #[cfg(test)]
    pub fn add_type_for_test(&mut self, typedef: TypeDefinition) {
        let full_path = if typedef.module_path.is_empty() {
            format!("{}::{}", typedef.crate_name, typedef.type_name)
        } else {
            format!("{}::{}::{}", typedef.crate_name, typedef.module_path, typedef.type_name)
        };
        let arc = Arc::new(typedef.clone());
        self.by_name
            .entry(typedef.type_name.clone())
            .or_default()
            .push(Arc::clone(&arc));
        self.by_path.insert(full_path, arc);
    }
}

// ============================================================================
// FILE COLLECTION
// ============================================================================

/// Recursively collect all .rs files in a directory
fn collect_rust_files(files: &mut Vec<(String, PathBuf)>, crate_name: &str, dir: &Path) {
    let entries = match fs::read_dir(dir) {
        Ok(e) => e,
        Err(_) => return,
    };

    for entry in entries.flatten() {
        let path = entry.path();

        if path.is_dir() {
            collect_rust_files(files, crate_name, &path);
        } else if path.extension().map_or(false, |e| e == "rs") {
            files.push((crate_name.to_string(), path));
        }
    }
}

// ============================================================================
// FILE PARSING
// ============================================================================

/// Parse a single file and extract type definitions
fn parse_file_for_types(crate_name: &str, file_path: &Path) -> Result<Vec<TypeDefinition>, String> {
    let content = fs::read_to_string(file_path)
        .map_err(|e| format!("Failed to read {}: {}", file_path.display(), e))?;

    let syntax_tree: File = syn::parse_file(&content)
        .map_err(|e| format!("Failed to parse {}: {}", file_path.display(), e))?;

    let module_path = infer_module_path(crate_name, file_path);
    let mut types = Vec::new();

    for item in &syntax_tree.items {
        match item {
            // SKIP Item::Use entirely - re-exports are NOT definitions
            Item::Use(_) => continue,

            Item::Struct(s) => {
                if let Some(typedef) = extract_struct(crate_name, &module_path, file_path, s) {
                    types.push(typedef);
                }
            }

            Item::Enum(e) => {
                if let Some(typedef) = extract_enum(crate_name, &module_path, file_path, e) {
                    types.push(typedef);
                }
            }

            Item::Type(t) => {
                if let Some(typedef) = extract_type_alias(crate_name, &module_path, file_path, t) {
                    types.push(typedef);
                }
            }

            Item::Macro(m) => {
                // Handle impl_vec!, impl_option!, etc.
                let generated = extract_macro_generated_types(crate_name, &module_path, file_path, m);
                types.extend(generated);
            }

            _ => {}
        }
    }

    Ok(types)
}

/// Infer the module path from file path
fn infer_module_path(crate_name: &str, file_path: &Path) -> String {
    // Extract path components after "src/"
    let path_str = file_path.to_string_lossy();
    
    let after_src = if let Some(idx) = path_str.find("/src/") {
        &path_str[idx + 5..]
    } else {
        return String::new();
    };

    // Remove .rs extension and handle mod.rs/lib.rs
    let without_ext = after_src.trim_end_matches(".rs");
    
    if without_ext == "lib" || without_ext == "mod" || without_ext.ends_with("/mod") || without_ext.ends_with("/lib") {
        // lib.rs or mod.rs - module path is the parent directory
        let parent = without_ext.rsplit_once('/').map(|(p, _)| p).unwrap_or("");
        parent.replace('/', "::")
    } else {
        without_ext.replace('/', "::")
    }
}

/// Build full path from crate name, module path, and type name
fn build_full_path(crate_name: &str, module_path: &str, type_name: &str) -> String {
    if module_path.is_empty() {
        format!("{}::{}", crate_name, type_name)
    } else {
        format!("{}::{}::{}", crate_name, module_path, type_name)
    }
}

// ============================================================================
// TYPE EXTRACTION
// ============================================================================

/// Extract a struct definition
fn extract_struct(
    crate_name: &str,
    module_path: &str,
    file_path: &Path,
    s: &syn::ItemStruct,
) -> Option<TypeDefinition> {
    let type_name = s.ident.to_string();
    let full_path = build_full_path(crate_name, module_path, &type_name);

    let generic_params: Vec<String> = s
        .generics
        .type_params()
        .map(|tp| tp.ident.to_string())
        .collect();

    let mut fields = IndexMap::new();
    for field in s.fields.iter() {
        if let Some(field_name) = field.ident.as_ref() {
            let field_ty = field.ty.to_token_stream().to_string();
            fields.insert(
                field_name.to_string(),
                FieldDef {
                    name: field_name.to_string(),
                    ty: clean_type_string(&field_ty),
                    doc: extract_doc_comments(&field.attrs),
                },
            );
        }
    }

    let has_repr_c = has_repr_c_attr(&s.attrs);
    let derives = extract_derives(&s.attrs);

    Some(TypeDefinition {
        full_path,
        type_name,
        file_path: file_path.to_path_buf(),
        module_path: module_path.to_string(),
        crate_name: crate_name.to_string(),
        kind: TypeDefKind::Struct {
            fields,
            has_repr_c,
            generic_params,
            derives,
        },
        source_code: s.to_token_stream().to_string(),
    })
}

/// Extract an enum definition
fn extract_enum(
    crate_name: &str,
    module_path: &str,
    file_path: &Path,
    e: &syn::ItemEnum,
) -> Option<TypeDefinition> {
    let type_name = e.ident.to_string();
    let full_path = build_full_path(crate_name, module_path, &type_name);

    let generic_params: Vec<String> = e
        .generics
        .type_params()
        .map(|tp| tp.ident.to_string())
        .collect();

    let mut variants = IndexMap::new();
    for variant in &e.variants {
        let variant_name = variant.ident.to_string();
        let variant_ty = if variant.fields.is_empty() {
            None
        } else {
            let fields_str = variant
                .fields
                .iter()
                .map(|f| f.ty.to_token_stream().to_string())
                .collect::<Vec<_>>()
                .join(", ");
            Some(clean_type_string(&fields_str))
        };

        variants.insert(
            variant_name.clone(),
            VariantDef {
                name: variant_name,
                ty: variant_ty,
                doc: extract_doc_comments(&variant.attrs),
            },
        );
    }

    let has_repr_c = has_repr_c_attr(&e.attrs);
    let derives = extract_derives(&e.attrs);

    Some(TypeDefinition {
        full_path,
        type_name,
        file_path: file_path.to_path_buf(),
        module_path: module_path.to_string(),
        crate_name: crate_name.to_string(),
        kind: TypeDefKind::Enum {
            variants,
            has_repr_c,
            generic_params,
            derives,
        },
        source_code: e.to_token_stream().to_string(),
    })
}

/// Extract a type alias
fn extract_type_alias(
    crate_name: &str,
    module_path: &str,
    file_path: &Path,
    t: &syn::ItemType,
) -> Option<TypeDefinition> {
    let type_name = t.ident.to_string();
    let full_path = build_full_path(crate_name, module_path, &type_name);
    let target = t.ty.to_token_stream().to_string();

    // Check if this is a callback typedef (extern "C" fn)
    if let syn::Type::BareFn(bare_fn) = &*t.ty {
        let args: Vec<CallbackArg> = bare_fn
            .inputs
            .iter()
            .map(|arg| CallbackArg {
                name: arg.name.as_ref().map(|(ident, _)| ident.to_string()),
                ty: clean_type_string(&arg.ty.to_token_stream().to_string()),
            })
            .collect();

        let returns = match &bare_fn.output {
            syn::ReturnType::Default => None,
            syn::ReturnType::Type(_, ty) => {
                let ret_str = ty.to_token_stream().to_string();
                let cleaned = clean_type_string(&ret_str);
                if cleaned.is_empty() || cleaned == "()" {
                    None
                } else {
                    Some(cleaned)
                }
            }
        };

        return Some(TypeDefinition {
            full_path,
            type_name,
            file_path: file_path.to_path_buf(),
            module_path: module_path.to_string(),
            crate_name: crate_name.to_string(),
            kind: TypeDefKind::CallbackTypedef { args, returns },
            source_code: t.to_token_stream().to_string(),
        });
    }

    Some(TypeDefinition {
        full_path,
        type_name,
        file_path: file_path.to_path_buf(),
        module_path: module_path.to_string(),
        crate_name: crate_name.to_string(),
        kind: TypeDefKind::TypeAlias {
            target: clean_type_string(&target),
        },
        source_code: t.to_token_stream().to_string(),
    })
}

/// Extract types generated by macros like impl_vec!, impl_option!
fn extract_macro_generated_types(
    crate_name: &str,
    module_path: &str,
    file_path: &Path,
    m: &syn::ItemMacro,
) -> Vec<TypeDefinition> {
    let mut types = Vec::new();

    // Get macro name
    let macro_name = m.mac.path.segments
        .last()
        .map(|s| s.ident.to_string())
        .unwrap_or_default();

    let tokens = m.mac.tokens.to_string();
    let args: Vec<&str> = tokens.split(',').map(|s| s.trim()).collect();

    match macro_name.as_str() {
        "impl_vec" | "impl_vec_clone" | "impl_vec_debug" => {
            // impl_vec!(BaseType, VecType, DestructorType)
            // Generates:
            //   - VecType (struct with ptr, len, cap, destructor fields)
            //   - DestructorType (enum with DefaultRust, NoDestructor, External variants)
            //   - DestructorTypeType (callback_typedef for extern "C" fn(*mut VecType))
            if args.len() >= 3 {
                let base_type = args[0].to_string();
                let vec_type = args[1].to_string();
                let destructor_type = args[2].to_string();
                let destructor_type_type = format!("{}Type", destructor_type);

                // VecType (struct)
                types.push(TypeDefinition {
                    full_path: build_full_path(crate_name, module_path, &vec_type),
                    type_name: vec_type.clone(),
                    file_path: file_path.to_path_buf(),
                    module_path: module_path.to_string(),
                    crate_name: crate_name.to_string(),
                    kind: TypeDefKind::MacroGenerated {
                        source_macro: macro_name.clone(),
                        base_type: base_type.clone(),
                        kind: MacroGeneratedKind::Vec,
                    },
                    source_code: m.to_token_stream().to_string(),
                });

                // DestructorType (enum)
                types.push(TypeDefinition {
                    full_path: build_full_path(crate_name, module_path, &destructor_type),
                    type_name: destructor_type.clone(),
                    file_path: file_path.to_path_buf(),
                    module_path: module_path.to_string(),
                    crate_name: crate_name.to_string(),
                    kind: TypeDefKind::MacroGenerated {
                        source_macro: macro_name.clone(),
                        base_type: base_type.clone(),
                        kind: MacroGeneratedKind::VecDestructor,
                    },
                    source_code: m.to_token_stream().to_string(),
                });

                // DestructorTypeType (callback_typedef for the External variant's fn pointer)
                // This is: extern "C" fn(*mut VecType)
                types.push(TypeDefinition {
                    full_path: build_full_path(crate_name, module_path, &destructor_type_type),
                    type_name: destructor_type_type,
                    file_path: file_path.to_path_buf(),
                    module_path: module_path.to_string(),
                    crate_name: crate_name.to_string(),
                    kind: TypeDefKind::MacroGenerated {
                        source_macro: macro_name,
                        base_type: vec_type, // The vec type is referenced in the callback
                        kind: MacroGeneratedKind::VecDestructorType,
                    },
                    source_code: m.to_token_stream().to_string(),
                });
            }
        }

        "impl_option" => {
            // impl_option! can have different forms:
            // impl_option!(BaseType, OptionType, EnumWrapperType, [tag_type])  - 3+ args
            // impl_option!(BaseType, OptionType, copy = false, [...])          - 2 args (no wrapper)
            // impl_option!(BaseType, OptionType, [...])                        - 2 args (no wrapper)
            if args.len() >= 2 {
                let base_type = args[0].to_string();
                let option_type = args[1].to_string();
                
                // Check if 3rd arg looks like a type name (not "copy" or "[")
                let has_wrapper = args.len() >= 3 && {
                    let third = args[2].trim();
                    !third.starts_with("copy") && 
                    !third.starts_with("clone") && 
                    !third.starts_with("[") &&
                    !third.is_empty()
                };

                // OptionType (always generated)
                types.push(TypeDefinition {
                    full_path: build_full_path(crate_name, module_path, &option_type),
                    type_name: option_type.clone(),
                    file_path: file_path.to_path_buf(),
                    module_path: module_path.to_string(),
                    crate_name: crate_name.to_string(),
                    kind: TypeDefKind::MacroGenerated {
                        source_macro: macro_name.clone(),
                        base_type: base_type.clone(),
                        kind: MacroGeneratedKind::Option,
                    },
                    source_code: m.to_token_stream().to_string(),
                });

                // EnumWrapperType (only if 3rd arg is a type name)
                if has_wrapper {
                    let wrapper_type = args[2].to_string();
                    types.push(TypeDefinition {
                        full_path: build_full_path(crate_name, module_path, &wrapper_type),
                        type_name: wrapper_type,
                        file_path: file_path.to_path_buf(),
                        module_path: module_path.to_string(),
                        crate_name: crate_name.to_string(),
                        kind: TypeDefKind::MacroGenerated {
                            source_macro: macro_name,
                            base_type,
                            kind: MacroGeneratedKind::OptionEnumWrapper,
                        },
                        source_code: m.to_token_stream().to_string(),
                    });
                }
            }
        }

        "impl_result" => {
            // impl_result!(OkType, ErrType, ResultType, copy = false, [...])
            // Generates: ResultType (enum with Ok/Err variants)
            if args.len() >= 3 {
                let ok_type = args[0].to_string();
                let err_type = args[1].to_string();
                let result_type = args[2].to_string();

                types.push(TypeDefinition {
                    full_path: build_full_path(crate_name, module_path, &result_type),
                    type_name: result_type,
                    file_path: file_path.to_path_buf(),
                    module_path: module_path.to_string(),
                    crate_name: crate_name.to_string(),
                    kind: TypeDefKind::MacroGenerated {
                        source_macro: macro_name,
                        base_type: format!("Result<{}, {}>", ok_type, err_type),
                        kind: MacroGeneratedKind::Result,
                    },
                    source_code: m.to_token_stream().to_string(),
                });
            }
        }

        "impl_callback" => {
            // impl_callback!(CallbackWrapper, OptionCallbackWrapper, CallbackValue, CallbackType)
            // Generates: CallbackWrapper (struct), OptionCallbackWrapper, CallbackValue (struct)
            // CallbackType is already a type alias defined separately
            if args.len() >= 4 {
                let callback_wrapper = args[0].to_string();
                let option_callback_wrapper = args[1].to_string();
                let callback_value = args[2].to_string();
                let callback_type = args[3].to_string(); // The extern "C" fn type

                // CallbackWrapper struct - has fields: data (RefAny), callback (CallbackValue)
                types.push(TypeDefinition {
                    full_path: build_full_path(crate_name, module_path, &callback_wrapper),
                    type_name: callback_wrapper.clone(),
                    file_path: file_path.to_path_buf(),
                    module_path: module_path.to_string(),
                    crate_name: crate_name.to_string(),
                    kind: TypeDefKind::MacroGenerated {
                        source_macro: macro_name.clone(),
                        base_type: callback_value.clone(), // References CallbackValue
                        kind: MacroGeneratedKind::CallbackWrapper,
                    },
                    source_code: m.to_token_stream().to_string(),
                });

                // OptionCallbackWrapper (via nested impl_option!)
                types.push(TypeDefinition {
                    full_path: build_full_path(crate_name, module_path, &option_callback_wrapper),
                    type_name: option_callback_wrapper,
                    file_path: file_path.to_path_buf(),
                    module_path: module_path.to_string(),
                    crate_name: crate_name.to_string(),
                    kind: TypeDefKind::MacroGenerated {
                        source_macro: macro_name.clone(),
                        base_type: callback_wrapper.clone(),
                        kind: MacroGeneratedKind::Option,
                    },
                    source_code: m.to_token_stream().to_string(),
                });

                // CallbackValue struct - has field: cb (CallbackType)
                types.push(TypeDefinition {
                    full_path: build_full_path(crate_name, module_path, &callback_value),
                    type_name: callback_value.clone(),
                    file_path: file_path.to_path_buf(),
                    module_path: module_path.to_string(),
                    crate_name: crate_name.to_string(),
                    kind: TypeDefKind::MacroGenerated {
                        source_macro: macro_name,
                        base_type: callback_type, // References CallbackType (the extern "C" fn)
                        kind: MacroGeneratedKind::CallbackValue,
                    },
                    source_code: m.to_token_stream().to_string(),
                });
            }
        }

        // ====================================================================
        // CSS PROPERTY MACROS - Generate wrapper structs around PixelValue/etc.
        // ====================================================================
        
        "define_dimension_property" => {
            // define_dimension_property!(LayoutMaxWidth, || Self { inner: PixelValue::px(core::f32::MAX) });
            // Generates a struct with #[repr(C)] and inner: PixelValue
            if !args.is_empty() {
                let struct_name = args[0].to_string();
                types.push(TypeDefinition {
                    full_path: build_full_path(crate_name, module_path, &struct_name),
                    type_name: struct_name.clone(),
                    file_path: file_path.to_path_buf(),
                    module_path: module_path.to_string(),
                    crate_name: crate_name.to_string(),
                    kind: TypeDefKind::Struct {
                        fields: {
                            let mut fields = IndexMap::new();
                            fields.insert("inner".to_string(), FieldDef {
                                name: "inner".to_string(),
                                ty: "PixelValue".to_string(),
                                doc: String::new(),
                            });
                            fields
                        },
                        has_repr_c: true,
                        generic_params: vec![],
                        derives: vec![
                            "Debug".to_string(), "Copy".to_string(), "Clone".to_string(),
                            "PartialEq".to_string(), "Eq".to_string(), "PartialOrd".to_string(),
                            "Ord".to_string(), "Hash".to_string(),
                        ],
                    },
                    source_code: m.to_token_stream().to_string(),
                });
            }
        }

        "define_position_property" => {
            // define_position_property!(LayoutTop);
            // Generates a struct with #[repr(C)] and inner: PixelValue
            if !args.is_empty() {
                let struct_name = args[0].to_string();
                types.push(TypeDefinition {
                    full_path: build_full_path(crate_name, module_path, &struct_name),
                    type_name: struct_name.clone(),
                    file_path: file_path.to_path_buf(),
                    module_path: module_path.to_string(),
                    crate_name: crate_name.to_string(),
                    kind: TypeDefKind::Struct {
                        fields: {
                            let mut fields = IndexMap::new();
                            fields.insert("inner".to_string(), FieldDef {
                                name: "inner".to_string(),
                                ty: "PixelValue".to_string(),
                                doc: String::new(),
                            });
                            fields
                        },
                        has_repr_c: true,
                        generic_params: vec![],
                        derives: vec![
                            "Default".to_string(), "Copy".to_string(), "Clone".to_string(),
                            "PartialEq".to_string(), "Eq".to_string(), "PartialOrd".to_string(),
                            "Ord".to_string(), "Hash".to_string(),
                        ],
                    },
                    source_code: m.to_token_stream().to_string(),
                });
            }
        }

        "define_border_side_property" => {
            // define_border_side_property!(StyleBorderTopStyle, BorderStyle, BorderStyle::None);
            // define_border_side_property!(StyleBorderTopColor, ColorU);
            // define_border_side_property!(LayoutBorderTopWidth, PixelValue, MEDIUM_BORDER_THICKNESS);
            if !args.is_empty() {
                let struct_name = args[0].to_string();
                let inner_type = if args.len() > 1 { 
                    args[1].to_string() 
                } else { 
                    "PixelValue".to_string() 
                };
                
                types.push(TypeDefinition {
                    full_path: build_full_path(crate_name, module_path, &struct_name),
                    type_name: struct_name.clone(),
                    file_path: file_path.to_path_buf(),
                    module_path: module_path.to_string(),
                    crate_name: crate_name.to_string(),
                    kind: TypeDefKind::Struct {
                        fields: {
                            let mut fields = IndexMap::new();
                            fields.insert("inner".to_string(), FieldDef {
                                name: "inner".to_string(),
                                ty: inner_type,
                                doc: String::new(),
                            });
                            fields
                        },
                        has_repr_c: true,
                        generic_params: vec![],
                        derives: vec![
                            "Copy".to_string(), "Clone".to_string(),
                            "PartialEq".to_string(), "Eq".to_string(), "PartialOrd".to_string(),
                            "Ord".to_string(), "Hash".to_string(),
                        ],
                    },
                    source_code: m.to_token_stream().to_string(),
                });
            }
        }

        "define_border_radius_property" => {
            // define_border_radius_property!(StyleBorderTopLeftRadius);
            // Generates a struct with inner: PixelValue
            if !args.is_empty() {
                let struct_name = args[0].to_string();
                types.push(TypeDefinition {
                    full_path: build_full_path(crate_name, module_path, &struct_name),
                    type_name: struct_name.clone(),
                    file_path: file_path.to_path_buf(),
                    module_path: module_path.to_string(),
                    crate_name: crate_name.to_string(),
                    kind: TypeDefKind::Struct {
                        fields: {
                            let mut fields = IndexMap::new();
                            fields.insert("inner".to_string(), FieldDef {
                                name: "inner".to_string(),
                                ty: "PixelValue".to_string(),
                                doc: String::new(),
                            });
                            fields
                        },
                        has_repr_c: true,
                        generic_params: vec![],
                        derives: vec![
                            "Default".to_string(), "Copy".to_string(), "Clone".to_string(),
                            "PartialEq".to_string(), "Eq".to_string(), "PartialOrd".to_string(),
                            "Ord".to_string(), "Hash".to_string(),
                        ],
                    },
                    source_code: m.to_token_stream().to_string(),
                });
            }
        }

        _ => {}
    }

    types
}

// ============================================================================
// HELPERS
// ============================================================================

/// Check if a type has #[repr(C)] or similar
fn has_repr_c_attr(attrs: &[syn::Attribute]) -> bool {
    attrs.iter().any(|attr| {
        if !attr.path().is_ident("repr") {
            return false;
        }
        let repr_str = attr.meta.to_token_stream().to_string();
        repr_str.contains("C")
            || repr_str.contains("transparent")
            || repr_str.contains("u8")
            || repr_str.contains("u16")
            || repr_str.contains("u32")
            || repr_str.contains("u64")
            || repr_str.contains("i8")
            || repr_str.contains("i16")
            || repr_str.contains("i32")
            || repr_str.contains("i64")
            || repr_str.contains("usize")
            || repr_str.contains("isize")
    })
}

/// Extract #[derive(...)] traits
fn extract_derives(attrs: &[syn::Attribute]) -> Vec<String> {
    let mut derives = Vec::new();
    for attr in attrs {
        if attr.path().is_ident("derive") {
            if let syn::Meta::List(list) = &attr.meta {
                let tokens = list.tokens.to_string();
                for item in tokens.split(',') {
                    let item = item.trim();
                    if !item.is_empty() {
                        derives.push(item.to_string());
                    }
                }
            }
        }
    }
    derives
}

/// Extract doc comments from attributes
fn extract_doc_comments(attrs: &[syn::Attribute]) -> String {
    let mut docs = Vec::new();
    for attr in attrs {
        if attr.path().is_ident("doc") {
            if let syn::Meta::NameValue(nv) = &attr.meta {
                if let syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) = &nv.value {
                    docs.push(s.value().trim().to_string());
                }
            }
        }
    }
    docs.join("\n")
}

/// Clean up a type string (remove extra whitespace, normalize)
fn clean_type_string(s: &str) -> String {
    s.split_whitespace().collect::<Vec<_>>().join(" ")
}

// ============================================================================
// UNIT TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    fn extract_types_from_source(source: &str) -> Vec<TypeDefinition> {
        let syntax_tree: File = syn::parse_file(source).expect("Failed to parse");
        let mut types = Vec::new();

        for item in &syntax_tree.items {
            match item {
                Item::Use(_) => continue, // Skip use statements
                Item::Struct(s) => {
                    if let Some(t) = extract_struct("test_crate", "", Path::new("test.rs"), s) {
                        types.push(t);
                    }
                }
                Item::Enum(e) => {
                    if let Some(t) = extract_enum("test_crate", "", Path::new("test.rs"), e) {
                        types.push(t);
                    }
                }
                Item::Type(t) => {
                    if let Some(td) = extract_type_alias("test_crate", "", Path::new("test.rs"), t) {
                        types.push(td);
                    }
                }
                Item::Macro(m) => {
                    let generated = extract_macro_generated_types("test_crate", "", Path::new("test.rs"), m);
                    types.extend(generated);
                }
                _ => {}
            }
        }

        types
    }

    #[test]
    fn test_skips_use_imports() {
        let source = r#"
            use azul_core::resources::FontCache;
            pub use other::Thing;
        "#;
        let types = extract_types_from_source(source);
        assert!(types.is_empty(), "use statements should not create type definitions");
    }

    #[test]
    fn test_extracts_struct_definition() {
        let source = r#"
            #[repr(C)]
            pub struct FontCache {
                pub fonts: FontVec,
            }
        "#;
        let types = extract_types_from_source(source);
        assert_eq!(types.len(), 1);
        assert_eq!(types[0].type_name, "FontCache");
        assert_eq!(types[0].full_path, "test_crate::FontCache");
        
        match &types[0].kind {
            TypeDefKind::Struct { has_repr_c, fields, .. } => {
                assert!(has_repr_c);
                assert!(fields.contains_key("fonts"));
            }
            _ => panic!("Expected Struct"),
        }
    }

    #[test]
    fn test_extracts_enum_definition() {
        let source = r#"
            #[repr(C)]
            pub enum Color {
                Red,
                Green,
                Blue,
            }
        "#;
        let types = extract_types_from_source(source);
        assert_eq!(types.len(), 1);
        assert_eq!(types[0].type_name, "Color");
        
        match &types[0].kind {
            TypeDefKind::Enum { variants, has_repr_c, .. } => {
                assert!(has_repr_c);
                assert_eq!(variants.len(), 3);
                assert!(variants.contains_key("Red"));
            }
            _ => panic!("Expected Enum"),
        }
    }

    #[test]
    fn test_extracts_type_alias() {
        let source = r#"
            pub type MyCallback = extern "C" fn(data: *const u8) -> bool;
        "#;
        let types = extract_types_from_source(source);
        assert_eq!(types.len(), 1);
        assert_eq!(types[0].type_name, "MyCallback");
        
        match &types[0].kind {
            TypeDefKind::CallbackTypedef { args, returns } => {
                assert_eq!(args.len(), 1);
                assert_eq!(returns.as_deref(), Some("bool"));
            }
            _ => panic!("Expected CallbackTypedef"),
        }
    }

    #[test]
    fn test_expands_impl_vec_macro() {
        let source = r#"
            pub struct Font { pub data: u8 }
            impl_vec!(Font, FontVec, FontVecDestructor);
        "#;
        let types = extract_types_from_source(source);
        
        // Should have: Font, FontVec, FontVecDestructor, FontVecDestructorType
        assert_eq!(types.len(), 4);
        
        let names: Vec<_> = types.iter().map(|t| t.type_name.as_str()).collect();
        assert!(names.contains(&"Font"));
        assert!(names.contains(&"FontVec"));
        assert!(names.contains(&"FontVecDestructor"));
        assert!(names.contains(&"FontVecDestructorType"));
    }

    #[test]
    fn test_expands_impl_option_macro() {
        let source = r#"
            pub struct Foo { pub x: i32 }
            impl_option!(Foo, OptionFoo, OptionFooEnumWrapper);
        "#;
        let types = extract_types_from_source(source);
        
        // Should have: Foo, OptionFoo, OptionFooEnumWrapper
        assert_eq!(types.len(), 3);
        
        let names: Vec<_> = types.iter().map(|t| t.type_name.as_str()).collect();
        assert!(names.contains(&"Foo"));
        assert!(names.contains(&"OptionFoo"));
        assert!(names.contains(&"OptionFooEnumWrapper"));
    }

    #[test]
    fn test_expands_impl_callback_macro() {
        let source = r#"
            pub type OnClickCallbackType = extern "C" fn(data: &mut RefAny) -> Update;
            impl_callback!(OnClick, OptionOnClick, OnClickCallback, OnClickCallbackType);
        "#;
        let types = extract_types_from_source(source);
        
        // Should have: OnClickCallbackType (type alias), OnClick, OptionOnClick, OnClickCallback
        assert_eq!(types.len(), 4);
        
        let names: Vec<_> = types.iter().map(|t| t.type_name.as_str()).collect();
        assert!(names.contains(&"OnClickCallbackType")); // The type alias
        assert!(names.contains(&"OnClick")); // CallbackWrapper
        assert!(names.contains(&"OptionOnClick")); // OptionCallbackWrapper
        assert!(names.contains(&"OnClickCallback")); // CallbackValue
    }

    #[test]
    fn test_is_primitive() {
        assert!(TypeIndex::is_primitive("u8"));
        assert!(TypeIndex::is_primitive("i32"));
        assert!(TypeIndex::is_primitive("f64"));
        assert!(TypeIndex::is_primitive("bool"));
        assert!(TypeIndex::is_primitive("*const u8"));
        assert!(TypeIndex::is_primitive("*mut c_void"));
        assert!(TypeIndex::is_primitive("&str"));
        assert!(TypeIndex::is_primitive("[u8; 4]"));
        
        assert!(!TypeIndex::is_primitive("String"));
        assert!(!TypeIndex::is_primitive("Vec"));
        assert!(!TypeIndex::is_primitive("FontCache"));
    }

    #[test]
    fn test_module_path_inference() {
        assert_eq!(
            infer_module_path("azul_core", Path::new("/foo/core/src/lib.rs")),
            ""
        );
        assert_eq!(
            infer_module_path("azul_core", Path::new("/foo/core/src/dom.rs")),
            "dom"
        );
        assert_eq!(
            infer_module_path("azul_core", Path::new("/foo/core/src/dom/mod.rs")),
            "dom"
        );
        assert_eq!(
            infer_module_path("azul_core", Path::new("/foo/core/src/widgets/button.rs")),
            "widgets::button"
        );
    }
}
