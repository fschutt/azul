# Text Selection Changeset Architecture

## Design Principles

### 1. Lazy Changeset Application (preventDefault Support)

**Current Pattern (Text Input)**:
```rust
// Pre-callback: Gather text input
let text_input = keyboard_state.current_char;

// User callbacks run (can call preventDefault)
let prevent_default = run_callbacks();

// Post-callback: Apply only if not prevented
if !prevent_default {
    apply_text_changeset();
}
```

**New Pattern (Selection + Editing)**:
```rust
// Pre-callback: Detect interaction patterns → Generate system events
let pre_filter = pre_callback_filter_internal_events(
    events,
    hit_test,
    keyboard_state, // Use VirtualKeyCode for arrow keys
    mouse_state,    // Track drag state
    managers,       // Selection, scroll, focus state
);

// Create changesets (but don't apply yet)
let changesets = create_changesets_from_system_events(&pre_filter.internal_events);

// User callbacks run with changesets available for inspection
let callbacks_result = run_callbacks_with_changesets(changesets);

// Post-callback: Apply changesets if not prevented
if !callbacks_result.prevent_default {
    apply_changesets(changesets);
    
    // Analyze state changes for scroll-into-view needs
    if needs_scroll_into_view() {
        scroll_focused_cursor_into_view();
    }
}
```

### 2. System Internal Events vs User Events

**System Internal Events** (hidden from user):
- Generated by analyzing state transitions
- Examples:
  - `TextClick` - Detected from mouse click + click count
  - `TextDragSelection` - Detected from mouse down + mouse move with button held
  - `ArrowKeyNavigation` - Detected from VirtualKeyCode::Left/Right/Up/Down
  - `KeyboardShortcut` - Detected from Ctrl+C/X/V/A/Z (VirtualKeyCode)

**User Events** (visible to callbacks):
- All events pass through to user callbacks
- User can inspect changeset and preventDefault

### 3. State-Based Analysis (Not Event-Based)

The pre-filter analyzes **state transitions**, not raw events:

```rust
pub fn pre_callback_filter_internal_events(
    events: &[SyntheticEvent],
    hit_test: Option<&FullHitTest>,
    keyboard_state: &KeyboardState,      // Use current_virtual_keycode
    mouse_state: &MouseState,            // Track button state
    selection_manager: &SelectionManager, // Current selection state
    focus_manager: &FocusManager,         // Current focus
    scroll_manager: &ScrollManager,       // Scroll positions
) -> PreCallbackFilterResult
```

**Example**: Drag-to-scroll detection
```rust
// Not: "Did MouseMove event happen?"
// But: "Is mouse button down + mouse outside container + selection active?"

if mouse_state.left_button_down &&
   selection_manager.has_active_selection() &&
   is_mouse_outside_container(mouse_state.position, container_rect)
{
    internal_events.push(PreCallbackSystemEvent::DragToScroll {
        direction: calculate_scroll_direction(),
    });
}
```

### 4. Changeset Structure

```rust
/// A text editing changeset that can be inspected before application
#[derive(Debug, Clone)]
pub struct TextChangeset {
    pub target: DomNodeId,
    pub operation: TextOperation,
    pub affected_range: SelectionRange,
    pub new_text: Option<String>,
    pub new_cursor_position: Option<CursorPosition>,
}

#[derive(Debug, Clone)]
pub enum TextOperation {
    /// Insert text at cursor
    Insert { text: String },
    /// Delete text in range
    Delete { range: SelectionRange },
    /// Replace text in range
    Replace { range: SelectionRange, text: String },
    /// Set selection (no text change)
    SetSelection { range: SelectionRange },
    /// Move cursor (no text change)
    MoveCursor { position: CursorPosition },
}
```

**Two-Phase Processing**:
1. **Create changeset** (pre-callback): Analyze what would change
2. **Apply changeset** (post-callback): Actually mutate state

This enables:
- User callbacks to inspect planned changes
- preventDefault to block specific operations
- Undo/redo stack to record changesets
- Validation before mutation

### 5. Scroll-Into-View as Post-Callback Analysis

**NOT** a system event from pre-filter, but a **state analysis** in post-filter:

```rust
pub fn post_callback_filter_internal_events(
    prevent_default: bool,
    changesets_applied: &[TextChangeset],
    layout_window: &LayoutWindow,
) -> PostCallbackFilterResult {
    let mut system_events = Vec::new();
    
    // Apply changesets if not prevented
    if !prevent_default {
        for changeset in changesets_applied {
            apply_changeset(changeset);
        }
        
        // Analyze if cursor moved out of view
        if let Some(cursor_rect) = layout_window.get_focused_cursor_rect() {
            if let Some(container) = find_scrollable_ancestor() {
                if !is_cursor_visible(cursor_rect, container) {
                    system_events.push(PostCallbackSystemEvent::ScrollIntoView);
                }
            }
        }
    }
    
    PostCallbackFilterResult { system_events }
}
```

**Why post-callback?**
- Cursor position only known after text changes applied
- Need final layout to determine visibility
- Scroll is consequence of applied changes, not input event

### 6. Timer System for Auto-Scroll

**Problem**: Drag-to-scroll needs continuous scrolling while mouse held still

**Solution**: Timer-based polling during drag

```rust
// Pre-callback: Detect drag-beyond-boundary
if is_dragging_outside_container() {
    internal_events.push(PreCallbackSystemEvent::TextDragSelection {
        needs_auto_scroll: true,
    });
}

// Post-callback: Start timer if drag needs scrolling
if has_drag_needing_scroll() {
    system_events.push(PostCallbackSystemEvent::StartAutoScrollTimer {
        interval: Duration::from_millis(50), // 20fps scrolling
        direction: scroll_direction,
    });
}

// Timer callback (separate flow):
fn on_auto_scroll_timer() {
    if !is_still_dragging() {
        cancel_auto_scroll_timer();
        return;
    }
    
    // Apply scroll increment
    scroll_manager.scroll_by(delta);
    
    // Update selection to mouse position
    update_drag_selection();
    
    // Re-render
    request_rerender();
}
```

## Implementation Architecture

### Phase 1: Refactor Pre-Filter to Use Manager State

**Current**:
```rust
pub fn pre_callback_filter_internal_events(
    events: &[SyntheticEvent],
    hit_test: Option<&FullHitTest>,
    click_count: u8,
) -> PreCallbackFilterResult
```

**New**:
```rust
pub fn pre_callback_filter_internal_events(
    events: &[SyntheticEvent],
    hit_test: Option<&FullHitTest>,
    keyboard_state: &KeyboardState,       // Use VirtualKeyCode
    mouse_state: &MouseState,
    selection_manager: &SelectionManager,
    focus_manager: &FocusManager,
) -> PreCallbackFilterResult
```

**Detection Logic**:
- `TextClick`: `events` contains MouseDown + `selection_manager.click_state`
- `TextDragSelection`: `mouse_state.left_button_down` + MouseMove events + has selection
- `ArrowKeyNavigation`: `keyboard_state.current_virtual_keycode` = Left/Right/Up/Down
- `KeyboardShortcut`: `keyboard_state` Ctrl pressed + `current_virtual_keycode`

### Phase 2: Changeset Creation

**New Module**: `layout/src/managers/changeset.rs`

```rust
pub fn create_changesets_from_system_events(
    events: &[PreCallbackSystemEvent],
    layout_window: &LayoutWindow,
) -> Vec<TextChangeset> {
    let mut changesets = Vec::new();
    
    for event in events {
        match event {
            PreCallbackSystemEvent::TextClick { target, position, click_count, .. } => {
                // Create selection changeset (no text mutation)
                let changeset = create_selection_changeset(target, position, click_count);
                changesets.push(changeset);
            }
            PreCallbackSystemEvent::ArrowKeyNavigation { target, direction, extend_selection, .. } => {
                // Create cursor movement or selection extension changeset
                let changeset = create_arrow_navigation_changeset(target, direction, extend_selection);
                changesets.push(changeset);
            }
            PreCallbackSystemEvent::KeyboardShortcut { target, shortcut } => {
                // Create copy/cut/paste changesets
                match shortcut {
                    KeyboardShortcut::Copy => { /* No changeset, just clipboard */ }
                    KeyboardShortcut::Cut => {
                        changesets.push(create_delete_selection_changeset(target));
                    }
                    KeyboardShortcut::Paste => {
                        changesets.push(create_paste_changeset(target));
                    }
                    // ...
                }
            }
            // ...
        }
    }
    
    changesets
}
```

### Phase 3: Apply Changesets (Post-Callback)

**Update**: `post_callback_filter_internal_events`

```rust
pub fn post_callback_filter_internal_events(
    prevent_default: bool,
    changesets: &[TextChangeset],
    layout_window: &mut LayoutWindow,
) -> PostCallbackFilterResult {
    let mut system_events = Vec::new();
    
    if !prevent_default {
        // Apply all changesets
        for changeset in changesets {
            apply_text_changeset(changeset, layout_window);
        }
        
        // Check if we need to scroll cursor into view
        if should_scroll_into_view(layout_window) {
            system_events.push(PostCallbackSystemEvent::ScrollIntoView);
        }
    }
    
    PostCallbackFilterResult { system_events }
}
```

### Phase 4: Process Post-Callback System Events

**In event loop** (`event_v2.rs`):

```rust
// After post-callback filter
for event in post_filter.system_events {
    match event {
        PostCallbackSystemEvent::ScrollIntoView => {
            layout_window.scroll_focused_cursor_into_view();
        }
        PostCallbackSystemEvent::StartAutoScrollTimer { interval, direction } => {
            start_auto_scroll_timer(interval, direction);
        }
        PostCallbackSystemEvent::CancelAutoScrollTimer => {
            cancel_auto_scroll_timer();
        }
        // ...
    }
}
```

## Key Architectural Decisions

### ✅ Use VirtualKeyCode (not reinvent)
- Already exists in `KeyboardState::current_virtual_keycode`
- Has `VirtualKeyCode::Left/Right/Up/Down` for arrows
- Has `VirtualKeyCode::A/C/X/V/Z` for shortcuts
- Check `keyboard_state.is_ctrl()` + `current_virtual_keycode`

### ✅ State-Based Detection (not event-based)
- Pre-filter analyzes manager state transitions
- Example: Drag detection = `mouse_state.left_button_down` + `has_selection()`
- More robust than tracking event sequences

### ✅ Two-Phase Changeset Processing
- **Phase 1** (pre-callback): Create changeset, don't apply
- **Phase 2** (post-callback): Apply if not prevented
- Enables preventDefault, undo/redo, validation

### ✅ Scroll-Into-View as Post-Callback Analysis
- NOT detected in pre-filter
- Analyzed after changesets applied
- Based on final cursor position vs container bounds
- Uses existing `scroll_focused_cursor_into_view()` method

### ✅ Timer System for Auto-Scroll
- Separate from event loop
- Triggered by `PostCallbackSystemEvent::StartAutoScrollTimer`
- Polls at 20fps during drag
- Cancels on MouseUp or mouse returns to container

## Migration Path

### Step 1: Update Pre-Filter Signature
- Add `keyboard_state`, `mouse_state`, managers
- Use `VirtualKeyCode` for key detection
- Remove hardcoded key_code checks

### Step 2: Implement State-Based Detection
- Drag selection: Check `mouse_state.left_button_down` + selection active
- Arrow keys: Check `keyboard_state.current_virtual_keycode`
- Shortcuts: Check `is_ctrl()` + `current_virtual_keycode`

### Step 3: Create Changeset System
- New module: `managers/changeset.rs`
- `TextChangeset` struct with operations
- `create_changesets_from_system_events()`
- `apply_text_changeset()`

### Step 4: Update Post-Filter
- Accept changesets parameter
- Apply if not prevented
- Analyze state for scroll-into-view needs
- Generate `PostCallbackSystemEvent::ScrollIntoView`

### Step 5: Process Post-Callback Events
- Handle `ScrollIntoView` → call existing method
- Handle `StartAutoScrollTimer` → start timer
- Handle `CancelAutoScrollTimer` → stop timer

### Step 6: Implement Auto-Scroll Timer
- Timer callback that checks drag state
- Apply scroll delta
- Update selection
- Request re-render

## Summary

**Core Insight**: The text selection system should follow the same lazy-application pattern as text input:

1. **Pre-callback**: Detect interaction patterns, create changesets (don't apply)
2. **Callbacks**: User can inspect changesets, call preventDefault
3. **Post-callback**: Apply changesets if not prevented, analyze state changes
4. **System processing**: Handle consequences (scroll-into-view, auto-scroll timers)

This architecture:
- ✅ Supports preventDefault for all operations
- ✅ Uses existing `VirtualKeyCode` (no reinvention)
- ✅ Analyzes state transitions (not raw events)
- ✅ Reuses existing `scroll_focused_cursor_into_view()`
- ✅ Separates changeset creation from application
- ✅ Enables undo/redo and validation
- ✅ Handles drag-to-scroll with timer system

---

## REFACTORING PLAN: Complete System Overhaul

### Current Problems

1. **Mixing concerns**: Selection logic mixed with event processing
2. **No changeset system**: Direct mutation, no preventDefault support
3. **Manual scroll tracking**: Scroll-into-view called explicitly, not analyzed
4. **No drag-to-scroll**: Missing accelerated scrolling based on distance from edge
5. **Cursor vs Selection**: Treated separately, but should be unified (cursor = 0-size selection)

### Refactoring Goals

1. **Unified scroll system**: `scroll_selection_into_view()` handles both cursor (0-size) and selection
2. **Accelerated auto-scroll**: Scroll speed increases with distance from container edge
3. **Complete changeset system**: All operations go through changeset creation → application
4. **State-based analysis**: Pre/post filters analyze manager state, not events
5. **Manager extensions**: SelectionManager, ScrollManager work together seamlessly

---

## Phase 1: Unified Scroll System

### Problem: Cursor vs Selection Duplication

**Current**:
```rust
scroll_focused_cursor_into_view() {
    let cursor_rect = get_focused_cursor_rect();
    scroll_rect_into_view(cursor_rect);
}

// Selection scrolling: NOT IMPLEMENTED
```

**Issues**:
- Selection scrolling not implemented
- Cursor treated as special case
- Can't handle drag-to-scroll for selections
- No distance-based acceleration

### Solution: Unified `scroll_selection_into_view()`

**Key Insight**: Cursor is just a selection with 0 size (collapsed selection)

```rust
/// Scroll selection or cursor into view with distance-based acceleration.
///
/// For drag-to-scroll: scroll speed increases with distance from container edge.
/// For cursor: acts as 0-size selection (collapsed to insertion point).
///
/// ## Algorithm
/// 1. Get selection bounds (or cursor position as 0-size rect)
/// 2. Find scrollable ancestor container
/// 3. Calculate distance from selection to container edges
/// 4. Compute scroll delta with acceleration based on distance
/// 5. Apply scroll with appropriate animation (instant for typing, smooth for drag)
///
/// ## Distance-Based Acceleration
/// ```
/// Distance from edge:  Scroll speed:
/// 0-20px              No scroll (dead zone)
/// 20-50px             Slow (1x)
/// 50-100px            Medium (2x)
/// 100-200px           Fast (4x)
/// 200+px              Very fast (8x)
/// ```
pub fn scroll_selection_into_view(
    &mut self,
    selection_type: SelectionScrollType,
    scroll_mode: ScrollMode,
) -> bool {
    // Get bounds to scroll into view
    let bounds = match selection_type {
        SelectionScrollType::Cursor => {
            // Cursor is 0-size selection at insertion point
            let cursor_rect = self.get_focused_cursor_rect()?;
            cursor_rect
        }
        SelectionScrollType::Selection => {
            // Get selection range(s) and compute bounding rect
            let ranges = self.selection_manager.get_selection();
            if ranges.is_empty() {
                return false; // No selection to scroll
            }
            self.calculate_selection_bounding_rect(ranges)?
        }
        SelectionScrollType::DragSelection { mouse_position } => {
            // For drag: use mouse position to determine scroll direction/speed
            // Selection itself may not be at edge, but mouse is
            LogicalRect::new(mouse_position, LogicalSize::zero())
        }
    };

    // Find scrollable ancestor
    let focused_node = self.focus_manager.focused_node?;
    let scroll_container = self.find_scrollable_ancestor(focused_node)?;
    
    // Get container bounds and current scroll state
    let container_rect = self.get_node_layout_rect(scroll_container)?;
    let scroll_state = self.scroll_manager.get_scroll_state(
        scroll_container.dom,
        scroll_container.node.into_crate_internal()?
    )?;
    
    // Calculate visible area (container rect adjusted by scroll offset)
    let visible_area = LogicalRect::new(
        LogicalPosition::new(
            container_rect.origin.x + scroll_state.current_offset.x,
            container_rect.origin.y + scroll_state.current_offset.y,
        ),
        container_rect.size,
    );
    
    // Calculate distance from bounds to container edges
    let distance = calculate_edge_distance(bounds, visible_area);
    
    // Apply distance-based acceleration for drag-to-scroll
    let scroll_delta = match scroll_mode {
        ScrollMode::Instant => {
            // For typing: instant scroll with fixed padding
            calculate_instant_scroll_delta(bounds, visible_area, PADDING)
        }
        ScrollMode::Accelerated => {
            // For drag: accelerated scroll based on distance
            calculate_accelerated_scroll_delta(distance)
        }
    };
    
    // Apply scroll if needed
    if scroll_delta.x != 0.0 || scroll_delta.y != 0.0 {
        let duration = match scroll_mode {
            ScrollMode::Instant => Duration::from_millis(0),
            ScrollMode::Accelerated => Duration::from_millis(16), // 60fps
        };
        
        self.scroll_manager.scroll_by(
            scroll_container.dom,
            scroll_container.node.into_crate_internal()?,
            scroll_delta,
            duration.into(),
            EasingFunction::Linear,
            get_current_time(),
        );
        
        true // Scrolled
    } else {
        false // Already visible
    }
}

#[derive(Debug, Clone, Copy)]
pub enum SelectionScrollType {
    /// Scroll cursor (0-size selection) into view
    Cursor,
    /// Scroll current selection bounds into view
    Selection,
    /// Scroll for drag selection (use mouse position for direction/speed)
    DragSelection { mouse_position: LogicalPosition },
}

#[derive(Debug, Clone, Copy)]
pub enum ScrollMode {
    /// Instant scroll (for typing, arrow keys)
    Instant,
    /// Accelerated scroll (for drag-to-scroll)
    Accelerated,
}

/// Calculate distance from rect to container edges (for acceleration)
fn calculate_edge_distance(
    rect: LogicalRect,
    container: LogicalRect,
) -> EdgeDistance {
    EdgeDistance {
        left: (rect.origin.x - container.origin.x).max(0.0),
        right: ((container.origin.x + container.size.width) - 
                (rect.origin.x + rect.size.width)).max(0.0),
        top: (rect.origin.y - container.origin.y).max(0.0),
        bottom: ((container.origin.y + container.size.height) - 
                 (rect.origin.y + rect.size.height)).max(0.0),
    }
}

/// Calculate scroll delta with distance-based acceleration
fn calculate_accelerated_scroll_delta(distance: EdgeDistance) -> LogicalPosition {
    const DEAD_ZONE: f32 = 20.0;
    const SLOW_ZONE: f32 = 50.0;
    const MEDIUM_ZONE: f32 = 100.0;
    const FAST_ZONE: f32 = 200.0;
    
    let accel_x = if distance.left < DEAD_ZONE {
        0.0
    } else if distance.left < SLOW_ZONE {
        -1.0
    } else if distance.left < MEDIUM_ZONE {
        -2.0
    } else if distance.left < FAST_ZONE {
        -4.0
    } else {
        -8.0
    };
    
    // Similar for right, top, bottom...
    
    LogicalPosition::new(accel_x, accel_y)
}

#[derive(Debug, Clone, Copy)]
struct EdgeDistance {
    left: f32,
    right: f32,
    top: f32,
    bottom: f32,
}
```

### Migration: Replace All Scroll Calls

**Before**:
```rust
scroll_focused_cursor_into_view();
```

**After**:
```rust
scroll_selection_into_view(SelectionScrollType::Cursor, ScrollMode::Instant);
```

**New Capability**:
```rust
// Drag-to-scroll with acceleration
scroll_selection_into_view(
    SelectionScrollType::DragSelection { mouse_position },
    ScrollMode::Accelerated,
);
```

---

## Phase 2: Complete Changeset System

### Current State

```rust
// Text input: Has lazy application
if !prevent_default {
    apply_text_changeset();
}

// Selection: NO lazy application, direct mutation
selection_manager.set_selection(range); // WRONG - no preventDefault support
```

### Target State: All Operations Use Changesets

```rust
/// All text editing and selection operations produce changesets
#[derive(Debug, Clone)]
pub struct TextChangeset {
    pub id: ChangesetId,
    pub target: DomNodeId,
    pub operation: TextOperation,
    pub timestamp: Instant,
}

#[derive(Debug, Clone)]
pub enum TextOperation {
    // === Text Mutations ===
    InsertText {
        position: CursorPosition,
        text: String,
        new_cursor: CursorPosition,
    },
    DeleteText {
        range: SelectionRange,
        deleted_text: String, // For undo
        new_cursor: CursorPosition,
    },
    ReplaceText {
        range: SelectionRange,
        old_text: String, // For undo
        new_text: String,
        new_cursor: CursorPosition,
    },
    
    // === Selection Mutations (no text change) ===
    SetSelection {
        old_range: Option<SelectionRange>, // For undo
        new_range: SelectionRange,
    },
    ExtendSelection {
        old_range: SelectionRange,
        new_range: SelectionRange,
        direction: SelectionDirection,
    },
    ClearSelection {
        old_range: SelectionRange, // For undo
    },
    
    // === Cursor Mutations (no text change) ===
    MoveCursor {
        old_position: CursorPosition,
        new_position: CursorPosition,
        movement: CursorMovement,
    },
    
    // === Clipboard Operations ===
    Copy {
        range: SelectionRange,
        content: ClipboardContent,
    },
    Cut {
        range: SelectionRange,
        content: ClipboardContent,
        new_cursor: CursorPosition,
    },
    Paste {
        position: CursorPosition,
        content: ClipboardContent,
        new_cursor: CursorPosition,
    },
}

#[derive(Debug, Clone, Copy)]
pub enum SelectionDirection {
    Forward,
    Backward,
}

#[derive(Debug, Clone, Copy)]
pub enum CursorMovement {
    Left,
    Right,
    Up,
    Down,
    WordLeft,
    WordRight,
    LineStart,
    LineEnd,
    DocumentStart,
    DocumentEnd,
}
```

### Changeset Lifecycle

```rust
// 1. PRE-CALLBACK: Create changesets from system events
let changesets = create_changesets_from_system_events(
    &pre_filter.internal_events,
    layout_window,
);

// 2. USER CALLBACKS: Inspect changesets, can preventDefault
let callback_result = run_callbacks_with_changesets(
    user_events,
    &changesets, // Pass to callbacks for inspection
);

// 3. POST-CALLBACK: Apply changesets if not prevented
if !callback_result.prevent_default {
    let applied = apply_changesets(&changesets, layout_window);
    
    // 4. ANALYZE STATE CHANGES: Determine consequences
    let needs_scroll = analyze_scroll_needs(&applied, layout_window);
    if needs_scroll {
        post_filter.system_events.push(
            PostCallbackSystemEvent::ScrollSelectionIntoView {
                scroll_type: determine_scroll_type(&applied),
                scroll_mode: determine_scroll_mode(&applied),
            }
        );
    }
}
```

### Changeset Creation Examples

```rust
// Single click: Create selection changeset
PreCallbackSystemEvent::TextClick { target, position, click_count: 1 } => {
    TextChangeset {
        target,
        operation: TextOperation::MoveCursor {
            old_position: get_current_cursor(target),
            new_position: position_to_cursor(position),
            movement: CursorMovement::Absolute,
        },
    }
}

// Double click: Create word selection changeset
PreCallbackSystemEvent::TextClick { target, position, click_count: 2 } => {
    let word_range = select_word_at_cursor(position);
    TextChangeset {
        target,
        operation: TextOperation::SetSelection {
            old_range: get_current_selection(target),
            new_range: word_range,
        },
    }
}

// Arrow key: Create cursor movement or selection extension changeset
PreCallbackSystemEvent::ArrowKeyNavigation { 
    target, 
    direction: ArrowDirection::Left,
    extend_selection: false,
    word_jump: false,
} => {
    TextChangeset {
        target,
        operation: TextOperation::MoveCursor {
            old_position: get_current_cursor(target),
            new_position: move_cursor_left(get_current_cursor(target)),
            movement: CursorMovement::Left,
        },
    }
}

// Shift+Arrow: Create selection extension changeset
PreCallbackSystemEvent::ArrowKeyNavigation { 
    target, 
    direction: ArrowDirection::Left,
    extend_selection: true,
    word_jump: false,
} => {
    let current_selection = get_current_selection(target);
    TextChangeset {
        target,
        operation: TextOperation::ExtendSelection {
            old_range: current_selection,
            new_range: extend_selection_left(current_selection),
            direction: SelectionDirection::Backward,
        },
    }
}

// Ctrl+C: Create copy changeset (no text mutation)
PreCallbackSystemEvent::KeyboardShortcut { target, shortcut: KeyboardShortcut::Copy } => {
    let selection = get_current_selection(target);
    let content = extract_clipboard_content(selection);
    TextChangeset {
        target,
        operation: TextOperation::Copy {
            range: selection,
            content,
        },
    }
}

// Drag selection: Create selection update changeset
PreCallbackSystemEvent::TextDragSelection { 
    target, 
    start_position, 
    current_position,
    is_dragging: true,
} => {
    TextChangeset {
        target,
        operation: TextOperation::SetSelection {
            old_range: get_current_selection(target),
            new_range: SelectionRange::new(
                position_to_cursor(start_position),
                position_to_cursor(current_position),
            ),
        },
    }
}
```

---

## Phase 3: State-Based Pre-Filter Analysis

### Current Problem

Pre-filter currently analyzes raw events, not state:

```rust
// BAD: Looking for MouseMove event
for event in events {
    if event.event_type == EventType::MouseMove { ... }
}
```

### Solution: Analyze Manager State

```rust
pub fn pre_callback_filter_internal_events(
    events: &[SyntheticEvent],
    hit_test: Option<&FullHitTest>,
    keyboard_state: &KeyboardState,       // NEW: State, not events
    mouse_state: &MouseState,             // NEW: State, not events
    selection_manager: &SelectionManager, // NEW: Selection state
    focus_manager: &FocusManager,         // NEW: Focus state
    scroll_manager: &ScrollManager,       // NEW: Scroll state
) -> PreCallbackFilterResult {
    let mut internal_events = Vec::new();
    let mut user_events = Vec::new();
    
    // === Analyze Selection State ===
    
    // Check for click with updated click count
    if mouse_state.left_button_down && selection_manager.click_state.is_fresh() {
        let click_count = selection_manager.click_state.click_count;
        if click_count > 0 && click_count <= 3 {
            if let Some(target) = get_focused_text_node(focus_manager, hit_test) {
                internal_events.push(PreCallbackSystemEvent::TextClick {
                    target,
                    position: mouse_state.position,
                    click_count,
                    timestamp: mouse_state.last_click_time,
                });
            }
        }
    }
    
    // Check for drag selection (button down + has selection + mouse moved)
    if mouse_state.left_button_down {
        if let Some(selection) = selection_manager.get_active_selection() {
            if let Some(drag_start) = selection_manager.drag_start_position {
                if mouse_state.position.distance_to(drag_start) > 5.0 {
                    if let Some(target) = selection.target {
                        internal_events.push(PreCallbackSystemEvent::TextDragSelection {
                            target,
                            start_position: drag_start,
                            current_position: mouse_state.position,
                            is_dragging: true,
                        });
                    }
                }
            }
        }
    }
    
    // === Analyze Keyboard State ===
    
    // Check for arrow key navigation
    if let Some(vk) = keyboard_state.current_virtual_keycode.as_option() {
        let direction = match vk {
            VirtualKeyCode::Left => Some(ArrowDirection::Left),
            VirtualKeyCode::Right => Some(ArrowDirection::Right),
            VirtualKeyCode::Up => Some(ArrowDirection::Up),
            VirtualKeyCode::Down => Some(ArrowDirection::Down),
            _ => None,
        };
        
        if let Some(direction) = direction {
            if let Some(target) = focus_manager.focused_node {
                internal_events.push(PreCallbackSystemEvent::ArrowKeyNavigation {
                    target,
                    direction,
                    extend_selection: keyboard_state.shift_down(),
                    word_jump: keyboard_state.ctrl_down(),
                });
            }
        }
    }
    
    // Check for keyboard shortcuts (Ctrl+C/X/V/A/Z)
    if keyboard_state.ctrl_down() {
        if let Some(vk) = keyboard_state.current_virtual_keycode.as_option() {
            let shortcut = match vk {
                VirtualKeyCode::C => Some(KeyboardShortcut::Copy),
                VirtualKeyCode::X => Some(KeyboardShortcut::Cut),
                VirtualKeyCode::V => Some(KeyboardShortcut::Paste),
                VirtualKeyCode::A => Some(KeyboardShortcut::SelectAll),
                VirtualKeyCode::Z if !keyboard_state.shift_down() => Some(KeyboardShortcut::Undo),
                VirtualKeyCode::Z if keyboard_state.shift_down() => Some(KeyboardShortcut::Redo),
                VirtualKeyCode::Y => Some(KeyboardShortcut::Redo),
                _ => None,
            };
            
            if let Some(shortcut) = shortcut {
                if let Some(target) = focus_manager.focused_node {
                    internal_events.push(PreCallbackSystemEvent::KeyboardShortcut {
                        target,
                        shortcut,
                    });
                }
            }
        }
    }
    
    // === Analyze Scroll State for Drag-to-Scroll ===
    
    // Check if drag selection is outside container bounds
    if let Some(drag_event) = internal_events.iter().find_map(|e| match e {
        PreCallbackSystemEvent::TextDragSelection { current_position, .. } => Some(current_position),
        _ => None,
    }) {
        if let Some(focused) = focus_manager.focused_node {
            if let Some(container) = scroll_manager.find_scrollable_ancestor(focused) {
                if let Some(container_rect) = get_container_rect(container) {
                    let distance = calculate_edge_distance_from_point(*drag_event, container_rect);
                    
                    // If outside container or within acceleration zone
                    if distance.left < ACCEL_ZONE || distance.right < ACCEL_ZONE ||
                       distance.top < ACCEL_ZONE || distance.bottom < ACCEL_ZONE {
                        // Drag-to-scroll needed - will be handled in post-callback
                        // (Changeset applied first, then scroll analyzed)
                    }
                }
            }
        }
    }
    
    // All events pass through to user callbacks
    user_events.extend_from_slice(events);
    
    PreCallbackFilterResult {
        internal_events,
        user_events,
    }
}
```

**Key Differences**:
- ✅ Uses `KeyboardState::current_virtual_keycode` (not event.key_code)
- ✅ Uses `KeyboardState::shift_down()`, `ctrl_down()` (not event.modifiers)
- ✅ Uses `MouseState::left_button_down` (not tracking events)
- ✅ Uses `SelectionManager::click_state`, `drag_start_position` (not local state)
- ✅ Analyzes state transitions, not event sequences

---

## Phase 4: Post-Filter State Analysis

### Current Problem

Post-filter doesn't analyze state changes:

```rust
// BAD: Hardcoded checks
if !prevent_default {
    apply_text_changeset();
    scroll_focused_cursor_into_view(); // Always called
}
```

### Solution: Analyze Applied Changesets

```rust
pub fn post_callback_filter_internal_events(
    prevent_default: bool,
    changesets: &[TextChangeset],
    layout_window: &mut LayoutWindow,
) -> PostCallbackFilterResult {
    let mut system_events = Vec::new();
    
    if !prevent_default {
        // Apply all changesets
        let applied = apply_changesets(changesets, layout_window);
        
        // === Analyze State Changes ===
        
        // Check if cursor/selection moved and needs scrolling
        for changeset in &applied {
            match &changeset.operation {
                TextOperation::MoveCursor { new_position, .. } => {
                    // Cursor moved - check if visible
                    if !is_cursor_visible(*new_position, layout_window) {
                        system_events.push(PostCallbackSystemEvent::ScrollSelectionIntoView {
                            scroll_type: SelectionScrollType::Cursor,
                            scroll_mode: ScrollMode::Instant,
                        });
                    }
                }
                
                TextOperation::SetSelection { new_range, .. } |
                TextOperation::ExtendSelection { new_range, .. } => {
                    // Selection changed - check if visible
                    if !is_selection_visible(*new_range, layout_window) {
                        system_events.push(PostCallbackSystemEvent::ScrollSelectionIntoView {
                            scroll_type: SelectionScrollType::Selection,
                            scroll_mode: ScrollMode::Instant,
                        });
                    }
                }
                
                TextOperation::InsertText { new_cursor, .. } |
                TextOperation::DeleteText { new_cursor, .. } |
                TextOperation::ReplaceText { new_cursor, .. } => {
                    // Text changed - cursor may need scrolling
                    if !is_cursor_visible(*new_cursor, layout_window) {
                        system_events.push(PostCallbackSystemEvent::ScrollSelectionIntoView {
                            scroll_type: SelectionScrollType::Cursor,
                            scroll_mode: ScrollMode::Instant,
                        });
                    }
                }
                
                _ => {}
            }
        }
        
        // Check if drag selection needs auto-scroll
        let has_active_drag = layout_window.selection_manager.is_dragging();
        if has_active_drag {
            if let Some(mouse_pos) = layout_window.mouse_state.position {
                if let Some(container) = find_scrollable_ancestor(layout_window) {
                    let distance = calculate_edge_distance_from_point(mouse_pos, container);
                    
                    if needs_auto_scroll(distance) {
                        system_events.push(PostCallbackSystemEvent::StartAutoScrollTimer {
                            interval: Duration::from_millis(16), // 60fps
                            scroll_type: SelectionScrollType::DragSelection { 
                                mouse_position: mouse_pos 
                            },
                        });
                    } else {
                        // Mouse returned to safe zone - cancel auto-scroll
                        system_events.push(PostCallbackSystemEvent::CancelAutoScrollTimer);
                    }
                }
            }
        } else {
            // Drag ended - cancel auto-scroll
            system_events.push(PostCallbackSystemEvent::CancelAutoScrollTimer);
        }
    }
    
    PostCallbackFilterResult { system_events }
}
```

**Key Features**:
- ✅ Analyzes applied changesets, not hardcoded
- ✅ Only scrolls if cursor/selection actually moved out of view
- ✅ Determines scroll type/mode from changeset operation
- ✅ Handles drag-to-scroll timer start/cancel automatically
- ✅ No manual calls to scroll functions

---

## Phase 5: Event Loop Integration

### Updated Event Loop Flow

```rust
// === State Diffing ===
let synthetic_events = diff_window_state();

// === Pre-Callback Filter ===
let pre_filter = azul_core::events::pre_callback_filter_internal_events(
    &synthetic_events,
    hit_test.as_ref(),
    &window_state.keyboard_state,        // NEW
    &window_state.mouse_state,           // NEW
    &layout_window.selection_manager,    // NEW
    &layout_window.focus_manager,        // NEW
    &layout_window.scroll_manager,       // NEW
);

// === Changeset Creation ===
let changesets = create_changesets_from_system_events(
    &pre_filter.internal_events,
    layout_window,
);

// === User Callbacks ===
let callback_result = run_callbacks(
    &pre_filter.user_events,
    &changesets, // Available for inspection
);

// === Post-Callback Filter ===
let post_filter = azul_core::events::post_callback_filter_internal_events(
    callback_result.prevent_default,
    &changesets,
    layout_window,
);

// === System Event Processing ===
for event in post_filter.system_events {
    match event {
        PostCallbackSystemEvent::ScrollSelectionIntoView { scroll_type, scroll_mode } => {
            layout_window.scroll_selection_into_view(scroll_type, scroll_mode);
        }
        
        PostCallbackSystemEvent::StartAutoScrollTimer { interval, scroll_type } => {
            start_auto_scroll_timer(interval, scroll_type);
        }
        
        PostCallbackSystemEvent::CancelAutoScrollTimer => {
            cancel_auto_scroll_timer();
        }
        
        // ... other system events
    }
}
```

---

## Implementation Checklist

### ✅ Phase 1: Unified Scroll System
- [ ] Implement `scroll_selection_into_view()` with SelectionScrollType enum
- [ ] Add `calculate_selection_bounding_rect()` method
- [ ] Implement `calculate_edge_distance()` for acceleration
- [ ] Implement `calculate_accelerated_scroll_delta()` with zones
- [ ] Add `ScrollMode::Instant` and `ScrollMode::Accelerated`
- [ ] Deprecate `scroll_focused_cursor_into_view()` (redirect to new method)
- [ ] Add tests for distance-based acceleration

### ✅ Phase 2: Complete Changeset System
- [ ] Create `layout/src/managers/changeset.rs` module
- [ ] Define `TextChangeset` struct with all operations
- [ ] Implement `TextOperation` enum (15+ variants)
- [ ] Implement `create_changesets_from_system_events()`
- [ ] Implement `apply_changesets()` with proper state mutation
- [ ] Add changeset validation (check bounds, permissions, etc.)
- [ ] Add undo/redo stack integration
- [ ] Add tests for each operation type

### ✅ Phase 3: State-Based Pre-Filter
- [ ] Update `pre_callback_filter_internal_events()` signature
  - Add `keyboard_state: &KeyboardState`
  - Add `mouse_state: &MouseState`
  - Add `selection_manager: &SelectionManager`
  - Add `focus_manager: &FocusManager`
  - Add `scroll_manager: &ScrollManager`
- [ ] Remove hardcoded key_code checks (use VirtualKeyCode)
- [ ] Implement click detection from SelectionManager::click_state
- [ ] Implement drag detection from mouse_state + selection state
- [ ] Implement arrow key detection from keyboard_state
- [ ] Implement shortcut detection from keyboard_state
- [ ] Add tests for state-based detection

### ✅ Phase 4: Post-Filter State Analysis
- [ ] Update `post_callback_filter_internal_events()` signature
  - Add `changesets: &[TextChangeset]`
  - Add `layout_window: &mut LayoutWindow`
- [ ] Implement changeset analysis for scroll needs
- [ ] Implement drag-to-scroll timer detection
- [ ] Generate `ScrollSelectionIntoView` events (not hardcoded calls)
- [ ] Generate `StartAutoScrollTimer` / `CancelAutoScrollTimer` events
- [ ] Add tests for state analysis

### ✅ Phase 5: Event Loop Integration
- [ ] Update event_v2.rs to pass manager state to pre-filter
- [ ] Add changeset creation step
- [ ] Pass changesets to callbacks for inspection
- [ ] Update post-filter call with changesets + layout_window
- [ ] Process `PostCallbackSystemEvent::ScrollSelectionIntoView`
- [ ] Implement auto-scroll timer system
- [ ] Remove manual scroll_focused_cursor_into_view() calls
- [ ] Add integration tests

### ✅ Phase 6: Auto-Scroll Timer System
- [ ] Create timer that fires at 60fps during drag
- [ ] Check if still dragging on each timer tick
- [ ] Call `scroll_selection_into_view()` with accelerated mode
- [ ] Update selection to current mouse position
- [ ] Cancel timer on mouse up or mouse returns to container
- [ ] Add timer performance tests

---

## Success Criteria

### ✅ Functional Requirements
- [ ] All text operations use changesets (no direct mutation)
- [ ] preventDefault works for all operations (selection, cursor, clipboard)
- [ ] Cursor scrolls into view automatically (instant)
- [ ] Selection scrolls into view automatically (instant)
- [ ] Drag-to-scroll works with distance-based acceleration
- [ ] Auto-scroll activates when dragging beyond container edge
- [ ] Auto-scroll speed increases with distance from edge
- [ ] Auto-scroll cancels when mouse returns or drag ends

### ✅ Performance Requirements
- [ ] Pre-filter analyzes state in O(1) time (no iteration)
- [ ] Changeset creation is O(n) where n = number of internal events
- [ ] Changeset application is O(n) where n = number of changesets
- [ ] Auto-scroll timer doesn't cause frame drops (60fps maintained)
- [ ] Distance calculation is cached, not recalculated every frame

### ✅ Code Quality Requirements
- [ ] No code duplication between cursor and selection scrolling
- [ ] All scroll logic unified in `scroll_selection_into_view()`
- [ ] Manager state passed explicitly (no hidden dependencies)
- [ ] All operations testable (pure functions where possible)
- [ ] Comprehensive test coverage (>80% for new code)

---

## Migration Strategy

### Step 1: Add New APIs (Non-Breaking)
- Implement `scroll_selection_into_view()` alongside existing
- Implement changeset system as new module
- Update pre/post filters with new signatures

### Step 2: Update Internal Calls
- Replace `scroll_focused_cursor_into_view()` with new API
- Update event loop to use changeset system
- Process post-callback events instead of manual calls

### Step 3: Deprecate Old APIs
- Mark `scroll_focused_cursor_into_view()` as deprecated
- Redirect to new unified method
- Add migration notes in documentation

### Step 4: Remove Old Code
- Delete deprecated methods after 1 release cycle
- Clean up any remaining manual scroll calls
- Remove temporary compatibility shims

---

## Summary

This refactoring creates a **complete lazy-application system** for text editing:

1. **Pre-callback**: Analyze manager state → Generate system events → Create changesets
2. **Callbacks**: User inspects changesets → Can preventDefault
3. **Post-callback**: Apply changesets → Analyze state changes → Generate system events
4. **Processing**: Handle system events (scroll, timers, etc.)

**Key Benefits**:
- ✅ Unified scroll system (cursor = 0-size selection)
- ✅ Distance-based auto-scroll acceleration
- ✅ Complete preventDefault support
- ✅ State-based analysis (no event tracking)
- ✅ Undo/redo ready (changesets recorded)
- ✅ Testable (pure functions)
- ✅ Extensible (new operations easy to add)
