# CSS 2.2 Table Layout Specification → Azul Implementation Mapping

This document maps each section of the CSS 2.2 Table specification (https://www.w3.org/TR/CSS22/tables.html) to the corresponding implementation in Azul's codebase.

**IMPORTANT ARCHITECTURAL DECISIONS:**
1. **Anonymous node generation must work on StyledDom (not Dom)** - This is because we need access to computed CSS display properties to determine what anonymous wrappers are needed.
2. **CallbackInfo methods must skip anonymous nodes** - get_parent(), get_sibling(), etc. should have no access to internal anonymous table structure elements to prevent user code from depending on implementation details.

---

## 17.1 Introduction to tables

**Spec Summary:** Tables are rectangular grids of cells organized into rows and columns. CSS supports two border models (separated and collapsed).

**Implementation Status:** ✅ Basic structure defined

**Code Mapping:**
- `azul/css/src/props/layout/table.rs` - Table CSS properties:
  - `LayoutTableLayout` - Controls layout algorithm (auto vs fixed)
  - `StyleBorderCollapse` - Border rendering model (separate vs collapse)
  - `LayoutBorderSpacing` - Cell spacing for separate borders
  - `StyleCaptionSide` - Caption placement (top vs bottom)
  - `StyleEmptyCells` - Empty cell rendering (show vs hide)

**TODO:**
- [ ] None - properties are complete

---

## 17.2 The CSS table model

**Spec Summary:** Table model includes: table, caption, rows, row groups, columns, column groups, and cells. Document languages map elements to table roles via `display` property.

### Display Property Values

**Spec Section:** Maps HTML elements to CSS display values
```
table    { display: table }
tr       { display: table-row }
thead    { display: table-header-group }
tbody    { display: table-row-group }
tfoot    { display: table-footer-group }
col      { display: table-column }
colgroup { display: table-column-group }
td, th   { display: table-cell }
caption  { display: table-caption }
```

**Implementation Status:** ⚠️ Partial - LayoutDisplay enum exists but may not have all table types

**Code Mapping:**
- `azul/css/src/props/layout/display.rs` - LayoutDisplay enum
- Need to verify these variants exist:
  - `Table` / `InlineTable`
  - `TableRow`
  - `TableRowGroup` / `TableHeaderGroup` / `TableFooterGroup`
  - `TableColumn` / `TableColumnGroup`
  - `TableCell`
  - `TableCaption`

**TODO:**
- [ ] Audit `LayoutDisplay` enum in `display.rs`
- [ ] Add missing table display types if needed
- [ ] Update parser in `display.rs` to handle table display values

---

## 17.2.1 Anonymous table objects

**Spec Summary:** CSS automatically generates missing table elements. Three-stage algorithm:
1. **Remove irrelevant boxes** - Whitespace nodes between table elements
2. **Generate missing child wrappers:**
   - If table child is not proper table child → wrap in anonymous `table-row`
   - If row-group child is not `table-row` → wrap in anonymous `table-row`
   - If row child is not `table-cell` → wrap in anonymous `table-cell`
3. **Generate missing parents:**
   - If `table-cell` without `table-row` parent → create anonymous `table-row`
   - If proper table child is misparented → create anonymous `table`/`inline-table`

**Implementation Status:** ❌ Not implemented

**Code Mapping:**
- **CRITICAL:** Must work on `StyledDom`, not `Dom`
- Location: `azul/core/src/dom.rs` or new file `azul/core/src/table_anonymous.rs`
- Function signature:
  ```rust
  pub fn generate_anonymous_table_elements(
      styled_dom: &mut StyledDom
  ) -> Result<(), TableAnonymousError>
  ```

**Why StyledDom not Dom:**
- Need access to computed `display` property to determine element type
- Dom doesn't have CSS information, StyledDom does
- Must happen after CSS cascade but before layout

**Data Structure Changes:**
- `NodeData` in `azul/core/src/dom.rs` needs:
  ```rust
  pub struct NodeData {
      // ... existing fields ...
      /// Marks nodes generated by anonymous table algorithm
      /// These should be skipped by CallbackInfo accessors
      pub is_anonymous_table_wrapper: bool,
  }
  ```

**Algorithm Implementation (3 stages):**

**Stage 1: Remove irrelevant boxes**
- Skip whitespace-only text nodes between table internal elements
- Location: Preprocessing step in `generate_anonymous_table_elements()`

**Stage 2: Generate missing child wrappers**
- If `table`/`inline-table` has non-proper-child:
  - Wrap consecutive non-proper-children in anonymous `table-row`
  - Mark with `is_anonymous_table_wrapper = true`
- If `table-row-group` has non-`table-row` child:
  - Wrap consecutive non-rows in anonymous `table-row`
- If `table-row` has non-`table-cell` child:
  - Wrap consecutive non-cells in anonymous `table-cell`

**Stage 3: Generate missing parents**
- If `table-cell` sequence has no `table-row` parent:
  - Create anonymous `table-row` wrapper
- If proper table child is misparented:
  - Create anonymous `table` or `inline-table` wrapper
  - Use `inline-table` if parent is inline box

**TODO:**
- [ ] Add `is_anonymous_table_wrapper: bool` to `NodeData`
- [ ] Create `generate_anonymous_table_elements()` function
- [ ] Implement 3-stage algorithm on StyledDom
- [ ] Call from layout pipeline (see 17.4 for integration point)

---

## 17.3 Columns

**Spec Summary:** Columns are derived from rows (row-primary model). Column properties:
- `border` - Only with `border-collapse: collapse`
- `background` - If cell and row are transparent
- `width` - Minimum column width
- `visibility` - `collapse` hides column, other values ignored

**Implementation Status:** ⚠️ Partial - properties exist but column handling not implemented

**Code Mapping:**
- Column width: Part of table layout algorithm (see 17.5.2)
- Column visibility: `azul/css/src/props/style/effects.rs` - Visibility enum
- Need column tracking structure in layout

**Data Structures:**
```rust
// In layout algorithm
struct TableColumnInfo {
    min_width: f32,
    max_width: f32,
    computed_width: Option<f32>,
    visibility: StyleVisibility,
}
```

**TODO:**
- [ ] Create `TableColumnInfo` struct in layout
- [ ] Track column elements during layout
- [ ] Apply column width constraints
- [ ] Handle `visibility: collapse` on columns

---

## 17.4 Tables in the visual formatting model

**Spec Summary:** Tables are block-level (`display: table`) or inline-level (`display: inline-table`). Create **table wrapper box** containing **table box** and **caption boxes**. Table wrapper establishes block formatting context, table box establishes table formatting context.

**Implementation Status:** ❌ Not implemented

**Code Mapping:**
- FormattingContext needs `Table` variant
- Location: `azul/layout/src/solver3/fc.rs` or `azul/layout/src/solver2/layout.rs`

**Current FormattingContext:**
```rust
// Current (needs Table variant)
pub enum FormattingContext {
    Block,
    Inline,
    Flex,
    Grid,
    None,
}
```

**Required Changes:**
```rust
pub enum FormattingContext {
    Block,
    Inline,
    Flex,
    Grid,
    Table,  // NEW
    None,
}

// Determine formatting context based on display property
fn determine_formatting_context(display: LayoutDisplay) -> FormattingContext {
    match display {
        LayoutDisplay::Table | LayoutDisplay::InlineTable => FormattingContext::Table,
        // ... existing cases ...
    }
}
```

**Integration Point:**
- After CSS cascade in `StyledDom` creation
- Before layout calculation
- Sequence:
  1. Parse HTML → Dom
  2. Apply CSS → StyledDom
  3. **Generate anonymous table elements** ← INSERT HERE
  4. Determine formatting contexts
  5. Run layout algorithm

**Code Location:**
- `azul/core/src/dom.rs` - `convert_dom_to_styled_dom()` or similar
- Call `generate_anonymous_table_elements()` on StyledDom

**TODO:**
- [ ] Add `FormattingContext::Table` variant
- [ ] Update `determine_formatting_context()` for table display types
- [ ] Integrate anonymous generation into StyledDom pipeline
- [ ] Create table wrapper box and table box in layout

---

### 17.4.1 Caption position and alignment

**Spec Summary:** `caption-side` property positions caption above (top) or below (bottom) table.

**Implementation Status:** ✅ Property defined

**Code Mapping:**
- Property: `azul/css/src/props/layout/table.rs` - `StyleCaptionSide` enum
- Layout: Handle in table layout algorithm (place caption box before or after table box)

**TODO:**
- [ ] In table layout, check `caption-side` property
- [ ] Position caption box appropriately in table wrapper

---

## 17.5 Visual layout of table contents

**Spec Summary:** Core table layout algorithm. Covers: layers, width algorithm, height algorithm, alignment.

### 17.5.1 Table layers and transparency

**Spec Summary:** Six layered backgrounds (bottom to top):
1. Table box
2. Column groups
3. Columns
4. Row groups
5. Rows
6. Cells

**Implementation Status:** ❌ Not implemented

**Code Mapping:**
- Background painting in rendering
- Location: `azul/layout/src/` or rendering pipeline
- Need to paint backgrounds in correct order

**TODO:**
- [ ] Implement layered background painting
- [ ] Respect layer order when rendering table
- [ ] Handle transparency correctly (let lower layers show through)

---

### 17.5.2 Table width algorithms: the 'table-layout' property

**Spec Summary:** Two algorithms:
- **Fixed** (17.5.2.1): Fast, based on first row and column widths
- **Auto** (17.5.2.2): Slower, content-based, considers all cells

**Implementation Status:** ⚠️ Property defined, algorithms not implemented

**Code Mapping:**
- Property: `azul/css/src/props/layout/table.rs` - `LayoutTableLayout` enum
- Algorithm: Need `layout_table_context()` function
- Location: `azul/layout/src/solver3/fc.rs` or similar

---

#### 17.5.2.1 Fixed table layout

**Spec Algorithm:**
1. Column with `width` property → sets column width
2. Else, first-row cell `width` → sets column width (divide if colspan)
3. Remaining columns share remaining space equally
4. Table width = max(`width` property, sum of column widths + borders/spacing)
5. Extra space distributed over columns

**Implementation Pseudocode:**
```rust
fn layout_table_fixed(
    table: &NodeId,
    styled_dom: &StyledDom,
    available_width: f32,
) -> TableLayout {
    // 1. Collect column elements and their widths
    let mut col_widths = vec![None; num_columns];
    for col in column_elements {
        if let Some(width) = col.width {
            col_widths[col.index] = Some(width);
        }
    }
    
    // 2. Process first row cells
    for cell in first_row_cells {
        if col_widths[cell.col].is_none() {
            if let Some(width) = cell.width {
                let width_per_col = width / cell.colspan;
                for i in 0..cell.colspan {
                    col_widths[cell.col + i] = Some(width_per_col);
                }
            }
        }
    }
    
    // 3. Distribute remaining space
    let total_specified = col_widths.iter().filter_map(|w| *w).sum();
    let remaining = available_width - total_specified;
    let num_unspecified = col_widths.iter().filter(|w| w.is_none()).count();
    let width_per_unspecified = remaining / num_unspecified as f32;
    
    for width in &mut col_widths {
        if width.is_none() {
            *width = Some(width_per_unspecified);
        }
    }
    
    // 4. Return layout
    TableLayout { col_widths, ... }
}
```

**TODO:**
- [ ] Implement `layout_table_fixed()`
- [ ] Handle column elements with width
- [ ] Handle first-row cell widths
- [ ] Distribute remaining space

---

#### 17.5.2.2 Automatic table layout

**Spec Algorithm:**
1. Calculate min/max content width (MCW/MAX) for each cell
2. For single-column cells: column min = max(cell MCW, column width), column max = max(cell MAX, column width)
3. For multi-column cells: distribute min/max across spanned columns
4. For column groups: ensure spanned columns meet group width
5. Final table width = max(table width property, CAPMIN, MIN of all columns)
6. Distribute: if final > MIN, distribute extra space

**Implementation Pseudocode:**
```rust
fn layout_table_auto(
    table: &NodeId,
    styled_dom: &StyledDom,
    available_width: f32,
) -> TableLayout {
    // 1. Calculate MCW and MAX for each cell
    struct CellMetrics {
        min_content_width: f32,  // MCW
        max_content_width: f32,  // MAX
        col: usize,
        colspan: usize,
    }
    
    let cell_metrics: Vec<CellMetrics> = cells.iter().map(|cell| {
        // Layout cell content to get metrics
        CellMetrics {
            min_content_width: measure_min_content(cell),
            max_content_width: measure_max_content(cell),
            col: cell.column_index,
            colspan: cell.colspan,
        }
    }).collect();
    
    // 2. Calculate column min/max
    let mut col_min = vec![0.0; num_columns];
    let mut col_max = vec![0.0; num_columns];
    
    for cell in &cell_metrics {
        if cell.colspan == 1 {
            col_min[cell.col] = col_min[cell.col].max(cell.min_content_width);
            col_max[cell.col] = col_max[cell.col].max(cell.max_content_width);
        }
    }
    
    // 3. Handle multi-column cells (distribute min/max)
    for cell in cell_metrics.iter().filter(|c| c.colspan > 1) {
        let total_min: f32 = (cell.col..cell.col + cell.colspan)
            .map(|i| col_min[i]).sum();
        if cell.min_content_width > total_min {
            distribute_excess(&mut col_min, cell.col, cell.colspan, 
                             cell.min_content_width - total_min);
        }
        // Same for max
    }
    
    // 4. Final width calculation
    let min_table_width: f32 = col_min.iter().sum();
    let max_table_width: f32 = col_max.iter().sum();
    let final_width = available_width.clamp(min_table_width, max_table_width);
    
    // 5. Distribute final width across columns
    let col_widths = if final_width > min_table_width {
        distribute_width_proportional(&col_min, &col_max, final_width)
    } else {
        col_min
    };
    
    TableLayout { col_widths, ... }
}
```

**TODO:**
- [ ] Implement `layout_table_auto()`
- [ ] Calculate min/max content width per cell
- [ ] Handle single-column cells
- [ ] Handle multi-column cells with distribution
- [ ] Apply column group constraints
- [ ] Distribute final width proportionally

---

### 17.5.3 Table height algorithms

**Spec Summary:**
- Table height = `height` property or sum of row heights + spacing/borders
- Row height = max(row's `height`, all cell heights in row, MIN required by cells)
- Cell height from content, cell `height` property influences row height
- Multi-row cells: sum of spanned rows must encompass cell

**Implementation Pseudocode:**
```rust
fn calculate_table_height(
    table: &NodeId,
    styled_dom: &StyledDom,
    col_widths: &[f32],
) -> TableHeightLayout {
    // 1. Calculate height for each cell (given column widths)
    let cell_heights = cells.iter().map(|cell| {
        layout_cell_content(cell, col_widths[cell.col], styled_dom)
    }).collect();
    
    // 2. Calculate row heights
    let mut row_heights = vec![0.0; num_rows];
    for (cell, height) in cells.iter().zip(&cell_heights) {
        if cell.rowspan == 1 {
            let row_height = row_heights[cell.row];
            let min_height = height.max(cell.height_property.unwrap_or(0.0));
            row_heights[cell.row] = row_height.max(min_height);
        }
    }
    
    // 3. Handle multi-row cells
    for cell in cells.iter().filter(|c| c.rowspan > 1) {
        let total_height: f32 = (cell.row..cell.row + cell.rowspan)
            .map(|i| row_heights[i]).sum();
        if cell_heights[cell.index] > total_height {
            // Distribute extra height across spanned rows
            let extra = cell_heights[cell.index] - total_height;
            distribute_height(&mut row_heights, cell.row, cell.rowspan, extra);
        }
    }
    
    // 4. Total table height
    let content_height: f32 = row_heights.iter().sum();
    let table_height = table.height_property.map(|h| h.max(content_height))
        .unwrap_or(content_height);
    
    TableHeightLayout { row_heights, total_height: table_height }
}
```

**Vertical Alignment (`vertical-align` on cells):**
- `baseline` - Cell baseline aligns with row baseline
- `top` - Cell top aligns with row top
- `bottom` - Cell bottom aligns with row bottom
- `middle` - Cell center aligns with row center

**TODO:**
- [ ] Implement `calculate_table_height()`
- [ ] Layout cell content given column widths
- [ ] Calculate row heights from cell heights
- [ ] Handle multi-row cell height distribution
- [ ] Apply `vertical-align` property to position cell content within row

---

### 17.5.4 Horizontal alignment in a column

**Spec Summary:** Use `text-align` property on cells for horizontal alignment.

**Implementation Status:** ✅ `text-align` property exists

**Code Mapping:**
- Property: `azul/css/src/props/style/text.rs` - `StyleTextAlign`
- Apply during cell content layout

**TODO:**
- [ ] Respect `text-align` when laying out cell content

---

### 17.5.5 Dynamic row and column effects

**Spec Summary:** `visibility: collapse` on rows/columns removes them without forcing table re-layout. Contents of intersecting cells are clipped.

**Implementation Status:** ⚠️ `visibility` property exists, collapse behavior not implemented

**Code Mapping:**
- Property: `azul/css/src/props/style/effects.rs` - `StyleVisibility` enum
- Check for `Collapse` variant on `table-row` and `table-column`
- Skip row/column in layout, clip intersecting cells

**TODO:**
- [ ] Check `visibility: collapse` on rows/columns
- [ ] Skip collapsed rows/columns in height/width calculation
- [ ] Clip cell contents that span into collapsed areas

---

## 17.6 Borders

**Spec Summary:** Two border models: separated and collapsed.

**Property:** `border-collapse` on table element

**Implementation Status:** ✅ Property defined

**Code Mapping:**
- Property: `azul/css/src/props/layout/table.rs` - `StyleBorderCollapse` enum

---

### 17.6.1 The separated borders model

**Spec Summary:** Each cell has individual border. `border-spacing` specifies distance between cell borders. Rows/columns/groups cannot have borders (ignored).

**Property:** `border-spacing`

**Implementation Status:** ✅ Property defined

**Code Mapping:**
- Property: `azul/css/src/props/layout/table.rs` - `LayoutBorderSpacing` struct
- Apply spacing when positioning cells:
  ```rust
  cell_x = prev_cell_x + prev_cell_width + border_spacing.horizontal;
  cell_y = prev_cell_y + prev_cell_height + border_spacing.vertical;
  ```

**TODO:**
- [ ] Apply `border-spacing` when calculating cell positions
- [ ] Ignore border properties on rows/columns/groups

---

#### 17.6.1.1 Borders and backgrounds around empty cells: the 'empty-cells' property

**Spec Summary:** Controls rendering of borders/backgrounds around empty cells (only in separated border model).
- `show` - Draw borders/backgrounds (default)
- `hide` - Don't draw borders/backgrounds

**Empty cell definition:**
- No visible content (no text, no floating/in-flow elements except collapsed whitespace)

**Implementation Status:** ✅ Property defined

**Code Mapping:**
- Property: `azul/css/src/props/layout/table.rs` - `StyleEmptyCells` enum
- Check during rendering:
  ```rust
  fn should_draw_cell_border(cell: &Cell, empty_cells: StyleEmptyCells) -> bool {
      if !cell.is_empty() {
          return true;
      }
      match empty_cells {
          StyleEmptyCells::Show => true,
          StyleEmptyCells::Hide => false,
      }
  }
  ```

**TODO:**
- [ ] Detect empty cells (no visible content)
- [ ] Skip border/background rendering for empty cells when `empty-cells: hide`

---

### 17.6.2 The collapsing border model

**Spec Summary:** Borders centered on grid lines between cells. Adjacent cells share borders. Border conflict resolution determines which border style wins.

**Implementation Status:** ⚠️ Property defined, algorithm not implemented

**Code Mapping:**
- Property: `azul/css/src/props/layout/table.rs` - `StyleBorderCollapse::Collapse`
- Need border conflict resolution algorithm

---

#### 17.6.2.1 Border conflict resolution

**Spec Summary:** When borders conflict at an edge, resolve by priority:
1. `border-style: hidden` wins (suppresses all borders)
2. `border-style: none` loses (lowest priority)
3. Wider borders win over narrower
4. If same width, style priority: double > solid > dashed > dotted > ridge > outset > groove > inset
5. If same style, color from cell > row > row-group > column > column-group > table
6. If same element type, left/top wins over right/bottom (for ltr tables)

**Implementation Pseudocode:**
```rust
enum BorderSource {
    Cell(NodeId),
    Row(NodeId),
    RowGroup(NodeId),
    Column(NodeId),
    ColumnGroup(NodeId),
    Table(NodeId),
}

struct CellEdgeBorder {
    width: f32,
    style: BorderStyle,
    color: ColorU,
    source: BorderSource,
}

fn resolve_border_conflict(borders: &[CellEdgeBorder]) -> Option<CellEdgeBorder> {
    // 1. Filter out 'none', return immediately if any 'hidden'
    if borders.iter().any(|b| b.style == BorderStyle::Hidden) {
        return None;
    }
    let borders: Vec<_> = borders.iter()
        .filter(|b| b.style != BorderStyle::None)
        .collect();
    if borders.is_empty() {
        return None;
    }
    
    // 2. Find widest border
    let max_width = borders.iter().map(|b| b.width).max().unwrap();
    let widest: Vec<_> = borders.iter()
        .filter(|b| b.width == max_width)
        .collect();
    
    // 3. If multiple widest, resolve by style priority
    const STYLE_PRIORITY: &[BorderStyle] = &[
        BorderStyle::Double, BorderStyle::Solid, BorderStyle::Dashed,
        BorderStyle::Dotted, BorderStyle::Ridge, BorderStyle::Outset,
        BorderStyle::Groove, BorderStyle::Inset
    ];
    for style in STYLE_PRIORITY {
        if let Some(border) = widest.iter().find(|b| b.style == *style) {
            return Some((*border).clone());
        }
    }
    
    // 4. If same style, resolve by source priority
    const SOURCE_PRIORITY: &[fn(&BorderSource) -> u8] = &[
        |s| matches!(s, BorderSource::Cell(_)) as u8,
        |s| matches!(s, BorderSource::Row(_)) as u8,
        |s| matches!(s, BorderSource::RowGroup(_)) as u8,
        |s| matches!(s, BorderSource::Column(_)) as u8,
        |s| matches!(s, BorderSource::ColumnGroup(_)) as u8,
        |s| matches!(s, BorderSource::Table(_)) as u8,
    ];
    
    // ... priority resolution logic
    widest[0].clone()
}
```

**TODO:**
- [ ] Collect borders from all sources (cell, row, column, groups, table)
- [ ] Implement `resolve_border_conflict()` algorithm
- [ ] Apply resolved borders when rendering collapsed border tables

---

### 17.6.3 Border styles

**Spec Summary:** Standard border styles plus table-specific meanings:
- `hidden` - Suppresses all borders (collapsing model only)
- `inset`/`outset` - Different behavior in separated vs collapsed models

**Implementation Status:** ✅ Border styles exist in CSS

**Code Mapping:**
- `azul/css/src/props/style/border.rs` - Border style enums
- Handle `hidden` specially in collapsed border model

**TODO:**
- [ ] Handle `border-style: hidden` in collapsed model (suppress borders)
- [ ] Implement different rendering for `inset`/`outset` in each model

---

## Integration Checklist

### Phase 1: Foundation (Properties & Types) ✅ COMPLETE
- [x] Add table CSS properties to `table.rs`
- [x] Add `FormatAsRustCode` implementations
- [x] Fix `repr(C)` issues
- [x] Integrate properties into `property.rs` (all 20+ match arms)
- [x] Compile azul-css successfully

### Phase 2: Display Types & Anonymous Generation
- [ ] Audit `LayoutDisplay` enum for all table display types
- [ ] Add missing display types: Table, InlineTable, TableRow, TableRowGroup, TableHeaderGroup, TableFooterGroup, TableColumn, TableColumnGroup, TableCell, TableCaption
- [ ] Add `is_anonymous_table_wrapper: bool` to `NodeData`
- [ ] Implement `generate_anonymous_table_elements()` on StyledDom
  - Stage 1: Remove irrelevant whitespace
  - Stage 2: Generate missing child wrappers
  - Stage 3: Generate missing parents
- [ ] Integrate into StyledDom creation pipeline

### Phase 3: CallbackInfo Integration
- [ ] Update `get_parent()` in CallbackInfo to skip anonymous nodes
- [ ] Update `get_sibling()` in CallbackInfo to skip anonymous nodes
- [ ] Update `get_first_child()` / `get_last_child()` to skip anonymous nodes
- [ ] Add tests to verify callbacks don't see anonymous structure

### Phase 4: Formatting Context
- [ ] Add `FormattingContext::Table` variant
- [ ] Update `determine_formatting_context()` for table display types
- [ ] Ensure table elements establish table formatting context

### Phase 5: Layout Algorithm - Width
- [ ] Create `TableLayoutContext` struct
- [ ] Implement `layout_table_fixed()` (17.5.2.1)
  - Handle column element widths
  - Handle first-row cell widths
  - Distribute remaining space
- [ ] Implement `layout_table_auto()` (17.5.2.2)
  - Calculate min/max content width per cell
  - Handle single-column cells
  - Handle multi-column cell width distribution
  - Apply column group constraints
- [ ] Implement column width resolution based on `table-layout` property

### Phase 6: Layout Algorithm - Height
- [ ] Implement `calculate_table_height()`
- [ ] Layout cell content given column widths
- [ ] Calculate row heights from cell heights
- [ ] Handle multi-row cell height distribution
- [ ] Apply `vertical-align` for cell content positioning

### Phase 7: Border Handling
- [ ] Implement separated border model
  - Apply `border-spacing` to cell positions
  - Respect `empty-cells` property
- [ ] Implement collapsed border model
  - Collect borders from all sources
  - Implement border conflict resolution algorithm
  - Handle `border-style: hidden`

### Phase 8: Layers & Rendering
- [ ] Implement layered background painting (6 layers)
- [ ] Respect layer order during rendering
- [ ] Handle transparency correctly

### Phase 9: Advanced Features
- [ ] Column `visibility: collapse` handling
- [ ] Row `visibility: collapse` handling
- [ ] Caption positioning (`caption-side`)
- [ ] Table `height` property handling
- [ ] Horizontal alignment (`text-align`)

### Phase 10: Testing & Refinement
- [ ] Create test suite for anonymous generation
- [ ] Create test suite for layout algorithms
- [ ] Test border collapse edge cases
- [ ] Test vertical alignment
- [ ] Test multi-row/multi-column cells
- [ ] Visual regression tests

---

## Key Architectural Notes

### 1. StyledDom vs Dom for Anonymous Generation

**CRITICAL DECISION:** Anonymous table element generation MUST work on `StyledDom`, not `Dom`.

**Reasoning:**
- Need access to computed CSS `display` property
- Must determine if element is `table`, `table-row`, `table-cell`, etc.
- Dom has no CSS information
- StyledDom has computed styles after cascade

**Pipeline:**
```
HTML Parse → Dom → Apply CSS → StyledDom → 
  [Generate Anonymous Table Elements] → 
    Determine FormattingContexts → Layout → Render
```

### 2. CallbackInfo Must Skip Anonymous Nodes

**CRITICAL REQUIREMENT:** User callbacks must have no access to anonymous table structure.

**Why:**
- Anonymous nodes are implementation detail
- User code should not depend on internal structure
- DOM API should reflect original document, not internal representation

**Implementation:**
- All traversal methods check `is_anonymous_table_wrapper` flag
- `get_parent()` - Skip anonymous ancestors
- `get_sibling()` - Skip anonymous siblings
- `get_first_child()` / `get_last_child()` - Skip anonymous children

**Example:**
```html
<!-- Original HTML -->
<table>
  <div>Content</div>
</table>

<!-- After anonymous generation (internal) -->
<table>
  <tr is_anonymous="true">
    <td is_anonymous="true">
      <div>Content</div>
    </td>
  </tr>
</table>

<!-- CallbackInfo sees (logical view) -->
<table>
  <div>Content</div>
</table>
```

### 3. Layout Algorithm Selection

Check `table-layout` property:
```rust
match table.get_property_or_default(CssPropertyType::TableLayout) {
    LayoutTableLayout::Fixed => layout_table_fixed(table, styled_dom, available_width),
    LayoutTableLayout::Auto => layout_table_auto(table, styled_dom, available_width),
}
```

### 4. Border Model Selection

Check `border-collapse` property:
```rust
match table.get_property_or_default(CssPropertyType::BorderCollapse) {
    StyleBorderCollapse::Separate => {
        let spacing = table.get_property_or_default(CssPropertyType::BorderSpacing);
        render_separated_borders(table, spacing);
    }
    StyleBorderCollapse::Collapse => {
        let borders = resolve_collapsed_borders(table);
        render_collapsed_borders(table, borders);
    }
}
```

---

## References

- **CSS 2.2 Specification:** https://www.w3.org/TR/CSS22/tables.html
- **371.patch:** Old PR with table layout implementation (use as reference, not 1:1 port)
- **Azul CSS Properties:** `azul/css/src/props/layout/table.rs`
- **Azul Layout:** `azul/layout/src/solver3/fc.rs` or `solver2/layout.rs`
- **Azul DOM:** `azul/core/src/dom.rs`

---

## Document Status

**Created:** 2025-11-14  
**Last Updated:** 2025-11-14  
**Status:** Initial comprehensive mapping complete  
**Next Action:** Begin Phase 2 - Display Types & Anonymous Generation
