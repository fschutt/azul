#!/usr/bin/env python3
"""
Analyze coverage.txt to find poorly-tested and untested code in the layout engine.

Usage:
    python3 scripts/analyze_coverage.py [coverage.txt]

Reads coverage.txt (generated by scripts/coverage.sh) and reports:
  - Completely untested layout files (0%)
  - Poorly tested layout files (<30%)
  - Untested function groups (by module area)
  - Summary statistics
"""

import sys
import os
import re
from collections import defaultdict

def parse_coverage(path):
    """Parse coverage.txt into list of (pct, covered, total, filepath)."""
    entries = []
    with open(path) as f:
        for line in f:
            line = line.strip()
            m = re.match(r'([\d.]+)%\s+(\d+)/(\d+)\s+(.+)', line)
            if m:
                pct = float(m.group(1))
                covered = int(m.group(2))
                total = int(m.group(3))
                filepath = m.group(4)
                entries.append((pct, covered, total, filepath))
    return entries

def categorize(entries):
    """Group entries by crate and module area."""
    groups = defaultdict(list)
    for pct, covered, total, path in entries:
        parts = path.split('/')
        if len(parts) >= 2:
            crate = parts[0]  # core, css, layout
            if len(parts) >= 3:
                area = '/'.join(parts[:3])  # e.g. layout/src/solver3
            else:
                area = '/'.join(parts[:2])
            groups[area].append((pct, covered, total, path))
    return groups

def main():
    coverage_file = sys.argv[1] if len(sys.argv) > 1 else 'coverage.txt'
    if not os.path.exists(coverage_file):
        print(f"Error: {coverage_file} not found. Run scripts/coverage.sh first.")
        sys.exit(1)

    entries = parse_coverage(coverage_file)
    if not entries:
        print("No coverage data found.")
        sys.exit(1)

    # Filter to layout files only
    layout_entries = [(p, c, t, f) for p, c, t, f in entries if f.startswith('layout/')]
    core_entries = [(p, c, t, f) for p, c, t, f in entries if f.startswith('core/')]
    css_entries = [(p, c, t, f) for p, c, t, f in entries if f.startswith('css/')]

    # === SECTION 1: Overall summary ===
    print("=" * 70)
    print("COVERAGE ANALYSIS REPORT")
    print("=" * 70)

    for label, group in [("core", core_entries), ("css", css_entries), ("layout", layout_entries)]:
        total_lines = sum(t for _, _, t, _ in group)
        covered_lines = sum(c for _, c, t, _ in group)
        pct = covered_lines / total_lines * 100 if total_lines else 0
        zero_count = sum(1 for p, _, _, _ in group if p == 0)
        print(f"  {label:>8s}: {pct:5.1f}%  ({covered_lines}/{total_lines} lines)  "
              f"  [{zero_count} files at 0%]")

    total_lines = sum(t for _, _, t, _ in entries)
    covered_lines = sum(c for _, c, t, _ in entries)
    total_pct = covered_lines / total_lines * 100 if total_lines else 0
    print(f"  {'TOTAL':>8s}: {total_pct:5.1f}%  ({covered_lines}/{total_lines} lines)")
    print()

    # === SECTION 2: Completely untested layout files ===
    untested = [(p, c, t, f) for p, c, t, f in layout_entries if p == 0.0]
    untested.sort(key=lambda x: -x[2])  # sort by total lines desc

    print("=" * 70)
    print(f"UNTESTED LAYOUT FILES (0% coverage) — {len(untested)} files")
    print("=" * 70)
    for _, _, total, path in untested:
        print(f"  {total:5d} lines  {path}")
    untested_lines = sum(t for _, _, t, _ in untested)
    print(f"  {'─' * 50}")
    print(f"  {untested_lines:5d} lines total untested")
    print()

    # === SECTION 3: Poorly tested layout files (<30%) ===
    poor = [(p, c, t, f) for p, c, t, f in layout_entries if 0 < p < 30]
    poor.sort(key=lambda x: x[0])

    print("=" * 70)
    print(f"POORLY TESTED LAYOUT FILES (<30% coverage) — {len(poor)} files")
    print("=" * 70)
    for pct, covered, total, path in poor:
        uncovered = total - covered
        print(f"  {pct:5.1f}%  ({uncovered:4d} uncovered)  {path}")
    print()

    # === SECTION 4: Module area breakdown ===
    groups = categorize(layout_entries)

    print("=" * 70)
    print("LAYOUT MODULE AREA BREAKDOWN")
    print("=" * 70)
    area_stats = []
    for area, items in sorted(groups.items()):
        total = sum(t for _, _, t, _ in items)
        covered = sum(c for _, c, t, _ in items)
        pct = covered / total * 100 if total else 0
        area_stats.append((pct, covered, total, area, len(items)))

    area_stats.sort(key=lambda x: x[0])
    for pct, covered, total, area, nfiles in area_stats:
        bar_len = int(pct / 2)
        bar = '█' * bar_len + '░' * (50 - bar_len)
        print(f"  {pct:5.1f}%  {bar}  {area} ({nfiles} files, {total} lines)")
    print()

    # === SECTION 5: High-impact untested code ===
    print("=" * 70)
    print("HIGH-IMPACT UNTESTED CODE (large files with low coverage)")
    print("=" * 70)
    print("  These files have the most uncovered lines:")
    print()

    # Sort all entries by uncovered lines desc
    by_uncovered = [(t - c, p, c, t, f) for p, c, t, f in layout_entries]
    by_uncovered.sort(reverse=True)
    for uncovered, pct, covered, total, path in by_uncovered[:15]:
        print(f"  {uncovered:5d} uncovered  ({pct:5.1f}% of {total:5d})  {path}")
    print()

    # === SECTION 6: Well-tested files ===
    well_tested = [(p, c, t, f) for p, c, t, f in layout_entries if p >= 50]
    well_tested.sort(key=lambda x: -x[0])

    print("=" * 70)
    print(f"WELL-TESTED LAYOUT FILES (≥50%) — {len(well_tested)} files")
    print("=" * 70)
    for pct, covered, total, path in well_tested:
        print(f"  {pct:5.1f}%  {covered:4d}/{total:<4d}  {path}")
    print()


if __name__ == '__main__':
    main()
