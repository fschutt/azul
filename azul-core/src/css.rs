//! Module for printing the CSS to Rust code

use alloc::collections::btree_map::BTreeMap;
use alloc::string::String;
use alloc::vec::Vec;
use azul_css::*;
use core::hash::Hash;

// In order to generate the Rust code, all items that implement Drop
// have to be declared before being used.
//
// This code does not compile:
//
// const A: StyleFontFamily = StyleFontFamily {
//     inner: AzString::from_const_str("Arial")
// };
//
// ... but this code does:
//
// static STRING_CONTENTS_1029834123098: &'static str = "Arial";
// static STRING_1029834123098: AzString = AzString::from_const_str(STRING_CONTENTS_1029834123098);
// const A: StyleFontFamily = StyleFontFamily { inner: STRING_1029834123098 };
//
// ... so during the XML-to-Rust compilation process, we have
// to separate out all types that implement Drop:
#[derive(Default)]
pub struct VecContents {
    // the u64 is the hash of the type (generated by string.get_hash())
    strings: BTreeMap<u64, AzString>,
    style_filters: BTreeMap<u64, StyleFilterVec>,
    style_background_sizes: BTreeMap<u64, StyleBackgroundSizeVec>,
    style_background_repeats: BTreeMap<u64, StyleBackgroundRepeatVec>,
    style_background_contents: BTreeMap<u64, StyleBackgroundContentVec>,
    style_background_positions: BTreeMap<u64, StyleBackgroundPositionVec>,
    style_transforms: BTreeMap<u64, StyleTransformVec>,
    font_families: BTreeMap<u64, StyleFontFamilyVec>,
    linear_color_stops: BTreeMap<u64, NormalizedLinearColorStopVec>,
    radial_color_stops: BTreeMap<u64, NormalizedRadialColorStopVec>,
}

impl VecContents {
    pub fn format(&self, tabs: usize) -> String {
        let mut result = String::new();
        let t = "    ".repeat(tabs);
        let t2 = "    ".repeat(tabs + 1);

        for (key, item) in self.strings.iter() {
            result.push_str(&format!(
                "\r\n    const STRING_{}: AzString = AzString::from_const_str(\"{}\");",
                key,
                item.as_str()
            ));
        }

        for (key, item) in self.style_filters.iter() {
            let val = item
                .iter()
                .map(|filter| format_style_filter(filter, tabs + 1))
                .collect::<Vec<_>>()
                .join(&format!(",\r\n{}", t));

            result.push_str(&format!(
                "\r\n    const STYLE_FILTER_{}_ITEMS: &[StyleFilter] = &[\r\n{}{}\r\n{}];",
                key, t2, val, t
            ));
        }

        for (key, item) in self.style_background_sizes.iter() {
            let val = item
                .iter()
                .map(|bgs| format_style_background_size(bgs))
                .collect::<Vec<_>>()
                .join(&format!(",\r\n{}", t));

            result.push_str(&format!("\r\n    const STYLE_BACKGROUND_SIZE_{}_ITEMS: &[StyleBackgroundSize] = &[\r\n{}{}\r\n{}];",
            key, t2, val, t));
        }

        for (key, item) in self.style_background_repeats.iter() {
            let val = item
                .iter()
                .map(|bgr| bgr.format_as_rust_code(tabs + 1))
                .collect::<Vec<_>>()
                .join(&format!(",\r\n{}", t));

            result.push_str(&format!("\r\n    const STYLE_BACKGROUND_REPEAT_{}_ITEMS: &[StyleBackgroundRepeat] = &[\r\n{}{}\r\n{}];",
            key, t2, val, t));
        }

        for (key, item) in self.style_background_contents.iter() {
            let val = item
                .iter()
                .map(|bgc| format_style_background_content(bgc, tabs + 1))
                .collect::<Vec<_>>()
                .join(&format!(",\r\n{}", t));

            result.push_str(&format!("\r\n    const STYLE_BACKGROUND_CONTENT_{}_ITEMS: &[StyleBackgroundContent] = &[\r\n{}{}\r\n{}];",
            key, t2, val, t));
        }

        for (key, item) in self.style_background_positions.iter() {
            let val = item
                .iter()
                .map(|bgp| format_style_background_position(bgp, tabs))
                .collect::<Vec<_>>()
                .join(&format!(",\r\n{}", t));

            result.push_str(&format!("\r\n    const STYLE_BACKGROUND_POSITION_{}_ITEMS: &[StyleBackgroundPosition] = &[\r\n{}{}\r\n{}];",
            key, t2, val, t));
        }

        for (key, item) in self.style_transforms.iter() {
            let val = format_style_transforms(item.as_ref(), tabs + 1);

            result.push_str(&format!(
                "\r\n    const STYLE_TRANSFORM_{}_ITEMS: &[StyleTransform] = &[\r\n{}{}\r\n{}];",
                key, t2, val, t
            ));
        }

        for (key, item) in self.font_families.iter() {
            let val = format_font_ids(item.as_ref(), tabs + 1);

            result.push_str(&format!(
                "\r\n    const STYLE_FONT_FAMILY_{}_ITEMS: &[StyleFontFamily] = &[\r\n{}{}\r\n{}];",
                key, t2, val, t
            ));
        }

        for (key, item) in self.linear_color_stops.iter() {
            let val = format_linear_color_stops(item.as_ref(), 1);

            result.push_str(&format!("\r\n    const LINEAR_COLOR_STOP_{}_ITEMS: &[NormalizedLinearColorStop] = &[\r\n{}{}\r\n{}];",
            key, t2, val, t));
        }

        for (key, item) in self.radial_color_stops.iter() {
            let val = format_radial_color_stops(item.as_ref(), tabs);

            result.push_str(&format!("\r\n    const RADIAL_COLOR_STOP_{}_ITEMS: &[NormalizedRadialColorStop] = &[\r\n{}{}\r\n{}];",
            key, t2, val, t));
        }

        result
    }

    // given a CSS property, clones all the necessary strings (see class documentation)
    pub fn insert_from_css_property(&mut self, prop: &CssProperty) {
        match prop {
            CssProperty::FontFamily(CssPropertyValue::Exact(v)) => {
                for family in v.iter() {
                    match family {
                        StyleFontFamily::System(s) => {
                            // if the font-family is surrounded by quotes, strip them ("Arial" -> Arial)
                            let s = s.as_str();
                            let s = s.trim();
                            let s = s.trim_start_matches('\"');
                            let s = s.trim_end_matches('\"');
                            let s = s.trim_start_matches('\'');
                            let s = s.trim_end_matches('\'');

                            self.strings.insert(s.get_hash(), s.to_string().into());
                        }
                        StyleFontFamily::File(s) => {
                            let s = s.as_str();
                            let s = s.trim();
                            let s = s.trim_start_matches('\"');
                            let s = s.trim_end_matches('\"');
                            let s = s.trim_start_matches('\'');
                            let s = s.trim_end_matches('\'');

                            self.strings.insert(s.get_hash(), s.to_string().into());
                        }
                        _ => {}
                    }
                }
                self.font_families.insert(v.get_hash(), v.clone());
            }
            CssProperty::Transform(CssPropertyValue::Exact(v)) => {
                self.style_transforms.insert(v.get_hash(), v.clone());
            }
            CssProperty::BackgroundRepeat(CssPropertyValue::Exact(v)) => {
                self.style_background_repeats
                    .insert(v.get_hash(), v.clone());
            }
            CssProperty::BackgroundSize(CssPropertyValue::Exact(v)) => {
                self.style_background_sizes.insert(v.get_hash(), v.clone());
            }
            CssProperty::BackgroundPosition(CssPropertyValue::Exact(v)) => {
                self.style_background_positions
                    .insert(v.get_hash(), v.clone());
            }
            CssProperty::BackgroundContent(CssPropertyValue::Exact(v)) => {
                for background in v.iter() {
                    match background {
                        StyleBackgroundContent::Image(id) => {
                            self.strings.insert(id.get_hash(), id.clone());
                        }
                        StyleBackgroundContent::LinearGradient(lg) => {
                            self.linear_color_stops
                                .insert(lg.stops.get_hash(), lg.stops.clone());
                        }
                        StyleBackgroundContent::RadialGradient(rg) => {
                            self.linear_color_stops
                                .insert(rg.stops.get_hash(), rg.stops.clone());
                        }
                        StyleBackgroundContent::ConicGradient(lg) => {
                            self.radial_color_stops
                                .insert(lg.stops.get_hash(), lg.stops.clone());
                        }
                        _ => {}
                    }
                }
                self.style_background_contents
                    .insert(v.get_hash(), v.clone());
            }
            CssProperty::Filter(CssPropertyValue::Exact(v)) => {
                self.style_filters.insert(v.get_hash(), v.clone());
            }
            CssProperty::BackdropFilter(CssPropertyValue::Exact(v)) => {
                self.style_filters.insert(v.get_hash(), v.clone());
            }
            _ => {}
        }
    }
}

pub fn css_to_rust_code(css: &Css) -> String {
    let mut output = String::new();

    output.push_str("const CSS: Css = Css {\r\n");
    output.push_str("\tstylesheets: [\r\n");

    for stylesheet in css.stylesheets.iter() {
        output.push_str("\t\tStylesheet {\r\n");
        output.push_str("\t\t\trules: [\r\n");

        for block in stylesheet.rules.iter() {
            output.push_str("\t\t\t\tCssRuleBlock: {\r\n");
            output.push_str(&format!(
                "\t\t\t\t\tpath: {},\r\n",
                print_block_path(&block.path, 5)
            ));

            output.push_str("\t\t\t\t\tdeclarations: [\r\n");

            for declaration in block.declarations.iter() {
                output.push_str(&format!(
                    "\t\t\t\t\t\t{},\r\n",
                    print_declaraction(declaration, 6)
                ));
            }

            output.push_str("\t\t\t\t\t]\r\n");

            output.push_str("\t\t\t\t},\r\n");
        }

        output.push_str("\t\t\t]\r\n");
        output.push_str("\t\t},\r\n");
    }

    output.push_str("\t]\r\n");
    output.push_str("};");

    let output = output.replace("\t", "    ");

    output
}

fn print_block_path(path: &CssPath, tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    let t1 = String::from("    ").repeat(tabs + 1);

    format!(
        "CssPath {{\r\n{}selectors: {}\r\n{}}}",
        t1,
        format_selectors(path.selectors.as_ref(), tabs + 1),
        t
    )
}

fn format_selectors(selectors: &[CssPathSelector], tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    let t1 = String::from("    ").repeat(tabs + 1);

    let selectors_formatted = selectors
        .iter()
        .map(|s| format!("{}{},", t1, format_single_selector(s, tabs + 1)))
        .collect::<Vec<String>>()
        .join("\r\n");

    format!("vec![\r\n{}\r\n{}].into()", selectors_formatted, t)
}

fn format_single_selector(p: &CssPathSelector, _tabs: usize) -> String {
    match p {
        CssPathSelector::Global => format!("CssPathSelector::Global"),
        CssPathSelector::Type(ntp) => format!("CssPathSelector::Type({})", format_node_type(ntp)),
        CssPathSelector::Class(class) => {
            format!("CssPathSelector::Class(String::from({:?}))", class)
        }
        CssPathSelector::Id(id) => format!("CssPathSelector::Id(String::from({:?}))", id),
        CssPathSelector::PseudoSelector(cps) => format!(
            "CssPathSelector::PseudoSelector({})",
            format_pseudo_selector_type(cps)
        ),
        CssPathSelector::DirectChildren => format!("CssPathSelector::DirectChildren"),
        CssPathSelector::Children => format!("CssPathSelector::Children"),
    }
}

fn format_node_type(n: &NodeTypeTag) -> &'static str {
    match n {
        NodeTypeTag::Body => "NodeTypeTag::Body",
        NodeTypeTag::Div => "NodeTypeTag::Div",
        NodeTypeTag::Br => "NodeTypeTag::Br",
        NodeTypeTag::P => "NodeTypeTag::P",
        NodeTypeTag::Img => "NodeTypeTag::Img",
        NodeTypeTag::IFrame => "NodeTypeTag::IFrame",
    }
}

fn format_pseudo_selector_type(p: &CssPathPseudoSelector) -> String {
    match p {
        CssPathPseudoSelector::First => format!("CssPathPseudoSelector::First"),
        CssPathPseudoSelector::Last => format!("CssPathPseudoSelector::Last"),
        CssPathPseudoSelector::NthChild(n) => format!(
            "CssPathPseudoSelector::NthChild({})",
            format_nth_child_selector(n)
        ),
        CssPathPseudoSelector::Hover => format!("CssPathPseudoSelector::Hover"),
        CssPathPseudoSelector::Active => format!("CssPathPseudoSelector::Active"),
        CssPathPseudoSelector::Focus => format!("CssPathPseudoSelector::Focus"),
    }
}

fn format_nth_child_selector(n: &CssNthChildSelector) -> String {
    match n {
        CssNthChildSelector::Number(num) => format!("CssNthChildSelector::Number({})", num),
        CssNthChildSelector::Even => format!("CssNthChildSelector::Even"),
        CssNthChildSelector::Odd => format!("CssNthChildSelector::Odd"),
        CssNthChildSelector::Pattern(CssNthChildPattern { repeat, offset }) => format!(
            "CssNthChildSelector::Pattern(CssNthChildPattern {{ repeat: {}, offset: {} }})",
            repeat, offset
        ),
    }
}

fn print_declaraction(decl: &CssDeclaration, tabs: usize) -> String {
    match decl {
        CssDeclaration::Static(s) => format!(
            "CssDeclaration::Static({})",
            format_static_css_prop(s, tabs)
        ),
        CssDeclaration::Dynamic(d) => format!(
            "CssDeclaration::Dynamic({})",
            format_dynamic_css_prop(d, tabs)
        ),
    }
}

pub(crate) trait GetHash {
    fn get_hash(&self) -> u64;
}

impl<T: Hash> GetHash for T {
    fn get_hash(&self) -> u64 {
        use highway::{HighwayHash, HighwayHasher, Key};
        let mut hasher = HighwayHasher::new(Key([0; 4]));
        self.hash(&mut hasher);
        hasher.finalize64()
    }
}

trait FormatAsRustCode {
    fn format_as_rust_code(&self, _tabs: usize) -> String;
}

pub(crate) fn format_static_css_prop(prop: &CssProperty, tabs: usize) -> String {
    match prop {
        CssProperty::TextColor(p) => format!(
            "CssProperty::TextColor({})",
            print_css_property_value(p, tabs, "StyleTextColor")
        ),
        CssProperty::FontSize(p) => format!(
            "CssProperty::FontSize({})",
            print_css_property_value(p, tabs, "StyleFontSize")
        ),
        CssProperty::FontFamily(p) => format!(
            "CssProperty::FontFamily({})",
            print_css_property_value(p, tabs, "StyleFontFamilyVec")
        ),
        CssProperty::TextAlign(p) => format!(
            "CssProperty::TextAlign({})",
            print_css_property_value(p, tabs, "StyleTextAlign")
        ),
        CssProperty::LetterSpacing(p) => format!(
            "CssProperty::LetterSpacing({})",
            print_css_property_value(p, tabs, "StyleLetterSpacing")
        ),
        CssProperty::LineHeight(p) => format!(
            "CssProperty::LineHeight({})",
            print_css_property_value(p, tabs, "StyleLineHeight")
        ),
        CssProperty::WordSpacing(p) => format!(
            "CssProperty::WordSpacing({})",
            print_css_property_value(p, tabs, "StyleWordSpacing")
        ),
        CssProperty::TabWidth(p) => format!(
            "CssProperty::TabWidth({})",
            print_css_property_value(p, tabs, "StyleTabWidth")
        ),
        CssProperty::Cursor(p) => format!(
            "CssProperty::Cursor({})",
            print_css_property_value(p, tabs, "StyleCursor")
        ),
        CssProperty::Display(p) => format!(
            "CssProperty::Display({})",
            print_css_property_value(p, tabs, "LayoutDisplay")
        ),
        CssProperty::Float(p) => format!(
            "CssProperty::Float({})",
            print_css_property_value(p, tabs, "LayoutFloat")
        ),
        CssProperty::BoxSizing(p) => format!(
            "CssProperty::BoxSizing({})",
            print_css_property_value(p, tabs, "LayoutBoxSizing")
        ),
        CssProperty::Width(p) => format!(
            "CssProperty::Width({})",
            print_css_property_value(p, tabs, "LayoutWidth")
        ),
        CssProperty::Height(p) => format!(
            "CssProperty::Height({})",
            print_css_property_value(p, tabs, "LayoutHeight")
        ),
        CssProperty::MinWidth(p) => format!(
            "CssProperty::MinWidth({})",
            print_css_property_value(p, tabs, "LayoutMinWidth")
        ),
        CssProperty::MinHeight(p) => format!(
            "CssProperty::MinHeight({})",
            print_css_property_value(p, tabs, "LayoutMinHeight")
        ),
        CssProperty::MaxWidth(p) => format!(
            "CssProperty::MaxWidth({})",
            print_css_property_value(p, tabs, "LayoutMaxWidth")
        ),
        CssProperty::MaxHeight(p) => format!(
            "CssProperty::MaxHeight({})",
            print_css_property_value(p, tabs, "LayoutMaxHeight")
        ),
        CssProperty::Position(p) => format!(
            "CssProperty::Position({})",
            print_css_property_value(p, tabs, "LayoutPosition")
        ),
        CssProperty::Top(p) => format!(
            "CssProperty::Top({})",
            print_css_property_value(p, tabs, "LayoutTop")
        ),
        CssProperty::Right(p) => format!(
            "CssProperty::Right({})",
            print_css_property_value(p, tabs, "LayoutRight")
        ),
        CssProperty::Left(p) => format!(
            "CssProperty::Left({})",
            print_css_property_value(p, tabs, "LayoutLeft")
        ),
        CssProperty::Bottom(p) => format!(
            "CssProperty::Bottom({})",
            print_css_property_value(p, tabs, "LayoutBottom")
        ),
        CssProperty::FlexWrap(p) => format!(
            "CssProperty::FlexWrap({})",
            print_css_property_value(p, tabs, "LayoutFlexWrap")
        ),
        CssProperty::FlexDirection(p) => format!(
            "CssProperty::FlexDirection({})",
            print_css_property_value(p, tabs, "LayoutFlexDirection")
        ),
        CssProperty::FlexGrow(p) => format!(
            "CssProperty::FlexGrow({})",
            print_css_property_value(p, tabs, "LayoutFlexGrow")
        ),
        CssProperty::FlexShrink(p) => format!(
            "CssProperty::FlexShrink({})",
            print_css_property_value(p, tabs, "LayoutFlexShrink")
        ),
        CssProperty::JustifyContent(p) => format!(
            "CssProperty::JustifyContent({})",
            print_css_property_value(p, tabs, "LayoutJustifyContent")
        ),
        CssProperty::AlignItems(p) => format!(
            "CssProperty::AlignItems({})",
            print_css_property_value(p, tabs, "LayoutAlignItems")
        ),
        CssProperty::AlignContent(p) => format!(
            "CssProperty::AlignContent({})",
            print_css_property_value(p, tabs, "LayoutAlignContent")
        ),
        CssProperty::BackgroundContent(p) => format!(
            "CssProperty::BackgroundContent({})",
            print_css_property_value(p, tabs, "StyleBackgroundContentVec")
        ),
        CssProperty::BackgroundPosition(p) => format!(
            "CssProperty::BackgroundPosition({})",
            print_css_property_value(p, tabs, "StyleBackgroundPositionVec")
        ),
        CssProperty::BackgroundSize(p) => format!(
            "CssProperty::BackgroundSize({})",
            print_css_property_value(p, tabs, "StyleBackgroundSizeVec")
        ),
        CssProperty::BackgroundRepeat(p) => format!(
            "CssProperty::BackgroundRepeat({})",
            print_css_property_value(p, tabs, "StyleBackgroundRepeatVec")
        ),
        CssProperty::OverflowX(p) => format!(
            "CssProperty::OverflowX({})",
            print_css_property_value(p, tabs, "LayoutOverflow")
        ),
        CssProperty::OverflowY(p) => format!(
            "CssProperty::OverflowY({})",
            print_css_property_value(p, tabs, "LayoutOverflow")
        ),
        CssProperty::PaddingTop(p) => format!(
            "CssProperty::PaddingTop({})",
            print_css_property_value(p, tabs, "LayoutPaddingTop")
        ),
        CssProperty::PaddingLeft(p) => format!(
            "CssProperty::PaddingLeft({})",
            print_css_property_value(p, tabs, "LayoutPaddingLeft")
        ),
        CssProperty::PaddingRight(p) => format!(
            "CssProperty::PaddingRight({})",
            print_css_property_value(p, tabs, "LayoutPaddingRight")
        ),
        CssProperty::PaddingBottom(p) => format!(
            "CssProperty::PaddingBottom({})",
            print_css_property_value(p, tabs, "LayoutPaddingBottom")
        ),
        CssProperty::MarginTop(p) => format!(
            "CssProperty::MarginTop({})",
            print_css_property_value(p, tabs, "LayoutMarginTop")
        ),
        CssProperty::MarginLeft(p) => format!(
            "CssProperty::MarginLeft({})",
            print_css_property_value(p, tabs, "LayoutMarginLeft")
        ),
        CssProperty::MarginRight(p) => format!(
            "CssProperty::MarginRight({})",
            print_css_property_value(p, tabs, "LayoutMarginRight")
        ),
        CssProperty::MarginBottom(p) => format!(
            "CssProperty::MarginBottom({})",
            print_css_property_value(p, tabs, "LayoutMarginBottom")
        ),
        CssProperty::BorderTopLeftRadius(p) => format!(
            "CssProperty::BorderTopLeftRadius({})",
            print_css_property_value(p, tabs, "StyleBorderTopLeftRadius")
        ),
        CssProperty::BorderTopRightRadius(p) => format!(
            "CssProperty::BorderTopRightRadius({})",
            print_css_property_value(p, tabs, "StyleBorderTopRightRadius")
        ),
        CssProperty::BorderBottomLeftRadius(p) => format!(
            "CssProperty::BorderBottomLeftRadius({})",
            print_css_property_value(p, tabs, "StyleBorderBottomLeftRadius")
        ),
        CssProperty::BorderBottomRightRadius(p) => format!(
            "CssProperty::BorderBottomRightRadius({})",
            print_css_property_value(p, tabs, "StyleBorderBottomRightRadius")
        ),
        CssProperty::BorderTopColor(p) => format!(
            "CssProperty::BorderTopColor({})",
            print_css_property_value(p, tabs, "StyleBorderTopColor")
        ),
        CssProperty::BorderRightColor(p) => format!(
            "CssProperty::BorderRightColor({})",
            print_css_property_value(p, tabs, "StyleBorderRightColor")
        ),
        CssProperty::BorderLeftColor(p) => format!(
            "CssProperty::BorderLeftColor({})",
            print_css_property_value(p, tabs, "StyleBorderLeftColor")
        ),
        CssProperty::BorderBottomColor(p) => format!(
            "CssProperty::BorderBottomColor({})",
            print_css_property_value(p, tabs, "StyleBorderBottomColor")
        ),
        CssProperty::BorderTopStyle(p) => format!(
            "CssProperty::BorderTopStyle({})",
            print_css_property_value(p, tabs, "StyleBorderTopStyle")
        ),
        CssProperty::BorderRightStyle(p) => format!(
            "CssProperty::BorderRightStyle({})",
            print_css_property_value(p, tabs, "StyleBorderRightStyle")
        ),
        CssProperty::BorderLeftStyle(p) => format!(
            "CssProperty::BorderLeftStyle({})",
            print_css_property_value(p, tabs, "StyleBorderLeftStyle")
        ),
        CssProperty::BorderBottomStyle(p) => format!(
            "CssProperty::BorderBottomStyle({})",
            print_css_property_value(p, tabs, "StyleBorderBottomStyle")
        ),
        CssProperty::BorderTopWidth(p) => format!(
            "CssProperty::BorderTopWidth({})",
            print_css_property_value(p, tabs, "LayoutBorderTopWidth")
        ),
        CssProperty::BorderRightWidth(p) => format!(
            "CssProperty::BorderRightWidth({})",
            print_css_property_value(p, tabs, "LayoutBorderRightWidth")
        ),
        CssProperty::BorderLeftWidth(p) => format!(
            "CssProperty::BorderLeftWidth({})",
            print_css_property_value(p, tabs, "LayoutBorderLeftWidth")
        ),
        CssProperty::BorderBottomWidth(p) => format!(
            "CssProperty::BorderBottomWidth({})",
            print_css_property_value(p, tabs, "LayoutBorderBottomWidth")
        ),
        CssProperty::BoxShadowLeft(p) => format!(
            "CssProperty::BoxShadowLeft({})",
            print_css_property_value(p, tabs, "StyleBoxShadow")
        ),
        CssProperty::BoxShadowRight(p) => format!(
            "CssProperty::BoxShadowRight({})",
            print_css_property_value(p, tabs, "StyleBoxShadow")
        ),
        CssProperty::BoxShadowTop(p) => format!(
            "CssProperty::BoxShadowTop({})",
            print_css_property_value(p, tabs, "StyleBoxShadow")
        ),
        CssProperty::BoxShadowBottom(p) => format!(
            "CssProperty::BoxShadowBottom({})",
            print_css_property_value(p, tabs, "StyleBoxShadow")
        ),
        CssProperty::ScrollbarStyle(p) => format!(
            "CssProperty::ScrollbarStyle({})",
            print_css_property_value(p, tabs, "ScrollbarStyle")
        ),
        CssProperty::Opacity(p) => format!(
            "CssProperty::Opacity({})",
            print_css_property_value(p, tabs, "StyleOpacity")
        ),
        CssProperty::Transform(p) => format!(
            "CssProperty::Transform({})",
            print_css_property_value(p, tabs, "StyleTransformVec")
        ),
        CssProperty::TransformOrigin(p) => format!(
            "CssProperty::TransformOrigin({})",
            print_css_property_value(p, tabs, "StyleTransformOrigin")
        ),
        CssProperty::PerspectiveOrigin(p) => format!(
            "CssProperty::PerspectiveOrigin({})",
            print_css_property_value(p, tabs, "StylePerspectiveOrigin")
        ),
        CssProperty::BackfaceVisibility(p) => format!(
            "CssProperty::BackfaceVisibility({})",
            print_css_property_value(p, tabs, "StyleBackfaceVisibility")
        ),
        CssProperty::MixBlendMode(p) => format!(
            "CssProperty::MixBlendMode({})",
            print_css_property_value(p, tabs, "StyleMixBlendMode")
        ),
        CssProperty::Filter(p) => format!(
            "CssProperty::Filter({})",
            print_css_property_value(p, tabs, "StyleFilterVec")
        ),
        CssProperty::BackdropFilter(p) => format!(
            "CssProperty::Filter({})",
            print_css_property_value(p, tabs, "StyleFilterVec")
        ),
        CssProperty::TextShadow(p) => format!(
            "CssProperty::TextShadow({})",
            print_css_property_value(p, tabs, "StyleBoxShadow")
        ),
    }
}

fn print_css_property_value<T: FormatAsRustCode>(
    prop_val: &CssPropertyValue<T>,
    tabs: usize,
    property_value_type: &'static str,
) -> String {
    match prop_val {
        CssPropertyValue::Auto => format!("{}Value::Auto", property_value_type),
        CssPropertyValue::None => format!("{}Value::None", property_value_type),
        CssPropertyValue::Initial => format!("{}Value::Initial", property_value_type),
        CssPropertyValue::Inherit => format!("{}Value::Inherit", property_value_type),
        CssPropertyValue::Exact(t) => format!(
            "{}Value::Exact({})",
            property_value_type,
            t.format_as_rust_code(tabs)
        ),
    }
}

fn format_dynamic_css_prop(decl: &DynamicCssProperty, tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    format!(
        "DynamicCssProperty {{\r\n{}    dynamic_id: {:?},\r\n{}    default_value: {},\r\n{}}}",
        t,
        decl.dynamic_id,
        t,
        format_static_css_prop(&decl.default_value, tabs + 1),
        t
    )
}

fn format_pixel_value(p: &PixelValue) -> String {
    match p.metric {
        SizeMetric::Px => format!(
            "PixelValue::const_px({})",
            libm::roundf(p.number.get()) as isize
        ),
        SizeMetric::Pt => format!(
            "PixelValue::const_pt({})",
            libm::roundf(p.number.get()) as isize
        ),
        SizeMetric::Em => format!(
            "PixelValue::const_em({})",
            libm::roundf(p.number.get()) as isize
        ),
        SizeMetric::Percent => format!(
            "PixelValue::const_percent({})",
            libm::roundf(p.number.get()) as isize
        ),
    }
}

fn format_pixel_value_no_percent(p: &PixelValueNoPercent) -> String {
    format!(
        "PixelValueNoPercent {{ inner: {} }}",
        format_pixel_value(&p.inner)
    )
}

fn format_float_value(f: &FloatValue) -> String {
    format!("FloatValue::const_new({})", libm::roundf(f.get()) as isize)
}

fn format_percentage_value(f: &PercentageValue) -> String {
    format!(
        "PercentageValue::const_new({})",
        libm::roundf(f.get()) as isize
    )
}

fn format_angle_value(f: &AngleValue) -> String {
    format!(
        "AngleValue::const_deg({})",
        libm::roundf(f.to_degrees()) as isize
    )
}

fn format_color_value(c: &ColorU) -> String {
    format!(
        "ColorU {{ r: {}, g: {}, b: {}, a: {} }}",
        c.r, c.g, c.b, c.a
    )
}

macro_rules! impl_float_value_fmt {
    ($struct_name:ident) => {
        impl FormatAsRustCode for $struct_name {
            fn format_as_rust_code(&self, _tabs: usize) -> String {
                format!(
                    "{} {{ inner: {} }}",
                    stringify!($struct_name),
                    format_float_value(&self.inner)
                )
            }
        }
    };
}

impl_float_value_fmt!(LayoutFlexGrow);
impl_float_value_fmt!(LayoutFlexShrink);

macro_rules! impl_percentage_value_fmt {
    ($struct_name:ident) => {
        impl FormatAsRustCode for $struct_name {
            fn format_as_rust_code(&self, _tabs: usize) -> String {
                format!(
                    "{} {{ inner: {} }}",
                    stringify!($struct_name),
                    format_percentage_value(&self.inner)
                )
            }
        }
    };
}

impl_percentage_value_fmt!(StyleTabWidth);
impl_percentage_value_fmt!(StyleLineHeight);
impl_percentage_value_fmt!(StyleOpacity);

macro_rules! impl_pixel_value_fmt {
    ($struct_name:ident) => {
        impl FormatAsRustCode for $struct_name {
            fn format_as_rust_code(&self, _tabs: usize) -> String {
                format!(
                    "{} {{ inner: {} }}",
                    stringify!($struct_name),
                    format_pixel_value(&self.inner)
                )
            }
        }
    };
}

impl_pixel_value_fmt!(StyleBorderTopLeftRadius);
impl_pixel_value_fmt!(StyleBorderBottomLeftRadius);
impl_pixel_value_fmt!(StyleBorderTopRightRadius);
impl_pixel_value_fmt!(StyleBorderBottomRightRadius);

impl_pixel_value_fmt!(LayoutBorderTopWidth);
impl_pixel_value_fmt!(LayoutBorderLeftWidth);
impl_pixel_value_fmt!(LayoutBorderRightWidth);
impl_pixel_value_fmt!(LayoutBorderBottomWidth);
impl_pixel_value_fmt!(StyleLetterSpacing);
impl_pixel_value_fmt!(StyleWordSpacing);
impl_pixel_value_fmt!(StyleFontSize);

impl_pixel_value_fmt!(LayoutMarginTop);
impl_pixel_value_fmt!(LayoutMarginBottom);
impl_pixel_value_fmt!(LayoutMarginRight);
impl_pixel_value_fmt!(LayoutMarginLeft);

impl_pixel_value_fmt!(LayoutPaddingTop);
impl_pixel_value_fmt!(LayoutPaddingBottom);
impl_pixel_value_fmt!(LayoutPaddingRight);
impl_pixel_value_fmt!(LayoutPaddingLeft);

impl_pixel_value_fmt!(LayoutWidth);
impl_pixel_value_fmt!(LayoutHeight);
impl_pixel_value_fmt!(LayoutMinHeight);
impl_pixel_value_fmt!(LayoutMinWidth);
impl_pixel_value_fmt!(LayoutMaxWidth);
impl_pixel_value_fmt!(LayoutMaxHeight);
impl_pixel_value_fmt!(LayoutTop);
impl_pixel_value_fmt!(LayoutBottom);
impl_pixel_value_fmt!(LayoutRight);
impl_pixel_value_fmt!(LayoutLeft);

macro_rules! impl_color_value_fmt {
    ($struct_name:ty) => {
        impl FormatAsRustCode for $struct_name {
            fn format_as_rust_code(&self, _tabs: usize) -> String {
                format!(
                    "{} {{ inner: {} }}",
                    stringify!($struct_name),
                    format_color_value(&self.inner)
                )
            }
        }
    };
}

impl_color_value_fmt!(StyleTextColor);
impl_color_value_fmt!(StyleBorderTopColor);
impl_color_value_fmt!(StyleBorderLeftColor);
impl_color_value_fmt!(StyleBorderRightColor);
impl_color_value_fmt!(StyleBorderBottomColor);

macro_rules! impl_enum_fmt {($enum_name:ident, $($enum_type:ident),+) => (
    impl FormatAsRustCode for $enum_name {
        fn format_as_rust_code(&self, _tabs: usize) -> String {
            match self {
                $(
                    $enum_name::$enum_type => String::from(concat!(stringify!($enum_name), "::", stringify!($enum_type))),
                )+
            }
        }
    }
)}

impl_enum_fmt!(
    StyleMixBlendMode,
    Normal,
    Multiply,
    Screen,
    Overlay,
    Darken,
    Lighten,
    ColorDodge,
    ColorBurn,
    HardLight,
    SoftLight,
    Difference,
    Exclusion,
    Hue,
    Saturation,
    Color,
    Luminosity
);

impl_enum_fmt!(
    StyleCursor,
    Alias,
    AllScroll,
    Cell,
    ColResize,
    ContextMenu,
    Copy,
    Crosshair,
    Default,
    EResize,
    EwResize,
    Grab,
    Grabbing,
    Help,
    Move,
    NResize,
    NsResize,
    NeswResize,
    NwseResize,
    Pointer,
    Progress,
    RowResize,
    SResize,
    SeResize,
    Text,
    Unset,
    VerticalText,
    WResize,
    Wait,
    ZoomIn,
    ZoomOut
);

impl_enum_fmt!(
    BorderStyle,
    None,
    Solid,
    Double,
    Dotted,
    Dashed,
    Hidden,
    Groove,
    Ridge,
    Inset,
    Outset
);

impl FormatAsRustCode for StyleFilterVec {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        format!(
            "StyleFilterVec::from_const_slice(STYLE_FILTER_{}_ITEMS)",
            self.get_hash()
        )
    }
}

impl FormatAsRustCode for StyleBackgroundSizeVec {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        format!(
            "StyleBackgroundSizeVec::from_const_slice(STYLE_BACKGROUND_SIZE_{}_ITEMS)",
            self.get_hash()
        )
    }
}

fn format_style_background_size(c: &StyleBackgroundSize) -> String {
    match c {
        StyleBackgroundSize::Contain => String::from("StyleBackgroundSize::Contain"),
        StyleBackgroundSize::Cover => String::from("StyleBackgroundSize::Cover"),
        StyleBackgroundSize::ExactSize([w, h]) => format!(
            "StyleBackgroundSize::ExactSize([{}, {}])",
            format_pixel_value(w),
            format_pixel_value(h)
        ),
    }
}

impl FormatAsRustCode for ScrollbarStyle {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        let t = String::from("    ").repeat(tabs);
        let t1 = String::from("    ").repeat(tabs + 1);
        format!(
            "ScrollbarStyle {{\r\n{}horizontal: {},\r\n{}vertical: {},\r\n{}}}",
            t1,
            format_scrollbar_info(&self.horizontal, tabs + 1),
            t1,
            format_scrollbar_info(&self.vertical, tabs + 1),
            t,
        )
    }
}

fn format_scrollbar_info(s: &ScrollbarInfo, tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    let t1 = String::from("    ").repeat(tabs + 1);
    format!("ScrollbarInfo {{\r\n{}width: {},\r\n{}padding_left: {},\r\n{}padding_right: {},\r\n{}track: {},\r\n{}thumb: {},\r\n{}button: {},\r\n{}button: {},\r\n{}resizer: {},\r\n{}}}",
        t1,
        s.width.format_as_rust_code(tabs + 1), t1,
        s.padding_left.format_as_rust_code(tabs + 1), t1,
        s.padding_right.format_as_rust_code(tabs + 1), t1,
        format_style_background_content(&s.track, tabs + 1), t1,
        format_style_background_content(&s.thumb, tabs + 1), t1,
        format_style_background_content(&s.button, tabs + 1), t1,
        format_style_background_content(&s.corner, tabs + 1), t1,
        format_style_background_content(&s.resizer, tabs + 1),
        t
    )
}

impl_enum_fmt!(StyleBackgroundRepeat, NoRepeat, Repeat, RepeatX, RepeatY);

impl FormatAsRustCode for StyleBackgroundRepeatVec {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        format!(
            "StyleBackgroundRepeatVec::from_const_slice(STYLE_BACKGROUND_REPEAT_{}_ITEMS)",
            self.get_hash()
        )
    }
}

impl_enum_fmt!(LayoutDisplay, None, Flex, Block, InlineBlock);

impl_enum_fmt!(LayoutFloat, Left, Right);

impl_enum_fmt!(LayoutBoxSizing, ContentBox, BorderBox);

impl_enum_fmt!(LayoutFlexDirection, Row, RowReverse, Column, ColumnReverse);

impl_enum_fmt!(LayoutFlexWrap, Wrap, NoWrap);

impl_enum_fmt!(
    LayoutJustifyContent,
    Start,
    End,
    Center,
    SpaceBetween,
    SpaceAround,
    SpaceEvenly
);

impl_enum_fmt!(LayoutAlignItems, FlexStart, FlexEnd, Stretch, Center);

impl_enum_fmt!(
    LayoutAlignContent,
    Start,
    End,
    Stretch,
    Center,
    SpaceBetween,
    SpaceAround
);

impl_enum_fmt!(Shape, Circle, Ellipse);

impl_enum_fmt!(LayoutPosition, Static, Fixed, Absolute, Relative);

impl_enum_fmt!(LayoutOverflow, Auto, Scroll, Visible, Hidden);

impl_enum_fmt!(StyleTextAlign, Center, Left, Right);

impl_enum_fmt!(
    DirectionCorner,
    Right,
    Left,
    Top,
    Bottom,
    TopRight,
    TopLeft,
    BottomRight,
    BottomLeft
);

impl_enum_fmt!(ExtendMode, Clamp, Repeat);

impl_enum_fmt!(StyleBackfaceVisibility, Visible, Hidden);

impl FormatAsRustCode for StyleBackgroundContentVec {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        format!(
            "StyleBackgroundContentVec::from_const_slice(STYLE_BACKGROUND_CONTENT_{}_ITEMS)",
            self.get_hash()
        )
    }
}

fn format_style_background_content(content: &StyleBackgroundContent, tabs: usize) -> String {
    match content {
        StyleBackgroundContent::LinearGradient(l) => format!(
            "StyleBackgroundContent::LinearGradient({})",
            format_linear_gradient(l, tabs)
        ),
        StyleBackgroundContent::RadialGradient(r) => format!(
            "StyleBackgroundContent::RadialGradient({})",
            format_radial_gradient(r, tabs)
        ),
        StyleBackgroundContent::ConicGradient(r) => format!(
            "StyleBackgroundContent::ConicGradient({})",
            format_conic_gradient(r, tabs)
        ),
        StyleBackgroundContent::Image(id) => format!("StyleBackgroundContent::Image({:?})", id),
        StyleBackgroundContent::Color(c) => {
            format!("StyleBackgroundContent::Color({})", format_color_value(c))
        }
    }
}

fn format_direction(d: &Direction, tabs: usize) -> String {
    match d {
        Direction::Angle(fv) => format!("Direction::Angle({})", format_angle_value(fv)),
        Direction::FromTo(DirectionCorners { from, to }) => format!(
            "Direction::FromTo(DirectionCorners {{ from: {}, to: {} }})",
            from.format_as_rust_code(tabs + 1),
            to.format_as_rust_code(tabs + 1)
        ),
    }
}

fn format_linear_gradient(l: &LinearGradient, tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    let t1 = String::from("    ").repeat(tabs + 1);
    format!("LinearGradient {{\r\n{}direction: {},\r\n{}extend_mode: {},\r\n{}stops: NormalizedLinearColorStopVec::from_const_slice(LINEAR_COLOR_STOP_{}_ITEMS),\r\n{}}}",
        t1, format_direction(&l.direction, tabs + 1), t1,
        l.extend_mode.format_as_rust_code(tabs + 1), t1,
        l.stops.get_hash(), t,
    )
}

fn format_conic_gradient(r: &ConicGradient, tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    let t1 = String::from("    ").repeat(tabs + 1);

    format!("ConicGradient {{\r\n{}extend_mode: {},\r\n{}center: {},\r\n{}angle: {},\r\n{}stops: NormalizedRadialColorStopVec::from_const_slice(RADIAL_COLOR_STOP_{}_ITEMS),\r\n{}}}",
        t1,
        r.extend_mode.format_as_rust_code(tabs + 1), t1,
        format_style_background_position(&r.center, tabs + 1), t1,
        format_angle_value(&r.angle), t1,
        r.stops.get_hash(), t,
    )
}

fn format_radial_gradient(r: &RadialGradient, tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    let t1 = String::from("    ").repeat(tabs + 1);
    format!("RadialGradient {{\r\n{}shape: {},\r\n{}extend_mode: {},\r\n{}position: {},\r\n{}size: RadialGradientSize::{:?},\r\n{}stops: NormalizedLinearColorStopVec::from_const_slice(LINEAR_COLOR_STOP_{}_ITEMS),\r\n{}}}",
        t1, r.shape.format_as_rust_code(tabs + 1), t1,
        r.extend_mode.format_as_rust_code(tabs + 1), t1,
        format_style_background_position(&r.position, tabs + 1), t1,
        r.size, t1,
        r.stops.get_hash(), t,
    )
}

fn format_linear_color_stops(stops: &[NormalizedLinearColorStop], tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    stops
        .iter()
        .map(|s| format_linear_color_stop(s))
        .collect::<Vec<_>>()
        .join(&format!(",\r\n{}", t))
}

fn format_linear_color_stop(g: &NormalizedLinearColorStop) -> String {
    format!(
        "NormalizedLinearColorStop {{ offset: {}, color: {} }}",
        format_percentage_value(&g.offset),
        format_color_value(&g.color),
    )
}

fn format_radial_color_stops(stops: &[NormalizedRadialColorStop], tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    stops
        .iter()
        .map(|s| format_radial_color_stop(s))
        .collect::<Vec<_>>()
        .join(&format!(",\r\n{}", t))
}

fn format_radial_color_stop(g: &NormalizedRadialColorStop) -> String {
    format!(
        "RadialColorStop {{ angle: {}, color: {} }}",
        format_angle_value(&g.angle),
        format_color_value(&g.color),
    )
}

impl FormatAsRustCode for StyleTransformVec {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        format!(
            "StyleTransformVec::from_const_slice(STYLE_TRANSFORM_{}_ITEMS)",
            self.get_hash()
        )
    }
}

fn format_style_filter(st: &StyleFilter, tabs: usize) -> String {
    let tabs_minus_one = String::from("    ").repeat(tabs);
    let tabs_str = String::from("    ").repeat(tabs + 1);
    match st {
        StyleFilter::Blend(mb) => format!("StyleFilter::Blend({})", mb.format_as_rust_code(tabs)),
        StyleFilter::Flood(c) => format!("StyleFilter::Flood({})", format_color_value(c)),
        StyleFilter::Blur(m) => format!(
            "StyleFilter::Blur(StyleBlur {{ width: {}, height: {} }})",
            format_pixel_value(&m.width),
            format_pixel_value(&m.height)
        ),
        StyleFilter::Opacity(pct) => {
            format!("StyleFilter::Opacity({})", format_percentage_value(pct))
        }
        StyleFilter::ColorMatrix(cm) => format!(
            "StyleFilter::ColorMatrix(StyleColorMatrix {{ matrix: {} }})",
            cm.matrix
                .iter()
                .map(|f| format_float_value(f))
                .collect::<Vec<_>>()
                .join(&format!(",\r\n{}", tabs_str))
        ),
        StyleFilter::DropShadow(m) => {
            format!("StyleFilter::DropShadow({})", m.format_as_rust_code(tabs))
        }
        StyleFilter::ComponentTransfer => format!("StyleFilter::ComponentTransfer"),
        StyleFilter::Offset(o) => format!(
            "StyleFilter::Offset(StyleFilterOffset {{ x: {}, y: {} }})",
            format_pixel_value(&o.x),
            format_pixel_value(&o.y)
        ),
        StyleFilter::Composite(StyleCompositeFilter::Over) => {
            format!("StyleFilter::Composite(StyleCompositeFilter::Over)")
        }
        StyleFilter::Composite(StyleCompositeFilter::In) => {
            format!("StyleFilter::Composite(StyleCompositeFilter::In)")
        }
        StyleFilter::Composite(StyleCompositeFilter::Atop) => {
            format!("StyleFilter::Composite(StyleCompositeFilter::Atop)")
        }
        StyleFilter::Composite(StyleCompositeFilter::Out) => {
            format!("StyleFilter::Composite(StyleCompositeFilter::Out)")
        }
        StyleFilter::Composite(StyleCompositeFilter::Xor) => {
            format!("StyleFilter::Composite(StyleCompositeFilter::Xor)")
        }
        StyleFilter::Composite(StyleCompositeFilter::Lighter) => {
            format!("StyleFilter::Composite(StyleCompositeFilter::Lighter)")
        }
        StyleFilter::Composite(StyleCompositeFilter::Arithmetic(fv)) => format!(
            "StyleFilter::Composite(StyleCompositeFilter::Arithmetic({}))",
            fv.iter()
                .map(|f| format_float_value(f))
                .collect::<Vec<_>>()
                .join(&format!(",\r\n{}", tabs))
        ),
    }
}

fn format_style_transforms(stops: &[StyleTransform], tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    stops
        .iter()
        .map(|s| format_style_transform(s, tabs))
        .collect::<Vec<_>>()
        .join(&format!(",\r\n{}", t))
}

fn format_style_transform(st: &StyleTransform, tabs: usize) -> String {
    let tabs_minus_one = String::from("    ").repeat(tabs);
    let tabs = String::from("    ").repeat(tabs + 1);
    match st {
        StyleTransform::Matrix(m) => format!("StyleTransform::Matrix(StyleTransformMatrix2D {{ a: {}, b: {}, c: {}, d: {}, tx: {}, ty: {} }})", format_pixel_value(&m.a), format_pixel_value(&m.b), format_pixel_value(&m.c), format_pixel_value(&m.d), format_pixel_value(&m.tx), format_pixel_value(&m.ty)),
        StyleTransform::Matrix3D(m) => format!("StyleTransform::Matrix3D(StyleTransformMatrix3D {{\r\n{tabs}m11: {},\r\n{tabs}m12: {},\r\n{tabs}m13: {},\r\n{tabs}m14: {},\r\n{tabs}m21: {},\r\n{tabs}m22: {},\r\n{tabs}m23: {},\r\n{tabs}m24: {},\r\n{tabs}m31: {},\r\n{tabs}m32: {},\r\n{tabs}m33: {},\r\n{tabs}m34: {},\r\n{tabs}m41: {},\r\n{tabs}m42: {},\r\n{tabs}m43: {},\r\n{tabs}m44: {}\r\n{tabs_minus_one}}})",
           format_pixel_value(&m.m11),
           format_pixel_value(&m.m12),
           format_pixel_value(&m.m13),
           format_pixel_value(&m.m14),
           format_pixel_value(&m.m21),
           format_pixel_value(&m.m22),
           format_pixel_value(&m.m23),
           format_pixel_value(&m.m24),
           format_pixel_value(&m.m31),
           format_pixel_value(&m.m32),
           format_pixel_value(&m.m33),
           format_pixel_value(&m.m34),
           format_pixel_value(&m.m41),
           format_pixel_value(&m.m42),
           format_pixel_value(&m.m43),
           format_pixel_value(&m.m44),
           tabs = tabs,
           tabs_minus_one = tabs_minus_one,
       ),
        StyleTransform::Translate(t) => format!("StyleTransform::Translate(StyleTransformTranslate2D {{ x: {}, y: {} }})", format_pixel_value(&t.x), format_pixel_value(&t.y)),
        StyleTransform::Translate3D(t) => format!("StyleTransform::Translate3D(StyleTransformTranslate3D {{ x: {}, y: {}, z: {})", format_pixel_value(&t.x), format_pixel_value(&t.y), format_pixel_value(&t.z)),
        StyleTransform::TranslateX(x) => format!("StyleTransform::TranslateX({})", format_pixel_value(&x)),
        StyleTransform::TranslateY(y) => format!("StyleTransform::TranslateY({})", format_pixel_value(&y)),
        StyleTransform::TranslateZ(z) => format!("StyleTransform::TranslateZ({})", format_pixel_value(&z)),
        StyleTransform::Rotate(r) => format!("StyleTransform::Rotate({})", format_angle_value(&r)),
        StyleTransform::Rotate3D(r) => format!("StyleTransform::Rotate3D(StyleTransformRotate3D {{ {}, {}, {}, {} }})", format_percentage_value(&r.x), format_percentage_value(&r.y), format_percentage_value(&r.z), format_angle_value(&r.angle)),
        StyleTransform::RotateX(x) => format!("StyleTransform::RotateX({})", format_angle_value(&x)),
        StyleTransform::RotateY(y) => format!("StyleTransform::RotateY({})", format_angle_value(&y)),
        StyleTransform::RotateZ(z) => format!("StyleTransform::RotateZ({})", format_angle_value(&z)),
        StyleTransform::Scale(s) => format!("StyleTransform::Scale(StyleTransformScale2D {{ x: {}, y: {} }})", format_percentage_value(&s.x), format_percentage_value(&s.y)),
        StyleTransform::Scale3D(s) => format!("StyleTransform::Scale3D(StyleTransformScale3D {{ x; {}, y: {}, z: {} }})", format_percentage_value(&s.x), format_percentage_value(&s.y), format_percentage_value(&s.z)),
        StyleTransform::ScaleX(x) => format!("StyleTransform::ScaleX({})", format_percentage_value(&x)),
        StyleTransform::ScaleY(y) => format!("StyleTransform::ScaleY({})", format_percentage_value(&y)),
        StyleTransform::ScaleZ(z) => format!("StyleTransform::ScaleZ({})", format_percentage_value(&z)),
        StyleTransform::Skew(sk) => format!("StyleTransform::Skew(StyleTransformSkew2D {{ x: {}, y: {} }})", format_percentage_value(&sk.x), format_percentage_value(&sk.y)),
        StyleTransform::SkewX(x) => format!("StyleTransform::SkewX({})", format_percentage_value(&x)),
        StyleTransform::SkewY(y) => format!("StyleTransform::SkewY({})", format_percentage_value(&y)),
        StyleTransform::Perspective(dist) => format!("StyleTransform::Perspective({})", format_pixel_value(&dist)),
    }
}

fn format_font_ids(font_ids: &[StyleFontFamily], tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    font_ids
        .iter()
        .map(|s| format!("{}", s.format_as_rust_code(tabs + 1)))
        .collect::<Vec<_>>()
        .join(&format!(",\r\n{}", t))
}

impl FormatAsRustCode for StyleFontFamilyVec {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        format!(
            "StyleFontFamilyVec::from_const_slice(STYLE_FONT_FAMILY_{}_ITEMS)",
            self.get_hash()
        )
    }
}

impl FormatAsRustCode for StyleFontFamily {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        use azul_css::StyleFontFamily::*;
        let t = String::from("    ").repeat(tabs);
        match self {
            System(id) => format!("StyleFontFamily::System(STRING_{})", id.get_hash()),
            File(path) => format!("StyleFontFamily::File(STRING_{})", path.get_hash()),
            Ref(font_ref) => format!("StyleFontFamily::Ref({:0x})", font_ref.data as usize),
        }
    }
}

impl FormatAsRustCode for StyleBackgroundPositionVec {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        format!(
            "StyleBackgroundPositionVec::from_const_slice(STYLE_BACKGROUND_POSITION_{}_ITEMS)",
            self.get_hash()
        )
    }
}

fn format_style_background_position(b: &StyleBackgroundPosition, tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    let t1 = String::from("    ").repeat(tabs + 1);
    format!(
        "StyleBackgroundPosition {{\r\n{}horizontal: {},\r\n{}vertical: {},\r\n{}}}",
        t1,
        format_background_position_horizontal(&b.horizontal),
        t1,
        format_background_position_vertical(&b.vertical),
        t
    )
}

fn format_background_position_horizontal(b: &BackgroundPositionHorizontal) -> String {
    match b {
        BackgroundPositionHorizontal::Left => format!("BackgroundPositionHorizontal::Left"),
        BackgroundPositionHorizontal::Center => format!("BackgroundPositionHorizontal::Center"),
        BackgroundPositionHorizontal::Right => format!("BackgroundPositionHorizontal::Right"),
        BackgroundPositionHorizontal::Exact(p) => format!(
            "BackgroundPositionHorizontal::Exact({})",
            format_pixel_value(p)
        ),
    }
}

fn format_background_position_vertical(b: &BackgroundPositionVertical) -> String {
    match b {
        BackgroundPositionVertical::Top => format!("BackgroundPositionVertical::Top"),
        BackgroundPositionVertical::Center => format!("BackgroundPositionVertical::Center"),
        BackgroundPositionVertical::Bottom => format!("BackgroundPositionVertical::Bottom"),
        BackgroundPositionVertical::Exact(p) => format!(
            "BackgroundPositionVertical::Exact({})",
            format_pixel_value(p)
        ),
    }
}

impl FormatAsRustCode for StyleBorderTopStyle {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        format!(
            "StyleBorderTopStyle {{ inner: {} }}",
            &self.inner.format_as_rust_code(tabs)
        )
    }
}

impl FormatAsRustCode for StyleBorderRightStyle {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        format!(
            "StyleBorderRightStyle {{ inner: {} }}",
            &self.inner.format_as_rust_code(tabs)
        )
    }
}

impl FormatAsRustCode for StyleBorderLeftStyle {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        format!(
            "StyleBorderLeftStyle {{ inner: {} }}",
            &self.inner.format_as_rust_code(tabs)
        )
    }
}

impl FormatAsRustCode for StyleBorderBottomStyle {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        format!(
            "StyleBorderBottomStyle {{ inner: {} }}",
            &self.inner.format_as_rust_code(tabs)
        )
    }
}

impl FormatAsRustCode for StyleBoxShadow {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        let t = String::from("    ").repeat(tabs);
        format!("StyleBoxShadow {{\r\n{}    offset: [{}, {}],\r\n{}    color: {},\r\n{}    blur_radius: {},\r\n{}    spread_radius: {},\r\n{}    clip_mode: BoxShadowClipMode::{:?},\r\n{}}}",
            t, format_pixel_value_no_percent(&self.offset[0]), format_pixel_value_no_percent(&self.offset[1]),
            t, format_color_value(&self.color),
            t, format_pixel_value_no_percent(&self.blur_radius),
            t, format_pixel_value_no_percent(&self.spread_radius),
            t, self.clip_mode,
            t
        )
    }
}

impl FormatAsRustCode for StyleTransformOrigin {
    fn format_as_rust_code(&self, _tabs: usize) -> String {
        format!(
            "StyleTransformOrigin {{ x: {}, y: {} }}",
            format_pixel_value(&self.x),
            format_pixel_value(&self.y)
        )
    }
}

impl FormatAsRustCode for StylePerspectiveOrigin {
    fn format_as_rust_code(&self, _tabs: usize) -> String {
        format!(
            "StylePerspectiveOrigin {{ x: {}, y: {} }}",
            format_pixel_value(&self.x),
            format_pixel_value(&self.y)
        )
    }
}
