use azul_css::CssProperty;
use std::{collections::BTreeMap, fmt};
use {
    app_state::AppState,
    default_callbacks::DefaultCallbackId,
    dom::TagId,
    dom::{Callback, Dom, On, TabIndex},
    id_tree::NodeId,
    style::HoverGroup,
    traits::Layout,
    window::{WindowId, WindowInfo},
    FastHashMap,
};

pub struct UiState<T: Layout> {
    /// The actual DOM, rendered from the .layout() function
    pub dom: Dom<T>,
    /// Tag IDs that were generated by
    pub tag_ids_to_callbacks: BTreeMap<TagId, BTreeMap<On, Callback<T>>>,
    pub tag_ids_to_default_callbacks: BTreeMap<TagId, BTreeMap<On, DefaultCallbackId>>,
    pub tab_index_tags: BTreeMap<TagId, (NodeId, TabIndex)>,
    pub draggable_tags: BTreeMap<TagId, NodeId>,
    pub tag_ids_to_node_ids: BTreeMap<TagId, NodeId>,
    /// One node can only have one tag, but one tag can be inserted in more than one map.
    pub node_ids_to_tag_ids: BTreeMap<NodeId, TagId>,
    /// The style properties that should be overridden for this frame, cloned from the `Css`
    pub dynamic_css_overrides: BTreeMap<NodeId, FastHashMap<String, CssProperty>>,
    /// Stores all tags for nodes that need to activate on a `:hover` or `:active` event.
    pub tag_ids_to_hover_active_states: BTreeMap<TagId, (NodeId, HoverGroup)>,
}

impl<T: Layout> fmt::Debug for UiState<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "UiState {{ \
             \tdom: {:?}, \
             \ttag_ids_to_callbacks: {:?}, \
             \ttag_ids_to_default_callbacks: {:?}, \
             \ttab_index_tags: {:?}, \
             \tdraggable_tags: {:?}, \
             \tnode_ids_to_tag_ids: {:?} \
             \ttag_ids_to_node_ids: {:?} \
             \ttag_ids_to_hover_active_states: {:?} \
             }}",
            self.dom,
            self.tag_ids_to_callbacks,
            self.tag_ids_to_default_callbacks,
            self.tab_index_tags,
            self.draggable_tags,
            self.node_ids_to_tag_ids,
            self.tag_ids_to_node_ids,
            self.tag_ids_to_hover_active_states
        )
    }
}

impl<T: Layout> UiState<T> {
    #[allow(unused_imports, unused_variables)]
    pub(crate) fn from_app_state(app_state: &mut AppState<T>, window_id: WindowId) -> Self {
        use dom::{Dom, NodeType, On};
        use std::sync::atomic::Ordering;

        let window_info = WindowInfo {
            window: &mut app_state.windows[window_id.id],
            resources: &app_state.resources,
        };

        // Only shortly lock the data to get the dom out
        let dom: Dom<T> = {
            let dom_lock = app_state.data.lock().unwrap();
            #[cfg(test)]
            {
                Dom::<T>::new(NodeType::Div)
            }

            #[cfg(not(test))]
            {
                dom_lock.layout(window_info)
            }
        };

        dom.into_ui_state()
    }

    pub fn create_tags_for_hover_nodes(&mut self, hover_nodes: &BTreeMap<NodeId, HoverGroup>) {
        use dom::new_tag_id;
        for (hover_node_id, hover_group) in hover_nodes {
            let hover_tag = match self.node_ids_to_tag_ids.get(hover_node_id) {
                Some(tag_id) => *tag_id,
                None => new_tag_id(),
            };

            self.node_ids_to_tag_ids.insert(*hover_node_id, hover_tag);
            self.tag_ids_to_node_ids.insert(hover_tag, *hover_node_id);
            self.tag_ids_to_hover_active_states
                .insert(hover_tag, (*hover_node_id, *hover_group));
        }
    }
}

// Empty test, for some reason codecov doesn't detect any files (and therefore
// doesn't report codecov % correctly) except if they have at least one test in
// the file. This is an empty test, which should be updated later on
#[test]
fn __codecov_test_ui_state_file() {}
