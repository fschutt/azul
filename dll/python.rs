#![allow(non_snake_case)]


#[macro_use]
extern crate alloc;
extern crate azul_core;

#[cfg(not(target_arch = "wasm32"))]
pub mod desktop;
pub mod extra;
pub mod str;

pub mod azul_impl {
    #[cfg(not(target_arch = "wasm32"))]
    pub use super::desktop::*;
}

use core::ffi::c_void;
use core::mem;
use pyo3::prelude::*;
use pyo3::PyObjectProtocol;
use pyo3::types::*;
use pyo3::exceptions::PyException;

// GL type definitions
type GLuint = u32; type AzGLuint = GLuint;
type GLint = i32; type AzGLint = GLint;
type GLint64 = i64; type AzGLint64 = GLint64;
type GLuint64 = u64; type AzGLuint64 = GLuint64;
type GLenum = u32; type AzGLenum = GLenum;
type GLintptr = isize; type AzGLintptr = GLintptr;
type GLboolean = u8; type AzGLboolean = GLboolean;
type GLsizeiptr = isize; type AzGLsizeiptr = GLsizeiptr;
type GLvoid = c_void; type AzGLvoid = GLvoid;
type GLbitfield = u32; type AzGLbitfield = GLbitfield;
type GLsizei = i32; type AzGLsizei = GLsizei;
type GLclampf = f32; type AzGLclampf = GLclampf;
type GLfloat = f32; type AzGLfloat = GLfloat;
type AzF32 = f32;
type AzU16 = u16;
type AzU32 = u32;
type AzScanCode = u32;


use pyo3::{PyVisit, PyTraverseError, PyGCProtocol};

fn pystring_to_azstring(input: &String) -> AzString {
    input.clone().into()
}
fn az_string_to_py_string(input: AzString) -> String {
    input.into()
}
fn pystring_to_refstr(input: &str) -> AzRefstr {
    AzRefstr {
        ptr: input.as_ptr(),
        len: input.len(),
    }
}
fn az_vecu8_to_py_vecu8(input: AzU8Vec) -> Vec<u8> {
    let input: azul_impl::css::U8Vec = unsafe { mem::transmute(input) };
    input.into_library_owned_vec()
}
fn vec_string_to_vec_refstr(input: &Vec<&str>) -> Vec<AzRefstr> {
    input.iter().map(|i| pystring_to_refstr(i)).collect()
}
fn pybytesrefmut_to_vecu8refmut(input: &mut Vec<u8>) -> AzU8VecRefMut {
    AzU8VecRefMut { ptr: input.as_mut_ptr(), len: input.len() }
}
fn pybytesref_to_vecu8_ref(input: &Vec<u8>) -> AzU8VecRef {
    AzU8VecRef { ptr: input.as_ptr(), len: input.len() }
}
fn pylist_f32_to_rust(input: &Vec<f32>) -> AzF32VecRef {
    AzF32VecRef { ptr: input.as_ptr(), len: input.len() }
}
fn pylist_u32_to_rust(input: &Vec<u32>) -> AzGLuintVecRef {
    AzGLuintVecRef { ptr: input.as_ptr(), len: input.len() }
}
fn pylist_i32_to_rust(input: &mut Vec<i32>) -> AzGLintVecRefMut {
    AzGLintVecRefMut { ptr: input.as_mut_ptr(), len: input.len() }
}
fn pylist_i64_to_rust(input: &mut Vec<i64>) -> AzGLint64VecRefMut {
    AzGLint64VecRefMut { ptr: input.as_mut_ptr(), len: input.len() }
}
fn pylist_bool_to_rust(input: &mut Vec<u8>) -> AzGLbooleanVecRefMut {
    AzGLbooleanVecRefMut { ptr: input.as_mut_ptr(), len: input.len() }
}
fn pylist_glfoat_to_rust(input: &mut Vec<f32>) -> AzGLfloatVecRefMut {
    AzGLfloatVecRefMut { ptr: input.as_mut_ptr(), len: input.len() }
}
fn pylist_str_to_rust(input: &Vec<AzRefstr>) -> AzRefstrVecRef {
    AzRefstrVecRef { ptr: input.as_ptr(), len: input.len() }
}
fn pylist_tessellated_svg_node(input: &Vec<AzTessellatedSvgNode>) -> AzTessellatedSvgNodeVecRef {
    AzTessellatedSvgNodeVecRef { ptr: input.as_ptr(), len: input.len() }
}

impl From<String> for AzString {
    fn from(s: String) -> AzString {
        Self { vec: s.into_bytes().into() }
    }
}

impl From<AzString> for String {
    fn from(s: AzString) -> String {
        let s: azul_impl::css::AzString = unsafe { mem::transmute(s) };
        s.into_library_owned_string()
    }
}

// AzU8Vec
impl From<AzU8Vec> for Vec<u8> {
    fn from(input: AzU8Vec) -> Vec<u8> {
        let input: azul_impl::css::U8Vec = unsafe { mem::transmute(input) };
        input.into_library_owned_vec()
    }
}

impl From<Vec<u8>> for AzU8Vec {
    fn from(input: Vec<u8>) -> AzU8Vec {

        let ptr = input.as_ptr();
        let len = input.len();
        let cap = input.capacity();

        let _ = ::core::mem::ManuallyDrop::new(input);

        Self {
            ptr,
            len,
            cap,
            destructor: AzU8VecDestructorEnumWrapper::DefaultRust(),
        }

    }
}

// manually implement App::new, WindowState::new,
// WindowCreateOptions::new and LayoutCallback::new

#[pyproto]
impl PyGCProtocol for AzApp {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::app::AzAppPtr = unsafe { mem::transmute(self) };

        // NOTE: should not block - this should only succeed
        // AFTER the App has finished executing
        let mut app_lock = match data.ptr.try_lock().ok() {
            Some(s) => s,
            None => return Ok(()),
        };

        let data_ref = match app_lock.data.downcast_ref::<AppDataTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data_ref._py_app_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::app::AzAppPtr = unsafe { mem::transmute(self) };

        // NOTE: should not block - this should only succeed
        // AFTER the App has finished executing
        let mut app_lock = match data.ptr.try_lock().ok() {
            Some(s) => s,
            None => return,
        };

        let mut data = match app_lock.data.downcast_mut::<AppDataTy>() {
            Some(s) => s,
            None => return,
        };

        // Clear reference, this decrements Python ref counter.
        data._py_app_data = None;
    }
}

#[repr(C)]
pub struct AppDataTy {
    _py_app_data: Option<PyObject>,
}

#[repr(C)]
pub struct LayoutCallbackTy {
    // acual callable object from python
    _py_layout_callback: Option<PyObject>,
}

extern "C" fn invoke_py_marshaled_layout_callback(
    marshal_data: &mut AzRefAny,
    app_data: &mut AzRefAny,
    info: AzLayoutCallbackInfo
) -> AzStyledDom {

    let mut marshal_data: &mut azul_impl::callbacks::RefAny = unsafe { mem::transmute(marshal_data) };
    let mut app_data: &mut azul_impl::callbacks::RefAny = unsafe { mem::transmute(app_data) };

    let mut app_data_downcast = match app_data.downcast_mut::<AppDataTy>() {
        Some(s) => s,
        None => return AzStyledDom::default(),
    };

    let mut app_data_downcast = match app_data_downcast._py_app_data.as_mut() {
        Some(s) => s,
        None => return AzStyledDom::default(),
    };

    let mut pyfunction = match marshal_data.downcast_mut::<LayoutCallbackTy>() {
        Some(s) => s,
        None => return AzStyledDom::default(),
    };

    let mut pyfunction = match pyfunction._py_layout_callback.as_mut() {
        Some(s) => s,
        None => return AzStyledDom::default(),
    };

    // call layout callback into python
    let s: AzStyledDom = Python::with_gil(|py| {

        match pyfunction.call1(py.clone(), (app_data_downcast.clone_ref(py.clone()), info)) {
            Ok(o) => match o.as_ref(py).extract::<AzStyledDom>() {
                Ok(o) => o.clone(),
                Err(e) => {
                    #[cfg(feature = "logging")] {
                        let cb_any = o.as_ref(py);
                        let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
                        log::error!("ERROR: LayoutCallback returned object of type {}, expected azul.dom.StyledDom", type_name);
                    }
                    AzStyledDom::default()
                }
            },
            Err(e) => {
                #[cfg(feature = "logging")] {
                    log::error!("Exception caught when invoking LayoutCallback: {}", e);
                }
                AzStyledDom::default()
            }
        }
    });

    s
}

#[pyproto]
impl PyGCProtocol for AzMarshaledLayoutCallback {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let mut refany = data.marshal_data.clone();

        let data = match refany.downcast_ref::<LayoutCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_layout_callback.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) };

        let mut data = match data.marshal_data.downcast_mut::<LayoutCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_layout_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_layout_callback = None;
        }
    }
}

#[repr(C)]
pub struct IFrameCallbackTy {
    _py_iframe_data: Option<PyObject>,
    _py_iframe_callback: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzIFrameNode {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::dom::IFrameNode = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let mut refany = data.data.clone();

        let data = match refany.downcast_ref::<IFrameCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_iframe_data.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_iframe_callback.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::dom::IFrameNode = unsafe { mem::transmute(self) };

        let mut data = match data.data.downcast_mut::<IFrameCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_iframe_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_iframe_data = None;
        }

        if data._py_iframe_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_iframe_callback = None;
        }
    }
}

extern "C" fn invoke_python_iframe(data: &mut azul_impl::callbacks::RefAny, info: azul_impl::callbacks::IFrameCallbackInfo) -> azul_impl::callbacks::IFrameCallbackReturn {

    let default = azul_impl::callbacks::IFrameCallbackReturn {
         dom: azul_impl::styled_dom::StyledDom::default(),
         scroll_size: azul_core::window::LogicalSize::new(0.0, 0.0),
         scroll_offset: azul_core::window::LogicalPosition::new(0.0, 0.0),
         virtual_scroll_size: azul_core::window::LogicalSize::new(0.0, 0.0),
         virtual_scroll_offset: azul_core::window::LogicalPosition::new(0.0, 0.0),
    };

    let data: &mut azul_impl::callbacks::RefAny = unsafe { mem::transmute(data) };

    let mut iframe_cb = match data.downcast_mut::<IFrameCallbackTy>() {
        Some(s) => s,
        None => return default,
    };

    let mut iframe_cb = &mut *iframe_cb;

    let mut py_data = match iframe_cb._py_iframe_data.as_mut() {
        Some(s) => s,
        None => return default,
    };

    let mut py_function = match iframe_cb._py_iframe_callback.as_mut() {
        Some(s) => s,
        None => return default,
    };

    // call iframe callback into python
    let s: azul_impl::callbacks::IFrameCallbackReturn = Python::with_gil(|py| {
        let info: AzIFrameCallbackInfo = unsafe { mem::transmute(info) };
        match py_function.call1(py.clone(), (py_data.clone_ref(py.clone()), info)) {
            Ok(o) => match o.as_ref(py).extract::<AzIFrameCallbackReturn>() {
                Ok(o) => unsafe { mem::transmute(o.clone()) },
                Err(e) => {
                    #[cfg(feature = "logging")] {
                        let cb_any = o.as_ref(py);
                        let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
                        log::error!("ERROR: LayoutCallback returned object of type {}, expected azul.callbacks.AzIFrameCallbackReturn", type_name);
                    }
                    default
                }
            },
            Err(e) => {
                #[cfg(feature = "logging")] {
                    log::error!("Exception caught when invoking IFrameCallback: {}", e);
                }
                default
            }
        }
    });

    s
}

#[repr(C)]
pub struct CallbackTy {
    _py_callback: Option<PyObject>,
    _py_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzCallbackData {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::dom::CallbackData = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let mut refany = data.data.clone();

        let data = match refany.downcast_ref::<CallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_callback.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::dom::CallbackData = unsafe { mem::transmute(self) };

        let mut data = match data.data.downcast_mut::<CallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_callback = None;
        }

        if data._py_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_data = None;
        }
    }
}

extern "C" fn invoke_python_callback(data: &mut azul_impl::callbacks::RefAny, info: azul_impl::callbacks::CallbackInfo) -> azul_impl::callbacks::Update {

    let default: azul_impl::callbacks::Update = azul_impl::callbacks::Update::DoNothing;

    let data: &mut azul_impl::callbacks::RefAny = unsafe { mem::transmute(data) };

    let mut cb = match data.downcast_mut::<CallbackTy>() {
        Some(s) => s,
        None => return default,
    };

    let mut cb = &mut *cb;

    let mut py_data = match cb._py_data.as_mut() {
        Some(s) => s,
        None => return default,
    };

    let mut py_function = match cb._py_callback.as_mut() {
        Some(s) => s,
        None => return default,
    };

    // call callback into python
    let s: azul_impl::callbacks::Update = Python::with_gil(|py| {
        let info: AzCallbackInfo = unsafe { mem::transmute(info) };

        match py_function.call1(py.clone(), (py_data.clone_ref(py.clone()), info)) {
            Ok(o) => match o.as_ref(py).extract::<AzUpdateEnumWrapper>() {
                Ok(o) => unsafe { mem::transmute(o.clone()) },
                Err(e) => {
                    #[cfg(feature = "logging")] {
                        let cb_any = o.as_ref(py);
                        let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
                        log::error!("ERROR: Callback returned object of type {}, expected azul.callbacks.Update", type_name);
                    }
                    default
                }
            },
            Err(e) => {
                #[cfg(feature = "logging")] {
                    log::error!("Exception caught when invoking Callback: {}", e);
                }
                default
            }
        }
    });

    s
}

#[repr(C)]
pub struct TimerCallbackTy {
    _py_timer_callback: Option<PyObject>,
    _py_timer_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzTimer {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::task::Timer = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let mut refany = data.data.clone();

        let data = match refany.downcast_ref::<TimerCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_timer_callback.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_timer_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::task::Timer = unsafe { mem::transmute(self) };

        let mut data = match data.data.downcast_mut::<TimerCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_timer_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_timer_callback = None;
        }

        if data._py_timer_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_timer_data = None;
        }
    }
}

#[repr(C)]
pub struct ImageCallbackTy {
    _py_image_callback: Option<PyObject>,
    _py_image_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzImageRef {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::resources::ImageRef = unsafe { mem::transmute(self) };

        let image_callback = match data.get_image_callback() {
            Some(s) => s,
            None => return Ok(()),
        };

        // temporary clone since we can't borrow mutable here
        let mut refany = image_callback.data.clone();

        let data = match refany.downcast_ref::<ImageCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_image_callback.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_image_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::resources::ImageRef = unsafe { mem::transmute(self) };

        let image_callback = match data.get_image_callback_mut() {
            Some(s) => s,
            None => return,
        };

        let mut data = match image_callback.data.downcast_mut::<ImageCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_image_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_image_callback = None;
        }

        if data._py_image_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_image_data = None;
        }
    }
}

#[repr(C)]
pub struct ThreadWriteBackCallbackTy {
    _py_thread_callback: Option<PyObject>,
    _py_thread_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzThread {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::task::Thread = unsafe { mem::transmute(self) };

        let mut thread_inner = match data.ptr.try_lock().ok() {
            Some(o) => o,
            None => return Ok(()),
        };

        let mut data = match thread_inner.writeback_data.downcast_mut::<ThreadWriteBackCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_thread_callback.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_thread_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::task::Thread = unsafe { mem::transmute(self) };

        let mut thread_inner = match data.ptr.try_lock().ok() {
            Some(o) => o,
            None => return,
        };

        let mut data = match thread_inner.writeback_data.downcast_mut::<ThreadWriteBackCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_thread_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_thread_callback = None;
        }

        if data._py_thread_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_thread_data = None;
        }
    }
}

#[repr(C)]
pub struct DatasetTy {
    _py_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzNodeData {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::dom::NodeData = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let dataset = match data.get_dataset().as_ref() {
            Some(s) => s,
            None => return Ok(()),
        };

        let mut refany = dataset.clone();

        let data = match refany.downcast_ref::<DatasetTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::dom::NodeData = unsafe { mem::transmute(self) };

        let dataset = match data.get_dataset_mut().as_mut() {
            Some(s) => s,
            None => return,
        };

        let mut data = match dataset.downcast_mut::<DatasetTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_data = None;
        }
    }
}
/// Configuration for optional features, such as whether to enable logging or panic hooks
#[pyclass(name = "AppConfig")]
pub struct AzAppConfig {
    #[pyo3(get, set)]
    pub log_level: AppLogLevel, 
    #[pyo3(get, set)]
    pub enable_visual_panic_hook: bool, 
    #[pyo3(get, set)]
    pub enable_logging_on_panic: bool, 
    #[pyo3(get, set)]
    pub enable_tab_navigation: bool, 
    #[pyo3(get, set)]
    pub termination_behavior: AppTerminationBehavior, 
}

/// Main application class
#[pyclass(name = "AzAppPtr")]
pub struct AzAzAppPtr {
    pub ptr: *const c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// Config necessary for threading + animations to work in no_std environments
#[pyclass(name = "ExternalSystemCallbacks")]
pub struct AzExternalSystemCallbacks {
    #[pyo3(get, set)]
    pub create_thread_fn: CreateThreadCallback, 
    #[pyo3(get, set)]
    pub get_system_time_fn: GetSystemTimeCallback, 
}

/// Options on how to initially create the window
#[pyclass(name = "WindowCreateOptions")]
pub struct AzWindowCreateOptions {
    #[pyo3(get, set)]
    pub state: WindowState, 
    #[pyo3(get, set)]
    pub size_to_content: bool, 
    #[pyo3(get, set)]
    pub renderer: OptionRendererOptions, 
    #[pyo3(get, set)]
    pub theme: OptionWindowTheme, 
    #[pyo3(get, set)]
    pub create_callback: OptionCallback, 
    #[pyo3(get, set)]
    pub hot_reload: bool, 
}

/// Force a specific renderer: note that azul will **crash** on startup if the `RendererOptions` are not satisfied.
#[pyclass(name = "RendererOptions")]
pub struct AzRendererOptions {
    #[pyo3(get, set)]
    pub vsync: Vsync, 
    #[pyo3(get, set)]
    pub srgb: Srgb, 
    #[pyo3(get, set)]
    pub hw_accel: HwAcceleration, 
}

/// Only used for calculations: Point coordinate (x, y) in layout space.
#[pyclass(name = "LayoutPoint")]
pub struct AzLayoutPoint {
    #[pyo3(get, set)]
    pub x: isize, 
    #[pyo3(get, set)]
    pub y: isize, 
}

/// Only used for calculations: Size (width, height) in layout space.
#[pyclass(name = "LayoutSize")]
pub struct AzLayoutSize {
    #[pyo3(get, set)]
    pub width: isize, 
    #[pyo3(get, set)]
    pub height: isize, 
}

/// Only used for calculations: Rectangle (x, y, width, height) in layout space.
#[pyclass(name = "LayoutRect")]
pub struct AzLayoutRect {
    #[pyo3(get, set)]
    pub origin: LayoutPoint, 
    #[pyo3(get, set)]
    pub size: LayoutSize, 
}

/// `AzIOSHandle` struct
#[pyclass(name = "IOSHandle")]
pub struct AzIOSHandle {
    #[pyo3(get, set)]
    pub ui_window: *mut c_void, 
    #[pyo3(get, set)]
    pub ui_view: *mut c_void, 
    #[pyo3(get, set)]
    pub ui_view_controller: *mut c_void, 
}

/// `AzMacOSHandle` struct
#[pyclass(name = "MacOSHandle")]
pub struct AzMacOSHandle {
    #[pyo3(get, set)]
    pub ns_window: *mut c_void, 
    #[pyo3(get, set)]
    pub ns_view: *mut c_void, 
}

/// `AzXlibHandle` struct
#[pyclass(name = "XlibHandle")]
pub struct AzXlibHandle {
    #[pyo3(get, set)]
    pub window: u64, 
    #[pyo3(get, set)]
    pub display: *mut c_void, 
}

/// `AzXcbHandle` struct
#[pyclass(name = "XcbHandle")]
pub struct AzXcbHandle {
    #[pyo3(get, set)]
    pub window: u32, 
    #[pyo3(get, set)]
    pub connection: *mut c_void, 
}

/// `AzWaylandHandle` struct
#[pyclass(name = "WaylandHandle")]
pub struct AzWaylandHandle {
    #[pyo3(get, set)]
    pub surface: *mut c_void, 
    #[pyo3(get, set)]
    pub display: *mut c_void, 
}

/// `AzWindowsHandle` struct
#[pyclass(name = "WindowsHandle")]
pub struct AzWindowsHandle {
    #[pyo3(get, set)]
    pub hwnd: *mut c_void, 
    #[pyo3(get, set)]
    pub hinstance: *mut c_void, 
}

/// `AzWebHandle` struct
#[pyclass(name = "WebHandle")]
pub struct AzWebHandle {
    #[pyo3(get, set)]
    pub id: u32, 
}

/// `AzAndroidHandle` struct
#[pyclass(name = "AndroidHandle")]
pub struct AzAndroidHandle {
    #[pyo3(get, set)]
    pub a_native_window: *mut c_void, 
}

/// Same as `LayoutPoint`, but uses `i32` instead of `isize`
#[pyclass(name = "PhysicalPositionI32")]
pub struct AzPhysicalPositionI32 {
    #[pyo3(get, set)]
    pub x: i32, 
    #[pyo3(get, set)]
    pub y: i32, 
}

/// Same as `LayoutPoint`, but uses `u32` instead of `isize`
#[pyclass(name = "PhysicalSizeU32")]
pub struct AzPhysicalSizeU32 {
    #[pyo3(get, set)]
    pub width: u32, 
    #[pyo3(get, set)]
    pub height: u32, 
}

/// Logical rectangle area (can differ based on HiDPI settings). Usually this is what you'd want for hit-testing and positioning elements.
#[pyclass(name = "LogicalRect")]
pub struct AzLogicalRect {
    #[pyo3(get, set)]
    pub origin: LogicalPosition, 
    #[pyo3(get, set)]
    pub size: LogicalSize, 
}

/// Logical position (can differ based on HiDPI settings). Usually this is what you'd want for hit-testing and positioning elements.
#[pyclass(name = "LogicalPosition")]
pub struct AzLogicalPosition {
    #[pyo3(get, set)]
    pub x: f32, 
    #[pyo3(get, set)]
    pub y: f32, 
}

/// A size in "logical" (non-HiDPI-adjusted) pixels in floating-point units
#[pyclass(name = "LogicalSize")]
pub struct AzLogicalSize {
    #[pyo3(get, set)]
    pub width: f32, 
    #[pyo3(get, set)]
    pub height: f32, 
}

/// Unique hash of a window icon, so that azul does not have to compare the actual bytes to see wether the window icon has changed.
#[pyclass(name = "IconKey")]
pub struct AzIconKey {
    #[pyo3(get, set)]
    pub id: usize, 
}

/// 16x16x4 bytes icon
#[pyclass(name = "SmallWindowIconBytes")]
pub struct AzSmallWindowIconBytes {
    #[pyo3(get, set)]
    pub key: IconKey, 
    #[pyo3(get, set)]
    pub rgba_bytes: U8Vec, 
}

/// 16x16x4 bytes icon
#[pyclass(name = "LargeWindowIconBytes")]
pub struct AzLargeWindowIconBytes {
    #[pyo3(get, set)]
    pub key: IconKey, 
    #[pyo3(get, set)]
    pub rgba_bytes: U8Vec, 
}

/// 256x256x4 bytes window icon
#[pyclass(name = "TaskBarIcon")]
pub struct AzTaskBarIcon {
    #[pyo3(get, set)]
    pub key: IconKey, 
    #[pyo3(get, set)]
    pub rgba_bytes: U8Vec, 
}

/// Minimum / maximum / current size of the window in logical dimensions
#[pyclass(name = "WindowSize")]
pub struct AzWindowSize {
    #[pyo3(get, set)]
    pub dimensions: LogicalSize, 
    #[pyo3(get, set)]
    pub dpi: u32, 
    #[pyo3(get, set)]
    pub min_dimensions: OptionLogicalSize, 
    #[pyo3(get, set)]
    pub max_dimensions: OptionLogicalSize, 
}

/// Boolean flags relating to the current window state
#[pyclass(name = "WindowFlags")]
pub struct AzWindowFlags {
    #[pyo3(get, set)]
    pub frame: WindowFrame, 
    #[pyo3(get, set)]
    pub close_requested: bool, 
    #[pyo3(get, set)]
    pub decorations: WindowDecorations, 
    #[pyo3(get, set)]
    pub is_visible: bool, 
    #[pyo3(get, set)]
    pub is_always_on_top: bool, 
    #[pyo3(get, set)]
    pub is_resizable: bool, 
    #[pyo3(get, set)]
    pub has_focus: bool, 
    #[pyo3(get, set)]
    pub background_material: WindowBackgroundMaterial, 
    #[pyo3(get, set)]
    pub smooth_scroll_enabled: bool, 
    #[pyo3(get, set)]
    pub autotab_enabled: bool, 
    #[pyo3(get, set)]
    pub window_type: WindowType, 
    #[pyo3(get, set)]
    pub has_decorations: bool, 
    #[pyo3(get, set)]
    pub use_native_menus: bool, 
    #[pyo3(get, set)]
    pub use_native_context_menus: bool, 
    #[pyo3(get, set)]
    pub is_top_level: bool, 
    #[pyo3(get, set)]
    pub prevent_system_sleep: bool, 
}

/// Toggles webrender debug flags (will make stuff appear on the screen that you might not want to - used for debugging purposes)
#[pyclass(name = "DebugState")]
pub struct AzDebugState {
    #[pyo3(get, set)]
    pub profiler_dbg: bool, 
    #[pyo3(get, set)]
    pub render_target_dbg: bool, 
    #[pyo3(get, set)]
    pub texture_cache_dbg: bool, 
    #[pyo3(get, set)]
    pub gpu_time_queries: bool, 
    #[pyo3(get, set)]
    pub gpu_sample_queries: bool, 
    #[pyo3(get, set)]
    pub disable_batching: bool, 
    #[pyo3(get, set)]
    pub epochs: bool, 
    #[pyo3(get, set)]
    pub echo_driver_messages: bool, 
    #[pyo3(get, set)]
    pub show_overdraw: bool, 
    #[pyo3(get, set)]
    pub gpu_cache_dbg: bool, 
    #[pyo3(get, set)]
    pub texture_cache_dbg_clear_evicted: bool, 
    #[pyo3(get, set)]
    pub picture_caching_dbg: bool, 
    #[pyo3(get, set)]
    pub primitive_dbg: bool, 
    #[pyo3(get, set)]
    pub zoom_dbg: bool, 
    #[pyo3(get, set)]
    pub small_screen: bool, 
    #[pyo3(get, set)]
    pub disable_opaque_pass: bool, 
    #[pyo3(get, set)]
    pub disable_alpha_pass: bool, 
    #[pyo3(get, set)]
    pub disable_clip_masks: bool, 
    #[pyo3(get, set)]
    pub disable_text_prims: bool, 
    #[pyo3(get, set)]
    pub disable_gradient_prims: bool, 
    #[pyo3(get, set)]
    pub obscure_images: bool, 
    #[pyo3(get, set)]
    pub glyph_flashing: bool, 
    #[pyo3(get, set)]
    pub smart_profiler: bool, 
    #[pyo3(get, set)]
    pub invalidation_dbg: bool, 
    #[pyo3(get, set)]
    pub tile_cache_logging_dbg: bool, 
    #[pyo3(get, set)]
    pub profiler_capture: bool, 
    #[pyo3(get, set)]
    pub force_picture_invalidation: bool, 
}

/// Determines which keys are pressed currently (modifiers, etc.)
#[pyclass(name = "KeyboardState")]
pub struct AzKeyboardState {
    #[pyo3(get, set)]
    pub current_virtual_keycode: OptionVirtualKeyCode, 
    #[pyo3(get, set)]
    pub pressed_virtual_keycodes: VirtualKeyCodeVec, 
    #[pyo3(get, set)]
    pub pressed_scancodes: ScanCodeVec, 
}

/// Mouse position, cursor type, user scroll input, etc.
#[pyclass(name = "MouseState")]
pub struct AzMouseState {
    #[pyo3(get, set)]
    pub mouse_cursor_type: OptionMouseCursorType, 
    #[pyo3(get, set)]
    pub cursor_position: CursorPosition, 
    #[pyo3(get, set)]
    pub is_cursor_locked: bool, 
    #[pyo3(get, set)]
    pub left_down: bool, 
    #[pyo3(get, set)]
    pub right_down: bool, 
    #[pyo3(get, set)]
    pub middle_down: bool, 
}

/// Platform-specific window configuration, i.e. WM options that are not cross-platform
#[pyclass(name = "PlatformSpecificOptions")]
pub struct AzPlatformSpecificOptions {
    #[pyo3(get, set)]
    pub windows_options: WindowsWindowOptions, 
    #[pyo3(get, set)]
    pub linux_options: LinuxWindowOptions, 
    #[pyo3(get, set)]
    pub mac_options: MacWindowOptions, 
    #[pyo3(get, set)]
    pub wasm_options: WasmWindowOptions, 
}

/// Window configuration specific to Win32
#[pyclass(name = "WindowsWindowOptions")]
pub struct AzWindowsWindowOptions {
    #[pyo3(get, set)]
    pub allow_drag_and_drop: bool, 
    #[pyo3(get, set)]
    pub no_redirection_bitmap: bool, 
    #[pyo3(get, set)]
    pub window_icon: OptionWindowIcon, 
    #[pyo3(get, set)]
    pub taskbar_icon: OptionTaskBarIcon, 
    #[pyo3(get, set)]
    pub parent_window: OptionHwndHandle, 
}

/// CSD theme of the window title / button controls
#[pyclass(name = "WaylandTheme")]
pub struct AzWaylandTheme {
    #[pyo3(get, set)]
    pub title_bar_active_background_color: [u8;4], 
    #[pyo3(get, set)]
    pub title_bar_active_separator_color: [u8;4], 
    #[pyo3(get, set)]
    pub title_bar_active_text_color: [u8;4], 
    #[pyo3(get, set)]
    pub title_bar_inactive_background_color: [u8;4], 
    #[pyo3(get, set)]
    pub title_bar_inactive_separator_color: [u8;4], 
    #[pyo3(get, set)]
    pub title_bar_inactive_text_color: [u8;4], 
    #[pyo3(get, set)]
    pub maximize_idle_foreground_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub minimize_idle_foreground_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub close_idle_foreground_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub maximize_hovered_foreground_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub minimize_hovered_foreground_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub close_hovered_foreground_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub maximize_disabled_foreground_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub minimize_disabled_foreground_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub close_disabled_foreground_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub maximize_idle_background_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub minimize_idle_background_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub close_idle_background_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub maximize_hovered_background_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub minimize_hovered_background_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub close_hovered_background_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub maximize_disabled_background_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub minimize_disabled_background_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub close_disabled_background_inactive_color: [u8;4], 
    #[pyo3(get, set)]
    pub maximize_idle_foreground_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub minimize_idle_foreground_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub close_idle_foreground_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub maximize_hovered_foreground_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub minimize_hovered_foreground_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub close_hovered_foreground_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub maximize_disabled_foreground_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub minimize_disabled_foreground_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub close_disabled_foreground_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub maximize_idle_background_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub minimize_idle_background_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub close_idle_background_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub maximize_hovered_background_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub minimize_hovered_background_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub close_hovered_background_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub maximize_disabled_background_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub minimize_disabled_background_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub close_disabled_background_active_color: [u8;4], 
    #[pyo3(get, set)]
    pub title_bar_font: AzString, 
    #[pyo3(get, set)]
    pub title_bar_font_size: f32, 
}

/// `AzWindowState` struct
#[pyclass(name = "WindowState")]
pub struct AzWindowState {
    #[pyo3(get, set)]
    pub title: AzString, 
    #[pyo3(get, set)]
    pub theme: WindowTheme, 
    #[pyo3(get, set)]
    pub size: WindowSize, 
    #[pyo3(get, set)]
    pub position: WindowPosition, 
    #[pyo3(get, set)]
    pub flags: WindowFlags, 
    #[pyo3(get, set)]
    pub debug_state: DebugState, 
    #[pyo3(get, set)]
    pub keyboard_state: KeyboardState, 
    #[pyo3(get, set)]
    pub mouse_state: MouseState, 
    #[pyo3(get, set)]
    pub touch_state: TouchState, 
    #[pyo3(get, set)]
    pub ime_position: ImePosition, 
    #[pyo3(get, set)]
    pub monitor: Monitor, 
    #[pyo3(get, set)]
    pub platform_specific_options: PlatformSpecificOptions, 
    #[pyo3(get, set)]
    pub renderer_options: RendererOptions, 
    #[pyo3(get, set)]
    pub background_color: ColorU, 
    #[pyo3(get, set)]
    pub layout_callback: LayoutCallback, 
    #[pyo3(get, set)]
    pub close_callback: OptionCallback, 
}

/// `AzLinuxWindowOptions` struct
#[pyclass(name = "LinuxWindowOptions")]
pub struct AzLinuxWindowOptions {
    #[pyo3(get, set)]
    pub x11_visual: OptionX11Visual, 
    #[pyo3(get, set)]
    pub x11_screen: OptionI32, 
    #[pyo3(get, set)]
    pub x11_wm_classes: StringPairVec, 
    #[pyo3(get, set)]
    pub x11_override_redirect: bool, 
    #[pyo3(get, set)]
    pub x11_window_types: XWindowTypeVec, 
    #[pyo3(get, set)]
    pub x11_gtk_theme_variant: OptionAzString, 
    #[pyo3(get, set)]
    pub x11_resize_increments: OptionLogicalSize, 
    #[pyo3(get, set)]
    pub x11_base_size: OptionLogicalSize, 
    #[pyo3(get, set)]
    pub wayland_app_id: OptionAzString, 
    #[pyo3(get, set)]
    pub wayland_theme: OptionWaylandTheme, 
    #[pyo3(get, set)]
    pub request_user_attention: UserAttentionType, 
    #[pyo3(get, set)]
    pub window_icon: OptionWindowIcon, 
    #[pyo3(get, set)]
    pub x11_decorations_state: OptionLinuxDecorationsState, 
}

/// `AzMacWindowOptions` struct
#[pyclass(name = "MacWindowOptions")]
pub struct AzMacWindowOptions {
    #[pyo3(get, set)]
    pub _reserved: u8, 
}

/// `AzWasmWindowOptions` struct
#[pyclass(name = "WasmWindowOptions")]
pub struct AzWasmWindowOptions {
    #[pyo3(get, set)]
    pub _reserved: u8, 
}

/// Current state of touch devices / touch inputs
#[pyclass(name = "TouchState")]
pub struct AzTouchState {
    #[pyo3(get, set)]
    pub num_touches: usize, 
}

/// Complete information about a monitor/display
#[pyclass(name = "Monitor")]
pub struct AzMonitor {
    #[pyo3(get, set)]
    pub id: MonitorId, 
    #[pyo3(get, set)]
    pub name: OptionAzString, 
    #[pyo3(get, set)]
    pub size: LayoutSize, 
    #[pyo3(get, set)]
    pub position: LayoutPoint, 
    #[pyo3(get, set)]
    pub scale_factor: f64, 
    #[pyo3(get, set)]
    pub work_area: LayoutRect, 
    #[pyo3(get, set)]
    pub video_modes: VideoModeVec, 
    #[pyo3(get, set)]
    pub is_primary_monitor: bool, 
}

/// Describes a rendering configuration for a monitor
#[pyclass(name = "VideoMode")]
pub struct AzVideoMode {
    #[pyo3(get, set)]
    pub size: LayoutSize, 
    #[pyo3(get, set)]
    pub bit_depth: u16, 
    #[pyo3(get, set)]
    pub refresh_rate: u16, 
}

/// `AzAzStringPair` struct
#[pyclass(name = "AzStringPair")]
pub struct AzAzStringPair {
    #[pyo3(get, set)]
    pub key: AzString, 
    #[pyo3(get, set)]
    pub value: AzString, 
}

/// `AzSystemCallbacks` struct
#[pyclass(name = "SystemCallbacks")]
pub struct AzSystemCallbacks {
    #[pyo3(get, set)]
    pub create_thread: *const c_void, 
    #[pyo3(get, set)]
    pub get_system_time: *const c_void, 
}

/// Identifies a specific monitor/display Contains both an index (for fast current-session lookup) and a stable hash (for persistence across app restarts and monitor reconfigurations). - `index`: Runtime index (0-based), may change if monitors are added/removed - `hash`: Stable identifier based on monitor properties (name, size, position) Applications can serialize `hash` to remember which monitor a window was on, then search for matching hash on next launch, falling back to index or PRIMARY.
#[pyclass(name = "MonitorId")]
pub struct AzMonitorId {
    #[pyo3(get, set)]
    pub index: usize, 
    #[pyo3(get, set)]
    pub hash: u64, 
}

/// C-ABI stable wrapper over a `MarshaledLayoutCallback`
#[pyclass(name = "MarshaledLayoutCallback")]
pub struct AzMarshaledLayoutCallback {
    #[pyo3(get, set)]
    pub marshal_data: RefAny, 
}

/// C-ABI stable wrapper over a `MarshaledLayoutCallbackInner`
#[pyclass(name = "MarshaledLayoutCallbackInner")]
pub struct AzMarshaledLayoutCallbackInner {
}

/// C-ABI stable wrapper over a `LayoutCallbackType`
#[pyclass(name = "LayoutCallbackInner")]
pub struct AzLayoutCallbackInner {
}

/// Stores a function pointer that is executed when the given UI element is hit Must return an `Update` that denotes if the screen should be redrawn.
#[pyclass(name = "Callback")]
pub struct AzCallback {
}

/// Information about the callback that is passed to the callback whenever a callback is invoked
#[pyclass(name = "CallbackInfo")]
pub struct AzCallbackInfo {
    #[pyo3(get, set)]
    pub ref_data: *const c_void, 
    #[pyo3(get, set)]
    pub system_style: Arc < SystemStyle >, 
    #[pyo3(get, set)]
    pub hit_dom_node: DomNodeId, 
    #[pyo3(get, set)]
    pub cursor_relative_to_item: OptionLogicalPosition, 
    #[pyo3(get, set)]
    pub cursor_in_viewport: OptionLogicalPosition, 
    #[pyo3(get, set)]
    pub changes: *mut c_void, 
}

/// Gives the `layout()` function access to the `RendererResources` and the `Window` (for querying images and fonts, as well as width / height)
#[pyclass(name = "LayoutCallbackInfo")]
pub struct AzLayoutCallbackInfo {
    #[pyo3(get, set)]
    pub ref_data: *const c_void, 
    #[pyo3(get, set)]
    pub window_size: WindowSize, 
    #[pyo3(get, set)]
    pub theme: WindowTheme, 
    #[pyo3(get, set)]
    pub _abi_ref: *const c_void, 
    #[pyo3(get, set)]
    pub _abi_mut: *mut c_void, 
}

/// A unique, runtime-generated identifier for a single `Dom` instance.
#[pyclass(name = "DomId")]
pub struct AzDomId {
    #[pyo3(get, set)]
    pub inner: usize, 
}

/// A UUID for a DOM node within a `LayoutWindow`.
#[pyclass(name = "DomNodeId")]
pub struct AzDomNodeId {
    #[pyo3(get, set)]
    pub dom: DomId, 
    #[pyo3(get, set)]
    pub node: NodeHierarchyItemId, 
}

/// `AzPositionInfoInner` struct
#[pyclass(name = "PositionInfoInner")]
pub struct AzPositionInfoInner {
    #[pyo3(get, set)]
    pub x_offset: f32, 
    #[pyo3(get, set)]
    pub y_offset: f32, 
    #[pyo3(get, set)]
    pub static_x_offset: f32, 
    #[pyo3(get, set)]
    pub static_y_offset: f32, 
}

/// Information about the bounds of a laid-out div rectangle. Necessary when invoking `IFrameCallbacks` and `RenderImageCallbacks`, so that they can change what their content is based on their size.
#[pyclass(name = "HidpiAdjustedBounds")]
pub struct AzHidpiAdjustedBounds {
    #[pyo3(get, set)]
    pub logical_size: LogicalSize, 
    #[pyo3(get, set)]
    pub hidpi_factor: DpiScaleFactor, 
}

/// `AzInlineText` struct
#[pyclass(name = "InlineText")]
pub struct AzInlineText {
    #[pyo3(get, set)]
    pub lines: InlineLineVec, 
    #[pyo3(get, set)]
    pub content_size: LogicalSize, 
    #[pyo3(get, set)]
    pub font_size_px: f32, 
    #[pyo3(get, set)]
    pub last_word_index: usize, 
    #[pyo3(get, set)]
    pub baseline_descender_px: f32, 
}

/// `AzInlineLine` struct
#[pyclass(name = "InlineLine")]
pub struct AzInlineLine {
    #[pyo3(get, set)]
    pub words: InlineWordVec, 
    #[pyo3(get, set)]
    pub bounds: LogicalRect, 
}

/// `AzInlineTextContents` struct
#[pyclass(name = "InlineTextContents")]
pub struct AzInlineTextContents {
    #[pyo3(get, set)]
    pub glyphs: InlineGlyphVec, 
    #[pyo3(get, set)]
    pub bounds: LogicalRect, 
}

/// `AzInlineGlyph` struct
#[pyclass(name = "InlineGlyph")]
pub struct AzInlineGlyph {
    #[pyo3(get, set)]
    pub bounds: LogicalRect, 
    #[pyo3(get, set)]
    pub unicode_codepoint: OptionChar, 
    #[pyo3(get, set)]
    pub glyph_index: u32, 
}

/// `AzInlineTextHit` struct
#[pyclass(name = "InlineTextHit")]
pub struct AzInlineTextHit {
    #[pyo3(get, set)]
    pub unicode_codepoint: OptionChar, 
    #[pyo3(get, set)]
    pub hit_relative_to_inline_text: LogicalPosition, 
    #[pyo3(get, set)]
    pub hit_relative_to_line: LogicalPosition, 
    #[pyo3(get, set)]
    pub hit_relative_to_text_content: LogicalPosition, 
    #[pyo3(get, set)]
    pub hit_relative_to_glyph: LogicalPosition, 
    #[pyo3(get, set)]
    pub line_index_relative_to_text: usize, 
    #[pyo3(get, set)]
    pub word_index_relative_to_text: usize, 
    #[pyo3(get, set)]
    pub text_content_index_relative_to_text: usize, 
    #[pyo3(get, set)]
    pub glyph_index_relative_to_text: usize, 
    #[pyo3(get, set)]
    pub char_index_relative_to_text: usize, 
    #[pyo3(get, set)]
    pub word_index_relative_to_line: usize, 
    #[pyo3(get, set)]
    pub text_content_index_relative_to_line: usize, 
    #[pyo3(get, set)]
    pub glyph_index_relative_to_line: usize, 
    #[pyo3(get, set)]
    pub char_index_relative_to_line: usize, 
    #[pyo3(get, set)]
    pub glyph_index_relative_to_word: usize, 
    #[pyo3(get, set)]
    pub char_index_relative_to_word: usize, 
}

/// CSS path to set the keyboard input focus
#[pyclass(name = "FocusTargetPath")]
pub struct AzFocusTargetPath {
    #[pyo3(get, set)]
    pub dom: DomId, 
    #[pyo3(get, set)]
    pub css_path: CssPath, 
}

/// `AzResolvedTextLayoutOptions` struct
#[pyclass(name = "ResolvedTextLayoutOptions")]
pub struct AzResolvedTextLayoutOptions {
    #[pyo3(get, set)]
    pub font_size_px: f32, 
    #[pyo3(get, set)]
    pub line_height: OptionF32, 
    #[pyo3(get, set)]
    pub letter_spacing: OptionF32, 
    #[pyo3(get, set)]
    pub word_spacing: OptionF32, 
    #[pyo3(get, set)]
    pub tab_width: OptionF32, 
    #[pyo3(get, set)]
    pub max_horizontal_width: OptionF32, 
    #[pyo3(get, set)]
    pub leading: OptionF32, 
    #[pyo3(get, set)]
    pub holes: LogicalRectVec, 
    #[pyo3(get, set)]
    pub max_vertical_height: OptionF32, 
    #[pyo3(get, set)]
    pub can_break: bool, 
    #[pyo3(get, set)]
    pub can_hyphenate: bool, 
    #[pyo3(get, set)]
    pub hyphenation_character: OptionChar, 
    #[pyo3(get, set)]
    pub is_rtl: ScriptType, 
    #[pyo3(get, set)]
    pub text_justify: OptionStyleTextAlign, 
}

/// Animation struct to start a new animation
#[pyclass(name = "Animation")]
pub struct AzAnimation {
    #[pyo3(get, set)]
    pub from: CssProperty, 
    #[pyo3(get, set)]
    pub to: CssProperty, 
    #[pyo3(get, set)]
    pub duration: AzDuration, 
    #[pyo3(get, set)]
    pub repeat: AnimationRepeat, 
    #[pyo3(get, set)]
    pub repeat_times: AnimationRepeatCount, 
    #[pyo3(get, set)]
    pub easing: AnimationInterpolationFunction, 
    #[pyo3(get, set)]
    pub relayout_on_finish: bool, 
}

/// Index of a Node in the internal `NodeDataContainer`
#[pyclass(name = "NodeHierarchyItemId")]
pub struct AzNodeHierarchyItemId {
    #[pyo3(get, set)]
    pub inner: usize, 
}

/// C-ABI wrapper over an `IFrameCallbackType`
#[pyclass(name = "IFrameCallback")]
pub struct AzIFrameCallback {
}

/// `AzIFrameCallbackInfo` struct
#[pyclass(name = "IFrameCallbackInfo")]
pub struct AzIFrameCallbackInfo {
    #[pyo3(get, set)]
    pub reason: IFrameCallbackReason, 
    #[pyo3(get, set)]
    pub system_fonts: *const c_void, 
    #[pyo3(get, set)]
    pub image_cache: *const c_void, 
    #[pyo3(get, set)]
    pub window_theme: WindowTheme, 
    #[pyo3(get, set)]
    pub bounds: HidpiAdjustedBounds, 
    #[pyo3(get, set)]
    pub scroll_size: LogicalSize, 
    #[pyo3(get, set)]
    pub scroll_offset: LogicalPosition, 
    #[pyo3(get, set)]
    pub virtual_scroll_size: LogicalSize, 
    #[pyo3(get, set)]
    pub virtual_scroll_offset: LogicalPosition, 
    #[pyo3(get, set)]
    pub _abi_ref: *const c_void, 
    #[pyo3(get, set)]
    pub _abi_mut: *mut c_void, 
}

/// Return value for an IFrame rendering callback. # Dual Size Model IFrame callbacks return two size/offset pairs that enable lazy loading and virtualization: ## Actual Content (`scroll_size` + `scroll_offset`) The size and position of content that has **actually been rendered**. This is the content currently present in the returned DOM. **Example**: A table view might render only 20 visible rows out of 1000 total rows. ## Virtual Content (`virtual_scroll_size` + `virtual_scroll_offset`) The size and position of content that the IFrame **pretends to have**. This is used for scrollbar sizing and positioning, allowing the scrollbar to represent the full dataset even when only a subset is rendered. **Example**: The same table might pretend to have all 1000 rows for scrollbar sizing. # Conditional Re-invocation The IFrame callback will be re-invoked **only when necessary** to avoid performance overhead: 1. **Initial render** - First time the IFrame appears in the layout 2. **Parent DOM recreated** - The parent DOM was rebuilt from scratch (not just re-laid-out) 3. **Window resize (expansion only)** - Window grows and IFrame bounds exceed `scroll_size` -  Only triggers **ONCE** per expansion (when bounds become uncovered) -  Does **NOT** trigger when window shrinks (content is clipped, not re-rendered) -  Does **NOT** trigger if expanded area is still within existing `scroll_size` 4. **Scroll near edge** - User scrolls within threshold (default 200px) of content edge -  Only triggers **ONCE** per edge approach (prevents repeated calls) - Flag resets when: scroll moves away from edge, or callback returns expanded content 5. **Programmatic scroll** - `set_scroll_position()` scrolls beyond rendered `scroll_size` - Same constraints as rule #4 (threshold and once-per-edge) ## Window Resize Example ```text Frame 0: IFrame bounds = 800600, scroll_size = 800600 (perfectly covered) Frame 1: Window resizes to 1000700 (larger) -> IFrame bounds = 1000700 -> Bounds no longer fully covered by scroll_size (800600) ->  RE-INVOKE callback once Frame 2: Window resizes to 1100800 (even larger) -> If callback returned scroll_size = 1100800, fully covered again ->  Do NOT re-invoke (content covers new bounds) -> If callback returned scroll_size = 1000700, not fully covered ->  RE-INVOKE again (new uncovered area) Frame 3: Window resizes to 900650 (smaller) -> Bounds now smaller than scroll_size ->  Do NOT re-invoke (content is just clipped by scrollbars) ``` ## Scroll Near Edge Example ```text scroll_size = 10002000 (width  height) Container = 800600 Threshold = 200px Current scroll_offset = 00 User scrolls to scroll_offset = 01500: -> Bottom edge at 1500 + 600 = 2100 -> Within 200px of scroll_size.height (2000) -> Distance from edge: 2100 - 2000 = 100px < 200px ->  RE-INVOKE callback to load more content Callback returns: -> New scroll_size = 10004000 (doubled) -> Flag reset (edge no longer near) -> User continues scrolling without re-invoke until near new edge ``` # Optimization: Returning None If the callback determines that no new content is needed (e.g., sufficient content has already been rendered ahead of the scroll position), it can return `OptionStyledDom::None` for the `dom` field. This signals the layout engine to keep using the current DOM and only update the scroll bounds. ```rust,ignore fn my_iframe_callback(data: &mut MyData, info: &mut IFrameCallbackInfo) -> IFrameCallbackReturn { let current_scroll = info.scroll_offset; // Check if we've already rendered content that covers this scroll position if data.already_rendered_area_covers(current_scroll, info.bounds.size) { return IFrameCallbackReturn { dom: OptionStyledDom::None, // Keep current DOM scroll_size: data.current_scroll_size, scroll_offset: data.current_scroll_offset, virtual_scroll_size: data.virtual_size, virtual_scroll_offset: LogicalPosition::zero(), }; } // Otherwise, render new content let new_dom = data.render_more_content(...); IFrameCallbackReturn { dom: OptionStyledDom::Some(new_dom), ... } } ``` # Example: Basic IFrame ```rust,ignore fn my_iframe_callback(data: &mut MyData, info: &mut IFrameCallbackInfo) -> IFrameCallbackReturn { let dom = Dom::body() .with_child(Dom::text("Hello from IFrame!")); let styled_dom = dom.style(Css::empty()); IFrameCallbackReturn { // The rendered content dom: OptionStyledDom::Some(styled_dom), // Size of actual rendered content (matches container) scroll_size: info.bounds.size, // Content starts at top-left scroll_offset: LogicalPosition::zero(), // Virtual size same as actual (no virtualization needed) virtual_scroll_size: info.bounds.size, virtual_scroll_offset: LogicalPosition::zero(), } } ``` # Example: Virtualized Table (Lazy Loading) ```rust,ignore struct TableData { total_rows: usize, // 1000 rows in full dataset row_height: f32, // 30px per row visible_rows: Vec<Row>, // Currently rendered rows (e.g., rows 0-29) first_visible_row: usize, // Index of first rendered row } fn table_iframe_callback(data: &mut TableData, info: &mut IFrameCallbackInfo) -> IFrameCallbackReturn { let container_height = info.bounds.size.height; let scroll_y = info.scroll_offset.y; // Calculate which rows should be visible based on scroll position let first_row = (scroll_y / data.row_height) as usize; let visible_count = (container_height / data.row_height).ceil() as usize + 2; // +2 for buffer // Fetch and render only the visible rows data.visible_rows = data.fetch_rows(first_row, visible_count); data.first_visible_row = first_row; let dom = Dom::body() .with_children( data.visible_rows.iter().map(|row| { Dom::div() .with_child(Dom::text(row.text.clone())) .with_inline_css_props(css_property_vec![ ("height", format!("{}px", data.row_height)), ]) }).collect() ); IFrameCallbackReturn { dom: OptionStyledDom::Some(dom.style(Css::empty())), // ACTUAL: Size of the ~30 rendered rows (e.g., 900px tall) scroll_size: LogicalSize::new( info.bounds.size.width, data.visible_rows.len() as f32 * data.row_height, ), // ACTUAL: Where these rows start in virtual space (e.g., y=300 if showing rows 10-30) scroll_offset: LogicalPosition::new( 0.0, first_row as f32 * data.row_height, ), // VIRTUAL: Size if all 1000 rows were rendered (30,000px tall) virtual_scroll_size: LogicalSize::new( info.bounds.size.width, data.total_rows as f32 * data.row_height, ), // VIRTUAL: Usually starts at origin virtual_scroll_offset: LogicalPosition::zero(), } } ``` In this example: - Only 20-30 rows are rendered at a time (~600-900px of DOM nodes) - The scrollbar represents all 1000 rows (30,000px virtual height) - When user scrolls near the bottom of rendered content, callback is re-invoked - New rows are rendered, and `scroll_size`/`scroll_offset` are updated - User experiences seamless scrolling through the full dataset # How the Layout Engine Uses These Values ## For Rendering - Uses `scroll_size` to determine the actual size of the IFrame's content box - Uses `scroll_offset` to position the content within the virtual space - Clips rendering to the visible viewport ## For Scrollbars - Uses `virtual_scroll_size` to calculate scrollbar thumb size and track length - Uses `virtual_scroll_offset` as the base for scroll position calculations - User sees scrollbar representing full virtual size, not just rendered content ## For Re-invocation Checks - Compares viewport bounds against `scroll_size` to detect edge proximity - Compares current scroll position against `scroll_offset + scroll_size` bounds - Triggers callback when user scrolls beyond the rendered content threshold
#[pyclass(name = "IFrameCallbackReturn")]
pub struct AzIFrameCallbackReturn {
    #[pyo3(get, set)]
    pub dom: OptionStyledDom, 
    #[pyo3(get, set)]
    pub scroll_size: LogicalSize, 
    #[pyo3(get, set)]
    pub scroll_offset: LogicalPosition, 
    #[pyo3(get, set)]
    pub virtual_scroll_size: LogicalSize, 
    #[pyo3(get, set)]
    pub virtual_scroll_offset: LogicalPosition, 
}

/// Callback that returns a rendered OpenGL texture **IMPORTANT**: In azul-core, this is stored as `CoreRenderImageCallback` with a `cb: usize` field. When creating callbacks in the data model, function pointers are cast to usize. This type is used in azul-layout where we can safely work with the actual function pointer type.
#[pyclass(name = "RenderImageCallback")]
pub struct AzRenderImageCallback {
}

/// Information passed to image rendering callbacks
#[pyclass(name = "RenderImageCallbackInfo")]
pub struct AzRenderImageCallbackInfo {
    #[pyo3(get, set)]
    pub callback_node_id: DomNodeId, 
    #[pyo3(get, set)]
    pub bounds: HidpiAdjustedBounds, 
    #[pyo3(get, set)]
    pub gl_context: *const c_void, 
    #[pyo3(get, set)]
    pub image_cache: *const c_void, 
    #[pyo3(get, set)]
    pub system_fonts: *const c_void, 
    #[pyo3(get, set)]
    pub _abi_ref: *const c_void, 
    #[pyo3(get, set)]
    pub _abi_mut: *mut c_void, 
}

/// `AzTimerCallback` struct
#[pyclass(name = "TimerCallback")]
pub struct AzTimerCallback {
}

/// `AzTimerCallbackInfo` struct
#[pyclass(name = "TimerCallbackInfo")]
pub struct AzTimerCallbackInfo {
    #[pyo3(get, set)]
    pub callback_info: CallbackInfo, 
    #[pyo3(get, set)]
    pub node_id: OptionDomNodeId, 
    #[pyo3(get, set)]
    pub frame_start: Instant, 
    #[pyo3(get, set)]
    pub call_count: usize, 
    #[pyo3(get, set)]
    pub is_about_to_finish: bool, 
    #[pyo3(get, set)]
    pub _abi_ref: *const c_void, 
    #[pyo3(get, set)]
    pub _abi_mut: *mut c_void, 
}

/// `AzTimerCallbackReturn` struct
#[pyclass(name = "TimerCallbackReturn")]
pub struct AzTimerCallbackReturn {
    #[pyo3(get, set)]
    pub should_update: Update, 
    #[pyo3(get, set)]
    pub should_terminate: TerminateTimer, 
}

/// `AzWriteBackCallback` struct
#[pyclass(name = "WriteBackCallback")]
pub struct AzWriteBackCallback {
}

/// `AzThreadCallback` struct
#[pyclass(name = "ThreadCallback")]
pub struct AzThreadCallback {
}

/// `AzRefCount` struct
#[pyclass(name = "RefCount")]
pub struct AzRefCount {
    pub ptr: *const RefCountInner, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// RefAny is a reference-counted, opaque pointer, which stores a reference to a struct. `RefAny` can be up- and downcasted (this usually done via generics and can't be expressed in the Rust API)
#[pyclass(name = "RefAny")]
pub struct AzRefAny {
    #[pyo3(get, set)]
    pub _internal_ptr: *const c_void, 
    #[pyo3(get, set)]
    pub sharing_info: RefCount, 
    #[pyo3(get, set)]
    pub instance_id: u64, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// Similar to `dom.CallbackData`, stores some data + a callback to call when the menu is activated
#[pyclass(name = "MenuCallback")]
pub struct AzMenuCallback {
    #[pyo3(get, set)]
    pub callback: Callback, 
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// The document model, similar to HTML. This is a create-only structure, you don't actually read anything back from it. It's designed for ease of construction.
#[pyclass(name = "Dom")]
pub struct AzDom {
    #[pyo3(get, set)]
    pub root: NodeData, 
    #[pyo3(get, set)]
    pub children: DomVec, 
    #[pyo3(get, set)]
    pub estimated_total_children: usize, 
}

/// Contains the necessary information to render an embedded `IFrame` node.
#[pyclass(name = "IFrameNode")]
pub struct AzIFrameNode {
    #[pyo3(get, set)]
    pub callback: IFrameCallback, 
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// `AzCallbackData` struct
#[pyclass(name = "CallbackData")]
pub struct AzCallbackData {
    #[pyo3(get, set)]
    pub event: EventFilter, 
    #[pyo3(get, set)]
    pub callback: Callback, 
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// Represents all data associated with a single DOM node, such as its type, classes, IDs, callbacks, and inline styles.
#[pyclass(name = "NodeData")]
pub struct AzNodeData {
    #[pyo3(get, set)]
    pub node_type: NodeType, 
    #[pyo3(get, set)]
    pub dataset: OptionRefAny, 
    #[pyo3(get, set)]
    pub ids_and_classes: IdOrClassVec, 
    #[pyo3(get, set)]
    pub attributes: AttributeVec, 
    #[pyo3(get, set)]
    pub callbacks: CoreCallbackDataVec, 
    #[pyo3(get, set)]
    pub inline_css_props: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub tab_index: OptionTabIndex, 
    #[pyo3(get, set)]
    pub extra: *const c_void, 
}

/// Holds information about a UI element for accessibility purposes (e.g., screen readers). This is a wrapper for platform-specific accessibility APIs like MSAA.
#[pyclass(name = "AccessibilityInfo")]
pub struct AzAccessibilityInfo {
    #[pyo3(get, set)]
    pub name: OptionAzString, 
    #[pyo3(get, set)]
    pub value: OptionAzString, 
    #[pyo3(get, set)]
    pub role: AccessibilityRole, 
    #[pyo3(get, set)]
    pub states: AccessibilityStateVec, 
    #[pyo3(get, set)]
    pub accelerator: OptionVirtualKeyCodeCombo, 
    #[pyo3(get, set)]
    pub default_action: OptionAzString, 
    #[pyo3(get, set)]
    pub supported_actions: AccessibilityActionVec, 
    #[pyo3(get, set)]
    pub is_live_region: bool, 
    #[pyo3(get, set)]
    pub labelled_by: OptionDomNodeId, 
    #[pyo3(get, set)]
    pub described_by: OptionDomNodeId, 
}

/// Represents a menu (context menu, dropdown menu, or application menu). A menu consists of a list of items that can be displayed as a popup or attached to a window's menu bar. Modeled after the Windows API for cross-platform consistency. # Fields * `items` - The menu items to display * `position` - Where the menu should appear (for popups) * `context_mouse_btn` - Which mouse button triggers the context menu
#[pyclass(name = "Menu")]
pub struct AzMenu {
    #[pyo3(get, set)]
    pub items: MenuItemVec, 
    #[pyo3(get, set)]
    pub position: MenuPopupPosition, 
    #[pyo3(get, set)]
    pub context_mouse_btn: ContextMenuMouseButton, 
}

/// A menu item with a text label and optional features. `StringMenuItem` represents a clickable menu entry that can have: - A text label - An optional keyboard accelerator (e.g., Ctrl+C) - An optional callback function - An optional icon (checkbox or image) - A state (normal, greyed, or disabled) - Child menu items (for sub-menus) # Examples ```rust,no_run use azul_core::menu::StringMenuItem; use azul_css::AzString; let item = StringMenuItem::new(AzString::from_const_str("Copy")); ```
#[pyclass(name = "StringMenuItem")]
pub struct AzStringMenuItem {
    #[pyo3(get, set)]
    pub label: AzString, 
    #[pyo3(get, set)]
    pub accelerator: OptionVirtualKeyCodeCombo, 
    #[pyo3(get, set)]
    pub callback: OptionCoreMenuCallback, 
    #[pyo3(get, set)]
    pub state: MenuItemState, 
    #[pyo3(get, set)]
    pub icon: OptionMenuItemIcon, 
    #[pyo3(get, set)]
    pub children: MenuItemVec, 
}

/// Combination of virtual key codes that have to be pressed together
#[pyclass(name = "VirtualKeyCodeCombo")]
pub struct AzVirtualKeyCodeCombo {
    #[pyo3(get, set)]
    pub keys: VirtualKeyCodeVec, 
}

/// One block of rules that applies a bunch of rules to a "path" in the style, i.e. `div#myid.myclass -> { ("justify-content", "center") }`
#[pyclass(name = "CssRuleBlock")]
pub struct AzCssRuleBlock {
    #[pyo3(get, set)]
    pub path: CssPath, 
    #[pyo3(get, set)]
    pub declarations: CssDeclarationVec, 
}

/// Represents a full CSS path (i.e. the "div#id.class" selector belonging to a CSS "content group" (the following key-value block)). ```no_run,ignore "#div > .my_class:focus" == [ CssPathSelector::Type(NodeTypeTag::Div), CssPathSelector::PseudoSelector(CssPathPseudoSelector::LimitChildren), CssPathSelector::Class("my_class"), CssPathSelector::PseudoSelector(CssPathPseudoSelector::Focus), ]
#[pyclass(name = "CssPath")]
pub struct AzCssPath {
    #[pyo3(get, set)]
    pub selectors: CssPathSelectorVec, 
}

/// `AzCssNthChildPattern` struct
#[pyclass(name = "CssNthChildPattern")]
pub struct AzCssNthChildPattern {
    #[pyo3(get, set)]
    pub repeat: u32, 
    #[pyo3(get, set)]
    pub offset: u32, 
}

/// `AzStylesheet` struct
#[pyclass(name = "Stylesheet")]
pub struct AzStylesheet {
    #[pyo3(get, set)]
    pub rules: CssRuleBlockVec, 
}

/// Css stylesheet - contains a parsed CSS stylesheet in "rule blocks", i.e. blocks of key-value pairs associated with a selector path.
#[pyclass(name = "Css")]
pub struct AzCss {
    #[pyo3(get, set)]
    pub stylesheets: StylesheetVec, 
}

/// A `DynamicCssProperty` is a type of css property that can be changed on possibly every frame by the Rust code - for example to implement an `On::Hover` behaviour. The syntax for such a property looks like this: ```no_run,ignore #my_div { padding: var(--my_dynamic_property_id, 400px); } ``` Azul will register a dynamic property with the key "my_dynamic_property_id" and the default value of 400px. If the property gets overridden during one frame, the overridden property takes precedence. At runtime the style is immutable (which is a performance optimization - if we can assume that the property never changes at runtime), we can do some optimizations on it. Dynamic style properties can also be used for animations and conditional styles (i.e. `hover`, `focus`, etc.), thereby leading to cleaner code, since all of these special cases now use one single API.
#[pyclass(name = "DynamicCssProperty")]
pub struct AzDynamicCssProperty {
    #[pyo3(get, set)]
    pub dynamic_id: AzString, 
    #[pyo3(get, set)]
    pub default_value: CssProperty, 
}

/// u8-based color, range 0 to 255 (similar to webrenders ColorU)
#[pyclass(name = "ColorU")]
pub struct AzColorU {
    #[pyo3(get, set)]
    pub r: u8, 
    #[pyo3(get, set)]
    pub g: u8, 
    #[pyo3(get, set)]
    pub b: u8, 
    #[pyo3(get, set)]
    pub a: u8, 
}

/// `AzPixelValue` struct
#[pyclass(name = "PixelValue")]
pub struct AzPixelValue {
    #[pyo3(get, set)]
    pub metric: SizeMetric, 
    #[pyo3(get, set)]
    pub number: FloatValue, 
}

/// Same as PixelValue, but doesn't allow a "%" sign
#[pyclass(name = "PixelValueNoPercent")]
pub struct AzPixelValueNoPercent {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Represents a `box-shadow` or `text-shadow` property.
#[pyclass(name = "StyleBoxShadow")]
pub struct AzStyleBoxShadow {
    #[pyo3(get, set)]
    pub offset: [PixelValueNoPercent;2], 
    #[pyo3(get, set)]
    pub color: ColorU, 
    #[pyo3(get, set)]
    pub blur_radius: PixelValueNoPercent, 
    #[pyo3(get, set)]
    pub spread_radius: PixelValueNoPercent, 
    #[pyo3(get, set)]
    pub clip_mode: BoxShadowClipMode, 
}

/// `AzStyleBlur` struct
#[pyclass(name = "StyleBlur")]
pub struct AzStyleBlur {
    #[pyo3(get, set)]
    pub width: PixelValue, 
    #[pyo3(get, set)]
    pub height: PixelValue, 
}

/// `AzStyleColorMatrix` struct
#[pyclass(name = "StyleColorMatrix")]
pub struct AzStyleColorMatrix {
    #[pyo3(get, set)]
    pub matrix: [FloatValue;20], 
}

/// `AzStyleFilterOffset` struct
#[pyclass(name = "StyleFilterOffset")]
pub struct AzStyleFilterOffset {
    #[pyo3(get, set)]
    pub x: PixelValue, 
    #[pyo3(get, set)]
    pub y: PixelValue, 
}

/// `AzLayoutBottom` struct
#[pyclass(name = "LayoutBottom")]
pub struct AzLayoutBottom {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Represents a `flex-grow` attribute, which dictates what proportion of the remaining space in the flex container should be assigned to the item. Default: 0
#[pyclass(name = "LayoutFlexGrow")]
pub struct AzLayoutFlexGrow {
    #[pyo3(get, set)]
    pub inner: FloatValue, 
}

/// Represents a `flex-shrink` attribute, which dictates what proportion of the negative space in the flex container should be removed from the item. Default: 1
#[pyclass(name = "LayoutFlexShrink")]
pub struct AzLayoutFlexShrink {
    #[pyo3(get, set)]
    pub inner: FloatValue, 
}

/// `AzLayoutHeight` struct
#[pyclass(name = "LayoutHeight")]
pub struct AzLayoutHeight {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutLeft` struct
#[pyclass(name = "LayoutLeft")]
pub struct AzLayoutLeft {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutMarginBottom` struct
#[pyclass(name = "LayoutMarginBottom")]
pub struct AzLayoutMarginBottom {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutMarginLeft` struct
#[pyclass(name = "LayoutMarginLeft")]
pub struct AzLayoutMarginLeft {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutMarginRight` struct
#[pyclass(name = "LayoutMarginRight")]
pub struct AzLayoutMarginRight {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutMarginTop` struct
#[pyclass(name = "LayoutMarginTop")]
pub struct AzLayoutMarginTop {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutMaxHeight` struct
#[pyclass(name = "LayoutMaxHeight")]
pub struct AzLayoutMaxHeight {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutMaxWidth` struct
#[pyclass(name = "LayoutMaxWidth")]
pub struct AzLayoutMaxWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutMinHeight` struct
#[pyclass(name = "LayoutMinHeight")]
pub struct AzLayoutMinHeight {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutMinWidth` struct
#[pyclass(name = "LayoutMinWidth")]
pub struct AzLayoutMinWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutPaddingBottom` struct
#[pyclass(name = "LayoutPaddingBottom")]
pub struct AzLayoutPaddingBottom {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutPaddingLeft` struct
#[pyclass(name = "LayoutPaddingLeft")]
pub struct AzLayoutPaddingLeft {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutPaddingRight` struct
#[pyclass(name = "LayoutPaddingRight")]
pub struct AzLayoutPaddingRight {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutPaddingTop` struct
#[pyclass(name = "LayoutPaddingTop")]
pub struct AzLayoutPaddingTop {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutRight` struct
#[pyclass(name = "LayoutRight")]
pub struct AzLayoutRight {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutTop` struct
#[pyclass(name = "LayoutTop")]
pub struct AzLayoutTop {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutWidth` struct
#[pyclass(name = "LayoutWidth")]
pub struct AzLayoutWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Wrapper around an f32 value that is internally casted to an isize, in order to provide hash-ability (to avoid numerical instability).
#[pyclass(name = "FloatValue")]
pub struct AzFloatValue {
    #[pyo3(get, set)]
    pub number: isize, 
}

/// Wrapper around FloatValue, represents a percentage instead of just being a regular floating-point value, i.e `5` = `5%`
#[pyclass(name = "PercentageValue")]
pub struct AzPercentageValue {
    #[pyo3(get, set)]
    pub number: FloatValue, 
}

/// FloatValue, but associated with a certain metric (i.e. deg, rad, etc.)
#[pyclass(name = "AngleValue")]
pub struct AzAngleValue {
    #[pyo3(get, set)]
    pub metric: AngleMetric, 
    #[pyo3(get, set)]
    pub number: FloatValue, 
}

/// `AzNormalizedLinearColorStop` struct
#[pyclass(name = "NormalizedLinearColorStop")]
pub struct AzNormalizedLinearColorStop {
    #[pyo3(get, set)]
    pub offset: PercentageValue, 
    #[pyo3(get, set)]
    pub color: ColorU, 
}

/// `AzNormalizedRadialColorStop` struct
#[pyclass(name = "NormalizedRadialColorStop")]
pub struct AzNormalizedRadialColorStop {
    #[pyo3(get, set)]
    pub angle: AngleValue, 
    #[pyo3(get, set)]
    pub color: ColorU, 
}

/// `AzDirectionCorners` struct
#[pyclass(name = "DirectionCorners")]
pub struct AzDirectionCorners {
    #[pyo3(get, set)]
    pub from: DirectionCorner, 
    #[pyo3(get, set)]
    pub to: DirectionCorner, 
}

/// `AzLinearGradient` struct
#[pyclass(name = "LinearGradient")]
pub struct AzLinearGradient {
    #[pyo3(get, set)]
    pub direction: Direction, 
    #[pyo3(get, set)]
    pub extend_mode: ExtendMode, 
    #[pyo3(get, set)]
    pub stops: NormalizedLinearColorStopVec, 
}

/// `AzRadialGradient` struct
#[pyclass(name = "RadialGradient")]
pub struct AzRadialGradient {
    #[pyo3(get, set)]
    pub shape: Shape, 
    #[pyo3(get, set)]
    pub size: RadialGradientSize, 
    #[pyo3(get, set)]
    pub position: StyleBackgroundPosition, 
    #[pyo3(get, set)]
    pub extend_mode: ExtendMode, 
    #[pyo3(get, set)]
    pub stops: NormalizedLinearColorStopVec, 
}

/// `AzConicGradient` struct
#[pyclass(name = "ConicGradient")]
pub struct AzConicGradient {
    #[pyo3(get, set)]
    pub extend_mode: ExtendMode, 
    #[pyo3(get, set)]
    pub center: StyleBackgroundPosition, 
    #[pyo3(get, set)]
    pub angle: AngleValue, 
    #[pyo3(get, set)]
    pub stops: NormalizedRadialColorStopVec, 
}

/// `AzStyleBackgroundPosition` struct
#[pyclass(name = "StyleBackgroundPosition")]
pub struct AzStyleBackgroundPosition {
    #[pyo3(get, set)]
    pub horizontal: BackgroundPositionHorizontal, 
    #[pyo3(get, set)]
    pub vertical: BackgroundPositionVertical, 
}

/// `AzStyleBorderBottomColor` struct
#[pyclass(name = "StyleBorderBottomColor")]
pub struct AzStyleBorderBottomColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// `AzStyleBorderBottomLeftRadius` struct
#[pyclass(name = "StyleBorderBottomLeftRadius")]
pub struct AzStyleBorderBottomLeftRadius {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzStyleBorderBottomRightRadius` struct
#[pyclass(name = "StyleBorderBottomRightRadius")]
pub struct AzStyleBorderBottomRightRadius {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzStyleBorderBottomStyle` struct
#[pyclass(name = "StyleBorderBottomStyle")]
pub struct AzStyleBorderBottomStyle {
    #[pyo3(get, set)]
    pub inner: BorderStyle, 
}

/// `AzLayoutBorderBottomWidth` struct
#[pyclass(name = "LayoutBorderBottomWidth")]
pub struct AzLayoutBorderBottomWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzStyleBorderLeftColor` struct
#[pyclass(name = "StyleBorderLeftColor")]
pub struct AzStyleBorderLeftColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// `AzStyleBorderLeftStyle` struct
#[pyclass(name = "StyleBorderLeftStyle")]
pub struct AzStyleBorderLeftStyle {
    #[pyo3(get, set)]
    pub inner: BorderStyle, 
}

/// `AzLayoutBorderLeftWidth` struct
#[pyclass(name = "LayoutBorderLeftWidth")]
pub struct AzLayoutBorderLeftWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzStyleBorderRightColor` struct
#[pyclass(name = "StyleBorderRightColor")]
pub struct AzStyleBorderRightColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// `AzStyleBorderRightStyle` struct
#[pyclass(name = "StyleBorderRightStyle")]
pub struct AzStyleBorderRightStyle {
    #[pyo3(get, set)]
    pub inner: BorderStyle, 
}

/// `AzLayoutBorderRightWidth` struct
#[pyclass(name = "LayoutBorderRightWidth")]
pub struct AzLayoutBorderRightWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzStyleBorderTopColor` struct
#[pyclass(name = "StyleBorderTopColor")]
pub struct AzStyleBorderTopColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// `AzStyleBorderTopLeftRadius` struct
#[pyclass(name = "StyleBorderTopLeftRadius")]
pub struct AzStyleBorderTopLeftRadius {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzStyleBorderTopRightRadius` struct
#[pyclass(name = "StyleBorderTopRightRadius")]
pub struct AzStyleBorderTopRightRadius {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzStyleBorderTopStyle` struct
#[pyclass(name = "StyleBorderTopStyle")]
pub struct AzStyleBorderTopStyle {
    #[pyo3(get, set)]
    pub inner: BorderStyle, 
}

/// `AzLayoutBorderTopWidth` struct
#[pyclass(name = "LayoutBorderTopWidth")]
pub struct AzLayoutBorderTopWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Holds info necessary for layouting / styling -webkit-scrollbar properties.
#[pyclass(name = "ScrollbarInfo")]
pub struct AzScrollbarInfo {
    #[pyo3(get, set)]
    pub width: LayoutWidth, 
    #[pyo3(get, set)]
    pub padding_left: LayoutPaddingLeft, 
    #[pyo3(get, set)]
    pub padding_right: LayoutPaddingRight, 
    #[pyo3(get, set)]
    pub track: StyleBackgroundContent, 
    #[pyo3(get, set)]
    pub thumb: StyleBackgroundContent, 
    #[pyo3(get, set)]
    pub button: StyleBackgroundContent, 
    #[pyo3(get, set)]
    pub corner: StyleBackgroundContent, 
    #[pyo3(get, set)]
    pub resizer: StyleBackgroundContent, 
}

/// Scrollbar style for both horizontal and vertical scrollbars.
#[pyclass(name = "ScrollbarStyle")]
pub struct AzScrollbarStyle {
    #[pyo3(get, set)]
    pub horizontal: ScrollbarInfo, 
    #[pyo3(get, set)]
    pub vertical: ScrollbarInfo, 
}

/// Represents a `font-size` attribute
#[pyclass(name = "StyleFontSize")]
pub struct AzStyleFontSize {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Represents a `letter-spacing` attribute
#[pyclass(name = "StyleLetterSpacing")]
pub struct AzStyleLetterSpacing {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Represents a `line-height` attribute
#[pyclass(name = "StyleLineHeight")]
pub struct AzStyleLineHeight {
    #[pyo3(get, set)]
    pub inner: PercentageValue, 
}

/// Represents a `tab-width` attribute
#[pyclass(name = "StyleTabWidth")]
pub struct AzStyleTabWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Represents an `opacity` attribute, a value from 0.0 to 1.0.
#[pyclass(name = "StyleOpacity")]
pub struct AzStyleOpacity {
    #[pyo3(get, set)]
    pub inner: PercentageValue, 
}

/// Represents a `transform-origin` attribute
#[pyclass(name = "StyleTransformOrigin")]
pub struct AzStyleTransformOrigin {
    #[pyo3(get, set)]
    pub x: PixelValue, 
    #[pyo3(get, set)]
    pub y: PixelValue, 
}

/// `AzInterpolateResolver` struct
#[pyclass(name = "InterpolateResolver")]
pub struct AzInterpolateResolver {
    #[pyo3(get, set)]
    pub interpolate_func: AnimationInterpolationFunction, 
    #[pyo3(get, set)]
    pub parent_rect_width: f32, 
    #[pyo3(get, set)]
    pub parent_rect_height: f32, 
    #[pyo3(get, set)]
    pub current_rect_width: f32, 
    #[pyo3(get, set)]
    pub current_rect_height: f32, 
}

/// `AzStyleTransformMatrix2D` struct
#[pyclass(name = "StyleTransformMatrix2D")]
pub struct AzStyleTransformMatrix2D {
    #[pyo3(get, set)]
    pub a: FloatValue, 
    #[pyo3(get, set)]
    pub b: FloatValue, 
    #[pyo3(get, set)]
    pub c: FloatValue, 
    #[pyo3(get, set)]
    pub d: FloatValue, 
    #[pyo3(get, set)]
    pub tx: FloatValue, 
    #[pyo3(get, set)]
    pub ty: FloatValue, 
}

/// `AzStyleTransformMatrix3D` struct
#[pyclass(name = "StyleTransformMatrix3D")]
pub struct AzStyleTransformMatrix3D {
    #[pyo3(get, set)]
    pub m11: FloatValue, 
    #[pyo3(get, set)]
    pub m12: FloatValue, 
    #[pyo3(get, set)]
    pub m13: FloatValue, 
    #[pyo3(get, set)]
    pub m14: FloatValue, 
    #[pyo3(get, set)]
    pub m21: FloatValue, 
    #[pyo3(get, set)]
    pub m22: FloatValue, 
    #[pyo3(get, set)]
    pub m23: FloatValue, 
    #[pyo3(get, set)]
    pub m24: FloatValue, 
    #[pyo3(get, set)]
    pub m31: FloatValue, 
    #[pyo3(get, set)]
    pub m32: FloatValue, 
    #[pyo3(get, set)]
    pub m33: FloatValue, 
    #[pyo3(get, set)]
    pub m34: FloatValue, 
    #[pyo3(get, set)]
    pub m41: FloatValue, 
    #[pyo3(get, set)]
    pub m42: FloatValue, 
    #[pyo3(get, set)]
    pub m43: FloatValue, 
    #[pyo3(get, set)]
    pub m44: FloatValue, 
}

/// `AzStyleTransformTranslate2D` struct
#[pyclass(name = "StyleTransformTranslate2D")]
pub struct AzStyleTransformTranslate2D {
    #[pyo3(get, set)]
    pub x: PixelValue, 
    #[pyo3(get, set)]
    pub y: PixelValue, 
}

/// `AzStyleTransformTranslate3D` struct
#[pyclass(name = "StyleTransformTranslate3D")]
pub struct AzStyleTransformTranslate3D {
    #[pyo3(get, set)]
    pub x: PixelValue, 
    #[pyo3(get, set)]
    pub y: PixelValue, 
    #[pyo3(get, set)]
    pub z: PixelValue, 
}

/// `AzStyleTransformRotate3D` struct
#[pyclass(name = "StyleTransformRotate3D")]
pub struct AzStyleTransformRotate3D {
    #[pyo3(get, set)]
    pub x: FloatValue, 
    #[pyo3(get, set)]
    pub y: FloatValue, 
    #[pyo3(get, set)]
    pub z: FloatValue, 
    #[pyo3(get, set)]
    pub angle: AngleValue, 
}

/// `AzStyleTransformScale2D` struct
#[pyclass(name = "StyleTransformScale2D")]
pub struct AzStyleTransformScale2D {
    #[pyo3(get, set)]
    pub x: FloatValue, 
    #[pyo3(get, set)]
    pub y: FloatValue, 
}

/// `AzStyleTransformScale3D` struct
#[pyclass(name = "StyleTransformScale3D")]
pub struct AzStyleTransformScale3D {
    #[pyo3(get, set)]
    pub x: FloatValue, 
    #[pyo3(get, set)]
    pub y: FloatValue, 
    #[pyo3(get, set)]
    pub z: FloatValue, 
}

/// `AzStyleTransformSkew2D` struct
#[pyclass(name = "StyleTransformSkew2D")]
pub struct AzStyleTransformSkew2D {
    #[pyo3(get, set)]
    pub x: AngleValue, 
    #[pyo3(get, set)]
    pub y: AngleValue, 
}

/// Represents a `color` attribute.
#[pyclass(name = "StyleTextColor")]
pub struct AzStyleTextColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// Represents a `word-spacing` attribute
#[pyclass(name = "StyleWordSpacing")]
pub struct AzStyleWordSpacing {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzCounterReset` struct
#[pyclass(name = "CounterReset")]
pub struct AzCounterReset {
    #[pyo3(get, set)]
    pub inner: AzString, 
}

/// Represents a `perspective-origin` attribute
#[pyclass(name = "StylePerspectiveOrigin")]
pub struct AzStylePerspectiveOrigin {
    #[pyo3(get, set)]
    pub x: PixelValue, 
    #[pyo3(get, set)]
    pub y: PixelValue, 
}

/// `AzSelectionBackgroundColor` struct
#[pyclass(name = "SelectionBackgroundColor")]
pub struct AzSelectionBackgroundColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// `AzColumnRuleColor` struct
#[pyclass(name = "ColumnRuleColor")]
pub struct AzColumnRuleColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// Atomically reference-counted parsed font data
#[pyclass(name = "FontRef")]
pub struct AzFontRef {
    #[pyo3(get, set)]
    pub parsed: *const c_void, 
    #[pyo3(get, set)]
    pub copies: *const AtomicUsize, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
    #[pyo3(get, set)]
    pub parsed_destructor: fn(*mut c_void), 
}

/// Common system metrics for UI element sizing and spacing.
#[pyclass(name = "SystemMetrics")]
pub struct AzSystemMetrics {
    #[pyo3(get, set)]
    pub corner_radius: OptionPixelValue, 
    #[pyo3(get, set)]
    pub border_width: OptionPixelValue, 
}

/// A unified collection of discovered system style properties.
#[pyclass(name = "SystemStyle")]
pub struct AzSystemStyle {
    #[pyo3(get, set)]
    pub theme: Theme, 
    #[pyo3(get, set)]
    pub platform: Platform, 
    #[pyo3(get, set)]
    pub colors: SystemColors, 
    #[pyo3(get, set)]
    pub fonts: SystemFonts, 
    #[pyo3(get, set)]
    pub metrics: SystemMetrics, 
    #[pyo3(get, set)]
    pub scrollbar: OptionComputedScrollbarStyle, 
    #[pyo3(get, set)]
    pub app_specific_stylesheet: *const c_void, 
}

/// `AzFontMetrics` struct
#[pyclass(name = "FontMetrics")]
pub struct AzFontMetrics {
    #[pyo3(get, set)]
    pub units_per_em: u16, 
    #[pyo3(get, set)]
    pub font_flags: u16, 
    #[pyo3(get, set)]
    pub x_min: i16, 
    #[pyo3(get, set)]
    pub y_min: i16, 
    #[pyo3(get, set)]
    pub x_max: i16, 
    #[pyo3(get, set)]
    pub y_max: i16, 
    #[pyo3(get, set)]
    pub ascender: i16, 
    #[pyo3(get, set)]
    pub descender: i16, 
    #[pyo3(get, set)]
    pub line_gap: i16, 
    #[pyo3(get, set)]
    pub advance_width_max: u16, 
    #[pyo3(get, set)]
    pub min_left_side_bearing: i16, 
    #[pyo3(get, set)]
    pub min_right_side_bearing: i16, 
    #[pyo3(get, set)]
    pub x_max_extent: i16, 
    #[pyo3(get, set)]
    pub caret_slope_rise: i16, 
    #[pyo3(get, set)]
    pub caret_slope_run: i16, 
    #[pyo3(get, set)]
    pub caret_offset: i16, 
    #[pyo3(get, set)]
    pub num_h_metrics: u16, 
    #[pyo3(get, set)]
    pub x_avg_char_width: i16, 
    #[pyo3(get, set)]
    pub us_weight_class: u16, 
    #[pyo3(get, set)]
    pub us_width_class: u16, 
    #[pyo3(get, set)]
    pub fs_type: u16, 
    #[pyo3(get, set)]
    pub y_subscript_x_size: i16, 
    #[pyo3(get, set)]
    pub y_subscript_y_size: i16, 
    #[pyo3(get, set)]
    pub y_subscript_x_offset: i16, 
    #[pyo3(get, set)]
    pub y_subscript_y_offset: i16, 
    #[pyo3(get, set)]
    pub y_superscript_x_size: i16, 
    #[pyo3(get, set)]
    pub y_superscript_y_size: i16, 
    #[pyo3(get, set)]
    pub y_superscript_x_offset: i16, 
    #[pyo3(get, set)]
    pub y_superscript_y_offset: i16, 
    #[pyo3(get, set)]
    pub y_strikeout_size: i16, 
    #[pyo3(get, set)]
    pub y_strikeout_position: i16, 
    #[pyo3(get, set)]
    pub s_family_class: i16, 
    #[pyo3(get, set)]
    pub panose: [u8;10], 
    #[pyo3(get, set)]
    pub ul_unicode_range1: u32, 
    #[pyo3(get, set)]
    pub ul_unicode_range2: u32, 
    #[pyo3(get, set)]
    pub ul_unicode_range3: u32, 
    #[pyo3(get, set)]
    pub ul_unicode_range4: u32, 
    #[pyo3(get, set)]
    pub ach_vend_id: u32, 
    #[pyo3(get, set)]
    pub fs_selection: u16, 
    #[pyo3(get, set)]
    pub us_first_char_index: u16, 
    #[pyo3(get, set)]
    pub us_last_char_index: u16, 
    #[pyo3(get, set)]
    pub s_typo_ascender: OptionI16, 
    #[pyo3(get, set)]
    pub s_typo_descender: OptionI16, 
    #[pyo3(get, set)]
    pub s_typo_line_gap: OptionI16, 
    #[pyo3(get, set)]
    pub us_win_ascent: OptionU16, 
    #[pyo3(get, set)]
    pub us_win_descent: OptionU16, 
    #[pyo3(get, set)]
    pub ul_code_page_range1: OptionU32, 
    #[pyo3(get, set)]
    pub ul_code_page_range2: OptionU32, 
    #[pyo3(get, set)]
    pub sx_height: OptionI16, 
    #[pyo3(get, set)]
    pub s_cap_height: OptionI16, 
    #[pyo3(get, set)]
    pub us_default_char: OptionU16, 
    #[pyo3(get, set)]
    pub us_break_char: OptionU16, 
    #[pyo3(get, set)]
    pub us_max_context: OptionU16, 
    #[pyo3(get, set)]
    pub us_lower_optical_point_size: OptionU16, 
    #[pyo3(get, set)]
    pub us_upper_optical_point_size: OptionU16, 
}

/// `AzCaretAnimationDuration` struct
#[pyclass(name = "CaretAnimationDuration")]
pub struct AzCaretAnimationDuration {
    #[pyo3(get, set)]
    pub inner: Duration, 
}

/// `AzColumnRuleStyle` struct
#[pyclass(name = "ColumnRuleStyle")]
pub struct AzColumnRuleStyle {
    #[pyo3(get, set)]
    pub inner: BorderStyle, 
}

/// `AzSvgPoint` struct
#[pyclass(name = "SvgPoint")]
pub struct AzSvgPoint {
    #[pyo3(get, set)]
    pub x: f32, 
    #[pyo3(get, set)]
    pub y: f32, 
}

/// Represents `grid-row` or `grid-column` (start / end)
#[pyclass(name = "GridPlacement")]
pub struct AzGridPlacement {
    #[pyo3(get, set)]
    pub start: GridLine, 
    #[pyo3(get, set)]
    pub end: GridLine, 
}

/// `AzStringSet` struct
#[pyclass(name = "StringSet")]
pub struct AzStringSet {
    #[pyo3(get, set)]
    pub inner: AzString, 
}

/// `AzSvgVector` struct
#[pyclass(name = "SvgVector")]
pub struct AzSvgVector {
    #[pyo3(get, set)]
    pub x: f64, 
    #[pyo3(get, set)]
    pub y: f64, 
}

/// `AzSvgRect` struct
#[pyclass(name = "SvgRect")]
pub struct AzSvgRect {
    #[pyo3(get, set)]
    pub width: f32, 
    #[pyo3(get, set)]
    pub height: f32, 
    #[pyo3(get, set)]
    pub x: f32, 
    #[pyo3(get, set)]
    pub y: f32, 
    #[pyo3(get, set)]
    pub radius_top_left: f32, 
    #[pyo3(get, set)]
    pub radius_top_right: f32, 
    #[pyo3(get, set)]
    pub radius_bottom_left: f32, 
    #[pyo3(get, set)]
    pub radius_bottom_right: f32, 
}

/// Common system colors used for UI elements.
#[pyclass(name = "SystemColors")]
pub struct AzSystemColors {
    #[pyo3(get, set)]
    pub text: OptionColorU, 
    #[pyo3(get, set)]
    pub background: OptionColorU, 
    #[pyo3(get, set)]
    pub accent: OptionColorU, 
    #[pyo3(get, set)]
    pub accent_text: OptionColorU, 
    #[pyo3(get, set)]
    pub button_face: OptionColorU, 
    #[pyo3(get, set)]
    pub button_text: OptionColorU, 
    #[pyo3(get, set)]
    pub window_background: OptionColorU, 
    #[pyo3(get, set)]
    pub selection_background: OptionColorU, 
    #[pyo3(get, set)]
    pub selection_text: OptionColorU, 
}

/// Represents `grid-template-columns` or `grid-template-rows`
#[pyclass(name = "GridTemplate")]
pub struct AzGridTemplate {
    #[pyo3(get, set)]
    pub tracks: GridTrackSizingVec, 
}

/// `AzContent` struct
#[pyclass(name = "Content")]
pub struct AzContent {
    #[pyo3(get, set)]
    pub inner: AzString, 
}

/// `AzLayoutGap` struct
#[pyclass(name = "LayoutGap")]
pub struct AzLayoutGap {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzShapeMargin` struct
#[pyclass(name = "ShapeMargin")]
pub struct AzShapeMargin {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzCounterIncrement` struct
#[pyclass(name = "CounterIncrement")]
pub struct AzCounterIncrement {
    #[pyo3(get, set)]
    pub inner: AzString, 
}

/// `AzSvgCubicCurve` struct
#[pyclass(name = "SvgCubicCurve")]
pub struct AzSvgCubicCurve {
    #[pyo3(get, set)]
    pub start: SvgPoint, 
    #[pyo3(get, set)]
    pub ctrl_1: SvgPoint, 
    #[pyo3(get, set)]
    pub ctrl_2: SvgPoint, 
    #[pyo3(get, set)]
    pub end: SvgPoint, 
}

/// `AzSvgQuadraticCurve` struct
#[pyclass(name = "SvgQuadraticCurve")]
pub struct AzSvgQuadraticCurve {
    #[pyo3(get, set)]
    pub start: SvgPoint, 
    #[pyo3(get, set)]
    pub ctrl: SvgPoint, 
    #[pyo3(get, set)]
    pub end: SvgPoint, 
}

/// `AzSelectionColor` struct
#[pyclass(name = "SelectionColor")]
pub struct AzSelectionColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// `AzShapeImageThreshold` struct
#[pyclass(name = "ShapeImageThreshold")]
pub struct AzShapeImageThreshold {
    #[pyo3(get, set)]
    pub inner: FloatValue, 
}

/// `AzColumnRuleWidth` struct
#[pyclass(name = "ColumnRuleWidth")]
pub struct AzColumnRuleWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzAzString` struct
#[pyclass(name = "AzString")]
pub struct AzAzString {
    #[pyo3(get, set)]
    pub vec: U8Vec, 
}

/// `AzCaretColor` struct
#[pyclass(name = "CaretColor")]
pub struct AzCaretColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// Common system font settings.
#[pyclass(name = "SystemFonts")]
pub struct AzSystemFonts {
    #[pyo3(get, set)]
    pub ui_font: OptionAzString, 
    #[pyo3(get, set)]
    pub ui_font_size: OptionF32, 
    #[pyo3(get, set)]
    pub monospace_font: OptionAzString, 
}

/// `AzRibbon` struct
#[pyclass(name = "Ribbon")]
pub struct AzRibbon {
    #[pyo3(get, set)]
    pub tab_active: i32, 
}

/// `AzRibbonOnTabClickedCallback` struct
#[pyclass(name = "RibbonOnTabClickedCallback")]
pub struct AzRibbonOnTabClickedCallback {
}

/// `AzButton` struct
#[pyclass(name = "Button")]
pub struct AzButton {
    #[pyo3(get, set)]
    pub label: AzString, 
    #[pyo3(get, set)]
    pub image: OptionImageRef, 
    #[pyo3(get, set)]
    pub container_style: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub label_style: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub image_style: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub on_click: OptionButtonOnClick, 
}

/// `AzButtonOnClick` struct
#[pyclass(name = "ButtonOnClick")]
pub struct AzButtonOnClick {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: Callback, 
}

/// `AzFileInput` struct
#[pyclass(name = "FileInput")]
pub struct AzFileInput {
    #[pyo3(get, set)]
    pub state: FileInputStateWrapper, 
    #[pyo3(get, set)]
    pub default_text: AzString, 
    #[pyo3(get, set)]
    pub image: OptionImageRef, 
    #[pyo3(get, set)]
    pub container_style: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub label_style: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub image_style: NodeDataInlineCssPropertyVec, 
}

/// `AzFileInputStateWrapper` struct
#[pyclass(name = "FileInputStateWrapper")]
pub struct AzFileInputStateWrapper {
    #[pyo3(get, set)]
    pub inner: FileInputState, 
    #[pyo3(get, set)]
    pub on_path_change: OptionFileInputOnPathChange, 
    #[pyo3(get, set)]
    pub file_dialog_title: AzString, 
    #[pyo3(get, set)]
    pub default_dir: OptionAzString, 
    #[pyo3(get, set)]
    pub file_types: OptionFileTypeList, 
}

/// `AzFileInputState` struct
#[pyclass(name = "FileInputState")]
pub struct AzFileInputState {
    #[pyo3(get, set)]
    pub path: OptionAzString, 
}

/// `AzFileInputOnPathChange` struct
#[pyclass(name = "FileInputOnPathChange")]
pub struct AzFileInputOnPathChange {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: FileInputOnPathChangeCallback, 
}

/// `AzFileInputOnPathChangeCallback` struct
#[pyclass(name = "FileInputOnPathChangeCallback")]
pub struct AzFileInputOnPathChangeCallback {
}

/// `AzCheckBox` struct
#[pyclass(name = "CheckBox")]
pub struct AzCheckBox {
    #[pyo3(get, set)]
    pub state: CheckBoxStateWrapper, 
    #[pyo3(get, set)]
    pub container_style: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub content_style: NodeDataInlineCssPropertyVec, 
}

/// `AzCheckBoxStateWrapper` struct
#[pyclass(name = "CheckBoxStateWrapper")]
pub struct AzCheckBoxStateWrapper {
    #[pyo3(get, set)]
    pub inner: CheckBoxState, 
    #[pyo3(get, set)]
    pub on_toggle: OptionCheckBoxOnToggle, 
}

/// `AzCheckBoxOnToggle` struct
#[pyclass(name = "CheckBoxOnToggle")]
pub struct AzCheckBoxOnToggle {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: CheckBoxOnToggleCallback, 
}

/// `AzCheckBoxOnToggleCallback` struct
#[pyclass(name = "CheckBoxOnToggleCallback")]
pub struct AzCheckBoxOnToggleCallback {
}

/// `AzCheckBoxState` struct
#[pyclass(name = "CheckBoxState")]
pub struct AzCheckBoxState {
    #[pyo3(get, set)]
    pub checked: bool, 
}

/// `AzLabel` struct
#[pyclass(name = "Label")]
pub struct AzLabel {
    #[pyo3(get, set)]
    pub string: AzString, 
    #[pyo3(get, set)]
    pub label_style: NodeDataInlineCssPropertyVec, 
}

/// `AzColorInput` struct
#[pyclass(name = "ColorInput")]
pub struct AzColorInput {
    #[pyo3(get, set)]
    pub state: ColorInputStateWrapper, 
    #[pyo3(get, set)]
    pub style: NodeDataInlineCssPropertyVec, 
}

/// `AzColorInputStateWrapper` struct
#[pyclass(name = "ColorInputStateWrapper")]
pub struct AzColorInputStateWrapper {
    #[pyo3(get, set)]
    pub inner: ColorInputState, 
    #[pyo3(get, set)]
    pub title: AzString, 
    #[pyo3(get, set)]
    pub on_value_change: OptionColorInputOnValueChange, 
}

/// `AzColorInputState` struct
#[pyclass(name = "ColorInputState")]
pub struct AzColorInputState {
    #[pyo3(get, set)]
    pub color: ColorU, 
}

/// `AzColorInputOnValueChange` struct
#[pyclass(name = "ColorInputOnValueChange")]
pub struct AzColorInputOnValueChange {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: ColorInputOnValueChangeCallback, 
}

/// `AzColorInputOnValueChangeCallback` struct
#[pyclass(name = "ColorInputOnValueChangeCallback")]
pub struct AzColorInputOnValueChangeCallback {
}

/// `AzTextInput` struct
#[pyclass(name = "TextInput")]
pub struct AzTextInput {
    #[pyo3(get, set)]
    pub state: TextInputStateWrapper, 
    #[pyo3(get, set)]
    pub placeholder_style: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub container_style: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub label_style: NodeDataInlineCssPropertyVec, 
}

/// `AzTextInputStateWrapper` struct
#[pyclass(name = "TextInputStateWrapper")]
pub struct AzTextInputStateWrapper {
    #[pyo3(get, set)]
    pub inner: TextInputState, 
    #[pyo3(get, set)]
    pub on_text_input: OptionTextInputOnTextInput, 
    #[pyo3(get, set)]
    pub on_virtual_key_down: OptionTextInputOnVirtualKeyDown, 
    #[pyo3(get, set)]
    pub on_focus_lost: OptionTextInputOnFocusLost, 
    #[pyo3(get, set)]
    pub update_text_input_before_calling_focus_lost_fn: bool, 
    #[pyo3(get, set)]
    pub update_text_input_before_calling_vk_down_fn: bool, 
    #[pyo3(get, set)]
    pub cursor_animation: OptionTimerId, 
}

/// `AzTextInputState` struct
#[pyclass(name = "TextInputState")]
pub struct AzTextInputState {
    #[pyo3(get, set)]
    pub text: U32Vec, 
    #[pyo3(get, set)]
    pub placeholder: OptionAzString, 
    #[pyo3(get, set)]
    pub max_len: usize, 
    #[pyo3(get, set)]
    pub selection: OptionTextInputSelection, 
    #[pyo3(get, set)]
    pub cursor_pos: usize, 
}

/// `AzTextInputSelectionRange` struct
#[pyclass(name = "TextInputSelectionRange")]
pub struct AzTextInputSelectionRange {
    #[pyo3(get, set)]
    pub from: usize, 
    #[pyo3(get, set)]
    pub to: usize, 
}

/// `AzTextInputOnTextInput` struct
#[pyclass(name = "TextInputOnTextInput")]
pub struct AzTextInputOnTextInput {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: TextInputOnTextInputCallback, 
}

/// `AzTextInputOnTextInputCallback` struct
#[pyclass(name = "TextInputOnTextInputCallback")]
pub struct AzTextInputOnTextInputCallback {
}

/// `AzTextInputOnVirtualKeyDown` struct
#[pyclass(name = "TextInputOnVirtualKeyDown")]
pub struct AzTextInputOnVirtualKeyDown {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: TextInputOnVirtualKeyDownCallback, 
}

/// `AzTextInputOnVirtualKeyDownCallback` struct
#[pyclass(name = "TextInputOnVirtualKeyDownCallback")]
pub struct AzTextInputOnVirtualKeyDownCallback {
}

/// `AzTextInputOnFocusLost` struct
#[pyclass(name = "TextInputOnFocusLost")]
pub struct AzTextInputOnFocusLost {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: TextInputOnFocusLostCallback, 
}

/// `AzTextInputOnFocusLostCallback` struct
#[pyclass(name = "TextInputOnFocusLostCallback")]
pub struct AzTextInputOnFocusLostCallback {
}

/// `AzOnTextInputReturn` struct
#[pyclass(name = "OnTextInputReturn")]
pub struct AzOnTextInputReturn {
    #[pyo3(get, set)]
    pub update: Update, 
    #[pyo3(get, set)]
    pub valid: TextInputValid, 
}

/// `AzNumberInput` struct
#[pyclass(name = "NumberInput")]
pub struct AzNumberInput {
    #[pyo3(get, set)]
    pub text_input: TextInput, 
    #[pyo3(get, set)]
    pub state: NumberInputStateWrapper, 
}

/// `AzNumberInputStateWrapper` struct
#[pyclass(name = "NumberInputStateWrapper")]
pub struct AzNumberInputStateWrapper {
    #[pyo3(get, set)]
    pub inner: NumberInputState, 
    #[pyo3(get, set)]
    pub on_value_change: OptionNumberInputOnValueChange, 
    #[pyo3(get, set)]
    pub on_focus_lost: OptionNumberInputOnFocusLost, 
}

/// `AzNumberInputState` struct
#[pyclass(name = "NumberInputState")]
pub struct AzNumberInputState {
    #[pyo3(get, set)]
    pub previous: f32, 
    #[pyo3(get, set)]
    pub number: f32, 
    #[pyo3(get, set)]
    pub min: f32, 
    #[pyo3(get, set)]
    pub max: f32, 
}

/// `AzNumberInputOnValueChange` struct
#[pyclass(name = "NumberInputOnValueChange")]
pub struct AzNumberInputOnValueChange {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: NumberInputOnValueChangeCallback, 
}

/// `AzNumberInputOnValueChangeCallback` struct
#[pyclass(name = "NumberInputOnValueChangeCallback")]
pub struct AzNumberInputOnValueChangeCallback {
}

/// `AzNumberInputOnFocusLost` struct
#[pyclass(name = "NumberInputOnFocusLost")]
pub struct AzNumberInputOnFocusLost {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: NumberInputOnFocusLostCallback, 
}

/// `AzNumberInputOnFocusLostCallback` struct
#[pyclass(name = "NumberInputOnFocusLostCallback")]
pub struct AzNumberInputOnFocusLostCallback {
}

/// `AzProgressBar` struct
#[pyclass(name = "ProgressBar")]
pub struct AzProgressBar {
    #[pyo3(get, set)]
    pub state: ProgressBarState, 
    #[pyo3(get, set)]
    pub height: PixelValue, 
    #[pyo3(get, set)]
    pub bar_background: StyleBackgroundContentVec, 
    #[pyo3(get, set)]
    pub container_background: StyleBackgroundContentVec, 
}

/// `AzProgressBarState` struct
#[pyclass(name = "ProgressBarState")]
pub struct AzProgressBarState {
    #[pyo3(get, set)]
    pub percent_done: f32, 
    #[pyo3(get, set)]
    pub display_percentage: bool, 
}

/// `AzTabHeader` struct
#[pyclass(name = "TabHeader")]
pub struct AzTabHeader {
    #[pyo3(get, set)]
    pub tabs: StringVec, 
    #[pyo3(get, set)]
    pub active_tab: usize, 
    #[pyo3(get, set)]
    pub on_click: OptionTabOnClick, 
}

/// `AzTabHeaderState` struct
#[pyclass(name = "TabHeaderState")]
pub struct AzTabHeaderState {
    #[pyo3(get, set)]
    pub active_tab: usize, 
}

/// `AzTabContent` struct
#[pyclass(name = "TabContent")]
pub struct AzTabContent {
    #[pyo3(get, set)]
    pub content: Dom, 
    #[pyo3(get, set)]
    pub has_padding: bool, 
}

/// `AzTabOnClick` struct
#[pyclass(name = "TabOnClick")]
pub struct AzTabOnClick {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: TabOnClickCallback, 
}

/// `AzTabOnClickCallback` struct
#[pyclass(name = "TabOnClickCallback")]
pub struct AzTabOnClickCallback {
}

/// `AzFrame` struct
#[pyclass(name = "Frame")]
pub struct AzFrame {
    #[pyo3(get, set)]
    pub title: AzString, 
    #[pyo3(get, set)]
    pub flex_grow: f32, 
    #[pyo3(get, set)]
    pub content: Dom, 
}

/// Same as the NodeGraph but without generics and without the actual data
#[pyclass(name = "NodeGraph")]
pub struct AzNodeGraph {
    #[pyo3(get, set)]
    pub node_types: NodeTypeIdInfoMapVec, 
    #[pyo3(get, set)]
    pub input_output_types: InputOutputTypeIdInfoMapVec, 
    #[pyo3(get, set)]
    pub nodes: NodeIdNodeMapVec, 
    #[pyo3(get, set)]
    pub allow_multiple_root_nodes: bool, 
    #[pyo3(get, set)]
    pub offset: LogicalPosition, 
    #[pyo3(get, set)]
    pub style: NodeGraphStyle, 
    #[pyo3(get, set)]
    pub callbacks: NodeGraphCallbacks, 
    #[pyo3(get, set)]
    pub add_node_str: AzString, 
    #[pyo3(get, set)]
    pub scale_factor: f32, 
}

/// `AzNodeTypeIdInfoMap` struct
#[pyclass(name = "NodeTypeIdInfoMap")]
pub struct AzNodeTypeIdInfoMap {
    #[pyo3(get, set)]
    pub node_type_id: NodeTypeId, 
    #[pyo3(get, set)]
    pub node_type_info: NodeTypeInfo, 
}

/// `AzInputOutputTypeIdInfoMap` struct
#[pyclass(name = "InputOutputTypeIdInfoMap")]
pub struct AzInputOutputTypeIdInfoMap {
    #[pyo3(get, set)]
    pub io_type_id: InputOutputTypeId, 
    #[pyo3(get, set)]
    pub io_info: InputOutputInfo, 
}

/// `AzNodeIdNodeMap` struct
#[pyclass(name = "NodeIdNodeMap")]
pub struct AzNodeIdNodeMap {
    #[pyo3(get, set)]
    pub node_id: NodeGraphNodeId, 
    #[pyo3(get, set)]
    pub node: Node, 
}

/// `AzNodeGraphCallbacks` struct
#[pyclass(name = "NodeGraphCallbacks")]
pub struct AzNodeGraphCallbacks {
    #[pyo3(get, set)]
    pub on_node_added: OptionOnNodeAdded, 
    #[pyo3(get, set)]
    pub on_node_removed: OptionOnNodeRemoved, 
    #[pyo3(get, set)]
    pub on_node_dragged: OptionOnNodeDragged, 
    #[pyo3(get, set)]
    pub on_node_graph_dragged: OptionOnNodeGraphDragged, 
    #[pyo3(get, set)]
    pub on_node_connected: OptionOnNodeConnected, 
    #[pyo3(get, set)]
    pub on_node_input_disconnected: OptionOnNodeInputDisconnected, 
    #[pyo3(get, set)]
    pub on_node_output_disconnected: OptionOnNodeOutputDisconnected, 
    #[pyo3(get, set)]
    pub on_node_field_edited: OptionOnNodeFieldEdited, 
}

/// `AzDropDownOnChoiceChange` struct
#[pyclass(name = "DropDownOnChoiceChange")]
pub struct AzDropDownOnChoiceChange {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: DropDownOnChoiceChangeCallback, 
}

/// `AzOnNodeAddedCallback` struct
#[pyclass(name = "OnNodeAddedCallback")]
pub struct AzOnNodeAddedCallback {
}

/// `AzOnNodeAdded` struct
#[pyclass(name = "OnNodeAdded")]
pub struct AzOnNodeAdded {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: OnNodeAddedCallback, 
}

/// `AzOnNodeRemovedCallback` struct
#[pyclass(name = "OnNodeRemovedCallback")]
pub struct AzOnNodeRemovedCallback {
}

/// `AzOnNodeRemoved` struct
#[pyclass(name = "OnNodeRemoved")]
pub struct AzOnNodeRemoved {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: OnNodeRemovedCallback, 
}

/// `AzOnNodeGraphDraggedCallback` struct
#[pyclass(name = "OnNodeGraphDraggedCallback")]
pub struct AzOnNodeGraphDraggedCallback {
}

/// `AzOnNodeGraphDragged` struct
#[pyclass(name = "OnNodeGraphDragged")]
pub struct AzOnNodeGraphDragged {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: OnNodeGraphDraggedCallback, 
}

/// `AzOnNodeDraggedCallback` struct
#[pyclass(name = "OnNodeDraggedCallback")]
pub struct AzOnNodeDraggedCallback {
}

/// `AzOnNodeDragged` struct
#[pyclass(name = "OnNodeDragged")]
pub struct AzOnNodeDragged {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: OnNodeDraggedCallback, 
}

/// `AzOnNodeConnectedCallback` struct
#[pyclass(name = "OnNodeConnectedCallback")]
pub struct AzOnNodeConnectedCallback {
}

/// `AzOnNodeConnected` struct
#[pyclass(name = "OnNodeConnected")]
pub struct AzOnNodeConnected {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: OnNodeConnectedCallback, 
}

/// `AzOnNodeInputDisconnectedCallback` struct
#[pyclass(name = "OnNodeInputDisconnectedCallback")]
pub struct AzOnNodeInputDisconnectedCallback {
}

/// `AzOnNodeInputDisconnected` struct
#[pyclass(name = "OnNodeInputDisconnected")]
pub struct AzOnNodeInputDisconnected {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: OnNodeInputDisconnectedCallback, 
}

/// `AzOnNodeOutputDisconnectedCallback` struct
#[pyclass(name = "OnNodeOutputDisconnectedCallback")]
pub struct AzOnNodeOutputDisconnectedCallback {
}

/// `AzOnNodeOutputDisconnected` struct
#[pyclass(name = "OnNodeOutputDisconnected")]
pub struct AzOnNodeOutputDisconnected {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: OnNodeOutputDisconnectedCallback, 
}

/// `AzOnNodeFieldEditedCallback` struct
#[pyclass(name = "OnNodeFieldEditedCallback")]
pub struct AzOnNodeFieldEditedCallback {
}

/// `AzInputOutputTypeId` struct
#[pyclass(name = "InputOutputTypeId")]
pub struct AzInputOutputTypeId {
    #[pyo3(get, set)]
    pub inner: u64, 
}

/// `AzNodeTypeId` struct
#[pyclass(name = "NodeTypeId")]
pub struct AzNodeTypeId {
    #[pyo3(get, set)]
    pub inner: u64, 
}

/// `AzNodeGraphNodeId` struct
#[pyclass(name = "NodeGraphNodeId")]
pub struct AzNodeGraphNodeId {
    #[pyo3(get, set)]
    pub inner: u64, 
}

/// `AzNode` struct
#[pyclass(name = "Node")]
pub struct AzNode {
    #[pyo3(get, set)]
    pub parent: OptionNodeId, 
    #[pyo3(get, set)]
    pub previous_sibling: OptionNodeId, 
    #[pyo3(get, set)]
    pub next_sibling: OptionNodeId, 
    #[pyo3(get, set)]
    pub last_child: OptionNodeId, 
}

/// `AzNodeTypeField` struct
#[pyclass(name = "NodeTypeField")]
pub struct AzNodeTypeField {
    #[pyo3(get, set)]
    pub key: AzString, 
    #[pyo3(get, set)]
    pub value: NodeTypeFieldValue, 
}

/// `AzInputConnection` struct
#[pyclass(name = "InputConnection")]
pub struct AzInputConnection {
    #[pyo3(get, set)]
    pub input_index: usize, 
    #[pyo3(get, set)]
    pub connects_to: OutputNodeAndIndexVec, 
}

/// `AzOutputNodeAndIndex` struct
#[pyclass(name = "OutputNodeAndIndex")]
pub struct AzOutputNodeAndIndex {
    #[pyo3(get, set)]
    pub node_id: NodeGraphNodeId, 
    #[pyo3(get, set)]
    pub output_index: usize, 
}

/// `AzOutputConnection` struct
#[pyclass(name = "OutputConnection")]
pub struct AzOutputConnection {
    #[pyo3(get, set)]
    pub output_index: usize, 
    #[pyo3(get, set)]
    pub connects_to: InputNodeAndIndexVec, 
}

/// `AzInputNodeAndIndex` struct
#[pyclass(name = "InputNodeAndIndex")]
pub struct AzInputNodeAndIndex {
    #[pyo3(get, set)]
    pub node_id: NodeGraphNodeId, 
    #[pyo3(get, set)]
    pub input_index: usize, 
}

/// `AzNodeTypeInfo` struct
#[pyclass(name = "NodeTypeInfo")]
pub struct AzNodeTypeInfo {
    #[pyo3(get, set)]
    pub is_root: bool, 
    #[pyo3(get, set)]
    pub name: AzString, 
    #[pyo3(get, set)]
    pub inputs: InputOutputTypeIdVec, 
    #[pyo3(get, set)]
    pub outputs: InputOutputTypeIdVec, 
}

/// `AzInputOutputInfo` struct
#[pyclass(name = "InputOutputInfo")]
pub struct AzInputOutputInfo {
    #[pyo3(get, set)]
    pub data_type: AzString, 
    #[pyo3(get, set)]
    pub color: ColorU, 
}

/// Things only relevant to the display of the node in an interactive editor - such as x and y position in the node graph, name, etc.
#[pyclass(name = "NodePosition")]
pub struct AzNodePosition {
    #[pyo3(get, set)]
    pub x: f32, 
    #[pyo3(get, set)]
    pub y: f32, 
}

/// `AzGraphDragAmount` struct
#[pyclass(name = "GraphDragAmount")]
pub struct AzGraphDragAmount {
    #[pyo3(get, set)]
    pub x: f32, 
    #[pyo3(get, set)]
    pub y: f32, 
}

/// `AzNodeDragAmount` struct
#[pyclass(name = "NodeDragAmount")]
pub struct AzNodeDragAmount {
    #[pyo3(get, set)]
    pub x: f32, 
    #[pyo3(get, set)]
    pub y: f32, 
}

/// List view, optionally able to lazy-load data
#[pyclass(name = "ListView")]
pub struct AzListView {
    #[pyo3(get, set)]
    pub columns: StringVec, 
    #[pyo3(get, set)]
    pub rows: ListViewRowVec, 
    #[pyo3(get, set)]
    pub sorted_by: OptionUsize, 
    #[pyo3(get, set)]
    pub scroll_offset: PixelValueNoPercent, 
    #[pyo3(get, set)]
    pub content_height: OptionPixelValueNoPercent, 
    #[pyo3(get, set)]
    pub column_context_menu: OptionMenu, 
    #[pyo3(get, set)]
    pub on_lazy_load_scroll: OptionListViewOnLazyLoadScroll, 
    #[pyo3(get, set)]
    pub on_column_click: OptionListViewOnColumnClick, 
    #[pyo3(get, set)]
    pub on_row_click: OptionListViewOnRowClick, 
}

/// Row of the ListView
#[pyclass(name = "ListViewRow")]
pub struct AzListViewRow {
    #[pyo3(get, set)]
    pub cells: DomVec, 
    #[pyo3(get, set)]
    pub height: OptionPixelValueNoPercent, 
}

/// State of the ListView, but without row data
#[pyclass(name = "ListViewState")]
pub struct AzListViewState {
    #[pyo3(get, set)]
    pub columns: StringVec, 
    #[pyo3(get, set)]
    pub sorted_by: OptionUsize, 
    #[pyo3(get, set)]
    pub current_row_count: usize, 
    #[pyo3(get, set)]
    pub scroll_offset: PixelValueNoPercent, 
    #[pyo3(get, set)]
    pub current_scroll_position: LogicalPosition, 
    #[pyo3(get, set)]
    pub current_content_height: LogicalSize, 
}

/// `AzListViewOnLazyLoadScrollCallback` struct
#[pyclass(name = "ListViewOnLazyLoadScrollCallback")]
pub struct AzListViewOnLazyLoadScrollCallback {
}

/// `AzListViewOnLazyLoadScroll` struct
#[pyclass(name = "ListViewOnLazyLoadScroll")]
pub struct AzListViewOnLazyLoadScroll {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: ListViewOnLazyLoadScrollCallback, 
}

/// `AzListViewOnColumnClickCallback` struct
#[pyclass(name = "ListViewOnColumnClickCallback")]
pub struct AzListViewOnColumnClickCallback {
}

/// `AzListViewOnColumnClick` struct
#[pyclass(name = "ListViewOnColumnClick")]
pub struct AzListViewOnColumnClick {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: ListViewOnColumnClickCallback, 
}

/// `AzListViewOnRowClickCallback` struct
#[pyclass(name = "ListViewOnRowClickCallback")]
pub struct AzListViewOnRowClickCallback {
}

/// `AzListViewOnRowClick` struct
#[pyclass(name = "ListViewOnRowClick")]
pub struct AzListViewOnRowClick {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: ListViewOnRowClickCallback, 
}

/// `AzTreeView` struct
#[pyclass(name = "TreeView")]
pub struct AzTreeView {
    #[pyo3(get, set)]
    pub root: AzString, 
}

/// `AzDropDown` struct
#[pyclass(name = "DropDown")]
pub struct AzDropDown {
    #[pyo3(get, set)]
    pub choices: StringVec, 
    #[pyo3(get, set)]
    pub selected: usize, 
    #[pyo3(get, set)]
    pub on_choice_change: OptionDropDownOnChoiceChange, 
}

/// `AzDropDownOnChoiceChangeCallback` struct
#[pyclass(name = "DropDownOnChoiceChangeCallback")]
pub struct AzDropDownOnChoiceChangeCallback {
}

/// `AzOnNodeFieldEdited` struct
#[pyclass(name = "OnNodeFieldEdited")]
pub struct AzOnNodeFieldEdited {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: OnNodeFieldEditedCallback, 
}

/// `AzNodeHierarchyItem` struct
#[pyclass(name = "NodeHierarchyItem")]
pub struct AzNodeHierarchyItem {
    #[pyo3(get, set)]
    pub parent: usize, 
    #[pyo3(get, set)]
    pub previous_sibling: usize, 
    #[pyo3(get, set)]
    pub next_sibling: usize, 
    #[pyo3(get, set)]
    pub last_child: usize, 
}

/// Has all the necessary information about the style CSS path
#[pyclass(name = "CascadeInfo")]
pub struct AzCascadeInfo {
    #[pyo3(get, set)]
    pub index_in_parent: u32, 
    #[pyo3(get, set)]
    pub is_last_child: bool, 
}

/// `AzStyledNodeState` struct
#[pyclass(name = "StyledNodeState")]
pub struct AzStyledNodeState {
    #[pyo3(get, set)]
    pub normal: bool, 
    #[pyo3(get, set)]
    pub hover: bool, 
    #[pyo3(get, set)]
    pub active: bool, 
    #[pyo3(get, set)]
    pub focused: bool, 
}

/// `AzStyledNode` struct
#[pyclass(name = "StyledNode")]
pub struct AzStyledNode {
    #[pyo3(get, set)]
    pub state: StyledNodeState, 
    #[pyo3(get, set)]
    pub tag_id: OptionTagId, 
}

/// `AzStyledDom` struct
#[pyclass(name = "StyledDom")]
pub struct AzStyledDom {
    #[pyo3(get, set)]
    pub root: NodeHierarchyItemId, 
    #[pyo3(get, set)]
    pub node_hierarchy: NodeHierarchyItemVec, 
    #[pyo3(get, set)]
    pub node_data: NodeDataVec, 
    #[pyo3(get, set)]
    pub styled_nodes: StyledNodeVec, 
    #[pyo3(get, set)]
    pub cascade_info: CascadeInfoVec, 
    #[pyo3(get, set)]
    pub nodes_with_window_callbacks: NodeIdVec, 
    #[pyo3(get, set)]
    pub nodes_with_not_callbacks: NodeIdVec, 
    #[pyo3(get, set)]
    pub nodes_with_datasets: NodeIdVec, 
    #[pyo3(get, set)]
    pub tag_ids_to_node_ids: TagIdToNodeIdMappingVec, 
    #[pyo3(get, set)]
    pub non_leaf_nodes: ParentWithNodeDepthVec, 
    #[pyo3(get, set)]
    pub css_property_cache: CssPropertyCachePtr, 
    #[pyo3(get, set)]
    pub dom_id: DomId, 
}

/// `AzTagIdToNodeIdMapping` struct
#[pyclass(name = "TagIdToNodeIdMapping")]
pub struct AzTagIdToNodeIdMapping {
    #[pyo3(get, set)]
    pub tag_id: AzTagId, 
    #[pyo3(get, set)]
    pub node_id: NodeHierarchyItemId, 
    #[pyo3(get, set)]
    pub tab_index: OptionTabIndex, 
    #[pyo3(get, set)]
    pub parent_node_ids: NodeIdVec, 
}

/// `AzParentWithNodeDepth` struct
#[pyclass(name = "ParentWithNodeDepth")]
pub struct AzParentWithNodeDepth {
    #[pyo3(get, set)]
    pub depth: usize, 
    #[pyo3(get, set)]
    pub node_id: NodeHierarchyItemId, 
}

/// `AzAzTagId` struct
#[pyclass(name = "AzTagId")]
pub struct AzAzTagId {
    #[pyo3(get, set)]
    pub inner: u64, 
}

/// `AzCssPropertyCachePtr` struct
#[pyclass(name = "CssPropertyCachePtr")]
pub struct AzCssPropertyCachePtr {
    #[pyo3(get, set)]
    pub ptr: BoxCssPropertyCache, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// OpenGL texture, use `ReadOnlyWindow::create_texture` to create a texture
#[pyclass(name = "Texture")]
pub struct AzTexture {
    #[pyo3(get, set)]
    pub texture_id: GLuint, 
    #[pyo3(get, set)]
    pub flags: TextureFlags, 
    #[pyo3(get, set)]
    pub size: PhysicalSizeU32, 
    #[pyo3(get, set)]
    pub background_color: ColorU, 
    #[pyo3(get, set)]
    pub gl_context: GlContextPtr, 
    #[pyo3(get, set)]
    pub format: RawImageFormat, 
    #[pyo3(get, set)]
    pub refcount: *const c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// Passing *const c_void is not easily possible when generating APIs, so this wrapper struct is for easier API generation
#[pyclass(name = "GlVoidPtrConst")]
pub struct AzGlVoidPtrConst {
    pub ptr: *const c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzGlVoidPtrMut` struct
#[pyclass(name = "GlVoidPtrMut")]
pub struct AzGlVoidPtrMut {
    pub ptr: *mut GLvoid, // raw pointer not exposed to Python
}

/// `AzTextureFlags` struct
#[pyclass(name = "TextureFlags")]
pub struct AzTextureFlags {
    #[pyo3(get, set)]
    pub is_opaque: bool, 
    #[pyo3(get, set)]
    pub is_video_texture: bool, 
}

/// For .get_gl_precision_format(), but ABI-safe - returning an array or a tuple is not ABI-safe
#[pyclass(name = "GlShaderPrecisionFormatReturn")]
pub struct AzGlShaderPrecisionFormatReturn {
    #[pyo3(get, set)]
    pub _0: GLint, 
    #[pyo3(get, set)]
    pub _1: GLint, 
    #[pyo3(get, set)]
    pub _2: GLint, 
}

/// `AzVertexAttribute` struct
#[pyclass(name = "VertexAttribute")]
pub struct AzVertexAttribute {
    #[pyo3(get, set)]
    pub name: AzString, 
    #[pyo3(get, set)]
    pub layout_location: OptionUsize, 
    #[pyo3(get, set)]
    pub attribute_type: VertexAttributeType, 
    #[pyo3(get, set)]
    pub item_count: usize, 
}

/// `AzVertexLayout` struct
#[pyclass(name = "VertexLayout")]
pub struct AzVertexLayout {
    #[pyo3(get, set)]
    pub fields: VertexAttributeVec, 
}

/// `AzVertexArrayObject` struct
#[pyclass(name = "VertexArrayObject")]
pub struct AzVertexArrayObject {
    #[pyo3(get, set)]
    pub vertex_layout: VertexLayout, 
    #[pyo3(get, set)]
    pub vao_id: GLuint, 
    #[pyo3(get, set)]
    pub gl_context: GlContextPtr, 
    #[pyo3(get, set)]
    pub refcount: *const c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzVertexBuffer` struct
#[pyclass(name = "VertexBuffer")]
pub struct AzVertexBuffer {
    #[pyo3(get, set)]
    pub vertex_buffer_id: GLuint, 
    #[pyo3(get, set)]
    pub vertex_buffer_len: usize, 
    #[pyo3(get, set)]
    pub vao: VertexArrayObject, 
    #[pyo3(get, set)]
    pub index_buffer_id: GLuint, 
    #[pyo3(get, set)]
    pub index_buffer_len: usize, 
    #[pyo3(get, set)]
    pub index_buffer_format: IndexBufferFormat, 
    #[pyo3(get, set)]
    pub refcount: *const c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzGlContextPtr` struct
#[pyclass(name = "GlContextPtr")]
pub struct AzGlContextPtr {
    pub ptr: *const c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub renderer_type: RendererType, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// C-ABI stable reexport of `&[u8]`
#[pyclass(name = "U8VecRef")]
pub struct AzU8VecRef {
    pub ptr: *const c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
}

/// C-ABI stable reexport of `&mut [u8]`
#[pyclass(name = "U8VecRefMut")]
pub struct AzU8VecRefMut {
    pub ptr: *mut c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
}

/// C-ABI stable reexport of `&[f32]`
#[pyclass(name = "F32VecRef")]
pub struct AzF32VecRef {
    pub ptr: *const c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
}

/// C-ABI stable reexport of `&[i32]`
#[pyclass(name = "I32VecRef")]
pub struct AzI32VecRef {
    pub ptr: *const c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
}

/// C-ABI stable reexport of `&[GLuint]` aka `&[u32]`
#[pyclass(name = "GLuintVecRef")]
pub struct AzGLuintVecRef {
    pub ptr: *const c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
}

/// C-ABI stable reexport of `&[GLenum]` aka `&[u32]`
#[pyclass(name = "GLenumVecRef")]
pub struct AzGLenumVecRef {
    pub ptr: *const c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
}

/// C-ABI stable reexport of `&mut [GLint]` aka `&mut [i32]`
#[pyclass(name = "GLintVecRefMut")]
pub struct AzGLintVecRefMut {
    pub ptr: *mut c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
}

/// C-ABI stable reexport of `&mut [GLint64]` aka `&mut [i64]`
#[pyclass(name = "GLint64VecRefMut")]
pub struct AzGLint64VecRefMut {
    pub ptr: *mut c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
}

/// C-ABI stable reexport of `&mut [GLboolean]` aka `&mut [u8]`
#[pyclass(name = "GLbooleanVecRefMut")]
pub struct AzGLbooleanVecRefMut {
    pub ptr: *mut c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
}

/// C-ABI stable reexport of `&mut [GLfloat]` aka `&mut [f32]`
#[pyclass(name = "GLfloatVecRefMut")]
pub struct AzGLfloatVecRefMut {
    pub ptr: *mut c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
}

/// C-ABI stable reexport of `&[Refstr]` aka `&mut [&str]`
#[pyclass(name = "RefstrVecRef")]
pub struct AzRefstrVecRef {
    pub ptr: *const c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
}

/// C-ABI stable reexport of `&str`
#[pyclass(name = "Refstr")]
pub struct AzRefstr {
    pub ptr: *const c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
}

/// C-ABI stable reexport of `(U8Vec, u32)`
#[pyclass(name = "GetProgramBinaryReturn")]
pub struct AzGetProgramBinaryReturn {
    #[pyo3(get, set)]
    pub _0: U8Vec, 
    #[pyo3(get, set)]
    pub _1: u32, 
}

/// C-ABI stable reexport of `(i32, u32, AzString)`
#[pyclass(name = "GetActiveAttribReturn")]
pub struct AzGetActiveAttribReturn {
    #[pyo3(get, set)]
    pub _0: i32, 
    #[pyo3(get, set)]
    pub _1: u32, 
    #[pyo3(get, set)]
    pub _2: AzString, 
}

/// C-ABI stable reexport of `*const gleam::gl::GLsync`
#[pyclass(name = "GLsyncPtr")]
pub struct AzGLsyncPtr {
    pub ptr: *const c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// C-ABI stable reexport of `(i32, u32, AzString)`
#[pyclass(name = "GetActiveUniformReturn")]
pub struct AzGetActiveUniformReturn {
    #[pyo3(get, set)]
    pub _0: i32, 
    #[pyo3(get, set)]
    pub _1: u32, 
    #[pyo3(get, set)]
    pub _2: AzString, 
}

/// `AzAzDebugMessage` struct
#[pyclass(name = "AzDebugMessage")]
pub struct AzAzDebugMessage {
    #[pyo3(get, set)]
    pub message: AzString, 
    #[pyo3(get, set)]
    pub source: GLenum, 
    #[pyo3(get, set)]
    pub ty: GLenum, 
    #[pyo3(get, set)]
    pub id: GLenum, 
    #[pyo3(get, set)]
    pub severity: GLenum, 
}

/// `AzImageRef` struct
#[pyclass(name = "ImageRef")]
pub struct AzImageRef {
    #[pyo3(get, set)]
    pub data: *const c_void, 
    #[pyo3(get, set)]
    pub copies: *const c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzRawImage` struct
#[pyclass(name = "RawImage")]
pub struct AzRawImage {
    #[pyo3(get, set)]
    pub pixels: RawImageData, 
    #[pyo3(get, set)]
    pub width: usize, 
    #[pyo3(get, set)]
    pub height: usize, 
    #[pyo3(get, set)]
    pub premultiplied_alpha: bool, 
    #[pyo3(get, set)]
    pub data_format: RawImageFormat, 
    #[pyo3(get, set)]
    pub tag: U8Vec, 
}

/// `AzImageMask` struct
#[pyclass(name = "ImageMask")]
pub struct AzImageMask {
    #[pyo3(get, set)]
    pub image: ImageRef, 
    #[pyo3(get, set)]
    pub rect: LogicalRect, 
    #[pyo3(get, set)]
    pub repeat: bool, 
}

/// `AzLoadedFontSource` struct
#[pyclass(name = "LoadedFontSource")]
pub struct AzLoadedFontSource {
    #[pyo3(get, set)]
    pub data: U8Vec, 
    #[pyo3(get, set)]
    pub index: u32, 
    #[pyo3(get, set)]
    pub load_outlines: bool, 
}

/// `AzSvg` struct
#[pyclass(name = "Svg")]
pub struct AzSvg {
    #[pyo3(get, set)]
    pub tree: *const c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzSvgXmlNode` struct
#[pyclass(name = "SvgXmlNode")]
pub struct AzSvgXmlNode {
    #[pyo3(get, set)]
    pub node: *const c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzSvgMultiPolygon` struct
#[pyclass(name = "SvgMultiPolygon")]
pub struct AzSvgMultiPolygon {
    #[pyo3(get, set)]
    pub rings: SvgPathVec, 
}

/// `AzSvgStyledNode` struct
#[pyclass(name = "SvgStyledNode")]
pub struct AzSvgStyledNode {
    #[pyo3(get, set)]
    pub geometry: SvgNode, 
    #[pyo3(get, set)]
    pub style: SvgStyle, 
}

/// `AzSvgCircle` struct
#[pyclass(name = "SvgCircle")]
pub struct AzSvgCircle {
    #[pyo3(get, set)]
    pub center_x: f32, 
    #[pyo3(get, set)]
    pub center_y: f32, 
    #[pyo3(get, set)]
    pub radius: f32, 
}

/// `AzSvgPath` struct
#[pyclass(name = "SvgPath")]
pub struct AzSvgPath {
    #[pyo3(get, set)]
    pub items: SvgPathElementVec, 
}

/// A line segment in 2D space.
#[pyclass(name = "SvgLine")]
pub struct AzSvgLine {
    #[pyo3(get, set)]
    pub start: SvgPoint, 
    #[pyo3(get, set)]
    pub end: SvgPoint, 
}

/// `AzSvgColoredVertex` struct
#[pyclass(name = "SvgColoredVertex")]
pub struct AzSvgColoredVertex {
    #[pyo3(get, set)]
    pub x: f32, 
    #[pyo3(get, set)]
    pub y: f32, 
    #[pyo3(get, set)]
    pub z: f32, 
    #[pyo3(get, set)]
    pub r: f32, 
    #[pyo3(get, set)]
    pub g: f32, 
    #[pyo3(get, set)]
    pub b: f32, 
    #[pyo3(get, set)]
    pub a: f32, 
}

/// `AzTessellatedColoredSvgNode` struct
#[pyclass(name = "TessellatedColoredSvgNode")]
pub struct AzTessellatedColoredSvgNode {
    #[pyo3(get, set)]
    pub vertices: SvgColoredVertexVec, 
    #[pyo3(get, set)]
    pub indices: U32Vec, 
}

/// Rust wrapper over a `&[TessellatedColoredSvgNode]` or `&Vec<TessellatedColoredSvgNode>`
#[pyclass(name = "TessellatedColoredSvgNodeVecRef")]
pub struct AzTessellatedColoredSvgNodeVecRef {
    pub ptr: *const c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
}

/// `AzTessellatedColoredGPUSvgNode` struct
#[pyclass(name = "TessellatedColoredGPUSvgNode")]
pub struct AzTessellatedColoredGPUSvgNode {
    #[pyo3(get, set)]
    pub vertex_index_buffer: VertexBuffer, 
}

/// `AzSvgVertex` struct
#[pyclass(name = "SvgVertex")]
pub struct AzSvgVertex {
    #[pyo3(get, set)]
    pub x: f32, 
    #[pyo3(get, set)]
    pub y: f32, 
}

/// `AzTessellatedSvgNode` struct
#[pyclass(name = "TessellatedSvgNode")]
pub struct AzTessellatedSvgNode {
    #[pyo3(get, set)]
    pub vertices: SvgVertexVec, 
    #[pyo3(get, set)]
    pub indices: U32Vec, 
}

/// Rust wrapper over a `&[TessellatedSvgNode]` or `&Vec<TessellatedSvgNode>`
#[pyclass(name = "TessellatedSvgNodeVecRef")]
pub struct AzTessellatedSvgNodeVecRef {
    pub ptr: *const c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
}

/// `AzTessellatedGPUSvgNode` struct
#[pyclass(name = "TessellatedGPUSvgNode")]
pub struct AzTessellatedGPUSvgNode {
    #[pyo3(get, set)]
    pub vertex_index_buffer: VertexBuffer, 
}

/// `AzSvgParseOptions` struct
#[pyclass(name = "SvgParseOptions")]
pub struct AzSvgParseOptions {
    #[pyo3(get, set)]
    pub relative_image_path: OptionAzString, 
    #[pyo3(get, set)]
    pub dpi: f32, 
    #[pyo3(get, set)]
    pub default_font_family: AzString, 
    #[pyo3(get, set)]
    pub font_size: f32, 
    #[pyo3(get, set)]
    pub languages: StringVec, 
    #[pyo3(get, set)]
    pub shape_rendering: ShapeRendering, 
    #[pyo3(get, set)]
    pub text_rendering: TextRendering, 
    #[pyo3(get, set)]
    pub image_rendering: ImageRendering, 
    #[pyo3(get, set)]
    pub keep_named_groups: bool, 
    #[pyo3(get, set)]
    pub fontdb: FontDatabase, 
}

/// `AzSvgRenderOptions` struct
#[pyclass(name = "SvgRenderOptions")]
pub struct AzSvgRenderOptions {
    #[pyo3(get, set)]
    pub target_size: OptionLayoutSize, 
    #[pyo3(get, set)]
    pub background_color: OptionColorU, 
    #[pyo3(get, set)]
    pub fit: SvgFitTo, 
    #[pyo3(get, set)]
    pub transform: SvgRenderTransform, 
}

/// `AzSvgRenderTransform` struct
#[pyclass(name = "SvgRenderTransform")]
pub struct AzSvgRenderTransform {
    #[pyo3(get, set)]
    pub sx: f32, 
    #[pyo3(get, set)]
    pub kx: f32, 
    #[pyo3(get, set)]
    pub ky: f32, 
    #[pyo3(get, set)]
    pub sy: f32, 
    #[pyo3(get, set)]
    pub tx: f32, 
    #[pyo3(get, set)]
    pub ty: f32, 
}

/// `AzSvgDashPattern` struct
#[pyclass(name = "SvgDashPattern")]
pub struct AzSvgDashPattern {
    #[pyo3(get, set)]
    pub offset: f32, 
    #[pyo3(get, set)]
    pub length_1: f32, 
    #[pyo3(get, set)]
    pub gap_1: f32, 
    #[pyo3(get, set)]
    pub length_2: f32, 
    #[pyo3(get, set)]
    pub gap_2: f32, 
    #[pyo3(get, set)]
    pub length_3: f32, 
    #[pyo3(get, set)]
    pub gap_3: f32, 
}

/// `AzSvgTransform` struct
#[pyclass(name = "SvgTransform")]
pub struct AzSvgTransform {
    #[pyo3(get, set)]
    pub sx: f32, 
    #[pyo3(get, set)]
    pub kx: f32, 
    #[pyo3(get, set)]
    pub ky: f32, 
    #[pyo3(get, set)]
    pub sy: f32, 
    #[pyo3(get, set)]
    pub tx: f32, 
    #[pyo3(get, set)]
    pub ty: f32, 
}

/// `AzSvgFillStyle` struct
#[pyclass(name = "SvgFillStyle")]
pub struct AzSvgFillStyle {
    #[pyo3(get, set)]
    pub line_join: SvgLineJoin, 
    #[pyo3(get, set)]
    pub miter_limit: f32, 
    #[pyo3(get, set)]
    pub tolerance: f32, 
    #[pyo3(get, set)]
    pub fill_rule: SvgFillRule, 
    #[pyo3(get, set)]
    pub transform: SvgTransform, 
    #[pyo3(get, set)]
    pub anti_alias: bool, 
    #[pyo3(get, set)]
    pub high_quality_aa: bool, 
}

/// `AzSvgStrokeStyle` struct
#[pyclass(name = "SvgStrokeStyle")]
pub struct AzSvgStrokeStyle {
    #[pyo3(get, set)]
    pub start_cap: SvgLineCap, 
    #[pyo3(get, set)]
    pub end_cap: SvgLineCap, 
    #[pyo3(get, set)]
    pub line_join: SvgLineJoin, 
    #[pyo3(get, set)]
    pub dash_pattern: OptionSvgDashPattern, 
    #[pyo3(get, set)]
    pub line_width: f32, 
    #[pyo3(get, set)]
    pub miter_limit: f32, 
    #[pyo3(get, set)]
    pub tolerance: f32, 
    #[pyo3(get, set)]
    pub apply_line_width: bool, 
    #[pyo3(get, set)]
    pub transform: SvgTransform, 
    #[pyo3(get, set)]
    pub anti_alias: bool, 
    #[pyo3(get, set)]
    pub high_quality_aa: bool, 
}

/// `AzSvgXmlOptions` struct
#[pyclass(name = "SvgXmlOptions")]
pub struct AzSvgXmlOptions {
    #[pyo3(get, set)]
    pub use_single_quote: bool, 
    #[pyo3(get, set)]
    pub indent: Indent, 
    #[pyo3(get, set)]
    pub attributes_indent: Indent, 
}

/// `AzXml` struct
#[pyclass(name = "Xml")]
pub struct AzXml {
    #[pyo3(get, set)]
    pub root: XmlNodeVec, 
}

/// Represents one XML node tag
#[pyclass(name = "XmlNode")]
pub struct AzXmlNode {
    #[pyo3(get, set)]
    pub node_type: XmlTagName, 
    #[pyo3(get, set)]
    pub attributes: XmlAttributeMap, 
    #[pyo3(get, set)]
    pub children: XmlNodeVec, 
    #[pyo3(get, set)]
    pub text: XmlTextContent, 
}

/// **Reference-counted** file handle
#[pyclass(name = "File")]
pub struct AzFile {
    #[pyo3(get, set)]
    pub ptr: BoxArc<Mutex<fs::File>>, 
    #[pyo3(get, set)]
    pub path: AzString, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzMsgBox` struct
#[pyclass(name = "MsgBox")]
pub struct AzMsgBox {
    #[pyo3(get, set)]
    pub _reserved: *mut c_void, 
}

/// `AzColorPickerDialog` struct
#[pyclass(name = "ColorPickerDialog")]
pub struct AzColorPickerDialog {
    #[pyo3(get, set)]
    pub _reserved: *mut c_void, 
}

/// File picker dialog
#[pyclass(name = "FileDialog")]
pub struct AzFileDialog {
    #[pyo3(get, set)]
    pub _reserved: *mut c_void, 
}

/// `AzFileTypeList` struct
#[pyclass(name = "FileTypeList")]
pub struct AzFileTypeList {
    #[pyo3(get, set)]
    pub document_types: StringVec, 
    #[pyo3(get, set)]
    pub document_descriptor: AzString, 
}

/// `AzSystemTickDiff` struct
#[pyclass(name = "SystemTickDiff")]
pub struct AzSystemTickDiff {
    #[pyo3(get, set)]
    pub tick_diff: u64, 
}

/// `AzAzInstantPtr` struct
#[pyclass(name = "AzInstantPtr")]
pub struct AzAzInstantPtr {
    pub ptr: *const c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub clone_fn: InstantPtrCloneCallback, 
    #[pyo3(get, set)]
    pub destructor: InstantPtrDestructorCallback, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzInstantPtrCloneCallback` struct
#[pyclass(name = "InstantPtrCloneCallback")]
pub struct AzInstantPtrCloneCallback {
}

/// `AzSystemTick` struct
#[pyclass(name = "SystemTick")]
pub struct AzSystemTick {
    #[pyo3(get, set)]
    pub tick_counter: u64, 
}

/// `AzSystemTimeDiff` struct
#[pyclass(name = "SystemTimeDiff")]
pub struct AzSystemTimeDiff {
    #[pyo3(get, set)]
    pub secs: u64, 
    #[pyo3(get, set)]
    pub nanos: u32, 
}

/// `AzInstantPtrDestructorCallback` struct
#[pyclass(name = "InstantPtrDestructorCallback")]
pub struct AzInstantPtrDestructorCallback {
}

/// `AzTimerId` struct
#[pyclass(name = "TimerId")]
pub struct AzTimerId {
    #[pyo3(get, set)]
    pub id: usize, 
}

/// `AzTimer` struct
#[pyclass(name = "Timer")]
pub struct AzTimer {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub node_id: OptionDomNodeId, 
    #[pyo3(get, set)]
    pub created: Instant, 
    #[pyo3(get, set)]
    pub last_run: OptionInstant, 
    #[pyo3(get, set)]
    pub run_count: usize, 
    #[pyo3(get, set)]
    pub delay: OptionDuration, 
    #[pyo3(get, set)]
    pub interval: OptionDuration, 
    #[pyo3(get, set)]
    pub timeout: OptionDuration, 
    #[pyo3(get, set)]
    pub callback: TimerCallback, 
}

/// `AzThreadId` struct
#[pyclass(name = "ThreadId")]
pub struct AzThreadId {
    #[pyo3(get, set)]
    pub id: usize, 
}

/// `AzThread` struct
#[pyclass(name = "Thread")]
pub struct AzThread {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzThreadSender` struct
#[pyclass(name = "ThreadSender")]
pub struct AzThreadSender {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzThreadReceiver` struct
#[pyclass(name = "ThreadReceiver")]
pub struct AzThreadReceiver {
    pub ptr: *const c_void, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzThreadWriteBackMsg` struct
#[pyclass(name = "ThreadWriteBackMsg")]
pub struct AzThreadWriteBackMsg {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: WriteBackCallback, 
}

/// Destructor of the `ThreadReceiver`
#[pyclass(name = "ThreadReceiverDestructorCallback")]
pub struct AzThreadReceiverDestructorCallback {
}

/// `AzCreateThreadCallback` struct
#[pyclass(name = "CreateThreadCallback")]
pub struct AzCreateThreadCallback {
}

/// Get the current system time, equivalent to `std::time::Instant::now()`, except it also works on systems that work with "ticks" instead of timers
#[pyclass(name = "GetSystemTimeCallback")]
pub struct AzGetSystemTimeCallback {
}

/// Function called to check if the thread has finished
#[pyclass(name = "CheckThreadFinishedCallback")]
pub struct AzCheckThreadFinishedCallback {
}

/// Function to send a message to the thread
#[pyclass(name = "LibrarySendThreadMsgCallback")]
pub struct AzLibrarySendThreadMsgCallback {
}

/// Function to receive a message from the thread
#[pyclass(name = "LibraryReceiveThreadMsgCallback")]
pub struct AzLibraryReceiveThreadMsgCallback {
}

/// Function that the running `Thread` can call to receive messages from the main UI thread
#[pyclass(name = "ThreadRecvCallback")]
pub struct AzThreadRecvCallback {
}

/// Function that the running `Thread` can call to receive messages from the main UI thread
#[pyclass(name = "ThreadSendCallback")]
pub struct AzThreadSendCallback {
}

/// Destructor of the `Thread`
#[pyclass(name = "ThreadDestructorCallback")]
pub struct AzThreadDestructorCallback {
}

/// Destructor of the `ThreadSender`
#[pyclass(name = "ThreadSenderDestructorCallback")]
pub struct AzThreadSenderDestructorCallback {
}

/// `AzFmtArg` struct
#[pyclass(name = "FmtArg")]
pub struct AzFmtArg {
    #[pyo3(get, set)]
    pub key: AzString, 
    #[pyo3(get, set)]
    pub value: FmtValue, 
}

/// Wrapper over a Rust-allocated `Vec<ListViewRow>`
#[pyclass(name = "ListViewRowVec")]
pub struct AzListViewRowVec {
    pub ptr: *const ListViewRow, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: ListViewRowVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<StyleFilter>`
#[pyclass(name = "StyleFilterVec")]
pub struct AzStyleFilterVec {
    pub ptr: *const StyleFilter, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StyleFilterVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<LogicalRect>`
#[pyclass(name = "LogicalRectVec")]
pub struct AzLogicalRectVec {
    pub ptr: *const LogicalRect, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: LogicalRectVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<NodeTypeIdInfoMap>`
#[pyclass(name = "NodeTypeIdInfoMapVec")]
pub struct AzNodeTypeIdInfoMapVec {
    pub ptr: *const NodeTypeIdInfoMap, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: NodeTypeIdInfoMapVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<InputOutputTypeIdInfoMap>`
#[pyclass(name = "InputOutputTypeIdInfoMapVec")]
pub struct AzInputOutputTypeIdInfoMapVec {
    pub ptr: *const InputOutputTypeIdInfoMap, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: InputOutputTypeIdInfoMapVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<NodeIdNodeMap>`
#[pyclass(name = "NodeIdNodeMapVec")]
pub struct AzNodeIdNodeMapVec {
    pub ptr: *const NodeIdNodeMap, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: NodeIdNodeMapVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<InputOutputTypeId>`
#[pyclass(name = "InputOutputTypeIdVec")]
pub struct AzInputOutputTypeIdVec {
    pub ptr: *const InputOutputTypeId, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: InputOutputTypeIdVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<NodeTypeField>`
#[pyclass(name = "NodeTypeFieldVec")]
pub struct AzNodeTypeFieldVec {
    pub ptr: *const NodeTypeField, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: NodeTypeFieldVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<InputConnection>`
#[pyclass(name = "InputConnectionVec")]
pub struct AzInputConnectionVec {
    pub ptr: *const InputConnection, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: InputConnectionVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<OutputNodeAndIndex>`
#[pyclass(name = "OutputNodeAndIndexVec")]
pub struct AzOutputNodeAndIndexVec {
    pub ptr: *const OutputNodeAndIndex, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: OutputNodeAndIndexVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<OutputConnection>`
#[pyclass(name = "OutputConnectionVec")]
pub struct AzOutputConnectionVec {
    pub ptr: *const OutputConnection, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: OutputConnectionVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<InputNodeAndIndex>`
#[pyclass(name = "InputNodeAndIndexVec")]
pub struct AzInputNodeAndIndexVec {
    pub ptr: *const InputNodeAndIndex, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: InputNodeAndIndexVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<AccessibilityState>`
#[pyclass(name = "AccessibilityStateVec")]
pub struct AzAccessibilityStateVec {
    pub ptr: *const AccessibilityState, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: AccessibilityStateVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<MenuItem>`
#[pyclass(name = "MenuItemVec")]
pub struct AzMenuItemVec {
    pub ptr: *const MenuItem, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: MenuItemVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<TessellatedSvgNode>`
#[pyclass(name = "TessellatedSvgNodeVec")]
pub struct AzTessellatedSvgNodeVec {
    pub ptr: *const TessellatedSvgNode, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: TessellatedSvgNodeVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<TessellatedColoredSvgNode>`
#[pyclass(name = "TessellatedColoredSvgNodeVec")]
pub struct AzTessellatedColoredSvgNodeVec {
    pub ptr: *const TessellatedColoredSvgNode, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: TessellatedColoredSvgNodeVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<StyleFontFamily>`
#[pyclass(name = "StyleFontFamilyVec")]
pub struct AzStyleFontFamilyVec {
    pub ptr: *const StyleFontFamily, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StyleFontFamilyVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<XmlNode>`
#[pyclass(name = "XmlNodeVec")]
pub struct AzXmlNodeVec {
    pub ptr: *const XmlNode, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: XmlNodeVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<FmtArg>`
#[pyclass(name = "FmtArgVec")]
pub struct AzFmtArgVec {
    pub ptr: *const FmtArg, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: FmtArgVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<InlineLine>`
#[pyclass(name = "InlineLineVec")]
pub struct AzInlineLineVec {
    pub ptr: *const InlineLine, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: InlineLineVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<InlineWord>`
#[pyclass(name = "InlineWordVec")]
pub struct AzInlineWordVec {
    pub ptr: *const InlineWord, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: InlineWordVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<InlineGlyph>`
#[pyclass(name = "InlineGlyphVec")]
pub struct AzInlineGlyphVec {
    pub ptr: *const InlineGlyph, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: InlineGlyphVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<InlineTextHit>`
#[pyclass(name = "InlineTextHitVec")]
pub struct AzInlineTextHitVec {
    pub ptr: *const InlineTextHit, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: InlineTextHitVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<Monitor>`
#[pyclass(name = "MonitorVec")]
pub struct AzMonitorVec {
    pub ptr: *const Monitor, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: MonitorVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<VideoMode>`
#[pyclass(name = "VideoModeVec")]
pub struct AzVideoModeVec {
    pub ptr: *const VideoMode, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: VideoModeVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<Dom>`
#[pyclass(name = "DomVec")]
pub struct AzDomVec {
    pub ptr: *const Dom, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: DomVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<IdOrClass>`
#[pyclass(name = "IdOrClassVec")]
pub struct AzIdOrClassVec {
    pub ptr: *const IdOrClass, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: IdOrClassVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<NodeDataInlineCssProperty>`
#[pyclass(name = "NodeDataInlineCssPropertyVec")]
pub struct AzNodeDataInlineCssPropertyVec {
    pub ptr: *const NodeDataInlineCssProperty, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: NodeDataInlineCssPropertyVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundContent>`
#[pyclass(name = "StyleBackgroundContentVec")]
pub struct AzStyleBackgroundContentVec {
    pub ptr: *const StyleBackgroundContent, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StyleBackgroundContentVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundPosition>`
#[pyclass(name = "StyleBackgroundPositionVec")]
pub struct AzStyleBackgroundPositionVec {
    pub ptr: *const StyleBackgroundPosition, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StyleBackgroundPositionVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundRepeat>`
#[pyclass(name = "StyleBackgroundRepeatVec")]
pub struct AzStyleBackgroundRepeatVec {
    pub ptr: *const StyleBackgroundRepeat, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StyleBackgroundRepeatVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundSize>`
#[pyclass(name = "StyleBackgroundSizeVec")]
pub struct AzStyleBackgroundSizeVec {
    pub ptr: *const StyleBackgroundSize, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StyleBackgroundSizeVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<StyleTransform>`
#[pyclass(name = "StyleTransformVec")]
pub struct AzStyleTransformVec {
    pub ptr: *const StyleTransform, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StyleTransformVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<CssProperty>`
#[pyclass(name = "CssPropertyVec")]
pub struct AzCssPropertyVec {
    pub ptr: *const CssProperty, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: CssPropertyVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<SvgMultiPolygon>`
#[pyclass(name = "SvgMultiPolygonVec")]
pub struct AzSvgMultiPolygonVec {
    pub ptr: *const SvgMultiPolygon, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: SvgMultiPolygonVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<SvgSimpleNode>`
#[pyclass(name = "SvgSimpleNodeVec")]
pub struct AzSvgSimpleNodeVec {
    pub ptr: *const SvgSimpleNode, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: SvgSimpleNodeVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<SvgPath>`
#[pyclass(name = "SvgPathVec")]
pub struct AzSvgPathVec {
    pub ptr: *const SvgPath, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: SvgPathVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<VertexAttribute>`
#[pyclass(name = "VertexAttributeVec")]
pub struct AzVertexAttributeVec {
    pub ptr: *const VertexAttribute, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: VertexAttributeVecDestructor, 
}

/// Wrapper over a Rust-allocated `VertexAttribute`
#[pyclass(name = "SvgPathElementVec")]
pub struct AzSvgPathElementVec {
    pub ptr: *const SvgPathElement, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: SvgPathElementVecDestructor, 
}

/// Wrapper over a Rust-allocated `SvgVertex`
#[pyclass(name = "SvgVertexVec")]
pub struct AzSvgVertexVec {
    pub ptr: *const SvgVertex, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: SvgVertexVecDestructor, 
}

/// Wrapper over a Rust-allocated `SvgColoredVertex`
#[pyclass(name = "SvgColoredVertexVec")]
pub struct AzSvgColoredVertexVec {
    pub ptr: *const SvgColoredVertex, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: SvgColoredVertexVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<u32>`
#[pyclass(name = "U32Vec")]
pub struct AzU32Vec {
    pub ptr: *const u32, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: U32VecDestructor, 
}

/// Wrapper over a Rust-allocated `XWindowType`
#[pyclass(name = "XWindowTypeVec")]
pub struct AzXWindowTypeVec {
    pub ptr: *const XWindowType, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: XWindowTypeVecDestructor, 
}

/// Wrapper over a Rust-allocated `VirtualKeyCode`
#[pyclass(name = "VirtualKeyCodeVec")]
pub struct AzVirtualKeyCodeVec {
    pub ptr: *const VirtualKeyCode, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: VirtualKeyCodeVecDestructor, 
}

/// Wrapper over a Rust-allocated `CascadeInfo`
#[pyclass(name = "CascadeInfoVec")]
pub struct AzCascadeInfoVec {
    pub ptr: *const CascadeInfo, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: CascadeInfoVecDestructor, 
}

/// Wrapper over a Rust-allocated `ScanCode`
#[pyclass(name = "ScanCodeVec")]
pub struct AzScanCodeVec {
    pub ptr: *const u32, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: ScanCodeVecDestructor, 
}

/// Wrapper over a Rust-allocated `CssDeclaration`
#[pyclass(name = "CssDeclarationVec")]
pub struct AzCssDeclarationVec {
    pub ptr: *const CssDeclaration, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: CssDeclarationVecDestructor, 
}

/// Wrapper over a Rust-allocated `CssPathSelector`
#[pyclass(name = "CssPathSelectorVec")]
pub struct AzCssPathSelectorVec {
    pub ptr: *const CssPathSelector, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: CssPathSelectorVecDestructor, 
}

/// Wrapper over a Rust-allocated `Stylesheet`
#[pyclass(name = "StylesheetVec")]
pub struct AzStylesheetVec {
    pub ptr: *const Stylesheet, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StylesheetVecDestructor, 
}

/// Wrapper over a Rust-allocated `CssRuleBlock`
#[pyclass(name = "CssRuleBlockVec")]
pub struct AzCssRuleBlockVec {
    pub ptr: *const CssRuleBlock, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: CssRuleBlockVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<u16>`
#[pyclass(name = "U16Vec")]
pub struct AzU16Vec {
    pub ptr: *const u16, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: U16VecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<f32>`
#[pyclass(name = "F32Vec")]
pub struct AzF32Vec {
    pub ptr: *const f32, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: F32VecDestructor, 
}

/// Wrapper over a Rust-allocated `U8Vec`
#[pyclass(name = "U8Vec")]
pub struct AzU8Vec {
    pub ptr: *const u8, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: U8VecDestructor, 
}

/// Wrapper over a Rust-allocated `CallbackData`
#[pyclass(name = "CallbackDataVec")]
pub struct AzCallbackDataVec {
    pub ptr: *const CallbackData, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: CallbackDataVecDestructor, 
}

/// Wrapper over a Rust-allocated `U32Vec`
#[pyclass(name = "GLuintVec")]
pub struct AzGLuintVec {
    pub ptr: *const u32, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: GLuintVecDestructor, 
}

/// Wrapper over a Rust-allocated `GLintVec`
#[pyclass(name = "GLintVec")]
pub struct AzGLintVec {
    pub ptr: *const i32, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: GLintVecDestructor, 
}

/// Wrapper over a Rust-allocated `StringVec`
#[pyclass(name = "StringVec")]
pub struct AzStringVec {
    pub ptr: *const String, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StringVecDestructor, 
}

/// Wrapper over a Rust-allocated `StringPairVec`
#[pyclass(name = "StringPairVec")]
pub struct AzStringPairVec {
    pub ptr: *const StringPair, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StringPairVecDestructor, 
}

/// Wrapper over a Rust-allocated `NormalizedLinearColorStopVec`
#[pyclass(name = "NormalizedLinearColorStopVec")]
pub struct AzNormalizedLinearColorStopVec {
    pub ptr: *const NormalizedLinearColorStop, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: NormalizedLinearColorStopVecDestructor, 
}

/// Wrapper over a Rust-allocated `NormalizedRadialColorStopVec`
#[pyclass(name = "NormalizedRadialColorStopVec")]
pub struct AzNormalizedRadialColorStopVec {
    pub ptr: *const NormalizedRadialColorStop, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: NormalizedRadialColorStopVecDestructor, 
}

/// Wrapper over a Rust-allocated `NodeIdVec`
#[pyclass(name = "NodeIdVec")]
pub struct AzNodeIdVec {
    pub ptr: *const NodeId, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: NodeIdVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<NodeHierarchyItem>`
#[pyclass(name = "NodeHierarchyItemVec")]
pub struct AzNodeHierarchyItemVec {
    pub ptr: *const NodeHierarchyItem, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: NodeHierarchyItemVecDestructor, 
}

/// Wrapper over a Rust-allocated `StyledNodeVec`
#[pyclass(name = "StyledNodeVec")]
pub struct AzStyledNodeVec {
    pub ptr: *const StyledNode, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StyledNodeVecDestructor, 
}

/// Wrapper over a Rust-allocated `TagIdToNodeIdMappingVec`
#[pyclass(name = "TagIdToNodeIdMappingVec")]
pub struct AzTagIdToNodeIdMappingVec {
    pub ptr: *const TagIdToNodeIdMapping, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: TagIdToNodeIdMappingVecDestructor, 
}

/// Wrapper over a Rust-allocated `ParentWithNodeDepthVec`
#[pyclass(name = "ParentWithNodeDepthVec")]
pub struct AzParentWithNodeDepthVec {
    pub ptr: *const ParentWithNodeDepth, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: ParentWithNodeDepthVecDestructor, 
}

/// Wrapper over a Rust-allocated `NodeDataVec`
#[pyclass(name = "NodeDataVec")]
pub struct AzNodeDataVec {
    pub ptr: *const NodeData, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: NodeDataVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<DebugMessage>`
#[pyclass(name = "AzDebugMessageVec")]
pub struct AzAzDebugMessageVec {
    pub ptr: *const DebugMessage, // raw pointer not exposed to Python
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: AzDebugMessageVecDestructor, 
}

/// `AzDuplicatedNamespaceError` struct
#[pyclass(name = "DuplicatedNamespaceError")]
pub struct AzDuplicatedNamespaceError {
    #[pyo3(get, set)]
    pub ns: AzString, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzUnknownNamespaceError` struct
#[pyclass(name = "UnknownNamespaceError")]
pub struct AzUnknownNamespaceError {
    #[pyo3(get, set)]
    pub ns: AzString, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzUnexpectedCloseTagError` struct
#[pyclass(name = "UnexpectedCloseTagError")]
pub struct AzUnexpectedCloseTagError {
    #[pyo3(get, set)]
    pub expected: AzString, 
    #[pyo3(get, set)]
    pub actual: AzString, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzUnknownEntityReferenceError` struct
#[pyclass(name = "UnknownEntityReferenceError")]
pub struct AzUnknownEntityReferenceError {
    #[pyo3(get, set)]
    pub entity: AzString, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzDuplicatedAttributeError` struct
#[pyclass(name = "DuplicatedAttributeError")]
pub struct AzDuplicatedAttributeError {
    #[pyo3(get, set)]
    pub attribute: AzString, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzXmlTextError` struct
#[pyclass(name = "XmlTextError")]
pub struct AzXmlTextError {
    #[pyo3(get, set)]
    pub stream_error: XmlStreamError, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzNonXmlCharError` struct
#[pyclass(name = "NonXmlCharError")]
pub struct AzNonXmlCharError {
    #[pyo3(get, set)]
    pub ch: u32, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzInvalidCharError` struct
#[pyclass(name = "InvalidCharError")]
pub struct AzInvalidCharError {
    #[pyo3(get, set)]
    pub expected: u8, 
    #[pyo3(get, set)]
    pub got: u8, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzInvalidCharMultipleError` struct
#[pyclass(name = "InvalidCharMultipleError")]
pub struct AzInvalidCharMultipleError {
    #[pyo3(get, set)]
    pub expected: u8, 
    #[pyo3(get, set)]
    pub got: U8Vec, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzInvalidQuoteError` struct
#[pyclass(name = "InvalidQuoteError")]
pub struct AzInvalidQuoteError {
    #[pyo3(get, set)]
    pub got: u8, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzInvalidSpaceError` struct
#[pyclass(name = "InvalidSpaceError")]
pub struct AzInvalidSpaceError {
    #[pyo3(get, set)]
    pub got: u8, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzInvalidStringError` struct
#[pyclass(name = "InvalidStringError")]
pub struct AzInvalidStringError {
    #[pyo3(get, set)]
    pub got: AzString, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzXmlTextPos` struct
#[pyclass(name = "XmlTextPos")]
pub struct AzXmlTextPos {
    #[pyo3(get, set)]
    pub row: u32, 
    #[pyo3(get, set)]
    pub col: u32, 
}

/// Stores the resources for the application, souch as fonts, images and cached texts, also clipboard strings Images and fonts can be references across window contexts (not yet tested, but should work).
#[pyclass(name = "ImageCache")]
pub struct AzImageCache {
    #[pyo3(get, set)]
    pub image_id_map: FastHashMap < AzString , ImageRef >, 
}

/// `AzFontCache` struct
#[pyclass(name = "FontCache")]
pub struct AzFontCache {
    pub ptr: *const c_void, // raw pointer not exposed to Python
}

/// `AzDpiScaleFactor` struct
#[pyclass(name = "DpiScaleFactor")]
pub struct AzDpiScaleFactor {
    #[pyo3(get, set)]
    pub inner: FloatValue, 
}

/// Version of the layout solver to use - future binary versions of azul may have more fields here, necessary so that old compiled applications don't break with newer releases of azul. Newer layout versions are opt-in only.
#[pyclass(name = "LayoutSolverVersion")]
#[repr(transparent)]
pub struct AzLayoutSolverVersionEnumWrapper {
    pub inner: AzLayoutSolverVersion,
}

/// `AzAppLogLevel` enum
#[pyclass(name = "AppLogLevel")]
#[repr(transparent)]
pub struct AzAppLogLevelEnumWrapper {
    pub inner: AzAppLogLevel,
}

/// Whether the renderer has VSync enabled
#[pyclass(name = "Vsync")]
#[repr(transparent)]
pub struct AzVsyncEnumWrapper {
    pub inner: AzVsync,
}

/// Does the renderer render in SRGB color space? By default, azul tries to set it to `Enabled` and falls back to `Disabled` if the OpenGL context can't be initialized properly
#[pyclass(name = "Srgb")]
#[repr(transparent)]
pub struct AzSrgbEnumWrapper {
    pub inner: AzSrgb,
}

/// Does the renderer render using hardware acceleration? By default, azul tries to set it to `Enabled` and falls back to `Disabled` if the OpenGL context can't be initialized properly
#[pyclass(name = "HwAcceleration")]
#[repr(transparent)]
pub struct AzHwAccelerationEnumWrapper {
    pub inner: AzHwAcceleration,
}

/// Raw platform handle, for integration in / with other toolkits and custom non-azul window extensions
#[pyclass(name = "RawWindowHandle")]
#[repr(transparent)]
pub struct AzRawWindowHandleEnumWrapper {
    pub inner: AzRawWindowHandle,
}

/// X window type. Maps directly to [`_NET_WM_WINDOW_TYPE`](https://specifications.freedesktop.org/wm-spec/wm-spec-1.5.html).
#[pyclass(name = "XWindowType")]
#[repr(transparent)]
pub struct AzXWindowTypeEnumWrapper {
    pub inner: AzXWindowType,
}

/// Window "favicon", usually shown in the top left of the window on Windows
#[pyclass(name = "WindowIcon")]
#[repr(transparent)]
pub struct AzWindowIconEnumWrapper {
    pub inner: AzWindowIcon,
}

/// Symbolic name for a keyboard key, does NOT take the keyboard locale into account
#[pyclass(name = "VirtualKeyCode")]
#[repr(transparent)]
pub struct AzVirtualKeyCodeEnumWrapper {
    pub inner: AzVirtualKeyCode,
}

/// Utility function for easier creation of a keymap - i.e. `[vec![Ctrl, S], my_function]`
#[pyclass(name = "AcceleratorKey")]
#[repr(transparent)]
pub struct AzAcceleratorKeyEnumWrapper {
    pub inner: AzAcceleratorKey,
}

/// State of the window frame (minimized, maximized, fullscreen or normal window)
#[pyclass(name = "WindowFrame")]
#[repr(transparent)]
pub struct AzWindowFrameEnumWrapper {
    pub inner: AzWindowFrame,
}

/// Current icon of the mouse cursor
#[pyclass(name = "MouseCursorType")]
#[repr(transparent)]
pub struct AzMouseCursorTypeEnumWrapper {
    pub inner: AzMouseCursorType,
}

/// Current position of the mouse cursor, relative to the window. Set to `Uninitialized` on startup (gets initialized on the first frame).
#[pyclass(name = "CursorPosition")]
#[repr(transparent)]
pub struct AzCursorPositionEnumWrapper {
    pub inner: AzCursorPosition,
}

/// Renderer type of the current windows OpenGL context
#[pyclass(name = "RendererType")]
#[repr(transparent)]
pub struct AzRendererTypeEnumWrapper {
    pub inner: AzRendererType,
}

/// `AzFullScreenMode` enum
#[pyclass(name = "FullScreenMode")]
#[repr(transparent)]
pub struct AzFullScreenModeEnumWrapper {
    pub inner: AzFullScreenMode,
}

/// State, size, etc of the window, for comparing to the last frame
#[pyclass(name = "WindowTheme")]
#[repr(transparent)]
pub struct AzWindowThemeEnumWrapper {
    pub inner: AzWindowTheme,
}

/// Position of the top left corner of the window relative to the top left of the monitor
#[pyclass(name = "WindowPosition")]
#[repr(transparent)]
pub struct AzWindowPositionEnumWrapper {
    pub inner: AzWindowPosition,
}

/// IME composition window rectangle (cursor position + height)
#[pyclass(name = "ImePosition")]
#[repr(transparent)]
pub struct AzImePositionEnumWrapper {
    pub inner: AzImePosition,
}

/// `AzUserAttentionType` enum
#[pyclass(name = "UserAttentionType")]
#[repr(transparent)]
pub struct AzUserAttentionTypeEnumWrapper {
    pub inner: AzUserAttentionType,
}

/// Window decoration style
#[pyclass(name = "WindowDecorations")]
#[repr(transparent)]
pub struct AzWindowDecorationsEnumWrapper {
    pub inner: AzWindowDecorations,
}

/// Compositor blur/transparency effects for window background
#[pyclass(name = "WindowBackgroundMaterial")]
#[repr(transparent)]
pub struct AzWindowBackgroundMaterialEnumWrapper {
    pub inner: AzWindowBackgroundMaterial,
}

/// Window type classification for behavior control
#[pyclass(name = "WindowType")]
#[repr(transparent)]
pub struct AzWindowTypeEnumWrapper {
    pub inner: AzWindowType,
}

/// `AzLayoutCallback` enum
#[pyclass(name = "LayoutCallback")]
#[repr(transparent)]
pub struct AzLayoutCallbackEnumWrapper {
    pub inner: AzLayoutCallback,
}

/// Which type of image should be updated: background image (the CSS background) or content image (the <img src=""> content)
#[pyclass(name = "UpdateImageType")]
#[repr(transparent)]
pub struct AzUpdateImageTypeEnumWrapper {
    pub inner: AzUpdateImageType,
}

/// Specifies if the screen should be updated after the callback function has returned
#[pyclass(name = "Update")]
#[repr(transparent)]
pub struct AzUpdateEnumWrapper {
    pub inner: AzUpdate,
}

/// `AzPositionInfo` enum
#[pyclass(name = "PositionInfo")]
#[repr(transparent)]
pub struct AzPositionInfoEnumWrapper {
    pub inner: AzPositionInfo,
}

/// `AzInlineWord` enum
#[pyclass(name = "InlineWord")]
#[repr(transparent)]
pub struct AzInlineWordEnumWrapper {
    pub inner: AzInlineWord,
}

/// Defines the focus_targeted node ID for the next frame
#[pyclass(name = "FocusTarget")]
#[repr(transparent)]
pub struct AzFocusTargetEnumWrapper {
    pub inner: AzFocusTarget,
}

/// `AzScriptType` enum
#[pyclass(name = "ScriptType")]
#[repr(transparent)]
pub struct AzScriptTypeEnumWrapper {
    pub inner: AzScriptType,
}

/// How should an animation repeat (loop, ping-pong, etc.)
#[pyclass(name = "AnimationRepeat")]
#[repr(transparent)]
pub struct AzAnimationRepeatEnumWrapper {
    pub inner: AzAnimationRepeat,
}

/// How many times should an animation repeat
#[pyclass(name = "AnimationRepeatCount")]
#[repr(transparent)]
pub struct AzAnimationRepeatCountEnumWrapper {
    pub inner: AzAnimationRepeatCount,
}

/// Which edge triggered a scroll-based re-invocation
#[pyclass(name = "EdgeType")]
#[repr(transparent)]
pub struct AzEdgeTypeEnumWrapper {
    pub inner: AzEdgeType,
}

/// Reason why an IFrame callback is being invoked. This helps the callback optimize its behavior based on why it's being called.
#[pyclass(name = "IFrameCallbackReason")]
#[repr(transparent)]
pub struct AzIFrameCallbackReasonEnumWrapper {
    pub inner: AzIFrameCallbackReason,
}

/// List of core DOM node types built into `azul`. This enum defines the building blocks of the UI, similar to HTML tags.
#[pyclass(name = "NodeType")]
#[repr(transparent)]
pub struct AzNodeTypeEnumWrapper {
    pub inner: AzNodeType,
}

/// Defines the type of event that can trigger a callback action.
#[pyclass(name = "On")]
#[repr(transparent)]
pub struct AzOnEnumWrapper {
    pub inner: AzOn,
}

/// `AzEventFilter` enum
#[pyclass(name = "EventFilter")]
#[repr(transparent)]
pub struct AzEventFilterEnumWrapper {
    pub inner: AzEventFilter,
}

/// `AzHoverEventFilter` enum
#[pyclass(name = "HoverEventFilter")]
#[repr(transparent)]
pub struct AzHoverEventFilterEnumWrapper {
    pub inner: AzHoverEventFilter,
}

/// `AzFocusEventFilter` enum
#[pyclass(name = "FocusEventFilter")]
#[repr(transparent)]
pub struct AzFocusEventFilterEnumWrapper {
    pub inner: AzFocusEventFilter,
}

/// `AzNotEventFilter` enum
#[pyclass(name = "NotEventFilter")]
#[repr(transparent)]
pub struct AzNotEventFilterEnumWrapper {
    pub inner: AzNotEventFilter,
}

/// `AzWindowEventFilter` enum
#[pyclass(name = "WindowEventFilter")]
#[repr(transparent)]
pub struct AzWindowEventFilterEnumWrapper {
    pub inner: AzWindowEventFilter,
}

/// `AzComponentEventFilter` enum
#[pyclass(name = "ComponentEventFilter")]
#[repr(transparent)]
pub struct AzComponentEventFilterEnumWrapper {
    pub inner: AzComponentEventFilter,
}

/// `AzApplicationEventFilter` enum
#[pyclass(name = "ApplicationEventFilter")]
#[repr(transparent)]
pub struct AzApplicationEventFilterEnumWrapper {
    pub inner: AzApplicationEventFilter,
}

/// Defines the element's purpose for accessibility APIs, informing assistive technologies like screen readers about the function of a UI element. Each variant corresponds to a standard control type or UI structure. For more details, see the [MSDN Role Constants page](https://docs.microsoft.com/en-us/windows/winauto/object-roles).
#[pyclass(name = "AccessibilityRole")]
#[repr(transparent)]
pub struct AzAccessibilityRoleEnumWrapper {
    pub inner: AzAccessibilityRole,
}

/// Defines the current state of an element for accessibility APIs (e.g., focused, checked). These states provide dynamic information to assistive technologies about the element's condition. See the [MSDN State Constants page](https://docs.microsoft.com/en-us/windows/win32/winauto/object-state-constants) for more details.
#[pyclass(name = "AccessibilityState")]
#[repr(transparent)]
pub struct AzAccessibilityStateEnumWrapper {
    pub inner: AzAccessibilityState,
}

/// Determines the behavior of an element in sequential focus navigation
#[pyclass(name = "TabIndex")]
#[repr(transparent)]
pub struct AzTabIndexEnumWrapper {
    pub inner: AzTabIndex,
}

/// An enum that holds either a CSS ID or a class name as a string.
#[pyclass(name = "IdOrClass")]
#[repr(transparent)]
pub struct AzIdOrClassEnumWrapper {
    pub inner: AzIdOrClass,
}

/// Represents an inline CSS property attached to a node for a specific interaction state. This allows defining styles for `:hover`, `:focus`, etc., directly on a DOM node.
#[pyclass(name = "NodeDataInlineCssProperty")]
#[repr(transparent)]
pub struct AzNodeDataInlineCssPropertyEnumWrapper {
    pub inner: AzNodeDataInlineCssProperty,
}

/// Determines whether this context menu should pop up on a left, right or middle click
#[pyclass(name = "ContextMenuMouseButton")]
#[repr(transparent)]
pub struct AzContextMenuMouseButtonEnumWrapper {
    pub inner: AzContextMenuMouseButton,
}

/// Specifies where a popup menu should appear relative to the cursor or clicked element. This positioning information is ignored for application-level menus (menu bars) and only applies to context menus and dropdowns.
#[pyclass(name = "MenuPopupPosition")]
#[repr(transparent)]
pub struct AzMenuPopupPositionEnumWrapper {
    pub inner: AzMenuPopupPosition,
}

/// Represents a single item in a menu. Menu items can be regular text items with labels and callbacks, visual separators, or line breaks for horizontal menu layouts.
#[pyclass(name = "MenuItem")]
#[repr(transparent)]
pub struct AzMenuItemEnumWrapper {
    pub inner: AzMenuItem,
}

/// Optional icon displayed next to a menu item. Icons can be either: - A checkbox (checked or unchecked) - A custom image (typically 16x16 pixels)
#[pyclass(name = "MenuItemIcon")]
#[repr(transparent)]
pub struct AzMenuItemIconEnumWrapper {
    pub inner: AzMenuItemIcon,
}

/// Describes the interactive state of a menu item. Menu items can be in different states that affect their appearance and behavior: - Normal items are clickable and render normally - Greyed items are visually disabled (greyed out) and non-clickable - Disabled items are non-clickable but retain normal appearance
#[pyclass(name = "MenuItemState")]
#[repr(transparent)]
pub struct AzMenuItemStateEnumWrapper {
    pub inner: AzMenuItemState,
}

/// `AzCssPathSelector` enum
#[pyclass(name = "CssPathSelector")]
#[repr(transparent)]
pub struct AzCssPathSelectorEnumWrapper {
    pub inner: AzCssPathSelector,
}

/// Represents one parsed CSS key-value pair, such as `"width: 20px"` => `CssProperty::Width(LayoutWidth::px(20.0))`
#[pyclass(name = "CssProperty")]
#[repr(transparent)]
pub struct AzCssPropertyEnumWrapper {
    pub inner: AzCssProperty,
}

/// `AzCssPathPseudoSelector` enum
#[pyclass(name = "CssPathPseudoSelector")]
#[repr(transparent)]
pub struct AzCssPathPseudoSelectorEnumWrapper {
    pub inner: AzCssPathPseudoSelector,
}

/// `AzCssNthChildSelector` enum
#[pyclass(name = "CssNthChildSelector")]
#[repr(transparent)]
pub struct AzCssNthChildSelectorEnumWrapper {
    pub inner: AzCssNthChildSelector,
}

/// Contains one parsed `key: value` pair, static or dynamic
#[pyclass(name = "CssDeclaration")]
#[repr(transparent)]
pub struct AzCssDeclarationEnumWrapper {
    pub inner: AzCssDeclaration,
}

/// Represents a CSS key (for example `"border-radius"` => `BorderRadius`). You can also derive this key from a `CssProperty` by calling `CssProperty::get_type()`.
#[pyclass(name = "CssPropertyType")]
#[repr(transparent)]
pub struct AzCssPropertyTypeEnumWrapper {
    pub inner: AzCssPropertyType,
}

/// Represents an animation timing function.
#[pyclass(name = "AnimationInterpolationFunction")]
#[repr(transparent)]
pub struct AzAnimationInterpolationFunctionEnumWrapper {
    pub inner: AzAnimationInterpolationFunction,
}

/// Signifies the type of a DOM node without carrying any associated data
#[pyclass(name = "NodeTypeTag")]
#[repr(transparent)]
pub struct AzNodeTypeTagEnumWrapper {
    pub inner: AzNodeTypeTag,
}

/// Enum representing the metric associated with a number (px, pt, em, etc.)
#[pyclass(name = "SizeMetric")]
#[repr(transparent)]
pub struct AzSizeMetricEnumWrapper {
    pub inner: AzSizeMetric,
}

/// What direction should a `box-shadow` be clipped in (inset or outset).
#[pyclass(name = "BoxShadowClipMode")]
#[repr(transparent)]
pub struct AzBoxShadowClipModeEnumWrapper {
    pub inner: AzBoxShadowClipMode,
}

/// Represents a `mix-blend-mode` attribute, which determines how an element's content should blend with the content of the element's parent.
#[pyclass(name = "StyleMixBlendMode")]
#[repr(transparent)]
pub struct AzStyleMixBlendModeEnumWrapper {
    pub inner: AzStyleMixBlendMode,
}

/// `AzStyleFilter` enum
#[pyclass(name = "StyleFilter")]
#[repr(transparent)]
pub struct AzStyleFilterEnumWrapper {
    pub inner: AzStyleFilter,
}

/// `AzStyleCompositeFilter` enum
#[pyclass(name = "StyleCompositeFilter")]
#[repr(transparent)]
pub struct AzStyleCompositeFilterEnumWrapper {
    pub inner: AzStyleCompositeFilter,
}

/// Represents an `align-content` attribute, which aligns a flex container's lines within it when there is extra space in the cross-axis. Default: `Stretch`
#[pyclass(name = "LayoutAlignContent")]
#[repr(transparent)]
pub struct AzLayoutAlignContentEnumWrapper {
    pub inner: AzLayoutAlignContent,
}

/// Represents an `align-items` attribute, which defines the default behavior for how flex items are laid out along the cross axis on the current line. Default: `Stretch`
#[pyclass(name = "LayoutAlignItems")]
#[repr(transparent)]
pub struct AzLayoutAlignItemsEnumWrapper {
    pub inner: AzLayoutAlignItems,
}

/// Represents a `box-sizing` attribute
#[pyclass(name = "LayoutBoxSizing")]
#[repr(transparent)]
pub struct AzLayoutBoxSizingEnumWrapper {
    pub inner: AzLayoutBoxSizing,
}

/// Represents a `flex-direction` attribute, which establishes the main-axis, thus defining the direction flex items are placed in the flex container. Default: `Row`
#[pyclass(name = "LayoutFlexDirection")]
#[repr(transparent)]
pub struct AzLayoutFlexDirectionEnumWrapper {
    pub inner: AzLayoutFlexDirection,
}

/// Represents a `display` CSS property value
#[pyclass(name = "LayoutDisplay")]
#[repr(transparent)]
pub struct AzLayoutDisplayEnumWrapper {
    pub inner: AzLayoutDisplay,
}

/// Represents a `float` attribute
#[pyclass(name = "LayoutFloat")]
#[repr(transparent)]
pub struct AzLayoutFloatEnumWrapper {
    pub inner: AzLayoutFloat,
}

/// Represents a `justify-content` attribute, which defines the alignment along the main axis. Default: `Start` (flex-start)
#[pyclass(name = "LayoutJustifyContent")]
#[repr(transparent)]
pub struct AzLayoutJustifyContentEnumWrapper {
    pub inner: AzLayoutJustifyContent,
}

/// Represents a `position` attribute - default: `Static`
#[pyclass(name = "LayoutPosition")]
#[repr(transparent)]
pub struct AzLayoutPositionEnumWrapper {
    pub inner: AzLayoutPosition,
}

/// Represents a `flex-wrap` attribute, which determines whether flex items are forced onto one line or can wrap onto multiple lines. Default: `NoWrap`
#[pyclass(name = "LayoutFlexWrap")]
#[repr(transparent)]
pub struct AzLayoutFlexWrapEnumWrapper {
    pub inner: AzLayoutFlexWrap,
}

/// Represents an `overflow-x` or `overflow-y` property. Determines what to do when content overflows an element's box.
#[pyclass(name = "LayoutOverflow")]
#[repr(transparent)]
pub struct AzLayoutOverflowEnumWrapper {
    pub inner: AzLayoutOverflow,
}

/// Enum representing the metric associated with an angle (deg, rad, etc.)
#[pyclass(name = "AngleMetric")]
#[repr(transparent)]
pub struct AzAngleMetricEnumWrapper {
    pub inner: AzAngleMetric,
}

/// `AzDirectionCorner` enum
#[pyclass(name = "DirectionCorner")]
#[repr(transparent)]
pub struct AzDirectionCornerEnumWrapper {
    pub inner: AzDirectionCorner,
}

/// CSS direction (necessary for gradients). Can either be a fixed angle or a direction ("to right" / "to left", etc.).
#[pyclass(name = "Direction")]
#[repr(transparent)]
pub struct AzDirectionEnumWrapper {
    pub inner: AzDirection,
}

/// Whether a `gradient` should be repeated or clamped to the edges.
#[pyclass(name = "ExtendMode")]
#[repr(transparent)]
pub struct AzExtendModeEnumWrapper {
    pub inner: AzExtendMode,
}

/// `AzShape` enum
#[pyclass(name = "Shape")]
#[repr(transparent)]
pub struct AzShapeEnumWrapper {
    pub inner: AzShape,
}

/// `AzRadialGradientSize` enum
#[pyclass(name = "RadialGradientSize")]
#[repr(transparent)]
pub struct AzRadialGradientSizeEnumWrapper {
    pub inner: AzRadialGradientSize,
}

/// `AzStyleBackgroundContent` enum
#[pyclass(name = "StyleBackgroundContent")]
#[repr(transparent)]
pub struct AzStyleBackgroundContentEnumWrapper {
    pub inner: AzStyleBackgroundContent,
}

/// `AzBackgroundPositionHorizontal` enum
#[pyclass(name = "BackgroundPositionHorizontal")]
#[repr(transparent)]
pub struct AzBackgroundPositionHorizontalEnumWrapper {
    pub inner: AzBackgroundPositionHorizontal,
}

/// `AzBackgroundPositionVertical` enum
#[pyclass(name = "BackgroundPositionVertical")]
#[repr(transparent)]
pub struct AzBackgroundPositionVerticalEnumWrapper {
    pub inner: AzBackgroundPositionVertical,
}

/// `AzStyleBackgroundRepeat` enum
#[pyclass(name = "StyleBackgroundRepeat")]
#[repr(transparent)]
pub struct AzStyleBackgroundRepeatEnumWrapper {
    pub inner: AzStyleBackgroundRepeat,
}

/// `AzStyleBackgroundSize` enum
#[pyclass(name = "StyleBackgroundSize")]
#[repr(transparent)]
pub struct AzStyleBackgroundSizeEnumWrapper {
    pub inner: AzStyleBackgroundSize,
}

/// Style of a `border`: solid, double, dash, ridge, etc.
#[pyclass(name = "BorderStyle")]
#[repr(transparent)]
pub struct AzBorderStyleEnumWrapper {
    pub inner: AzBorderStyle,
}

/// Represents a `cursor` attribute, defining the mouse cursor to be displayed when pointing over an element.
#[pyclass(name = "StyleCursor")]
#[repr(transparent)]
pub struct AzStyleCursorEnumWrapper {
    pub inner: AzStyleCursor,
}

/// Represents a `font-family` attribute
#[pyclass(name = "StyleFontFamily")]
#[repr(transparent)]
pub struct AzStyleFontFamilyEnumWrapper {
    pub inner: AzStyleFontFamily,
}

/// Represents a `backface-visibility` attribute
#[pyclass(name = "StyleBackfaceVisibility")]
#[repr(transparent)]
pub struct AzStyleBackfaceVisibilityEnumWrapper {
    pub inner: AzStyleBackfaceVisibility,
}

/// Represents one component of a `transform` attribute
#[pyclass(name = "StyleTransform")]
#[repr(transparent)]
pub struct AzStyleTransformEnumWrapper {
    pub inner: AzStyleTransform,
}

/// Horizontal text alignment enum (left, center, right) - default: `Left`
#[pyclass(name = "StyleTextAlign")]
#[repr(transparent)]
pub struct AzStyleTextAlignEnumWrapper {
    pub inner: AzStyleTextAlign,
}

/// Type alias for CssPropertyValue < StyleBoxShadow >
#[pyclass(name = "StyleBoxShadowValue")]
#[repr(transparent)]
pub struct AzStyleBoxShadowValueEnumWrapper {
    pub inner: AzStyleBoxShadowValue,
}

/// Type alias for CssPropertyValue < LayoutAlignContent >
#[pyclass(name = "LayoutAlignContentValue")]
#[repr(transparent)]
pub struct AzLayoutAlignContentValueEnumWrapper {
    pub inner: AzLayoutAlignContentValue,
}

/// Type alias for CssPropertyValue < LayoutAlignItems >
#[pyclass(name = "LayoutAlignItemsValue")]
#[repr(transparent)]
pub struct AzLayoutAlignItemsValueEnumWrapper {
    pub inner: AzLayoutAlignItemsValue,
}

/// Type alias for CssPropertyValue < LayoutBottom >
#[pyclass(name = "LayoutBottomValue")]
#[repr(transparent)]
pub struct AzLayoutBottomValueEnumWrapper {
    pub inner: AzLayoutBottomValue,
}

/// Type alias for CssPropertyValue < LayoutBoxSizing >
#[pyclass(name = "LayoutBoxSizingValue")]
#[repr(transparent)]
pub struct AzLayoutBoxSizingValueEnumWrapper {
    pub inner: AzLayoutBoxSizingValue,
}

/// Type alias for CssPropertyValue < LayoutFlexDirection >
#[pyclass(name = "LayoutFlexDirectionValue")]
#[repr(transparent)]
pub struct AzLayoutFlexDirectionValueEnumWrapper {
    pub inner: AzLayoutFlexDirectionValue,
}

/// Type alias for CssPropertyValue < LayoutDisplay >
#[pyclass(name = "LayoutDisplayValue")]
#[repr(transparent)]
pub struct AzLayoutDisplayValueEnumWrapper {
    pub inner: AzLayoutDisplayValue,
}

/// Type alias for CssPropertyValue < LayoutFlexGrow >
#[pyclass(name = "LayoutFlexGrowValue")]
#[repr(transparent)]
pub struct AzLayoutFlexGrowValueEnumWrapper {
    pub inner: AzLayoutFlexGrowValue,
}

/// Type alias for CssPropertyValue < LayoutFlexShrink >
#[pyclass(name = "LayoutFlexShrinkValue")]
#[repr(transparent)]
pub struct AzLayoutFlexShrinkValueEnumWrapper {
    pub inner: AzLayoutFlexShrinkValue,
}

/// Type alias for CssPropertyValue < LayoutFloat >
#[pyclass(name = "LayoutFloatValue")]
#[repr(transparent)]
pub struct AzLayoutFloatValueEnumWrapper {
    pub inner: AzLayoutFloatValue,
}

/// Type alias for CssPropertyValue < LayoutHeight >
#[pyclass(name = "LayoutHeightValue")]
#[repr(transparent)]
pub struct AzLayoutHeightValueEnumWrapper {
    pub inner: AzLayoutHeightValue,
}

/// Type alias for CssPropertyValue < LayoutJustifyContent >
#[pyclass(name = "LayoutJustifyContentValue")]
#[repr(transparent)]
pub struct AzLayoutJustifyContentValueEnumWrapper {
    pub inner: AzLayoutJustifyContentValue,
}

/// Type alias for CssPropertyValue < LayoutLeft >
#[pyclass(name = "LayoutLeftValue")]
#[repr(transparent)]
pub struct AzLayoutLeftValueEnumWrapper {
    pub inner: AzLayoutLeftValue,
}

/// Type alias for CssPropertyValue < LayoutMarginBottom >
#[pyclass(name = "LayoutMarginBottomValue")]
#[repr(transparent)]
pub struct AzLayoutMarginBottomValueEnumWrapper {
    pub inner: AzLayoutMarginBottomValue,
}

/// Type alias for CssPropertyValue < LayoutMarginLeft >
#[pyclass(name = "LayoutMarginLeftValue")]
#[repr(transparent)]
pub struct AzLayoutMarginLeftValueEnumWrapper {
    pub inner: AzLayoutMarginLeftValue,
}

/// Type alias for CssPropertyValue < LayoutMarginRight >
#[pyclass(name = "LayoutMarginRightValue")]
#[repr(transparent)]
pub struct AzLayoutMarginRightValueEnumWrapper {
    pub inner: AzLayoutMarginRightValue,
}

/// Type alias for CssPropertyValue < LayoutMarginTop >
#[pyclass(name = "LayoutMarginTopValue")]
#[repr(transparent)]
pub struct AzLayoutMarginTopValueEnumWrapper {
    pub inner: AzLayoutMarginTopValue,
}

/// Type alias for CssPropertyValue < LayoutMaxHeight >
#[pyclass(name = "LayoutMaxHeightValue")]
#[repr(transparent)]
pub struct AzLayoutMaxHeightValueEnumWrapper {
    pub inner: AzLayoutMaxHeightValue,
}

/// Type alias for CssPropertyValue < LayoutMaxWidth >
#[pyclass(name = "LayoutMaxWidthValue")]
#[repr(transparent)]
pub struct AzLayoutMaxWidthValueEnumWrapper {
    pub inner: AzLayoutMaxWidthValue,
}

/// Type alias for CssPropertyValue < LayoutMinHeight >
#[pyclass(name = "LayoutMinHeightValue")]
#[repr(transparent)]
pub struct AzLayoutMinHeightValueEnumWrapper {
    pub inner: AzLayoutMinHeightValue,
}

/// Type alias for CssPropertyValue < LayoutMinWidth >
#[pyclass(name = "LayoutMinWidthValue")]
#[repr(transparent)]
pub struct AzLayoutMinWidthValueEnumWrapper {
    pub inner: AzLayoutMinWidthValue,
}

/// Type alias for CssPropertyValue < LayoutPaddingBottom >
#[pyclass(name = "LayoutPaddingBottomValue")]
#[repr(transparent)]
pub struct AzLayoutPaddingBottomValueEnumWrapper {
    pub inner: AzLayoutPaddingBottomValue,
}

/// Type alias for CssPropertyValue < LayoutPaddingLeft >
#[pyclass(name = "LayoutPaddingLeftValue")]
#[repr(transparent)]
pub struct AzLayoutPaddingLeftValueEnumWrapper {
    pub inner: AzLayoutPaddingLeftValue,
}

/// Type alias for CssPropertyValue < LayoutPaddingRight >
#[pyclass(name = "LayoutPaddingRightValue")]
#[repr(transparent)]
pub struct AzLayoutPaddingRightValueEnumWrapper {
    pub inner: AzLayoutPaddingRightValue,
}

/// Type alias for CssPropertyValue < LayoutPaddingTop >
#[pyclass(name = "LayoutPaddingTopValue")]
#[repr(transparent)]
pub struct AzLayoutPaddingTopValueEnumWrapper {
    pub inner: AzLayoutPaddingTopValue,
}

/// Type alias for CssPropertyValue < LayoutPosition >
#[pyclass(name = "LayoutPositionValue")]
#[repr(transparent)]
pub struct AzLayoutPositionValueEnumWrapper {
    pub inner: AzLayoutPositionValue,
}

/// Type alias for CssPropertyValue < LayoutRight >
#[pyclass(name = "LayoutRightValue")]
#[repr(transparent)]
pub struct AzLayoutRightValueEnumWrapper {
    pub inner: AzLayoutRightValue,
}

/// Type alias for CssPropertyValue < LayoutTop >
#[pyclass(name = "LayoutTopValue")]
#[repr(transparent)]
pub struct AzLayoutTopValueEnumWrapper {
    pub inner: AzLayoutTopValue,
}

/// Type alias for CssPropertyValue < LayoutWidth >
#[pyclass(name = "LayoutWidthValue")]
#[repr(transparent)]
pub struct AzLayoutWidthValueEnumWrapper {
    pub inner: AzLayoutWidthValue,
}

/// Type alias for CssPropertyValue < LayoutFlexWrap >
#[pyclass(name = "LayoutFlexWrapValue")]
#[repr(transparent)]
pub struct AzLayoutFlexWrapValueEnumWrapper {
    pub inner: AzLayoutFlexWrapValue,
}

/// Type alias for CssPropertyValue < LayoutOverflow >
#[pyclass(name = "LayoutOverflowValue")]
#[repr(transparent)]
pub struct AzLayoutOverflowValueEnumWrapper {
    pub inner: AzLayoutOverflowValue,
}

/// Type alias for CssPropertyValue < ScrollbarStyle >
#[pyclass(name = "ScrollbarStyleValue")]
#[repr(transparent)]
pub struct AzScrollbarStyleValueEnumWrapper {
    pub inner: AzScrollbarStyleValue,
}

/// Type alias for CssPropertyValue < StyleBackgroundContentVec >
#[pyclass(name = "StyleBackgroundContentVecValue")]
#[repr(transparent)]
pub struct AzStyleBackgroundContentVecValueEnumWrapper {
    pub inner: AzStyleBackgroundContentVecValue,
}

/// Type alias for CssPropertyValue < StyleBackgroundPositionVec >
#[pyclass(name = "StyleBackgroundPositionVecValue")]
#[repr(transparent)]
pub struct AzStyleBackgroundPositionVecValueEnumWrapper {
    pub inner: AzStyleBackgroundPositionVecValue,
}

/// Type alias for CssPropertyValue < StyleBackgroundRepeatVec >
#[pyclass(name = "StyleBackgroundRepeatVecValue")]
#[repr(transparent)]
pub struct AzStyleBackgroundRepeatVecValueEnumWrapper {
    pub inner: AzStyleBackgroundRepeatVecValue,
}

/// Type alias for CssPropertyValue < StyleBackgroundSizeVec >
#[pyclass(name = "StyleBackgroundSizeVecValue")]
#[repr(transparent)]
pub struct AzStyleBackgroundSizeVecValueEnumWrapper {
    pub inner: AzStyleBackgroundSizeVecValue,
}

/// Type alias for CssPropertyValue < StyleBorderBottomColor >
#[pyclass(name = "StyleBorderBottomColorValue")]
#[repr(transparent)]
pub struct AzStyleBorderBottomColorValueEnumWrapper {
    pub inner: AzStyleBorderBottomColorValue,
}

/// Type alias for CssPropertyValue < StyleBorderBottomLeftRadius >
#[pyclass(name = "StyleBorderBottomLeftRadiusValue")]
#[repr(transparent)]
pub struct AzStyleBorderBottomLeftRadiusValueEnumWrapper {
    pub inner: AzStyleBorderBottomLeftRadiusValue,
}

/// Type alias for CssPropertyValue < StyleBorderBottomRightRadius >
#[pyclass(name = "StyleBorderBottomRightRadiusValue")]
#[repr(transparent)]
pub struct AzStyleBorderBottomRightRadiusValueEnumWrapper {
    pub inner: AzStyleBorderBottomRightRadiusValue,
}

/// Type alias for CssPropertyValue < StyleBorderBottomStyle >
#[pyclass(name = "StyleBorderBottomStyleValue")]
#[repr(transparent)]
pub struct AzStyleBorderBottomStyleValueEnumWrapper {
    pub inner: AzStyleBorderBottomStyleValue,
}

/// Type alias for CssPropertyValue < LayoutBorderBottomWidth >
#[pyclass(name = "LayoutBorderBottomWidthValue")]
#[repr(transparent)]
pub struct AzLayoutBorderBottomWidthValueEnumWrapper {
    pub inner: AzLayoutBorderBottomWidthValue,
}

/// Type alias for CssPropertyValue < StyleBorderLeftColor >
#[pyclass(name = "StyleBorderLeftColorValue")]
#[repr(transparent)]
pub struct AzStyleBorderLeftColorValueEnumWrapper {
    pub inner: AzStyleBorderLeftColorValue,
}

/// Type alias for CssPropertyValue < StyleBorderLeftStyle >
#[pyclass(name = "StyleBorderLeftStyleValue")]
#[repr(transparent)]
pub struct AzStyleBorderLeftStyleValueEnumWrapper {
    pub inner: AzStyleBorderLeftStyleValue,
}

/// Type alias for CssPropertyValue < LayoutBorderLeftWidth >
#[pyclass(name = "LayoutBorderLeftWidthValue")]
#[repr(transparent)]
pub struct AzLayoutBorderLeftWidthValueEnumWrapper {
    pub inner: AzLayoutBorderLeftWidthValue,
}

/// Type alias for CssPropertyValue < StyleBorderRightColor >
#[pyclass(name = "StyleBorderRightColorValue")]
#[repr(transparent)]
pub struct AzStyleBorderRightColorValueEnumWrapper {
    pub inner: AzStyleBorderRightColorValue,
}

/// Type alias for CssPropertyValue < StyleBorderRightStyle >
#[pyclass(name = "StyleBorderRightStyleValue")]
#[repr(transparent)]
pub struct AzStyleBorderRightStyleValueEnumWrapper {
    pub inner: AzStyleBorderRightStyleValue,
}

/// Type alias for CssPropertyValue < LayoutBorderRightWidth >
#[pyclass(name = "LayoutBorderRightWidthValue")]
#[repr(transparent)]
pub struct AzLayoutBorderRightWidthValueEnumWrapper {
    pub inner: AzLayoutBorderRightWidthValue,
}

/// Type alias for CssPropertyValue < StyleBorderTopColor >
#[pyclass(name = "StyleBorderTopColorValue")]
#[repr(transparent)]
pub struct AzStyleBorderTopColorValueEnumWrapper {
    pub inner: AzStyleBorderTopColorValue,
}

/// Type alias for CssPropertyValue < StyleBorderTopLeftRadius >
#[pyclass(name = "StyleBorderTopLeftRadiusValue")]
#[repr(transparent)]
pub struct AzStyleBorderTopLeftRadiusValueEnumWrapper {
    pub inner: AzStyleBorderTopLeftRadiusValue,
}

/// Type alias for CssPropertyValue < StyleBorderTopRightRadius >
#[pyclass(name = "StyleBorderTopRightRadiusValue")]
#[repr(transparent)]
pub struct AzStyleBorderTopRightRadiusValueEnumWrapper {
    pub inner: AzStyleBorderTopRightRadiusValue,
}

/// Type alias for CssPropertyValue < StyleBorderTopStyle >
#[pyclass(name = "StyleBorderTopStyleValue")]
#[repr(transparent)]
pub struct AzStyleBorderTopStyleValueEnumWrapper {
    pub inner: AzStyleBorderTopStyleValue,
}

/// Type alias for CssPropertyValue < LayoutBorderTopWidth >
#[pyclass(name = "LayoutBorderTopWidthValue")]
#[repr(transparent)]
pub struct AzLayoutBorderTopWidthValueEnumWrapper {
    pub inner: AzLayoutBorderTopWidthValue,
}

/// Type alias for CssPropertyValue < StyleCursor >
#[pyclass(name = "StyleCursorValue")]
#[repr(transparent)]
pub struct AzStyleCursorValueEnumWrapper {
    pub inner: AzStyleCursorValue,
}

/// Type alias for CssPropertyValue < StyleFontFamilyVec >
#[pyclass(name = "StyleFontFamilyVecValue")]
#[repr(transparent)]
pub struct AzStyleFontFamilyVecValueEnumWrapper {
    pub inner: AzStyleFontFamilyVecValue,
}

/// Type alias for CssPropertyValue < StyleFontSize >
#[pyclass(name = "StyleFontSizeValue")]
#[repr(transparent)]
pub struct AzStyleFontSizeValueEnumWrapper {
    pub inner: AzStyleFontSizeValue,
}

/// Type alias for CssPropertyValue < StyleLetterSpacing >
#[pyclass(name = "StyleLetterSpacingValue")]
#[repr(transparent)]
pub struct AzStyleLetterSpacingValueEnumWrapper {
    pub inner: AzStyleLetterSpacingValue,
}

/// Type alias for CssPropertyValue < StyleLineHeight >
#[pyclass(name = "StyleLineHeightValue")]
#[repr(transparent)]
pub struct AzStyleLineHeightValueEnumWrapper {
    pub inner: AzStyleLineHeightValue,
}

/// Type alias for CssPropertyValue < StyleTabWidth >
#[pyclass(name = "StyleTabWidthValue")]
#[repr(transparent)]
pub struct AzStyleTabWidthValueEnumWrapper {
    pub inner: AzStyleTabWidthValue,
}

/// Type alias for CssPropertyValue < StyleTextAlign >
#[pyclass(name = "StyleTextAlignValue")]
#[repr(transparent)]
pub struct AzStyleTextAlignValueEnumWrapper {
    pub inner: AzStyleTextAlignValue,
}

/// Type alias for CssPropertyValue < StyleTextColor >
#[pyclass(name = "StyleTextColorValue")]
#[repr(transparent)]
pub struct AzStyleTextColorValueEnumWrapper {
    pub inner: AzStyleTextColorValue,
}

/// Type alias for CssPropertyValue < StyleWordSpacing >
#[pyclass(name = "StyleWordSpacingValue")]
#[repr(transparent)]
pub struct AzStyleWordSpacingValueEnumWrapper {
    pub inner: AzStyleWordSpacingValue,
}

/// Type alias for CssPropertyValue < StyleOpacity >
#[pyclass(name = "StyleOpacityValue")]
#[repr(transparent)]
pub struct AzStyleOpacityValueEnumWrapper {
    pub inner: AzStyleOpacityValue,
}

/// Type alias for CssPropertyValue < StyleTransformVec >
#[pyclass(name = "StyleTransformVecValue")]
#[repr(transparent)]
pub struct AzStyleTransformVecValueEnumWrapper {
    pub inner: AzStyleTransformVecValue,
}

/// Type alias for CssPropertyValue < StyleTransformOrigin >
#[pyclass(name = "StyleTransformOriginValue")]
#[repr(transparent)]
pub struct AzStyleTransformOriginValueEnumWrapper {
    pub inner: AzStyleTransformOriginValue,
}

/// Type alias for CssPropertyValue < StylePerspectiveOrigin >
#[pyclass(name = "StylePerspectiveOriginValue")]
#[repr(transparent)]
pub struct AzStylePerspectiveOriginValueEnumWrapper {
    pub inner: AzStylePerspectiveOriginValue,
}

/// Type alias for CssPropertyValue < StyleBackfaceVisibility >
#[pyclass(name = "StyleBackfaceVisibilityValue")]
#[repr(transparent)]
pub struct AzStyleBackfaceVisibilityValueEnumWrapper {
    pub inner: AzStyleBackfaceVisibilityValue,
}

/// Type alias for CssPropertyValue < StyleMixBlendMode >
#[pyclass(name = "StyleMixBlendModeValue")]
#[repr(transparent)]
pub struct AzStyleMixBlendModeValueEnumWrapper {
    pub inner: AzStyleMixBlendModeValue,
}

/// Type alias for CssPropertyValue < StyleFilterVec >
#[pyclass(name = "StyleFilterVecValue")]
#[repr(transparent)]
pub struct AzStyleFilterVecValueEnumWrapper {
    pub inner: AzStyleFilterVecValue,
}

/// Generic CSS property value that can be Auto, None, Initial, Inherit, or an exact value
#[pyclass(name = "CssPropertyValue")]
#[repr(transparent)]
pub struct AzCssPropertyValueEnumWrapper {
    pub inner: AzCssPropertyValue,
}

/// Represents a grid line position (start or end)
#[pyclass(name = "GridLine")]
#[repr(transparent)]
pub struct AzGridLineEnumWrapper {
    pub inner: AzGridLine,
}

/// Represents a `z-index` attribute - controls stacking order of positioned elements
#[pyclass(name = "LayoutZIndex")]
#[repr(transparent)]
pub struct AzLayoutZIndexEnumWrapper {
    pub inner: AzLayoutZIndex,
}

/// Represents `justify-items` for grid containers
#[pyclass(name = "LayoutJustifyItems")]
#[repr(transparent)]
pub struct AzLayoutJustifyItemsEnumWrapper {
    pub inner: AzLayoutJustifyItems,
}

/// Represents the detected platform.
#[pyclass(name = "Platform")]
#[repr(transparent)]
pub struct AzPlatformEnumWrapper {
    pub inner: AzPlatform,
}

/// `AzColumnSpan` enum
#[pyclass(name = "ColumnSpan")]
#[repr(transparent)]
pub struct AzColumnSpanEnumWrapper {
    pub inner: AzColumnSpan,
}

/// Represents a `clear` attribute
#[pyclass(name = "LayoutClear")]
#[repr(transparent)]
pub struct AzLayoutClearEnumWrapper {
    pub inner: AzLayoutClear,
}

/// How to handle white space inside an element.
#[pyclass(name = "StyleWhiteSpace")]
#[repr(transparent)]
pub struct AzStyleWhiteSpaceEnumWrapper {
    pub inner: AzStyleWhiteSpace,
}

/// Represents a `break-inside` CSS property value.
#[pyclass(name = "BreakInside")]
#[repr(transparent)]
pub struct AzBreakInsideEnumWrapper {
    pub inner: AzBreakInside,
}

/// Represents an `align-self` attribute, which allows the default alignment (or the one specified by align-items) to be overridden for individual flex items. Default: `Auto`
#[pyclass(name = "LayoutAlignSelf")]
#[repr(transparent)]
pub struct AzLayoutAlignSelfEnumWrapper {
    pub inner: AzLayoutAlignSelf,
}

/// `AzShapeOutside` enum
#[pyclass(name = "ShapeOutside")]
#[repr(transparent)]
pub struct AzShapeOutsideEnumWrapper {
    pub inner: AzShapeOutside,
}

/// Represents the detected Linux Desktop Environment.
#[pyclass(name = "DesktopEnvironment")]
#[repr(transparent)]
pub struct AzDesktopEnvironmentEnumWrapper {
    pub inner: AzDesktopEnvironment,
}

/// `AzColumnCount` enum
#[pyclass(name = "ColumnCount")]
#[repr(transparent)]
pub struct AzColumnCountEnumWrapper {
    pub inner: AzColumnCount,
}

/// Represents a `writing-mode` attribute
#[pyclass(name = "LayoutWritingMode")]
#[repr(transparent)]
pub struct AzLayoutWritingModeEnumWrapper {
    pub inner: AzLayoutWritingMode,
}

/// Controls whether the user can select text. Used to prevent accidental text selection on UI controls like buttons.
#[pyclass(name = "StyleUserSelect")]
#[repr(transparent)]
pub struct AzStyleUserSelectEnumWrapper {
    pub inner: AzStyleUserSelect,
}

/// `AzFlowInto` enum
#[pyclass(name = "FlowInto")]
#[repr(transparent)]
pub struct AzFlowIntoEnumWrapper {
    pub inner: AzFlowInto,
}

/// Represents `justify-self` for grid items
#[pyclass(name = "LayoutJustifySelf")]
#[repr(transparent)]
pub struct AzLayoutJustifySelfEnumWrapper {
    pub inner: AzLayoutJustifySelf,
}

/// Hyphenation rules.
#[pyclass(name = "StyleHyphens")]
#[repr(transparent)]
pub struct AzStyleHyphensEnumWrapper {
    pub inner: AzStyleHyphens,
}

/// Text direction.
#[pyclass(name = "StyleDirection")]
#[repr(transparent)]
pub struct AzStyleDirectionEnumWrapper {
    pub inner: AzStyleDirection,
}

/// Represents a `flex-basis` attribute
#[pyclass(name = "LayoutFlexBasis")]
#[repr(transparent)]
pub struct AzLayoutFlexBasisEnumWrapper {
    pub inner: AzLayoutFlexBasis,
}

/// `AzLayoutTextJustify` enum
#[pyclass(name = "LayoutTextJustify")]
#[repr(transparent)]
pub struct AzLayoutTextJustifyEnumWrapper {
    pub inner: AzLayoutTextJustify,
}

/// `AzColumnWidth` enum
#[pyclass(name = "ColumnWidth")]
#[repr(transparent)]
pub struct AzColumnWidthEnumWrapper {
    pub inner: AzColumnWidth,
}

/// Represents a `box-decoration-break` CSS property value.
#[pyclass(name = "BoxDecorationBreak")]
#[repr(transparent)]
pub struct AzBoxDecorationBreakEnumWrapper {
    pub inner: AzBoxDecorationBreak,
}

/// Represents a `visibility` attribute, controlling element visibility.
#[pyclass(name = "StyleVisibility")]
#[repr(transparent)]
pub struct AzStyleVisibilityEnumWrapper {
    pub inner: AzStyleVisibility,
}

/// The overall theme type.
#[pyclass(name = "Theme")]
#[repr(transparent)]
pub struct AzThemeEnumWrapper {
    pub inner: AzTheme,
}

/// Represents the `grid-auto-flow` property
#[pyclass(name = "LayoutGridAutoFlow")]
#[repr(transparent)]
pub struct AzLayoutGridAutoFlowEnumWrapper {
    pub inner: AzLayoutGridAutoFlow,
}

/// Text decoration (underline, overline, line-through).
#[pyclass(name = "StyleTextDecoration")]
#[repr(transparent)]
pub struct AzStyleTextDecorationEnumWrapper {
    pub inner: AzStyleTextDecoration,
}

/// `AzColumnFill` enum
#[pyclass(name = "ColumnFill")]
#[repr(transparent)]
pub struct AzColumnFillEnumWrapper {
    pub inner: AzColumnFill,
}

/// `AzFlowFrom` enum
#[pyclass(name = "FlowFrom")]
#[repr(transparent)]
pub struct AzFlowFromEnumWrapper {
    pub inner: AzFlowFrom,
}

/// Represents a `break-before` or `break-after` CSS property value.
#[pyclass(name = "PageBreak")]
#[repr(transparent)]
pub struct AzPageBreakEnumWrapper {
    pub inner: AzPageBreak,
}

/// Represents the standard `scrollbar-width` property.
#[pyclass(name = "LayoutScrollbarWidth")]
#[repr(transparent)]
pub struct AzLayoutScrollbarWidthEnumWrapper {
    pub inner: AzLayoutScrollbarWidth,
}

/// Represents the standard `scrollbar-color` property.
#[pyclass(name = "StyleScrollbarColor")]
#[repr(transparent)]
pub struct AzStyleScrollbarColorEnumWrapper {
    pub inner: AzStyleScrollbarColor,
}

/// `AzTextInputSelection` enum
#[pyclass(name = "TextInputSelection")]
#[repr(transparent)]
pub struct AzTextInputSelectionEnumWrapper {
    pub inner: AzTextInputSelection,
}

/// `AzTextInputValid` enum
#[pyclass(name = "TextInputValid")]
#[repr(transparent)]
pub struct AzTextInputValidEnumWrapper {
    pub inner: AzTextInputValid,
}

/// `AzNodeGraphStyle` enum
#[pyclass(name = "NodeGraphStyle")]
#[repr(transparent)]
pub struct AzNodeGraphStyleEnumWrapper {
    pub inner: AzNodeGraphStyle,
}

/// `AzNodeTypeFieldValue` enum
#[pyclass(name = "NodeTypeFieldValue")]
#[repr(transparent)]
pub struct AzNodeTypeFieldValueEnumWrapper {
    pub inner: AzNodeTypeFieldValue,
}

/// `AzCssPropertySource` enum
#[pyclass(name = "CssPropertySource")]
#[repr(transparent)]
pub struct AzCssPropertySourceEnumWrapper {
    pub inner: AzCssPropertySource,
}

/// `AzVertexAttributeType` enum
#[pyclass(name = "VertexAttributeType")]
#[repr(transparent)]
pub struct AzVertexAttributeTypeEnumWrapper {
    pub inner: AzVertexAttributeType,
}

/// `AzIndexBufferFormat` enum
#[pyclass(name = "IndexBufferFormat")]
#[repr(transparent)]
pub struct AzIndexBufferFormatEnumWrapper {
    pub inner: AzIndexBufferFormat,
}

/// `AzAzGlType` enum
#[pyclass(name = "AzGlType")]
#[repr(transparent)]
pub struct AzAzGlTypeEnumWrapper {
    pub inner: AzAzGlType,
}

/// `AzRawImageFormat` enum
#[pyclass(name = "RawImageFormat")]
#[repr(transparent)]
pub struct AzRawImageFormatEnumWrapper {
    pub inner: AzRawImageFormat,
}

/// `AzEncodeImageError` enum
#[pyclass(name = "EncodeImageError")]
#[repr(transparent)]
pub struct AzEncodeImageErrorEnumWrapper {
    pub inner: AzEncodeImageError,
}

/// `AzDecodeImageError` enum
#[pyclass(name = "DecodeImageError")]
#[repr(transparent)]
pub struct AzDecodeImageErrorEnumWrapper {
    pub inner: AzDecodeImageError,
}

/// `AzRawImageData` enum
#[pyclass(name = "RawImageData")]
#[repr(transparent)]
pub struct AzRawImageDataEnumWrapper {
    pub inner: AzRawImageData,
}

/// One `SvgNode` corresponds to one SVG `<path></path>` element
#[pyclass(name = "SvgNode")]
#[repr(transparent)]
pub struct AzSvgNodeEnumWrapper {
    pub inner: AzSvgNode,
}

/// One `SvgSimpleNode` is either a path, a rect or a circle
#[pyclass(name = "SvgSimpleNode")]
#[repr(transparent)]
pub struct AzSvgSimpleNodeEnumWrapper {
    pub inner: AzSvgSimpleNode,
}

/// `AzSvgPathElement` enum
#[pyclass(name = "SvgPathElement")]
#[repr(transparent)]
pub struct AzSvgPathElementEnumWrapper {
    pub inner: AzSvgPathElement,
}

/// `AzShapeRendering` enum
#[pyclass(name = "ShapeRendering")]
#[repr(transparent)]
pub struct AzShapeRenderingEnumWrapper {
    pub inner: AzShapeRendering,
}

/// `AzTextRendering` enum
#[pyclass(name = "TextRendering")]
#[repr(transparent)]
pub struct AzTextRenderingEnumWrapper {
    pub inner: AzTextRendering,
}

/// `AzImageRendering` enum
#[pyclass(name = "ImageRendering")]
#[repr(transparent)]
pub struct AzImageRenderingEnumWrapper {
    pub inner: AzImageRendering,
}

/// `AzFontDatabase` enum
#[pyclass(name = "FontDatabase")]
#[repr(transparent)]
pub struct AzFontDatabaseEnumWrapper {
    pub inner: AzFontDatabase,
}

/// `AzIndent` enum
#[pyclass(name = "Indent")]
#[repr(transparent)]
pub struct AzIndentEnumWrapper {
    pub inner: AzIndent,
}

/// `AzSvgFitTo` enum
#[pyclass(name = "SvgFitTo")]
#[repr(transparent)]
pub struct AzSvgFitToEnumWrapper {
    pub inner: AzSvgFitTo,
}

/// `AzSvgStyle` enum
#[pyclass(name = "SvgStyle")]
#[repr(transparent)]
pub struct AzSvgStyleEnumWrapper {
    pub inner: AzSvgStyle,
}

/// `AzSvgFillRule` enum
#[pyclass(name = "SvgFillRule")]
#[repr(transparent)]
pub struct AzSvgFillRuleEnumWrapper {
    pub inner: AzSvgFillRule,
}

/// `AzSvgLineJoin` enum
#[pyclass(name = "SvgLineJoin")]
#[repr(transparent)]
pub struct AzSvgLineJoinEnumWrapper {
    pub inner: AzSvgLineJoin,
}

/// `AzSvgLineCap` enum
#[pyclass(name = "SvgLineCap")]
#[repr(transparent)]
pub struct AzSvgLineCapEnumWrapper {
    pub inner: AzSvgLineCap,
}

/// `AzSvgParseError` enum
#[pyclass(name = "SvgParseError")]
#[repr(transparent)]
pub struct AzSvgParseErrorEnumWrapper {
    pub inner: AzSvgParseError,
}

/// Type of message box icon
#[pyclass(name = "MsgBoxIcon")]
#[repr(transparent)]
pub struct AzMsgBoxIconEnumWrapper {
    pub inner: AzMsgBoxIcon,
}

/// Value returned from a yes / no message box
#[pyclass(name = "YesNo")]
#[repr(transparent)]
pub struct AzYesNoEnumWrapper {
    pub inner: AzYesNo,
}

/// Value returned from an ok / cancel message box
#[pyclass(name = "OkCancel")]
#[repr(transparent)]
pub struct AzOkCancelEnumWrapper {
    pub inner: AzOkCancel,
}

/// `AzInstant` enum
#[pyclass(name = "Instant")]
#[repr(transparent)]
pub struct AzInstantEnumWrapper {
    pub inner: AzInstant,
}

/// `AzDuration` enum
#[pyclass(name = "Duration")]
#[repr(transparent)]
pub struct AzDurationEnumWrapper {
    pub inner: AzDuration,
}

/// Should a timer terminate or not - used to remove active timers
#[pyclass(name = "TerminateTimer")]
#[repr(transparent)]
pub struct AzTerminateTimerEnumWrapper {
    pub inner: AzTerminateTimer,
}

/// Message that can be sent from the main thread to the Thread using the ThreadId. The thread can ignore the event.
#[pyclass(name = "ThreadSendMsg")]
#[repr(transparent)]
pub struct AzThreadSendMsgEnumWrapper {
    pub inner: AzThreadSendMsg,
}

/// `AzThreadReceiveMsg` enum
#[pyclass(name = "ThreadReceiveMsg")]
#[repr(transparent)]
pub struct AzThreadReceiveMsgEnumWrapper {
    pub inner: AzThreadReceiveMsg,
}

/// `AzFmtValue` enum
#[pyclass(name = "FmtValue")]
#[repr(transparent)]
pub struct AzFmtValueEnumWrapper {
    pub inner: AzFmtValue,
}

/// `AzStyleFontFamilyVecDestructor` enum
#[pyclass(name = "StyleFontFamilyVecDestructor")]
#[repr(transparent)]
pub struct AzStyleFontFamilyVecDestructorEnumWrapper {
    pub inner: AzStyleFontFamilyVecDestructor,
}

/// `AzListViewRowVecDestructor` enum
#[pyclass(name = "ListViewRowVecDestructor")]
#[repr(transparent)]
pub struct AzListViewRowVecDestructorEnumWrapper {
    pub inner: AzListViewRowVecDestructor,
}

/// `AzStyleFilterVecDestructor` enum
#[pyclass(name = "StyleFilterVecDestructor")]
#[repr(transparent)]
pub struct AzStyleFilterVecDestructorEnumWrapper {
    pub inner: AzStyleFilterVecDestructor,
}

/// `AzLogicalRectVecDestructor` enum
#[pyclass(name = "LogicalRectVecDestructor")]
#[repr(transparent)]
pub struct AzLogicalRectVecDestructorEnumWrapper {
    pub inner: AzLogicalRectVecDestructor,
}

/// `AzNodeTypeIdInfoMapVecDestructor` enum
#[pyclass(name = "NodeTypeIdInfoMapVecDestructor")]
#[repr(transparent)]
pub struct AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
    pub inner: AzNodeTypeIdInfoMapVecDestructor,
}

/// `AzInputOutputTypeIdInfoMapVecDestructor` enum
#[pyclass(name = "InputOutputTypeIdInfoMapVecDestructor")]
#[repr(transparent)]
pub struct AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
    pub inner: AzInputOutputTypeIdInfoMapVecDestructor,
}

/// `AzNodeIdNodeMapVecDestructor` enum
#[pyclass(name = "NodeIdNodeMapVecDestructor")]
#[repr(transparent)]
pub struct AzNodeIdNodeMapVecDestructorEnumWrapper {
    pub inner: AzNodeIdNodeMapVecDestructor,
}

/// `AzInputOutputTypeIdVecDestructor` enum
#[pyclass(name = "InputOutputTypeIdVecDestructor")]
#[repr(transparent)]
pub struct AzInputOutputTypeIdVecDestructorEnumWrapper {
    pub inner: AzInputOutputTypeIdVecDestructor,
}

/// `AzNodeTypeFieldVecDestructor` enum
#[pyclass(name = "NodeTypeFieldVecDestructor")]
#[repr(transparent)]
pub struct AzNodeTypeFieldVecDestructorEnumWrapper {
    pub inner: AzNodeTypeFieldVecDestructor,
}

/// `AzInputConnectionVecDestructor` enum
#[pyclass(name = "InputConnectionVecDestructor")]
#[repr(transparent)]
pub struct AzInputConnectionVecDestructorEnumWrapper {
    pub inner: AzInputConnectionVecDestructor,
}

/// `AzOutputNodeAndIndexVecDestructor` enum
#[pyclass(name = "OutputNodeAndIndexVecDestructor")]
#[repr(transparent)]
pub struct AzOutputNodeAndIndexVecDestructorEnumWrapper {
    pub inner: AzOutputNodeAndIndexVecDestructor,
}

/// `AzOutputConnectionVecDestructor` enum
#[pyclass(name = "OutputConnectionVecDestructor")]
#[repr(transparent)]
pub struct AzOutputConnectionVecDestructorEnumWrapper {
    pub inner: AzOutputConnectionVecDestructor,
}

/// `AzInputNodeAndIndexVecDestructor` enum
#[pyclass(name = "InputNodeAndIndexVecDestructor")]
#[repr(transparent)]
pub struct AzInputNodeAndIndexVecDestructorEnumWrapper {
    pub inner: AzInputNodeAndIndexVecDestructor,
}

/// `AzAccessibilityStateVecDestructor` enum
#[pyclass(name = "AccessibilityStateVecDestructor")]
#[repr(transparent)]
pub struct AzAccessibilityStateVecDestructorEnumWrapper {
    pub inner: AzAccessibilityStateVecDestructor,
}

/// `AzMenuItemVecDestructor` enum
#[pyclass(name = "MenuItemVecDestructor")]
#[repr(transparent)]
pub struct AzMenuItemVecDestructorEnumWrapper {
    pub inner: AzMenuItemVecDestructor,
}

/// `AzTessellatedSvgNodeVecDestructor` enum
#[pyclass(name = "TessellatedSvgNodeVecDestructor")]
#[repr(transparent)]
pub struct AzTessellatedSvgNodeVecDestructorEnumWrapper {
    pub inner: AzTessellatedSvgNodeVecDestructor,
}

/// `AzTessellatedColoredSvgNodeVecDestructor` enum
#[pyclass(name = "TessellatedColoredSvgNodeVecDestructor")]
#[repr(transparent)]
pub struct AzTessellatedColoredSvgNodeVecDestructorEnumWrapper {
    pub inner: AzTessellatedColoredSvgNodeVecDestructor,
}

/// `AzXmlNodeVecDestructor` enum
#[pyclass(name = "XmlNodeVecDestructor")]
#[repr(transparent)]
pub struct AzXmlNodeVecDestructorEnumWrapper {
    pub inner: AzXmlNodeVecDestructor,
}

/// `AzFmtArgVecDestructor` enum
#[pyclass(name = "FmtArgVecDestructor")]
#[repr(transparent)]
pub struct AzFmtArgVecDestructorEnumWrapper {
    pub inner: AzFmtArgVecDestructor,
}

/// `AzInlineLineVecDestructor` enum
#[pyclass(name = "InlineLineVecDestructor")]
#[repr(transparent)]
pub struct AzInlineLineVecDestructorEnumWrapper {
    pub inner: AzInlineLineVecDestructor,
}

/// `AzInlineWordVecDestructor` enum
#[pyclass(name = "InlineWordVecDestructor")]
#[repr(transparent)]
pub struct AzInlineWordVecDestructorEnumWrapper {
    pub inner: AzInlineWordVecDestructor,
}

/// `AzInlineGlyphVecDestructor` enum
#[pyclass(name = "InlineGlyphVecDestructor")]
#[repr(transparent)]
pub struct AzInlineGlyphVecDestructorEnumWrapper {
    pub inner: AzInlineGlyphVecDestructor,
}

/// `AzInlineTextHitVecDestructor` enum
#[pyclass(name = "InlineTextHitVecDestructor")]
#[repr(transparent)]
pub struct AzInlineTextHitVecDestructorEnumWrapper {
    pub inner: AzInlineTextHitVecDestructor,
}

/// `AzMonitorVecDestructor` enum
#[pyclass(name = "MonitorVecDestructor")]
#[repr(transparent)]
pub struct AzMonitorVecDestructorEnumWrapper {
    pub inner: AzMonitorVecDestructor,
}

/// `AzVideoModeVecDestructor` enum
#[pyclass(name = "VideoModeVecDestructor")]
#[repr(transparent)]
pub struct AzVideoModeVecDestructorEnumWrapper {
    pub inner: AzVideoModeVecDestructor,
}

/// `AzDomVecDestructor` enum
#[pyclass(name = "DomVecDestructor")]
#[repr(transparent)]
pub struct AzDomVecDestructorEnumWrapper {
    pub inner: AzDomVecDestructor,
}

/// `AzIdOrClassVecDestructor` enum
#[pyclass(name = "IdOrClassVecDestructor")]
#[repr(transparent)]
pub struct AzIdOrClassVecDestructorEnumWrapper {
    pub inner: AzIdOrClassVecDestructor,
}

/// `AzNodeDataInlineCssPropertyVecDestructor` enum
#[pyclass(name = "NodeDataInlineCssPropertyVecDestructor")]
#[repr(transparent)]
pub struct AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
    pub inner: AzNodeDataInlineCssPropertyVecDestructor,
}

/// `AzStyleBackgroundContentVecDestructor` enum
#[pyclass(name = "StyleBackgroundContentVecDestructor")]
#[repr(transparent)]
pub struct AzStyleBackgroundContentVecDestructorEnumWrapper {
    pub inner: AzStyleBackgroundContentVecDestructor,
}

/// `AzStyleBackgroundPositionVecDestructor` enum
#[pyclass(name = "StyleBackgroundPositionVecDestructor")]
#[repr(transparent)]
pub struct AzStyleBackgroundPositionVecDestructorEnumWrapper {
    pub inner: AzStyleBackgroundPositionVecDestructor,
}

/// `AzStyleBackgroundRepeatVecDestructor` enum
#[pyclass(name = "StyleBackgroundRepeatVecDestructor")]
#[repr(transparent)]
pub struct AzStyleBackgroundRepeatVecDestructorEnumWrapper {
    pub inner: AzStyleBackgroundRepeatVecDestructor,
}

/// `AzStyleBackgroundSizeVecDestructor` enum
#[pyclass(name = "StyleBackgroundSizeVecDestructor")]
#[repr(transparent)]
pub struct AzStyleBackgroundSizeVecDestructorEnumWrapper {
    pub inner: AzStyleBackgroundSizeVecDestructor,
}

/// `AzStyleTransformVecDestructor` enum
#[pyclass(name = "StyleTransformVecDestructor")]
#[repr(transparent)]
pub struct AzStyleTransformVecDestructorEnumWrapper {
    pub inner: AzStyleTransformVecDestructor,
}

/// `AzCssPropertyVecDestructor` enum
#[pyclass(name = "CssPropertyVecDestructor")]
#[repr(transparent)]
pub struct AzCssPropertyVecDestructorEnumWrapper {
    pub inner: AzCssPropertyVecDestructor,
}

/// `AzSvgMultiPolygonVecDestructor` enum
#[pyclass(name = "SvgMultiPolygonVecDestructor")]
#[repr(transparent)]
pub struct AzSvgMultiPolygonVecDestructorEnumWrapper {
    pub inner: AzSvgMultiPolygonVecDestructor,
}

/// `AzSvgSimpleNodeVecDestructor` enum
#[pyclass(name = "SvgSimpleNodeVecDestructor")]
#[repr(transparent)]
pub struct AzSvgSimpleNodeVecDestructorEnumWrapper {
    pub inner: AzSvgSimpleNodeVecDestructor,
}

/// `AzSvgPathVecDestructor` enum
#[pyclass(name = "SvgPathVecDestructor")]
#[repr(transparent)]
pub struct AzSvgPathVecDestructorEnumWrapper {
    pub inner: AzSvgPathVecDestructor,
}

/// `AzVertexAttributeVecDestructor` enum
#[pyclass(name = "VertexAttributeVecDestructor")]
#[repr(transparent)]
pub struct AzVertexAttributeVecDestructorEnumWrapper {
    pub inner: AzVertexAttributeVecDestructor,
}

/// `AzSvgPathElementVecDestructor` enum
#[pyclass(name = "SvgPathElementVecDestructor")]
#[repr(transparent)]
pub struct AzSvgPathElementVecDestructorEnumWrapper {
    pub inner: AzSvgPathElementVecDestructor,
}

/// `AzSvgVertexVecDestructor` enum
#[pyclass(name = "SvgVertexVecDestructor")]
#[repr(transparent)]
pub struct AzSvgVertexVecDestructorEnumWrapper {
    pub inner: AzSvgVertexVecDestructor,
}

/// `AzSvgColoredVertexVecDestructor` enum
#[pyclass(name = "SvgColoredVertexVecDestructor")]
#[repr(transparent)]
pub struct AzSvgColoredVertexVecDestructorEnumWrapper {
    pub inner: AzSvgColoredVertexVecDestructor,
}

/// `AzU32VecDestructor` enum
#[pyclass(name = "U32VecDestructor")]
#[repr(transparent)]
pub struct AzU32VecDestructorEnumWrapper {
    pub inner: AzU32VecDestructor,
}

/// `AzXWindowTypeVecDestructor` enum
#[pyclass(name = "XWindowTypeVecDestructor")]
#[repr(transparent)]
pub struct AzXWindowTypeVecDestructorEnumWrapper {
    pub inner: AzXWindowTypeVecDestructor,
}

/// `AzVirtualKeyCodeVecDestructor` enum
#[pyclass(name = "VirtualKeyCodeVecDestructor")]
#[repr(transparent)]
pub struct AzVirtualKeyCodeVecDestructorEnumWrapper {
    pub inner: AzVirtualKeyCodeVecDestructor,
}

/// `AzCascadeInfoVecDestructor` enum
#[pyclass(name = "CascadeInfoVecDestructor")]
#[repr(transparent)]
pub struct AzCascadeInfoVecDestructorEnumWrapper {
    pub inner: AzCascadeInfoVecDestructor,
}

/// `AzScanCodeVecDestructor` enum
#[pyclass(name = "ScanCodeVecDestructor")]
#[repr(transparent)]
pub struct AzScanCodeVecDestructorEnumWrapper {
    pub inner: AzScanCodeVecDestructor,
}

/// `AzCssDeclarationVecDestructor` enum
#[pyclass(name = "CssDeclarationVecDestructor")]
#[repr(transparent)]
pub struct AzCssDeclarationVecDestructorEnumWrapper {
    pub inner: AzCssDeclarationVecDestructor,
}

/// `AzCssPathSelectorVecDestructor` enum
#[pyclass(name = "CssPathSelectorVecDestructor")]
#[repr(transparent)]
pub struct AzCssPathSelectorVecDestructorEnumWrapper {
    pub inner: AzCssPathSelectorVecDestructor,
}

/// `AzStylesheetVecDestructor` enum
#[pyclass(name = "StylesheetVecDestructor")]
#[repr(transparent)]
pub struct AzStylesheetVecDestructorEnumWrapper {
    pub inner: AzStylesheetVecDestructor,
}

/// `AzCssRuleBlockVecDestructor` enum
#[pyclass(name = "CssRuleBlockVecDestructor")]
#[repr(transparent)]
pub struct AzCssRuleBlockVecDestructorEnumWrapper {
    pub inner: AzCssRuleBlockVecDestructor,
}

/// `AzF32VecDestructor` enum
#[pyclass(name = "F32VecDestructor")]
#[repr(transparent)]
pub struct AzF32VecDestructorEnumWrapper {
    pub inner: AzF32VecDestructor,
}

/// `AzU16VecDestructor` enum
#[pyclass(name = "U16VecDestructor")]
#[repr(transparent)]
pub struct AzU16VecDestructorEnumWrapper {
    pub inner: AzU16VecDestructor,
}

/// `AzU8VecDestructor` enum
#[pyclass(name = "U8VecDestructor")]
#[repr(transparent)]
pub struct AzU8VecDestructorEnumWrapper {
    pub inner: AzU8VecDestructor,
}

/// `AzCallbackDataVecDestructor` enum
#[pyclass(name = "CallbackDataVecDestructor")]
#[repr(transparent)]
pub struct AzCallbackDataVecDestructorEnumWrapper {
    pub inner: AzCallbackDataVecDestructor,
}

/// `AzGLuintVecDestructor` enum
#[pyclass(name = "GLuintVecDestructor")]
#[repr(transparent)]
pub struct AzGLuintVecDestructorEnumWrapper {
    pub inner: AzGLuintVecDestructor,
}

/// `AzGLintVecDestructor` enum
#[pyclass(name = "GLintVecDestructor")]
#[repr(transparent)]
pub struct AzGLintVecDestructorEnumWrapper {
    pub inner: AzGLintVecDestructor,
}

/// `AzStringVecDestructor` enum
#[pyclass(name = "StringVecDestructor")]
#[repr(transparent)]
pub struct AzStringVecDestructorEnumWrapper {
    pub inner: AzStringVecDestructor,
}

/// `AzStringPairVecDestructor` enum
#[pyclass(name = "StringPairVecDestructor")]
#[repr(transparent)]
pub struct AzStringPairVecDestructorEnumWrapper {
    pub inner: AzStringPairVecDestructor,
}

/// `AzNormalizedLinearColorStopVecDestructor` enum
#[pyclass(name = "NormalizedLinearColorStopVecDestructor")]
#[repr(transparent)]
pub struct AzNormalizedLinearColorStopVecDestructorEnumWrapper {
    pub inner: AzNormalizedLinearColorStopVecDestructor,
}

/// `AzNormalizedRadialColorStopVecDestructor` enum
#[pyclass(name = "NormalizedRadialColorStopVecDestructor")]
#[repr(transparent)]
pub struct AzNormalizedRadialColorStopVecDestructorEnumWrapper {
    pub inner: AzNormalizedRadialColorStopVecDestructor,
}

/// `AzNodeIdVecDestructor` enum
#[pyclass(name = "NodeIdVecDestructor")]
#[repr(transparent)]
pub struct AzNodeIdVecDestructorEnumWrapper {
    pub inner: AzNodeIdVecDestructor,
}

/// `AzNodeHierarchyItemVecDestructor` enum
#[pyclass(name = "NodeHierarchyItemVecDestructor")]
#[repr(transparent)]
pub struct AzNodeHierarchyItemVecDestructorEnumWrapper {
    pub inner: AzNodeHierarchyItemVecDestructor,
}

/// `AzStyledNodeVecDestructor` enum
#[pyclass(name = "StyledNodeVecDestructor")]
#[repr(transparent)]
pub struct AzStyledNodeVecDestructorEnumWrapper {
    pub inner: AzStyledNodeVecDestructor,
}

/// `AzTagIdToNodeIdMappingVecDestructor` enum
#[pyclass(name = "TagIdToNodeIdMappingVecDestructor")]
#[repr(transparent)]
pub struct AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
    pub inner: AzTagIdToNodeIdMappingVecDestructor,
}

/// `AzParentWithNodeDepthVecDestructor` enum
#[pyclass(name = "ParentWithNodeDepthVecDestructor")]
#[repr(transparent)]
pub struct AzParentWithNodeDepthVecDestructorEnumWrapper {
    pub inner: AzParentWithNodeDepthVecDestructor,
}

/// `AzNodeDataVecDestructor` enum
#[pyclass(name = "NodeDataVecDestructor")]
#[repr(transparent)]
pub struct AzNodeDataVecDestructorEnumWrapper {
    pub inner: AzNodeDataVecDestructor,
}

/// `AzAzDebugMessageVecDestructor` enum
#[pyclass(name = "AzDebugMessageVecDestructor")]
#[repr(transparent)]
pub struct AzAzDebugMessageVecDestructorEnumWrapper {
    pub inner: AzAzDebugMessageVecDestructor,
}

/// `AzOptionSvgPoint` enum
#[pyclass(name = "OptionSvgPoint")]
#[repr(transparent)]
pub struct AzOptionSvgPointEnumWrapper {
    pub inner: AzOptionSvgPoint,
}

/// `AzOptionStyleTextAlign` enum
#[pyclass(name = "OptionStyleTextAlign")]
#[repr(transparent)]
pub struct AzOptionStyleTextAlignEnumWrapper {
    pub inner: AzOptionStyleTextAlign,
}

/// `AzOptionListViewOnRowClick` enum
#[pyclass(name = "OptionListViewOnRowClick")]
#[repr(transparent)]
pub struct AzOptionListViewOnRowClickEnumWrapper {
    pub inner: AzOptionListViewOnRowClick,
}

/// `AzOptionListViewOnColumnClick` enum
#[pyclass(name = "OptionListViewOnColumnClick")]
#[repr(transparent)]
pub struct AzOptionListViewOnColumnClickEnumWrapper {
    pub inner: AzOptionListViewOnColumnClick,
}

/// `AzOptionListViewOnLazyLoadScroll` enum
#[pyclass(name = "OptionListViewOnLazyLoadScroll")]
#[repr(transparent)]
pub struct AzOptionListViewOnLazyLoadScrollEnumWrapper {
    pub inner: AzOptionListViewOnLazyLoadScroll,
}

/// `AzOptionMenu` enum
#[pyclass(name = "OptionMenu")]
#[repr(transparent)]
pub struct AzOptionMenuEnumWrapper {
    pub inner: AzOptionMenu,
}

/// `AzOptionPixelValueNoPercent` enum
#[pyclass(name = "OptionPixelValueNoPercent")]
#[repr(transparent)]
pub struct AzOptionPixelValueNoPercentEnumWrapper {
    pub inner: AzOptionPixelValueNoPercent,
}

/// `AzOptionDropDownOnChoiceChange` enum
#[pyclass(name = "OptionDropDownOnChoiceChange")]
#[repr(transparent)]
pub struct AzOptionDropDownOnChoiceChangeEnumWrapper {
    pub inner: AzOptionDropDownOnChoiceChange,
}

/// `AzOptionResolvedTextLayoutOptions` enum
#[pyclass(name = "OptionResolvedTextLayoutOptions")]
#[repr(transparent)]
pub struct AzOptionResolvedTextLayoutOptionsEnumWrapper {
    pub inner: AzOptionResolvedTextLayoutOptions,
}

/// `AzOptionU8VecRef` enum
#[pyclass(name = "OptionU8VecRef")]
#[repr(transparent)]
pub struct AzOptionU8VecRefEnumWrapper {
    pub inner: AzOptionU8VecRef,
}

/// `AzOptionOnNodeAdded` enum
#[pyclass(name = "OptionOnNodeAdded")]
#[repr(transparent)]
pub struct AzOptionOnNodeAddedEnumWrapper {
    pub inner: AzOptionOnNodeAdded,
}

/// `AzOptionOnNodeRemoved` enum
#[pyclass(name = "OptionOnNodeRemoved")]
#[repr(transparent)]
pub struct AzOptionOnNodeRemovedEnumWrapper {
    pub inner: AzOptionOnNodeRemoved,
}

/// `AzOptionOnNodeGraphDragged` enum
#[pyclass(name = "OptionOnNodeGraphDragged")]
#[repr(transparent)]
pub struct AzOptionOnNodeGraphDraggedEnumWrapper {
    pub inner: AzOptionOnNodeGraphDragged,
}

/// `AzOptionOnNodeDragged` enum
#[pyclass(name = "OptionOnNodeDragged")]
#[repr(transparent)]
pub struct AzOptionOnNodeDraggedEnumWrapper {
    pub inner: AzOptionOnNodeDragged,
}

/// `AzOptionOnNodeConnected` enum
#[pyclass(name = "OptionOnNodeConnected")]
#[repr(transparent)]
pub struct AzOptionOnNodeConnectedEnumWrapper {
    pub inner: AzOptionOnNodeConnected,
}

/// `AzOptionOnNodeInputDisconnected` enum
#[pyclass(name = "OptionOnNodeInputDisconnected")]
#[repr(transparent)]
pub struct AzOptionOnNodeInputDisconnectedEnumWrapper {
    pub inner: AzOptionOnNodeInputDisconnected,
}

/// `AzOptionOnNodeOutputDisconnected` enum
#[pyclass(name = "OptionOnNodeOutputDisconnected")]
#[repr(transparent)]
pub struct AzOptionOnNodeOutputDisconnectedEnumWrapper {
    pub inner: AzOptionOnNodeOutputDisconnected,
}

/// `AzOptionColorInputOnValueChange` enum
#[pyclass(name = "OptionColorInputOnValueChange")]
#[repr(transparent)]
pub struct AzOptionColorInputOnValueChangeEnumWrapper {
    pub inner: AzOptionColorInputOnValueChange,
}

/// `AzOptionButtonOnClick` enum
#[pyclass(name = "OptionButtonOnClick")]
#[repr(transparent)]
pub struct AzOptionButtonOnClickEnumWrapper {
    pub inner: AzOptionButtonOnClick,
}

/// `AzOptionTabOnClick` enum
#[pyclass(name = "OptionTabOnClick")]
#[repr(transparent)]
pub struct AzOptionTabOnClickEnumWrapper {
    pub inner: AzOptionTabOnClick,
}

/// `AzOptionFileInputOnPathChange` enum
#[pyclass(name = "OptionFileInputOnPathChange")]
#[repr(transparent)]
pub struct AzOptionFileInputOnPathChangeEnumWrapper {
    pub inner: AzOptionFileInputOnPathChange,
}

/// `AzOptionCheckBoxOnToggle` enum
#[pyclass(name = "OptionCheckBoxOnToggle")]
#[repr(transparent)]
pub struct AzOptionCheckBoxOnToggleEnumWrapper {
    pub inner: AzOptionCheckBoxOnToggle,
}

/// `AzOptionTextInputOnTextInput` enum
#[pyclass(name = "OptionTextInputOnTextInput")]
#[repr(transparent)]
pub struct AzOptionTextInputOnTextInputEnumWrapper {
    pub inner: AzOptionTextInputOnTextInput,
}

/// `AzOptionTextInputOnVirtualKeyDown` enum
#[pyclass(name = "OptionTextInputOnVirtualKeyDown")]
#[repr(transparent)]
pub struct AzOptionTextInputOnVirtualKeyDownEnumWrapper {
    pub inner: AzOptionTextInputOnVirtualKeyDown,
}

/// `AzOptionTextInputOnFocusLost` enum
#[pyclass(name = "OptionTextInputOnFocusLost")]
#[repr(transparent)]
pub struct AzOptionTextInputOnFocusLostEnumWrapper {
    pub inner: AzOptionTextInputOnFocusLost,
}

/// `AzOptionTextInputSelection` enum
#[pyclass(name = "OptionTextInputSelection")]
#[repr(transparent)]
pub struct AzOptionTextInputSelectionEnumWrapper {
    pub inner: AzOptionTextInputSelection,
}

/// `AzOptionNumberInputOnFocusLost` enum
#[pyclass(name = "OptionNumberInputOnFocusLost")]
#[repr(transparent)]
pub struct AzOptionNumberInputOnFocusLostEnumWrapper {
    pub inner: AzOptionNumberInputOnFocusLost,
}

/// `AzOptionNumberInputOnValueChange` enum
#[pyclass(name = "OptionNumberInputOnValueChange")]
#[repr(transparent)]
pub struct AzOptionNumberInputOnValueChangeEnumWrapper {
    pub inner: AzOptionNumberInputOnValueChange,
}

/// `AzOptionMenuItemIcon` enum
#[pyclass(name = "OptionMenuItemIcon")]
#[repr(transparent)]
pub struct AzOptionMenuItemIconEnumWrapper {
    pub inner: AzOptionMenuItemIcon,
}

/// Optional MenuCallback
#[pyclass(name = "OptionMenuCallback")]
#[repr(transparent)]
pub struct AzOptionMenuCallbackEnumWrapper {
    pub inner: AzOptionMenuCallback,
}

/// `AzOptionVirtualKeyCodeCombo` enum
#[pyclass(name = "OptionVirtualKeyCodeCombo")]
#[repr(transparent)]
pub struct AzOptionVirtualKeyCodeComboEnumWrapper {
    pub inner: AzOptionVirtualKeyCodeCombo,
}

/// `AzOptionCssProperty` enum
#[pyclass(name = "OptionCssProperty")]
#[repr(transparent)]
pub struct AzOptionCssPropertyEnumWrapper {
    pub inner: AzOptionCssProperty,
}

/// `AzOptionPositionInfo` enum
#[pyclass(name = "OptionPositionInfo")]
#[repr(transparent)]
pub struct AzOptionPositionInfoEnumWrapper {
    pub inner: AzOptionPositionInfo,
}

/// `AzOptionTimerId` enum
#[pyclass(name = "OptionTimerId")]
#[repr(transparent)]
pub struct AzOptionTimerIdEnumWrapper {
    pub inner: AzOptionTimerId,
}

/// `AzOptionThreadId` enum
#[pyclass(name = "OptionThreadId")]
#[repr(transparent)]
pub struct AzOptionThreadIdEnumWrapper {
    pub inner: AzOptionThreadId,
}

/// `AzOptionI16` enum
#[pyclass(name = "OptionI16")]
#[repr(transparent)]
pub struct AzOptionI16EnumWrapper {
    pub inner: AzOptionI16,
}

/// `AzOptionU16` enum
#[pyclass(name = "OptionU16")]
#[repr(transparent)]
pub struct AzOptionU16EnumWrapper {
    pub inner: AzOptionU16,
}

/// `AzOptionU32` enum
#[pyclass(name = "OptionU32")]
#[repr(transparent)]
pub struct AzOptionU32EnumWrapper {
    pub inner: AzOptionU32,
}

/// `AzOptionImageRef` enum
#[pyclass(name = "OptionImageRef")]
#[repr(transparent)]
pub struct AzOptionImageRefEnumWrapper {
    pub inner: AzOptionImageRef,
}

/// `AzOptionFontRef` enum
#[pyclass(name = "OptionFontRef")]
#[repr(transparent)]
pub struct AzOptionFontRefEnumWrapper {
    pub inner: AzOptionFontRef,
}

/// `AzOptionOnNodeFieldEdited` enum
#[pyclass(name = "OptionOnNodeFieldEdited")]
#[repr(transparent)]
pub struct AzOptionOnNodeFieldEditedEnumWrapper {
    pub inner: AzOptionOnNodeFieldEdited,
}

/// `AzOptionFileTypeList` enum
#[pyclass(name = "OptionFileTypeList")]
#[repr(transparent)]
pub struct AzOptionFileTypeListEnumWrapper {
    pub inner: AzOptionFileTypeList,
}

/// `AzOptionWindowState` enum
#[pyclass(name = "OptionWindowState")]
#[repr(transparent)]
pub struct AzOptionWindowStateEnumWrapper {
    pub inner: AzOptionWindowState,
}

/// `AzOptionMouseState` enum
#[pyclass(name = "OptionMouseState")]
#[repr(transparent)]
pub struct AzOptionMouseStateEnumWrapper {
    pub inner: AzOptionMouseState,
}

/// `AzOptionKeyboardState` enum
#[pyclass(name = "OptionKeyboardState")]
#[repr(transparent)]
pub struct AzOptionKeyboardStateEnumWrapper {
    pub inner: AzOptionKeyboardState,
}

/// `AzOptionStringVec` enum
#[pyclass(name = "OptionStringVec")]
#[repr(transparent)]
pub struct AzOptionStringVecEnumWrapper {
    pub inner: AzOptionStringVec,
}

/// `AzOptionFile` enum
#[pyclass(name = "OptionFile")]
#[repr(transparent)]
pub struct AzOptionFileEnumWrapper {
    pub inner: AzOptionFile,
}

/// `AzOptionClipboard` enum
#[pyclass(name = "OptionClipboard")]
#[repr(transparent)]
pub struct AzOptionClipboardEnumWrapper {
    pub inner: AzOptionClipboard,
}

/// `AzOptionThreadReceiveMsg` enum
#[pyclass(name = "OptionThreadReceiveMsg")]
#[repr(transparent)]
pub struct AzOptionThreadReceiveMsgEnumWrapper {
    pub inner: AzOptionThreadReceiveMsg,
}

/// `AzOptionPercentageValue` enum
#[pyclass(name = "OptionPercentageValue")]
#[repr(transparent)]
pub struct AzOptionPercentageValueEnumWrapper {
    pub inner: AzOptionPercentageValue,
}

/// `AzOptionAngleValue` enum
#[pyclass(name = "OptionAngleValue")]
#[repr(transparent)]
pub struct AzOptionAngleValueEnumWrapper {
    pub inner: AzOptionAngleValue,
}

/// `AzOptionRendererOptions` enum
#[pyclass(name = "OptionRendererOptions")]
#[repr(transparent)]
pub struct AzOptionRendererOptionsEnumWrapper {
    pub inner: AzOptionRendererOptions,
}

/// Optional Callback
#[pyclass(name = "OptionCallback")]
#[repr(transparent)]
pub struct AzOptionCallbackEnumWrapper {
    pub inner: AzOptionCallback,
}

/// `AzOptionThreadSendMsg` enum
#[pyclass(name = "OptionThreadSendMsg")]
#[repr(transparent)]
pub struct AzOptionThreadSendMsgEnumWrapper {
    pub inner: AzOptionThreadSendMsg,
}

/// `AzOptionLayoutRect` enum
#[pyclass(name = "OptionLayoutRect")]
#[repr(transparent)]
pub struct AzOptionLayoutRectEnumWrapper {
    pub inner: AzOptionLayoutRect,
}

/// `AzOptionRefAny` enum
#[pyclass(name = "OptionRefAny")]
#[repr(transparent)]
pub struct AzOptionRefAnyEnumWrapper {
    pub inner: AzOptionRefAny,
}

/// `AzOptionInlineText` enum
#[pyclass(name = "OptionInlineText")]
#[repr(transparent)]
pub struct AzOptionInlineTextEnumWrapper {
    pub inner: AzOptionInlineText,
}

/// `AzOptionLayoutPoint` enum
#[pyclass(name = "OptionLayoutPoint")]
#[repr(transparent)]
pub struct AzOptionLayoutPointEnumWrapper {
    pub inner: AzOptionLayoutPoint,
}

/// `AzOptionLayoutSize` enum
#[pyclass(name = "OptionLayoutSize")]
#[repr(transparent)]
pub struct AzOptionLayoutSizeEnumWrapper {
    pub inner: AzOptionLayoutSize,
}

/// `AzOptionWindowTheme` enum
#[pyclass(name = "OptionWindowTheme")]
#[repr(transparent)]
pub struct AzOptionWindowThemeEnumWrapper {
    pub inner: AzOptionWindowTheme,
}

/// `AzOptionNodeId` enum
#[pyclass(name = "OptionNodeId")]
#[repr(transparent)]
pub struct AzOptionNodeIdEnumWrapper {
    pub inner: AzOptionNodeId,
}

/// `AzOptionDomNodeId` enum
#[pyclass(name = "OptionDomNodeId")]
#[repr(transparent)]
pub struct AzOptionDomNodeIdEnumWrapper {
    pub inner: AzOptionDomNodeId,
}

/// `AzOptionColorU` enum
#[pyclass(name = "OptionColorU")]
#[repr(transparent)]
pub struct AzOptionColorUEnumWrapper {
    pub inner: AzOptionColorU,
}

/// `AzOptionRawImage` enum
#[pyclass(name = "OptionRawImage")]
#[repr(transparent)]
pub struct AzOptionRawImageEnumWrapper {
    pub inner: AzOptionRawImage,
}

/// `AzOptionSvgDashPattern` enum
#[pyclass(name = "OptionSvgDashPattern")]
#[repr(transparent)]
pub struct AzOptionSvgDashPatternEnumWrapper {
    pub inner: AzOptionSvgDashPattern,
}

/// `AzOptionWaylandTheme` enum
#[pyclass(name = "OptionWaylandTheme")]
#[repr(transparent)]
pub struct AzOptionWaylandThemeEnumWrapper {
    pub inner: AzOptionWaylandTheme,
}

/// `AzOptionTaskBarIcon` enum
#[pyclass(name = "OptionTaskBarIcon")]
#[repr(transparent)]
pub struct AzOptionTaskBarIconEnumWrapper {
    pub inner: AzOptionTaskBarIcon,
}

/// `AzOptionHwndHandle` enum
#[pyclass(name = "OptionHwndHandle")]
#[repr(transparent)]
pub struct AzOptionHwndHandleEnumWrapper {
    pub inner: AzOptionHwndHandle,
}

/// `AzOptionLogicalPosition` enum
#[pyclass(name = "OptionLogicalPosition")]
#[repr(transparent)]
pub struct AzOptionLogicalPositionEnumWrapper {
    pub inner: AzOptionLogicalPosition,
}

/// `AzOptionPhysicalPositionI32` enum
#[pyclass(name = "OptionPhysicalPositionI32")]
#[repr(transparent)]
pub struct AzOptionPhysicalPositionI32EnumWrapper {
    pub inner: AzOptionPhysicalPositionI32,
}

/// `AzOptionWindowIcon` enum
#[pyclass(name = "OptionWindowIcon")]
#[repr(transparent)]
pub struct AzOptionWindowIconEnumWrapper {
    pub inner: AzOptionWindowIcon,
}

/// `AzOptionGlContextPtr` enum
#[pyclass(name = "OptionGlContextPtr")]
#[repr(transparent)]
pub struct AzOptionGlContextPtrEnumWrapper {
    pub inner: AzOptionGlContextPtr,
}

/// `AzOptionX11Visual` enum
#[pyclass(name = "OptionX11Visual")]
#[repr(transparent)]
pub struct AzOptionX11VisualEnumWrapper {
    pub inner: AzOptionX11Visual,
}

/// `AzOptionI32` enum
#[pyclass(name = "OptionI32")]
#[repr(transparent)]
pub struct AzOptionI32EnumWrapper {
    pub inner: AzOptionI32,
}

/// `AzOptionF32` enum
#[pyclass(name = "OptionF32")]
#[repr(transparent)]
pub struct AzOptionF32EnumWrapper {
    pub inner: AzOptionF32,
}

/// `AzOptionMouseCursorType` enum
#[pyclass(name = "OptionMouseCursorType")]
#[repr(transparent)]
pub struct AzOptionMouseCursorTypeEnumWrapper {
    pub inner: AzOptionMouseCursorType,
}

/// `AzOptionLogicalSize` enum
#[pyclass(name = "OptionLogicalSize")]
#[repr(transparent)]
pub struct AzOptionLogicalSizeEnumWrapper {
    pub inner: AzOptionLogicalSize,
}

/// Option<char> but the char is a u32, for C FFI stability reasons
#[pyclass(name = "OptionChar")]
#[repr(transparent)]
pub struct AzOptionCharEnumWrapper {
    pub inner: AzOptionChar,
}

/// `AzOptionVirtualKeyCode` enum
#[pyclass(name = "OptionVirtualKeyCode")]
#[repr(transparent)]
pub struct AzOptionVirtualKeyCodeEnumWrapper {
    pub inner: AzOptionVirtualKeyCode,
}

/// `AzOptionDom` enum
#[pyclass(name = "OptionDom")]
#[repr(transparent)]
pub struct AzOptionDomEnumWrapper {
    pub inner: AzOptionDom,
}

/// `AzOptionTexture` enum
#[pyclass(name = "OptionTexture")]
#[repr(transparent)]
pub struct AzOptionTextureEnumWrapper {
    pub inner: AzOptionTexture,
}

/// `AzOptionImageMask` enum
#[pyclass(name = "OptionImageMask")]
#[repr(transparent)]
pub struct AzOptionImageMaskEnumWrapper {
    pub inner: AzOptionImageMask,
}

/// `AzOptionTabIndex` enum
#[pyclass(name = "OptionTabIndex")]
#[repr(transparent)]
pub struct AzOptionTabIndexEnumWrapper {
    pub inner: AzOptionTabIndex,
}

/// `AzOptionTagId` enum
#[pyclass(name = "OptionTagId")]
#[repr(transparent)]
pub struct AzOptionTagIdEnumWrapper {
    pub inner: AzOptionTagId,
}

/// `AzOptionDuration` enum
#[pyclass(name = "OptionDuration")]
#[repr(transparent)]
pub struct AzOptionDurationEnumWrapper {
    pub inner: AzOptionDuration,
}

/// `AzOptionInstant` enum
#[pyclass(name = "OptionInstant")]
#[repr(transparent)]
pub struct AzOptionInstantEnumWrapper {
    pub inner: AzOptionInstant,
}

/// `AzOptionUsize` enum
#[pyclass(name = "OptionUsize")]
#[repr(transparent)]
pub struct AzOptionUsizeEnumWrapper {
    pub inner: AzOptionUsize,
}

/// `AzOptionU8Vec` enum
#[pyclass(name = "OptionU8Vec")]
#[repr(transparent)]
pub struct AzOptionU8VecEnumWrapper {
    pub inner: AzOptionU8Vec,
}

/// `AzOptionAzString` enum
#[pyclass(name = "OptionAzString")]
#[repr(transparent)]
pub struct AzOptionAzStringEnumWrapper {
    pub inner: AzOptionAzString,
}

/// `AzResultXmlXmlError` enum
#[pyclass(name = "ResultXmlXmlError")]
#[repr(transparent)]
pub struct AzResultXmlXmlErrorEnumWrapper {
    pub inner: AzResultXmlXmlError,
}

/// `AzResultRawImageDecodeImageError` enum
#[pyclass(name = "ResultRawImageDecodeImageError")]
#[repr(transparent)]
pub struct AzResultRawImageDecodeImageErrorEnumWrapper {
    pub inner: AzResultRawImageDecodeImageError,
}

/// `AzResultU8VecEncodeImageError` enum
#[pyclass(name = "ResultU8VecEncodeImageError")]
#[repr(transparent)]
pub struct AzResultU8VecEncodeImageErrorEnumWrapper {
    pub inner: AzResultU8VecEncodeImageError,
}

/// `AzResultSvgXmlNodeSvgParseError` enum
#[pyclass(name = "ResultSvgXmlNodeSvgParseError")]
#[repr(transparent)]
pub struct AzResultSvgXmlNodeSvgParseErrorEnumWrapper {
    pub inner: AzResultSvgXmlNodeSvgParseError,
}

/// `AzResultSvgSvgParseError` enum
#[pyclass(name = "ResultSvgSvgParseError")]
#[repr(transparent)]
pub struct AzResultSvgSvgParseErrorEnumWrapper {
    pub inner: AzResultSvgSvgParseError,
}

/// `AzXmlError` enum
#[pyclass(name = "XmlError")]
#[repr(transparent)]
pub struct AzXmlErrorEnumWrapper {
    pub inner: AzXmlError,
}

/// `AzXmlParseError` enum
#[pyclass(name = "XmlParseError")]
#[repr(transparent)]
pub struct AzXmlParseErrorEnumWrapper {
    pub inner: AzXmlParseError,
}

/// `AzXmlStreamError` enum
#[pyclass(name = "XmlStreamError")]
#[repr(transparent)]
pub struct AzXmlStreamErrorEnumWrapper {
    pub inner: AzXmlStreamError,
}

/// Determines what happens when all application windows are closed
#[pyclass(name = "AppTerminationBehavior")]
#[repr(transparent)]
pub struct AzAppTerminationBehaviorEnumWrapper {
    pub inner: AzAppTerminationBehavior,
}


// Necessary because the Python interpreter may send structs across different threads
unsafe impl Send for AzAzAppPtr { }
unsafe impl Send for AzIOSHandle { }
unsafe impl Send for AzMacOSHandle { }
unsafe impl Send for AzXlibHandle { }
unsafe impl Send for AzXcbHandle { }
unsafe impl Send for AzWaylandHandle { }
unsafe impl Send for AzWindowsHandle { }
unsafe impl Send for AzAndroidHandle { }
unsafe impl Send for AzSystemCallbacks { }
unsafe impl Send for AzCallbackInfo { }
unsafe impl Send for AzLayoutCallbackInfo { }
unsafe impl Send for AzIFrameCallbackInfo { }
unsafe impl Send for AzRenderImageCallbackInfo { }
unsafe impl Send for AzTimerCallbackInfo { }
unsafe impl Send for AzRefCount { }
unsafe impl Send for AzRefAny { }
unsafe impl Send for AzNodeData { }
unsafe impl Send for AzFontRef { }
unsafe impl Send for AzSystemStyle { }
unsafe impl Send for AzTexture { }
unsafe impl Send for AzGlVoidPtrConst { }
unsafe impl Send for AzGlVoidPtrMut { }
unsafe impl Send for AzVertexArrayObject { }
unsafe impl Send for AzVertexBuffer { }
unsafe impl Send for AzGlContextPtr { }
unsafe impl Send for AzU8VecRef { }
unsafe impl Send for AzU8VecRefMut { }
unsafe impl Send for AzF32VecRef { }
unsafe impl Send for AzI32VecRef { }
unsafe impl Send for AzGLuintVecRef { }
unsafe impl Send for AzGLenumVecRef { }
unsafe impl Send for AzGLintVecRefMut { }
unsafe impl Send for AzGLint64VecRefMut { }
unsafe impl Send for AzGLbooleanVecRefMut { }
unsafe impl Send for AzGLfloatVecRefMut { }
unsafe impl Send for AzRefstrVecRef { }
unsafe impl Send for AzRefstr { }
unsafe impl Send for AzGLsyncPtr { }
unsafe impl Send for AzImageRef { }
unsafe impl Send for AzSvg { }
unsafe impl Send for AzSvgXmlNode { }
unsafe impl Send for AzTessellatedColoredSvgNodeVecRef { }
unsafe impl Send for AzTessellatedSvgNodeVecRef { }
unsafe impl Send for AzMsgBox { }
unsafe impl Send for AzColorPickerDialog { }
unsafe impl Send for AzFileDialog { }
unsafe impl Send for AzAzInstantPtr { }
unsafe impl Send for AzThreadReceiver { }
unsafe impl Send for AzListViewRowVec { }
unsafe impl Send for AzStyleFilterVec { }
unsafe impl Send for AzLogicalRectVec { }
unsafe impl Send for AzNodeTypeIdInfoMapVec { }
unsafe impl Send for AzInputOutputTypeIdInfoMapVec { }
unsafe impl Send for AzNodeIdNodeMapVec { }
unsafe impl Send for AzInputOutputTypeIdVec { }
unsafe impl Send for AzNodeTypeFieldVec { }
unsafe impl Send for AzInputConnectionVec { }
unsafe impl Send for AzOutputNodeAndIndexVec { }
unsafe impl Send for AzOutputConnectionVec { }
unsafe impl Send for AzInputNodeAndIndexVec { }
unsafe impl Send for AzAccessibilityStateVec { }
unsafe impl Send for AzMenuItemVec { }
unsafe impl Send for AzTessellatedSvgNodeVec { }
unsafe impl Send for AzTessellatedColoredSvgNodeVec { }
unsafe impl Send for AzStyleFontFamilyVec { }
unsafe impl Send for AzXmlNodeVec { }
unsafe impl Send for AzFmtArgVec { }
unsafe impl Send for AzInlineLineVec { }
unsafe impl Send for AzInlineWordVec { }
unsafe impl Send for AzInlineGlyphVec { }
unsafe impl Send for AzInlineTextHitVec { }
unsafe impl Send for AzMonitorVec { }
unsafe impl Send for AzVideoModeVec { }
unsafe impl Send for AzDomVec { }
unsafe impl Send for AzIdOrClassVec { }
unsafe impl Send for AzNodeDataInlineCssPropertyVec { }
unsafe impl Send for AzStyleBackgroundContentVec { }
unsafe impl Send for AzStyleBackgroundPositionVec { }
unsafe impl Send for AzStyleBackgroundRepeatVec { }
unsafe impl Send for AzStyleBackgroundSizeVec { }
unsafe impl Send for AzStyleTransformVec { }
unsafe impl Send for AzCssPropertyVec { }
unsafe impl Send for AzSvgMultiPolygonVec { }
unsafe impl Send for AzSvgSimpleNodeVec { }
unsafe impl Send for AzSvgPathVec { }
unsafe impl Send for AzVertexAttributeVec { }
unsafe impl Send for AzSvgPathElementVec { }
unsafe impl Send for AzSvgVertexVec { }
unsafe impl Send for AzSvgColoredVertexVec { }
unsafe impl Send for AzU32Vec { }
unsafe impl Send for AzXWindowTypeVec { }
unsafe impl Send for AzVirtualKeyCodeVec { }
unsafe impl Send for AzCascadeInfoVec { }
unsafe impl Send for AzScanCodeVec { }
unsafe impl Send for AzCssDeclarationVec { }
unsafe impl Send for AzCssPathSelectorVec { }
unsafe impl Send for AzStylesheetVec { }
unsafe impl Send for AzCssRuleBlockVec { }
unsafe impl Send for AzU16Vec { }
unsafe impl Send for AzF32Vec { }
unsafe impl Send for AzU8Vec { }
unsafe impl Send for AzCallbackDataVec { }
unsafe impl Send for AzGLuintVec { }
unsafe impl Send for AzGLintVec { }
unsafe impl Send for AzStringVec { }
unsafe impl Send for AzStringPairVec { }
unsafe impl Send for AzNormalizedLinearColorStopVec { }
unsafe impl Send for AzNormalizedRadialColorStopVec { }
unsafe impl Send for AzNodeIdVec { }
unsafe impl Send for AzNodeHierarchyItemVec { }
unsafe impl Send for AzStyledNodeVec { }
unsafe impl Send for AzTagIdToNodeIdMappingVec { }
unsafe impl Send for AzParentWithNodeDepthVec { }
unsafe impl Send for AzNodeDataVec { }
unsafe impl Send for AzAzDebugMessageVec { }
unsafe impl Send for AzFontCache { }


// Python objects must implement Clone at minimum
impl Clone for AzAppConfig { fn clone(&self) -> Self { let r: &azul_core::resources::AppConfig = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAzAppPtr { fn clone(&self) -> Self { let r: &azul_dll::desktop::app::AzAppPtr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzExternalSystemCallbacks { fn clone(&self) -> Self { let r: &azul_layout::callbacks::ExternalSystemCallbacks = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowCreateOptions { fn clone(&self) -> Self { let r: &azul_core::window::WindowCreateOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRendererOptions { fn clone(&self) -> Self { let r: &azul_core::window::RendererOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPoint { fn clone(&self) -> Self { let r: &azul_css::props::basic::geometry::LayoutPoint = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutSize { fn clone(&self) -> Self { let r: &azul_css::props::basic::geometry::LayoutSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutRect { fn clone(&self) -> Self { let r: &azul_css::props::basic::geometry::LayoutRect = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIOSHandle { fn clone(&self) -> Self { let r: &azul_core::window::IOSHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMacOSHandle { fn clone(&self) -> Self { let r: &azul_core::window::MacOSHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXlibHandle { fn clone(&self) -> Self { let r: &azul_core::window::XlibHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXcbHandle { fn clone(&self) -> Self { let r: &azul_core::window::XcbHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWaylandHandle { fn clone(&self) -> Self { let r: &azul_core::window::WaylandHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowsHandle { fn clone(&self) -> Self { let r: &azul_core::window::WindowsHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWebHandle { fn clone(&self) -> Self { let r: &azul_core::window::WebHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAndroidHandle { fn clone(&self) -> Self { let r: &azul_core::window::AndroidHandle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPhysicalPositionI32 { fn clone(&self) -> Self { let r: &azul_core::window::PhysicalPositionI32 = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPhysicalSizeU32 { fn clone(&self) -> Self { let r: &azul_core::window::PhysicalSizeU32 = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLogicalRect { fn clone(&self) -> Self { let r: &azul_core::window::LogicalRect = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLogicalPosition { fn clone(&self) -> Self { let r: &azul_core::window::LogicalPosition = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLogicalSize { fn clone(&self) -> Self { let r: &azul_core::window::LogicalSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIconKey { fn clone(&self) -> Self { let r: &azul_core::window::IconKey = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSmallWindowIconBytes { fn clone(&self) -> Self { let r: &azul_core::window::SmallWindowIconBytes = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLargeWindowIconBytes { fn clone(&self) -> Self { let r: &azul_core::window::LargeWindowIconBytes = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTaskBarIcon { fn clone(&self) -> Self { let r: &azul_core::window::TaskBarIcon = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowSize { fn clone(&self) -> Self { let r: &azul_core::window::WindowSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowFlags { fn clone(&self) -> Self { let r: &azul_core::window::WindowFlags = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDebugState { fn clone(&self) -> Self { let r: &azul_core::window::DebugState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzKeyboardState { fn clone(&self) -> Self { let r: &azul_core::window::KeyboardState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMouseState { fn clone(&self) -> Self { let r: &azul_core::window::MouseState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPlatformSpecificOptions { fn clone(&self) -> Self { let r: &azul_core::window::PlatformSpecificOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowsWindowOptions { fn clone(&self) -> Self { let r: &azul_core::window::WindowsWindowOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWaylandTheme { fn clone(&self) -> Self { let r: &azul_core::window::WaylandTheme = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowState { fn clone(&self) -> Self { let r: &azul_core::window::WindowState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLinuxWindowOptions { fn clone(&self) -> Self { let r: &azul_core::window::LinuxWindowOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMacWindowOptions { fn clone(&self) -> Self { let r: &azul_core::window::MacWindowOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWasmWindowOptions { fn clone(&self) -> Self { let r: &azul_core::window::WasmWindowOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTouchState { fn clone(&self) -> Self { let r: &azul_core::window::TouchState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMonitor { fn clone(&self) -> Self { let r: &azul_core::window::Monitor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVideoMode { fn clone(&self) -> Self { let r: &azul_core::window::VideoMode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAzStringPair { fn clone(&self) -> Self { let r: &azul_core::window::AzStringPair = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSystemCallbacks { fn clone(&self) -> Self { let r: &azul_layout::window::SystemCallbacks = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMonitorId { fn clone(&self) -> Self { let r: &azul_core::window::MonitorId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMarshaledLayoutCallback { fn clone(&self) -> Self { let r: &azul_core::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMarshaledLayoutCallbackInner { fn clone(&self) -> Self { let r: &azul_core::callbacks::MarshaledLayoutCallbackInner = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutCallbackInner { fn clone(&self) -> Self { let r: &azul_core::callbacks::LayoutCallbackInner = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCallback { fn clone(&self) -> Self { let r: &azul_layout::callbacks::Callback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCallbackInfo { fn clone(&self) -> Self { let r: &azul_layout::callbacks::CallbackInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutCallbackInfo { fn clone(&self) -> Self { let r: &azul_core::callbacks::LayoutCallbackInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDomId { fn clone(&self) -> Self { let r: &azul_core::dom::DomId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDomNodeId { fn clone(&self) -> Self { let r: &azul_core::dom::DomNodeId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPositionInfoInner { fn clone(&self) -> Self { let r: &azul_core::ui_solver::PositionInfoInner = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzHidpiAdjustedBounds { fn clone(&self) -> Self { let r: &azul_core::callbacks::HidpiAdjustedBounds = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineText { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineText = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineLine { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineLine = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineTextContents { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineTextContents = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineGlyph { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineGlyph = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineTextHit { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineTextHit = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFocusTargetPath { fn clone(&self) -> Self { let r: &azul_core::callbacks::FocusTargetPath = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzResolvedTextLayoutOptions { fn clone(&self) -> Self { let r: &azul_core::ui_solver::ResolvedTextLayoutOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAnimation { fn clone(&self) -> Self { let r: &azul_core::callbacks::Animation = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeHierarchyItemId { fn clone(&self) -> Self { let r: &azul_core::styled_dom::NodeHierarchyItemId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIFrameCallback { fn clone(&self) -> Self { let r: &azul_core::callbacks::IFrameCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIFrameCallbackInfo { fn clone(&self) -> Self { let r: &azul_core::callbacks::IFrameCallbackInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIFrameCallbackReturn { fn clone(&self) -> Self { let r: &azul_core::callbacks::IFrameCallbackReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRenderImageCallback { fn clone(&self) -> Self { let r: &azul_layout::callbacks::RenderImageCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRenderImageCallbackInfo { fn clone(&self) -> Self { let r: &azul_layout::callbacks::RenderImageCallbackInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTimerCallback { fn clone(&self) -> Self { let r: &azul_core::callbacks::TimerCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTimerCallbackInfo { fn clone(&self) -> Self { let r: &azul_core::callbacks::TimerCallbackInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTimerCallbackReturn { fn clone(&self) -> Self { let r: &azul_core::callbacks::TimerCallbackReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWriteBackCallback { fn clone(&self) -> Self { let r: &azul_core::callbacks::WriteBackCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadCallback { fn clone(&self) -> Self { let r: &azul_core::callbacks::ThreadCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRefCount { fn clone(&self) -> Self { let r: &azul_core::callbacks::RefCount = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRefAny { fn clone(&self) -> Self { let r: &azul_core::callbacks::RefAny = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuCallback { fn clone(&self) -> Self { let r: &azul_core::window::MenuCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDom { fn clone(&self) -> Self { let r: &azul_core::dom::Dom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIFrameNode { fn clone(&self) -> Self { let r: &azul_core::dom::IFrameNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCallbackData { fn clone(&self) -> Self { let r: &azul_core::dom::CallbackData = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeData { fn clone(&self) -> Self { let r: &azul_core::dom::NodeData = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityInfo { fn clone(&self) -> Self { let r: &azul_core::dom::AccessibilityInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenu { fn clone(&self) -> Self { let r: &azul_core::menu::Menu = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringMenuItem { fn clone(&self) -> Self { let r: &azul_core::menu::StringMenuItem = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVirtualKeyCodeCombo { fn clone(&self) -> Self { let r: &azul_core::window::VirtualKeyCodeCombo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssRuleBlock { fn clone(&self) -> Self { let r: &azul_css::css::CssRuleBlock = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPath { fn clone(&self) -> Self { let r: &azul_css::css::CssPath = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssNthChildPattern { fn clone(&self) -> Self { let r: &azul_css::css::CssNthChildPattern = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStylesheet { fn clone(&self) -> Self { let r: &azul_css::css::Stylesheet = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCss { fn clone(&self) -> Self { let r: &azul_css::css::Css = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDynamicCssProperty { fn clone(&self) -> Self { let r: &azul_css::css::DynamicCssProperty = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorU { fn clone(&self) -> Self { let r: &azul_css::props::basic::color::ColorU = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPixelValue { fn clone(&self) -> Self { let r: &azul_css::props::basic::pixel::PixelValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPixelValueNoPercent { fn clone(&self) -> Self { let r: &azul_css::props::basic::pixel::PixelValueNoPercent = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBoxShadow { fn clone(&self) -> Self { let r: &azul_css::props::style::box_shadow::StyleBoxShadow = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBlur { fn clone(&self) -> Self { let r: &azul_css::props::style::filter::StyleBlur = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleColorMatrix { fn clone(&self) -> Self { let r: &azul_css::props::style::filter::StyleColorMatrix = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFilterOffset { fn clone(&self) -> Self { let r: &azul_css::props::style::filter::StyleFilterOffset = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBottom { fn clone(&self) -> Self { let r: &azul_css::LayoutBottom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexGrow { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutFlexGrow = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexShrink { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutFlexShrink = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutHeight { fn clone(&self) -> Self { let r: &azul_css::props::layout::dimensions::LayoutHeight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutLeft { fn clone(&self) -> Self { let r: &azul_css::LayoutLeft = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginBottom { fn clone(&self) -> Self { let r: &azul_css::LayoutMarginBottom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginLeft { fn clone(&self) -> Self { let r: &azul_css::LayoutMarginLeft = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginRight { fn clone(&self) -> Self { let r: &azul_css::LayoutMarginRight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginTop { fn clone(&self) -> Self { let r: &azul_css::LayoutMarginTop = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMaxHeight { fn clone(&self) -> Self { let r: &azul_css::LayoutMaxHeight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMaxWidth { fn clone(&self) -> Self { let r: &azul_css::LayoutMaxWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMinHeight { fn clone(&self) -> Self { let r: &azul_css::LayoutMinHeight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMinWidth { fn clone(&self) -> Self { let r: &azul_css::LayoutMinWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingBottom { fn clone(&self) -> Self { let r: &azul_css::LayoutPaddingBottom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingLeft { fn clone(&self) -> Self { let r: &azul_css::LayoutPaddingLeft = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingRight { fn clone(&self) -> Self { let r: &azul_css::LayoutPaddingRight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingTop { fn clone(&self) -> Self { let r: &azul_css::LayoutPaddingTop = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutRight { fn clone(&self) -> Self { let r: &azul_css::LayoutRight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutTop { fn clone(&self) -> Self { let r: &azul_css::LayoutTop = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutWidth { fn clone(&self) -> Self { let r: &azul_css::props::layout::dimensions::LayoutWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFloatValue { fn clone(&self) -> Self { let r: &azul_css::props::basic::length::FloatValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPercentageValue { fn clone(&self) -> Self { let r: &azul_css::props::basic::length::PercentageValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAngleValue { fn clone(&self) -> Self { let r: &azul_css::props::basic::angle::AngleValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedLinearColorStop { fn clone(&self) -> Self { let r: &azul_css::props::style::background::NormalizedLinearColorStop = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedRadialColorStop { fn clone(&self) -> Self { let r: &azul_css::props::style::background::NormalizedRadialColorStop = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDirectionCorners { fn clone(&self) -> Self { let r: &azul_css::props::basic::direction::DirectionCorners = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLinearGradient { fn clone(&self) -> Self { let r: &azul_css::props::style::background::LinearGradient = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRadialGradient { fn clone(&self) -> Self { let r: &azul_css::props::style::background::RadialGradient = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzConicGradient { fn clone(&self) -> Self { let r: &azul_css::props::style::background::ConicGradient = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundPosition { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundPosition = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomColor { fn clone(&self) -> Self { let r: &azul_css::StyleBorderBottomColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomLeftRadius { fn clone(&self) -> Self { let r: &azul_css::StyleBorderBottomLeftRadius = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomRightRadius { fn clone(&self) -> Self { let r: &azul_css::StyleBorderBottomRightRadius = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomStyle { fn clone(&self) -> Self { let r: &azul_css::StyleBorderBottomStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderBottomWidth { fn clone(&self) -> Self { let r: &azul_css::LayoutBorderBottomWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderLeftColor { fn clone(&self) -> Self { let r: &azul_css::StyleBorderLeftColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderLeftStyle { fn clone(&self) -> Self { let r: &azul_css::StyleBorderLeftStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderLeftWidth { fn clone(&self) -> Self { let r: &azul_css::LayoutBorderLeftWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderRightColor { fn clone(&self) -> Self { let r: &azul_css::StyleBorderRightColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderRightStyle { fn clone(&self) -> Self { let r: &azul_css::StyleBorderRightStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderRightWidth { fn clone(&self) -> Self { let r: &azul_css::LayoutBorderRightWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopColor { fn clone(&self) -> Self { let r: &azul_css::StyleBorderTopColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopLeftRadius { fn clone(&self) -> Self { let r: &azul_css::StyleBorderTopLeftRadius = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopRightRadius { fn clone(&self) -> Self { let r: &azul_css::StyleBorderTopRightRadius = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopStyle { fn clone(&self) -> Self { let r: &azul_css::StyleBorderTopStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderTopWidth { fn clone(&self) -> Self { let r: &azul_css::LayoutBorderTopWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzScrollbarInfo { fn clone(&self) -> Self { let r: &azul_css::props::style::scrollbar::ScrollbarInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzScrollbarStyle { fn clone(&self) -> Self { let r: &azul_css::props::style::scrollbar::ScrollbarStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontSize { fn clone(&self) -> Self { let r: &azul_css::props::basic::font::StyleFontSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleLetterSpacing { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleLetterSpacing = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleLineHeight { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleLineHeight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTabWidth { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleTabWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleOpacity { fn clone(&self) -> Self { let r: &azul_css::props::style::effects::StyleOpacity = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformOrigin { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformOrigin = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInterpolateResolver { fn clone(&self) -> Self { let r: &azul_css::props::basic::animation::InterpolateResolver = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformMatrix2D { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformMatrix2D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformMatrix3D { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformMatrix3D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformTranslate2D { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformTranslate2D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformTranslate3D { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformTranslate3D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformRotate3D { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformRotate3D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformScale2D { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformScale2D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformScale3D { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformScale3D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformSkew2D { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformSkew2D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTextColor { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleTextColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleWordSpacing { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleWordSpacing = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCounterReset { fn clone(&self) -> Self { let r: &azul_css::props::style::content::CounterReset = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStylePerspectiveOrigin { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StylePerspectiveOrigin = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSelectionBackgroundColor { fn clone(&self) -> Self { let r: &azul_css::props::style::selection::SelectionBackgroundColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColumnRuleColor { fn clone(&self) -> Self { let r: &azul_css::props::layout::column::ColumnRuleColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFontRef { fn clone(&self) -> Self { let r: &azul_css::FontRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSystemMetrics { fn clone(&self) -> Self { let r: &azul_css::system::SystemMetrics = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSystemStyle { fn clone(&self) -> Self { let r: &azul_css::system::SystemStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFontMetrics { fn clone(&self) -> Self { let r: &azul_css::FontMetrics = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCaretAnimationDuration { fn clone(&self) -> Self { let r: &azul_css::props::style::text::CaretAnimationDuration = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColumnRuleStyle { fn clone(&self) -> Self { let r: &azul_css::props::layout::column::ColumnRuleStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPoint { fn clone(&self) -> Self { let r: &azul_layout::xml::svg::SvgPoint = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGridPlacement { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::GridPlacement = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringSet { fn clone(&self) -> Self { let r: &azul_css::props::style::content::StringSet = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgVector { fn clone(&self) -> Self { let r: &azul_layout::xml::svg::SvgVector = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgRect { fn clone(&self) -> Self { let r: &azul_layout::xml::svg::SvgRect = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSystemColors { fn clone(&self) -> Self { let r: &azul_css::system::SystemColors = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGridTemplate { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::GridTemplate = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzContent { fn clone(&self) -> Self { let r: &azul_css::props::style::content::Content = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutGap { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::LayoutGap = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapeMargin { fn clone(&self) -> Self { let r: &azul_css::props::layout::shape::ShapeMargin = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCounterIncrement { fn clone(&self) -> Self { let r: &azul_css::props::style::content::CounterIncrement = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgCubicCurve { fn clone(&self) -> Self { let r: &azul_layout::xml::svg::SvgCubicCurve = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgQuadraticCurve { fn clone(&self) -> Self { let r: &azul_layout::xml::svg::SvgQuadraticCurve = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSelectionColor { fn clone(&self) -> Self { let r: &azul_css::props::style::selection::SelectionColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapeImageThreshold { fn clone(&self) -> Self { let r: &azul_css::props::layout::shape::ShapeImageThreshold = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColumnRuleWidth { fn clone(&self) -> Self { let r: &azul_css::props::layout::column::ColumnRuleWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAzString { fn clone(&self) -> Self { let r: &azul_css::AzString = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCaretColor { fn clone(&self) -> Self { let r: &azul_css::props::style::text::CaretColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSystemFonts { fn clone(&self) -> Self { let r: &azul_css::system::SystemFonts = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRibbon { fn clone(&self) -> Self { let r: &azul_dll::widgets::ribbon::Ribbon = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRibbonOnTabClickedCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::ribbon::RibbonOnTabClickedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzButton { fn clone(&self) -> Self { let r: &azul_dll::widgets::button::Button = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzButtonOnClick { fn clone(&self) -> Self { let r: &azul_dll::widgets::button::ButtonOnClick = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFileInput { fn clone(&self) -> Self { let r: &azul_dll::widgets::file_input::FileInput = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFileInputStateWrapper { fn clone(&self) -> Self { let r: &azul_dll::widgets::file_input::FileInputStateWrapper = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFileInputState { fn clone(&self) -> Self { let r: &azul_dll::widgets::file_input::FileInputState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFileInputOnPathChange { fn clone(&self) -> Self { let r: &azul_dll::widgets::file_input::FileInputOnPathChange = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFileInputOnPathChangeCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::file_input::FileInputOnPathChangeCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckBox { fn clone(&self) -> Self { let r: &azul_dll::widgets::check_box::CheckBox = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckBoxStateWrapper { fn clone(&self) -> Self { let r: &azul_dll::widgets::check_box::CheckBoxStateWrapper = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckBoxOnToggle { fn clone(&self) -> Self { let r: &azul_dll::widgets::check_box::CheckBoxOnToggle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckBoxOnToggleCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::check_box::CheckBoxOnToggleCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckBoxState { fn clone(&self) -> Self { let r: &azul_dll::widgets::check_box::CheckBoxState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLabel { fn clone(&self) -> Self { let r: &azul_dll::widgets::label::Label = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorInput { fn clone(&self) -> Self { let r: &azul_dll::widgets::color_input::ColorInput = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorInputStateWrapper { fn clone(&self) -> Self { let r: &azul_dll::widgets::color_input::ColorInputStateWrapper = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorInputState { fn clone(&self) -> Self { let r: &azul_dll::widgets::color_input::ColorInputState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorInputOnValueChange { fn clone(&self) -> Self { let r: &azul_dll::widgets::color_input::ColorInputOnValueChange = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorInputOnValueChangeCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::color_input::ColorInputOnValueChangeCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInput { fn clone(&self) -> Self { let r: &azul_dll::widgets::text_input::TextInput = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputStateWrapper { fn clone(&self) -> Self { let r: &azul_dll::widgets::text_input::TextInputStateWrapper = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputState { fn clone(&self) -> Self { let r: &azul_dll::widgets::text_input::TextInputState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputSelectionRange { fn clone(&self) -> Self { let r: &azul_dll::widgets::text_input::TextInputSelectionRange = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnTextInput { fn clone(&self) -> Self { let r: &azul_dll::widgets::text_input::TextInputOnTextInput = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnTextInputCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::text_input::TextInputOnTextInputCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnVirtualKeyDown { fn clone(&self) -> Self { let r: &azul_dll::widgets::text_input::TextInputOnVirtualKeyDown = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnVirtualKeyDownCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::text_input::TextInputOnVirtualKeyDownCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnFocusLost { fn clone(&self) -> Self { let r: &azul_dll::widgets::text_input::TextInputOnFocusLost = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnFocusLostCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::text_input::TextInputOnFocusLostCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnTextInputReturn { fn clone(&self) -> Self { let r: &azul_dll::widgets::text_input::OnTextInputReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInput { fn clone(&self) -> Self { let r: &azul_dll::widgets::number_input::NumberInput = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputStateWrapper { fn clone(&self) -> Self { let r: &azul_dll::widgets::number_input::NumberInputStateWrapper = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputState { fn clone(&self) -> Self { let r: &azul_dll::widgets::number_input::NumberInputState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputOnValueChange { fn clone(&self) -> Self { let r: &azul_dll::widgets::number_input::NumberInputOnValueChange = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputOnValueChangeCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::number_input::NumberInputOnValueChangeCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputOnFocusLost { fn clone(&self) -> Self { let r: &azul_dll::widgets::number_input::NumberInputOnFocusLost = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputOnFocusLostCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::number_input::NumberInputOnFocusLostCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzProgressBar { fn clone(&self) -> Self { let r: &azul_dll::widgets::progressbar::ProgressBar = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzProgressBarState { fn clone(&self) -> Self { let r: &azul_dll::widgets::progressbar::ProgressBarState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTabHeader { fn clone(&self) -> Self { let r: &azul_dll::widgets::tabs::TabHeader = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTabHeaderState { fn clone(&self) -> Self { let r: &azul_dll::widgets::tabs::TabHeaderState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTabContent { fn clone(&self) -> Self { let r: &azul_dll::widgets::tabs::TabContent = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTabOnClick { fn clone(&self) -> Self { let r: &azul_dll::widgets::tabs::TabOnClick = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTabOnClickCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::tabs::TabOnClickCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFrame { fn clone(&self) -> Self { let r: &crate::widgets::frame::Frame = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraph { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::NodeGraph = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeIdInfoMap { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::NodeTypeIdInfoMap = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputOutputTypeIdInfoMap { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::InputOutputTypeIdInfoMap = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeIdNodeMap { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::NodeIdNodeMap = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphCallbacks { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::NodeGraphCallbacks = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDropDownOnChoiceChange { fn clone(&self) -> Self { let r: &azul_dll::widgets::drop_down::DropDownOnChoiceChange = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnNodeAddedCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OnNodeAddedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnNodeAdded { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OnNodeAdded = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnNodeRemovedCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OnNodeRemovedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnNodeRemoved { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OnNodeRemoved = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnNodeGraphDraggedCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OnNodeGraphDraggedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnNodeGraphDragged { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OnNodeGraphDragged = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnNodeDraggedCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OnNodeDraggedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnNodeDragged { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OnNodeDragged = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnNodeConnectedCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OnNodeConnectedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnNodeConnected { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OnNodeConnected = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnNodeInputDisconnectedCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OnNodeInputDisconnectedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnNodeInputDisconnected { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OnNodeInputDisconnected = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnNodeOutputDisconnectedCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OnNodeOutputDisconnectedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnNodeOutputDisconnected { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OnNodeOutputDisconnected = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnNodeFieldEditedCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OnNodeFieldEditedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputOutputTypeId { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::InputOutputTypeId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeId { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::NodeTypeId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphNodeId { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::NodeGraphNodeId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNode { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::Node = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeField { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::NodeTypeField = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputConnection { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::InputConnection = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOutputNodeAndIndex { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OutputNodeAndIndex = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOutputConnection { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OutputConnection = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputNodeAndIndex { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::InputNodeAndIndex = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeInfo { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::NodeTypeInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputOutputInfo { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::InputOutputInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodePosition { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::NodePosition = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGraphDragAmount { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::GraphDragAmount = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDragAmount { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::NodeDragAmount = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListView { fn clone(&self) -> Self { let r: &azul_dll::widgets::list_view::ListView = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewRow { fn clone(&self) -> Self { let r: &azul_dll::widgets::list_view::ListViewRow = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewState { fn clone(&self) -> Self { let r: &azul_dll::widgets::list_view::ListViewState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewOnLazyLoadScrollCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::list_view::ListViewOnLazyLoadScrollCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewOnLazyLoadScroll { fn clone(&self) -> Self { let r: &azul_dll::widgets::list_view::ListViewOnLazyLoadScroll = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewOnColumnClickCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::list_view::ListViewOnColumnClickCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewOnColumnClick { fn clone(&self) -> Self { let r: &azul_dll::widgets::list_view::ListViewOnColumnClick = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewOnRowClickCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::list_view::ListViewOnRowClickCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewOnRowClick { fn clone(&self) -> Self { let r: &azul_dll::widgets::list_view::ListViewOnRowClick = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTreeView { fn clone(&self) -> Self { let r: &azul_dll::widgets::tree_view::TreeView = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDropDown { fn clone(&self) -> Self { let r: &azul_dll::widgets::drop_down::DropDown = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDropDownOnChoiceChangeCallback { fn clone(&self) -> Self { let r: &azul_dll::widgets::drop_down::DropDownOnChoiceChangeCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnNodeFieldEdited { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::OnNodeFieldEdited = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeHierarchyItem { fn clone(&self) -> Self { let r: &azul_core::styled_dom::NodeHierarchyItem = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCascadeInfo { fn clone(&self) -> Self { let r: &azul_core::style::CascadeInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyledNodeState { fn clone(&self) -> Self { let r: &azul_core::styled_dom::StyledNodeState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyledNode { fn clone(&self) -> Self { let r: &azul_core::styled_dom::StyledNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyledDom { fn clone(&self) -> Self { let r: &azul_core::styled_dom::StyledDom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTagIdToNodeIdMapping { fn clone(&self) -> Self { let r: &azul_core::styled_dom::TagIdToNodeIdMapping = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzParentWithNodeDepth { fn clone(&self) -> Self { let r: &azul_core::styled_dom::ParentWithNodeDepth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAzTagId { fn clone(&self) -> Self { let r: &azul_core::styled_dom::AzTagId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPropertyCachePtr { fn clone(&self) -> Self { let r: &azul_core::styled_dom::CssPropertyCachePtr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTexture { fn clone(&self) -> Self { let r: &azul_core::gl::Texture = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGlVoidPtrConst { fn clone(&self) -> Self { let r: &azul_core::gl::GlVoidPtrConst = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGlVoidPtrMut { fn clone(&self) -> Self { let r: &azul_core::gl::GlVoidPtrMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextureFlags { fn clone(&self) -> Self { let r: &azul_core::gl::TextureFlags = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGlShaderPrecisionFormatReturn { fn clone(&self) -> Self { let r: &azul_core::gl::GlShaderPrecisionFormatReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexAttribute { fn clone(&self) -> Self { let r: &azul_core::gl::VertexAttribute = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexLayout { fn clone(&self) -> Self { let r: &azul_core::gl::VertexLayout = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexArrayObject { fn clone(&self) -> Self { let r: &azul_core::gl::VertexArrayObject = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexBuffer { fn clone(&self) -> Self { let r: &azul_core::gl::VertexBuffer = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGlContextPtr { fn clone(&self) -> Self { let r: &azul_core::gl::GlContextPtr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU8VecRef { fn clone(&self) -> Self { let r: &azul_core::gl::U8VecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU8VecRefMut { fn clone(&self) -> Self { let r: &azul_core::gl::U8VecRefMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzF32VecRef { fn clone(&self) -> Self { let r: &azul_core::gl::F32VecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzI32VecRef { fn clone(&self) -> Self { let r: &azul_core::gl::I32VecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLuintVecRef { fn clone(&self) -> Self { let r: &azul_core::gl::GLuintVecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLenumVecRef { fn clone(&self) -> Self { let r: &azul_core::gl::GLenumVecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLintVecRefMut { fn clone(&self) -> Self { let r: &azul_core::gl::GLintVecRefMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLint64VecRefMut { fn clone(&self) -> Self { let r: &azul_core::gl::GLint64VecRefMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLbooleanVecRefMut { fn clone(&self) -> Self { let r: &azul_core::gl::GLbooleanVecRefMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLfloatVecRefMut { fn clone(&self) -> Self { let r: &azul_core::gl::GLfloatVecRefMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRefstrVecRef { fn clone(&self) -> Self { let r: &azul_core::gl::RefstrVecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRefstr { fn clone(&self) -> Self { let r: &azul_core::gl::Refstr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGetProgramBinaryReturn { fn clone(&self) -> Self { let r: &azul_core::gl::GetProgramBinaryReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGetActiveAttribReturn { fn clone(&self) -> Self { let r: &azul_core::gl::GetActiveAttribReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLsyncPtr { fn clone(&self) -> Self { let r: &azul_core::gl::GLsyncPtr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGetActiveUniformReturn { fn clone(&self) -> Self { let r: &azul_core::gl::GetActiveUniformReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAzDebugMessage { fn clone(&self) -> Self { let r: &azul_core::gl::AzDebugMessage = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzImageRef { fn clone(&self) -> Self { let r: &azul_core::resources::ImageRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRawImage { fn clone(&self) -> Self { let r: &azul_core::resources::RawImage = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzImageMask { fn clone(&self) -> Self { let r: &azul_core::resources::ImageMask = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLoadedFontSource { fn clone(&self) -> Self { let r: &azul_core::resources::LoadedFontSource = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvg { fn clone(&self) -> Self { let r: &azul_layout::xml::svg::Svg = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgXmlNode { fn clone(&self) -> Self { let r: &azul_layout::xml::svg::SvgXmlNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgMultiPolygon { fn clone(&self) -> Self { let r: &azul_core::svg::SvgMultiPolygon = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgStyledNode { fn clone(&self) -> Self { let r: &azul_core::svg::SvgStyledNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgCircle { fn clone(&self) -> Self { let r: &azul_core::svg::SvgCircle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPath { fn clone(&self) -> Self { let r: &azul_core::svg::SvgPath = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgLine { fn clone(&self) -> Self { let r: &azul_core::svg::SvgLine = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgColoredVertex { fn clone(&self) -> Self { let r: &azul_core::svg::SvgColoredVertex = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedColoredSvgNode { fn clone(&self) -> Self { let r: &azul_core::svg::TessellatedColoredSvgNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedColoredSvgNodeVecRef { fn clone(&self) -> Self { let r: &azul_core::svg::TessellatedColoredSvgNodeVecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedColoredGPUSvgNode { fn clone(&self) -> Self { let r: &azul_core::svg::TessellatedColoredGPUSvgNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgVertex { fn clone(&self) -> Self { let r: &azul_core::svg::SvgVertex = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedSvgNode { fn clone(&self) -> Self { let r: &azul_core::svg::TessellatedSvgNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedSvgNodeVecRef { fn clone(&self) -> Self { let r: &azul_core::svg::TessellatedSvgNodeVecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedGPUSvgNode { fn clone(&self) -> Self { let r: &azul_core::svg::TessellatedGPUSvgNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgParseOptions { fn clone(&self) -> Self { let r: &azul_core::svg::SvgParseOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgRenderOptions { fn clone(&self) -> Self { let r: &azul_core::svg::SvgRenderOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgRenderTransform { fn clone(&self) -> Self { let r: &azul_core::svg::SvgRenderTransform = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgDashPattern { fn clone(&self) -> Self { let r: &azul_core::svg::SvgDashPattern = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgTransform { fn clone(&self) -> Self { let r: &azul_core::svg::SvgTransform = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgFillStyle { fn clone(&self) -> Self { let r: &azul_core::svg::SvgFillStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgStrokeStyle { fn clone(&self) -> Self { let r: &azul_core::svg::SvgStrokeStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgXmlOptions { fn clone(&self) -> Self { let r: &azul_core::svg::SvgXmlOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXml { fn clone(&self) -> Self { let r: &azul_core::xml::Xml = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlNode { fn clone(&self) -> Self { let r: &azul_core::xml::XmlNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFile { fn clone(&self) -> Self { let r: &crate::azul_impl::file::File = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMsgBox { fn clone(&self) -> Self { let r: &crate::azul_impl::dialogs::MsgBox = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorPickerDialog { fn clone(&self) -> Self { let r: &crate::azul_impl::dialogs::ColorPickerDialog = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFileDialog { fn clone(&self) -> Self { let r: &crate::azul_impl::dialogs::FileDialog = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFileTypeList { fn clone(&self) -> Self { let r: &crate::azul_impl::dialogs::FileTypeList = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSystemTickDiff { fn clone(&self) -> Self { let r: &azul_core::task::SystemTickDiff = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAzInstantPtr { fn clone(&self) -> Self { let r: &azul_core::task::AzInstantPtr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInstantPtrCloneCallback { fn clone(&self) -> Self { let r: &azul_core::task::InstantPtrCloneCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSystemTick { fn clone(&self) -> Self { let r: &azul_core::task::SystemTick = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSystemTimeDiff { fn clone(&self) -> Self { let r: &azul_core::task::SystemTimeDiff = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInstantPtrDestructorCallback { fn clone(&self) -> Self { let r: &azul_core::task::InstantPtrDestructorCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTimerId { fn clone(&self) -> Self { let r: &azul_core::task::TimerId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTimer { fn clone(&self) -> Self { let r: &azul_core::task::Timer = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadId { fn clone(&self) -> Self { let r: &azul_core::task::ThreadId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThread { fn clone(&self) -> Self { let r: &azul_core::task::Thread = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadSender { fn clone(&self) -> Self { let r: &azul_core::task::ThreadSender = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadReceiver { fn clone(&self) -> Self { let r: &azul_core::task::ThreadReceiver = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadWriteBackMsg { fn clone(&self) -> Self { let r: &azul_core::task::ThreadWriteBackMsg = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadReceiverDestructorCallback { fn clone(&self) -> Self { let r: &azul_core::task::ThreadReceiverDestructorCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCreateThreadCallback { fn clone(&self) -> Self { let r: &azul_core::task::CreateThreadCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGetSystemTimeCallback { fn clone(&self) -> Self { let r: &azul_core::task::GetSystemTimeCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckThreadFinishedCallback { fn clone(&self) -> Self { let r: &azul_core::task::CheckThreadFinishedCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLibrarySendThreadMsgCallback { fn clone(&self) -> Self { let r: &azul_core::task::LibrarySendThreadMsgCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLibraryReceiveThreadMsgCallback { fn clone(&self) -> Self { let r: &azul_core::task::LibraryReceiveThreadMsgCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadRecvCallback { fn clone(&self) -> Self { let r: &azul_core::task::ThreadRecvCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadSendCallback { fn clone(&self) -> Self { let r: &azul_core::task::ThreadSendCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadDestructorCallback { fn clone(&self) -> Self { let r: &azul_core::task::ThreadDestructorCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadSenderDestructorCallback { fn clone(&self) -> Self { let r: &azul_core::task::ThreadSenderDestructorCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFmtArg { fn clone(&self) -> Self { let r: &azul_dll::str::FmtArg = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewRowVec { fn clone(&self) -> Self { let r: &crate::widgets::list_view::ListViewRowVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFilterVec { fn clone(&self) -> Self { let r: &azul_css::props::style::filter::StyleFilterVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLogicalRectVec { fn clone(&self) -> Self { let r: &azul_core::geom::LogicalRectVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeIdInfoMapVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeTypeIdInfoMapVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputOutputTypeIdInfoMapVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeIdNodeMapVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeIdNodeMapVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputOutputTypeIdVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputOutputTypeIdVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeFieldVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeTypeFieldVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputConnectionVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputConnectionVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOutputNodeAndIndexVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OutputNodeAndIndexVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOutputConnectionVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OutputConnectionVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputNodeAndIndexVec { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputNodeAndIndexVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityStateVec { fn clone(&self) -> Self { let r: &azul_core::dom::AccessibilityStateVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuItemVec { fn clone(&self) -> Self { let r: &azul_core::menu::MenuItemVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedSvgNodeVec { fn clone(&self) -> Self { let r: &azul_core::svg::TessellatedSvgNodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedColoredSvgNodeVec { fn clone(&self) -> Self { let r: &azul_core::svg::TessellatedColoredSvgNodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontFamilyVec { fn clone(&self) -> Self { let r: &azul_css::props::basic::font::StyleFontFamilyVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlNodeVec { fn clone(&self) -> Self { let r: &azul_core::xml::XmlNodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFmtArgVec { fn clone(&self) -> Self { let r: &crate::str::FmtArgVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineLineVec { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineLineVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineWordVec { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineWordVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineGlyphVec { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineGlyphVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineTextHitVec { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineTextHitVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMonitorVec { fn clone(&self) -> Self { let r: &azul_core::window::MonitorVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVideoModeVec { fn clone(&self) -> Self { let r: &azul_core::window::VideoModeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDomVec { fn clone(&self) -> Self { let r: &azul_core::dom::DomVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIdOrClassVec { fn clone(&self) -> Self { let r: &azul_core::dom::IdOrClassVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDataInlineCssPropertyVec { fn clone(&self) -> Self { let r: &azul_core::dom::NodeDataInlineCssPropertyVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundContentVec { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundContentVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundPositionVec { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundPositionVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundRepeatVec { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundRepeatVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundSizeVec { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundSizeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformVec { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPropertyVec { fn clone(&self) -> Self { let r: &azul_dll::widgets::number_input::CssPropertyVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgMultiPolygonVec { fn clone(&self) -> Self { let r: &azul_core::svg::SvgMultiPolygonVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgSimpleNodeVec { fn clone(&self) -> Self { let r: &azul_core::svg::SvgSimpleNodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPathVec { fn clone(&self) -> Self { let r: &azul_core::svg::SvgPathVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexAttributeVec { fn clone(&self) -> Self { let r: &azul_core::gl::VertexAttributeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPathElementVec { fn clone(&self) -> Self { let r: &azul_core::svg::SvgPathElementVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgVertexVec { fn clone(&self) -> Self { let r: &azul_core::svg::SvgVertexVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgColoredVertexVec { fn clone(&self) -> Self { let r: &azul_core::svg::SvgColoredVertexVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU32Vec { fn clone(&self) -> Self { let r: &azul_css::corety::U32Vec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXWindowTypeVec { fn clone(&self) -> Self { let r: &azul_core::window::XWindowTypeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVirtualKeyCodeVec { fn clone(&self) -> Self { let r: &azul_core::window::VirtualKeyCodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCascadeInfoVec { fn clone(&self) -> Self { let r: &azul_core::style::CascadeInfoVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzScanCodeVec { fn clone(&self) -> Self { let r: &azul_core::window::ScanCodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssDeclarationVec { fn clone(&self) -> Self { let r: &azul_css::css::CssDeclarationVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPathSelectorVec { fn clone(&self) -> Self { let r: &azul_css::css::CssPathSelectorVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStylesheetVec { fn clone(&self) -> Self { let r: &azul_css::css::StylesheetVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssRuleBlockVec { fn clone(&self) -> Self { let r: &azul_css::css::CssRuleBlockVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU16Vec { fn clone(&self) -> Self { let r: &azul_css::corety::U16Vec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzF32Vec { fn clone(&self) -> Self { let r: &azul_css::corety::F32Vec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU8Vec { fn clone(&self) -> Self { let r: &azul_css::corety::U8Vec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCallbackDataVec { fn clone(&self) -> Self { let r: &azul_core::dom::CallbackDataVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLuintVec { fn clone(&self) -> Self { let r: &azul_core::gl::GLuintVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLintVec { fn clone(&self) -> Self { let r: &azul_core::gl::GLintVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringVec { fn clone(&self) -> Self { let r: &azul_css::corety::StringVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringPairVec { fn clone(&self) -> Self { let r: &azul_core::window::StringPairVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedLinearColorStopVec { fn clone(&self) -> Self { let r: &azul_css::props::style::background::NormalizedLinearColorStopVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedRadialColorStopVec { fn clone(&self) -> Self { let r: &azul_css::props::style::background::NormalizedRadialColorStopVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeIdVec { fn clone(&self) -> Self { let r: &azul_core::styled_dom::NodeIdVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeHierarchyItemVec { fn clone(&self) -> Self { let r: &azul_core::styled_dom::NodeHierarchyItemVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyledNodeVec { fn clone(&self) -> Self { let r: &azul_core::styled_dom::StyledNodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTagIdToNodeIdMappingVec { fn clone(&self) -> Self { let r: &azul_core::styled_dom::TagIdToNodeIdMappingVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzParentWithNodeDepthVec { fn clone(&self) -> Self { let r: &azul_core::styled_dom::ParentWithNodeDepthVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDataVec { fn clone(&self) -> Self { let r: &azul_core::dom::NodeDataVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAzDebugMessageVec { fn clone(&self) -> Self { let r: &azul_core::gl::AzDebugMessageVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDuplicatedNamespaceError { fn clone(&self) -> Self { let r: &azul_core::xml::DuplicatedNamespaceError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzUnknownNamespaceError { fn clone(&self) -> Self { let r: &azul_core::xml::UnknownNamespaceError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzUnexpectedCloseTagError { fn clone(&self) -> Self { let r: &azul_core::xml::UnexpectedCloseTagError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzUnknownEntityReferenceError { fn clone(&self) -> Self { let r: &azul_core::xml::UnknownEntityReferenceError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDuplicatedAttributeError { fn clone(&self) -> Self { let r: &azul_core::xml::DuplicatedAttributeError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlTextError { fn clone(&self) -> Self { let r: &azul_core::xml::XmlTextError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNonXmlCharError { fn clone(&self) -> Self { let r: &azul_core::xml::NonXmlCharError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInvalidCharError { fn clone(&self) -> Self { let r: &azul_core::xml::InvalidCharError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInvalidCharMultipleError { fn clone(&self) -> Self { let r: &azul_core::xml::InvalidCharMultipleError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInvalidQuoteError { fn clone(&self) -> Self { let r: &azul_core::xml::InvalidQuoteError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInvalidSpaceError { fn clone(&self) -> Self { let r: &azul_core::xml::InvalidSpaceError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInvalidStringError { fn clone(&self) -> Self { let r: &azul_core::xml::InvalidStringError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlTextPos { fn clone(&self) -> Self { let r: &azul_core::xml::XmlTextPos = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzImageCache { fn clone(&self) -> Self { let r: &azul_core::resources::ImageCache = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFontCache { fn clone(&self) -> Self { let r: &azul_core::resources::FontCache = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDpiScaleFactor { fn clone(&self) -> Self { let r: &azul_core::resources::DpiScaleFactor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutSolverVersionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::app_resources::LayoutSolverVersion = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAppLogLevelEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::resources::AppLogLevel = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVsyncEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::Vsync = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSrgbEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::Srgb = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzHwAccelerationEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::HwAcceleration = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRawWindowHandleEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::RawWindowHandle = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXWindowTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::XWindowType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowIconEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowIcon = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVirtualKeyCodeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::VirtualKeyCode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAcceleratorKeyEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::AcceleratorKey = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowFrameEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowFrame = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMouseCursorTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::MouseCursorType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCursorPositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::CursorPosition = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRendererTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::RendererType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFullScreenModeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::FullScreenMode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowThemeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowTheme = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowPositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowPosition = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzImePositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::ImePosition = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzUserAttentionTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::UserAttentionType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowDecorationsEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowDecorations = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowBackgroundMaterialEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowBackgroundMaterial = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutCallbackEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::LayoutCallback = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzUpdateImageTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::UpdateImageType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzUpdateEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::Update = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPositionInfoEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::ui_solver::PositionInfo = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineWordEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineWord = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFocusTargetEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::FocusTarget = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzScriptTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::ui_solver::ScriptType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAnimationRepeatEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::AnimationRepeat = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAnimationRepeatCountEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::AnimationRepeatCount = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzEdgeTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::EdgeType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIFrameCallbackReasonEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::IFrameCallbackReason = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::NodeType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::On = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::EventFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzHoverEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::HoverEventFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFocusEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::FocusEventFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNotEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::NotEventFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::WindowEventFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzComponentEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::ComponentEventFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzApplicationEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::ApplicationEventFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityRoleEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::AccessibilityRole = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityStateEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::AccessibilityState = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTabIndexEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::TabIndex = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIdOrClassEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::IdOrClass = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDataInlineCssPropertyEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::NodeDataInlineCssProperty = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzContextMenuMouseButtonEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::ContextMenuMouseButton = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuPopupPositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::menu::MenuPopupPosition = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuItemEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::menu::MenuItem = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuItemIconEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::menu::MenuItemIcon = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuItemStateEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::menu::MenuItemState = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPathSelectorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::CssPathSelector = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPropertyEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::CssProperty = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPathPseudoSelectorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::CssPathPseudoSelector = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssNthChildSelectorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::CssNthChildSelector = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssDeclarationEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::CssDeclaration = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPropertyTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::CssPropertyType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAnimationInterpolationFunctionEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::animation::AnimationInterpolationFunction = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeTagEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::NodeTypeTag = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSizeMetricEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::length::SizeMetric = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzBoxShadowClipModeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::box_shadow::BoxShadowClipMode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleMixBlendModeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::effects::StyleMixBlendMode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::filter::StyleFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleCompositeFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::filter::StyleCompositeFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutAlignContentEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutAlignContent = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutAlignItemsEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutAlignItems = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBoxSizingEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::dimensions::LayoutBoxSizing = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexDirectionEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutFlexDirection = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutDisplayEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::display::LayoutDisplay = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFloatEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::display::LayoutFloat = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutJustifyContentEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutJustifyContent = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::position::LayoutPosition = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexWrapEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutFlexWrap = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutOverflowEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::overflow::LayoutOverflow = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAngleMetricEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::angle::AngleMetric = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDirectionCornerEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::direction::DirectionCorner = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDirectionEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::direction::Direction = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzExtendModeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::ExtendMode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::Shape = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRadialGradientSizeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::RadialGradientSize = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundContentEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundContent = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzBackgroundPositionHorizontalEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::BackgroundPositionHorizontal = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzBackgroundPositionVerticalEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::BackgroundPositionVertical = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundRepeatEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundRepeat = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundSizeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundSize = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzBorderStyleEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::border::BorderStyle = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleCursorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::effects::StyleCursor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontFamilyEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::font::StyleFontFamily = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackfaceVisibilityEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleBackfaceVisibility = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransform = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTextAlignEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleTextAlign = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBoxShadowValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBoxShadowValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutAlignContentValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutAlignContentValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutAlignItemsValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutAlignItemsValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBottomValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutBottomValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBoxSizingValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutBoxSizingValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexDirectionValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutFlexDirectionValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutDisplayValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutDisplayValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexGrowValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutFlexGrowValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexShrinkValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutFlexShrinkValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFloatValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutFloatValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutHeightValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutHeightValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutJustifyContentValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutJustifyContentValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutLeftValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutLeftValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginBottomValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutMarginBottomValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginLeftValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutMarginLeftValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginRightValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutMarginRightValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginTopValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutMarginTopValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMaxHeightValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutMaxHeightValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMaxWidthValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutMaxWidthValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMinHeightValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutMinHeightValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMinWidthValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutMinWidthValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingBottomValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutPaddingBottomValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingLeftValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutPaddingLeftValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingRightValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutPaddingRightValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingTopValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutPaddingTopValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPositionValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutPositionValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutRightValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutRightValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutTopValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutTopValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutWidthValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutWidthValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexWrapValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutFlexWrapValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutOverflowValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutOverflowValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzScrollbarStyleValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::ScrollbarStyleValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundContentVecValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBackgroundContentVecValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundPositionVecValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBackgroundPositionVecValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundRepeatVecValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBackgroundRepeatVecValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundSizeVecValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBackgroundSizeVecValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomColorValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBorderBottomColorValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomLeftRadiusValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBorderBottomLeftRadiusValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomRightRadiusValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBorderBottomRightRadiusValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomStyleValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBorderBottomStyleValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderBottomWidthValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutBorderBottomWidthValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderLeftColorValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBorderLeftColorValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderLeftStyleValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBorderLeftStyleValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderLeftWidthValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutBorderLeftWidthValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderRightColorValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBorderRightColorValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderRightStyleValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBorderRightStyleValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderRightWidthValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutBorderRightWidthValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopColorValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBorderTopColorValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopLeftRadiusValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBorderTopLeftRadiusValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopRightRadiusValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBorderTopRightRadiusValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopStyleValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBorderTopStyleValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderTopWidthValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::LayoutBorderTopWidthValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleCursorValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleCursorValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontFamilyVecValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleFontFamilyVecValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontSizeValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleFontSizeValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleLetterSpacingValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleLetterSpacingValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleLineHeightValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleLineHeightValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTabWidthValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleTabWidthValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTextAlignValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleTextAlignValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTextColorValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleTextColorValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleWordSpacingValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleWordSpacingValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleOpacityValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleOpacityValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformVecValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleTransformVecValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformOriginValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleTransformOriginValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStylePerspectiveOriginValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StylePerspectiveOriginValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackfaceVisibilityValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleBackfaceVisibilityValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleMixBlendModeValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleMixBlendModeValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFilterVecValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::StyleFilterVecValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPropertyValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::CssPropertyValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGridLineEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::GridLine = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutZIndexEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::position::LayoutZIndex = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutJustifyItemsEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::LayoutJustifyItems = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPlatformEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::system::Platform = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColumnSpanEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::column::ColumnSpan = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutClearEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::wrapping::LayoutClear = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleWhiteSpaceEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleWhiteSpace = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzBreakInsideEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::fragmentation::BreakInside = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutAlignSelfEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutAlignSelf = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapeOutsideEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::shape::ShapeOutside = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDesktopEnvironmentEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::system::DesktopEnvironment = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColumnCountEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::column::ColumnCount = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutWritingModeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::wrapping::LayoutWritingMode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleUserSelectEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleUserSelect = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFlowIntoEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flow::FlowInto = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutJustifySelfEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::LayoutJustifySelf = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleHyphensEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleHyphens = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleDirectionEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleDirection = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexBasisEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutFlexBasis = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutTextJustifyEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::text::LayoutTextJustify = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColumnWidthEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::column::ColumnWidth = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzBoxDecorationBreakEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::fragmentation::BoxDecorationBreak = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleVisibilityEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::effects::StyleVisibility = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThemeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::system::Theme = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutGridAutoFlowEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::LayoutGridAutoFlow = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTextDecorationEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleTextDecoration = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColumnFillEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::column::ColumnFill = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFlowFromEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flow::FlowFrom = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPageBreakEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::fragmentation::PageBreak = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutScrollbarWidthEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::scrollbar::LayoutScrollbarWidth = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleScrollbarColorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::scrollbar::StyleScrollbarColor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputSelectionEnumWrapper { fn clone(&self) -> Self { let r: &azul_dll::widgets::text_input::TextInputSelection = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputValidEnumWrapper { fn clone(&self) -> Self { let r: &azul_dll::widgets::text_input::TextInputValid = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeGraphStyleEnumWrapper { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::NodeGraphStyle = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeFieldValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_dll::widgets::node_graph::NodeTypeFieldValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPropertySourceEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::styled_dom::CssPropertySource = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexAttributeTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::VertexAttributeType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIndexBufferFormatEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::IndexBufferFormat = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAzGlTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::AzGlType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRawImageFormatEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::resources::RawImageFormat = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzEncodeImageErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::image::encode::EncodeImageError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDecodeImageErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::image::decode::DecodeImageError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRawImageDataEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::resources::RawImageData = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgNodeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgNode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgSimpleNodeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgSimpleNode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPathElementEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgPathElement = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapeRenderingEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::ShapeRendering = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextRenderingEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::TextRendering = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzImageRenderingEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::ImageRendering = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFontDatabaseEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::FontDatabase = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIndentEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::Indent = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgFitToEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgFitTo = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgStyleEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgStyle = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgFillRuleEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgFillRule = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgLineJoinEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgLineJoin = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgLineCapEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgLineCap = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgParseErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::xml::svg::SvgParseError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMsgBoxIconEnumWrapper { fn clone(&self) -> Self { let r: &crate::azul_impl::dialogs::MsgBoxIcon = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzYesNoEnumWrapper { fn clone(&self) -> Self { let r: &crate::azul_impl::dialogs::YesNo = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOkCancelEnumWrapper { fn clone(&self) -> Self { let r: &crate::azul_impl::dialogs::OkCancel = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInstantEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::task::Instant = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDurationEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::task::Duration = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTerminateTimerEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::task::TerminateTimer = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadSendMsgEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::task::ThreadSendMsg = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzThreadReceiveMsgEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::task::ThreadReceiveMsg = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFmtValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_dll::str::FmtValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontFamilyVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::font::StyleFontFamilyVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewRowVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::list_view::ListViewRowVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFilterVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::filter::StyleFilterVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLogicalRectVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::geom::LogicalRectVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeIdInfoMapVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeTypeIdInfoMapVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeIdNodeMapVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeIdNodeMapVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputOutputTypeIdVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputOutputTypeIdVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeFieldVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::NodeTypeFieldVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputConnectionVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputConnectionVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOutputNodeAndIndexVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OutputNodeAndIndexVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOutputConnectionVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OutputConnectionVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInputNodeAndIndexVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::InputNodeAndIndexVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityStateVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::AccessibilityStateVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuItemVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::menu::MenuItemVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedSvgNodeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::TessellatedSvgNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedColoredSvgNodeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::TessellatedColoredSvgNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlNodeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::xml::XmlNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFmtArgVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &crate::str::FmtArgVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineLineVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineLineVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineWordVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineWordVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineGlyphVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineGlyphVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInlineTextHitVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::InlineTextHitVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMonitorVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::MonitorVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVideoModeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::VideoModeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDomVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::DomVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIdOrClassVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::IdOrClassVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDataInlineCssPropertyVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::NodeDataInlineCssPropertyVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundContentVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundContentVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundPositionVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundPositionVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundRepeatVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundRepeatVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundSizeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundSizeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPropertyVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::CssPropertyVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgMultiPolygonVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgMultiPolygonVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgSimpleNodeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgSimpleNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPathVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgPathVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexAttributeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::VertexAttributeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPathElementVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgPathElementVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgVertexVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgVertexVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgColoredVertexVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgColoredVertexVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU32VecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::U32VecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXWindowTypeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::XWindowTypeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVirtualKeyCodeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::VirtualKeyCodeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCascadeInfoVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::style::CascadeInfoVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzScanCodeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::ScanCodeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssDeclarationVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::CssDeclarationVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPathSelectorVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::CssPathSelectorVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStylesheetVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::StylesheetVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssRuleBlockVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::CssRuleBlockVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzF32VecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::F32VecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU16VecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::U16VecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU8VecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::U8VecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCallbackDataVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::CallbackDataVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLuintVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::GLuintVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLintVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::GLintVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::StringVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringPairVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::StringPairVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedLinearColorStopVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::NormalizedLinearColorStopVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedRadialColorStopVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::NormalizedRadialColorStopVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeIdVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::styled_dom::NodeIdVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeHierarchyItemVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::styled_dom::NodeHierarchyItemVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyledNodeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::styled_dom::StyledNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTagIdToNodeIdMappingVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::styled_dom::TagIdToNodeIdMappingVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzParentWithNodeDepthVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::styled_dom::ParentWithNodeDepthVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDataVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::NodeDataVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAzDebugMessageVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::AzDebugMessageVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionSvgPointEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::animation::OptionSvgPoint = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionStyleTextAlignEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::text::OptionStyleTextAlign = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionListViewOnRowClickEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::list_view::OptionListViewOnRowClick = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionListViewOnColumnClickEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::list_view::OptionListViewOnColumnClick = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionListViewOnLazyLoadScrollEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::list_view::OptionListViewOnLazyLoadScroll = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionMenuEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::menu::OptionMenu = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionPixelValueNoPercentEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::pixel::OptionPixelValueNoPercent = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionDropDownOnChoiceChangeEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::drop_down::OptionDropDownOnChoiceChange = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionResolvedTextLayoutOptionsEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::ui_solver::OptionResolvedTextLayoutOptions = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionU8VecRefEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::OptionU8VecRef = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionOnNodeAddedEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OptionOnNodeAdded = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionOnNodeRemovedEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OptionOnNodeRemoved = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionOnNodeGraphDraggedEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OptionOnNodeGraphDragged = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionOnNodeDraggedEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OptionOnNodeDragged = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionOnNodeConnectedEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OptionOnNodeConnected = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionOnNodeInputDisconnectedEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OptionOnNodeInputDisconnected = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionOnNodeOutputDisconnectedEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OptionOnNodeOutputDisconnected = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionColorInputOnValueChangeEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::color_input::OptionColorInputOnValueChange = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionButtonOnClickEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::button::OptionButtonOnClick = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTabOnClickEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::tabs::OptionTabOnClick = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionFileInputOnPathChangeEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::file_input::OptionFileInputOnPathChange = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionCheckBoxOnToggleEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::check_box::OptionCheckBoxOnToggle = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTextInputOnTextInputEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::text_input::OptionTextInputOnTextInput = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTextInputOnVirtualKeyDownEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::text_input::OptionTextInputOnVirtualKeyDown = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTextInputOnFocusLostEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::text_input::OptionTextInputOnFocusLost = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTextInputSelectionEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::text_input::OptionTextInputSelection = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionNumberInputOnFocusLostEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::number_input::OptionNumberInputOnFocusLost = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionNumberInputOnValueChangeEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::number_input::OptionNumberInputOnValueChange = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionMenuItemIconEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::menu::OptionMenuItemIcon = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionMenuCallbackEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::callbacks::OptionMenuCallback = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionVirtualKeyCodeComboEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionVirtualKeyCodeCombo = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionCssPropertyEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::OptionCssProperty = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionPositionInfoEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::ui_solver::OptionPositionInfo = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTimerIdEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::task::OptionTimerId = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionThreadIdEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::task::OptionThreadId = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionI16EnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::OptionI16 = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionU16EnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::OptionU16 = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionU32EnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::OptionU32 = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionImageRefEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::resources::OptionImageRef = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionFontRefEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::font::OptionFontRef = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionOnNodeFieldEditedEnumWrapper { fn clone(&self) -> Self { let r: &crate::widgets::node_graph::OptionOnNodeFieldEdited = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionFileTypeListEnumWrapper { fn clone(&self) -> Self { let r: &azul_dll::desktop::dialogs::OptionFileTypeList = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionWindowStateEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::window_state::OptionWindowState = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionMouseStateEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionMouseState = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionKeyboardStateEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionKeyboardState = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionStringVecEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::OptionStringVec = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionFileEnumWrapper { fn clone(&self) -> Self { let r: &azul_dll::desktop::file::OptionFile = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionClipboardEnumWrapper { fn clone(&self) -> Self { let r: &azul_dll::desktop::app::OptionClipboard = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionThreadReceiveMsgEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::thread::OptionThreadReceiveMsg = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionPercentageValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::length::OptionPercentageValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionAngleValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::angle::OptionAngleValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionRendererOptionsEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionRendererOptions = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionCallbackEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::callbacks::OptionCallback = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionThreadSendMsgEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::task::OptionThreadSendMsg = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionLayoutRectEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::geometry::OptionLayoutRect = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionRefAnyEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::refany::OptionRefAny = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionInlineTextEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::OptionInlineText = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionLayoutPointEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::geometry::OptionLayoutPoint = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionLayoutSizeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::geometry::OptionLayoutSize = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionWindowThemeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionWindowTheme = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionNodeIdEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::styled_dom::OptionNodeId = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionDomNodeIdEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::OptionDomNodeId = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionColorUEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::color::OptionColorU = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionRawImageEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::resources::OptionRawImage = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionSvgDashPatternEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::OptionSvgDashPattern = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionWaylandThemeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionWaylandTheme = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTaskBarIconEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionTaskBarIcon = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionHwndHandleEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionHwndHandle = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionLogicalPositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::geom::OptionLogicalPosition = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionPhysicalPositionI32EnumWrapper { fn clone(&self) -> Self { let r: &azul_core::geom::OptionPhysicalPositionI32 = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionWindowIconEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionWindowIcon = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionGlContextPtrEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::OptionGlContextPtr = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionX11VisualEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionX11Visual = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionI32EnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::OptionI32 = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionF32EnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::OptionF32 = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionMouseCursorTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionMouseCursorType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionLogicalSizeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::geom::OptionLogicalSize = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionCharEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionChar = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionVirtualKeyCodeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionVirtualKeyCode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionDomEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::OptionDom = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTextureEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::OptionTexture = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionImageMaskEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::resources::OptionImageMask = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTabIndexEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::OptionTabIndex = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTagIdEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::styled_dom::OptionTagId = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionDurationEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::task::OptionDuration = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionInstantEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::task::OptionInstant = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionUsizeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::OptionUsize = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionU8VecEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::OptionU8Vec = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionAzStringEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::OptionAzString = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzResultXmlXmlErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::xml::ResultXmlXmlError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzResultRawImageDecodeImageErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::image::decode::ResultRawImageDecodeImageError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzResultU8VecEncodeImageErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::image::encode::ResultU8VecEncodeImageError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzResultSvgXmlNodeSvgParseErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::ResultSvgXmlNodeSvgParseError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzResultSvgSvgParseErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::ResultSvgSvgParseError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::xml::XmlError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlParseErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::xml::XmlParseError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlStreamErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::xml::XmlStreamError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAppTerminationBehaviorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::resources::AppTerminationBehavior = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }

// Implement Drop for all objects with drop constructors
impl Drop for AzAzAppPtr { fn drop(&mut self) { crate::AzAzAppPtr_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzRefCount { fn drop(&mut self) { crate::AzRefCount_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzRefAny { fn drop(&mut self) { crate::AzRefAny_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzFontRef { fn drop(&mut self) { crate::AzFontRef_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCssPropertyCachePtr { fn drop(&mut self) { crate::AzCssPropertyCachePtr_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzTexture { fn drop(&mut self) { crate::AzTexture_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzGlVoidPtrConst { fn drop(&mut self) { crate::AzGlVoidPtrConst_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzVertexArrayObject { fn drop(&mut self) { crate::AzVertexArrayObject_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzVertexBuffer { fn drop(&mut self) { crate::AzVertexBuffer_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzGlContextPtr { fn drop(&mut self) { crate::AzGlContextPtr_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzGLsyncPtr { fn drop(&mut self) { crate::AzGLsyncPtr_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvg { fn drop(&mut self) { crate::AzSvg_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgXmlNode { fn drop(&mut self) { crate::AzSvgXmlNode_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzFile { fn drop(&mut self) { crate::AzFile_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzAzInstantPtr { fn drop(&mut self) { crate::AzAzInstantPtr_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzThread { fn drop(&mut self) { crate::AzThread_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzThreadSender { fn drop(&mut self) { crate::AzThreadSender_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzThreadReceiver { fn drop(&mut self) { crate::AzThreadReceiver_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzListViewRowVec { fn drop(&mut self) { crate::AzListViewRowVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleFilterVec { fn drop(&mut self) { crate::AzStyleFilterVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzLogicalRectVec { fn drop(&mut self) { crate::AzLogicalRectVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeTypeIdInfoMapVec { fn drop(&mut self) { crate::AzNodeTypeIdInfoMapVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInputOutputTypeIdInfoMapVec { fn drop(&mut self) { crate::AzInputOutputTypeIdInfoMapVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeIdNodeMapVec { fn drop(&mut self) { crate::AzNodeIdNodeMapVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInputOutputTypeIdVec { fn drop(&mut self) { crate::AzInputOutputTypeIdVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeTypeFieldVec { fn drop(&mut self) { crate::AzNodeTypeFieldVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInputConnectionVec { fn drop(&mut self) { crate::AzInputConnectionVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzOutputNodeAndIndexVec { fn drop(&mut self) { crate::AzOutputNodeAndIndexVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzOutputConnectionVec { fn drop(&mut self) { crate::AzOutputConnectionVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInputNodeAndIndexVec { fn drop(&mut self) { crate::AzInputNodeAndIndexVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzAccessibilityStateVec { fn drop(&mut self) { crate::AzAccessibilityStateVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzMenuItemVec { fn drop(&mut self) { crate::AzMenuItemVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzTessellatedSvgNodeVec { fn drop(&mut self) { crate::AzTessellatedSvgNodeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzTessellatedColoredSvgNodeVec { fn drop(&mut self) { crate::AzTessellatedColoredSvgNodeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleFontFamilyVec { fn drop(&mut self) { crate::AzStyleFontFamilyVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzXmlNodeVec { fn drop(&mut self) { crate::AzXmlNodeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzFmtArgVec { fn drop(&mut self) { crate::AzFmtArgVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInlineLineVec { fn drop(&mut self) { crate::AzInlineLineVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInlineWordVec { fn drop(&mut self) { crate::AzInlineWordVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInlineGlyphVec { fn drop(&mut self) { crate::AzInlineGlyphVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzInlineTextHitVec { fn drop(&mut self) { crate::AzInlineTextHitVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzMonitorVec { fn drop(&mut self) { crate::AzMonitorVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzVideoModeVec { fn drop(&mut self) { crate::AzVideoModeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzDomVec { fn drop(&mut self) { crate::AzDomVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzIdOrClassVec { fn drop(&mut self) { crate::AzIdOrClassVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeDataInlineCssPropertyVec { fn drop(&mut self) { crate::AzNodeDataInlineCssPropertyVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleBackgroundContentVec { fn drop(&mut self) { crate::AzStyleBackgroundContentVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleBackgroundPositionVec { fn drop(&mut self) { crate::AzStyleBackgroundPositionVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleBackgroundRepeatVec { fn drop(&mut self) { crate::AzStyleBackgroundRepeatVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleBackgroundSizeVec { fn drop(&mut self) { crate::AzStyleBackgroundSizeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleTransformVec { fn drop(&mut self) { crate::AzStyleTransformVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCssPropertyVec { fn drop(&mut self) { crate::AzCssPropertyVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgMultiPolygonVec { fn drop(&mut self) { crate::AzSvgMultiPolygonVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgSimpleNodeVec { fn drop(&mut self) { crate::AzSvgSimpleNodeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgPathVec { fn drop(&mut self) { crate::AzSvgPathVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzVertexAttributeVec { fn drop(&mut self) { crate::AzVertexAttributeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgPathElementVec { fn drop(&mut self) { crate::AzSvgPathElementVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgVertexVec { fn drop(&mut self) { crate::AzSvgVertexVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgColoredVertexVec { fn drop(&mut self) { crate::AzSvgColoredVertexVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzU32Vec { fn drop(&mut self) { crate::AzU32Vec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzXWindowTypeVec { fn drop(&mut self) { crate::AzXWindowTypeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzVirtualKeyCodeVec { fn drop(&mut self) { crate::AzVirtualKeyCodeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCascadeInfoVec { fn drop(&mut self) { crate::AzCascadeInfoVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzScanCodeVec { fn drop(&mut self) { crate::AzScanCodeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCssDeclarationVec { fn drop(&mut self) { crate::AzCssDeclarationVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCssPathSelectorVec { fn drop(&mut self) { crate::AzCssPathSelectorVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStylesheetVec { fn drop(&mut self) { crate::AzStylesheetVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCssRuleBlockVec { fn drop(&mut self) { crate::AzCssRuleBlockVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzU16Vec { fn drop(&mut self) { crate::AzU16Vec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzF32Vec { fn drop(&mut self) { crate::AzF32Vec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzU8Vec { fn drop(&mut self) { crate::AzU8Vec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCallbackDataVec { fn drop(&mut self) { crate::AzCallbackDataVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzGLuintVec { fn drop(&mut self) { crate::AzGLuintVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzGLintVec { fn drop(&mut self) { crate::AzGLintVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStringVec { fn drop(&mut self) { crate::AzStringVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStringPairVec { fn drop(&mut self) { crate::AzStringPairVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNormalizedLinearColorStopVec { fn drop(&mut self) { crate::AzNormalizedLinearColorStopVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNormalizedRadialColorStopVec { fn drop(&mut self) { crate::AzNormalizedRadialColorStopVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeIdVec { fn drop(&mut self) { crate::AzNodeIdVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeHierarchyItemVec { fn drop(&mut self) { crate::AzNodeHierarchyItemVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyledNodeVec { fn drop(&mut self) { crate::AzStyledNodeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzTagIdToNodeIdMappingVec { fn drop(&mut self) { crate::AzTagIdToNodeIdMappingVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzParentWithNodeDepthVec { fn drop(&mut self) { crate::AzParentWithNodeDepthVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeDataVec { fn drop(&mut self) { crate::AzNodeDataVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzAzDebugMessageVec { fn drop(&mut self) { crate::AzAzDebugMessageVec_delete(unsafe { mem::transmute(self) }); } }

#[pymethods]
impl AzLayoutSolverVersionEnumWrapper {
    #[classattr]
    const Default: AzLayoutSolverVersion = AzLayoutSolverVersion::Default;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutSolverVersionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::LayoutSolverVersion = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::LayoutSolverVersion = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutSolverVersionEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAppConfig {
    #[new]
    fn new(/* args */) -> AzAppConfig {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzAppConfig {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::AppConfig = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::AppConfig = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAppLogLevelEnumWrapper {
    #[classattr]
    const Off: AzAppLogLevel = AzAppLogLevel::Off;
    #[classattr]
    const Error: AzAppLogLevel = AzAppLogLevel::Error;
    #[classattr]
    const Warn: AzAppLogLevel = AzAppLogLevel::Warn;
    #[classattr]
    const Info: AzAppLogLevel = AzAppLogLevel::Info;
    #[classattr]
    const Debug: AzAppLogLevel = AzAppLogLevel::Debug;
    #[classattr]
    const Trace: AzAppLogLevel = AzAppLogLevel::Trace;
}

#[pyproto]
impl PyObjectProtocol for AzAppLogLevelEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::AppLogLevel = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::AppLogLevel = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAppLogLevelEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAzAppPtr {
    fn add_image(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_monitors(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn run(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzAzAppPtr {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::desktop::app::AzAppPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::desktop::app::AzAppPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzExternalSystemCallbacks {
    #[staticmethod]
    fn library_internal(/* args */) -> AzExternalSystemCallbacks {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzExternalSystemCallbacks {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ExternalSystemCallbacks = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ExternalSystemCallbacks = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowCreateOptions {
    #[new]
    fn new(/* args */) -> AzWindowCreateOptions {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzWindowCreateOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowCreateOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowCreateOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRendererOptions {
}

#[pyproto]
impl PyObjectProtocol for AzRendererOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::RendererOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::RendererOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVsyncEnumWrapper {
    #[classattr]
    const Enabled: AzVsync = AzVsync::Enabled;
    #[classattr]
    const Disabled: AzVsync = AzVsync::Disabled;
    #[classattr]
    const DontCare: AzVsync = AzVsync::DontCare;
}

#[pyproto]
impl PyObjectProtocol for AzVsyncEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Vsync = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Vsync = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzVsyncEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSrgbEnumWrapper {
    #[classattr]
    const Enabled: AzSrgb = AzSrgb::Enabled;
    #[classattr]
    const Disabled: AzSrgb = AzSrgb::Disabled;
    #[classattr]
    const DontCare: AzSrgb = AzSrgb::DontCare;
}

#[pyproto]
impl PyObjectProtocol for AzSrgbEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Srgb = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Srgb = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzSrgbEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzHwAccelerationEnumWrapper {
    #[classattr]
    const Enabled: AzHwAcceleration = AzHwAcceleration::Enabled;
    #[classattr]
    const Disabled: AzHwAcceleration = AzHwAcceleration::Disabled;
    #[classattr]
    const DontCare: AzHwAcceleration = AzHwAcceleration::DontCare;
}

#[pyproto]
impl PyObjectProtocol for AzHwAccelerationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::HwAcceleration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::HwAcceleration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzHwAccelerationEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutPoint {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPoint {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutPoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutPoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutSize {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutSize {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutRect {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutRect {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRawWindowHandleEnumWrapper {
    #[staticmethod]
    fn IOS(v: IOSHandle) -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::IOS(v) }}
    }
    #[staticmethod]
    fn MacOS(v: MacOSHandle) -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::MacOS(v) }}
    }
    #[staticmethod]
    fn Xlib(v: XlibHandle) -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::Xlib(v) }}
    }
    #[staticmethod]
    fn Xcb(v: XcbHandle) -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::Xcb(v) }}
    }
    #[staticmethod]
    fn Wayland(v: WaylandHandle) -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::Wayland(v) }}
    }
    #[staticmethod]
    fn Windows(v: WindowsHandle) -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::Windows(v) }}
    }
    #[staticmethod]
    fn Web(v: WebHandle) -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::Web(v) }}
    }
    #[staticmethod]
    fn Android(v: AndroidHandle) -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::Android(v) }}
    }
    #[classattr]
    fn Unsupported() -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper { inner: AzRawWindowHandle::Unsupported }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzRawWindowHandle;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzRawWindowHandle::IOS(v) => Ok(vec!["IOS".into_py(py), v.into_py(py)]),
            AzRawWindowHandle::MacOS(v) => Ok(vec!["MacOS".into_py(py), v.into_py(py)]),
            AzRawWindowHandle::Xlib(v) => Ok(vec!["Xlib".into_py(py), v.into_py(py)]),
            AzRawWindowHandle::Xcb(v) => Ok(vec!["Xcb".into_py(py), v.into_py(py)]),
            AzRawWindowHandle::Wayland(v) => Ok(vec!["Wayland".into_py(py), v.into_py(py)]),
            AzRawWindowHandle::Windows(v) => Ok(vec!["Windows".into_py(py), v.into_py(py)]),
            AzRawWindowHandle::Web(v) => Ok(vec!["Web".into_py(py), v.into_py(py)]),
            AzRawWindowHandle::Android(v) => Ok(vec!["Android".into_py(py), v.into_py(py)]),
            AzRawWindowHandle::Unsupported => Ok(vec!["Unsupported".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRawWindowHandleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::RawWindowHandle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::RawWindowHandle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIOSHandle {
}

#[pyproto]
impl PyObjectProtocol for AzIOSHandle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::IOSHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::IOSHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMacOSHandle {
}

#[pyproto]
impl PyObjectProtocol for AzMacOSHandle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MacOSHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MacOSHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXlibHandle {
}

#[pyproto]
impl PyObjectProtocol for AzXlibHandle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XlibHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XlibHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXcbHandle {
}

#[pyproto]
impl PyObjectProtocol for AzXcbHandle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XcbHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XcbHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWaylandHandle {
}

#[pyproto]
impl PyObjectProtocol for AzWaylandHandle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WaylandHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WaylandHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowsHandle {
}

#[pyproto]
impl PyObjectProtocol for AzWindowsHandle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowsHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowsHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWebHandle {
}

#[pyproto]
impl PyObjectProtocol for AzWebHandle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WebHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WebHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAndroidHandle {
}

#[pyproto]
impl PyObjectProtocol for AzAndroidHandle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::AndroidHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::AndroidHandle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXWindowTypeEnumWrapper {
    #[classattr]
    const Desktop: AzXWindowType = AzXWindowType::Desktop;
    #[classattr]
    const Dock: AzXWindowType = AzXWindowType::Dock;
    #[classattr]
    const Toolbar: AzXWindowType = AzXWindowType::Toolbar;
    #[classattr]
    const Menu: AzXWindowType = AzXWindowType::Menu;
    #[classattr]
    const Utility: AzXWindowType = AzXWindowType::Utility;
    #[classattr]
    const Splash: AzXWindowType = AzXWindowType::Splash;
    #[classattr]
    const Dialog: AzXWindowType = AzXWindowType::Dialog;
    #[classattr]
    const DropdownMenu: AzXWindowType = AzXWindowType::DropdownMenu;
    #[classattr]
    const PopupMenu: AzXWindowType = AzXWindowType::PopupMenu;
    #[classattr]
    const Tooltip: AzXWindowType = AzXWindowType::Tooltip;
    #[classattr]
    const Notification: AzXWindowType = AzXWindowType::Notification;
    #[classattr]
    const Combo: AzXWindowType = AzXWindowType::Combo;
    #[classattr]
    const Dnd: AzXWindowType = AzXWindowType::Dnd;
    #[classattr]
    const Normal: AzXWindowType = AzXWindowType::Normal;
}

#[pyproto]
impl PyObjectProtocol for AzXWindowTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzXWindowTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzPhysicalPositionI32 {
}

#[pyproto]
impl PyObjectProtocol for AzPhysicalPositionI32 {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::PhysicalPositionI32 = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::PhysicalPositionI32 = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPhysicalSizeU32 {
}

#[pyproto]
impl PyObjectProtocol for AzPhysicalSizeU32 {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::PhysicalSizeU32 = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::PhysicalSizeU32 = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalRect {
}

#[pyproto]
impl PyObjectProtocol for AzLogicalRect {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LogicalRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LogicalRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalPosition {
    #[new]
    fn new(/* args */) -> AzLogicalPosition {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn zero(/* args */) -> AzLogicalPosition {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzLogicalPosition {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LogicalPosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LogicalPosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalSize {
    fn to_physical(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzLogicalSize {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LogicalSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LogicalSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIconKey {
}

#[pyproto]
impl PyObjectProtocol for AzIconKey {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::IconKey = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::IconKey = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSmallWindowIconBytes {
}

#[pyproto]
impl PyObjectProtocol for AzSmallWindowIconBytes {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::SmallWindowIconBytes = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::SmallWindowIconBytes = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLargeWindowIconBytes {
}

#[pyproto]
impl PyObjectProtocol for AzLargeWindowIconBytes {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LargeWindowIconBytes = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LargeWindowIconBytes = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowIconEnumWrapper {
    #[staticmethod]
    fn Small(v: SmallWindowIconBytes) -> AzWindowIconEnumWrapper {
        AzWindowIconEnumWrapper { inner: AzWindowIcon::Small(v) }}
    }
    #[staticmethod]
    fn Large(v: LargeWindowIconBytes) -> AzWindowIconEnumWrapper {
        AzWindowIconEnumWrapper { inner: AzWindowIcon::Large(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzWindowIcon;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzWindowIcon::Small(v) => Ok(vec!["Small".into_py(py), v.into_py(py)]),
            AzWindowIcon::Large(v) => Ok(vec!["Large".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzWindowIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTaskBarIcon {
}

#[pyproto]
impl PyObjectProtocol for AzTaskBarIcon {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::TaskBarIcon = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::TaskBarIcon = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVirtualKeyCodeEnumWrapper {
    #[classattr]
    const Key1: AzVirtualKeyCode = AzVirtualKeyCode::Key1;
    #[classattr]
    const Key2: AzVirtualKeyCode = AzVirtualKeyCode::Key2;
    #[classattr]
    const Key3: AzVirtualKeyCode = AzVirtualKeyCode::Key3;
    #[classattr]
    const Key4: AzVirtualKeyCode = AzVirtualKeyCode::Key4;
    #[classattr]
    const Key5: AzVirtualKeyCode = AzVirtualKeyCode::Key5;
    #[classattr]
    const Key6: AzVirtualKeyCode = AzVirtualKeyCode::Key6;
    #[classattr]
    const Key7: AzVirtualKeyCode = AzVirtualKeyCode::Key7;
    #[classattr]
    const Key8: AzVirtualKeyCode = AzVirtualKeyCode::Key8;
    #[classattr]
    const Key9: AzVirtualKeyCode = AzVirtualKeyCode::Key9;
    #[classattr]
    const Key0: AzVirtualKeyCode = AzVirtualKeyCode::Key0;
    #[classattr]
    const A: AzVirtualKeyCode = AzVirtualKeyCode::A;
    #[classattr]
    const B: AzVirtualKeyCode = AzVirtualKeyCode::B;
    #[classattr]
    const C: AzVirtualKeyCode = AzVirtualKeyCode::C;
    #[classattr]
    const D: AzVirtualKeyCode = AzVirtualKeyCode::D;
    #[classattr]
    const E: AzVirtualKeyCode = AzVirtualKeyCode::E;
    #[classattr]
    const F: AzVirtualKeyCode = AzVirtualKeyCode::F;
    #[classattr]
    const G: AzVirtualKeyCode = AzVirtualKeyCode::G;
    #[classattr]
    const H: AzVirtualKeyCode = AzVirtualKeyCode::H;
    #[classattr]
    const I: AzVirtualKeyCode = AzVirtualKeyCode::I;
    #[classattr]
    const J: AzVirtualKeyCode = AzVirtualKeyCode::J;
    #[classattr]
    const K: AzVirtualKeyCode = AzVirtualKeyCode::K;
    #[classattr]
    const L: AzVirtualKeyCode = AzVirtualKeyCode::L;
    #[classattr]
    const M: AzVirtualKeyCode = AzVirtualKeyCode::M;
    #[classattr]
    const N: AzVirtualKeyCode = AzVirtualKeyCode::N;
    #[classattr]
    const O: AzVirtualKeyCode = AzVirtualKeyCode::O;
    #[classattr]
    const P: AzVirtualKeyCode = AzVirtualKeyCode::P;
    #[classattr]
    const Q: AzVirtualKeyCode = AzVirtualKeyCode::Q;
    #[classattr]
    const R: AzVirtualKeyCode = AzVirtualKeyCode::R;
    #[classattr]
    const S: AzVirtualKeyCode = AzVirtualKeyCode::S;
    #[classattr]
    const T: AzVirtualKeyCode = AzVirtualKeyCode::T;
    #[classattr]
    const U: AzVirtualKeyCode = AzVirtualKeyCode::U;
    #[classattr]
    const V: AzVirtualKeyCode = AzVirtualKeyCode::V;
    #[classattr]
    const W: AzVirtualKeyCode = AzVirtualKeyCode::W;
    #[classattr]
    const X: AzVirtualKeyCode = AzVirtualKeyCode::X;
    #[classattr]
    const Y: AzVirtualKeyCode = AzVirtualKeyCode::Y;
    #[classattr]
    const Z: AzVirtualKeyCode = AzVirtualKeyCode::Z;
    #[classattr]
    const Escape: AzVirtualKeyCode = AzVirtualKeyCode::Escape;
    #[classattr]
    const F1: AzVirtualKeyCode = AzVirtualKeyCode::F1;
    #[classattr]
    const F2: AzVirtualKeyCode = AzVirtualKeyCode::F2;
    #[classattr]
    const F3: AzVirtualKeyCode = AzVirtualKeyCode::F3;
    #[classattr]
    const F4: AzVirtualKeyCode = AzVirtualKeyCode::F4;
    #[classattr]
    const F5: AzVirtualKeyCode = AzVirtualKeyCode::F5;
    #[classattr]
    const F6: AzVirtualKeyCode = AzVirtualKeyCode::F6;
    #[classattr]
    const F7: AzVirtualKeyCode = AzVirtualKeyCode::F7;
    #[classattr]
    const F8: AzVirtualKeyCode = AzVirtualKeyCode::F8;
    #[classattr]
    const F9: AzVirtualKeyCode = AzVirtualKeyCode::F9;
    #[classattr]
    const F10: AzVirtualKeyCode = AzVirtualKeyCode::F10;
    #[classattr]
    const F11: AzVirtualKeyCode = AzVirtualKeyCode::F11;
    #[classattr]
    const F12: AzVirtualKeyCode = AzVirtualKeyCode::F12;
    #[classattr]
    const F13: AzVirtualKeyCode = AzVirtualKeyCode::F13;
    #[classattr]
    const F14: AzVirtualKeyCode = AzVirtualKeyCode::F14;
    #[classattr]
    const F15: AzVirtualKeyCode = AzVirtualKeyCode::F15;
    #[classattr]
    const F16: AzVirtualKeyCode = AzVirtualKeyCode::F16;
    #[classattr]
    const F17: AzVirtualKeyCode = AzVirtualKeyCode::F17;
    #[classattr]
    const F18: AzVirtualKeyCode = AzVirtualKeyCode::F18;
    #[classattr]
    const F19: AzVirtualKeyCode = AzVirtualKeyCode::F19;
    #[classattr]
    const F20: AzVirtualKeyCode = AzVirtualKeyCode::F20;
    #[classattr]
    const F21: AzVirtualKeyCode = AzVirtualKeyCode::F21;
    #[classattr]
    const F22: AzVirtualKeyCode = AzVirtualKeyCode::F22;
    #[classattr]
    const F23: AzVirtualKeyCode = AzVirtualKeyCode::F23;
    #[classattr]
    const F24: AzVirtualKeyCode = AzVirtualKeyCode::F24;
    #[classattr]
    const Snapshot: AzVirtualKeyCode = AzVirtualKeyCode::Snapshot;
    #[classattr]
    const Scroll: AzVirtualKeyCode = AzVirtualKeyCode::Scroll;
    #[classattr]
    const Pause: AzVirtualKeyCode = AzVirtualKeyCode::Pause;
    #[classattr]
    const Insert: AzVirtualKeyCode = AzVirtualKeyCode::Insert;
    #[classattr]
    const Home: AzVirtualKeyCode = AzVirtualKeyCode::Home;
    #[classattr]
    const Delete: AzVirtualKeyCode = AzVirtualKeyCode::Delete;
    #[classattr]
    const End: AzVirtualKeyCode = AzVirtualKeyCode::End;
    #[classattr]
    const PageDown: AzVirtualKeyCode = AzVirtualKeyCode::PageDown;
    #[classattr]
    const PageUp: AzVirtualKeyCode = AzVirtualKeyCode::PageUp;
    #[classattr]
    const Left: AzVirtualKeyCode = AzVirtualKeyCode::Left;
    #[classattr]
    const Up: AzVirtualKeyCode = AzVirtualKeyCode::Up;
    #[classattr]
    const Right: AzVirtualKeyCode = AzVirtualKeyCode::Right;
    #[classattr]
    const Down: AzVirtualKeyCode = AzVirtualKeyCode::Down;
    #[classattr]
    const Back: AzVirtualKeyCode = AzVirtualKeyCode::Back;
    #[classattr]
    const Return: AzVirtualKeyCode = AzVirtualKeyCode::Return;
    #[classattr]
    const Space: AzVirtualKeyCode = AzVirtualKeyCode::Space;
    #[classattr]
    const Compose: AzVirtualKeyCode = AzVirtualKeyCode::Compose;
    #[classattr]
    const Caret: AzVirtualKeyCode = AzVirtualKeyCode::Caret;
    #[classattr]
    const Numlock: AzVirtualKeyCode = AzVirtualKeyCode::Numlock;
    #[classattr]
    const Numpad0: AzVirtualKeyCode = AzVirtualKeyCode::Numpad0;
    #[classattr]
    const Numpad1: AzVirtualKeyCode = AzVirtualKeyCode::Numpad1;
    #[classattr]
    const Numpad2: AzVirtualKeyCode = AzVirtualKeyCode::Numpad2;
    #[classattr]
    const Numpad3: AzVirtualKeyCode = AzVirtualKeyCode::Numpad3;
    #[classattr]
    const Numpad4: AzVirtualKeyCode = AzVirtualKeyCode::Numpad4;
    #[classattr]
    const Numpad5: AzVirtualKeyCode = AzVirtualKeyCode::Numpad5;
    #[classattr]
    const Numpad6: AzVirtualKeyCode = AzVirtualKeyCode::Numpad6;
    #[classattr]
    const Numpad7: AzVirtualKeyCode = AzVirtualKeyCode::Numpad7;
    #[classattr]
    const Numpad8: AzVirtualKeyCode = AzVirtualKeyCode::Numpad8;
    #[classattr]
    const Numpad9: AzVirtualKeyCode = AzVirtualKeyCode::Numpad9;
    #[classattr]
    const NumpadAdd: AzVirtualKeyCode = AzVirtualKeyCode::NumpadAdd;
    #[classattr]
    const NumpadDivide: AzVirtualKeyCode = AzVirtualKeyCode::NumpadDivide;
    #[classattr]
    const NumpadDecimal: AzVirtualKeyCode = AzVirtualKeyCode::NumpadDecimal;
    #[classattr]
    const NumpadComma: AzVirtualKeyCode = AzVirtualKeyCode::NumpadComma;
    #[classattr]
    const NumpadEnter: AzVirtualKeyCode = AzVirtualKeyCode::NumpadEnter;
    #[classattr]
    const NumpadEquals: AzVirtualKeyCode = AzVirtualKeyCode::NumpadEquals;
    #[classattr]
    const NumpadMultiply: AzVirtualKeyCode = AzVirtualKeyCode::NumpadMultiply;
    #[classattr]
    const NumpadSubtract: AzVirtualKeyCode = AzVirtualKeyCode::NumpadSubtract;
    #[classattr]
    const AbntC1: AzVirtualKeyCode = AzVirtualKeyCode::AbntC1;
    #[classattr]
    const AbntC2: AzVirtualKeyCode = AzVirtualKeyCode::AbntC2;
    #[classattr]
    const Apostrophe: AzVirtualKeyCode = AzVirtualKeyCode::Apostrophe;
    #[classattr]
    const Apps: AzVirtualKeyCode = AzVirtualKeyCode::Apps;
    #[classattr]
    const Asterisk: AzVirtualKeyCode = AzVirtualKeyCode::Asterisk;
    #[classattr]
    const At: AzVirtualKeyCode = AzVirtualKeyCode::At;
    #[classattr]
    const Ax: AzVirtualKeyCode = AzVirtualKeyCode::Ax;
    #[classattr]
    const Backslash: AzVirtualKeyCode = AzVirtualKeyCode::Backslash;
    #[classattr]
    const Calculator: AzVirtualKeyCode = AzVirtualKeyCode::Calculator;
    #[classattr]
    const Capital: AzVirtualKeyCode = AzVirtualKeyCode::Capital;
    #[classattr]
    const Colon: AzVirtualKeyCode = AzVirtualKeyCode::Colon;
    #[classattr]
    const Comma: AzVirtualKeyCode = AzVirtualKeyCode::Comma;
    #[classattr]
    const Convert: AzVirtualKeyCode = AzVirtualKeyCode::Convert;
    #[classattr]
    const Equals: AzVirtualKeyCode = AzVirtualKeyCode::Equals;
    #[classattr]
    const Grave: AzVirtualKeyCode = AzVirtualKeyCode::Grave;
    #[classattr]
    const Kana: AzVirtualKeyCode = AzVirtualKeyCode::Kana;
    #[classattr]
    const Kanji: AzVirtualKeyCode = AzVirtualKeyCode::Kanji;
    #[classattr]
    const LAlt: AzVirtualKeyCode = AzVirtualKeyCode::LAlt;
    #[classattr]
    const LBracket: AzVirtualKeyCode = AzVirtualKeyCode::LBracket;
    #[classattr]
    const LControl: AzVirtualKeyCode = AzVirtualKeyCode::LControl;
    #[classattr]
    const LShift: AzVirtualKeyCode = AzVirtualKeyCode::LShift;
    #[classattr]
    const LWin: AzVirtualKeyCode = AzVirtualKeyCode::LWin;
    #[classattr]
    const Mail: AzVirtualKeyCode = AzVirtualKeyCode::Mail;
    #[classattr]
    const MediaSelect: AzVirtualKeyCode = AzVirtualKeyCode::MediaSelect;
    #[classattr]
    const MediaStop: AzVirtualKeyCode = AzVirtualKeyCode::MediaStop;
    #[classattr]
    const Minus: AzVirtualKeyCode = AzVirtualKeyCode::Minus;
    #[classattr]
    const Mute: AzVirtualKeyCode = AzVirtualKeyCode::Mute;
    #[classattr]
    const MyComputer: AzVirtualKeyCode = AzVirtualKeyCode::MyComputer;
    #[classattr]
    const NavigateForward: AzVirtualKeyCode = AzVirtualKeyCode::NavigateForward;
    #[classattr]
    const NavigateBackward: AzVirtualKeyCode = AzVirtualKeyCode::NavigateBackward;
    #[classattr]
    const NextTrack: AzVirtualKeyCode = AzVirtualKeyCode::NextTrack;
    #[classattr]
    const NoConvert: AzVirtualKeyCode = AzVirtualKeyCode::NoConvert;
    #[classattr]
    const OEM102: AzVirtualKeyCode = AzVirtualKeyCode::OEM102;
    #[classattr]
    const Period: AzVirtualKeyCode = AzVirtualKeyCode::Period;
    #[classattr]
    const PlayPause: AzVirtualKeyCode = AzVirtualKeyCode::PlayPause;
    #[classattr]
    const Plus: AzVirtualKeyCode = AzVirtualKeyCode::Plus;
    #[classattr]
    const Power: AzVirtualKeyCode = AzVirtualKeyCode::Power;
    #[classattr]
    const PrevTrack: AzVirtualKeyCode = AzVirtualKeyCode::PrevTrack;
    #[classattr]
    const RAlt: AzVirtualKeyCode = AzVirtualKeyCode::RAlt;
    #[classattr]
    const RBracket: AzVirtualKeyCode = AzVirtualKeyCode::RBracket;
    #[classattr]
    const RControl: AzVirtualKeyCode = AzVirtualKeyCode::RControl;
    #[classattr]
    const RShift: AzVirtualKeyCode = AzVirtualKeyCode::RShift;
    #[classattr]
    const RWin: AzVirtualKeyCode = AzVirtualKeyCode::RWin;
    #[classattr]
    const Semicolon: AzVirtualKeyCode = AzVirtualKeyCode::Semicolon;
    #[classattr]
    const Slash: AzVirtualKeyCode = AzVirtualKeyCode::Slash;
    #[classattr]
    const Sleep: AzVirtualKeyCode = AzVirtualKeyCode::Sleep;
    #[classattr]
    const Stop: AzVirtualKeyCode = AzVirtualKeyCode::Stop;
    #[classattr]
    const Sysrq: AzVirtualKeyCode = AzVirtualKeyCode::Sysrq;
    #[classattr]
    const Tab: AzVirtualKeyCode = AzVirtualKeyCode::Tab;
    #[classattr]
    const Underline: AzVirtualKeyCode = AzVirtualKeyCode::Underline;
    #[classattr]
    const Unlabeled: AzVirtualKeyCode = AzVirtualKeyCode::Unlabeled;
    #[classattr]
    const VolumeDown: AzVirtualKeyCode = AzVirtualKeyCode::VolumeDown;
    #[classattr]
    const VolumeUp: AzVirtualKeyCode = AzVirtualKeyCode::VolumeUp;
    #[classattr]
    const Wake: AzVirtualKeyCode = AzVirtualKeyCode::Wake;
    #[classattr]
    const WebBack: AzVirtualKeyCode = AzVirtualKeyCode::WebBack;
    #[classattr]
    const WebFavorites: AzVirtualKeyCode = AzVirtualKeyCode::WebFavorites;
    #[classattr]
    const WebForward: AzVirtualKeyCode = AzVirtualKeyCode::WebForward;
    #[classattr]
    const WebHome: AzVirtualKeyCode = AzVirtualKeyCode::WebHome;
    #[classattr]
    const WebRefresh: AzVirtualKeyCode = AzVirtualKeyCode::WebRefresh;
    #[classattr]
    const WebSearch: AzVirtualKeyCode = AzVirtualKeyCode::WebSearch;
    #[classattr]
    const WebStop: AzVirtualKeyCode = AzVirtualKeyCode::WebStop;
    #[classattr]
    const Yen: AzVirtualKeyCode = AzVirtualKeyCode::Yen;
    #[classattr]
    const Copy: AzVirtualKeyCode = AzVirtualKeyCode::Copy;
    #[classattr]
    const Paste: AzVirtualKeyCode = AzVirtualKeyCode::Paste;
    #[classattr]
    const Cut: AzVirtualKeyCode = AzVirtualKeyCode::Cut;
}

#[pyproto]
impl PyObjectProtocol for AzVirtualKeyCodeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzVirtualKeyCodeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAcceleratorKeyEnumWrapper {
    #[classattr]
    fn Ctrl() -> AzAcceleratorKeyEnumWrapper {
        AzAcceleratorKeyEnumWrapper { inner: AzAcceleratorKey::Ctrl }
    }
    #[classattr]
    fn Alt() -> AzAcceleratorKeyEnumWrapper {
        AzAcceleratorKeyEnumWrapper { inner: AzAcceleratorKey::Alt }
    }
    #[classattr]
    fn Shift() -> AzAcceleratorKeyEnumWrapper {
        AzAcceleratorKeyEnumWrapper { inner: AzAcceleratorKey::Shift }
    }
    #[staticmethod]
    fn Key(v: VirtualKeyCode) -> AzAcceleratorKeyEnumWrapper {
        AzAcceleratorKeyEnumWrapper { inner: AzAcceleratorKey::Key(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzAcceleratorKey;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAcceleratorKey::Ctrl => Ok(vec!["Ctrl".into_py(py), ().into_py(py)]),
            AzAcceleratorKey::Alt => Ok(vec!["Alt".into_py(py), ().into_py(py)]),
            AzAcceleratorKey::Shift => Ok(vec!["Shift".into_py(py), ().into_py(py)]),
            AzAcceleratorKey::Key(v) => Ok(vec!["Key".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAcceleratorKeyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::AcceleratorKey = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::AcceleratorKey = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowSize {
    fn get_hidpi_factor(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzWindowSize {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowFlags {
}

#[pyproto]
impl PyObjectProtocol for AzWindowFlags {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowFlags = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowFlags = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowFrameEnumWrapper {
    #[classattr]
    const Normal: AzWindowFrame = AzWindowFrame::Normal;
    #[classattr]
    const Minimized: AzWindowFrame = AzWindowFrame::Minimized;
    #[classattr]
    const Maximized: AzWindowFrame = AzWindowFrame::Maximized;
    #[classattr]
    const Fullscreen: AzWindowFrame = AzWindowFrame::Fullscreen;
}

#[pyproto]
impl PyObjectProtocol for AzWindowFrameEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowFrame = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowFrame = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzWindowFrameEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzDebugState {
}

#[pyproto]
impl PyObjectProtocol for AzDebugState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::DebugState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::DebugState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzKeyboardState {
    fn shift_down(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn ctrl_down(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn alt_down(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn super_down(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_key_down(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzKeyboardState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::KeyboardState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::KeyboardState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMouseCursorTypeEnumWrapper {
    #[classattr]
    const Default: AzMouseCursorType = AzMouseCursorType::Default;
    #[classattr]
    const Crosshair: AzMouseCursorType = AzMouseCursorType::Crosshair;
    #[classattr]
    const Hand: AzMouseCursorType = AzMouseCursorType::Hand;
    #[classattr]
    const Arrow: AzMouseCursorType = AzMouseCursorType::Arrow;
    #[classattr]
    const Move: AzMouseCursorType = AzMouseCursorType::Move;
    #[classattr]
    const Text: AzMouseCursorType = AzMouseCursorType::Text;
    #[classattr]
    const Wait: AzMouseCursorType = AzMouseCursorType::Wait;
    #[classattr]
    const Help: AzMouseCursorType = AzMouseCursorType::Help;
    #[classattr]
    const Progress: AzMouseCursorType = AzMouseCursorType::Progress;
    #[classattr]
    const NotAllowed: AzMouseCursorType = AzMouseCursorType::NotAllowed;
    #[classattr]
    const ContextMenu: AzMouseCursorType = AzMouseCursorType::ContextMenu;
    #[classattr]
    const Cell: AzMouseCursorType = AzMouseCursorType::Cell;
    #[classattr]
    const VerticalText: AzMouseCursorType = AzMouseCursorType::VerticalText;
    #[classattr]
    const Alias: AzMouseCursorType = AzMouseCursorType::Alias;
    #[classattr]
    const Copy: AzMouseCursorType = AzMouseCursorType::Copy;
    #[classattr]
    const NoDrop: AzMouseCursorType = AzMouseCursorType::NoDrop;
    #[classattr]
    const Grab: AzMouseCursorType = AzMouseCursorType::Grab;
    #[classattr]
    const Grabbing: AzMouseCursorType = AzMouseCursorType::Grabbing;
    #[classattr]
    const AllScroll: AzMouseCursorType = AzMouseCursorType::AllScroll;
    #[classattr]
    const ZoomIn: AzMouseCursorType = AzMouseCursorType::ZoomIn;
    #[classattr]
    const ZoomOut: AzMouseCursorType = AzMouseCursorType::ZoomOut;
    #[classattr]
    const EResize: AzMouseCursorType = AzMouseCursorType::EResize;
    #[classattr]
    const NResize: AzMouseCursorType = AzMouseCursorType::NResize;
    #[classattr]
    const NeResize: AzMouseCursorType = AzMouseCursorType::NeResize;
    #[classattr]
    const NwResize: AzMouseCursorType = AzMouseCursorType::NwResize;
    #[classattr]
    const SResize: AzMouseCursorType = AzMouseCursorType::SResize;
    #[classattr]
    const SeResize: AzMouseCursorType = AzMouseCursorType::SeResize;
    #[classattr]
    const SwResize: AzMouseCursorType = AzMouseCursorType::SwResize;
    #[classattr]
    const WResize: AzMouseCursorType = AzMouseCursorType::WResize;
    #[classattr]
    const EwResize: AzMouseCursorType = AzMouseCursorType::EwResize;
    #[classattr]
    const NsResize: AzMouseCursorType = AzMouseCursorType::NsResize;
    #[classattr]
    const NeswResize: AzMouseCursorType = AzMouseCursorType::NeswResize;
    #[classattr]
    const NwseResize: AzMouseCursorType = AzMouseCursorType::NwseResize;
    #[classattr]
    const ColResize: AzMouseCursorType = AzMouseCursorType::ColResize;
    #[classattr]
    const RowResize: AzMouseCursorType = AzMouseCursorType::RowResize;
}

#[pyproto]
impl PyObjectProtocol for AzMouseCursorTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MouseCursorType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MouseCursorType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzMouseCursorTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzCursorPositionEnumWrapper {
    #[staticmethod]
    fn OutOfWindow(v: LogicalPosition) -> AzCursorPositionEnumWrapper {
        AzCursorPositionEnumWrapper { inner: AzCursorPosition::OutOfWindow(v) }}
    }
    #[classattr]
    fn Uninitialized() -> AzCursorPositionEnumWrapper {
        AzCursorPositionEnumWrapper { inner: AzCursorPosition::Uninitialized }
    }
    #[staticmethod]
    fn InWindow(v: LogicalPosition) -> AzCursorPositionEnumWrapper {
        AzCursorPositionEnumWrapper { inner: AzCursorPosition::InWindow(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCursorPosition;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCursorPosition::OutOfWindow(v) => Ok(vec!["OutOfWindow".into_py(py), v.into_py(py)]),
            AzCursorPosition::Uninitialized => Ok(vec!["Uninitialized".into_py(py), ().into_py(py)]),
            AzCursorPosition::InWindow(v) => Ok(vec!["InWindow".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCursorPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::CursorPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::CursorPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMouseState {
}

#[pyproto]
impl PyObjectProtocol for AzMouseState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MouseState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MouseState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPlatformSpecificOptions {
}

#[pyproto]
impl PyObjectProtocol for AzPlatformSpecificOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::PlatformSpecificOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::PlatformSpecificOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowsWindowOptions {
}

#[pyproto]
impl PyObjectProtocol for AzWindowsWindowOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowsWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowsWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWaylandTheme {
}

#[pyproto]
impl PyObjectProtocol for AzWaylandTheme {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WaylandTheme = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WaylandTheme = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRendererTypeEnumWrapper {
    #[classattr]
    const Hardware: AzRendererType = AzRendererType::Hardware;
    #[classattr]
    const Software: AzRendererType = AzRendererType::Software;
}

#[pyproto]
impl PyObjectProtocol for AzRendererTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::RendererType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::RendererType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzRendererTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzWindowState {
    #[new]
    fn new(/* args */) -> AzWindowState {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn default(/* args */) -> AzWindowState {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzWindowState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLinuxWindowOptions {
}

#[pyproto]
impl PyObjectProtocol for AzLinuxWindowOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LinuxWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LinuxWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMacWindowOptions {
}

#[pyproto]
impl PyObjectProtocol for AzMacWindowOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MacWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MacWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWasmWindowOptions {
}

#[pyproto]
impl PyObjectProtocol for AzWasmWindowOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WasmWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WasmWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFullScreenModeEnumWrapper {
    #[classattr]
    const SlowFullScreen: AzFullScreenMode = AzFullScreenMode::SlowFullScreen;
    #[classattr]
    const FastFullScreen: AzFullScreenMode = AzFullScreenMode::FastFullScreen;
    #[classattr]
    const SlowWindowed: AzFullScreenMode = AzFullScreenMode::SlowWindowed;
    #[classattr]
    const FastWindowed: AzFullScreenMode = AzFullScreenMode::FastWindowed;
}

#[pyproto]
impl PyObjectProtocol for AzFullScreenModeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::FullScreenMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::FullScreenMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzFullScreenModeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzWindowThemeEnumWrapper {
    #[classattr]
    const DarkMode: AzWindowTheme = AzWindowTheme::DarkMode;
    #[classattr]
    const LightMode: AzWindowTheme = AzWindowTheme::LightMode;
}

#[pyproto]
impl PyObjectProtocol for AzWindowThemeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzWindowThemeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzWindowPositionEnumWrapper {
    #[classattr]
    fn Uninitialized() -> AzWindowPositionEnumWrapper {
        AzWindowPositionEnumWrapper { inner: AzWindowPosition::Uninitialized }
    }
    #[staticmethod]
    fn Initialized(v: PhysicalPositionI32) -> AzWindowPositionEnumWrapper {
        AzWindowPositionEnumWrapper { inner: AzWindowPosition::Initialized(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzWindowPosition;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzWindowPosition::Uninitialized => Ok(vec!["Uninitialized".into_py(py), ().into_py(py)]),
            AzWindowPosition::Initialized(v) => Ok(vec!["Initialized".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzWindowPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzImePositionEnumWrapper {
    #[classattr]
    fn Uninitialized() -> AzImePositionEnumWrapper {
        AzImePositionEnumWrapper { inner: AzImePosition::Uninitialized }
    }
    #[staticmethod]
    fn Initialized(v: LogicalRect) -> AzImePositionEnumWrapper {
        AzImePositionEnumWrapper { inner: AzImePosition::Initialized(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzImePosition;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzImePosition::Uninitialized => Ok(vec!["Uninitialized".into_py(py), ().into_py(py)]),
            AzImePosition::Initialized(v) => Ok(vec!["Initialized".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzImePositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ImePosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ImePosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTouchState {
}

#[pyproto]
impl PyObjectProtocol for AzTouchState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::TouchState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::TouchState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMonitor {
}

#[pyproto]
impl PyObjectProtocol for AzMonitor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Monitor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Monitor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVideoMode {
}

#[pyproto]
impl PyObjectProtocol for AzVideoMode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoMode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoMode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAzStringPair {
}

#[pyproto]
impl PyObjectProtocol for AzAzStringPair {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::AzStringPair = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::AzStringPair = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemCallbacks {
}

#[pyproto]
impl PyObjectProtocol for AzSystemCallbacks {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::window::SystemCallbacks = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::window::SystemCallbacks = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUserAttentionTypeEnumWrapper {
    #[classattr]
    const None: AzUserAttentionType = AzUserAttentionType::None;
    #[classattr]
    const Critical: AzUserAttentionType = AzUserAttentionType::Critical;
    #[classattr]
    const Informational: AzUserAttentionType = AzUserAttentionType::Informational;
}

#[pyproto]
impl PyObjectProtocol for AzUserAttentionTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::UserAttentionType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::UserAttentionType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzUserAttentionTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzWindowDecorationsEnumWrapper {
    #[classattr]
    const Normal: AzWindowDecorations = AzWindowDecorations::Normal;
    #[classattr]
    const NoTitle: AzWindowDecorations = AzWindowDecorations::NoTitle;
    #[classattr]
    const NoControls: AzWindowDecorations = AzWindowDecorations::NoControls;
    #[classattr]
    const None: AzWindowDecorations = AzWindowDecorations::None;
}

#[pyproto]
impl PyObjectProtocol for AzWindowDecorationsEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowDecorations = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowDecorations = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzWindowDecorationsEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzWindowBackgroundMaterialEnumWrapper {
    #[classattr]
    const Opaque: AzWindowBackgroundMaterial = AzWindowBackgroundMaterial::Opaque;
    #[classattr]
    const Transparent: AzWindowBackgroundMaterial = AzWindowBackgroundMaterial::Transparent;
    #[classattr]
    const Sidebar: AzWindowBackgroundMaterial = AzWindowBackgroundMaterial::Sidebar;
    #[classattr]
    const Menu: AzWindowBackgroundMaterial = AzWindowBackgroundMaterial::Menu;
    #[classattr]
    const HUD: AzWindowBackgroundMaterial = AzWindowBackgroundMaterial::HUD;
    #[classattr]
    const Titlebar: AzWindowBackgroundMaterial = AzWindowBackgroundMaterial::Titlebar;
    #[classattr]
    const MicaAlt: AzWindowBackgroundMaterial = AzWindowBackgroundMaterial::MicaAlt;
}

#[pyproto]
impl PyObjectProtocol for AzWindowBackgroundMaterialEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowBackgroundMaterial = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowBackgroundMaterial = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzWindowBackgroundMaterialEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzMonitorId {
}

#[pyproto]
impl PyObjectProtocol for AzMonitorId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MonitorId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MonitorId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowTypeEnumWrapper {
    #[classattr]
    const Normal: AzWindowType = AzWindowType::Normal;
    #[classattr]
    const Menu: AzWindowType = AzWindowType::Menu;
    #[classattr]
    const Tooltip: AzWindowType = AzWindowType::Tooltip;
    #[classattr]
    const Dialog: AzWindowType = AzWindowType::Dialog;
}

#[pyproto]
impl PyObjectProtocol for AzWindowTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzWindowTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutCallbackEnumWrapper {
    #[staticmethod]
    fn Raw(v: LayoutCallbackInner) -> AzLayoutCallbackEnumWrapper {
        AzLayoutCallbackEnumWrapper { inner: AzLayoutCallback::Raw(v) }}
    }
    #[staticmethod]
    fn Marshaled(v: MarshaledLayoutCallback) -> AzLayoutCallbackEnumWrapper {
        AzLayoutCallbackEnumWrapper { inner: AzLayoutCallback::Marshaled(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutCallback;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutCallback::Raw(v) => Ok(vec!["Raw".into_py(py), v.into_py(py)]),
            AzLayoutCallback::Marshaled(v) => Ok(vec!["Marshaled".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutCallbackEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::LayoutCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::LayoutCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMarshaledLayoutCallback {
}

#[pyproto]
impl PyObjectProtocol for AzMarshaledLayoutCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMarshaledLayoutCallbackInner {
}

#[pyproto]
impl PyObjectProtocol for AzMarshaledLayoutCallbackInner {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::MarshaledLayoutCallbackInner = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::MarshaledLayoutCallbackInner = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutCallbackInner {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutCallbackInner {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::LayoutCallbackInner = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::LayoutCallbackInner = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallback {
}

#[pyproto]
impl PyObjectProtocol for AzCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::Callback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::Callback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallbackInfo {
    fn get_hit_node(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_system_time_fn(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_cursor_relative_to_viewport(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_cursor_relative_to_node(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_current_window_state(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_current_keyboard_state(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_current_mouse_state(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_previous_window_state(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_previous_keyboard_state(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_previous_mouse_state(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_current_window_handle(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_gl_context(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_scroll_position(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_dataset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_string_contents(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_inline_text(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_font_ref(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_text_layout_options(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn shape_text(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_index_in_parent(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_parent(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_previous_sibling(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_next_sibling(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_first_child(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_last_child(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_node_position(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_node_size(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_computed_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_window_state(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_focus(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_scroll_position(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_string_contents(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn add_image(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn has_image(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_image(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn update_image(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_image(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn update_image_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn stop_propagation(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn create_window(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn start_timer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn start_animation(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn stop_timer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn send_thread_msg(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn stop_thread(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::CallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::CallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUpdateImageTypeEnumWrapper {
    #[classattr]
    const Background: AzUpdateImageType = AzUpdateImageType::Background;
    #[classattr]
    const Content: AzUpdateImageType = AzUpdateImageType::Content;
}

#[pyproto]
impl PyObjectProtocol for AzUpdateImageTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::UpdateImageType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::UpdateImageType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzUpdateImageTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzUpdateEnumWrapper {
    #[classattr]
    const DoNothing: AzUpdate = AzUpdate::DoNothing;
    #[classattr]
    const RefreshDom: AzUpdate = AzUpdate::RefreshDom;
    #[classattr]
    const RefreshDomAllWindows: AzUpdate = AzUpdate::RefreshDomAllWindows;
}

#[pyproto]
impl PyObjectProtocol for AzUpdateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::Update = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::Update = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzUpdateEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutCallbackInfo {
    fn get_gl_context(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_system_fonts(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_image(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzLayoutCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::LayoutCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::LayoutCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomId {
}

#[pyproto]
impl PyObjectProtocol for AzDomId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::DomId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::DomId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomNodeId {
}

#[pyproto]
impl PyObjectProtocol for AzDomNodeId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::DomNodeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::DomNodeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPositionInfoEnumWrapper {
    #[staticmethod]
    fn Static(v: PositionInfoInner) -> AzPositionInfoEnumWrapper {
        AzPositionInfoEnumWrapper { inner: AzPositionInfo::Static(v) }}
    }
    #[staticmethod]
    fn Fixed(v: PositionInfoInner) -> AzPositionInfoEnumWrapper {
        AzPositionInfoEnumWrapper { inner: AzPositionInfo::Fixed(v) }}
    }
    #[staticmethod]
    fn Absolute(v: PositionInfoInner) -> AzPositionInfoEnumWrapper {
        AzPositionInfoEnumWrapper { inner: AzPositionInfo::Absolute(v) }}
    }
    #[staticmethod]
    fn Relative(v: PositionInfoInner) -> AzPositionInfoEnumWrapper {
        AzPositionInfoEnumWrapper { inner: AzPositionInfo::Relative(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzPositionInfo;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzPositionInfo::Static(v) => Ok(vec!["Static".into_py(py), v.into_py(py)]),
            AzPositionInfo::Fixed(v) => Ok(vec!["Fixed".into_py(py), v.into_py(py)]),
            AzPositionInfo::Absolute(v) => Ok(vec!["Absolute".into_py(py), v.into_py(py)]),
            AzPositionInfo::Relative(v) => Ok(vec!["Relative".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzPositionInfoEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::ui_solver::PositionInfo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::ui_solver::PositionInfo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPositionInfoInner {
}

#[pyproto]
impl PyObjectProtocol for AzPositionInfoInner {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::ui_solver::PositionInfoInner = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::ui_solver::PositionInfoInner = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzHidpiAdjustedBounds {
    fn get_logical_size(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_physical_size(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_hidpi_factor(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzHidpiAdjustedBounds {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::HidpiAdjustedBounds = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::HidpiAdjustedBounds = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineText {
    fn hit_test(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzInlineText {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineText = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineText = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineLine {
}

#[pyproto]
impl PyObjectProtocol for AzInlineLine {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineLine = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineLine = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineWordEnumWrapper {
    #[classattr]
    fn Tab() -> AzInlineWordEnumWrapper {
        AzInlineWordEnumWrapper { inner: AzInlineWord::Tab }
    }
    #[classattr]
    fn Return() -> AzInlineWordEnumWrapper {
        AzInlineWordEnumWrapper { inner: AzInlineWord::Return }
    }
    #[classattr]
    fn Space() -> AzInlineWordEnumWrapper {
        AzInlineWordEnumWrapper { inner: AzInlineWord::Space }
    }
    #[staticmethod]
    fn Word(v: InlineTextContents) -> AzInlineWordEnumWrapper {
        AzInlineWordEnumWrapper { inner: AzInlineWord::Word(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInlineWord;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInlineWord::Tab => Ok(vec!["Tab".into_py(py), ().into_py(py)]),
            AzInlineWord::Return => Ok(vec!["Return".into_py(py), ().into_py(py)]),
            AzInlineWord::Space => Ok(vec!["Space".into_py(py), ().into_py(py)]),
            AzInlineWord::Word(v) => Ok(vec!["Word".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineWordEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineWord = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineWord = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineTextContents {
}

#[pyproto]
impl PyObjectProtocol for AzInlineTextContents {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineTextContents = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineTextContents = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineGlyph {
}

#[pyproto]
impl PyObjectProtocol for AzInlineGlyph {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineGlyph = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineGlyph = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineTextHit {
}

#[pyproto]
impl PyObjectProtocol for AzInlineTextHit {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineTextHit = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineTextHit = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFocusTargetEnumWrapper {
    #[staticmethod]
    fn Id(v: DomNodeId) -> AzFocusTargetEnumWrapper {
        AzFocusTargetEnumWrapper { inner: AzFocusTarget::Id(v) }}
    }
    #[staticmethod]
    fn Path(v: FocusTargetPath) -> AzFocusTargetEnumWrapper {
        AzFocusTargetEnumWrapper { inner: AzFocusTarget::Path(v) }}
    }
    #[classattr]
    fn Previous() -> AzFocusTargetEnumWrapper {
        AzFocusTargetEnumWrapper { inner: AzFocusTarget::Previous }
    }
    #[classattr]
    fn Next() -> AzFocusTargetEnumWrapper {
        AzFocusTargetEnumWrapper { inner: AzFocusTarget::Next }
    }
    #[classattr]
    fn First() -> AzFocusTargetEnumWrapper {
        AzFocusTargetEnumWrapper { inner: AzFocusTarget::First }
    }
    #[classattr]
    fn Last() -> AzFocusTargetEnumWrapper {
        AzFocusTargetEnumWrapper { inner: AzFocusTarget::Last }
    }
    #[classattr]
    fn NoFocus() -> AzFocusTargetEnumWrapper {
        AzFocusTargetEnumWrapper { inner: AzFocusTarget::NoFocus }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzFocusTarget;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzFocusTarget::Id(v) => Ok(vec!["Id".into_py(py), v.into_py(py)]),
            AzFocusTarget::Path(v) => Ok(vec!["Path".into_py(py), v.into_py(py)]),
            AzFocusTarget::Previous => Ok(vec!["Previous".into_py(py), ().into_py(py)]),
            AzFocusTarget::Next => Ok(vec!["Next".into_py(py), ().into_py(py)]),
            AzFocusTarget::First => Ok(vec!["First".into_py(py), ().into_py(py)]),
            AzFocusTarget::Last => Ok(vec!["Last".into_py(py), ().into_py(py)]),
            AzFocusTarget::NoFocus => Ok(vec!["NoFocus".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFocusTargetEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::FocusTarget = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::FocusTarget = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFocusTargetPath {
}

#[pyproto]
impl PyObjectProtocol for AzFocusTargetPath {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::FocusTargetPath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::FocusTargetPath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScriptTypeEnumWrapper {
    #[classattr]
    const Mixed: AzScriptType = AzScriptType::Mixed;
    #[classattr]
    const LTR: AzScriptType = AzScriptType::LTR;
    #[classattr]
    const RTL: AzScriptType = AzScriptType::RTL;
}

#[pyproto]
impl PyObjectProtocol for AzScriptTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::ui_solver::ScriptType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::ui_solver::ScriptType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzScriptTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzResolvedTextLayoutOptions {
    #[staticmethod]
    fn default(/* args */) -> AzResolvedTextLayoutOptions {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzResolvedTextLayoutOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::ui_solver::ResolvedTextLayoutOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::ui_solver::ResolvedTextLayoutOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAnimation {
}

#[pyproto]
impl PyObjectProtocol for AzAnimation {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::Animation = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::Animation = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAnimationRepeatEnumWrapper {
    #[classattr]
    const NoRepeat: AzAnimationRepeat = AzAnimationRepeat::NoRepeat;
    #[classattr]
    const Loop: AzAnimationRepeat = AzAnimationRepeat::Loop;
    #[classattr]
    const PingPong: AzAnimationRepeat = AzAnimationRepeat::PingPong;
}

#[pyproto]
impl PyObjectProtocol for AzAnimationRepeatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::AnimationRepeat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::AnimationRepeat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAnimationRepeatEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAnimationRepeatCountEnumWrapper {
    #[staticmethod]
    fn Times(v: usize) -> AzAnimationRepeatCountEnumWrapper {
        AzAnimationRepeatCountEnumWrapper { inner: AzAnimationRepeatCount::Times(v) }}
    }
    #[classattr]
    fn Infinite() -> AzAnimationRepeatCountEnumWrapper {
        AzAnimationRepeatCountEnumWrapper { inner: AzAnimationRepeatCount::Infinite }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzAnimationRepeatCount;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAnimationRepeatCount::Times(v) => Ok(vec!["Times".into_py(py), v.into_py(py)]),
            AzAnimationRepeatCount::Infinite => Ok(vec!["Infinite".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAnimationRepeatCountEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::AnimationRepeatCount = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::AnimationRepeatCount = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeHierarchyItemId {
}

#[pyproto]
impl PyObjectProtocol for AzNodeHierarchyItemId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeHierarchyItemId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeHierarchyItemId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameCallback {
}

#[pyproto]
impl PyObjectProtocol for AzIFrameCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::IFrameCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::IFrameCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameCallbackInfo {
}

#[pyproto]
impl PyObjectProtocol for AzIFrameCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::IFrameCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::IFrameCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameCallbackReturn {
}

#[pyproto]
impl PyObjectProtocol for AzIFrameCallbackReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::IFrameCallbackReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::IFrameCallbackReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRenderImageCallback {
}

#[pyproto]
impl PyObjectProtocol for AzRenderImageCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::RenderImageCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::RenderImageCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRenderImageCallbackInfo {
    fn get_gl_context(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_bounds(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_callback_node_id(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_inline_text(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_index_in_parent(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_parent(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_previous_sibling(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_next_sibling(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_first_child(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_last_child(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzRenderImageCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::RenderImageCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::RenderImageCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTimerCallback {
}

#[pyproto]
impl PyObjectProtocol for AzTimerCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::TimerCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::TimerCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTimerCallbackInfo {
}

#[pyproto]
impl PyObjectProtocol for AzTimerCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::TimerCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::TimerCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTimerCallbackReturn {
}

#[pyproto]
impl PyObjectProtocol for AzTimerCallbackReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::TimerCallbackReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::TimerCallbackReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWriteBackCallback {
}

#[pyproto]
impl PyObjectProtocol for AzWriteBackCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::WriteBackCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::WriteBackCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadCallback {
}

#[pyproto]
impl PyObjectProtocol for AzThreadCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::ThreadCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::ThreadCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRefCount {
    fn can_be_shared(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn can_be_shared_mut(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn increase_ref(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn decrease_ref(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn increase_refmut(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn decrease_refmut(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzRefCount {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::RefCount = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::RefCount = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRefAny {
    fn get_type_id(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_type_name(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzRefAny {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::RefAny = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::RefAny = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzEdgeTypeEnumWrapper {
    #[classattr]
    const Top: AzEdgeType = AzEdgeType::Top;
    #[classattr]
    const Bottom: AzEdgeType = AzEdgeType::Bottom;
    #[classattr]
    const Left: AzEdgeType = AzEdgeType::Left;
    #[classattr]
    const Right: AzEdgeType = AzEdgeType::Right;
}

#[pyproto]
impl PyObjectProtocol for AzEdgeTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::EdgeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::EdgeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzEdgeTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzExternalSystemCallbacks {
}

#[pyproto]
impl PyObjectProtocol for AzExternalSystemCallbacks {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::ExternalSystemCallbacks = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::ExternalSystemCallbacks = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuCallback {
}

#[pyproto]
impl PyObjectProtocol for AzMenuCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::MenuCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::MenuCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameCallbackReasonEnumWrapper {
    #[classattr]
    fn InitialRender() -> AzIFrameCallbackReasonEnumWrapper {
        AzIFrameCallbackReasonEnumWrapper { inner: AzIFrameCallbackReason::InitialRender }
    }
    #[classattr]
    fn DomRecreated() -> AzIFrameCallbackReasonEnumWrapper {
        AzIFrameCallbackReasonEnumWrapper { inner: AzIFrameCallbackReason::DomRecreated }
    }
    #[classattr]
    fn BoundsExpanded() -> AzIFrameCallbackReasonEnumWrapper {
        AzIFrameCallbackReasonEnumWrapper { inner: AzIFrameCallbackReason::BoundsExpanded }
    }
    #[staticmethod]
    fn EdgeScrolled(v: EdgeType) -> AzIFrameCallbackReasonEnumWrapper {
        AzIFrameCallbackReasonEnumWrapper { inner: AzIFrameCallbackReason::EdgeScrolled(v) }}
    }
    #[classattr]
    fn ScrollBeyondContent() -> AzIFrameCallbackReasonEnumWrapper {
        AzIFrameCallbackReasonEnumWrapper { inner: AzIFrameCallbackReason::ScrollBeyondContent }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzIFrameCallbackReason;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzIFrameCallbackReason::InitialRender => Ok(vec!["InitialRender".into_py(py), ().into_py(py)]),
            AzIFrameCallbackReason::DomRecreated => Ok(vec!["DomRecreated".into_py(py), ().into_py(py)]),
            AzIFrameCallbackReason::BoundsExpanded => Ok(vec!["BoundsExpanded".into_py(py), ().into_py(py)]),
            AzIFrameCallbackReason::EdgeScrolled(v) => Ok(vec!["EdgeScrolled".into_py(py), v.into_py(py)]),
            AzIFrameCallbackReason::ScrollBeyondContent => Ok(vec!["ScrollBeyondContent".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIFrameCallbackReasonEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::IFrameCallbackReason = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::IFrameCallbackReason = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDom {
    #[new]
    fn new(/* args */) -> AzDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn body(/* args */) -> AzDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn div(/* args */) -> AzDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn br(/* args */) -> AzDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn text(/* args */) -> AzDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn image(/* args */) -> AzDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_node_type(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_node_type(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_ids_and_classes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_ids_and_classes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_callbacks(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_callbacks(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_css_props(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_css_props(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn add_child(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_child(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_children(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_children(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn add_id(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_id(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn add_class(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_class(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn add_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn add_hover_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_hover_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn add_active_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_active_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn add_focus_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_focus_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_hover_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_hover_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_active_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_active_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_focus_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_focus_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_clip_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_clip_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_tab_index(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_tab_index(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_accessibility_info(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_accessibility_info(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_menu_bar(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_menu_bar(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_context_menu(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_context_menu(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn hash(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn node_count(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_html_string(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_html_string_test(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzDom {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::Dom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::Dom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameNode {
}

#[pyproto]
impl PyObjectProtocol for AzIFrameNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::IFrameNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::IFrameNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallbackData {
}

#[pyproto]
impl PyObjectProtocol for AzCallbackData {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::CallbackData = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::CallbackData = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeData {
    #[new]
    fn new(/* args */) -> AzNodeData {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn body(/* args */) -> AzNodeData {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn div(/* args */) -> AzNodeData {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn br(/* args */) -> AzNodeData {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn text(/* args */) -> AzNodeData {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn image(/* args */) -> AzNodeData {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_node_type(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_node_type(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_ids_and_classes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_ids_and_classes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_callbacks(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_callbacks(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_css_props(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_css_props(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_hover_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_hover_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_active_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_active_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_focus_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_focus_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_clip_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_tab_index(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_accessibility_info(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_menu_bar(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_context_menu(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn hash(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeData {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeData = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeData = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeEnumWrapper {
    #[classattr]
    fn Html() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Html }
    }
    #[classattr]
    fn Head() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Head }
    }
    #[classattr]
    fn Body() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Body }
    }
    #[classattr]
    fn Div() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Div }
    }
    #[classattr]
    fn P() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::P }
    }
    #[classattr]
    fn Article() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Article }
    }
    #[classattr]
    fn Section() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Section }
    }
    #[classattr]
    fn Nav() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Nav }
    }
    #[classattr]
    fn Aside() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Aside }
    }
    #[classattr]
    fn Header() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Header }
    }
    #[classattr]
    fn Footer() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Footer }
    }
    #[classattr]
    fn Main() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Main }
    }
    #[classattr]
    fn Figure() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Figure }
    }
    #[classattr]
    fn FigCaption() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::FigCaption }
    }
    #[classattr]
    fn H1() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::H1 }
    }
    #[classattr]
    fn H2() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::H2 }
    }
    #[classattr]
    fn H3() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::H3 }
    }
    #[classattr]
    fn H4() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::H4 }
    }
    #[classattr]
    fn H5() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::H5 }
    }
    #[classattr]
    fn H6() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::H6 }
    }
    #[classattr]
    fn Br() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Br }
    }
    #[classattr]
    fn Hr() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Hr }
    }
    #[classattr]
    fn Pre() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Pre }
    }
    #[classattr]
    fn BlockQuote() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::BlockQuote }
    }
    #[classattr]
    fn Address() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Address }
    }
    #[classattr]
    fn Details() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Details }
    }
    #[classattr]
    fn Summary() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Summary }
    }
    #[classattr]
    fn Dialog() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Dialog }
    }
    #[classattr]
    fn Ul() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Ul }
    }
    #[classattr]
    fn Ol() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Ol }
    }
    #[classattr]
    fn Li() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Li }
    }
    #[classattr]
    fn Dl() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Dl }
    }
    #[classattr]
    fn Dt() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Dt }
    }
    #[classattr]
    fn Dd() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Dd }
    }
    #[classattr]
    fn Menu() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Menu }
    }
    #[classattr]
    fn MenuItem() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::MenuItem }
    }
    #[classattr]
    fn Table() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Table }
    }
    #[classattr]
    fn Caption() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Caption }
    }
    #[classattr]
    fn THead() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::THead }
    }
    #[classattr]
    fn TBody() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::TBody }
    }
    #[classattr]
    fn TFoot() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::TFoot }
    }
    #[classattr]
    fn Tr() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Tr }
    }
    #[classattr]
    fn Th() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Th }
    }
    #[classattr]
    fn Td() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Td }
    }
    #[classattr]
    fn ColGroup() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::ColGroup }
    }
    #[classattr]
    fn Col() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Col }
    }
    #[classattr]
    fn Form() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Form }
    }
    #[classattr]
    fn FieldSet() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::FieldSet }
    }
    #[classattr]
    fn Legend() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Legend }
    }
    #[classattr]
    fn Label() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Label }
    }
    #[classattr]
    fn Input() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Input }
    }
    #[classattr]
    fn Button() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Button }
    }
    #[classattr]
    fn Select() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Select }
    }
    #[classattr]
    fn OptGroup() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::OptGroup }
    }
    #[classattr]
    fn SelectOption() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::SelectOption }
    }
    #[classattr]
    fn TextArea() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::TextArea }
    }
    #[classattr]
    fn Output() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Output }
    }
    #[classattr]
    fn Progress() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Progress }
    }
    #[classattr]
    fn Meter() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Meter }
    }
    #[classattr]
    fn DataList() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::DataList }
    }
    #[classattr]
    fn Span() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Span }
    }
    #[classattr]
    fn A() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::A }
    }
    #[classattr]
    fn Em() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Em }
    }
    #[classattr]
    fn Strong() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Strong }
    }
    #[classattr]
    fn B() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::B }
    }
    #[classattr]
    fn I() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::I }
    }
    #[classattr]
    fn U() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::U }
    }
    #[classattr]
    fn S() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::S }
    }
    #[classattr]
    fn Mark() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Mark }
    }
    #[classattr]
    fn Del() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Del }
    }
    #[classattr]
    fn Ins() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Ins }
    }
    #[classattr]
    fn Code() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Code }
    }
    #[classattr]
    fn Samp() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Samp }
    }
    #[classattr]
    fn Kbd() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Kbd }
    }
    #[classattr]
    fn Var() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Var }
    }
    #[classattr]
    fn Cite() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Cite }
    }
    #[classattr]
    fn Dfn() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Dfn }
    }
    #[classattr]
    fn Abbr() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Abbr }
    }
    #[classattr]
    fn Acronym() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Acronym }
    }
    #[classattr]
    fn Q() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Q }
    }
    #[classattr]
    fn Time() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Time }
    }
    #[classattr]
    fn Sub() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Sub }
    }
    #[classattr]
    fn Sup() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Sup }
    }
    #[classattr]
    fn Small() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Small }
    }
    #[classattr]
    fn Big() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Big }
    }
    #[classattr]
    fn Bdo() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Bdo }
    }
    #[classattr]
    fn Canvas() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Canvas }
    }
    #[classattr]
    fn Object() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Object }
    }
    #[classattr]
    fn Param() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Param }
    }
    #[classattr]
    fn Embed() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Embed }
    }
    #[classattr]
    fn Audio() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Audio }
    }
    #[classattr]
    fn Video() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Video }
    }
    #[classattr]
    fn Source() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Source }
    }
    #[classattr]
    fn Track() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Track }
    }
    #[classattr]
    fn Map() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Map }
    }
    #[classattr]
    fn Area() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Area }
    }
    #[classattr]
    fn Title() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Title }
    }
    #[classattr]
    fn Meta() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Meta }
    }
    #[classattr]
    fn Link() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Link }
    }
    #[classattr]
    fn Script() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Script }
    }
    #[classattr]
    fn Style() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Style }
    }
    #[classattr]
    fn Base() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Base }
    }
    #[classattr]
    fn Before() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Before }
    }
    #[classattr]
    fn After() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::After }
    }
    #[classattr]
    fn Marker() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Marker }
    }
    #[classattr]
    fn Placeholder() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Placeholder }
    }
    #[staticmethod]
    fn Text(v: AzString) -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Text(v) }}
    }
    #[staticmethod]
    fn Image(v: ImageRef) -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Image(v) }}
    }
    #[staticmethod]
    fn IFrame(v: IFrameNode) -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::IFrame(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeType;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeType::Html => Ok(vec!["Html".into_py(py), ().into_py(py)]),
            AzNodeType::Head => Ok(vec!["Head".into_py(py), ().into_py(py)]),
            AzNodeType::Body => Ok(vec!["Body".into_py(py), ().into_py(py)]),
            AzNodeType::Div => Ok(vec!["Div".into_py(py), ().into_py(py)]),
            AzNodeType::P => Ok(vec!["P".into_py(py), ().into_py(py)]),
            AzNodeType::Article => Ok(vec!["Article".into_py(py), ().into_py(py)]),
            AzNodeType::Section => Ok(vec!["Section".into_py(py), ().into_py(py)]),
            AzNodeType::Nav => Ok(vec!["Nav".into_py(py), ().into_py(py)]),
            AzNodeType::Aside => Ok(vec!["Aside".into_py(py), ().into_py(py)]),
            AzNodeType::Header => Ok(vec!["Header".into_py(py), ().into_py(py)]),
            AzNodeType::Footer => Ok(vec!["Footer".into_py(py), ().into_py(py)]),
            AzNodeType::Main => Ok(vec!["Main".into_py(py), ().into_py(py)]),
            AzNodeType::Figure => Ok(vec!["Figure".into_py(py), ().into_py(py)]),
            AzNodeType::FigCaption => Ok(vec!["FigCaption".into_py(py), ().into_py(py)]),
            AzNodeType::H1 => Ok(vec!["H1".into_py(py), ().into_py(py)]),
            AzNodeType::H2 => Ok(vec!["H2".into_py(py), ().into_py(py)]),
            AzNodeType::H3 => Ok(vec!["H3".into_py(py), ().into_py(py)]),
            AzNodeType::H4 => Ok(vec!["H4".into_py(py), ().into_py(py)]),
            AzNodeType::H5 => Ok(vec!["H5".into_py(py), ().into_py(py)]),
            AzNodeType::H6 => Ok(vec!["H6".into_py(py), ().into_py(py)]),
            AzNodeType::Br => Ok(vec!["Br".into_py(py), ().into_py(py)]),
            AzNodeType::Hr => Ok(vec!["Hr".into_py(py), ().into_py(py)]),
            AzNodeType::Pre => Ok(vec!["Pre".into_py(py), ().into_py(py)]),
            AzNodeType::BlockQuote => Ok(vec!["BlockQuote".into_py(py), ().into_py(py)]),
            AzNodeType::Address => Ok(vec!["Address".into_py(py), ().into_py(py)]),
            AzNodeType::Details => Ok(vec!["Details".into_py(py), ().into_py(py)]),
            AzNodeType::Summary => Ok(vec!["Summary".into_py(py), ().into_py(py)]),
            AzNodeType::Dialog => Ok(vec!["Dialog".into_py(py), ().into_py(py)]),
            AzNodeType::Ul => Ok(vec!["Ul".into_py(py), ().into_py(py)]),
            AzNodeType::Ol => Ok(vec!["Ol".into_py(py), ().into_py(py)]),
            AzNodeType::Li => Ok(vec!["Li".into_py(py), ().into_py(py)]),
            AzNodeType::Dl => Ok(vec!["Dl".into_py(py), ().into_py(py)]),
            AzNodeType::Dt => Ok(vec!["Dt".into_py(py), ().into_py(py)]),
            AzNodeType::Dd => Ok(vec!["Dd".into_py(py), ().into_py(py)]),
            AzNodeType::Menu => Ok(vec!["Menu".into_py(py), ().into_py(py)]),
            AzNodeType::MenuItem => Ok(vec!["MenuItem".into_py(py), ().into_py(py)]),
            AzNodeType::Table => Ok(vec!["Table".into_py(py), ().into_py(py)]),
            AzNodeType::Caption => Ok(vec!["Caption".into_py(py), ().into_py(py)]),
            AzNodeType::THead => Ok(vec!["THead".into_py(py), ().into_py(py)]),
            AzNodeType::TBody => Ok(vec!["TBody".into_py(py), ().into_py(py)]),
            AzNodeType::TFoot => Ok(vec!["TFoot".into_py(py), ().into_py(py)]),
            AzNodeType::Tr => Ok(vec!["Tr".into_py(py), ().into_py(py)]),
            AzNodeType::Th => Ok(vec!["Th".into_py(py), ().into_py(py)]),
            AzNodeType::Td => Ok(vec!["Td".into_py(py), ().into_py(py)]),
            AzNodeType::ColGroup => Ok(vec!["ColGroup".into_py(py), ().into_py(py)]),
            AzNodeType::Col => Ok(vec!["Col".into_py(py), ().into_py(py)]),
            AzNodeType::Form => Ok(vec!["Form".into_py(py), ().into_py(py)]),
            AzNodeType::FieldSet => Ok(vec!["FieldSet".into_py(py), ().into_py(py)]),
            AzNodeType::Legend => Ok(vec!["Legend".into_py(py), ().into_py(py)]),
            AzNodeType::Label => Ok(vec!["Label".into_py(py), ().into_py(py)]),
            AzNodeType::Input => Ok(vec!["Input".into_py(py), ().into_py(py)]),
            AzNodeType::Button => Ok(vec!["Button".into_py(py), ().into_py(py)]),
            AzNodeType::Select => Ok(vec!["Select".into_py(py), ().into_py(py)]),
            AzNodeType::OptGroup => Ok(vec!["OptGroup".into_py(py), ().into_py(py)]),
            AzNodeType::SelectOption => Ok(vec!["SelectOption".into_py(py), ().into_py(py)]),
            AzNodeType::TextArea => Ok(vec!["TextArea".into_py(py), ().into_py(py)]),
            AzNodeType::Output => Ok(vec!["Output".into_py(py), ().into_py(py)]),
            AzNodeType::Progress => Ok(vec!["Progress".into_py(py), ().into_py(py)]),
            AzNodeType::Meter => Ok(vec!["Meter".into_py(py), ().into_py(py)]),
            AzNodeType::DataList => Ok(vec!["DataList".into_py(py), ().into_py(py)]),
            AzNodeType::Span => Ok(vec!["Span".into_py(py), ().into_py(py)]),
            AzNodeType::A => Ok(vec!["A".into_py(py), ().into_py(py)]),
            AzNodeType::Em => Ok(vec!["Em".into_py(py), ().into_py(py)]),
            AzNodeType::Strong => Ok(vec!["Strong".into_py(py), ().into_py(py)]),
            AzNodeType::B => Ok(vec!["B".into_py(py), ().into_py(py)]),
            AzNodeType::I => Ok(vec!["I".into_py(py), ().into_py(py)]),
            AzNodeType::U => Ok(vec!["U".into_py(py), ().into_py(py)]),
            AzNodeType::S => Ok(vec!["S".into_py(py), ().into_py(py)]),
            AzNodeType::Mark => Ok(vec!["Mark".into_py(py), ().into_py(py)]),
            AzNodeType::Del => Ok(vec!["Del".into_py(py), ().into_py(py)]),
            AzNodeType::Ins => Ok(vec!["Ins".into_py(py), ().into_py(py)]),
            AzNodeType::Code => Ok(vec!["Code".into_py(py), ().into_py(py)]),
            AzNodeType::Samp => Ok(vec!["Samp".into_py(py), ().into_py(py)]),
            AzNodeType::Kbd => Ok(vec!["Kbd".into_py(py), ().into_py(py)]),
            AzNodeType::Var => Ok(vec!["Var".into_py(py), ().into_py(py)]),
            AzNodeType::Cite => Ok(vec!["Cite".into_py(py), ().into_py(py)]),
            AzNodeType::Dfn => Ok(vec!["Dfn".into_py(py), ().into_py(py)]),
            AzNodeType::Abbr => Ok(vec!["Abbr".into_py(py), ().into_py(py)]),
            AzNodeType::Acronym => Ok(vec!["Acronym".into_py(py), ().into_py(py)]),
            AzNodeType::Q => Ok(vec!["Q".into_py(py), ().into_py(py)]),
            AzNodeType::Time => Ok(vec!["Time".into_py(py), ().into_py(py)]),
            AzNodeType::Sub => Ok(vec!["Sub".into_py(py), ().into_py(py)]),
            AzNodeType::Sup => Ok(vec!["Sup".into_py(py), ().into_py(py)]),
            AzNodeType::Small => Ok(vec!["Small".into_py(py), ().into_py(py)]),
            AzNodeType::Big => Ok(vec!["Big".into_py(py), ().into_py(py)]),
            AzNodeType::Bdo => Ok(vec!["Bdo".into_py(py), ().into_py(py)]),
            AzNodeType::Canvas => Ok(vec!["Canvas".into_py(py), ().into_py(py)]),
            AzNodeType::Object => Ok(vec!["Object".into_py(py), ().into_py(py)]),
            AzNodeType::Param => Ok(vec!["Param".into_py(py), ().into_py(py)]),
            AzNodeType::Embed => Ok(vec!["Embed".into_py(py), ().into_py(py)]),
            AzNodeType::Audio => Ok(vec!["Audio".into_py(py), ().into_py(py)]),
            AzNodeType::Video => Ok(vec!["Video".into_py(py), ().into_py(py)]),
            AzNodeType::Source => Ok(vec!["Source".into_py(py), ().into_py(py)]),
            AzNodeType::Track => Ok(vec!["Track".into_py(py), ().into_py(py)]),
            AzNodeType::Map => Ok(vec!["Map".into_py(py), ().into_py(py)]),
            AzNodeType::Area => Ok(vec!["Area".into_py(py), ().into_py(py)]),
            AzNodeType::Title => Ok(vec!["Title".into_py(py), ().into_py(py)]),
            AzNodeType::Meta => Ok(vec!["Meta".into_py(py), ().into_py(py)]),
            AzNodeType::Link => Ok(vec!["Link".into_py(py), ().into_py(py)]),
            AzNodeType::Script => Ok(vec!["Script".into_py(py), ().into_py(py)]),
            AzNodeType::Style => Ok(vec!["Style".into_py(py), ().into_py(py)]),
            AzNodeType::Base => Ok(vec!["Base".into_py(py), ().into_py(py)]),
            AzNodeType::Before => Ok(vec!["Before".into_py(py), ().into_py(py)]),
            AzNodeType::After => Ok(vec!["After".into_py(py), ().into_py(py)]),
            AzNodeType::Marker => Ok(vec!["Marker".into_py(py), ().into_py(py)]),
            AzNodeType::Placeholder => Ok(vec!["Placeholder".into_py(py), ().into_py(py)]),
            AzNodeType::Text(v) => Ok(vec!["Text".into_py(py), v.into_py(py)]),
            AzNodeType::Image(v) => Ok(vec!["Image".into_py(py), v.into_py(py)]),
            AzNodeType::IFrame(v) => Ok(vec!["IFrame".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnEnumWrapper {
    #[classattr]
    const MouseOver: AzOn = AzOn::MouseOver;
    #[classattr]
    const MouseDown: AzOn = AzOn::MouseDown;
    #[classattr]
    const LeftMouseDown: AzOn = AzOn::LeftMouseDown;
    #[classattr]
    const MiddleMouseDown: AzOn = AzOn::MiddleMouseDown;
    #[classattr]
    const RightMouseDown: AzOn = AzOn::RightMouseDown;
    #[classattr]
    const MouseUp: AzOn = AzOn::MouseUp;
    #[classattr]
    const LeftMouseUp: AzOn = AzOn::LeftMouseUp;
    #[classattr]
    const MiddleMouseUp: AzOn = AzOn::MiddleMouseUp;
    #[classattr]
    const RightMouseUp: AzOn = AzOn::RightMouseUp;
    #[classattr]
    const MouseEnter: AzOn = AzOn::MouseEnter;
    #[classattr]
    const MouseLeave: AzOn = AzOn::MouseLeave;
    #[classattr]
    const Scroll: AzOn = AzOn::Scroll;
    #[classattr]
    const TextInput: AzOn = AzOn::TextInput;
    #[classattr]
    const VirtualKeyDown: AzOn = AzOn::VirtualKeyDown;
    #[classattr]
    const VirtualKeyUp: AzOn = AzOn::VirtualKeyUp;
    #[classattr]
    const HoveredFile: AzOn = AzOn::HoveredFile;
    #[classattr]
    const DroppedFile: AzOn = AzOn::DroppedFile;
    #[classattr]
    const HoveredFileCancelled: AzOn = AzOn::HoveredFileCancelled;
    #[classattr]
    const FocusReceived: AzOn = AzOn::FocusReceived;
    #[classattr]
    const FocusLost: AzOn = AzOn::FocusLost;
    #[classattr]
    const Default: AzOn = AzOn::Default;
    #[classattr]
    const Collapse: AzOn = AzOn::Collapse;
    #[classattr]
    const Expand: AzOn = AzOn::Expand;
    #[classattr]
    const Increment: AzOn = AzOn::Increment;
    #[classattr]
    const Decrement: AzOn = AzOn::Decrement;
}

#[pyproto]
impl PyObjectProtocol for AzOnEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::On = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::On = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzOnEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzEventFilterEnumWrapper {
    #[staticmethod]
    fn Hover(v: HoverEventFilter) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper { inner: AzEventFilter::Hover(v) }}
    }
    #[staticmethod]
    fn Not(v: NotEventFilter) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper { inner: AzEventFilter::Not(v) }}
    }
    #[staticmethod]
    fn Focus(v: FocusEventFilter) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper { inner: AzEventFilter::Focus(v) }}
    }
    #[staticmethod]
    fn Window(v: WindowEventFilter) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper { inner: AzEventFilter::Window(v) }}
    }
    #[staticmethod]
    fn Component(v: ComponentEventFilter) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper { inner: AzEventFilter::Component(v) }}
    }
    #[staticmethod]
    fn Application(v: ApplicationEventFilter) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper { inner: AzEventFilter::Application(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzEventFilter;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzEventFilter::Hover(v) => Ok(vec!["Hover".into_py(py), v.into_py(py)]),
            AzEventFilter::Not(v) => Ok(vec!["Not".into_py(py), v.into_py(py)]),
            AzEventFilter::Focus(v) => Ok(vec!["Focus".into_py(py), v.into_py(py)]),
            AzEventFilter::Window(v) => Ok(vec!["Window".into_py(py), v.into_py(py)]),
            AzEventFilter::Component(v) => Ok(vec!["Component".into_py(py), v.into_py(py)]),
            AzEventFilter::Application(v) => Ok(vec!["Application".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::EventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::EventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzHoverEventFilterEnumWrapper {
    #[classattr]
    const MouseOver: AzHoverEventFilter = AzHoverEventFilter::MouseOver;
    #[classattr]
    const MouseDown: AzHoverEventFilter = AzHoverEventFilter::MouseDown;
    #[classattr]
    const LeftMouseDown: AzHoverEventFilter = AzHoverEventFilter::LeftMouseDown;
    #[classattr]
    const RightMouseDown: AzHoverEventFilter = AzHoverEventFilter::RightMouseDown;
    #[classattr]
    const MiddleMouseDown: AzHoverEventFilter = AzHoverEventFilter::MiddleMouseDown;
    #[classattr]
    const MouseUp: AzHoverEventFilter = AzHoverEventFilter::MouseUp;
    #[classattr]
    const LeftMouseUp: AzHoverEventFilter = AzHoverEventFilter::LeftMouseUp;
    #[classattr]
    const RightMouseUp: AzHoverEventFilter = AzHoverEventFilter::RightMouseUp;
    #[classattr]
    const MiddleMouseUp: AzHoverEventFilter = AzHoverEventFilter::MiddleMouseUp;
    #[classattr]
    const MouseEnter: AzHoverEventFilter = AzHoverEventFilter::MouseEnter;
    #[classattr]
    const MouseLeave: AzHoverEventFilter = AzHoverEventFilter::MouseLeave;
    #[classattr]
    const Scroll: AzHoverEventFilter = AzHoverEventFilter::Scroll;
    #[classattr]
    const ScrollStart: AzHoverEventFilter = AzHoverEventFilter::ScrollStart;
    #[classattr]
    const ScrollEnd: AzHoverEventFilter = AzHoverEventFilter::ScrollEnd;
    #[classattr]
    const TextInput: AzHoverEventFilter = AzHoverEventFilter::TextInput;
    #[classattr]
    const VirtualKeyDown: AzHoverEventFilter = AzHoverEventFilter::VirtualKeyDown;
    #[classattr]
    const VirtualKeyUp: AzHoverEventFilter = AzHoverEventFilter::VirtualKeyUp;
    #[classattr]
    const HoveredFile: AzHoverEventFilter = AzHoverEventFilter::HoveredFile;
    #[classattr]
    const DroppedFile: AzHoverEventFilter = AzHoverEventFilter::DroppedFile;
    #[classattr]
    const HoveredFileCancelled: AzHoverEventFilter = AzHoverEventFilter::HoveredFileCancelled;
    #[classattr]
    const TouchStart: AzHoverEventFilter = AzHoverEventFilter::TouchStart;
    #[classattr]
    const TouchMove: AzHoverEventFilter = AzHoverEventFilter::TouchMove;
    #[classattr]
    const TouchEnd: AzHoverEventFilter = AzHoverEventFilter::TouchEnd;
    #[classattr]
    const TouchCancel: AzHoverEventFilter = AzHoverEventFilter::TouchCancel;
    #[classattr]
    const DoubleClick: AzHoverEventFilter = AzHoverEventFilter::DoubleClick;
    #[classattr]
    const Drag: AzHoverEventFilter = AzHoverEventFilter::Drag;
    #[classattr]
    const DragEnd: AzHoverEventFilter = AzHoverEventFilter::DragEnd;
    #[classattr]
    const DragStart: AzHoverEventFilter = AzHoverEventFilter::DragStart;
    #[classattr]
    const LongPress: AzHoverEventFilter = AzHoverEventFilter::LongPress;
    #[classattr]
    const PenDown: AzHoverEventFilter = AzHoverEventFilter::PenDown;
    #[classattr]
    const PenEnter: AzHoverEventFilter = AzHoverEventFilter::PenEnter;
    #[classattr]
    const PenLeave: AzHoverEventFilter = AzHoverEventFilter::PenLeave;
    #[classattr]
    const PenMove: AzHoverEventFilter = AzHoverEventFilter::PenMove;
    #[classattr]
    const PenUp: AzHoverEventFilter = AzHoverEventFilter::PenUp;
    #[classattr]
    const PinchIn: AzHoverEventFilter = AzHoverEventFilter::PinchIn;
    #[classattr]
    const PinchOut: AzHoverEventFilter = AzHoverEventFilter::PinchOut;
    #[classattr]
    const RotateClockwise: AzHoverEventFilter = AzHoverEventFilter::RotateClockwise;
    #[classattr]
    const RotateCounterClockwise: AzHoverEventFilter = AzHoverEventFilter::RotateCounterClockwise;
    #[classattr]
    const SwipeDown: AzHoverEventFilter = AzHoverEventFilter::SwipeDown;
    #[classattr]
    const SwipeLeft: AzHoverEventFilter = AzHoverEventFilter::SwipeLeft;
    #[classattr]
    const SwipeRight: AzHoverEventFilter = AzHoverEventFilter::SwipeRight;
    #[classattr]
    const SwipeUp: AzHoverEventFilter = AzHoverEventFilter::SwipeUp;
    #[classattr]
    const SystemTextSingleClick: AzHoverEventFilter = AzHoverEventFilter::SystemTextSingleClick;
    #[classattr]
    const SystemTextDoubleClick: AzHoverEventFilter = AzHoverEventFilter::SystemTextDoubleClick;
    #[classattr]
    const SystemTextTripleClick: AzHoverEventFilter = AzHoverEventFilter::SystemTextTripleClick;
}

#[pyproto]
impl PyObjectProtocol for AzHoverEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::HoverEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::HoverEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzHoverEventFilterEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzFocusEventFilterEnumWrapper {
    #[classattr]
    const MouseOver: AzFocusEventFilter = AzFocusEventFilter::MouseOver;
    #[classattr]
    const MouseDown: AzFocusEventFilter = AzFocusEventFilter::MouseDown;
    #[classattr]
    const LeftMouseDown: AzFocusEventFilter = AzFocusEventFilter::LeftMouseDown;
    #[classattr]
    const RightMouseDown: AzFocusEventFilter = AzFocusEventFilter::RightMouseDown;
    #[classattr]
    const MiddleMouseDown: AzFocusEventFilter = AzFocusEventFilter::MiddleMouseDown;
    #[classattr]
    const MouseUp: AzFocusEventFilter = AzFocusEventFilter::MouseUp;
    #[classattr]
    const LeftMouseUp: AzFocusEventFilter = AzFocusEventFilter::LeftMouseUp;
    #[classattr]
    const RightMouseUp: AzFocusEventFilter = AzFocusEventFilter::RightMouseUp;
    #[classattr]
    const MiddleMouseUp: AzFocusEventFilter = AzFocusEventFilter::MiddleMouseUp;
    #[classattr]
    const MouseEnter: AzFocusEventFilter = AzFocusEventFilter::MouseEnter;
    #[classattr]
    const MouseLeave: AzFocusEventFilter = AzFocusEventFilter::MouseLeave;
    #[classattr]
    const Scroll: AzFocusEventFilter = AzFocusEventFilter::Scroll;
    #[classattr]
    const ScrollStart: AzFocusEventFilter = AzFocusEventFilter::ScrollStart;
    #[classattr]
    const ScrollEnd: AzFocusEventFilter = AzFocusEventFilter::ScrollEnd;
    #[classattr]
    const TextInput: AzFocusEventFilter = AzFocusEventFilter::TextInput;
    #[classattr]
    const VirtualKeyDown: AzFocusEventFilter = AzFocusEventFilter::VirtualKeyDown;
    #[classattr]
    const VirtualKeyUp: AzFocusEventFilter = AzFocusEventFilter::VirtualKeyUp;
    #[classattr]
    const FocusReceived: AzFocusEventFilter = AzFocusEventFilter::FocusReceived;
    #[classattr]
    const FocusLost: AzFocusEventFilter = AzFocusEventFilter::FocusLost;
    #[classattr]
    const DoubleClick: AzFocusEventFilter = AzFocusEventFilter::DoubleClick;
    #[classattr]
    const Drag: AzFocusEventFilter = AzFocusEventFilter::Drag;
    #[classattr]
    const DragEnd: AzFocusEventFilter = AzFocusEventFilter::DragEnd;
    #[classattr]
    const DragStart: AzFocusEventFilter = AzFocusEventFilter::DragStart;
    #[classattr]
    const LongPress: AzFocusEventFilter = AzFocusEventFilter::LongPress;
    #[classattr]
    const PenDown: AzFocusEventFilter = AzFocusEventFilter::PenDown;
    #[classattr]
    const PenMove: AzFocusEventFilter = AzFocusEventFilter::PenMove;
    #[classattr]
    const PenUp: AzFocusEventFilter = AzFocusEventFilter::PenUp;
    #[classattr]
    const PinchIn: AzFocusEventFilter = AzFocusEventFilter::PinchIn;
    #[classattr]
    const PinchOut: AzFocusEventFilter = AzFocusEventFilter::PinchOut;
    #[classattr]
    const RotateClockwise: AzFocusEventFilter = AzFocusEventFilter::RotateClockwise;
    #[classattr]
    const RotateCounterClockwise: AzFocusEventFilter = AzFocusEventFilter::RotateCounterClockwise;
    #[classattr]
    const SwipeDown: AzFocusEventFilter = AzFocusEventFilter::SwipeDown;
    #[classattr]
    const SwipeLeft: AzFocusEventFilter = AzFocusEventFilter::SwipeLeft;
    #[classattr]
    const SwipeRight: AzFocusEventFilter = AzFocusEventFilter::SwipeRight;
    #[classattr]
    const SwipeUp: AzFocusEventFilter = AzFocusEventFilter::SwipeUp;
}

#[pyproto]
impl PyObjectProtocol for AzFocusEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::FocusEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::FocusEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzFocusEventFilterEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzNotEventFilterEnumWrapper {
    #[staticmethod]
    fn Hover(v: HoverEventFilter) -> AzNotEventFilterEnumWrapper {
        AzNotEventFilterEnumWrapper { inner: AzNotEventFilter::Hover(v) }}
    }
    #[staticmethod]
    fn Focus(v: FocusEventFilter) -> AzNotEventFilterEnumWrapper {
        AzNotEventFilterEnumWrapper { inner: AzNotEventFilter::Focus(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNotEventFilter;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNotEventFilter::Hover(v) => Ok(vec!["Hover".into_py(py), v.into_py(py)]),
            AzNotEventFilter::Focus(v) => Ok(vec!["Focus".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNotEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NotEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NotEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowEventFilterEnumWrapper {
    #[classattr]
    const MouseOver: AzWindowEventFilter = AzWindowEventFilter::MouseOver;
    #[classattr]
    const MouseDown: AzWindowEventFilter = AzWindowEventFilter::MouseDown;
    #[classattr]
    const LeftMouseDown: AzWindowEventFilter = AzWindowEventFilter::LeftMouseDown;
    #[classattr]
    const RightMouseDown: AzWindowEventFilter = AzWindowEventFilter::RightMouseDown;
    #[classattr]
    const MiddleMouseDown: AzWindowEventFilter = AzWindowEventFilter::MiddleMouseDown;
    #[classattr]
    const MouseUp: AzWindowEventFilter = AzWindowEventFilter::MouseUp;
    #[classattr]
    const LeftMouseUp: AzWindowEventFilter = AzWindowEventFilter::LeftMouseUp;
    #[classattr]
    const RightMouseUp: AzWindowEventFilter = AzWindowEventFilter::RightMouseUp;
    #[classattr]
    const MiddleMouseUp: AzWindowEventFilter = AzWindowEventFilter::MiddleMouseUp;
    #[classattr]
    const MouseEnter: AzWindowEventFilter = AzWindowEventFilter::MouseEnter;
    #[classattr]
    const MouseLeave: AzWindowEventFilter = AzWindowEventFilter::MouseLeave;
    #[classattr]
    const Scroll: AzWindowEventFilter = AzWindowEventFilter::Scroll;
    #[classattr]
    const ScrollStart: AzWindowEventFilter = AzWindowEventFilter::ScrollStart;
    #[classattr]
    const ScrollEnd: AzWindowEventFilter = AzWindowEventFilter::ScrollEnd;
    #[classattr]
    const TextInput: AzWindowEventFilter = AzWindowEventFilter::TextInput;
    #[classattr]
    const VirtualKeyDown: AzWindowEventFilter = AzWindowEventFilter::VirtualKeyDown;
    #[classattr]
    const VirtualKeyUp: AzWindowEventFilter = AzWindowEventFilter::VirtualKeyUp;
    #[classattr]
    const HoveredFile: AzWindowEventFilter = AzWindowEventFilter::HoveredFile;
    #[classattr]
    const DroppedFile: AzWindowEventFilter = AzWindowEventFilter::DroppedFile;
    #[classattr]
    const HoveredFileCancelled: AzWindowEventFilter = AzWindowEventFilter::HoveredFileCancelled;
    #[classattr]
    const Resized: AzWindowEventFilter = AzWindowEventFilter::Resized;
    #[classattr]
    const Moved: AzWindowEventFilter = AzWindowEventFilter::Moved;
    #[classattr]
    const TouchStart: AzWindowEventFilter = AzWindowEventFilter::TouchStart;
    #[classattr]
    const TouchMove: AzWindowEventFilter = AzWindowEventFilter::TouchMove;
    #[classattr]
    const TouchEnd: AzWindowEventFilter = AzWindowEventFilter::TouchEnd;
    #[classattr]
    const TouchCancel: AzWindowEventFilter = AzWindowEventFilter::TouchCancel;
    #[classattr]
    const FocusReceived: AzWindowEventFilter = AzWindowEventFilter::FocusReceived;
    #[classattr]
    const FocusLost: AzWindowEventFilter = AzWindowEventFilter::FocusLost;
    #[classattr]
    const CloseRequested: AzWindowEventFilter = AzWindowEventFilter::CloseRequested;
    #[classattr]
    const ThemeChanged: AzWindowEventFilter = AzWindowEventFilter::ThemeChanged;
    #[classattr]
    const WindowFocusReceived: AzWindowEventFilter = AzWindowEventFilter::WindowFocusReceived;
    #[classattr]
    const WindowFocusLost: AzWindowEventFilter = AzWindowEventFilter::WindowFocusLost;
    #[classattr]
    const DoubleClick: AzWindowEventFilter = AzWindowEventFilter::DoubleClick;
    #[classattr]
    const Drag: AzWindowEventFilter = AzWindowEventFilter::Drag;
    #[classattr]
    const DragEnd: AzWindowEventFilter = AzWindowEventFilter::DragEnd;
    #[classattr]
    const DragStart: AzWindowEventFilter = AzWindowEventFilter::DragStart;
    #[classattr]
    const LongPress: AzWindowEventFilter = AzWindowEventFilter::LongPress;
    #[classattr]
    const PenDown: AzWindowEventFilter = AzWindowEventFilter::PenDown;
    #[classattr]
    const PenEnter: AzWindowEventFilter = AzWindowEventFilter::PenEnter;
    #[classattr]
    const PenLeave: AzWindowEventFilter = AzWindowEventFilter::PenLeave;
    #[classattr]
    const PenMove: AzWindowEventFilter = AzWindowEventFilter::PenMove;
    #[classattr]
    const PenUp: AzWindowEventFilter = AzWindowEventFilter::PenUp;
    #[classattr]
    const PinchIn: AzWindowEventFilter = AzWindowEventFilter::PinchIn;
    #[classattr]
    const PinchOut: AzWindowEventFilter = AzWindowEventFilter::PinchOut;
    #[classattr]
    const RotateClockwise: AzWindowEventFilter = AzWindowEventFilter::RotateClockwise;
    #[classattr]
    const RotateCounterClockwise: AzWindowEventFilter = AzWindowEventFilter::RotateCounterClockwise;
    #[classattr]
    const SwipeDown: AzWindowEventFilter = AzWindowEventFilter::SwipeDown;
    #[classattr]
    const SwipeLeft: AzWindowEventFilter = AzWindowEventFilter::SwipeLeft;
    #[classattr]
    const SwipeRight: AzWindowEventFilter = AzWindowEventFilter::SwipeRight;
    #[classattr]
    const SwipeUp: AzWindowEventFilter = AzWindowEventFilter::SwipeUp;
}

#[pyproto]
impl PyObjectProtocol for AzWindowEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::WindowEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::WindowEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzWindowEventFilterEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzComponentEventFilterEnumWrapper {
    #[classattr]
    const AfterMount: AzComponentEventFilter = AzComponentEventFilter::AfterMount;
    #[classattr]
    const BeforeUnmount: AzComponentEventFilter = AzComponentEventFilter::BeforeUnmount;
    #[classattr]
    const NodeResized: AzComponentEventFilter = AzComponentEventFilter::NodeResized;
    #[classattr]
    const DefaultAction: AzComponentEventFilter = AzComponentEventFilter::DefaultAction;
    #[classattr]
    const Selected: AzComponentEventFilter = AzComponentEventFilter::Selected;
}

#[pyproto]
impl PyObjectProtocol for AzComponentEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::ComponentEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::ComponentEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzComponentEventFilterEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzApplicationEventFilterEnumWrapper {
    #[classattr]
    const DeviceConnected: AzApplicationEventFilter = AzApplicationEventFilter::DeviceConnected;
    #[classattr]
    const DeviceDisconnected: AzApplicationEventFilter = AzApplicationEventFilter::DeviceDisconnected;
}

#[pyproto]
impl PyObjectProtocol for AzApplicationEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::ApplicationEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::ApplicationEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzApplicationEventFilterEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAccessibilityInfo {
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAccessibilityRoleEnumWrapper {
    #[classattr]
    const TitleBar: AzAccessibilityRole = AzAccessibilityRole::TitleBar;
    #[classattr]
    const MenuBar: AzAccessibilityRole = AzAccessibilityRole::MenuBar;
    #[classattr]
    const ScrollBar: AzAccessibilityRole = AzAccessibilityRole::ScrollBar;
    #[classattr]
    const Grip: AzAccessibilityRole = AzAccessibilityRole::Grip;
    #[classattr]
    const Sound: AzAccessibilityRole = AzAccessibilityRole::Sound;
    #[classattr]
    const Cursor: AzAccessibilityRole = AzAccessibilityRole::Cursor;
    #[classattr]
    const Caret: AzAccessibilityRole = AzAccessibilityRole::Caret;
    #[classattr]
    const Alert: AzAccessibilityRole = AzAccessibilityRole::Alert;
    #[classattr]
    const Window: AzAccessibilityRole = AzAccessibilityRole::Window;
    #[classattr]
    const Client: AzAccessibilityRole = AzAccessibilityRole::Client;
    #[classattr]
    const MenuPopup: AzAccessibilityRole = AzAccessibilityRole::MenuPopup;
    #[classattr]
    const MenuItem: AzAccessibilityRole = AzAccessibilityRole::MenuItem;
    #[classattr]
    const Tooltip: AzAccessibilityRole = AzAccessibilityRole::Tooltip;
    #[classattr]
    const Application: AzAccessibilityRole = AzAccessibilityRole::Application;
    #[classattr]
    const Document: AzAccessibilityRole = AzAccessibilityRole::Document;
    #[classattr]
    const Pane: AzAccessibilityRole = AzAccessibilityRole::Pane;
    #[classattr]
    const Chart: AzAccessibilityRole = AzAccessibilityRole::Chart;
    #[classattr]
    const Dialog: AzAccessibilityRole = AzAccessibilityRole::Dialog;
    #[classattr]
    const Border: AzAccessibilityRole = AzAccessibilityRole::Border;
    #[classattr]
    const Grouping: AzAccessibilityRole = AzAccessibilityRole::Grouping;
    #[classattr]
    const Separator: AzAccessibilityRole = AzAccessibilityRole::Separator;
    #[classattr]
    const Toolbar: AzAccessibilityRole = AzAccessibilityRole::Toolbar;
    #[classattr]
    const StatusBar: AzAccessibilityRole = AzAccessibilityRole::StatusBar;
    #[classattr]
    const Table: AzAccessibilityRole = AzAccessibilityRole::Table;
    #[classattr]
    const ColumnHeader: AzAccessibilityRole = AzAccessibilityRole::ColumnHeader;
    #[classattr]
    const RowHeader: AzAccessibilityRole = AzAccessibilityRole::RowHeader;
    #[classattr]
    const Column: AzAccessibilityRole = AzAccessibilityRole::Column;
    #[classattr]
    const Row: AzAccessibilityRole = AzAccessibilityRole::Row;
    #[classattr]
    const Cell: AzAccessibilityRole = AzAccessibilityRole::Cell;
    #[classattr]
    const Link: AzAccessibilityRole = AzAccessibilityRole::Link;
    #[classattr]
    const HelpBalloon: AzAccessibilityRole = AzAccessibilityRole::HelpBalloon;
    #[classattr]
    const Character: AzAccessibilityRole = AzAccessibilityRole::Character;
    #[classattr]
    const List: AzAccessibilityRole = AzAccessibilityRole::List;
    #[classattr]
    const ListItem: AzAccessibilityRole = AzAccessibilityRole::ListItem;
    #[classattr]
    const Outline: AzAccessibilityRole = AzAccessibilityRole::Outline;
    #[classattr]
    const OutlineItem: AzAccessibilityRole = AzAccessibilityRole::OutlineItem;
    #[classattr]
    const PageTab: AzAccessibilityRole = AzAccessibilityRole::PageTab;
    #[classattr]
    const PropertyPage: AzAccessibilityRole = AzAccessibilityRole::PropertyPage;
    #[classattr]
    const Indicator: AzAccessibilityRole = AzAccessibilityRole::Indicator;
    #[classattr]
    const Graphic: AzAccessibilityRole = AzAccessibilityRole::Graphic;
    #[classattr]
    const StaticText: AzAccessibilityRole = AzAccessibilityRole::StaticText;
    #[classattr]
    const Text: AzAccessibilityRole = AzAccessibilityRole::Text;
    #[classattr]
    const PushButton: AzAccessibilityRole = AzAccessibilityRole::PushButton;
    #[classattr]
    const CheckButton: AzAccessibilityRole = AzAccessibilityRole::CheckButton;
    #[classattr]
    const RadioButton: AzAccessibilityRole = AzAccessibilityRole::RadioButton;
    #[classattr]
    const ComboBox: AzAccessibilityRole = AzAccessibilityRole::ComboBox;
    #[classattr]
    const DropList: AzAccessibilityRole = AzAccessibilityRole::DropList;
    #[classattr]
    const ProgressBar: AzAccessibilityRole = AzAccessibilityRole::ProgressBar;
    #[classattr]
    const Dial: AzAccessibilityRole = AzAccessibilityRole::Dial;
    #[classattr]
    const HotkeyField: AzAccessibilityRole = AzAccessibilityRole::HotkeyField;
    #[classattr]
    const Slider: AzAccessibilityRole = AzAccessibilityRole::Slider;
    #[classattr]
    const SpinButton: AzAccessibilityRole = AzAccessibilityRole::SpinButton;
    #[classattr]
    const Diagram: AzAccessibilityRole = AzAccessibilityRole::Diagram;
    #[classattr]
    const Animation: AzAccessibilityRole = AzAccessibilityRole::Animation;
    #[classattr]
    const Equation: AzAccessibilityRole = AzAccessibilityRole::Equation;
    #[classattr]
    const ButtonDropdown: AzAccessibilityRole = AzAccessibilityRole::ButtonDropdown;
    #[classattr]
    const ButtonMenu: AzAccessibilityRole = AzAccessibilityRole::ButtonMenu;
    #[classattr]
    const ButtonDropdownGrid: AzAccessibilityRole = AzAccessibilityRole::ButtonDropdownGrid;
    #[classattr]
    const Whitespace: AzAccessibilityRole = AzAccessibilityRole::Whitespace;
    #[classattr]
    const PageTabList: AzAccessibilityRole = AzAccessibilityRole::PageTabList;
    #[classattr]
    const Clock: AzAccessibilityRole = AzAccessibilityRole::Clock;
    #[classattr]
    const SplitButton: AzAccessibilityRole = AzAccessibilityRole::SplitButton;
    #[classattr]
    const IpAddress: AzAccessibilityRole = AzAccessibilityRole::IpAddress;
    #[classattr]
    const Nothing: AzAccessibilityRole = AzAccessibilityRole::Nothing;
    #[classattr]
    const Unknown: AzAccessibilityRole = AzAccessibilityRole::Unknown;
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityRoleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityRole = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityRole = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAccessibilityRoleEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAccessibilityStateEnumWrapper {
    #[classattr]
    const Unavailable: AzAccessibilityState = AzAccessibilityState::Unavailable;
    #[classattr]
    const Selected: AzAccessibilityState = AzAccessibilityState::Selected;
    #[classattr]
    const Focused: AzAccessibilityState = AzAccessibilityState::Focused;
    #[classattr]
    const Checked: AzAccessibilityState = AzAccessibilityState::Checked;
    #[classattr]
    const Readonly: AzAccessibilityState = AzAccessibilityState::Readonly;
    #[classattr]
    const Default: AzAccessibilityState = AzAccessibilityState::Default;
    #[classattr]
    const Expanded: AzAccessibilityState = AzAccessibilityState::Expanded;
    #[classattr]
    const Collapsed: AzAccessibilityState = AzAccessibilityState::Collapsed;
    #[classattr]
    const Busy: AzAccessibilityState = AzAccessibilityState::Busy;
    #[classattr]
    const Offscreen: AzAccessibilityState = AzAccessibilityState::Offscreen;
    #[classattr]
    const Focusable: AzAccessibilityState = AzAccessibilityState::Focusable;
    #[classattr]
    const Selectable: AzAccessibilityState = AzAccessibilityState::Selectable;
    #[classattr]
    const Linked: AzAccessibilityState = AzAccessibilityState::Linked;
    #[classattr]
    const Traversed: AzAccessibilityState = AzAccessibilityState::Traversed;
    #[classattr]
    const Multiselectable: AzAccessibilityState = AzAccessibilityState::Multiselectable;
    #[classattr]
    const Protected: AzAccessibilityState = AzAccessibilityState::Protected;
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAccessibilityStateEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzTabIndexEnumWrapper {
    #[classattr]
    fn Auto() -> AzTabIndexEnumWrapper {
        AzTabIndexEnumWrapper { inner: AzTabIndex::Auto }
    }
    #[staticmethod]
    fn OverrideInParent(v: u32) -> AzTabIndexEnumWrapper {
        AzTabIndexEnumWrapper { inner: AzTabIndex::OverrideInParent(v) }}
    }
    #[classattr]
    fn NoKeyboardFocus() -> AzTabIndexEnumWrapper {
        AzTabIndexEnumWrapper { inner: AzTabIndex::NoKeyboardFocus }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzTabIndex;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTabIndex::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzTabIndex::OverrideInParent(v) => Ok(vec!["OverrideInParent".into_py(py), v.into_py(py)]),
            AzTabIndex::NoKeyboardFocus => Ok(vec!["NoKeyboardFocus".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTabIndexEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::TabIndex = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::TabIndex = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIdOrClassEnumWrapper {
    #[staticmethod]
    fn Id(v: AzString) -> AzIdOrClassEnumWrapper {
        AzIdOrClassEnumWrapper { inner: AzIdOrClass::Id(v) }}
    }
    #[staticmethod]
    fn Class(v: AzString) -> AzIdOrClassEnumWrapper {
        AzIdOrClassEnumWrapper { inner: AzIdOrClass::Class(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzIdOrClass;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzIdOrClass::Id(v) => Ok(vec!["Id".into_py(py), v.into_py(py)]),
            AzIdOrClass::Class(v) => Ok(vec!["Class".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIdOrClassEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::IdOrClass = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::IdOrClass = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataInlineCssPropertyEnumWrapper {
    #[staticmethod]
    fn Normal(v: CssProperty) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Normal(v) }}
    }
    #[staticmethod]
    fn Active(v: CssProperty) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Active(v) }}
    }
    #[staticmethod]
    fn Focus(v: CssProperty) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Focus(v) }}
    }
    #[staticmethod]
    fn Hover(v: CssProperty) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Hover(v) }}
    }
    #[staticmethod]
    fn Disabled(v: CssProperty) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Disabled(v) }}
    }
    #[staticmethod]
    fn Checked(v: CssProperty) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Checked(v) }}
    }
    #[staticmethod]
    fn FocusWithin(v: CssProperty) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::FocusWithin(v) }}
    }
    #[staticmethod]
    fn Visited(v: CssProperty) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Visited(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeDataInlineCssProperty;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeDataInlineCssProperty::Normal(v) => Ok(vec!["Normal".into_py(py), v.into_py(py)]),
            AzNodeDataInlineCssProperty::Active(v) => Ok(vec!["Active".into_py(py), v.into_py(py)]),
            AzNodeDataInlineCssProperty::Focus(v) => Ok(vec!["Focus".into_py(py), v.into_py(py)]),
            AzNodeDataInlineCssProperty::Hover(v) => Ok(vec!["Hover".into_py(py), v.into_py(py)]),
            AzNodeDataInlineCssProperty::Disabled(v) => Ok(vec!["Disabled".into_py(py), v.into_py(py)]),
            AzNodeDataInlineCssProperty::Checked(v) => Ok(vec!["Checked".into_py(py), v.into_py(py)]),
            AzNodeDataInlineCssProperty::FocusWithin(v) => Ok(vec!["FocusWithin".into_py(py), v.into_py(py)]),
            AzNodeDataInlineCssProperty::Visited(v) => Ok(vec!["Visited".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataInlineCssPropertyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataInlineCssProperty = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataInlineCssProperty = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomId {
}

#[pyproto]
impl PyObjectProtocol for AzDomId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::DomId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::DomId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomNodeId {
}

#[pyproto]
impl PyObjectProtocol for AzDomNodeId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::DomNodeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::DomNodeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenu {
    #[new]
    fn new(/* args */) -> AzMenu {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_popup_position(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_popup_position(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzMenu {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::Menu = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::Menu = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzContextMenuMouseButtonEnumWrapper {
    #[classattr]
    const Right: AzContextMenuMouseButton = AzContextMenuMouseButton::Right;
    #[classattr]
    const Middle: AzContextMenuMouseButton = AzContextMenuMouseButton::Middle;
    #[classattr]
    const Left: AzContextMenuMouseButton = AzContextMenuMouseButton::Left;
}

#[pyproto]
impl PyObjectProtocol for AzContextMenuMouseButtonEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ContextMenuMouseButton = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ContextMenuMouseButton = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzContextMenuMouseButtonEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzMenuPopupPositionEnumWrapper {
    #[classattr]
    const BottomLeftOfCursor: AzMenuPopupPosition = AzMenuPopupPosition::BottomLeftOfCursor;
    #[classattr]
    const BottomRightOfCursor: AzMenuPopupPosition = AzMenuPopupPosition::BottomRightOfCursor;
    #[classattr]
    const TopLeftOfCursor: AzMenuPopupPosition = AzMenuPopupPosition::TopLeftOfCursor;
    #[classattr]
    const TopRightOfCursor: AzMenuPopupPosition = AzMenuPopupPosition::TopRightOfCursor;
    #[classattr]
    const BottomOfHitRect: AzMenuPopupPosition = AzMenuPopupPosition::BottomOfHitRect;
    #[classattr]
    const LeftOfHitRect: AzMenuPopupPosition = AzMenuPopupPosition::LeftOfHitRect;
    #[classattr]
    const TopOfHitRect: AzMenuPopupPosition = AzMenuPopupPosition::TopOfHitRect;
    #[classattr]
    const RightOfHitRect: AzMenuPopupPosition = AzMenuPopupPosition::RightOfHitRect;
    #[classattr]
    const AutoCursor: AzMenuPopupPosition = AzMenuPopupPosition::AutoCursor;
    #[classattr]
    const AutoHitRect: AzMenuPopupPosition = AzMenuPopupPosition::AutoHitRect;
}

#[pyproto]
impl PyObjectProtocol for AzMenuPopupPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuPopupPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuPopupPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzMenuPopupPositionEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzMenuItemEnumWrapper {
    #[staticmethod]
    fn String(v: StringMenuItem) -> AzMenuItemEnumWrapper {
        AzMenuItemEnumWrapper { inner: AzMenuItem::String(v) }}
    }
    #[classattr]
    fn Separator() -> AzMenuItemEnumWrapper {
        AzMenuItemEnumWrapper { inner: AzMenuItem::Separator }
    }
    #[classattr]
    fn BreakLine() -> AzMenuItemEnumWrapper {
        AzMenuItemEnumWrapper { inner: AzMenuItem::BreakLine }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzMenuItem;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzMenuItem::String(v) => Ok(vec!["String".into_py(py), v.into_py(py)]),
            AzMenuItem::Separator => Ok(vec!["Separator".into_py(py), ().into_py(py)]),
            AzMenuItem::BreakLine => Ok(vec!["BreakLine".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItem = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItem = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringMenuItem {
    #[new]
    fn new(/* args */) -> AzStringMenuItem {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn add_child(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_child(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_children(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_children(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzStringMenuItem {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::StringMenuItem = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::StringMenuItem = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVirtualKeyCodeCombo {
}

#[pyproto]
impl PyObjectProtocol for AzVirtualKeyCodeCombo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeCombo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeCombo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuCallback {
}

#[pyproto]
impl PyObjectProtocol for AzMenuCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MenuCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MenuCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuItemIconEnumWrapper {
    #[staticmethod]
    fn Checkbox(v: bool) -> AzMenuItemIconEnumWrapper {
        AzMenuItemIconEnumWrapper { inner: AzMenuItemIcon::Checkbox(v) }}
    }
    #[staticmethod]
    fn Image(v: ImageRef) -> AzMenuItemIconEnumWrapper {
        AzMenuItemIconEnumWrapper { inner: AzMenuItemIcon::Image(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzMenuItemIcon;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzMenuItemIcon::Checkbox(v) => Ok(vec!["Checkbox".into_py(py), v.into_py(py)]),
            AzMenuItemIcon::Image(v) => Ok(vec!["Image".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItemIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItemIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuItemStateEnumWrapper {
    #[classattr]
    const Normal: AzMenuItemState = AzMenuItemState::Normal;
    #[classattr]
    const Greyed: AzMenuItemState = AzMenuItemState::Greyed;
    #[classattr]
    const Disabled: AzMenuItemState = AzMenuItemState::Disabled;
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItemState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItemState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzMenuItemStateEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzCssRuleBlock {
}

#[pyproto]
impl PyObjectProtocol for AzCssRuleBlock {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssRuleBlock = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssRuleBlock = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPath {
}

#[pyproto]
impl PyObjectProtocol for AzCssPath {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPathSelectorEnumWrapper {
    #[classattr]
    fn Global() -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::Global }
    }
    #[staticmethod]
    fn Type(v: NodeTypeTag) -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::Type(v) }}
    }
    #[staticmethod]
    fn Class(v: AzString) -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::Class(v) }}
    }
    #[staticmethod]
    fn Id(v: AzString) -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::Id(v) }}
    }
    #[staticmethod]
    fn PseudoSelector(v: CssPathPseudoSelector) -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::PseudoSelector(v) }}
    }
    #[classattr]
    fn DirectChildren() -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::DirectChildren }
    }
    #[classattr]
    fn Children() -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::Children }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssPathSelector;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPathSelector::Global => Ok(vec!["Global".into_py(py), ().into_py(py)]),
            AzCssPathSelector::Type(v) => Ok(vec!["Type".into_py(py), v.into_py(py)]),
            AzCssPathSelector::Class(v) => Ok(vec!["Class".into_py(py), v.into_py(py)]),
            AzCssPathSelector::Id(v) => Ok(vec!["Id".into_py(py), v.into_py(py)]),
            AzCssPathSelector::PseudoSelector(v) => Ok(vec!["PseudoSelector".into_py(py), v.into_py(py)]),
            AzCssPathSelector::DirectChildren => Ok(vec!["DirectChildren".into_py(py), ().into_py(py)]),
            AzCssPathSelector::Children => Ok(vec!["Children".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPathSelectorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPathSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPathSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyEnumWrapper {
    #[staticmethod]
    fn CaretColor(v: CaretColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::CaretColor(v) }}
    }
    #[staticmethod]
    fn CaretAnimationDuration(v: CaretAnimationDurationValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::CaretAnimationDuration(v) }}
    }
    #[staticmethod]
    fn SelectionBackgroundColor(v: SelectionBackgroundColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::SelectionBackgroundColor(v) }}
    }
    #[staticmethod]
    fn SelectionColor(v: SelectionColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::SelectionColor(v) }}
    }
    #[staticmethod]
    fn TextColor(v: StyleTextColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TextColor(v) }}
    }
    #[staticmethod]
    fn FontSize(v: StyleFontSizeValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FontSize(v) }}
    }
    #[staticmethod]
    fn FontFamily(v: StyleFontFamilyVecValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FontFamily(v) }}
    }
    #[staticmethod]
    fn TextAlign(v: StyleTextAlignValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TextAlign(v) }}
    }
    #[staticmethod]
    fn TextJustify(v: LayoutTextJustifyValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TextJustify(v) }}
    }
    #[staticmethod]
    fn LetterSpacing(v: StyleLetterSpacingValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::LetterSpacing(v) }}
    }
    #[staticmethod]
    fn LineHeight(v: StyleLineHeightValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::LineHeight(v) }}
    }
    #[staticmethod]
    fn WordSpacing(v: StyleWordSpacingValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::WordSpacing(v) }}
    }
    #[staticmethod]
    fn TabWidth(v: StyleTabWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TabWidth(v) }}
    }
    #[staticmethod]
    fn WhiteSpace(v: StyleWhiteSpaceValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::WhiteSpace(v) }}
    }
    #[staticmethod]
    fn Hyphens(v: StyleHyphensValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Hyphens(v) }}
    }
    #[staticmethod]
    fn Direction(v: StyleDirectionValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Direction(v) }}
    }
    #[staticmethod]
    fn UserSelect(v: StyleUserSelectValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::UserSelect(v) }}
    }
    #[staticmethod]
    fn TextDecoration(v: StyleTextDecorationValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TextDecoration(v) }}
    }
    #[staticmethod]
    fn Cursor(v: StyleCursorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Cursor(v) }}
    }
    #[staticmethod]
    fn Display(v: LayoutDisplayValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Display(v) }}
    }
    #[staticmethod]
    fn Float(v: LayoutFloatValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Float(v) }}
    }
    #[staticmethod]
    fn BoxSizing(v: LayoutBoxSizingValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxSizing(v) }}
    }
    #[staticmethod]
    fn Width(v: LayoutWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Width(v) }}
    }
    #[staticmethod]
    fn Height(v: LayoutHeightValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Height(v) }}
    }
    #[staticmethod]
    fn MinWidth(v: LayoutMinWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MinWidth(v) }}
    }
    #[staticmethod]
    fn MinHeight(v: LayoutMinHeightValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MinHeight(v) }}
    }
    #[staticmethod]
    fn MaxWidth(v: LayoutMaxWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MaxWidth(v) }}
    }
    #[staticmethod]
    fn MaxHeight(v: LayoutMaxHeightValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MaxHeight(v) }}
    }
    #[staticmethod]
    fn Position(v: LayoutPositionValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Position(v) }}
    }
    #[staticmethod]
    fn Top(v: LayoutTopValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Top(v) }}
    }
    #[staticmethod]
    fn Right(v: LayoutRightValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Right(v) }}
    }
    #[staticmethod]
    fn Left(v: LayoutLeftValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Left(v) }}
    }
    #[staticmethod]
    fn Bottom(v: LayoutBottomValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Bottom(v) }}
    }
    #[staticmethod]
    fn ZIndex(v: LayoutZIndexValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ZIndex(v) }}
    }
    #[staticmethod]
    fn FlexWrap(v: LayoutFlexWrapValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FlexWrap(v) }}
    }
    #[staticmethod]
    fn FlexDirection(v: LayoutFlexDirectionValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FlexDirection(v) }}
    }
    #[staticmethod]
    fn FlexGrow(v: LayoutFlexGrowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FlexGrow(v) }}
    }
    #[staticmethod]
    fn FlexShrink(v: LayoutFlexShrinkValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FlexShrink(v) }}
    }
    #[staticmethod]
    fn FlexBasis(v: LayoutFlexBasisValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FlexBasis(v) }}
    }
    #[staticmethod]
    fn JustifyContent(v: LayoutJustifyContentValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::JustifyContent(v) }}
    }
    #[staticmethod]
    fn AlignItems(v: LayoutAlignItemsValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::AlignItems(v) }}
    }
    #[staticmethod]
    fn AlignContent(v: LayoutAlignContentValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::AlignContent(v) }}
    }
    #[staticmethod]
    fn ColumnGap(v: LayoutColumnGapValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ColumnGap(v) }}
    }
    #[staticmethod]
    fn RowGap(v: LayoutRowGapValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::RowGap(v) }}
    }
    #[staticmethod]
    fn GridTemplateColumns(v: LayoutGridTemplateColumnsValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::GridTemplateColumns(v) }}
    }
    #[staticmethod]
    fn GridTemplateRows(v: LayoutGridTemplateRowsValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::GridTemplateRows(v) }}
    }
    #[staticmethod]
    fn GridAutoColumns(v: LayoutGridAutoColumnsValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::GridAutoColumns(v) }}
    }
    #[staticmethod]
    fn GridAutoRows(v: LayoutGridAutoRowsValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::GridAutoRows(v) }}
    }
    #[staticmethod]
    fn GridColumn(v: LayoutGridColumnValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::GridColumn(v) }}
    }
    #[staticmethod]
    fn GridRow(v: LayoutGridRowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::GridRow(v) }}
    }
    #[staticmethod]
    fn WritingMode(v: LayoutWritingModeValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::WritingMode(v) }}
    }
    #[staticmethod]
    fn Clear(v: LayoutClearValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Clear(v) }}
    }
    #[staticmethod]
    fn BackgroundContent(v: StyleBackgroundContentVecValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BackgroundContent(v) }}
    }
    #[staticmethod]
    fn BackgroundPosition(v: StyleBackgroundPositionVecValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BackgroundPosition(v) }}
    }
    #[staticmethod]
    fn BackgroundSize(v: StyleBackgroundSizeVecValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BackgroundSize(v) }}
    }
    #[staticmethod]
    fn BackgroundRepeat(v: StyleBackgroundRepeatVecValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BackgroundRepeat(v) }}
    }
    #[staticmethod]
    fn OverflowX(v: LayoutOverflowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::OverflowX(v) }}
    }
    #[staticmethod]
    fn OverflowY(v: LayoutOverflowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::OverflowY(v) }}
    }
    #[staticmethod]
    fn GridAutoFlow(v: LayoutGridAutoFlowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::GridAutoFlow(v) }}
    }
    #[staticmethod]
    fn JustifySelf(v: LayoutJustifySelfValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::JustifySelf(v) }}
    }
    #[staticmethod]
    fn JustifyItems(v: LayoutJustifyItemsValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::JustifyItems(v) }}
    }
    #[staticmethod]
    fn Gap(v: LayoutGapValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Gap(v) }}
    }
    #[staticmethod]
    fn GridGap(v: LayoutGapValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::GridGap(v) }}
    }
    #[staticmethod]
    fn AlignSelf(v: LayoutAlignSelfValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::AlignSelf(v) }}
    }
    #[staticmethod]
    fn Font(v: StyleFontValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Font(v) }}
    }
    #[staticmethod]
    fn PaddingTop(v: LayoutPaddingTopValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::PaddingTop(v) }}
    }
    #[staticmethod]
    fn PaddingLeft(v: LayoutPaddingLeftValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::PaddingLeft(v) }}
    }
    #[staticmethod]
    fn PaddingRight(v: LayoutPaddingRightValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::PaddingRight(v) }}
    }
    #[staticmethod]
    fn PaddingBottom(v: LayoutPaddingBottomValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::PaddingBottom(v) }}
    }
    #[staticmethod]
    fn MarginTop(v: LayoutMarginTopValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MarginTop(v) }}
    }
    #[staticmethod]
    fn MarginLeft(v: LayoutMarginLeftValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MarginLeft(v) }}
    }
    #[staticmethod]
    fn MarginRight(v: LayoutMarginRightValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MarginRight(v) }}
    }
    #[staticmethod]
    fn MarginBottom(v: LayoutMarginBottomValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MarginBottom(v) }}
    }
    #[staticmethod]
    fn BorderTopLeftRadius(v: StyleBorderTopLeftRadiusValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderTopLeftRadius(v) }}
    }
    #[staticmethod]
    fn LayoutTextJustify(v: LayoutTextJustifyValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::LayoutTextJustify(v) }}
    }
    #[staticmethod]
    fn BorderTopRightRadius(v: StyleBorderTopRightRadiusValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderTopRightRadius(v) }}
    }
    #[staticmethod]
    fn BorderBottomLeftRadius(v: StyleBorderBottomLeftRadiusValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderBottomLeftRadius(v) }}
    }
    #[staticmethod]
    fn BorderBottomRightRadius(v: StyleBorderBottomRightRadiusValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderBottomRightRadius(v) }}
    }
    #[staticmethod]
    fn BorderTopColor(v: StyleBorderTopColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderTopColor(v) }}
    }
    #[staticmethod]
    fn BorderRightColor(v: StyleBorderRightColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderRightColor(v) }}
    }
    #[staticmethod]
    fn BorderLeftColor(v: StyleBorderLeftColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderLeftColor(v) }}
    }
    #[staticmethod]
    fn BorderBottomColor(v: StyleBorderBottomColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderBottomColor(v) }}
    }
    #[staticmethod]
    fn BorderTopStyle(v: StyleBorderTopStyleValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderTopStyle(v) }}
    }
    #[staticmethod]
    fn BorderRightStyle(v: StyleBorderRightStyleValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderRightStyle(v) }}
    }
    #[staticmethod]
    fn BorderLeftStyle(v: StyleBorderLeftStyleValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderLeftStyle(v) }}
    }
    #[staticmethod]
    fn BorderBottomStyle(v: StyleBorderBottomStyleValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderBottomStyle(v) }}
    }
    #[staticmethod]
    fn BorderTopWidth(v: LayoutBorderTopWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderTopWidth(v) }}
    }
    #[staticmethod]
    fn BorderRightWidth(v: LayoutBorderRightWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderRightWidth(v) }}
    }
    #[staticmethod]
    fn BorderLeftWidth(v: LayoutBorderLeftWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderLeftWidth(v) }}
    }
    #[staticmethod]
    fn BorderBottomWidth(v: LayoutBorderBottomWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderBottomWidth(v) }}
    }
    #[staticmethod]
    fn BoxShadowLeft(v: StyleBoxShadowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxShadowLeft(v) }}
    }
    #[staticmethod]
    fn BoxShadowRight(v: StyleBoxShadowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxShadowRight(v) }}
    }
    #[staticmethod]
    fn BoxShadowTop(v: StyleBoxShadowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxShadowTop(v) }}
    }
    #[staticmethod]
    fn BoxShadowBottom(v: StyleBoxShadowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxShadowBottom(v) }}
    }
    #[staticmethod]
    fn Scrollbar(v: ScrollbarStyleValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Scrollbar(v) }}
    }
    #[staticmethod]
    fn ScrollbarWidth(v: LayoutScrollbarWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ScrollbarWidth(v) }}
    }
    #[staticmethod]
    fn ScrollbarColor(v: StyleScrollbarColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ScrollbarColor(v) }}
    }
    #[staticmethod]
    fn Opacity(v: StyleOpacityValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Opacity(v) }}
    }
    #[staticmethod]
    fn Visibility(v: StyleVisibilityValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Visibility(v) }}
    }
    #[staticmethod]
    fn Transform(v: StyleTransformVecValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Transform(v) }}
    }
    #[staticmethod]
    fn TransformOrigin(v: StyleTransformOriginValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TransformOrigin(v) }}
    }
    #[staticmethod]
    fn PerspectiveOrigin(v: StylePerspectiveOriginValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::PerspectiveOrigin(v) }}
    }
    #[staticmethod]
    fn BackfaceVisibility(v: StyleBackfaceVisibilityValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BackfaceVisibility(v) }}
    }
    #[staticmethod]
    fn MixBlendMode(v: StyleMixBlendModeValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MixBlendMode(v) }}
    }
    #[staticmethod]
    fn Filter(v: StyleFilterVecValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Filter(v) }}
    }
    #[staticmethod]
    fn BackdropFilter(v: StyleFilterVecValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BackdropFilter(v) }}
    }
    #[staticmethod]
    fn TextShadow(v: StyleBoxShadowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TextShadow(v) }}
    }
    #[staticmethod]
    fn BreakBefore(v: PageBreakValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BreakBefore(v) }}
    }
    #[staticmethod]
    fn BreakAfter(v: PageBreakValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BreakAfter(v) }}
    }
    #[staticmethod]
    fn BreakInside(v: BreakInsideValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BreakInside(v) }}
    }
    #[staticmethod]
    fn Orphans(v: OrphansValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Orphans(v) }}
    }
    #[staticmethod]
    fn Widows(v: WidowsValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Widows(v) }}
    }
    #[staticmethod]
    fn BoxDecorationBreak(v: BoxDecorationBreakValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxDecorationBreak(v) }}
    }
    #[staticmethod]
    fn ColumnCount(v: ColumnCountValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ColumnCount(v) }}
    }
    #[staticmethod]
    fn ColumnWidth(v: ColumnWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ColumnWidth(v) }}
    }
    #[staticmethod]
    fn ColumnSpan(v: ColumnSpanValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ColumnSpan(v) }}
    }
    #[staticmethod]
    fn ColumnFill(v: ColumnFillValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ColumnFill(v) }}
    }
    #[staticmethod]
    fn ColumnRuleWidth(v: ColumnRuleWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ColumnRuleWidth(v) }}
    }
    #[staticmethod]
    fn ColumnRuleStyle(v: ColumnRuleStyleValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ColumnRuleStyle(v) }}
    }
    #[staticmethod]
    fn ColumnRuleColor(v: ColumnRuleColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ColumnRuleColor(v) }}
    }
    #[staticmethod]
    fn FlowInto(v: FlowIntoValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FlowInto(v) }}
    }
    #[staticmethod]
    fn FlowFrom(v: FlowFromValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FlowFrom(v) }}
    }
    #[staticmethod]
    fn ShapeOutside(v: ShapeOutsideValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ShapeOutside(v) }}
    }
    #[staticmethod]
    fn ShapeMargin(v: ShapeMarginValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ShapeMargin(v) }}
    }
    #[staticmethod]
    fn ShapeImageThreshold(v: ShapeImageThresholdValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ShapeImageThreshold(v) }}
    }
    #[staticmethod]
    fn Content(v: ContentValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Content(v) }}
    }
    #[staticmethod]
    fn CounterReset(v: CounterResetValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::CounterReset(v) }}
    }
    #[staticmethod]
    fn CounterIncrement(v: CounterIncrementValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::CounterIncrement(v) }}
    }
    #[staticmethod]
    fn StringSet(v: StringSetValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::StringSet(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssProperty;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssProperty::CaretColor(v) => Ok(vec!["CaretColor".into_py(py), v.into_py(py)]),
            AzCssProperty::CaretAnimationDuration(v) => Ok(vec!["CaretAnimationDuration".into_py(py), v.into_py(py)]),
            AzCssProperty::SelectionBackgroundColor(v) => Ok(vec!["SelectionBackgroundColor".into_py(py), v.into_py(py)]),
            AzCssProperty::SelectionColor(v) => Ok(vec!["SelectionColor".into_py(py), v.into_py(py)]),
            AzCssProperty::TextColor(v) => Ok(vec!["TextColor".into_py(py), v.into_py(py)]),
            AzCssProperty::FontSize(v) => Ok(vec!["FontSize".into_py(py), v.into_py(py)]),
            AzCssProperty::FontFamily(v) => Ok(vec!["FontFamily".into_py(py), v.into_py(py)]),
            AzCssProperty::TextAlign(v) => Ok(vec!["TextAlign".into_py(py), v.into_py(py)]),
            AzCssProperty::TextJustify(v) => Ok(vec!["TextJustify".into_py(py), v.into_py(py)]),
            AzCssProperty::LetterSpacing(v) => Ok(vec!["LetterSpacing".into_py(py), v.into_py(py)]),
            AzCssProperty::LineHeight(v) => Ok(vec!["LineHeight".into_py(py), v.into_py(py)]),
            AzCssProperty::WordSpacing(v) => Ok(vec!["WordSpacing".into_py(py), v.into_py(py)]),
            AzCssProperty::TabWidth(v) => Ok(vec!["TabWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::WhiteSpace(v) => Ok(vec!["WhiteSpace".into_py(py), v.into_py(py)]),
            AzCssProperty::Hyphens(v) => Ok(vec!["Hyphens".into_py(py), v.into_py(py)]),
            AzCssProperty::Direction(v) => Ok(vec!["Direction".into_py(py), v.into_py(py)]),
            AzCssProperty::UserSelect(v) => Ok(vec!["UserSelect".into_py(py), v.into_py(py)]),
            AzCssProperty::TextDecoration(v) => Ok(vec!["TextDecoration".into_py(py), v.into_py(py)]),
            AzCssProperty::Cursor(v) => Ok(vec!["Cursor".into_py(py), v.into_py(py)]),
            AzCssProperty::Display(v) => Ok(vec!["Display".into_py(py), v.into_py(py)]),
            AzCssProperty::Float(v) => Ok(vec!["Float".into_py(py), v.into_py(py)]),
            AzCssProperty::BoxSizing(v) => Ok(vec!["BoxSizing".into_py(py), v.into_py(py)]),
            AzCssProperty::Width(v) => Ok(vec!["Width".into_py(py), v.into_py(py)]),
            AzCssProperty::Height(v) => Ok(vec!["Height".into_py(py), v.into_py(py)]),
            AzCssProperty::MinWidth(v) => Ok(vec!["MinWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::MinHeight(v) => Ok(vec!["MinHeight".into_py(py), v.into_py(py)]),
            AzCssProperty::MaxWidth(v) => Ok(vec!["MaxWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::MaxHeight(v) => Ok(vec!["MaxHeight".into_py(py), v.into_py(py)]),
            AzCssProperty::Position(v) => Ok(vec!["Position".into_py(py), v.into_py(py)]),
            AzCssProperty::Top(v) => Ok(vec!["Top".into_py(py), v.into_py(py)]),
            AzCssProperty::Right(v) => Ok(vec!["Right".into_py(py), v.into_py(py)]),
            AzCssProperty::Left(v) => Ok(vec!["Left".into_py(py), v.into_py(py)]),
            AzCssProperty::Bottom(v) => Ok(vec!["Bottom".into_py(py), v.into_py(py)]),
            AzCssProperty::ZIndex(v) => Ok(vec!["ZIndex".into_py(py), v.into_py(py)]),
            AzCssProperty::FlexWrap(v) => Ok(vec!["FlexWrap".into_py(py), v.into_py(py)]),
            AzCssProperty::FlexDirection(v) => Ok(vec!["FlexDirection".into_py(py), v.into_py(py)]),
            AzCssProperty::FlexGrow(v) => Ok(vec!["FlexGrow".into_py(py), v.into_py(py)]),
            AzCssProperty::FlexShrink(v) => Ok(vec!["FlexShrink".into_py(py), v.into_py(py)]),
            AzCssProperty::FlexBasis(v) => Ok(vec!["FlexBasis".into_py(py), v.into_py(py)]),
            AzCssProperty::JustifyContent(v) => Ok(vec!["JustifyContent".into_py(py), v.into_py(py)]),
            AzCssProperty::AlignItems(v) => Ok(vec!["AlignItems".into_py(py), v.into_py(py)]),
            AzCssProperty::AlignContent(v) => Ok(vec!["AlignContent".into_py(py), v.into_py(py)]),
            AzCssProperty::ColumnGap(v) => Ok(vec!["ColumnGap".into_py(py), v.into_py(py)]),
            AzCssProperty::RowGap(v) => Ok(vec!["RowGap".into_py(py), v.into_py(py)]),
            AzCssProperty::GridTemplateColumns(v) => Ok(vec!["GridTemplateColumns".into_py(py), v.into_py(py)]),
            AzCssProperty::GridTemplateRows(v) => Ok(vec!["GridTemplateRows".into_py(py), v.into_py(py)]),
            AzCssProperty::GridAutoColumns(v) => Ok(vec!["GridAutoColumns".into_py(py), v.into_py(py)]),
            AzCssProperty::GridAutoRows(v) => Ok(vec!["GridAutoRows".into_py(py), v.into_py(py)]),
            AzCssProperty::GridColumn(v) => Ok(vec!["GridColumn".into_py(py), v.into_py(py)]),
            AzCssProperty::GridRow(v) => Ok(vec!["GridRow".into_py(py), v.into_py(py)]),
            AzCssProperty::WritingMode(v) => Ok(vec!["WritingMode".into_py(py), v.into_py(py)]),
            AzCssProperty::Clear(v) => Ok(vec!["Clear".into_py(py), v.into_py(py)]),
            AzCssProperty::BackgroundContent(v) => Ok(vec!["BackgroundContent".into_py(py), v.into_py(py)]),
            AzCssProperty::BackgroundPosition(v) => Ok(vec!["BackgroundPosition".into_py(py), v.into_py(py)]),
            AzCssProperty::BackgroundSize(v) => Ok(vec!["BackgroundSize".into_py(py), v.into_py(py)]),
            AzCssProperty::BackgroundRepeat(v) => Ok(vec!["BackgroundRepeat".into_py(py), v.into_py(py)]),
            AzCssProperty::OverflowX(v) => Ok(vec!["OverflowX".into_py(py), v.into_py(py)]),
            AzCssProperty::OverflowY(v) => Ok(vec!["OverflowY".into_py(py), v.into_py(py)]),
            AzCssProperty::GridAutoFlow(v) => Ok(vec!["GridAutoFlow".into_py(py), v.into_py(py)]),
            AzCssProperty::JustifySelf(v) => Ok(vec!["JustifySelf".into_py(py), v.into_py(py)]),
            AzCssProperty::JustifyItems(v) => Ok(vec!["JustifyItems".into_py(py), v.into_py(py)]),
            AzCssProperty::Gap(v) => Ok(vec!["Gap".into_py(py), v.into_py(py)]),
            AzCssProperty::GridGap(v) => Ok(vec!["GridGap".into_py(py), v.into_py(py)]),
            AzCssProperty::AlignSelf(v) => Ok(vec!["AlignSelf".into_py(py), v.into_py(py)]),
            AzCssProperty::Font(v) => Ok(vec!["Font".into_py(py), v.into_py(py)]),
            AzCssProperty::PaddingTop(v) => Ok(vec!["PaddingTop".into_py(py), v.into_py(py)]),
            AzCssProperty::PaddingLeft(v) => Ok(vec!["PaddingLeft".into_py(py), v.into_py(py)]),
            AzCssProperty::PaddingRight(v) => Ok(vec!["PaddingRight".into_py(py), v.into_py(py)]),
            AzCssProperty::PaddingBottom(v) => Ok(vec!["PaddingBottom".into_py(py), v.into_py(py)]),
            AzCssProperty::MarginTop(v) => Ok(vec!["MarginTop".into_py(py), v.into_py(py)]),
            AzCssProperty::MarginLeft(v) => Ok(vec!["MarginLeft".into_py(py), v.into_py(py)]),
            AzCssProperty::MarginRight(v) => Ok(vec!["MarginRight".into_py(py), v.into_py(py)]),
            AzCssProperty::MarginBottom(v) => Ok(vec!["MarginBottom".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderTopLeftRadius(v) => Ok(vec!["BorderTopLeftRadius".into_py(py), v.into_py(py)]),
            AzCssProperty::LayoutTextJustify(v) => Ok(vec!["LayoutTextJustify".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderTopRightRadius(v) => Ok(vec!["BorderTopRightRadius".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderBottomLeftRadius(v) => Ok(vec!["BorderBottomLeftRadius".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderBottomRightRadius(v) => Ok(vec!["BorderBottomRightRadius".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderTopColor(v) => Ok(vec!["BorderTopColor".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderRightColor(v) => Ok(vec!["BorderRightColor".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderLeftColor(v) => Ok(vec!["BorderLeftColor".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderBottomColor(v) => Ok(vec!["BorderBottomColor".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderTopStyle(v) => Ok(vec!["BorderTopStyle".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderRightStyle(v) => Ok(vec!["BorderRightStyle".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderLeftStyle(v) => Ok(vec!["BorderLeftStyle".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderBottomStyle(v) => Ok(vec!["BorderBottomStyle".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderTopWidth(v) => Ok(vec!["BorderTopWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderRightWidth(v) => Ok(vec!["BorderRightWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderLeftWidth(v) => Ok(vec!["BorderLeftWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderBottomWidth(v) => Ok(vec!["BorderBottomWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::BoxShadowLeft(v) => Ok(vec!["BoxShadowLeft".into_py(py), v.into_py(py)]),
            AzCssProperty::BoxShadowRight(v) => Ok(vec!["BoxShadowRight".into_py(py), v.into_py(py)]),
            AzCssProperty::BoxShadowTop(v) => Ok(vec!["BoxShadowTop".into_py(py), v.into_py(py)]),
            AzCssProperty::BoxShadowBottom(v) => Ok(vec!["BoxShadowBottom".into_py(py), v.into_py(py)]),
            AzCssProperty::Scrollbar(v) => Ok(vec!["Scrollbar".into_py(py), v.into_py(py)]),
            AzCssProperty::ScrollbarWidth(v) => Ok(vec!["ScrollbarWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::ScrollbarColor(v) => Ok(vec!["ScrollbarColor".into_py(py), v.into_py(py)]),
            AzCssProperty::Opacity(v) => Ok(vec!["Opacity".into_py(py), v.into_py(py)]),
            AzCssProperty::Visibility(v) => Ok(vec!["Visibility".into_py(py), v.into_py(py)]),
            AzCssProperty::Transform(v) => Ok(vec!["Transform".into_py(py), v.into_py(py)]),
            AzCssProperty::TransformOrigin(v) => Ok(vec!["TransformOrigin".into_py(py), v.into_py(py)]),
            AzCssProperty::PerspectiveOrigin(v) => Ok(vec!["PerspectiveOrigin".into_py(py), v.into_py(py)]),
            AzCssProperty::BackfaceVisibility(v) => Ok(vec!["BackfaceVisibility".into_py(py), v.into_py(py)]),
            AzCssProperty::MixBlendMode(v) => Ok(vec!["MixBlendMode".into_py(py), v.into_py(py)]),
            AzCssProperty::Filter(v) => Ok(vec!["Filter".into_py(py), v.into_py(py)]),
            AzCssProperty::BackdropFilter(v) => Ok(vec!["BackdropFilter".into_py(py), v.into_py(py)]),
            AzCssProperty::TextShadow(v) => Ok(vec!["TextShadow".into_py(py), v.into_py(py)]),
            AzCssProperty::BreakBefore(v) => Ok(vec!["BreakBefore".into_py(py), v.into_py(py)]),
            AzCssProperty::BreakAfter(v) => Ok(vec!["BreakAfter".into_py(py), v.into_py(py)]),
            AzCssProperty::BreakInside(v) => Ok(vec!["BreakInside".into_py(py), v.into_py(py)]),
            AzCssProperty::Orphans(v) => Ok(vec!["Orphans".into_py(py), v.into_py(py)]),
            AzCssProperty::Widows(v) => Ok(vec!["Widows".into_py(py), v.into_py(py)]),
            AzCssProperty::BoxDecorationBreak(v) => Ok(vec!["BoxDecorationBreak".into_py(py), v.into_py(py)]),
            AzCssProperty::ColumnCount(v) => Ok(vec!["ColumnCount".into_py(py), v.into_py(py)]),
            AzCssProperty::ColumnWidth(v) => Ok(vec!["ColumnWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::ColumnSpan(v) => Ok(vec!["ColumnSpan".into_py(py), v.into_py(py)]),
            AzCssProperty::ColumnFill(v) => Ok(vec!["ColumnFill".into_py(py), v.into_py(py)]),
            AzCssProperty::ColumnRuleWidth(v) => Ok(vec!["ColumnRuleWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::ColumnRuleStyle(v) => Ok(vec!["ColumnRuleStyle".into_py(py), v.into_py(py)]),
            AzCssProperty::ColumnRuleColor(v) => Ok(vec!["ColumnRuleColor".into_py(py), v.into_py(py)]),
            AzCssProperty::FlowInto(v) => Ok(vec!["FlowInto".into_py(py), v.into_py(py)]),
            AzCssProperty::FlowFrom(v) => Ok(vec!["FlowFrom".into_py(py), v.into_py(py)]),
            AzCssProperty::ShapeOutside(v) => Ok(vec!["ShapeOutside".into_py(py), v.into_py(py)]),
            AzCssProperty::ShapeMargin(v) => Ok(vec!["ShapeMargin".into_py(py), v.into_py(py)]),
            AzCssProperty::ShapeImageThreshold(v) => Ok(vec!["ShapeImageThreshold".into_py(py), v.into_py(py)]),
            AzCssProperty::Content(v) => Ok(vec!["Content".into_py(py), v.into_py(py)]),
            AzCssProperty::CounterReset(v) => Ok(vec!["CounterReset".into_py(py), v.into_py(py)]),
            AzCssProperty::CounterIncrement(v) => Ok(vec!["CounterIncrement".into_py(py), v.into_py(py)]),
            AzCssProperty::StringSet(v) => Ok(vec!["StringSet".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::CssProperty = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::CssProperty = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPathPseudoSelectorEnumWrapper {
    #[classattr]
    fn First() -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::First }
    }
    #[classattr]
    fn Last() -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::Last }
    }
    #[staticmethod]
    fn NthChild(v: CssNthChildSelector) -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::NthChild(v) }}
    }
    #[classattr]
    fn Hover() -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::Hover }
    }
    #[classattr]
    fn Active() -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::Active }
    }
    #[classattr]
    fn Focus() -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::Focus }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssPathPseudoSelector;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPathPseudoSelector::First => Ok(vec!["First".into_py(py), ().into_py(py)]),
            AzCssPathPseudoSelector::Last => Ok(vec!["Last".into_py(py), ().into_py(py)]),
            AzCssPathPseudoSelector::NthChild(v) => Ok(vec!["NthChild".into_py(py), v.into_py(py)]),
            AzCssPathPseudoSelector::Hover => Ok(vec!["Hover".into_py(py), ().into_py(py)]),
            AzCssPathPseudoSelector::Active => Ok(vec!["Active".into_py(py), ().into_py(py)]),
            AzCssPathPseudoSelector::Focus => Ok(vec!["Focus".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPathPseudoSelectorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPathPseudoSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPathPseudoSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssNthChildSelectorEnumWrapper {
    #[staticmethod]
    fn Number(v: u32) -> AzCssNthChildSelectorEnumWrapper {
        AzCssNthChildSelectorEnumWrapper { inner: AzCssNthChildSelector::Number(v) }}
    }
    #[classattr]
    fn Even() -> AzCssNthChildSelectorEnumWrapper {
        AzCssNthChildSelectorEnumWrapper { inner: AzCssNthChildSelector::Even }
    }
    #[classattr]
    fn Odd() -> AzCssNthChildSelectorEnumWrapper {
        AzCssNthChildSelectorEnumWrapper { inner: AzCssNthChildSelector::Odd }
    }
    #[staticmethod]
    fn Pattern(v: CssNthChildPattern) -> AzCssNthChildSelectorEnumWrapper {
        AzCssNthChildSelectorEnumWrapper { inner: AzCssNthChildSelector::Pattern(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssNthChildSelector;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssNthChildSelector::Number(v) => Ok(vec!["Number".into_py(py), v.into_py(py)]),
            AzCssNthChildSelector::Even => Ok(vec!["Even".into_py(py), ().into_py(py)]),
            AzCssNthChildSelector::Odd => Ok(vec!["Odd".into_py(py), ().into_py(py)]),
            AzCssNthChildSelector::Pattern(v) => Ok(vec!["Pattern".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssNthChildSelectorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssNthChildSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssNthChildSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssNthChildPattern {
}

#[pyproto]
impl PyObjectProtocol for AzCssNthChildPattern {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssNthChildPattern = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssNthChildPattern = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylesheet {
}

#[pyproto]
impl PyObjectProtocol for AzStylesheet {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::Stylesheet = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::Stylesheet = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCss {
    #[staticmethod]
    fn empty(/* args */) -> AzCss {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn from_string(/* args */) -> AzCss {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzCss {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::Css = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::Css = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssDeclarationEnumWrapper {
    #[staticmethod]
    fn Static(v: CssProperty) -> AzCssDeclarationEnumWrapper {
        AzCssDeclarationEnumWrapper { inner: AzCssDeclaration::Static(v) }}
    }
    #[staticmethod]
    fn Dynamic(v: DynamicCssProperty) -> AzCssDeclarationEnumWrapper {
        AzCssDeclarationEnumWrapper { inner: AzCssDeclaration::Dynamic(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssDeclaration;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssDeclaration::Static(v) => Ok(vec!["Static".into_py(py), v.into_py(py)]),
            AzCssDeclaration::Dynamic(v) => Ok(vec!["Dynamic".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssDeclarationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssDeclaration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssDeclaration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDynamicCssProperty {
}

#[pyproto]
impl PyObjectProtocol for AzDynamicCssProperty {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::DynamicCssProperty = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::DynamicCssProperty = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyTypeEnumWrapper {
    #[classattr]
    const CaretColor: AzCssPropertyType = AzCssPropertyType::CaretColor;
    #[classattr]
    const CaretAnimationDuration: AzCssPropertyType = AzCssPropertyType::CaretAnimationDuration;
    #[classattr]
    const SelectionBackgroundColor: AzCssPropertyType = AzCssPropertyType::SelectionBackgroundColor;
    #[classattr]
    const SelectionColor: AzCssPropertyType = AzCssPropertyType::SelectionColor;
    #[classattr]
    const TextColor: AzCssPropertyType = AzCssPropertyType::TextColor;
    #[classattr]
    const FontSize: AzCssPropertyType = AzCssPropertyType::FontSize;
    #[classattr]
    const FontFamily: AzCssPropertyType = AzCssPropertyType::FontFamily;
    #[classattr]
    const TextAlign: AzCssPropertyType = AzCssPropertyType::TextAlign;
    #[classattr]
    const TextJustify: AzCssPropertyType = AzCssPropertyType::TextJustify;
    #[classattr]
    const LetterSpacing: AzCssPropertyType = AzCssPropertyType::LetterSpacing;
    #[classattr]
    const LineHeight: AzCssPropertyType = AzCssPropertyType::LineHeight;
    #[classattr]
    const WordSpacing: AzCssPropertyType = AzCssPropertyType::WordSpacing;
    #[classattr]
    const TabWidth: AzCssPropertyType = AzCssPropertyType::TabWidth;
    #[classattr]
    const WhiteSpace: AzCssPropertyType = AzCssPropertyType::WhiteSpace;
    #[classattr]
    const Hyphens: AzCssPropertyType = AzCssPropertyType::Hyphens;
    #[classattr]
    const Direction: AzCssPropertyType = AzCssPropertyType::Direction;
    #[classattr]
    const UserSelect: AzCssPropertyType = AzCssPropertyType::UserSelect;
    #[classattr]
    const TextDecoration: AzCssPropertyType = AzCssPropertyType::TextDecoration;
    #[classattr]
    const Cursor: AzCssPropertyType = AzCssPropertyType::Cursor;
    #[classattr]
    const Display: AzCssPropertyType = AzCssPropertyType::Display;
    #[classattr]
    const Float: AzCssPropertyType = AzCssPropertyType::Float;
    #[classattr]
    const BoxSizing: AzCssPropertyType = AzCssPropertyType::BoxSizing;
    #[classattr]
    const Width: AzCssPropertyType = AzCssPropertyType::Width;
    #[classattr]
    const Height: AzCssPropertyType = AzCssPropertyType::Height;
    #[classattr]
    const MinWidth: AzCssPropertyType = AzCssPropertyType::MinWidth;
    #[classattr]
    const MinHeight: AzCssPropertyType = AzCssPropertyType::MinHeight;
    #[classattr]
    const MaxWidth: AzCssPropertyType = AzCssPropertyType::MaxWidth;
    #[classattr]
    const MaxHeight: AzCssPropertyType = AzCssPropertyType::MaxHeight;
    #[classattr]
    const Position: AzCssPropertyType = AzCssPropertyType::Position;
    #[classattr]
    const Top: AzCssPropertyType = AzCssPropertyType::Top;
    #[classattr]
    const Right: AzCssPropertyType = AzCssPropertyType::Right;
    #[classattr]
    const Left: AzCssPropertyType = AzCssPropertyType::Left;
    #[classattr]
    const Bottom: AzCssPropertyType = AzCssPropertyType::Bottom;
    #[classattr]
    const ZIndex: AzCssPropertyType = AzCssPropertyType::ZIndex;
    #[classattr]
    const FlexWrap: AzCssPropertyType = AzCssPropertyType::FlexWrap;
    #[classattr]
    const FlexDirection: AzCssPropertyType = AzCssPropertyType::FlexDirection;
    #[classattr]
    const FlexGrow: AzCssPropertyType = AzCssPropertyType::FlexGrow;
    #[classattr]
    const FlexShrink: AzCssPropertyType = AzCssPropertyType::FlexShrink;
    #[classattr]
    const FlexBasis: AzCssPropertyType = AzCssPropertyType::FlexBasis;
    #[classattr]
    const JustifyContent: AzCssPropertyType = AzCssPropertyType::JustifyContent;
    #[classattr]
    const AlignItems: AzCssPropertyType = AzCssPropertyType::AlignItems;
    #[classattr]
    const AlignContent: AzCssPropertyType = AzCssPropertyType::AlignContent;
    #[classattr]
    const ColumnGap: AzCssPropertyType = AzCssPropertyType::ColumnGap;
    #[classattr]
    const RowGap: AzCssPropertyType = AzCssPropertyType::RowGap;
    #[classattr]
    const GridTemplateColumns: AzCssPropertyType = AzCssPropertyType::GridTemplateColumns;
    #[classattr]
    const GridTemplateRows: AzCssPropertyType = AzCssPropertyType::GridTemplateRows;
    #[classattr]
    const GridAutoColumns: AzCssPropertyType = AzCssPropertyType::GridAutoColumns;
    #[classattr]
    const GridAutoRows: AzCssPropertyType = AzCssPropertyType::GridAutoRows;
    #[classattr]
    const GridColumn: AzCssPropertyType = AzCssPropertyType::GridColumn;
    #[classattr]
    const GridRow: AzCssPropertyType = AzCssPropertyType::GridRow;
    #[classattr]
    const GridAutoFlow: AzCssPropertyType = AzCssPropertyType::GridAutoFlow;
    #[classattr]
    const JustifySelf: AzCssPropertyType = AzCssPropertyType::JustifySelf;
    #[classattr]
    const JustifyItems: AzCssPropertyType = AzCssPropertyType::JustifyItems;
    #[classattr]
    const Gap: AzCssPropertyType = AzCssPropertyType::Gap;
    #[classattr]
    const GridGap: AzCssPropertyType = AzCssPropertyType::GridGap;
    #[classattr]
    const AlignSelf: AzCssPropertyType = AzCssPropertyType::AlignSelf;
    #[classattr]
    const Font: AzCssPropertyType = AzCssPropertyType::Font;
    #[classattr]
    const WritingMode: AzCssPropertyType = AzCssPropertyType::WritingMode;
    #[classattr]
    const Clear: AzCssPropertyType = AzCssPropertyType::Clear;
    #[classattr]
    const BackgroundContent: AzCssPropertyType = AzCssPropertyType::BackgroundContent;
    #[classattr]
    const BackgroundPosition: AzCssPropertyType = AzCssPropertyType::BackgroundPosition;
    #[classattr]
    const BackgroundSize: AzCssPropertyType = AzCssPropertyType::BackgroundSize;
    #[classattr]
    const BackgroundRepeat: AzCssPropertyType = AzCssPropertyType::BackgroundRepeat;
    #[classattr]
    const OverflowX: AzCssPropertyType = AzCssPropertyType::OverflowX;
    #[classattr]
    const OverflowY: AzCssPropertyType = AzCssPropertyType::OverflowY;
    #[classattr]
    const PaddingTop: AzCssPropertyType = AzCssPropertyType::PaddingTop;
    #[classattr]
    const PaddingLeft: AzCssPropertyType = AzCssPropertyType::PaddingLeft;
    #[classattr]
    const PaddingRight: AzCssPropertyType = AzCssPropertyType::PaddingRight;
    #[classattr]
    const PaddingBottom: AzCssPropertyType = AzCssPropertyType::PaddingBottom;
    #[classattr]
    const MarginTop: AzCssPropertyType = AzCssPropertyType::MarginTop;
    #[classattr]
    const MarginLeft: AzCssPropertyType = AzCssPropertyType::MarginLeft;
    #[classattr]
    const MarginRight: AzCssPropertyType = AzCssPropertyType::MarginRight;
    #[classattr]
    const MarginBottom: AzCssPropertyType = AzCssPropertyType::MarginBottom;
    #[classattr]
    const BorderTopLeftRadius: AzCssPropertyType = AzCssPropertyType::BorderTopLeftRadius;
    #[classattr]
    const BorderTopRightRadius: AzCssPropertyType = AzCssPropertyType::BorderTopRightRadius;
    #[classattr]
    const BorderBottomLeftRadius: AzCssPropertyType = AzCssPropertyType::BorderBottomLeftRadius;
    #[classattr]
    const BorderBottomRightRadius: AzCssPropertyType = AzCssPropertyType::BorderBottomRightRadius;
    #[classattr]
    const BorderTopColor: AzCssPropertyType = AzCssPropertyType::BorderTopColor;
    #[classattr]
    const BorderRightColor: AzCssPropertyType = AzCssPropertyType::BorderRightColor;
    #[classattr]
    const BorderLeftColor: AzCssPropertyType = AzCssPropertyType::BorderLeftColor;
    #[classattr]
    const BorderBottomColor: AzCssPropertyType = AzCssPropertyType::BorderBottomColor;
    #[classattr]
    const BorderTopStyle: AzCssPropertyType = AzCssPropertyType::BorderTopStyle;
    #[classattr]
    const BorderRightStyle: AzCssPropertyType = AzCssPropertyType::BorderRightStyle;
    #[classattr]
    const BorderLeftStyle: AzCssPropertyType = AzCssPropertyType::BorderLeftStyle;
    #[classattr]
    const BorderBottomStyle: AzCssPropertyType = AzCssPropertyType::BorderBottomStyle;
    #[classattr]
    const BorderTopWidth: AzCssPropertyType = AzCssPropertyType::BorderTopWidth;
    #[classattr]
    const BorderRightWidth: AzCssPropertyType = AzCssPropertyType::BorderRightWidth;
    #[classattr]
    const BorderLeftWidth: AzCssPropertyType = AzCssPropertyType::BorderLeftWidth;
    #[classattr]
    const BorderBottomWidth: AzCssPropertyType = AzCssPropertyType::BorderBottomWidth;
    #[classattr]
    const BoxShadowLeft: AzCssPropertyType = AzCssPropertyType::BoxShadowLeft;
    #[classattr]
    const BoxShadowRight: AzCssPropertyType = AzCssPropertyType::BoxShadowRight;
    #[classattr]
    const BoxShadowTop: AzCssPropertyType = AzCssPropertyType::BoxShadowTop;
    #[classattr]
    const BoxShadowBottom: AzCssPropertyType = AzCssPropertyType::BoxShadowBottom;
    #[classattr]
    const Scrollbar: AzCssPropertyType = AzCssPropertyType::Scrollbar;
    #[classattr]
    const ScrollbarWidth: AzCssPropertyType = AzCssPropertyType::ScrollbarWidth;
    #[classattr]
    const ScrollbarColor: AzCssPropertyType = AzCssPropertyType::ScrollbarColor;
    #[classattr]
    const Opacity: AzCssPropertyType = AzCssPropertyType::Opacity;
    #[classattr]
    const Visibility: AzCssPropertyType = AzCssPropertyType::Visibility;
    #[classattr]
    const Transform: AzCssPropertyType = AzCssPropertyType::Transform;
    #[classattr]
    const TransformOrigin: AzCssPropertyType = AzCssPropertyType::TransformOrigin;
    #[classattr]
    const PerspectiveOrigin: AzCssPropertyType = AzCssPropertyType::PerspectiveOrigin;
    #[classattr]
    const BackfaceVisibility: AzCssPropertyType = AzCssPropertyType::BackfaceVisibility;
    #[classattr]
    const MixBlendMode: AzCssPropertyType = AzCssPropertyType::MixBlendMode;
    #[classattr]
    const Filter: AzCssPropertyType = AzCssPropertyType::Filter;
    #[classattr]
    const BackdropFilter: AzCssPropertyType = AzCssPropertyType::BackdropFilter;
    #[classattr]
    const TextShadow: AzCssPropertyType = AzCssPropertyType::TextShadow;
    #[classattr]
    const BreakBefore: AzCssPropertyType = AzCssPropertyType::BreakBefore;
    #[classattr]
    const BreakAfter: AzCssPropertyType = AzCssPropertyType::BreakAfter;
    #[classattr]
    const BreakInside: AzCssPropertyType = AzCssPropertyType::BreakInside;
    #[classattr]
    const Orphans: AzCssPropertyType = AzCssPropertyType::Orphans;
    #[classattr]
    const Widows: AzCssPropertyType = AzCssPropertyType::Widows;
    #[classattr]
    const BoxDecorationBreak: AzCssPropertyType = AzCssPropertyType::BoxDecorationBreak;
    #[classattr]
    const ColumnCount: AzCssPropertyType = AzCssPropertyType::ColumnCount;
    #[classattr]
    const ColumnWidth: AzCssPropertyType = AzCssPropertyType::ColumnWidth;
    #[classattr]
    const ColumnSpan: AzCssPropertyType = AzCssPropertyType::ColumnSpan;
    #[classattr]
    const ColumnFill: AzCssPropertyType = AzCssPropertyType::ColumnFill;
    #[classattr]
    const ColumnRuleWidth: AzCssPropertyType = AzCssPropertyType::ColumnRuleWidth;
    #[classattr]
    const ColumnRuleStyle: AzCssPropertyType = AzCssPropertyType::ColumnRuleStyle;
    #[classattr]
    const ColumnRuleColor: AzCssPropertyType = AzCssPropertyType::ColumnRuleColor;
    #[classattr]
    const FlowInto: AzCssPropertyType = AzCssPropertyType::FlowInto;
    #[classattr]
    const FlowFrom: AzCssPropertyType = AzCssPropertyType::FlowFrom;
    #[classattr]
    const ShapeOutside: AzCssPropertyType = AzCssPropertyType::ShapeOutside;
    #[classattr]
    const ShapeMargin: AzCssPropertyType = AzCssPropertyType::ShapeMargin;
    #[classattr]
    const ShapeImageThreshold: AzCssPropertyType = AzCssPropertyType::ShapeImageThreshold;
    #[classattr]
    const Content: AzCssPropertyType = AzCssPropertyType::Content;
    #[classattr]
    const CounterReset: AzCssPropertyType = AzCssPropertyType::CounterReset;
    #[classattr]
    const CounterIncrement: AzCssPropertyType = AzCssPropertyType::CounterIncrement;
    #[classattr]
    const StringSet: AzCssPropertyType = AzCssPropertyType::StringSet;
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::CssPropertyType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::CssPropertyType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzCssPropertyTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAnimationInterpolationFunctionEnumWrapper {
    #[classattr]
    fn Ease() -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::Ease }
    }
    #[classattr]
    fn Linear() -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::Linear }
    }
    #[classattr]
    fn EaseIn() -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::EaseIn }
    }
    #[classattr]
    fn EaseOut() -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::EaseOut }
    }
    #[classattr]
    fn EaseInOut() -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::EaseInOut }
    }
    #[staticmethod]
    fn CubicBezier(v: SvgCubicCurve) -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::CubicBezier(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzAnimationInterpolationFunction;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAnimationInterpolationFunction::Ease => Ok(vec!["Ease".into_py(py), ().into_py(py)]),
            AzAnimationInterpolationFunction::Linear => Ok(vec!["Linear".into_py(py), ().into_py(py)]),
            AzAnimationInterpolationFunction::EaseIn => Ok(vec!["EaseIn".into_py(py), ().into_py(py)]),
            AzAnimationInterpolationFunction::EaseOut => Ok(vec!["EaseOut".into_py(py), ().into_py(py)]),
            AzAnimationInterpolationFunction::EaseInOut => Ok(vec!["EaseInOut".into_py(py), ().into_py(py)]),
            AzAnimationInterpolationFunction::CubicBezier(v) => Ok(vec!["CubicBezier".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAnimationInterpolationFunctionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::AnimationInterpolationFunction = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::AnimationInterpolationFunction = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeTagEnumWrapper {
    #[classattr]
    const Html: AzNodeTypeTag = AzNodeTypeTag::Html;
    #[classattr]
    const Head: AzNodeTypeTag = AzNodeTypeTag::Head;
    #[classattr]
    const Body: AzNodeTypeTag = AzNodeTypeTag::Body;
    #[classattr]
    const Div: AzNodeTypeTag = AzNodeTypeTag::Div;
    #[classattr]
    const P: AzNodeTypeTag = AzNodeTypeTag::P;
    #[classattr]
    const Article: AzNodeTypeTag = AzNodeTypeTag::Article;
    #[classattr]
    const Section: AzNodeTypeTag = AzNodeTypeTag::Section;
    #[classattr]
    const Nav: AzNodeTypeTag = AzNodeTypeTag::Nav;
    #[classattr]
    const Aside: AzNodeTypeTag = AzNodeTypeTag::Aside;
    #[classattr]
    const Header: AzNodeTypeTag = AzNodeTypeTag::Header;
    #[classattr]
    const Footer: AzNodeTypeTag = AzNodeTypeTag::Footer;
    #[classattr]
    const Main: AzNodeTypeTag = AzNodeTypeTag::Main;
    #[classattr]
    const Figure: AzNodeTypeTag = AzNodeTypeTag::Figure;
    #[classattr]
    const FigCaption: AzNodeTypeTag = AzNodeTypeTag::FigCaption;
    #[classattr]
    const H1: AzNodeTypeTag = AzNodeTypeTag::H1;
    #[classattr]
    const H2: AzNodeTypeTag = AzNodeTypeTag::H2;
    #[classattr]
    const H3: AzNodeTypeTag = AzNodeTypeTag::H3;
    #[classattr]
    const H4: AzNodeTypeTag = AzNodeTypeTag::H4;
    #[classattr]
    const H5: AzNodeTypeTag = AzNodeTypeTag::H5;
    #[classattr]
    const H6: AzNodeTypeTag = AzNodeTypeTag::H6;
    #[classattr]
    const Br: AzNodeTypeTag = AzNodeTypeTag::Br;
    #[classattr]
    const Hr: AzNodeTypeTag = AzNodeTypeTag::Hr;
    #[classattr]
    const Pre: AzNodeTypeTag = AzNodeTypeTag::Pre;
    #[classattr]
    const BlockQuote: AzNodeTypeTag = AzNodeTypeTag::BlockQuote;
    #[classattr]
    const Address: AzNodeTypeTag = AzNodeTypeTag::Address;
    #[classattr]
    const Details: AzNodeTypeTag = AzNodeTypeTag::Details;
    #[classattr]
    const Summary: AzNodeTypeTag = AzNodeTypeTag::Summary;
    #[classattr]
    const Dialog: AzNodeTypeTag = AzNodeTypeTag::Dialog;
    #[classattr]
    const Ul: AzNodeTypeTag = AzNodeTypeTag::Ul;
    #[classattr]
    const Ol: AzNodeTypeTag = AzNodeTypeTag::Ol;
    #[classattr]
    const Li: AzNodeTypeTag = AzNodeTypeTag::Li;
    #[classattr]
    const Dl: AzNodeTypeTag = AzNodeTypeTag::Dl;
    #[classattr]
    const Dt: AzNodeTypeTag = AzNodeTypeTag::Dt;
    #[classattr]
    const Dd: AzNodeTypeTag = AzNodeTypeTag::Dd;
    #[classattr]
    const Menu: AzNodeTypeTag = AzNodeTypeTag::Menu;
    #[classattr]
    const MenuItem: AzNodeTypeTag = AzNodeTypeTag::MenuItem;
    #[classattr]
    const Table: AzNodeTypeTag = AzNodeTypeTag::Table;
    #[classattr]
    const Caption: AzNodeTypeTag = AzNodeTypeTag::Caption;
    #[classattr]
    const THead: AzNodeTypeTag = AzNodeTypeTag::THead;
    #[classattr]
    const TBody: AzNodeTypeTag = AzNodeTypeTag::TBody;
    #[classattr]
    const TFoot: AzNodeTypeTag = AzNodeTypeTag::TFoot;
    #[classattr]
    const Tr: AzNodeTypeTag = AzNodeTypeTag::Tr;
    #[classattr]
    const Th: AzNodeTypeTag = AzNodeTypeTag::Th;
    #[classattr]
    const Td: AzNodeTypeTag = AzNodeTypeTag::Td;
    #[classattr]
    const ColGroup: AzNodeTypeTag = AzNodeTypeTag::ColGroup;
    #[classattr]
    const Col: AzNodeTypeTag = AzNodeTypeTag::Col;
    #[classattr]
    const Form: AzNodeTypeTag = AzNodeTypeTag::Form;
    #[classattr]
    const FieldSet: AzNodeTypeTag = AzNodeTypeTag::FieldSet;
    #[classattr]
    const Legend: AzNodeTypeTag = AzNodeTypeTag::Legend;
    #[classattr]
    const Label: AzNodeTypeTag = AzNodeTypeTag::Label;
    #[classattr]
    const Input: AzNodeTypeTag = AzNodeTypeTag::Input;
    #[classattr]
    const Button: AzNodeTypeTag = AzNodeTypeTag::Button;
    #[classattr]
    const Select: AzNodeTypeTag = AzNodeTypeTag::Select;
    #[classattr]
    const OptGroup: AzNodeTypeTag = AzNodeTypeTag::OptGroup;
    #[classattr]
    const SelectOption: AzNodeTypeTag = AzNodeTypeTag::SelectOption;
    #[classattr]
    const TextArea: AzNodeTypeTag = AzNodeTypeTag::TextArea;
    #[classattr]
    const Output: AzNodeTypeTag = AzNodeTypeTag::Output;
    #[classattr]
    const Progress: AzNodeTypeTag = AzNodeTypeTag::Progress;
    #[classattr]
    const Meter: AzNodeTypeTag = AzNodeTypeTag::Meter;
    #[classattr]
    const DataList: AzNodeTypeTag = AzNodeTypeTag::DataList;
    #[classattr]
    const Span: AzNodeTypeTag = AzNodeTypeTag::Span;
    #[classattr]
    const A: AzNodeTypeTag = AzNodeTypeTag::A;
    #[classattr]
    const Em: AzNodeTypeTag = AzNodeTypeTag::Em;
    #[classattr]
    const Strong: AzNodeTypeTag = AzNodeTypeTag::Strong;
    #[classattr]
    const B: AzNodeTypeTag = AzNodeTypeTag::B;
    #[classattr]
    const I: AzNodeTypeTag = AzNodeTypeTag::I;
    #[classattr]
    const U: AzNodeTypeTag = AzNodeTypeTag::U;
    #[classattr]
    const S: AzNodeTypeTag = AzNodeTypeTag::S;
    #[classattr]
    const Mark: AzNodeTypeTag = AzNodeTypeTag::Mark;
    #[classattr]
    const Del: AzNodeTypeTag = AzNodeTypeTag::Del;
    #[classattr]
    const Ins: AzNodeTypeTag = AzNodeTypeTag::Ins;
    #[classattr]
    const Code: AzNodeTypeTag = AzNodeTypeTag::Code;
    #[classattr]
    const Samp: AzNodeTypeTag = AzNodeTypeTag::Samp;
    #[classattr]
    const Kbd: AzNodeTypeTag = AzNodeTypeTag::Kbd;
    #[classattr]
    const Var: AzNodeTypeTag = AzNodeTypeTag::Var;
    #[classattr]
    const Cite: AzNodeTypeTag = AzNodeTypeTag::Cite;
    #[classattr]
    const Dfn: AzNodeTypeTag = AzNodeTypeTag::Dfn;
    #[classattr]
    const Abbr: AzNodeTypeTag = AzNodeTypeTag::Abbr;
    #[classattr]
    const Acronym: AzNodeTypeTag = AzNodeTypeTag::Acronym;
    #[classattr]
    const Q: AzNodeTypeTag = AzNodeTypeTag::Q;
    #[classattr]
    const Time: AzNodeTypeTag = AzNodeTypeTag::Time;
    #[classattr]
    const Sub: AzNodeTypeTag = AzNodeTypeTag::Sub;
    #[classattr]
    const Sup: AzNodeTypeTag = AzNodeTypeTag::Sup;
    #[classattr]
    const Small: AzNodeTypeTag = AzNodeTypeTag::Small;
    #[classattr]
    const Big: AzNodeTypeTag = AzNodeTypeTag::Big;
    #[classattr]
    const Bdo: AzNodeTypeTag = AzNodeTypeTag::Bdo;
    #[classattr]
    const Canvas: AzNodeTypeTag = AzNodeTypeTag::Canvas;
    #[classattr]
    const Object: AzNodeTypeTag = AzNodeTypeTag::Object;
    #[classattr]
    const Param: AzNodeTypeTag = AzNodeTypeTag::Param;
    #[classattr]
    const Embed: AzNodeTypeTag = AzNodeTypeTag::Embed;
    #[classattr]
    const Audio: AzNodeTypeTag = AzNodeTypeTag::Audio;
    #[classattr]
    const Video: AzNodeTypeTag = AzNodeTypeTag::Video;
    #[classattr]
    const Source: AzNodeTypeTag = AzNodeTypeTag::Source;
    #[classattr]
    const Track: AzNodeTypeTag = AzNodeTypeTag::Track;
    #[classattr]
    const Map: AzNodeTypeTag = AzNodeTypeTag::Map;
    #[classattr]
    const Area: AzNodeTypeTag = AzNodeTypeTag::Area;
    #[classattr]
    const Title: AzNodeTypeTag = AzNodeTypeTag::Title;
    #[classattr]
    const Meta: AzNodeTypeTag = AzNodeTypeTag::Meta;
    #[classattr]
    const Link: AzNodeTypeTag = AzNodeTypeTag::Link;
    #[classattr]
    const Script: AzNodeTypeTag = AzNodeTypeTag::Script;
    #[classattr]
    const Style: AzNodeTypeTag = AzNodeTypeTag::Style;
    #[classattr]
    const Base: AzNodeTypeTag = AzNodeTypeTag::Base;
    #[classattr]
    const Text: AzNodeTypeTag = AzNodeTypeTag::Text;
    #[classattr]
    const Img: AzNodeTypeTag = AzNodeTypeTag::Img;
    #[classattr]
    const IFrame: AzNodeTypeTag = AzNodeTypeTag::IFrame;
    #[classattr]
    const Before: AzNodeTypeTag = AzNodeTypeTag::Before;
    #[classattr]
    const After: AzNodeTypeTag = AzNodeTypeTag::After;
    #[classattr]
    const Marker: AzNodeTypeTag = AzNodeTypeTag::Marker;
    #[classattr]
    const Placeholder: AzNodeTypeTag = AzNodeTypeTag::Placeholder;
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeTagEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::NodeTypeTag = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::NodeTypeTag = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzNodeTypeTagEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzColorU {
    #[staticmethod]
    fn from_str(/* args */) -> AzColorU {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn transparent(/* args */) -> AzColorU {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn white(/* args */) -> AzColorU {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn black(/* args */) -> AzColorU {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn to_hash(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzColorU {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::color::ColorU = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::color::ColorU = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSizeMetricEnumWrapper {
    #[classattr]
    const Px: AzSizeMetric = AzSizeMetric::Px;
    #[classattr]
    const Pt: AzSizeMetric = AzSizeMetric::Pt;
    #[classattr]
    const Em: AzSizeMetric = AzSizeMetric::Em;
    #[classattr]
    const In: AzSizeMetric = AzSizeMetric::In;
    #[classattr]
    const Cm: AzSizeMetric = AzSizeMetric::Cm;
    #[classattr]
    const Mm: AzSizeMetric = AzSizeMetric::Mm;
    #[classattr]
    const Percent: AzSizeMetric = AzSizeMetric::Percent;
}

#[pyproto]
impl PyObjectProtocol for AzSizeMetricEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::length::SizeMetric = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::length::SizeMetric = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzSizeMetricEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzPixelValue {
}

#[pyproto]
impl PyObjectProtocol for AzPixelValue {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::pixel::PixelValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::pixel::PixelValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPixelValueNoPercent {
}

#[pyproto]
impl PyObjectProtocol for AzPixelValueNoPercent {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::pixel::PixelValueNoPercent = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::pixel::PixelValueNoPercent = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBoxShadowClipModeEnumWrapper {
    #[classattr]
    const Outset: AzBoxShadowClipMode = AzBoxShadowClipMode::Outset;
    #[classattr]
    const Inset: AzBoxShadowClipMode = AzBoxShadowClipMode::Inset;
}

#[pyproto]
impl PyObjectProtocol for AzBoxShadowClipModeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::box_shadow::BoxShadowClipMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::box_shadow::BoxShadowClipMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzBoxShadowClipModeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleBoxShadow {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBoxShadow {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::box_shadow::StyleBoxShadow = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::box_shadow::StyleBoxShadow = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleMixBlendModeEnumWrapper {
    #[classattr]
    const Normal: AzStyleMixBlendMode = AzStyleMixBlendMode::Normal;
    #[classattr]
    const Multiply: AzStyleMixBlendMode = AzStyleMixBlendMode::Multiply;
    #[classattr]
    const Screen: AzStyleMixBlendMode = AzStyleMixBlendMode::Screen;
    #[classattr]
    const Overlay: AzStyleMixBlendMode = AzStyleMixBlendMode::Overlay;
    #[classattr]
    const Darken: AzStyleMixBlendMode = AzStyleMixBlendMode::Darken;
    #[classattr]
    const Lighten: AzStyleMixBlendMode = AzStyleMixBlendMode::Lighten;
    #[classattr]
    const ColorDodge: AzStyleMixBlendMode = AzStyleMixBlendMode::ColorDodge;
    #[classattr]
    const ColorBurn: AzStyleMixBlendMode = AzStyleMixBlendMode::ColorBurn;
    #[classattr]
    const HardLight: AzStyleMixBlendMode = AzStyleMixBlendMode::HardLight;
    #[classattr]
    const SoftLight: AzStyleMixBlendMode = AzStyleMixBlendMode::SoftLight;
    #[classattr]
    const Difference: AzStyleMixBlendMode = AzStyleMixBlendMode::Difference;
    #[classattr]
    const Exclusion: AzStyleMixBlendMode = AzStyleMixBlendMode::Exclusion;
    #[classattr]
    const Hue: AzStyleMixBlendMode = AzStyleMixBlendMode::Hue;
    #[classattr]
    const Saturation: AzStyleMixBlendMode = AzStyleMixBlendMode::Saturation;
    #[classattr]
    const Color: AzStyleMixBlendMode = AzStyleMixBlendMode::Color;
    #[classattr]
    const Luminosity: AzStyleMixBlendMode = AzStyleMixBlendMode::Luminosity;
}

#[pyproto]
impl PyObjectProtocol for AzStyleMixBlendModeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::effects::StyleMixBlendMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::effects::StyleMixBlendMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleMixBlendModeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleFilterEnumWrapper {
    #[staticmethod]
    fn Blend(v: StyleMixBlendMode) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::Blend(v) }}
    }
    #[staticmethod]
    fn Flood(v: ColorU) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::Flood(v) }}
    }
    #[staticmethod]
    fn Blur(v: StyleBlur) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::Blur(v) }}
    }
    #[staticmethod]
    fn Opacity(v: PercentageValue) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::Opacity(v) }}
    }
    #[staticmethod]
    fn ColorMatrix(v: StyleColorMatrix) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::ColorMatrix(v) }}
    }
    #[staticmethod]
    fn DropShadow(v: StyleBoxShadow) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::DropShadow(v) }}
    }
    #[classattr]
    fn ComponentTransfer() -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::ComponentTransfer }
    }
    #[staticmethod]
    fn Offset(v: StyleFilterOffset) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::Offset(v) }}
    }
    #[staticmethod]
    fn Composite(v: StyleCompositeFilter) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::Composite(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleFilter;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFilter::Blend(v) => Ok(vec!["Blend".into_py(py), v.into_py(py)]),
            AzStyleFilter::Flood(v) => Ok(vec!["Flood".into_py(py), v.into_py(py)]),
            AzStyleFilter::Blur(v) => Ok(vec!["Blur".into_py(py), v.into_py(py)]),
            AzStyleFilter::Opacity(v) => Ok(vec!["Opacity".into_py(py), v.into_py(py)]),
            AzStyleFilter::ColorMatrix(v) => Ok(vec!["ColorMatrix".into_py(py), v.into_py(py)]),
            AzStyleFilter::DropShadow(v) => Ok(vec!["DropShadow".into_py(py), v.into_py(py)]),
            AzStyleFilter::ComponentTransfer => Ok(vec!["ComponentTransfer".into_py(py), ().into_py(py)]),
            AzStyleFilter::Offset(v) => Ok(vec!["Offset".into_py(py), v.into_py(py)]),
            AzStyleFilter::Composite(v) => Ok(vec!["Composite".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBlur {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBlur {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleBlur = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleBlur = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleColorMatrix {
}

#[pyproto]
impl PyObjectProtocol for AzStyleColorMatrix {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleColorMatrix = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleColorMatrix = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFilterOffset {
}

#[pyproto]
impl PyObjectProtocol for AzStyleFilterOffset {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleFilterOffset = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleFilterOffset = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleCompositeFilterEnumWrapper {
    #[classattr]
    fn Over() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper { inner: AzStyleCompositeFilter::Over }
    }
    #[classattr]
    fn In() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper { inner: AzStyleCompositeFilter::In }
    }
    #[classattr]
    fn Atop() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper { inner: AzStyleCompositeFilter::Atop }
    }
    #[classattr]
    fn Out() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper { inner: AzStyleCompositeFilter::Out }
    }
    #[classattr]
    fn Xor() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper { inner: AzStyleCompositeFilter::Xor }
    }
    #[classattr]
    fn Lighter() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper { inner: AzStyleCompositeFilter::Lighter }
    }
    #[staticmethod]
    fn Arithmetic(v: [FloatValue) -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper { inner: AzStyleCompositeFilter::Arithmetic(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleCompositeFilter;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleCompositeFilter::Over => Ok(vec!["Over".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::In => Ok(vec!["In".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::Atop => Ok(vec!["Atop".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::Out => Ok(vec!["Out".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::Xor => Ok(vec!["Xor".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::Lighter => Ok(vec!["Lighter".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::Arithmetic(v) => Ok(vec!["Arithmetic".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleCompositeFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleCompositeFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleCompositeFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutAlignContentEnumWrapper {
    #[classattr]
    const Stretch: AzLayoutAlignContent = AzLayoutAlignContent::Stretch;
    #[classattr]
    const Center: AzLayoutAlignContent = AzLayoutAlignContent::Center;
    #[classattr]
    const Start: AzLayoutAlignContent = AzLayoutAlignContent::Start;
    #[classattr]
    const End: AzLayoutAlignContent = AzLayoutAlignContent::End;
    #[classattr]
    const SpaceBetween: AzLayoutAlignContent = AzLayoutAlignContent::SpaceBetween;
    #[classattr]
    const SpaceAround: AzLayoutAlignContent = AzLayoutAlignContent::SpaceAround;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutAlignContentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutAlignContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutAlignContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutAlignContentEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutAlignItemsEnumWrapper {
    #[classattr]
    const Stretch: AzLayoutAlignItems = AzLayoutAlignItems::Stretch;
    #[classattr]
    const Center: AzLayoutAlignItems = AzLayoutAlignItems::Center;
    #[classattr]
    const Start: AzLayoutAlignItems = AzLayoutAlignItems::Start;
    #[classattr]
    const End: AzLayoutAlignItems = AzLayoutAlignItems::End;
    #[classattr]
    const Baseline: AzLayoutAlignItems = AzLayoutAlignItems::Baseline;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutAlignItemsEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutAlignItems = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutAlignItems = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutAlignItemsEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutBottom {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBottom {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBoxSizingEnumWrapper {
    #[classattr]
    const ContentBox: AzLayoutBoxSizing = AzLayoutBoxSizing::ContentBox;
    #[classattr]
    const BorderBox: AzLayoutBoxSizing = AzLayoutBoxSizing::BorderBox;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBoxSizingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutBoxSizing = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutBoxSizing = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutBoxSizingEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutFlexDirectionEnumWrapper {
    #[classattr]
    const Row: AzLayoutFlexDirection = AzLayoutFlexDirection::Row;
    #[classattr]
    const RowReverse: AzLayoutFlexDirection = AzLayoutFlexDirection::RowReverse;
    #[classattr]
    const Column: AzLayoutFlexDirection = AzLayoutFlexDirection::Column;
    #[classattr]
    const ColumnReverse: AzLayoutFlexDirection = AzLayoutFlexDirection::ColumnReverse;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexDirectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexDirection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexDirection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutFlexDirectionEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutDisplayEnumWrapper {
    #[classattr]
    const None: AzLayoutDisplay = AzLayoutDisplay::None;
    #[classattr]
    const Block: AzLayoutDisplay = AzLayoutDisplay::Block;
    #[classattr]
    const Inline: AzLayoutDisplay = AzLayoutDisplay::Inline;
    #[classattr]
    const InlineBlock: AzLayoutDisplay = AzLayoutDisplay::InlineBlock;
    #[classattr]
    const Flex: AzLayoutDisplay = AzLayoutDisplay::Flex;
    #[classattr]
    const InlineFlex: AzLayoutDisplay = AzLayoutDisplay::InlineFlex;
    #[classattr]
    const Table: AzLayoutDisplay = AzLayoutDisplay::Table;
    #[classattr]
    const InlineTable: AzLayoutDisplay = AzLayoutDisplay::InlineTable;
    #[classattr]
    const TableRowGroup: AzLayoutDisplay = AzLayoutDisplay::TableRowGroup;
    #[classattr]
    const TableHeaderGroup: AzLayoutDisplay = AzLayoutDisplay::TableHeaderGroup;
    #[classattr]
    const TableFooterGroup: AzLayoutDisplay = AzLayoutDisplay::TableFooterGroup;
    #[classattr]
    const TableRow: AzLayoutDisplay = AzLayoutDisplay::TableRow;
    #[classattr]
    const TableColumnGroup: AzLayoutDisplay = AzLayoutDisplay::TableColumnGroup;
    #[classattr]
    const TableColumn: AzLayoutDisplay = AzLayoutDisplay::TableColumn;
    #[classattr]
    const TableCell: AzLayoutDisplay = AzLayoutDisplay::TableCell;
    #[classattr]
    const TableCaption: AzLayoutDisplay = AzLayoutDisplay::TableCaption;
    #[classattr]
    const FlowRoot: AzLayoutDisplay = AzLayoutDisplay::FlowRoot;
    #[classattr]
    const ListItem: AzLayoutDisplay = AzLayoutDisplay::ListItem;
    #[classattr]
    const RunIn: AzLayoutDisplay = AzLayoutDisplay::RunIn;
    #[classattr]
    const Marker: AzLayoutDisplay = AzLayoutDisplay::Marker;
    #[classattr]
    const Grid: AzLayoutDisplay = AzLayoutDisplay::Grid;
    #[classattr]
    const InlineGrid: AzLayoutDisplay = AzLayoutDisplay::InlineGrid;
    #[classattr]
    const Initial: AzLayoutDisplay = AzLayoutDisplay::Initial;
    #[classattr]
    const Inherit: AzLayoutDisplay = AzLayoutDisplay::Inherit;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutDisplayEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::display::LayoutDisplay = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::display::LayoutDisplay = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutDisplayEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutFlexGrow {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexGrow {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexGrow = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexGrow = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexShrink {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexShrink {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexShrink = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexShrink = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFloatEnumWrapper {
    #[classattr]
    const Left: AzLayoutFloat = AzLayoutFloat::Left;
    #[classattr]
    const Right: AzLayoutFloat = AzLayoutFloat::Right;
    #[classattr]
    const None: AzLayoutFloat = AzLayoutFloat::None;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFloatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::display::LayoutFloat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::display::LayoutFloat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutFloatEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutHeight {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutHeight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutJustifyContentEnumWrapper {
    #[classattr]
    const FlexStart: AzLayoutJustifyContent = AzLayoutJustifyContent::FlexStart;
    #[classattr]
    const FlexEnd: AzLayoutJustifyContent = AzLayoutJustifyContent::FlexEnd;
    #[classattr]
    const Start: AzLayoutJustifyContent = AzLayoutJustifyContent::Start;
    #[classattr]
    const End: AzLayoutJustifyContent = AzLayoutJustifyContent::End;
    #[classattr]
    const Center: AzLayoutJustifyContent = AzLayoutJustifyContent::Center;
    #[classattr]
    const SpaceBetween: AzLayoutJustifyContent = AzLayoutJustifyContent::SpaceBetween;
    #[classattr]
    const SpaceAround: AzLayoutJustifyContent = AzLayoutJustifyContent::SpaceAround;
    #[classattr]
    const SpaceEvenly: AzLayoutJustifyContent = AzLayoutJustifyContent::SpaceEvenly;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutJustifyContentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutJustifyContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutJustifyContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutJustifyContentEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutLeft {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutLeft {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginBottom {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginBottom {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutMarginBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutMarginBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginLeft {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginLeft {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutMarginLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutMarginLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginRight {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginRight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutMarginRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutMarginRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginTop {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginTop {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutMarginTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutMarginTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMaxHeight {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMaxHeight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutMaxHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutMaxHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMaxWidth {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMaxWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutMaxWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutMaxWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMinHeight {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMinHeight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutMinHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutMinHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMinWidth {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMinWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutMinWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutMinWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingBottom {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingBottom {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutPaddingBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutPaddingBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingLeft {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingLeft {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutPaddingLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutPaddingLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingRight {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingRight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutPaddingRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutPaddingRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingTop {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingTop {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutPaddingTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutPaddingTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPositionEnumWrapper {
    #[classattr]
    const Static: AzLayoutPosition = AzLayoutPosition::Static;
    #[classattr]
    const Relative: AzLayoutPosition = AzLayoutPosition::Relative;
    #[classattr]
    const Absolute: AzLayoutPosition = AzLayoutPosition::Absolute;
    #[classattr]
    const Fixed: AzLayoutPosition = AzLayoutPosition::Fixed;
    #[classattr]
    const Sticky: AzLayoutPosition = AzLayoutPosition::Sticky;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::position::LayoutPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::position::LayoutPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutPositionEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutRight {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutRight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutTop {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutTop {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutWidth {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexWrapEnumWrapper {
    #[classattr]
    const Wrap: AzLayoutFlexWrap = AzLayoutFlexWrap::Wrap;
    #[classattr]
    const NoWrap: AzLayoutFlexWrap = AzLayoutFlexWrap::NoWrap;
    #[classattr]
    const WrapReverse: AzLayoutFlexWrap = AzLayoutFlexWrap::WrapReverse;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexWrapEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexWrap = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexWrap = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutFlexWrapEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutOverflowEnumWrapper {
    #[classattr]
    const Scroll: AzLayoutOverflow = AzLayoutOverflow::Scroll;
    #[classattr]
    const Auto: AzLayoutOverflow = AzLayoutOverflow::Auto;
    #[classattr]
    const Hidden: AzLayoutOverflow = AzLayoutOverflow::Hidden;
    #[classattr]
    const Visible: AzLayoutOverflow = AzLayoutOverflow::Visible;
    #[classattr]
    const Clip: AzLayoutOverflow = AzLayoutOverflow::Clip;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutOverflowEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::overflow::LayoutOverflow = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::overflow::LayoutOverflow = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutOverflowEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzFloatValue {
}

#[pyproto]
impl PyObjectProtocol for AzFloatValue {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::length::FloatValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::length::FloatValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPercentageValue {
}

#[pyproto]
impl PyObjectProtocol for AzPercentageValue {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::length::PercentageValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::length::PercentageValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAngleMetricEnumWrapper {
    #[classattr]
    const Degree: AzAngleMetric = AzAngleMetric::Degree;
    #[classattr]
    const Radians: AzAngleMetric = AzAngleMetric::Radians;
    #[classattr]
    const Grad: AzAngleMetric = AzAngleMetric::Grad;
    #[classattr]
    const Turn: AzAngleMetric = AzAngleMetric::Turn;
    #[classattr]
    const Percent: AzAngleMetric = AzAngleMetric::Percent;
}

#[pyproto]
impl PyObjectProtocol for AzAngleMetricEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::angle::AngleMetric = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::angle::AngleMetric = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAngleMetricEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAngleValue {
    fn get_degrees(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzAngleValue {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::angle::AngleValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::angle::AngleValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedLinearColorStop {
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedLinearColorStop {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedLinearColorStop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedLinearColorStop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedRadialColorStop {
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedRadialColorStop {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedRadialColorStop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedRadialColorStop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDirectionCornerEnumWrapper {
    #[classattr]
    const Right: AzDirectionCorner = AzDirectionCorner::Right;
    #[classattr]
    const Left: AzDirectionCorner = AzDirectionCorner::Left;
    #[classattr]
    const Top: AzDirectionCorner = AzDirectionCorner::Top;
    #[classattr]
    const Bottom: AzDirectionCorner = AzDirectionCorner::Bottom;
    #[classattr]
    const TopRight: AzDirectionCorner = AzDirectionCorner::TopRight;
    #[classattr]
    const TopLeft: AzDirectionCorner = AzDirectionCorner::TopLeft;
    #[classattr]
    const BottomRight: AzDirectionCorner = AzDirectionCorner::BottomRight;
    #[classattr]
    const BottomLeft: AzDirectionCorner = AzDirectionCorner::BottomLeft;
}

#[pyproto]
impl PyObjectProtocol for AzDirectionCornerEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::direction::DirectionCorner = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::direction::DirectionCorner = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzDirectionCornerEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzDirectionCorners {
}

#[pyproto]
impl PyObjectProtocol for AzDirectionCorners {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::direction::DirectionCorners = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::direction::DirectionCorners = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDirectionEnumWrapper {
    #[staticmethod]
    fn Angle(v: AngleValue) -> AzDirectionEnumWrapper {
        AzDirectionEnumWrapper { inner: AzDirection::Angle(v) }}
    }
    #[staticmethod]
    fn FromTo(v: DirectionCorners) -> AzDirectionEnumWrapper {
        AzDirectionEnumWrapper { inner: AzDirection::FromTo(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzDirection;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzDirection::Angle(v) => Ok(vec!["Angle".into_py(py), v.into_py(py)]),
            AzDirection::FromTo(v) => Ok(vec!["FromTo".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDirectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::direction::Direction = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::direction::Direction = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzExtendModeEnumWrapper {
    #[classattr]
    const Clamp: AzExtendMode = AzExtendMode::Clamp;
    #[classattr]
    const Repeat: AzExtendMode = AzExtendMode::Repeat;
}

#[pyproto]
impl PyObjectProtocol for AzExtendModeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::ExtendMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::ExtendMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzExtendModeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLinearGradient {
}

#[pyproto]
impl PyObjectProtocol for AzLinearGradient {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::LinearGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::LinearGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapeEnumWrapper {
    #[classattr]
    const Ellipse: AzShape = AzShape::Ellipse;
    #[classattr]
    const Circle: AzShape = AzShape::Circle;
}

#[pyproto]
impl PyObjectProtocol for AzShapeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::Shape = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::Shape = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzShapeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzRadialGradientSizeEnumWrapper {
    #[classattr]
    const ClosestSide: AzRadialGradientSize = AzRadialGradientSize::ClosestSide;
    #[classattr]
    const ClosestCorner: AzRadialGradientSize = AzRadialGradientSize::ClosestCorner;
    #[classattr]
    const FarthestSide: AzRadialGradientSize = AzRadialGradientSize::FarthestSide;
    #[classattr]
    const FarthestCorner: AzRadialGradientSize = AzRadialGradientSize::FarthestCorner;
}

#[pyproto]
impl PyObjectProtocol for AzRadialGradientSizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::RadialGradientSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::RadialGradientSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzRadialGradientSizeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzRadialGradient {
}

#[pyproto]
impl PyObjectProtocol for AzRadialGradient {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::RadialGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::RadialGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzConicGradient {
}

#[pyproto]
impl PyObjectProtocol for AzConicGradient {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::ConicGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::ConicGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundContentEnumWrapper {
    #[staticmethod]
    fn LinearGradient(v: LinearGradient) -> AzStyleBackgroundContentEnumWrapper {
        AzStyleBackgroundContentEnumWrapper { inner: AzStyleBackgroundContent::LinearGradient(v) }}
    }
    #[staticmethod]
    fn RadialGradient(v: RadialGradient) -> AzStyleBackgroundContentEnumWrapper {
        AzStyleBackgroundContentEnumWrapper { inner: AzStyleBackgroundContent::RadialGradient(v) }}
    }
    #[staticmethod]
    fn ConicGradient(v: ConicGradient) -> AzStyleBackgroundContentEnumWrapper {
        AzStyleBackgroundContentEnumWrapper { inner: AzStyleBackgroundContent::ConicGradient(v) }}
    }
    #[staticmethod]
    fn Image(v: AzString) -> AzStyleBackgroundContentEnumWrapper {
        AzStyleBackgroundContentEnumWrapper { inner: AzStyleBackgroundContent::Image(v) }}
    }
    #[staticmethod]
    fn Color(v: ColorU) -> AzStyleBackgroundContentEnumWrapper {
        AzStyleBackgroundContentEnumWrapper { inner: AzStyleBackgroundContent::Color(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundContent;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundContent::LinearGradient(v) => Ok(vec!["LinearGradient".into_py(py), v.into_py(py)]),
            AzStyleBackgroundContent::RadialGradient(v) => Ok(vec!["RadialGradient".into_py(py), v.into_py(py)]),
            AzStyleBackgroundContent::ConicGradient(v) => Ok(vec!["ConicGradient".into_py(py), v.into_py(py)]),
            AzStyleBackgroundContent::Image(v) => Ok(vec!["Image".into_py(py), v.into_py(py)]),
            AzStyleBackgroundContent::Color(v) => Ok(vec!["Color".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundContentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBackgroundPositionHorizontalEnumWrapper {
    #[classattr]
    fn Left() -> AzBackgroundPositionHorizontalEnumWrapper {
        AzBackgroundPositionHorizontalEnumWrapper { inner: AzBackgroundPositionHorizontal::Left }
    }
    #[classattr]
    fn Center() -> AzBackgroundPositionHorizontalEnumWrapper {
        AzBackgroundPositionHorizontalEnumWrapper { inner: AzBackgroundPositionHorizontal::Center }
    }
    #[classattr]
    fn Right() -> AzBackgroundPositionHorizontalEnumWrapper {
        AzBackgroundPositionHorizontalEnumWrapper { inner: AzBackgroundPositionHorizontal::Right }
    }
    #[staticmethod]
    fn Exact(v: PixelValue) -> AzBackgroundPositionHorizontalEnumWrapper {
        AzBackgroundPositionHorizontalEnumWrapper { inner: AzBackgroundPositionHorizontal::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzBackgroundPositionHorizontal;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzBackgroundPositionHorizontal::Left => Ok(vec!["Left".into_py(py), ().into_py(py)]),
            AzBackgroundPositionHorizontal::Center => Ok(vec!["Center".into_py(py), ().into_py(py)]),
            AzBackgroundPositionHorizontal::Right => Ok(vec!["Right".into_py(py), ().into_py(py)]),
            AzBackgroundPositionHorizontal::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzBackgroundPositionHorizontalEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::BackgroundPositionHorizontal = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::BackgroundPositionHorizontal = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBackgroundPositionVerticalEnumWrapper {
    #[classattr]
    fn Top() -> AzBackgroundPositionVerticalEnumWrapper {
        AzBackgroundPositionVerticalEnumWrapper { inner: AzBackgroundPositionVertical::Top }
    }
    #[classattr]
    fn Center() -> AzBackgroundPositionVerticalEnumWrapper {
        AzBackgroundPositionVerticalEnumWrapper { inner: AzBackgroundPositionVertical::Center }
    }
    #[classattr]
    fn Bottom() -> AzBackgroundPositionVerticalEnumWrapper {
        AzBackgroundPositionVerticalEnumWrapper { inner: AzBackgroundPositionVertical::Bottom }
    }
    #[staticmethod]
    fn Exact(v: PixelValue) -> AzBackgroundPositionVerticalEnumWrapper {
        AzBackgroundPositionVerticalEnumWrapper { inner: AzBackgroundPositionVertical::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzBackgroundPositionVertical;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzBackgroundPositionVertical::Top => Ok(vec!["Top".into_py(py), ().into_py(py)]),
            AzBackgroundPositionVertical::Center => Ok(vec!["Center".into_py(py), ().into_py(py)]),
            AzBackgroundPositionVertical::Bottom => Ok(vec!["Bottom".into_py(py), ().into_py(py)]),
            AzBackgroundPositionVertical::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzBackgroundPositionVerticalEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::BackgroundPositionVertical = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::BackgroundPositionVertical = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundPosition {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundPosition {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundPosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundPosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundRepeatEnumWrapper {
    #[classattr]
    const NoRepeat: AzStyleBackgroundRepeat = AzStyleBackgroundRepeat::NoRepeat;
    #[classattr]
    const Repeat: AzStyleBackgroundRepeat = AzStyleBackgroundRepeat::Repeat;
    #[classattr]
    const RepeatX: AzStyleBackgroundRepeat = AzStyleBackgroundRepeat::RepeatX;
    #[classattr]
    const RepeatY: AzStyleBackgroundRepeat = AzStyleBackgroundRepeat::RepeatY;
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundRepeatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundRepeat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundRepeat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleBackgroundRepeatEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleBackgroundSizeEnumWrapper {
    #[staticmethod]
    fn ExactSize(v: [PixelValue) -> AzStyleBackgroundSizeEnumWrapper {
        AzStyleBackgroundSizeEnumWrapper { inner: AzStyleBackgroundSize::ExactSize(v) }}
    }
    #[classattr]
    fn Contain() -> AzStyleBackgroundSizeEnumWrapper {
        AzStyleBackgroundSizeEnumWrapper { inner: AzStyleBackgroundSize::Contain }
    }
    #[classattr]
    fn Cover() -> AzStyleBackgroundSizeEnumWrapper {
        AzStyleBackgroundSizeEnumWrapper { inner: AzStyleBackgroundSize::Cover }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundSize;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundSize::ExactSize(v) => Ok(vec!["ExactSize".into_py(py), v.into_py(py)]),
            AzStyleBackgroundSize::Contain => Ok(vec!["Contain".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSize::Cover => Ok(vec!["Cover".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundSizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomColor {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderBottomColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderBottomColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomLeftRadius {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomLeftRadius {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderBottomLeftRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderBottomLeftRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomRightRadius {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomRightRadius {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderBottomRightRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderBottomRightRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBorderStyleEnumWrapper {
    #[classattr]
    const None: AzBorderStyle = AzBorderStyle::None;
    #[classattr]
    const Solid: AzBorderStyle = AzBorderStyle::Solid;
    #[classattr]
    const Double: AzBorderStyle = AzBorderStyle::Double;
    #[classattr]
    const Dotted: AzBorderStyle = AzBorderStyle::Dotted;
    #[classattr]
    const Dashed: AzBorderStyle = AzBorderStyle::Dashed;
    #[classattr]
    const Hidden: AzBorderStyle = AzBorderStyle::Hidden;
    #[classattr]
    const Groove: AzBorderStyle = AzBorderStyle::Groove;
    #[classattr]
    const Ridge: AzBorderStyle = AzBorderStyle::Ridge;
    #[classattr]
    const Inset: AzBorderStyle = AzBorderStyle::Inset;
    #[classattr]
    const Outset: AzBorderStyle = AzBorderStyle::Outset;
}

#[pyproto]
impl PyObjectProtocol for AzBorderStyleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::BorderStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::BorderStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzBorderStyleEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleBorderBottomStyle {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderBottomStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderBottomStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderBottomWidth {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderBottomWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutBorderBottomWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutBorderBottomWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderLeftColor {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderLeftColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderLeftColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderLeftColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderLeftStyle {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderLeftStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderLeftStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderLeftStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderLeftWidth {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderLeftWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutBorderLeftWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutBorderLeftWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderRightColor {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderRightColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderRightColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderRightColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderRightStyle {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderRightStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderRightStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderRightStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderRightWidth {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderRightWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutBorderRightWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutBorderRightWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopColor {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderTopColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderTopColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopLeftRadius {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopLeftRadius {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderTopLeftRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderTopLeftRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopRightRadius {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopRightRadius {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderTopRightRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderTopRightRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopStyle {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderTopStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::StyleBorderTopStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderTopWidth {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderTopWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutBorderTopWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::LayoutBorderTopWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScrollbarInfo {
}

#[pyproto]
impl PyObjectProtocol for AzScrollbarInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::ScrollbarInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::ScrollbarInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScrollbarStyle {
}

#[pyproto]
impl PyObjectProtocol for AzScrollbarStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::ScrollbarStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::ScrollbarStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleCursorEnumWrapper {
    #[classattr]
    const Alias: AzStyleCursor = AzStyleCursor::Alias;
    #[classattr]
    const AllScroll: AzStyleCursor = AzStyleCursor::AllScroll;
    #[classattr]
    const Cell: AzStyleCursor = AzStyleCursor::Cell;
    #[classattr]
    const ColResize: AzStyleCursor = AzStyleCursor::ColResize;
    #[classattr]
    const ContextMenu: AzStyleCursor = AzStyleCursor::ContextMenu;
    #[classattr]
    const Copy: AzStyleCursor = AzStyleCursor::Copy;
    #[classattr]
    const Crosshair: AzStyleCursor = AzStyleCursor::Crosshair;
    #[classattr]
    const Default: AzStyleCursor = AzStyleCursor::Default;
    #[classattr]
    const EResize: AzStyleCursor = AzStyleCursor::EResize;
    #[classattr]
    const EwResize: AzStyleCursor = AzStyleCursor::EwResize;
    #[classattr]
    const Grab: AzStyleCursor = AzStyleCursor::Grab;
    #[classattr]
    const Grabbing: AzStyleCursor = AzStyleCursor::Grabbing;
    #[classattr]
    const Help: AzStyleCursor = AzStyleCursor::Help;
    #[classattr]
    const Move: AzStyleCursor = AzStyleCursor::Move;
    #[classattr]
    const NResize: AzStyleCursor = AzStyleCursor::NResize;
    #[classattr]
    const NsResize: AzStyleCursor = AzStyleCursor::NsResize;
    #[classattr]
    const NeswResize: AzStyleCursor = AzStyleCursor::NeswResize;
    #[classattr]
    const NwseResize: AzStyleCursor = AzStyleCursor::NwseResize;
    #[classattr]
    const Pointer: AzStyleCursor = AzStyleCursor::Pointer;
    #[classattr]
    const Progress: AzStyleCursor = AzStyleCursor::Progress;
    #[classattr]
    const RowResize: AzStyleCursor = AzStyleCursor::RowResize;
    #[classattr]
    const SResize: AzStyleCursor = AzStyleCursor::SResize;
    #[classattr]
    const SeResize: AzStyleCursor = AzStyleCursor::SeResize;
    #[classattr]
    const Text: AzStyleCursor = AzStyleCursor::Text;
    #[classattr]
    const Unset: AzStyleCursor = AzStyleCursor::Unset;
    #[classattr]
    const VerticalText: AzStyleCursor = AzStyleCursor::VerticalText;
    #[classattr]
    const WResize: AzStyleCursor = AzStyleCursor::WResize;
    #[classattr]
    const Wait: AzStyleCursor = AzStyleCursor::Wait;
    #[classattr]
    const ZoomIn: AzStyleCursor = AzStyleCursor::ZoomIn;
    #[classattr]
    const ZoomOut: AzStyleCursor = AzStyleCursor::ZoomOut;
}

#[pyproto]
impl PyObjectProtocol for AzStyleCursorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::effects::StyleCursor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::effects::StyleCursor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleCursorEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleFontFamilyEnumWrapper {
    #[staticmethod]
    fn System(v: AzString) -> AzStyleFontFamilyEnumWrapper {
        AzStyleFontFamilyEnumWrapper { inner: AzStyleFontFamily::System(v) }}
    }
    #[staticmethod]
    fn File(v: AzString) -> AzStyleFontFamilyEnumWrapper {
        AzStyleFontFamilyEnumWrapper { inner: AzStyleFontFamily::File(v) }}
    }
    #[staticmethod]
    fn Ref(v: FontRef) -> AzStyleFontFamilyEnumWrapper {
        AzStyleFontFamilyEnumWrapper { inner: AzStyleFontFamily::Ref(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleFontFamily;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFontFamily::System(v) => Ok(vec!["System".into_py(py), v.into_py(py)]),
            AzStyleFontFamily::File(v) => Ok(vec!["File".into_py(py), v.into_py(py)]),
            AzStyleFontFamily::Ref(v) => Ok(vec!["Ref".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontFamilyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontFamily = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontFamily = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontSize {
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontSize {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleLetterSpacing {
}

#[pyproto]
impl PyObjectProtocol for AzStyleLetterSpacing {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleLetterSpacing = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleLetterSpacing = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleLineHeight {
}

#[pyproto]
impl PyObjectProtocol for AzStyleLineHeight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleLineHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleLineHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTabWidth {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTabWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTabWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTabWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleOpacity {
}

#[pyproto]
impl PyObjectProtocol for AzStyleOpacity {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::effects::StyleOpacity = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::effects::StyleOpacity = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformOrigin {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformOrigin {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformOrigin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformOrigin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInterpolateResolver {
}

#[pyproto]
impl PyObjectProtocol for AzInterpolateResolver {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::InterpolateResolver = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::InterpolateResolver = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackfaceVisibilityEnumWrapper {
    #[classattr]
    const Visible: AzStyleBackfaceVisibility = AzStyleBackfaceVisibility::Visible;
    #[classattr]
    const Hidden: AzStyleBackfaceVisibility = AzStyleBackfaceVisibility::Hidden;
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackfaceVisibilityEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleBackfaceVisibility = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleBackfaceVisibility = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleBackfaceVisibilityEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleTransformEnumWrapper {
    #[staticmethod]
    fn Matrix(v: StyleTransformMatrix2D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Matrix(v) }}
    }
    #[staticmethod]
    fn Matrix3D(v: StyleTransformMatrix3D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Matrix3D(v) }}
    }
    #[staticmethod]
    fn Translate(v: StyleTransformTranslate2D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Translate(v) }}
    }
    #[staticmethod]
    fn Translate3D(v: StyleTransformTranslate3D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Translate3D(v) }}
    }
    #[staticmethod]
    fn TranslateX(v: PixelValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::TranslateX(v) }}
    }
    #[staticmethod]
    fn TranslateY(v: PixelValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::TranslateY(v) }}
    }
    #[staticmethod]
    fn TranslateZ(v: PixelValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::TranslateZ(v) }}
    }
    #[staticmethod]
    fn Rotate(v: AngleValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Rotate(v) }}
    }
    #[staticmethod]
    fn Rotate3D(v: StyleTransformRotate3D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Rotate3D(v) }}
    }
    #[staticmethod]
    fn RotateX(v: AngleValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::RotateX(v) }}
    }
    #[staticmethod]
    fn RotateY(v: AngleValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::RotateY(v) }}
    }
    #[staticmethod]
    fn RotateZ(v: AngleValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::RotateZ(v) }}
    }
    #[staticmethod]
    fn Scale(v: StyleTransformScale2D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Scale(v) }}
    }
    #[staticmethod]
    fn Scale3D(v: StyleTransformScale3D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Scale3D(v) }}
    }
    #[staticmethod]
    fn ScaleX(v: PercentageValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::ScaleX(v) }}
    }
    #[staticmethod]
    fn ScaleY(v: PercentageValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::ScaleY(v) }}
    }
    #[staticmethod]
    fn ScaleZ(v: PercentageValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::ScaleZ(v) }}
    }
    #[staticmethod]
    fn Skew(v: StyleTransformSkew2D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Skew(v) }}
    }
    #[staticmethod]
    fn SkewX(v: AngleValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::SkewX(v) }}
    }
    #[staticmethod]
    fn SkewY(v: AngleValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::SkewY(v) }}
    }
    #[staticmethod]
    fn Perspective(v: PixelValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Perspective(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTransform;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTransform::Matrix(v) => Ok(vec!["Matrix".into_py(py), v.into_py(py)]),
            AzStyleTransform::Matrix3D(v) => Ok(vec!["Matrix3D".into_py(py), v.into_py(py)]),
            AzStyleTransform::Translate(v) => Ok(vec!["Translate".into_py(py), v.into_py(py)]),
            AzStyleTransform::Translate3D(v) => Ok(vec!["Translate3D".into_py(py), v.into_py(py)]),
            AzStyleTransform::TranslateX(v) => Ok(vec!["TranslateX".into_py(py), v.into_py(py)]),
            AzStyleTransform::TranslateY(v) => Ok(vec!["TranslateY".into_py(py), v.into_py(py)]),
            AzStyleTransform::TranslateZ(v) => Ok(vec!["TranslateZ".into_py(py), v.into_py(py)]),
            AzStyleTransform::Rotate(v) => Ok(vec!["Rotate".into_py(py), v.into_py(py)]),
            AzStyleTransform::Rotate3D(v) => Ok(vec!["Rotate3D".into_py(py), v.into_py(py)]),
            AzStyleTransform::RotateX(v) => Ok(vec!["RotateX".into_py(py), v.into_py(py)]),
            AzStyleTransform::RotateY(v) => Ok(vec!["RotateY".into_py(py), v.into_py(py)]),
            AzStyleTransform::RotateZ(v) => Ok(vec!["RotateZ".into_py(py), v.into_py(py)]),
            AzStyleTransform::Scale(v) => Ok(vec!["Scale".into_py(py), v.into_py(py)]),
            AzStyleTransform::Scale3D(v) => Ok(vec!["Scale3D".into_py(py), v.into_py(py)]),
            AzStyleTransform::ScaleX(v) => Ok(vec!["ScaleX".into_py(py), v.into_py(py)]),
            AzStyleTransform::ScaleY(v) => Ok(vec!["ScaleY".into_py(py), v.into_py(py)]),
            AzStyleTransform::ScaleZ(v) => Ok(vec!["ScaleZ".into_py(py), v.into_py(py)]),
            AzStyleTransform::Skew(v) => Ok(vec!["Skew".into_py(py), v.into_py(py)]),
            AzStyleTransform::SkewX(v) => Ok(vec!["SkewX".into_py(py), v.into_py(py)]),
            AzStyleTransform::SkewY(v) => Ok(vec!["SkewY".into_py(py), v.into_py(py)]),
            AzStyleTransform::Perspective(v) => Ok(vec!["Perspective".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransform = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransform = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformMatrix2D {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformMatrix2D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformMatrix2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformMatrix2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformMatrix3D {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformMatrix3D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformMatrix3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformMatrix3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformTranslate2D {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformTranslate2D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformTranslate2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformTranslate2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformTranslate3D {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformTranslate3D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformTranslate3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformTranslate3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformRotate3D {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformRotate3D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformRotate3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformRotate3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformScale2D {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformScale2D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformScale2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformScale2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformScale3D {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformScale3D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformScale3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformScale3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformSkew2D {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformSkew2D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformSkew2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformSkew2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTextAlignEnumWrapper {
    #[classattr]
    const Left: AzStyleTextAlign = AzStyleTextAlign::Left;
    #[classattr]
    const Center: AzStyleTextAlign = AzStyleTextAlign::Center;
    #[classattr]
    const Right: AzStyleTextAlign = AzStyleTextAlign::Right;
    #[classattr]
    const Justify: AzStyleTextAlign = AzStyleTextAlign::Justify;
    #[classattr]
    const Start: AzStyleTextAlign = AzStyleTextAlign::Start;
    #[classattr]
    const End: AzStyleTextAlign = AzStyleTextAlign::End;
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextAlignEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTextAlign = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTextAlign = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleTextAlignEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleTextColor {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTextColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTextColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleWordSpacing {
}

#[pyproto]
impl PyObjectProtocol for AzStyleWordSpacing {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleWordSpacing = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleWordSpacing = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBoxShadowValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBoxShadowValueEnumWrapper {
        AzStyleBoxShadowValueEnumWrapper { inner: AzStyleBoxShadowValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBoxShadowValueEnumWrapper {
        AzStyleBoxShadowValueEnumWrapper { inner: AzStyleBoxShadowValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBoxShadowValueEnumWrapper {
        AzStyleBoxShadowValueEnumWrapper { inner: AzStyleBoxShadowValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBoxShadowValueEnumWrapper {
        AzStyleBoxShadowValueEnumWrapper { inner: AzStyleBoxShadowValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBoxShadow) -> AzStyleBoxShadowValueEnumWrapper {
        AzStyleBoxShadowValueEnumWrapper { inner: AzStyleBoxShadowValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBoxShadowValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBoxShadowValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBoxShadowValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBoxShadowValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBoxShadowValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBoxShadowValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBoxShadowValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBoxShadowValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBoxShadowValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutAlignContentValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutAlignContentValueEnumWrapper {
        AzLayoutAlignContentValueEnumWrapper { inner: AzLayoutAlignContentValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutAlignContentValueEnumWrapper {
        AzLayoutAlignContentValueEnumWrapper { inner: AzLayoutAlignContentValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutAlignContentValueEnumWrapper {
        AzLayoutAlignContentValueEnumWrapper { inner: AzLayoutAlignContentValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutAlignContentValueEnumWrapper {
        AzLayoutAlignContentValueEnumWrapper { inner: AzLayoutAlignContentValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutAlignContent) -> AzLayoutAlignContentValueEnumWrapper {
        AzLayoutAlignContentValueEnumWrapper { inner: AzLayoutAlignContentValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutAlignContentValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutAlignContentValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutAlignContentValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutAlignContentValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutAlignContentValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutAlignContentValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutAlignContentValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutAlignContentValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutAlignContentValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutAlignItemsValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutAlignItemsValueEnumWrapper {
        AzLayoutAlignItemsValueEnumWrapper { inner: AzLayoutAlignItemsValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutAlignItemsValueEnumWrapper {
        AzLayoutAlignItemsValueEnumWrapper { inner: AzLayoutAlignItemsValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutAlignItemsValueEnumWrapper {
        AzLayoutAlignItemsValueEnumWrapper { inner: AzLayoutAlignItemsValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutAlignItemsValueEnumWrapper {
        AzLayoutAlignItemsValueEnumWrapper { inner: AzLayoutAlignItemsValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutAlignItems) -> AzLayoutAlignItemsValueEnumWrapper {
        AzLayoutAlignItemsValueEnumWrapper { inner: AzLayoutAlignItemsValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutAlignItemsValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutAlignItemsValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutAlignItemsValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutAlignItemsValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutAlignItemsValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutAlignItemsValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutAlignItemsValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutAlignItemsValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutAlignItemsValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBottomValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBottomValueEnumWrapper {
        AzLayoutBottomValueEnumWrapper { inner: AzLayoutBottomValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutBottomValueEnumWrapper {
        AzLayoutBottomValueEnumWrapper { inner: AzLayoutBottomValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutBottomValueEnumWrapper {
        AzLayoutBottomValueEnumWrapper { inner: AzLayoutBottomValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutBottomValueEnumWrapper {
        AzLayoutBottomValueEnumWrapper { inner: AzLayoutBottomValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutBottom) -> AzLayoutBottomValueEnumWrapper {
        AzLayoutBottomValueEnumWrapper { inner: AzLayoutBottomValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutBottomValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBottomValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBottomValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBottomValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutBottomValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutBottomValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBottomValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutBottomValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutBottomValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBoxSizingValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBoxSizingValueEnumWrapper {
        AzLayoutBoxSizingValueEnumWrapper { inner: AzLayoutBoxSizingValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutBoxSizingValueEnumWrapper {
        AzLayoutBoxSizingValueEnumWrapper { inner: AzLayoutBoxSizingValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutBoxSizingValueEnumWrapper {
        AzLayoutBoxSizingValueEnumWrapper { inner: AzLayoutBoxSizingValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutBoxSizingValueEnumWrapper {
        AzLayoutBoxSizingValueEnumWrapper { inner: AzLayoutBoxSizingValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutBoxSizing) -> AzLayoutBoxSizingValueEnumWrapper {
        AzLayoutBoxSizingValueEnumWrapper { inner: AzLayoutBoxSizingValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutBoxSizingValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBoxSizingValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBoxSizingValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBoxSizingValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutBoxSizingValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutBoxSizingValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBoxSizingValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutBoxSizingValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutBoxSizingValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexDirectionValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFlexDirectionValueEnumWrapper {
        AzLayoutFlexDirectionValueEnumWrapper { inner: AzLayoutFlexDirectionValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutFlexDirectionValueEnumWrapper {
        AzLayoutFlexDirectionValueEnumWrapper { inner: AzLayoutFlexDirectionValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutFlexDirectionValueEnumWrapper {
        AzLayoutFlexDirectionValueEnumWrapper { inner: AzLayoutFlexDirectionValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutFlexDirectionValueEnumWrapper {
        AzLayoutFlexDirectionValueEnumWrapper { inner: AzLayoutFlexDirectionValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutFlexDirection) -> AzLayoutFlexDirectionValueEnumWrapper {
        AzLayoutFlexDirectionValueEnumWrapper { inner: AzLayoutFlexDirectionValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutFlexDirectionValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFlexDirectionValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFlexDirectionValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutFlexDirectionValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutFlexDirectionValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutFlexDirectionValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexDirectionValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutFlexDirectionValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutFlexDirectionValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutDisplayValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutDisplayValueEnumWrapper {
        AzLayoutDisplayValueEnumWrapper { inner: AzLayoutDisplayValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutDisplayValueEnumWrapper {
        AzLayoutDisplayValueEnumWrapper { inner: AzLayoutDisplayValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutDisplayValueEnumWrapper {
        AzLayoutDisplayValueEnumWrapper { inner: AzLayoutDisplayValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutDisplayValueEnumWrapper {
        AzLayoutDisplayValueEnumWrapper { inner: AzLayoutDisplayValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutDisplay) -> AzLayoutDisplayValueEnumWrapper {
        AzLayoutDisplayValueEnumWrapper { inner: AzLayoutDisplayValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutDisplayValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutDisplayValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutDisplayValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutDisplayValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutDisplayValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutDisplayValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutDisplayValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutDisplayValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutDisplayValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexGrowValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFlexGrowValueEnumWrapper {
        AzLayoutFlexGrowValueEnumWrapper { inner: AzLayoutFlexGrowValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutFlexGrowValueEnumWrapper {
        AzLayoutFlexGrowValueEnumWrapper { inner: AzLayoutFlexGrowValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutFlexGrowValueEnumWrapper {
        AzLayoutFlexGrowValueEnumWrapper { inner: AzLayoutFlexGrowValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutFlexGrowValueEnumWrapper {
        AzLayoutFlexGrowValueEnumWrapper { inner: AzLayoutFlexGrowValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutFlexGrow) -> AzLayoutFlexGrowValueEnumWrapper {
        AzLayoutFlexGrowValueEnumWrapper { inner: AzLayoutFlexGrowValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutFlexGrowValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFlexGrowValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFlexGrowValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutFlexGrowValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutFlexGrowValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutFlexGrowValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexGrowValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutFlexGrowValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutFlexGrowValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexShrinkValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFlexShrinkValueEnumWrapper {
        AzLayoutFlexShrinkValueEnumWrapper { inner: AzLayoutFlexShrinkValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutFlexShrinkValueEnumWrapper {
        AzLayoutFlexShrinkValueEnumWrapper { inner: AzLayoutFlexShrinkValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutFlexShrinkValueEnumWrapper {
        AzLayoutFlexShrinkValueEnumWrapper { inner: AzLayoutFlexShrinkValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutFlexShrinkValueEnumWrapper {
        AzLayoutFlexShrinkValueEnumWrapper { inner: AzLayoutFlexShrinkValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutFlexShrink) -> AzLayoutFlexShrinkValueEnumWrapper {
        AzLayoutFlexShrinkValueEnumWrapper { inner: AzLayoutFlexShrinkValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutFlexShrinkValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFlexShrinkValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFlexShrinkValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutFlexShrinkValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutFlexShrinkValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutFlexShrinkValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexShrinkValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutFlexShrinkValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutFlexShrinkValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFloatValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFloatValueEnumWrapper {
        AzLayoutFloatValueEnumWrapper { inner: AzLayoutFloatValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutFloatValueEnumWrapper {
        AzLayoutFloatValueEnumWrapper { inner: AzLayoutFloatValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutFloatValueEnumWrapper {
        AzLayoutFloatValueEnumWrapper { inner: AzLayoutFloatValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutFloatValueEnumWrapper {
        AzLayoutFloatValueEnumWrapper { inner: AzLayoutFloatValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutFloat) -> AzLayoutFloatValueEnumWrapper {
        AzLayoutFloatValueEnumWrapper { inner: AzLayoutFloatValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutFloatValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFloatValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFloatValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutFloatValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutFloatValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutFloatValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFloatValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutFloatValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutFloatValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutHeightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutHeightValueEnumWrapper {
        AzLayoutHeightValueEnumWrapper { inner: AzLayoutHeightValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutHeightValueEnumWrapper {
        AzLayoutHeightValueEnumWrapper { inner: AzLayoutHeightValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutHeightValueEnumWrapper {
        AzLayoutHeightValueEnumWrapper { inner: AzLayoutHeightValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutHeightValueEnumWrapper {
        AzLayoutHeightValueEnumWrapper { inner: AzLayoutHeightValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutHeight) -> AzLayoutHeightValueEnumWrapper {
        AzLayoutHeightValueEnumWrapper { inner: AzLayoutHeightValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutHeightValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutHeightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutHeightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutHeightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutHeightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutHeightValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutHeightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutHeightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutHeightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutJustifyContentValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutJustifyContentValueEnumWrapper {
        AzLayoutJustifyContentValueEnumWrapper { inner: AzLayoutJustifyContentValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutJustifyContentValueEnumWrapper {
        AzLayoutJustifyContentValueEnumWrapper { inner: AzLayoutJustifyContentValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutJustifyContentValueEnumWrapper {
        AzLayoutJustifyContentValueEnumWrapper { inner: AzLayoutJustifyContentValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutJustifyContentValueEnumWrapper {
        AzLayoutJustifyContentValueEnumWrapper { inner: AzLayoutJustifyContentValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutJustifyContent) -> AzLayoutJustifyContentValueEnumWrapper {
        AzLayoutJustifyContentValueEnumWrapper { inner: AzLayoutJustifyContentValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutJustifyContentValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutJustifyContentValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutJustifyContentValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutJustifyContentValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutJustifyContentValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutJustifyContentValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutJustifyContentValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutJustifyContentValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutJustifyContentValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutLeftValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutLeftValueEnumWrapper {
        AzLayoutLeftValueEnumWrapper { inner: AzLayoutLeftValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutLeftValueEnumWrapper {
        AzLayoutLeftValueEnumWrapper { inner: AzLayoutLeftValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutLeftValueEnumWrapper {
        AzLayoutLeftValueEnumWrapper { inner: AzLayoutLeftValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutLeftValueEnumWrapper {
        AzLayoutLeftValueEnumWrapper { inner: AzLayoutLeftValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutLeft) -> AzLayoutLeftValueEnumWrapper {
        AzLayoutLeftValueEnumWrapper { inner: AzLayoutLeftValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutLeftValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutLeftValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutLeftValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutLeftValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutLeftValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutLeftValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutLeftValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutLeftValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutLeftValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginBottomValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMarginBottomValueEnumWrapper {
        AzLayoutMarginBottomValueEnumWrapper { inner: AzLayoutMarginBottomValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutMarginBottomValueEnumWrapper {
        AzLayoutMarginBottomValueEnumWrapper { inner: AzLayoutMarginBottomValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutMarginBottomValueEnumWrapper {
        AzLayoutMarginBottomValueEnumWrapper { inner: AzLayoutMarginBottomValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutMarginBottomValueEnumWrapper {
        AzLayoutMarginBottomValueEnumWrapper { inner: AzLayoutMarginBottomValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutMarginBottom) -> AzLayoutMarginBottomValueEnumWrapper {
        AzLayoutMarginBottomValueEnumWrapper { inner: AzLayoutMarginBottomValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutMarginBottomValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMarginBottomValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMarginBottomValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMarginBottomValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMarginBottomValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMarginBottomValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginBottomValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutMarginBottomValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutMarginBottomValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginLeftValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMarginLeftValueEnumWrapper {
        AzLayoutMarginLeftValueEnumWrapper { inner: AzLayoutMarginLeftValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutMarginLeftValueEnumWrapper {
        AzLayoutMarginLeftValueEnumWrapper { inner: AzLayoutMarginLeftValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutMarginLeftValueEnumWrapper {
        AzLayoutMarginLeftValueEnumWrapper { inner: AzLayoutMarginLeftValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutMarginLeftValueEnumWrapper {
        AzLayoutMarginLeftValueEnumWrapper { inner: AzLayoutMarginLeftValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutMarginLeft) -> AzLayoutMarginLeftValueEnumWrapper {
        AzLayoutMarginLeftValueEnumWrapper { inner: AzLayoutMarginLeftValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutMarginLeftValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMarginLeftValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMarginLeftValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMarginLeftValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMarginLeftValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMarginLeftValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginLeftValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutMarginLeftValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutMarginLeftValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginRightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMarginRightValueEnumWrapper {
        AzLayoutMarginRightValueEnumWrapper { inner: AzLayoutMarginRightValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutMarginRightValueEnumWrapper {
        AzLayoutMarginRightValueEnumWrapper { inner: AzLayoutMarginRightValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutMarginRightValueEnumWrapper {
        AzLayoutMarginRightValueEnumWrapper { inner: AzLayoutMarginRightValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutMarginRightValueEnumWrapper {
        AzLayoutMarginRightValueEnumWrapper { inner: AzLayoutMarginRightValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutMarginRight) -> AzLayoutMarginRightValueEnumWrapper {
        AzLayoutMarginRightValueEnumWrapper { inner: AzLayoutMarginRightValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutMarginRightValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMarginRightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMarginRightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMarginRightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMarginRightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMarginRightValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginRightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutMarginRightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutMarginRightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginTopValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMarginTopValueEnumWrapper {
        AzLayoutMarginTopValueEnumWrapper { inner: AzLayoutMarginTopValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutMarginTopValueEnumWrapper {
        AzLayoutMarginTopValueEnumWrapper { inner: AzLayoutMarginTopValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutMarginTopValueEnumWrapper {
        AzLayoutMarginTopValueEnumWrapper { inner: AzLayoutMarginTopValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutMarginTopValueEnumWrapper {
        AzLayoutMarginTopValueEnumWrapper { inner: AzLayoutMarginTopValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutMarginTop) -> AzLayoutMarginTopValueEnumWrapper {
        AzLayoutMarginTopValueEnumWrapper { inner: AzLayoutMarginTopValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutMarginTopValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMarginTopValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMarginTopValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMarginTopValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMarginTopValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMarginTopValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginTopValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutMarginTopValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutMarginTopValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMaxHeightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMaxHeightValueEnumWrapper {
        AzLayoutMaxHeightValueEnumWrapper { inner: AzLayoutMaxHeightValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutMaxHeightValueEnumWrapper {
        AzLayoutMaxHeightValueEnumWrapper { inner: AzLayoutMaxHeightValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutMaxHeightValueEnumWrapper {
        AzLayoutMaxHeightValueEnumWrapper { inner: AzLayoutMaxHeightValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutMaxHeightValueEnumWrapper {
        AzLayoutMaxHeightValueEnumWrapper { inner: AzLayoutMaxHeightValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutMaxHeight) -> AzLayoutMaxHeightValueEnumWrapper {
        AzLayoutMaxHeightValueEnumWrapper { inner: AzLayoutMaxHeightValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutMaxHeightValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMaxHeightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMaxHeightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMaxHeightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMaxHeightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMaxHeightValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMaxHeightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutMaxHeightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutMaxHeightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMaxWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMaxWidthValueEnumWrapper {
        AzLayoutMaxWidthValueEnumWrapper { inner: AzLayoutMaxWidthValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutMaxWidthValueEnumWrapper {
        AzLayoutMaxWidthValueEnumWrapper { inner: AzLayoutMaxWidthValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutMaxWidthValueEnumWrapper {
        AzLayoutMaxWidthValueEnumWrapper { inner: AzLayoutMaxWidthValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutMaxWidthValueEnumWrapper {
        AzLayoutMaxWidthValueEnumWrapper { inner: AzLayoutMaxWidthValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutMaxWidth) -> AzLayoutMaxWidthValueEnumWrapper {
        AzLayoutMaxWidthValueEnumWrapper { inner: AzLayoutMaxWidthValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutMaxWidthValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMaxWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMaxWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMaxWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMaxWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMaxWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMaxWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutMaxWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutMaxWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMinHeightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMinHeightValueEnumWrapper {
        AzLayoutMinHeightValueEnumWrapper { inner: AzLayoutMinHeightValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutMinHeightValueEnumWrapper {
        AzLayoutMinHeightValueEnumWrapper { inner: AzLayoutMinHeightValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutMinHeightValueEnumWrapper {
        AzLayoutMinHeightValueEnumWrapper { inner: AzLayoutMinHeightValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutMinHeightValueEnumWrapper {
        AzLayoutMinHeightValueEnumWrapper { inner: AzLayoutMinHeightValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutMinHeight) -> AzLayoutMinHeightValueEnumWrapper {
        AzLayoutMinHeightValueEnumWrapper { inner: AzLayoutMinHeightValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutMinHeightValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMinHeightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMinHeightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMinHeightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMinHeightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMinHeightValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMinHeightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutMinHeightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutMinHeightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMinWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMinWidthValueEnumWrapper {
        AzLayoutMinWidthValueEnumWrapper { inner: AzLayoutMinWidthValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutMinWidthValueEnumWrapper {
        AzLayoutMinWidthValueEnumWrapper { inner: AzLayoutMinWidthValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutMinWidthValueEnumWrapper {
        AzLayoutMinWidthValueEnumWrapper { inner: AzLayoutMinWidthValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutMinWidthValueEnumWrapper {
        AzLayoutMinWidthValueEnumWrapper { inner: AzLayoutMinWidthValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutMinWidth) -> AzLayoutMinWidthValueEnumWrapper {
        AzLayoutMinWidthValueEnumWrapper { inner: AzLayoutMinWidthValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutMinWidthValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMinWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMinWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMinWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMinWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMinWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMinWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutMinWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutMinWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingBottomValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutPaddingBottomValueEnumWrapper {
        AzLayoutPaddingBottomValueEnumWrapper { inner: AzLayoutPaddingBottomValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutPaddingBottomValueEnumWrapper {
        AzLayoutPaddingBottomValueEnumWrapper { inner: AzLayoutPaddingBottomValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutPaddingBottomValueEnumWrapper {
        AzLayoutPaddingBottomValueEnumWrapper { inner: AzLayoutPaddingBottomValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutPaddingBottomValueEnumWrapper {
        AzLayoutPaddingBottomValueEnumWrapper { inner: AzLayoutPaddingBottomValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutPaddingBottom) -> AzLayoutPaddingBottomValueEnumWrapper {
        AzLayoutPaddingBottomValueEnumWrapper { inner: AzLayoutPaddingBottomValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutPaddingBottomValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutPaddingBottomValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutPaddingBottomValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutPaddingBottomValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutPaddingBottomValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutPaddingBottomValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingBottomValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutPaddingBottomValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutPaddingBottomValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingLeftValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutPaddingLeftValueEnumWrapper {
        AzLayoutPaddingLeftValueEnumWrapper { inner: AzLayoutPaddingLeftValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutPaddingLeftValueEnumWrapper {
        AzLayoutPaddingLeftValueEnumWrapper { inner: AzLayoutPaddingLeftValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutPaddingLeftValueEnumWrapper {
        AzLayoutPaddingLeftValueEnumWrapper { inner: AzLayoutPaddingLeftValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutPaddingLeftValueEnumWrapper {
        AzLayoutPaddingLeftValueEnumWrapper { inner: AzLayoutPaddingLeftValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutPaddingLeft) -> AzLayoutPaddingLeftValueEnumWrapper {
        AzLayoutPaddingLeftValueEnumWrapper { inner: AzLayoutPaddingLeftValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutPaddingLeftValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutPaddingLeftValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutPaddingLeftValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutPaddingLeftValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutPaddingLeftValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutPaddingLeftValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingLeftValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutPaddingLeftValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutPaddingLeftValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingRightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutPaddingRightValueEnumWrapper {
        AzLayoutPaddingRightValueEnumWrapper { inner: AzLayoutPaddingRightValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutPaddingRightValueEnumWrapper {
        AzLayoutPaddingRightValueEnumWrapper { inner: AzLayoutPaddingRightValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutPaddingRightValueEnumWrapper {
        AzLayoutPaddingRightValueEnumWrapper { inner: AzLayoutPaddingRightValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutPaddingRightValueEnumWrapper {
        AzLayoutPaddingRightValueEnumWrapper { inner: AzLayoutPaddingRightValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutPaddingRight) -> AzLayoutPaddingRightValueEnumWrapper {
        AzLayoutPaddingRightValueEnumWrapper { inner: AzLayoutPaddingRightValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutPaddingRightValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutPaddingRightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutPaddingRightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutPaddingRightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutPaddingRightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutPaddingRightValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingRightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutPaddingRightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutPaddingRightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingTopValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutPaddingTopValueEnumWrapper {
        AzLayoutPaddingTopValueEnumWrapper { inner: AzLayoutPaddingTopValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutPaddingTopValueEnumWrapper {
        AzLayoutPaddingTopValueEnumWrapper { inner: AzLayoutPaddingTopValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutPaddingTopValueEnumWrapper {
        AzLayoutPaddingTopValueEnumWrapper { inner: AzLayoutPaddingTopValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutPaddingTopValueEnumWrapper {
        AzLayoutPaddingTopValueEnumWrapper { inner: AzLayoutPaddingTopValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutPaddingTop) -> AzLayoutPaddingTopValueEnumWrapper {
        AzLayoutPaddingTopValueEnumWrapper { inner: AzLayoutPaddingTopValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutPaddingTopValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutPaddingTopValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutPaddingTopValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutPaddingTopValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutPaddingTopValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutPaddingTopValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingTopValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutPaddingTopValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutPaddingTopValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPositionValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutPositionValueEnumWrapper {
        AzLayoutPositionValueEnumWrapper { inner: AzLayoutPositionValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutPositionValueEnumWrapper {
        AzLayoutPositionValueEnumWrapper { inner: AzLayoutPositionValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutPositionValueEnumWrapper {
        AzLayoutPositionValueEnumWrapper { inner: AzLayoutPositionValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutPositionValueEnumWrapper {
        AzLayoutPositionValueEnumWrapper { inner: AzLayoutPositionValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutPosition) -> AzLayoutPositionValueEnumWrapper {
        AzLayoutPositionValueEnumWrapper { inner: AzLayoutPositionValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutPositionValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutPositionValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutPositionValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutPositionValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutPositionValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutPositionValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPositionValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutPositionValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutPositionValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutRightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutRightValueEnumWrapper {
        AzLayoutRightValueEnumWrapper { inner: AzLayoutRightValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutRightValueEnumWrapper {
        AzLayoutRightValueEnumWrapper { inner: AzLayoutRightValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutRightValueEnumWrapper {
        AzLayoutRightValueEnumWrapper { inner: AzLayoutRightValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutRightValueEnumWrapper {
        AzLayoutRightValueEnumWrapper { inner: AzLayoutRightValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutRight) -> AzLayoutRightValueEnumWrapper {
        AzLayoutRightValueEnumWrapper { inner: AzLayoutRightValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutRightValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutRightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutRightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutRightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutRightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutRightValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutRightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutRightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutRightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutTopValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutTopValueEnumWrapper {
        AzLayoutTopValueEnumWrapper { inner: AzLayoutTopValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutTopValueEnumWrapper {
        AzLayoutTopValueEnumWrapper { inner: AzLayoutTopValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutTopValueEnumWrapper {
        AzLayoutTopValueEnumWrapper { inner: AzLayoutTopValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutTopValueEnumWrapper {
        AzLayoutTopValueEnumWrapper { inner: AzLayoutTopValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutTop) -> AzLayoutTopValueEnumWrapper {
        AzLayoutTopValueEnumWrapper { inner: AzLayoutTopValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutTopValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutTopValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutTopValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutTopValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutTopValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutTopValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutTopValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutTopValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutTopValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutWidthValueEnumWrapper {
        AzLayoutWidthValueEnumWrapper { inner: AzLayoutWidthValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutWidthValueEnumWrapper {
        AzLayoutWidthValueEnumWrapper { inner: AzLayoutWidthValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutWidthValueEnumWrapper {
        AzLayoutWidthValueEnumWrapper { inner: AzLayoutWidthValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutWidthValueEnumWrapper {
        AzLayoutWidthValueEnumWrapper { inner: AzLayoutWidthValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutWidth) -> AzLayoutWidthValueEnumWrapper {
        AzLayoutWidthValueEnumWrapper { inner: AzLayoutWidthValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutWidthValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexWrapValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFlexWrapValueEnumWrapper {
        AzLayoutFlexWrapValueEnumWrapper { inner: AzLayoutFlexWrapValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutFlexWrapValueEnumWrapper {
        AzLayoutFlexWrapValueEnumWrapper { inner: AzLayoutFlexWrapValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutFlexWrapValueEnumWrapper {
        AzLayoutFlexWrapValueEnumWrapper { inner: AzLayoutFlexWrapValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutFlexWrapValueEnumWrapper {
        AzLayoutFlexWrapValueEnumWrapper { inner: AzLayoutFlexWrapValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutFlexWrap) -> AzLayoutFlexWrapValueEnumWrapper {
        AzLayoutFlexWrapValueEnumWrapper { inner: AzLayoutFlexWrapValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutFlexWrapValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFlexWrapValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFlexWrapValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutFlexWrapValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutFlexWrapValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutFlexWrapValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexWrapValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutFlexWrapValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutFlexWrapValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutOverflowValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutOverflowValueEnumWrapper {
        AzLayoutOverflowValueEnumWrapper { inner: AzLayoutOverflowValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutOverflowValueEnumWrapper {
        AzLayoutOverflowValueEnumWrapper { inner: AzLayoutOverflowValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutOverflowValueEnumWrapper {
        AzLayoutOverflowValueEnumWrapper { inner: AzLayoutOverflowValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutOverflowValueEnumWrapper {
        AzLayoutOverflowValueEnumWrapper { inner: AzLayoutOverflowValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutOverflow) -> AzLayoutOverflowValueEnumWrapper {
        AzLayoutOverflowValueEnumWrapper { inner: AzLayoutOverflowValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutOverflowValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutOverflowValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutOverflowValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutOverflowValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutOverflowValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutOverflowValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutOverflowValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutOverflowValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutOverflowValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScrollbarStyleValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzScrollbarStyleValueEnumWrapper {
        AzScrollbarStyleValueEnumWrapper { inner: AzScrollbarStyleValue::Auto }
    }
    #[classattr]
    fn None() -> AzScrollbarStyleValueEnumWrapper {
        AzScrollbarStyleValueEnumWrapper { inner: AzScrollbarStyleValue::None }
    }
    #[classattr]
    fn Inherit() -> AzScrollbarStyleValueEnumWrapper {
        AzScrollbarStyleValueEnumWrapper { inner: AzScrollbarStyleValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzScrollbarStyleValueEnumWrapper {
        AzScrollbarStyleValueEnumWrapper { inner: AzScrollbarStyleValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: ScrollbarStyle) -> AzScrollbarStyleValueEnumWrapper {
        AzScrollbarStyleValueEnumWrapper { inner: AzScrollbarStyleValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzScrollbarStyleValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzScrollbarStyleValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzScrollbarStyleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzScrollbarStyleValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzScrollbarStyleValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzScrollbarStyleValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzScrollbarStyleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::ScrollbarStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::ScrollbarStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundContentVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBackgroundContentVecValueEnumWrapper {
        AzStyleBackgroundContentVecValueEnumWrapper { inner: AzStyleBackgroundContentVecValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBackgroundContentVecValueEnumWrapper {
        AzStyleBackgroundContentVecValueEnumWrapper { inner: AzStyleBackgroundContentVecValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBackgroundContentVecValueEnumWrapper {
        AzStyleBackgroundContentVecValueEnumWrapper { inner: AzStyleBackgroundContentVecValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBackgroundContentVecValueEnumWrapper {
        AzStyleBackgroundContentVecValueEnumWrapper { inner: AzStyleBackgroundContentVecValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBackgroundContentVec) -> AzStyleBackgroundContentVecValueEnumWrapper {
        AzStyleBackgroundContentVecValueEnumWrapper { inner: AzStyleBackgroundContentVecValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundContentVecValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundContentVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBackgroundContentVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBackgroundContentVecValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBackgroundContentVecValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBackgroundContentVecValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundContentVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBackgroundContentVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBackgroundContentVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundPositionVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBackgroundPositionVecValueEnumWrapper {
        AzStyleBackgroundPositionVecValueEnumWrapper { inner: AzStyleBackgroundPositionVecValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBackgroundPositionVecValueEnumWrapper {
        AzStyleBackgroundPositionVecValueEnumWrapper { inner: AzStyleBackgroundPositionVecValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBackgroundPositionVecValueEnumWrapper {
        AzStyleBackgroundPositionVecValueEnumWrapper { inner: AzStyleBackgroundPositionVecValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBackgroundPositionVecValueEnumWrapper {
        AzStyleBackgroundPositionVecValueEnumWrapper { inner: AzStyleBackgroundPositionVecValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBackgroundPositionVec) -> AzStyleBackgroundPositionVecValueEnumWrapper {
        AzStyleBackgroundPositionVecValueEnumWrapper { inner: AzStyleBackgroundPositionVecValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundPositionVecValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundPositionVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBackgroundPositionVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBackgroundPositionVecValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBackgroundPositionVecValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBackgroundPositionVecValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundPositionVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBackgroundPositionVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBackgroundPositionVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundRepeatVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBackgroundRepeatVecValueEnumWrapper {
        AzStyleBackgroundRepeatVecValueEnumWrapper { inner: AzStyleBackgroundRepeatVecValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBackgroundRepeatVecValueEnumWrapper {
        AzStyleBackgroundRepeatVecValueEnumWrapper { inner: AzStyleBackgroundRepeatVecValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBackgroundRepeatVecValueEnumWrapper {
        AzStyleBackgroundRepeatVecValueEnumWrapper { inner: AzStyleBackgroundRepeatVecValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBackgroundRepeatVecValueEnumWrapper {
        AzStyleBackgroundRepeatVecValueEnumWrapper { inner: AzStyleBackgroundRepeatVecValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBackgroundRepeatVec) -> AzStyleBackgroundRepeatVecValueEnumWrapper {
        AzStyleBackgroundRepeatVecValueEnumWrapper { inner: AzStyleBackgroundRepeatVecValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundRepeatVecValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundRepeatVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBackgroundRepeatVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBackgroundRepeatVecValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBackgroundRepeatVecValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBackgroundRepeatVecValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundRepeatVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBackgroundRepeatVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBackgroundRepeatVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundSizeVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBackgroundSizeVecValueEnumWrapper {
        AzStyleBackgroundSizeVecValueEnumWrapper { inner: AzStyleBackgroundSizeVecValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBackgroundSizeVecValueEnumWrapper {
        AzStyleBackgroundSizeVecValueEnumWrapper { inner: AzStyleBackgroundSizeVecValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBackgroundSizeVecValueEnumWrapper {
        AzStyleBackgroundSizeVecValueEnumWrapper { inner: AzStyleBackgroundSizeVecValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBackgroundSizeVecValueEnumWrapper {
        AzStyleBackgroundSizeVecValueEnumWrapper { inner: AzStyleBackgroundSizeVecValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBackgroundSizeVec) -> AzStyleBackgroundSizeVecValueEnumWrapper {
        AzStyleBackgroundSizeVecValueEnumWrapper { inner: AzStyleBackgroundSizeVecValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundSizeVecValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundSizeVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSizeVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSizeVecValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSizeVecValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSizeVecValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundSizeVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBackgroundSizeVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBackgroundSizeVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomColorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderBottomColorValueEnumWrapper {
        AzStyleBorderBottomColorValueEnumWrapper { inner: AzStyleBorderBottomColorValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBorderBottomColorValueEnumWrapper {
        AzStyleBorderBottomColorValueEnumWrapper { inner: AzStyleBorderBottomColorValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderBottomColorValueEnumWrapper {
        AzStyleBorderBottomColorValueEnumWrapper { inner: AzStyleBorderBottomColorValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderBottomColorValueEnumWrapper {
        AzStyleBorderBottomColorValueEnumWrapper { inner: AzStyleBorderBottomColorValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBorderBottomColor) -> AzStyleBorderBottomColorValueEnumWrapper {
        AzStyleBorderBottomColorValueEnumWrapper { inner: AzStyleBorderBottomColorValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderBottomColorValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderBottomColorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomColorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomColorValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomColorValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomColorValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomColorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderBottomColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderBottomColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomLeftRadiusValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderBottomLeftRadiusValueEnumWrapper {
        AzStyleBorderBottomLeftRadiusValueEnumWrapper { inner: AzStyleBorderBottomLeftRadiusValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBorderBottomLeftRadiusValueEnumWrapper {
        AzStyleBorderBottomLeftRadiusValueEnumWrapper { inner: AzStyleBorderBottomLeftRadiusValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderBottomLeftRadiusValueEnumWrapper {
        AzStyleBorderBottomLeftRadiusValueEnumWrapper { inner: AzStyleBorderBottomLeftRadiusValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderBottomLeftRadiusValueEnumWrapper {
        AzStyleBorderBottomLeftRadiusValueEnumWrapper { inner: AzStyleBorderBottomLeftRadiusValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBorderBottomLeftRadius) -> AzStyleBorderBottomLeftRadiusValueEnumWrapper {
        AzStyleBorderBottomLeftRadiusValueEnumWrapper { inner: AzStyleBorderBottomLeftRadiusValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderBottomLeftRadiusValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderBottomLeftRadiusValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomLeftRadiusValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomLeftRadiusValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomLeftRadiusValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomLeftRadiusValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomLeftRadiusValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderBottomLeftRadiusValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderBottomLeftRadiusValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomRightRadiusValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderBottomRightRadiusValueEnumWrapper {
        AzStyleBorderBottomRightRadiusValueEnumWrapper { inner: AzStyleBorderBottomRightRadiusValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBorderBottomRightRadiusValueEnumWrapper {
        AzStyleBorderBottomRightRadiusValueEnumWrapper { inner: AzStyleBorderBottomRightRadiusValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderBottomRightRadiusValueEnumWrapper {
        AzStyleBorderBottomRightRadiusValueEnumWrapper { inner: AzStyleBorderBottomRightRadiusValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderBottomRightRadiusValueEnumWrapper {
        AzStyleBorderBottomRightRadiusValueEnumWrapper { inner: AzStyleBorderBottomRightRadiusValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBorderBottomRightRadius) -> AzStyleBorderBottomRightRadiusValueEnumWrapper {
        AzStyleBorderBottomRightRadiusValueEnumWrapper { inner: AzStyleBorderBottomRightRadiusValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderBottomRightRadiusValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderBottomRightRadiusValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomRightRadiusValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomRightRadiusValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomRightRadiusValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomRightRadiusValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomRightRadiusValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderBottomRightRadiusValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderBottomRightRadiusValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomStyleValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderBottomStyleValueEnumWrapper {
        AzStyleBorderBottomStyleValueEnumWrapper { inner: AzStyleBorderBottomStyleValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBorderBottomStyleValueEnumWrapper {
        AzStyleBorderBottomStyleValueEnumWrapper { inner: AzStyleBorderBottomStyleValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderBottomStyleValueEnumWrapper {
        AzStyleBorderBottomStyleValueEnumWrapper { inner: AzStyleBorderBottomStyleValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderBottomStyleValueEnumWrapper {
        AzStyleBorderBottomStyleValueEnumWrapper { inner: AzStyleBorderBottomStyleValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBorderBottomStyle) -> AzStyleBorderBottomStyleValueEnumWrapper {
        AzStyleBorderBottomStyleValueEnumWrapper { inner: AzStyleBorderBottomStyleValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderBottomStyleValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderBottomStyleValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomStyleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomStyleValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomStyleValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomStyleValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomStyleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderBottomStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderBottomStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderBottomWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBorderBottomWidthValueEnumWrapper {
        AzLayoutBorderBottomWidthValueEnumWrapper { inner: AzLayoutBorderBottomWidthValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutBorderBottomWidthValueEnumWrapper {
        AzLayoutBorderBottomWidthValueEnumWrapper { inner: AzLayoutBorderBottomWidthValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutBorderBottomWidthValueEnumWrapper {
        AzLayoutBorderBottomWidthValueEnumWrapper { inner: AzLayoutBorderBottomWidthValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutBorderBottomWidthValueEnumWrapper {
        AzLayoutBorderBottomWidthValueEnumWrapper { inner: AzLayoutBorderBottomWidthValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutBorderBottomWidth) -> AzLayoutBorderBottomWidthValueEnumWrapper {
        AzLayoutBorderBottomWidthValueEnumWrapper { inner: AzLayoutBorderBottomWidthValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutBorderBottomWidthValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBorderBottomWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBorderBottomWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBorderBottomWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutBorderBottomWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutBorderBottomWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderBottomWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutBorderBottomWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutBorderBottomWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderLeftColorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderLeftColorValueEnumWrapper {
        AzStyleBorderLeftColorValueEnumWrapper { inner: AzStyleBorderLeftColorValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBorderLeftColorValueEnumWrapper {
        AzStyleBorderLeftColorValueEnumWrapper { inner: AzStyleBorderLeftColorValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderLeftColorValueEnumWrapper {
        AzStyleBorderLeftColorValueEnumWrapper { inner: AzStyleBorderLeftColorValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderLeftColorValueEnumWrapper {
        AzStyleBorderLeftColorValueEnumWrapper { inner: AzStyleBorderLeftColorValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBorderLeftColor) -> AzStyleBorderLeftColorValueEnumWrapper {
        AzStyleBorderLeftColorValueEnumWrapper { inner: AzStyleBorderLeftColorValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderLeftColorValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderLeftColorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftColorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftColorValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftColorValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftColorValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderLeftColorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderLeftColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderLeftColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderLeftStyleValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderLeftStyleValueEnumWrapper {
        AzStyleBorderLeftStyleValueEnumWrapper { inner: AzStyleBorderLeftStyleValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBorderLeftStyleValueEnumWrapper {
        AzStyleBorderLeftStyleValueEnumWrapper { inner: AzStyleBorderLeftStyleValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderLeftStyleValueEnumWrapper {
        AzStyleBorderLeftStyleValueEnumWrapper { inner: AzStyleBorderLeftStyleValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderLeftStyleValueEnumWrapper {
        AzStyleBorderLeftStyleValueEnumWrapper { inner: AzStyleBorderLeftStyleValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBorderLeftStyle) -> AzStyleBorderLeftStyleValueEnumWrapper {
        AzStyleBorderLeftStyleValueEnumWrapper { inner: AzStyleBorderLeftStyleValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderLeftStyleValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderLeftStyleValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftStyleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftStyleValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftStyleValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftStyleValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderLeftStyleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderLeftStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderLeftStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderLeftWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBorderLeftWidthValueEnumWrapper {
        AzLayoutBorderLeftWidthValueEnumWrapper { inner: AzLayoutBorderLeftWidthValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutBorderLeftWidthValueEnumWrapper {
        AzLayoutBorderLeftWidthValueEnumWrapper { inner: AzLayoutBorderLeftWidthValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutBorderLeftWidthValueEnumWrapper {
        AzLayoutBorderLeftWidthValueEnumWrapper { inner: AzLayoutBorderLeftWidthValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutBorderLeftWidthValueEnumWrapper {
        AzLayoutBorderLeftWidthValueEnumWrapper { inner: AzLayoutBorderLeftWidthValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutBorderLeftWidth) -> AzLayoutBorderLeftWidthValueEnumWrapper {
        AzLayoutBorderLeftWidthValueEnumWrapper { inner: AzLayoutBorderLeftWidthValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutBorderLeftWidthValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBorderLeftWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBorderLeftWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBorderLeftWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutBorderLeftWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutBorderLeftWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderLeftWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutBorderLeftWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutBorderLeftWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderRightColorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderRightColorValueEnumWrapper {
        AzStyleBorderRightColorValueEnumWrapper { inner: AzStyleBorderRightColorValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBorderRightColorValueEnumWrapper {
        AzStyleBorderRightColorValueEnumWrapper { inner: AzStyleBorderRightColorValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderRightColorValueEnumWrapper {
        AzStyleBorderRightColorValueEnumWrapper { inner: AzStyleBorderRightColorValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderRightColorValueEnumWrapper {
        AzStyleBorderRightColorValueEnumWrapper { inner: AzStyleBorderRightColorValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBorderRightColor) -> AzStyleBorderRightColorValueEnumWrapper {
        AzStyleBorderRightColorValueEnumWrapper { inner: AzStyleBorderRightColorValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderRightColorValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderRightColorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderRightColorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderRightColorValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderRightColorValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderRightColorValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderRightColorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderRightColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderRightColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderRightStyleValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderRightStyleValueEnumWrapper {
        AzStyleBorderRightStyleValueEnumWrapper { inner: AzStyleBorderRightStyleValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBorderRightStyleValueEnumWrapper {
        AzStyleBorderRightStyleValueEnumWrapper { inner: AzStyleBorderRightStyleValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderRightStyleValueEnumWrapper {
        AzStyleBorderRightStyleValueEnumWrapper { inner: AzStyleBorderRightStyleValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderRightStyleValueEnumWrapper {
        AzStyleBorderRightStyleValueEnumWrapper { inner: AzStyleBorderRightStyleValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBorderRightStyle) -> AzStyleBorderRightStyleValueEnumWrapper {
        AzStyleBorderRightStyleValueEnumWrapper { inner: AzStyleBorderRightStyleValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderRightStyleValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderRightStyleValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderRightStyleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderRightStyleValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderRightStyleValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderRightStyleValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderRightStyleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderRightStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderRightStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderRightWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBorderRightWidthValueEnumWrapper {
        AzLayoutBorderRightWidthValueEnumWrapper { inner: AzLayoutBorderRightWidthValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutBorderRightWidthValueEnumWrapper {
        AzLayoutBorderRightWidthValueEnumWrapper { inner: AzLayoutBorderRightWidthValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutBorderRightWidthValueEnumWrapper {
        AzLayoutBorderRightWidthValueEnumWrapper { inner: AzLayoutBorderRightWidthValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutBorderRightWidthValueEnumWrapper {
        AzLayoutBorderRightWidthValueEnumWrapper { inner: AzLayoutBorderRightWidthValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutBorderRightWidth) -> AzLayoutBorderRightWidthValueEnumWrapper {
        AzLayoutBorderRightWidthValueEnumWrapper { inner: AzLayoutBorderRightWidthValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutBorderRightWidthValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBorderRightWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBorderRightWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBorderRightWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutBorderRightWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutBorderRightWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderRightWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutBorderRightWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutBorderRightWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopColorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderTopColorValueEnumWrapper {
        AzStyleBorderTopColorValueEnumWrapper { inner: AzStyleBorderTopColorValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBorderTopColorValueEnumWrapper {
        AzStyleBorderTopColorValueEnumWrapper { inner: AzStyleBorderTopColorValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderTopColorValueEnumWrapper {
        AzStyleBorderTopColorValueEnumWrapper { inner: AzStyleBorderTopColorValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderTopColorValueEnumWrapper {
        AzStyleBorderTopColorValueEnumWrapper { inner: AzStyleBorderTopColorValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBorderTopColor) -> AzStyleBorderTopColorValueEnumWrapper {
        AzStyleBorderTopColorValueEnumWrapper { inner: AzStyleBorderTopColorValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderTopColorValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderTopColorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderTopColorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderTopColorValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderTopColorValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderTopColorValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopColorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderTopColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderTopColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopLeftRadiusValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderTopLeftRadiusValueEnumWrapper {
        AzStyleBorderTopLeftRadiusValueEnumWrapper { inner: AzStyleBorderTopLeftRadiusValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBorderTopLeftRadiusValueEnumWrapper {
        AzStyleBorderTopLeftRadiusValueEnumWrapper { inner: AzStyleBorderTopLeftRadiusValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderTopLeftRadiusValueEnumWrapper {
        AzStyleBorderTopLeftRadiusValueEnumWrapper { inner: AzStyleBorderTopLeftRadiusValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderTopLeftRadiusValueEnumWrapper {
        AzStyleBorderTopLeftRadiusValueEnumWrapper { inner: AzStyleBorderTopLeftRadiusValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBorderTopLeftRadius) -> AzStyleBorderTopLeftRadiusValueEnumWrapper {
        AzStyleBorderTopLeftRadiusValueEnumWrapper { inner: AzStyleBorderTopLeftRadiusValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderTopLeftRadiusValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderTopLeftRadiusValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderTopLeftRadiusValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderTopLeftRadiusValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderTopLeftRadiusValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderTopLeftRadiusValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopLeftRadiusValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderTopLeftRadiusValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderTopLeftRadiusValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopRightRadiusValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderTopRightRadiusValueEnumWrapper {
        AzStyleBorderTopRightRadiusValueEnumWrapper { inner: AzStyleBorderTopRightRadiusValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBorderTopRightRadiusValueEnumWrapper {
        AzStyleBorderTopRightRadiusValueEnumWrapper { inner: AzStyleBorderTopRightRadiusValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderTopRightRadiusValueEnumWrapper {
        AzStyleBorderTopRightRadiusValueEnumWrapper { inner: AzStyleBorderTopRightRadiusValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderTopRightRadiusValueEnumWrapper {
        AzStyleBorderTopRightRadiusValueEnumWrapper { inner: AzStyleBorderTopRightRadiusValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBorderTopRightRadius) -> AzStyleBorderTopRightRadiusValueEnumWrapper {
        AzStyleBorderTopRightRadiusValueEnumWrapper { inner: AzStyleBorderTopRightRadiusValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderTopRightRadiusValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderTopRightRadiusValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderTopRightRadiusValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderTopRightRadiusValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderTopRightRadiusValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderTopRightRadiusValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopRightRadiusValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderTopRightRadiusValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderTopRightRadiusValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopStyleValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderTopStyleValueEnumWrapper {
        AzStyleBorderTopStyleValueEnumWrapper { inner: AzStyleBorderTopStyleValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBorderTopStyleValueEnumWrapper {
        AzStyleBorderTopStyleValueEnumWrapper { inner: AzStyleBorderTopStyleValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderTopStyleValueEnumWrapper {
        AzStyleBorderTopStyleValueEnumWrapper { inner: AzStyleBorderTopStyleValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderTopStyleValueEnumWrapper {
        AzStyleBorderTopStyleValueEnumWrapper { inner: AzStyleBorderTopStyleValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBorderTopStyle) -> AzStyleBorderTopStyleValueEnumWrapper {
        AzStyleBorderTopStyleValueEnumWrapper { inner: AzStyleBorderTopStyleValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBorderTopStyleValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderTopStyleValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderTopStyleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderTopStyleValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderTopStyleValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderTopStyleValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopStyleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderTopStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBorderTopStyleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderTopWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBorderTopWidthValueEnumWrapper {
        AzLayoutBorderTopWidthValueEnumWrapper { inner: AzLayoutBorderTopWidthValue::Auto }
    }
    #[classattr]
    fn None() -> AzLayoutBorderTopWidthValueEnumWrapper {
        AzLayoutBorderTopWidthValueEnumWrapper { inner: AzLayoutBorderTopWidthValue::None }
    }
    #[classattr]
    fn Inherit() -> AzLayoutBorderTopWidthValueEnumWrapper {
        AzLayoutBorderTopWidthValueEnumWrapper { inner: AzLayoutBorderTopWidthValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzLayoutBorderTopWidthValueEnumWrapper {
        AzLayoutBorderTopWidthValueEnumWrapper { inner: AzLayoutBorderTopWidthValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: LayoutBorderTopWidth) -> AzLayoutBorderTopWidthValueEnumWrapper {
        AzLayoutBorderTopWidthValueEnumWrapper { inner: AzLayoutBorderTopWidthValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutBorderTopWidthValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBorderTopWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBorderTopWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBorderTopWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutBorderTopWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutBorderTopWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderTopWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutBorderTopWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::LayoutBorderTopWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleCursorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleCursorValueEnumWrapper {
        AzStyleCursorValueEnumWrapper { inner: AzStyleCursorValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleCursorValueEnumWrapper {
        AzStyleCursorValueEnumWrapper { inner: AzStyleCursorValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleCursorValueEnumWrapper {
        AzStyleCursorValueEnumWrapper { inner: AzStyleCursorValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleCursorValueEnumWrapper {
        AzStyleCursorValueEnumWrapper { inner: AzStyleCursorValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleCursor) -> AzStyleCursorValueEnumWrapper {
        AzStyleCursorValueEnumWrapper { inner: AzStyleCursorValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleCursorValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleCursorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleCursorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleCursorValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleCursorValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleCursorValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleCursorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleCursorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleCursorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontFamilyVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleFontFamilyVecValueEnumWrapper {
        AzStyleFontFamilyVecValueEnumWrapper { inner: AzStyleFontFamilyVecValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleFontFamilyVecValueEnumWrapper {
        AzStyleFontFamilyVecValueEnumWrapper { inner: AzStyleFontFamilyVecValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleFontFamilyVecValueEnumWrapper {
        AzStyleFontFamilyVecValueEnumWrapper { inner: AzStyleFontFamilyVecValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleFontFamilyVecValueEnumWrapper {
        AzStyleFontFamilyVecValueEnumWrapper { inner: AzStyleFontFamilyVecValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleFontFamilyVec) -> AzStyleFontFamilyVecValueEnumWrapper {
        AzStyleFontFamilyVecValueEnumWrapper { inner: AzStyleFontFamilyVecValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleFontFamilyVecValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFontFamilyVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontFamilyVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleFontFamilyVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleFontFamilyVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontSizeValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleFontSizeValueEnumWrapper {
        AzStyleFontSizeValueEnumWrapper { inner: AzStyleFontSizeValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleFontSizeValueEnumWrapper {
        AzStyleFontSizeValueEnumWrapper { inner: AzStyleFontSizeValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleFontSizeValueEnumWrapper {
        AzStyleFontSizeValueEnumWrapper { inner: AzStyleFontSizeValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleFontSizeValueEnumWrapper {
        AzStyleFontSizeValueEnumWrapper { inner: AzStyleFontSizeValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleFontSize) -> AzStyleFontSizeValueEnumWrapper {
        AzStyleFontSizeValueEnumWrapper { inner: AzStyleFontSizeValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleFontSizeValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFontSizeValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleFontSizeValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleFontSizeValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleFontSizeValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleFontSizeValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontSizeValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleFontSizeValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleFontSizeValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleLetterSpacingValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleLetterSpacingValueEnumWrapper {
        AzStyleLetterSpacingValueEnumWrapper { inner: AzStyleLetterSpacingValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleLetterSpacingValueEnumWrapper {
        AzStyleLetterSpacingValueEnumWrapper { inner: AzStyleLetterSpacingValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleLetterSpacingValueEnumWrapper {
        AzStyleLetterSpacingValueEnumWrapper { inner: AzStyleLetterSpacingValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleLetterSpacingValueEnumWrapper {
        AzStyleLetterSpacingValueEnumWrapper { inner: AzStyleLetterSpacingValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleLetterSpacing) -> AzStyleLetterSpacingValueEnumWrapper {
        AzStyleLetterSpacingValueEnumWrapper { inner: AzStyleLetterSpacingValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleLetterSpacingValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleLetterSpacingValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleLetterSpacingValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleLetterSpacingValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleLetterSpacingValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleLetterSpacingValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleLetterSpacingValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleLetterSpacingValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleLetterSpacingValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleLineHeightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleLineHeightValueEnumWrapper {
        AzStyleLineHeightValueEnumWrapper { inner: AzStyleLineHeightValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleLineHeightValueEnumWrapper {
        AzStyleLineHeightValueEnumWrapper { inner: AzStyleLineHeightValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleLineHeightValueEnumWrapper {
        AzStyleLineHeightValueEnumWrapper { inner: AzStyleLineHeightValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleLineHeightValueEnumWrapper {
        AzStyleLineHeightValueEnumWrapper { inner: AzStyleLineHeightValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleLineHeight) -> AzStyleLineHeightValueEnumWrapper {
        AzStyleLineHeightValueEnumWrapper { inner: AzStyleLineHeightValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleLineHeightValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleLineHeightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleLineHeightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleLineHeightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleLineHeightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleLineHeightValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleLineHeightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleLineHeightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleLineHeightValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTabWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleTabWidthValueEnumWrapper {
        AzStyleTabWidthValueEnumWrapper { inner: AzStyleTabWidthValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleTabWidthValueEnumWrapper {
        AzStyleTabWidthValueEnumWrapper { inner: AzStyleTabWidthValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleTabWidthValueEnumWrapper {
        AzStyleTabWidthValueEnumWrapper { inner: AzStyleTabWidthValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleTabWidthValueEnumWrapper {
        AzStyleTabWidthValueEnumWrapper { inner: AzStyleTabWidthValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleTabWidth) -> AzStyleTabWidthValueEnumWrapper {
        AzStyleTabWidthValueEnumWrapper { inner: AzStyleTabWidthValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTabWidthValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTabWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleTabWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleTabWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleTabWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleTabWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTabWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleTabWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleTabWidthValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTextAlignValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleTextAlignValueEnumWrapper {
        AzStyleTextAlignValueEnumWrapper { inner: AzStyleTextAlignValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleTextAlignValueEnumWrapper {
        AzStyleTextAlignValueEnumWrapper { inner: AzStyleTextAlignValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleTextAlignValueEnumWrapper {
        AzStyleTextAlignValueEnumWrapper { inner: AzStyleTextAlignValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleTextAlignValueEnumWrapper {
        AzStyleTextAlignValueEnumWrapper { inner: AzStyleTextAlignValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleTextAlign) -> AzStyleTextAlignValueEnumWrapper {
        AzStyleTextAlignValueEnumWrapper { inner: AzStyleTextAlignValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTextAlignValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTextAlignValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleTextAlignValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleTextAlignValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleTextAlignValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleTextAlignValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextAlignValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleTextAlignValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleTextAlignValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTextColorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleTextColorValueEnumWrapper {
        AzStyleTextColorValueEnumWrapper { inner: AzStyleTextColorValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleTextColorValueEnumWrapper {
        AzStyleTextColorValueEnumWrapper { inner: AzStyleTextColorValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleTextColorValueEnumWrapper {
        AzStyleTextColorValueEnumWrapper { inner: AzStyleTextColorValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleTextColorValueEnumWrapper {
        AzStyleTextColorValueEnumWrapper { inner: AzStyleTextColorValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleTextColor) -> AzStyleTextColorValueEnumWrapper {
        AzStyleTextColorValueEnumWrapper { inner: AzStyleTextColorValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTextColorValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTextColorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleTextColorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleTextColorValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleTextColorValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleTextColorValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextColorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleTextColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleTextColorValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleWordSpacingValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleWordSpacingValueEnumWrapper {
        AzStyleWordSpacingValueEnumWrapper { inner: AzStyleWordSpacingValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleWordSpacingValueEnumWrapper {
        AzStyleWordSpacingValueEnumWrapper { inner: AzStyleWordSpacingValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleWordSpacingValueEnumWrapper {
        AzStyleWordSpacingValueEnumWrapper { inner: AzStyleWordSpacingValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleWordSpacingValueEnumWrapper {
        AzStyleWordSpacingValueEnumWrapper { inner: AzStyleWordSpacingValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleWordSpacing) -> AzStyleWordSpacingValueEnumWrapper {
        AzStyleWordSpacingValueEnumWrapper { inner: AzStyleWordSpacingValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleWordSpacingValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleWordSpacingValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleWordSpacingValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleWordSpacingValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleWordSpacingValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleWordSpacingValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleWordSpacingValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleWordSpacingValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleWordSpacingValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleOpacityValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleOpacityValueEnumWrapper {
        AzStyleOpacityValueEnumWrapper { inner: AzStyleOpacityValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleOpacityValueEnumWrapper {
        AzStyleOpacityValueEnumWrapper { inner: AzStyleOpacityValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleOpacityValueEnumWrapper {
        AzStyleOpacityValueEnumWrapper { inner: AzStyleOpacityValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleOpacityValueEnumWrapper {
        AzStyleOpacityValueEnumWrapper { inner: AzStyleOpacityValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleOpacity) -> AzStyleOpacityValueEnumWrapper {
        AzStyleOpacityValueEnumWrapper { inner: AzStyleOpacityValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleOpacityValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleOpacityValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleOpacityValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleOpacityValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleOpacityValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleOpacityValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleOpacityValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleOpacityValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleOpacityValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleTransformVecValueEnumWrapper {
        AzStyleTransformVecValueEnumWrapper { inner: AzStyleTransformVecValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleTransformVecValueEnumWrapper {
        AzStyleTransformVecValueEnumWrapper { inner: AzStyleTransformVecValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleTransformVecValueEnumWrapper {
        AzStyleTransformVecValueEnumWrapper { inner: AzStyleTransformVecValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleTransformVecValueEnumWrapper {
        AzStyleTransformVecValueEnumWrapper { inner: AzStyleTransformVecValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleTransformVec) -> AzStyleTransformVecValueEnumWrapper {
        AzStyleTransformVecValueEnumWrapper { inner: AzStyleTransformVecValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTransformVecValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTransformVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleTransformVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleTransformVecValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleTransformVecValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleTransformVecValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleTransformVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleTransformVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformOriginValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleTransformOriginValueEnumWrapper {
        AzStyleTransformOriginValueEnumWrapper { inner: AzStyleTransformOriginValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleTransformOriginValueEnumWrapper {
        AzStyleTransformOriginValueEnumWrapper { inner: AzStyleTransformOriginValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleTransformOriginValueEnumWrapper {
        AzStyleTransformOriginValueEnumWrapper { inner: AzStyleTransformOriginValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleTransformOriginValueEnumWrapper {
        AzStyleTransformOriginValueEnumWrapper { inner: AzStyleTransformOriginValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleTransformOrigin) -> AzStyleTransformOriginValueEnumWrapper {
        AzStyleTransformOriginValueEnumWrapper { inner: AzStyleTransformOriginValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTransformOriginValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTransformOriginValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleTransformOriginValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleTransformOriginValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleTransformOriginValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleTransformOriginValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformOriginValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleTransformOriginValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleTransformOriginValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylePerspectiveOriginValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStylePerspectiveOriginValueEnumWrapper {
        AzStylePerspectiveOriginValueEnumWrapper { inner: AzStylePerspectiveOriginValue::Auto }
    }
    #[classattr]
    fn None() -> AzStylePerspectiveOriginValueEnumWrapper {
        AzStylePerspectiveOriginValueEnumWrapper { inner: AzStylePerspectiveOriginValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStylePerspectiveOriginValueEnumWrapper {
        AzStylePerspectiveOriginValueEnumWrapper { inner: AzStylePerspectiveOriginValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStylePerspectiveOriginValueEnumWrapper {
        AzStylePerspectiveOriginValueEnumWrapper { inner: AzStylePerspectiveOriginValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleTransformOrigin) -> AzStylePerspectiveOriginValueEnumWrapper {
        AzStylePerspectiveOriginValueEnumWrapper { inner: AzStylePerspectiveOriginValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStylePerspectiveOriginValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStylePerspectiveOriginValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStylePerspectiveOriginValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStylePerspectiveOriginValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStylePerspectiveOriginValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStylePerspectiveOriginValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStylePerspectiveOriginValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StylePerspectiveOriginValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StylePerspectiveOriginValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackfaceVisibilityValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBackfaceVisibilityValueEnumWrapper {
        AzStyleBackfaceVisibilityValueEnumWrapper { inner: AzStyleBackfaceVisibilityValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleBackfaceVisibilityValueEnumWrapper {
        AzStyleBackfaceVisibilityValueEnumWrapper { inner: AzStyleBackfaceVisibilityValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleBackfaceVisibilityValueEnumWrapper {
        AzStyleBackfaceVisibilityValueEnumWrapper { inner: AzStyleBackfaceVisibilityValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleBackfaceVisibilityValueEnumWrapper {
        AzStyleBackfaceVisibilityValueEnumWrapper { inner: AzStyleBackfaceVisibilityValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleBackfaceVisibility) -> AzStyleBackfaceVisibilityValueEnumWrapper {
        AzStyleBackfaceVisibilityValueEnumWrapper { inner: AzStyleBackfaceVisibilityValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackfaceVisibilityValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackfaceVisibilityValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBackfaceVisibilityValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBackfaceVisibilityValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBackfaceVisibilityValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBackfaceVisibilityValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackfaceVisibilityValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBackfaceVisibilityValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleBackfaceVisibilityValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleMixBlendModeValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleMixBlendModeValueEnumWrapper {
        AzStyleMixBlendModeValueEnumWrapper { inner: AzStyleMixBlendModeValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleMixBlendModeValueEnumWrapper {
        AzStyleMixBlendModeValueEnumWrapper { inner: AzStyleMixBlendModeValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleMixBlendModeValueEnumWrapper {
        AzStyleMixBlendModeValueEnumWrapper { inner: AzStyleMixBlendModeValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleMixBlendModeValueEnumWrapper {
        AzStyleMixBlendModeValueEnumWrapper { inner: AzStyleMixBlendModeValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleMixBlendMode) -> AzStyleMixBlendModeValueEnumWrapper {
        AzStyleMixBlendModeValueEnumWrapper { inner: AzStyleMixBlendModeValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleMixBlendModeValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleMixBlendModeValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleMixBlendModeValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleMixBlendModeValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleMixBlendModeValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleMixBlendModeValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleMixBlendModeValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleMixBlendModeValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleMixBlendModeValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFilterVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleFilterVecValueEnumWrapper {
        AzStyleFilterVecValueEnumWrapper { inner: AzStyleFilterVecValue::Auto }
    }
    #[classattr]
    fn None() -> AzStyleFilterVecValueEnumWrapper {
        AzStyleFilterVecValueEnumWrapper { inner: AzStyleFilterVecValue::None }
    }
    #[classattr]
    fn Inherit() -> AzStyleFilterVecValueEnumWrapper {
        AzStyleFilterVecValueEnumWrapper { inner: AzStyleFilterVecValue::Inherit }
    }
    #[classattr]
    fn Initial() -> AzStyleFilterVecValueEnumWrapper {
        AzStyleFilterVecValueEnumWrapper { inner: AzStyleFilterVecValue::Initial }
    }
    #[staticmethod]
    fn Exact(v: StyleFilterVec) -> AzStyleFilterVecValueEnumWrapper {
        AzStyleFilterVecValueEnumWrapper { inner: AzStyleFilterVecValue::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleFilterVecValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFilterVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleFilterVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleFilterVecValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleFilterVecValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleFilterVecValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFilterVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleFilterVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::StyleFilterVecValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzCssPropertyValueEnumWrapper {
        AzCssPropertyValueEnumWrapper { inner: AzCssPropertyValue::Auto }
    }
    #[classattr]
    fn None() -> AzCssPropertyValueEnumWrapper {
        AzCssPropertyValueEnumWrapper { inner: AzCssPropertyValue::None }
    }
    #[classattr]
    fn Initial() -> AzCssPropertyValueEnumWrapper {
        AzCssPropertyValueEnumWrapper { inner: AzCssPropertyValue::Initial }
    }
    #[classattr]
    fn Inherit() -> AzCssPropertyValueEnumWrapper {
        AzCssPropertyValueEnumWrapper { inner: AzCssPropertyValue::Inherit }
    }
    #[staticmethod]

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssPropertyValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPropertyValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzCssPropertyValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzCssPropertyValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzCssPropertyValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzCssPropertyValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPropertyValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPropertyValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCounterReset {
}

#[pyproto]
impl PyObjectProtocol for AzCounterReset {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::content::CounterReset = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::content::CounterReset = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGridLineEnumWrapper {
    #[classattr]
    fn Auto() -> AzGridLineEnumWrapper {
        AzGridLineEnumWrapper { inner: AzGridLine::Auto }
    }
    #[staticmethod]
    fn Line(v: i32) -> AzGridLineEnumWrapper {
        AzGridLineEnumWrapper { inner: AzGridLine::Line(v) }}
    }
    #[staticmethod]
    #[staticmethod]
    fn Span(v: i32) -> AzGridLineEnumWrapper {
        AzGridLineEnumWrapper { inner: AzGridLine::Span(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzGridLine;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzGridLine::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzGridLine::Line(v) => Ok(vec!["Line".into_py(py), v.into_py(py)]),
            AzGridLine::Named(v) => Ok(vec!["Named".into_py(py), v.into_py(py)]),
            AzGridLine::Span(v) => Ok(vec!["Span".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGridLineEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridLine = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridLine = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylePerspectiveOrigin {
}

#[pyproto]
impl PyObjectProtocol for AzStylePerspectiveOrigin {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StylePerspectiveOrigin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StylePerspectiveOrigin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutZIndexEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutZIndexEnumWrapper {
        AzLayoutZIndexEnumWrapper { inner: AzLayoutZIndex::Auto }
    }
    #[staticmethod]
    fn Integer(v: i32) -> AzLayoutZIndexEnumWrapper {
        AzLayoutZIndexEnumWrapper { inner: AzLayoutZIndex::Integer(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutZIndex;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutZIndex::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutZIndex::Integer(v) => Ok(vec!["Integer".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutZIndexEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::position::LayoutZIndex = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::position::LayoutZIndex = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutJustifyItemsEnumWrapper {
    #[classattr]
    const Start: AzLayoutJustifyItems = AzLayoutJustifyItems::Start;
    #[classattr]
    const End: AzLayoutJustifyItems = AzLayoutJustifyItems::End;
    #[classattr]
    const Center: AzLayoutJustifyItems = AzLayoutJustifyItems::Center;
    #[classattr]
    const Stretch: AzLayoutJustifyItems = AzLayoutJustifyItems::Stretch;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutJustifyItemsEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::LayoutJustifyItems = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::LayoutJustifyItems = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutJustifyItemsEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSelectionBackgroundColor {
}

#[pyproto]
impl PyObjectProtocol for AzSelectionBackgroundColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::selection::SelectionBackgroundColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::selection::SelectionBackgroundColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColumnRuleColor {
}

#[pyproto]
impl PyObjectProtocol for AzColumnRuleColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnRuleColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnRuleColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFontRef {
}

#[pyproto]
impl PyObjectProtocol for AzFontRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::FontRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::FontRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPlatformEnumWrapper {
    #[classattr]
    fn Windows() -> AzPlatformEnumWrapper {
        AzPlatformEnumWrapper { inner: AzPlatform::Windows }
    }
    #[classattr]
    fn MacOs() -> AzPlatformEnumWrapper {
        AzPlatformEnumWrapper { inner: AzPlatform::MacOs }
    }
    #[staticmethod]
    fn Linux(v: DesktopEnvironment) -> AzPlatformEnumWrapper {
        AzPlatformEnumWrapper { inner: AzPlatform::Linux(v) }}
    }
    #[classattr]
    fn Android() -> AzPlatformEnumWrapper {
        AzPlatformEnumWrapper { inner: AzPlatform::Android }
    }
    #[classattr]
    fn Ios() -> AzPlatformEnumWrapper {
        AzPlatformEnumWrapper { inner: AzPlatform::Ios }
    }
    #[classattr]
    fn Unknown() -> AzPlatformEnumWrapper {
        AzPlatformEnumWrapper { inner: AzPlatform::Unknown }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzPlatform;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzPlatform::Windows => Ok(vec!["Windows".into_py(py), ().into_py(py)]),
            AzPlatform::MacOs => Ok(vec!["MacOs".into_py(py), ().into_py(py)]),
            AzPlatform::Linux(v) => Ok(vec!["Linux".into_py(py), v.into_py(py)]),
            AzPlatform::Android => Ok(vec!["Android".into_py(py), ().into_py(py)]),
            AzPlatform::Ios => Ok(vec!["Ios".into_py(py), ().into_py(py)]),
            AzPlatform::Unknown => Ok(vec!["Unknown".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzPlatformEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::system::Platform = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::system::Platform = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColumnSpanEnumWrapper {
    #[classattr]
    const None: AzColumnSpan = AzColumnSpan::None;
    #[classattr]
    const All: AzColumnSpan = AzColumnSpan::All;
}

#[pyproto]
impl PyObjectProtocol for AzColumnSpanEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnSpan = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnSpan = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzColumnSpanEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutClearEnumWrapper {
    #[classattr]
    const None: AzLayoutClear = AzLayoutClear::None;
    #[classattr]
    const Left: AzLayoutClear = AzLayoutClear::Left;
    #[classattr]
    const Right: AzLayoutClear = AzLayoutClear::Right;
    #[classattr]
    const Both: AzLayoutClear = AzLayoutClear::Both;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutClearEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::wrapping::LayoutClear = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::wrapping::LayoutClear = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutClearEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutPoint {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPoint {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::LayoutPoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::LayoutPoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleWhiteSpaceEnumWrapper {
    #[classattr]
    const Normal: AzStyleWhiteSpace = AzStyleWhiteSpace::Normal;
    #[classattr]
    const Pre: AzStyleWhiteSpace = AzStyleWhiteSpace::Pre;
    #[classattr]
    const Nowrap: AzStyleWhiteSpace = AzStyleWhiteSpace::Nowrap;
}

#[pyproto]
impl PyObjectProtocol for AzStyleWhiteSpaceEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleWhiteSpace = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleWhiteSpace = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleWhiteSpaceEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSystemMetrics {
}

#[pyproto]
impl PyObjectProtocol for AzSystemMetrics {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::system::SystemMetrics = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::system::SystemMetrics = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemStyle {
}

#[pyproto]
impl PyObjectProtocol for AzSystemStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::system::SystemStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::system::SystemStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFontMetrics {
}

#[pyproto]
impl PyObjectProtocol for AzFontMetrics {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::FontMetrics = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::FontMetrics = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBreakInsideEnumWrapper {
    #[classattr]
    const Auto: AzBreakInside = AzBreakInside::Auto;
    #[classattr]
    const Avoid: AzBreakInside = AzBreakInside::Avoid;
    #[classattr]
    const AvoidPage: AzBreakInside = AzBreakInside::AvoidPage;
    #[classattr]
    const AvoidColumn: AzBreakInside = AzBreakInside::AvoidColumn;
}

#[pyproto]
impl PyObjectProtocol for AzBreakInsideEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::fragmentation::BreakInside = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::fragmentation::BreakInside = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzBreakInsideEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutAlignSelfEnumWrapper {
    #[classattr]
    const Auto: AzLayoutAlignSelf = AzLayoutAlignSelf::Auto;
    #[classattr]
    const Stretch: AzLayoutAlignSelf = AzLayoutAlignSelf::Stretch;
    #[classattr]
    const Center: AzLayoutAlignSelf = AzLayoutAlignSelf::Center;
    #[classattr]
    const Start: AzLayoutAlignSelf = AzLayoutAlignSelf::Start;
    #[classattr]
    const End: AzLayoutAlignSelf = AzLayoutAlignSelf::End;
    #[classattr]
    const Baseline: AzLayoutAlignSelf = AzLayoutAlignSelf::Baseline;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutAlignSelfEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutAlignSelf = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutAlignSelf = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutAlignSelfEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzCaretAnimationDuration {
}

#[pyproto]
impl PyObjectProtocol for AzCaretAnimationDuration {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::CaretAnimationDuration = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::CaretAnimationDuration = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColumnRuleStyle {
}

#[pyproto]
impl PyObjectProtocol for AzColumnRuleStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnRuleStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnRuleStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPoint {
}

#[pyproto]
impl PyObjectProtocol for AzSvgPoint {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgPoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgPoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGridPlacement {
}

#[pyproto]
impl PyObjectProtocol for AzGridPlacement {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridPlacement = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridPlacement = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringSet {
}

#[pyproto]
impl PyObjectProtocol for AzStringSet {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::content::StringSet = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::content::StringSet = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapeOutsideEnumWrapper {
    #[classattr]
    fn None() -> AzShapeOutsideEnumWrapper {
        AzShapeOutsideEnumWrapper { inner: AzShapeOutside::None }
    }
    #[staticmethod]

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzShapeOutside;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzShapeOutside::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzShapeOutside::Shape(v) => Ok(vec!["Shape".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzShapeOutsideEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::shape::ShapeOutside = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::shape::ShapeOutside = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgVector {
}

#[pyproto]
impl PyObjectProtocol for AzSvgVector {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgVector = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgVector = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDesktopEnvironmentEnumWrapper {
    #[classattr]
    fn Gnome() -> AzDesktopEnvironmentEnumWrapper {
        AzDesktopEnvironmentEnumWrapper { inner: AzDesktopEnvironment::Gnome }
    }
    #[classattr]
    fn Kde() -> AzDesktopEnvironmentEnumWrapper {
        AzDesktopEnvironmentEnumWrapper { inner: AzDesktopEnvironment::Kde }
    }
    #[staticmethod]
    fn Other(v: AzString) -> AzDesktopEnvironmentEnumWrapper {
        AzDesktopEnvironmentEnumWrapper { inner: AzDesktopEnvironment::Other(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzDesktopEnvironment;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzDesktopEnvironment::Gnome => Ok(vec!["Gnome".into_py(py), ().into_py(py)]),
            AzDesktopEnvironment::Kde => Ok(vec!["Kde".into_py(py), ().into_py(py)]),
            AzDesktopEnvironment::Other(v) => Ok(vec!["Other".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDesktopEnvironmentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::system::DesktopEnvironment = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::system::DesktopEnvironment = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColumnCountEnumWrapper {
    #[classattr]
    fn Auto() -> AzColumnCountEnumWrapper {
        AzColumnCountEnumWrapper { inner: AzColumnCount::Auto }
    }
    #[staticmethod]
    fn Integer(v: u32) -> AzColumnCountEnumWrapper {
        AzColumnCountEnumWrapper { inner: AzColumnCount::Integer(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzColumnCount;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzColumnCount::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzColumnCount::Integer(v) => Ok(vec!["Integer".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzColumnCountEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnCount = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnCount = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutWritingModeEnumWrapper {
    #[classattr]
    const HorizontalTb: AzLayoutWritingMode = AzLayoutWritingMode::HorizontalTb;
    #[classattr]
    const VerticalRl: AzLayoutWritingMode = AzLayoutWritingMode::VerticalRl;
    #[classattr]
    const VerticalLr: AzLayoutWritingMode = AzLayoutWritingMode::VerticalLr;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutWritingModeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::wrapping::LayoutWritingMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::wrapping::LayoutWritingMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutWritingModeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSvgRect {
}

#[pyproto]
impl PyObjectProtocol for AzSvgRect {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemColors {
}

#[pyproto]
impl PyObjectProtocol for AzSystemColors {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::system::SystemColors = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::system::SystemColors = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutRect {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutRect {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::LayoutRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::LayoutRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleUserSelectEnumWrapper {
    #[classattr]
    const Auto: AzStyleUserSelect = AzStyleUserSelect::Auto;
    #[classattr]
    const Text: AzStyleUserSelect = AzStyleUserSelect::Text;
    #[classattr]
    const None: AzStyleUserSelect = AzStyleUserSelect::None;
    #[classattr]
    const All: AzStyleUserSelect = AzStyleUserSelect::All;
}

#[pyproto]
impl PyObjectProtocol for AzStyleUserSelectEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleUserSelect = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleUserSelect = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleUserSelectEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzFlowIntoEnumWrapper {
    #[classattr]
    fn None() -> AzFlowIntoEnumWrapper {
        AzFlowIntoEnumWrapper { inner: AzFlowInto::None }
    }
    #[staticmethod]
    fn Named(v: AzString) -> AzFlowIntoEnumWrapper {
        AzFlowIntoEnumWrapper { inner: AzFlowInto::Named(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzFlowInto;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzFlowInto::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzFlowInto::Named(v) => Ok(vec!["Named".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFlowIntoEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flow::FlowInto = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flow::FlowInto = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGridTemplate {
}

#[pyproto]
impl PyObjectProtocol for AzGridTemplate {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridTemplate = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridTemplate = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutJustifySelfEnumWrapper {
    #[classattr]
    const Auto: AzLayoutJustifySelf = AzLayoutJustifySelf::Auto;
    #[classattr]
    const Start: AzLayoutJustifySelf = AzLayoutJustifySelf::Start;
    #[classattr]
    const End: AzLayoutJustifySelf = AzLayoutJustifySelf::End;
    #[classattr]
    const Center: AzLayoutJustifySelf = AzLayoutJustifySelf::Center;
    #[classattr]
    const Stretch: AzLayoutJustifySelf = AzLayoutJustifySelf::Stretch;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutJustifySelfEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::LayoutJustifySelf = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::LayoutJustifySelf = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutJustifySelfEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzContent {
}

#[pyproto]
impl PyObjectProtocol for AzContent {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::content::Content = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::content::Content = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleHyphensEnumWrapper {
    #[classattr]
    const Auto: AzStyleHyphens = AzStyleHyphens::Auto;
    #[classattr]
    const None: AzStyleHyphens = AzStyleHyphens::None;
}

#[pyproto]
impl PyObjectProtocol for AzStyleHyphensEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleHyphens = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleHyphens = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleHyphensEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutGap {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutGap {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::LayoutGap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::LayoutGap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleDirectionEnumWrapper {
    #[classattr]
    const Ltr: AzStyleDirection = AzStyleDirection::Ltr;
    #[classattr]
    const Rtl: AzStyleDirection = AzStyleDirection::Rtl;
}

#[pyproto]
impl PyObjectProtocol for AzStyleDirectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleDirection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleDirection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleDirectionEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutFlexBasisEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFlexBasisEnumWrapper {
        AzLayoutFlexBasisEnumWrapper { inner: AzLayoutFlexBasis::Auto }
    }
    #[staticmethod]
    fn Exact(v: PixelValue) -> AzLayoutFlexBasisEnumWrapper {
        AzLayoutFlexBasisEnumWrapper { inner: AzLayoutFlexBasis::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutFlexBasis;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFlexBasis::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFlexBasis::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexBasisEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexBasis = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexBasis = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapeMargin {
}

#[pyproto]
impl PyObjectProtocol for AzShapeMargin {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::shape::ShapeMargin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::shape::ShapeMargin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutTextJustifyEnumWrapper {
    #[classattr]
    const Auto: AzLayoutTextJustify = AzLayoutTextJustify::Auto;
    #[classattr]
    const None: AzLayoutTextJustify = AzLayoutTextJustify::None;
    #[classattr]
    const InterWord: AzLayoutTextJustify = AzLayoutTextJustify::InterWord;
    #[classattr]
    const InterCharacter: AzLayoutTextJustify = AzLayoutTextJustify::InterCharacter;
    #[classattr]
    const Distribute: AzLayoutTextJustify = AzLayoutTextJustify::Distribute;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutTextJustifyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::text::LayoutTextJustify = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::text::LayoutTextJustify = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutTextJustifyEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzColumnWidthEnumWrapper {
    #[classattr]
    fn Auto() -> AzColumnWidthEnumWrapper {
        AzColumnWidthEnumWrapper { inner: AzColumnWidth::Auto }
    }
    #[staticmethod]
    fn Length(v: PixelValue) -> AzColumnWidthEnumWrapper {
        AzColumnWidthEnumWrapper { inner: AzColumnWidth::Length(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzColumnWidth;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzColumnWidth::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzColumnWidth::Length(v) => Ok(vec!["Length".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzColumnWidthEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnWidth = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnWidth = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCounterIncrement {
}

#[pyproto]
impl PyObjectProtocol for AzCounterIncrement {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::content::CounterIncrement = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::content::CounterIncrement = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBoxDecorationBreakEnumWrapper {
    #[classattr]
    const Slice: AzBoxDecorationBreak = AzBoxDecorationBreak::Slice;
    #[classattr]
    const Clone: AzBoxDecorationBreak = AzBoxDecorationBreak::Clone;
}

#[pyproto]
impl PyObjectProtocol for AzBoxDecorationBreakEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::fragmentation::BoxDecorationBreak = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::fragmentation::BoxDecorationBreak = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzBoxDecorationBreakEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSvgCubicCurve {
}

#[pyproto]
impl PyObjectProtocol for AzSvgCubicCurve {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgCubicCurve = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgCubicCurve = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgQuadraticCurve {
}

#[pyproto]
impl PyObjectProtocol for AzSvgQuadraticCurve {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgQuadraticCurve = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgQuadraticCurve = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSelectionColor {
}

#[pyproto]
impl PyObjectProtocol for AzSelectionColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::selection::SelectionColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::selection::SelectionColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleVisibilityEnumWrapper {
    #[classattr]
    const Visible: AzStyleVisibility = AzStyleVisibility::Visible;
    #[classattr]
    const Hidden: AzStyleVisibility = AzStyleVisibility::Hidden;
    #[classattr]
    const Collapse: AzStyleVisibility = AzStyleVisibility::Collapse;
}

#[pyproto]
impl PyObjectProtocol for AzStyleVisibilityEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::effects::StyleVisibility = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::effects::StyleVisibility = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleVisibilityEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzThemeEnumWrapper {
    #[classattr]
    const Light: AzTheme = AzTheme::Light;
    #[classattr]
    const Dark: AzTheme = AzTheme::Dark;
}

#[pyproto]
impl PyObjectProtocol for AzThemeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::system::Theme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::system::Theme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzThemeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzShapeImageThreshold {
}

#[pyproto]
impl PyObjectProtocol for AzShapeImageThreshold {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::shape::ShapeImageThreshold = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::shape::ShapeImageThreshold = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutGridAutoFlowEnumWrapper {
    #[classattr]
    const Row: AzLayoutGridAutoFlow = AzLayoutGridAutoFlow::Row;
    #[classattr]
    const Column: AzLayoutGridAutoFlow = AzLayoutGridAutoFlow::Column;
    #[classattr]
    const RowDense: AzLayoutGridAutoFlow = AzLayoutGridAutoFlow::RowDense;
    #[classattr]
    const ColumnDense: AzLayoutGridAutoFlow = AzLayoutGridAutoFlow::ColumnDense;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutGridAutoFlowEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::LayoutGridAutoFlow = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::LayoutGridAutoFlow = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutGridAutoFlowEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzColumnRuleWidth {
}

#[pyproto]
impl PyObjectProtocol for AzColumnRuleWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnRuleWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnRuleWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAzString {
}

#[pyproto]
impl PyObjectProtocol for AzAzString {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::AzString = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::AzString = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTextDecorationEnumWrapper {
    #[classattr]
    const None: AzStyleTextDecoration = AzStyleTextDecoration::None;
    #[classattr]
    const Underline: AzStyleTextDecoration = AzStyleTextDecoration::Underline;
    #[classattr]
    const Overline: AzStyleTextDecoration = AzStyleTextDecoration::Overline;
    #[classattr]
    const LineThrough: AzStyleTextDecoration = AzStyleTextDecoration::LineThrough;
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextDecorationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTextDecoration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTextDecoration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleTextDecorationEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzCaretColor {
}

#[pyproto]
impl PyObjectProtocol for AzCaretColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::CaretColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::CaretColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutSize {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutSize {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::LayoutSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::LayoutSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColumnFillEnumWrapper {
    #[classattr]
    const Auto: AzColumnFill = AzColumnFill::Auto;
    #[classattr]
    const Balance: AzColumnFill = AzColumnFill::Balance;
}

#[pyproto]
impl PyObjectProtocol for AzColumnFillEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnFill = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnFill = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzColumnFillEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSystemFonts {
}

#[pyproto]
impl PyObjectProtocol for AzSystemFonts {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::system::SystemFonts = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::system::SystemFonts = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFlowFromEnumWrapper {
    #[classattr]
    fn None() -> AzFlowFromEnumWrapper {
        AzFlowFromEnumWrapper { inner: AzFlowFrom::None }
    }
    #[staticmethod]
    fn Named(v: AzString) -> AzFlowFromEnumWrapper {
        AzFlowFromEnumWrapper { inner: AzFlowFrom::Named(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzFlowFrom;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzFlowFrom::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzFlowFrom::Named(v) => Ok(vec!["Named".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFlowFromEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flow::FlowFrom = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flow::FlowFrom = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPageBreakEnumWrapper {
    #[classattr]
    const Auto: AzPageBreak = AzPageBreak::Auto;
    #[classattr]
    const Avoid: AzPageBreak = AzPageBreak::Avoid;
    #[classattr]
    const Always: AzPageBreak = AzPageBreak::Always;
    #[classattr]
    const All: AzPageBreak = AzPageBreak::All;
    #[classattr]
    const Page: AzPageBreak = AzPageBreak::Page;
    #[classattr]
    const AvoidPage: AzPageBreak = AzPageBreak::AvoidPage;
    #[classattr]
    const Left: AzPageBreak = AzPageBreak::Left;
    #[classattr]
    const Right: AzPageBreak = AzPageBreak::Right;
    #[classattr]
    const Recto: AzPageBreak = AzPageBreak::Recto;
    #[classattr]
    const Verso: AzPageBreak = AzPageBreak::Verso;
    #[classattr]
    const Column: AzPageBreak = AzPageBreak::Column;
    #[classattr]
    const AvoidColumn: AzPageBreak = AzPageBreak::AvoidColumn;
}

#[pyproto]
impl PyObjectProtocol for AzPageBreakEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::fragmentation::PageBreak = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::fragmentation::PageBreak = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzPageBreakEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutScrollbarWidthEnumWrapper {
    #[classattr]
    const Auto: AzLayoutScrollbarWidth = AzLayoutScrollbarWidth::Auto;
    #[classattr]
    const Thin: AzLayoutScrollbarWidth = AzLayoutScrollbarWidth::Thin;
    #[classattr]
    const None: AzLayoutScrollbarWidth = AzLayoutScrollbarWidth::None;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutScrollbarWidthEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::LayoutScrollbarWidth = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::LayoutScrollbarWidth = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutScrollbarWidthEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleScrollbarColorEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleScrollbarColorEnumWrapper {
        AzStyleScrollbarColorEnumWrapper { inner: AzStyleScrollbarColor::Auto }
    }
    #[staticmethod]

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleScrollbarColor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleScrollbarColor::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleScrollbarColor::Custom(v) => Ok(vec!["Custom".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleScrollbarColorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::StyleScrollbarColor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::StyleScrollbarColor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRibbon {
}

#[pyproto]
impl PyObjectProtocol for AzRibbon {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::ribbon::Ribbon = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::ribbon::Ribbon = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRibbonOnTabClickedCallback {
}

#[pyproto]
impl PyObjectProtocol for AzRibbonOnTabClickedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::ribbon::RibbonOnTabClickedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::ribbon::RibbonOnTabClickedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzButton {
    #[new]
    fn new(/* args */) -> AzButton {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzButton {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::button::Button = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::button::Button = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzButtonOnClick {
}

#[pyproto]
impl PyObjectProtocol for AzButtonOnClick {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::button::ButtonOnClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::button::ButtonOnClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileInput {
    #[new]
    fn new(/* args */) -> AzFileInput {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_default_text(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_default_text(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzFileInput {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::file_input::FileInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::file_input::FileInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileInputStateWrapper {
}

#[pyproto]
impl PyObjectProtocol for AzFileInputStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::file_input::FileInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::file_input::FileInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileInputState {
}

#[pyproto]
impl PyObjectProtocol for AzFileInputState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::file_input::FileInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::file_input::FileInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileInputOnPathChange {
}

#[pyproto]
impl PyObjectProtocol for AzFileInputOnPathChange {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::file_input::FileInputOnPathChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::file_input::FileInputOnPathChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileInputOnPathChangeCallback {
}

#[pyproto]
impl PyObjectProtocol for AzFileInputOnPathChangeCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::file_input::FileInputOnPathChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::file_input::FileInputOnPathChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBox {
    #[new]
    fn new(/* args */) -> AzCheckBox {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzCheckBox {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::check_box::CheckBox = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::check_box::CheckBox = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBoxStateWrapper {
}

#[pyproto]
impl PyObjectProtocol for AzCheckBoxStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::check_box::CheckBoxStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::check_box::CheckBoxStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBoxOnToggle {
}

#[pyproto]
impl PyObjectProtocol for AzCheckBoxOnToggle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::check_box::CheckBoxOnToggle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::check_box::CheckBoxOnToggle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBoxOnToggleCallback {
}

#[pyproto]
impl PyObjectProtocol for AzCheckBoxOnToggleCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::check_box::CheckBoxOnToggleCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::check_box::CheckBoxOnToggleCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBoxState {
}

#[pyproto]
impl PyObjectProtocol for AzCheckBoxState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::check_box::CheckBoxState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::check_box::CheckBoxState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLabel {
    #[new]
    fn new(/* args */) -> AzLabel {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzLabel {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::label::Label = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::label::Label = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInput {
    #[new]
    fn new(/* args */) -> AzColorInput {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzColorInput {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::color_input::ColorInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::color_input::ColorInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInputStateWrapper {
}

#[pyproto]
impl PyObjectProtocol for AzColorInputStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::color_input::ColorInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::color_input::ColorInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInputState {
}

#[pyproto]
impl PyObjectProtocol for AzColorInputState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::color_input::ColorInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::color_input::ColorInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInputOnValueChange {
}

#[pyproto]
impl PyObjectProtocol for AzColorInputOnValueChange {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::color_input::ColorInputOnValueChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::color_input::ColorInputOnValueChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInputOnValueChangeCallback {
}

#[pyproto]
impl PyObjectProtocol for AzColorInputOnValueChangeCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::color_input::ColorInputOnValueChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::color_input::ColorInputOnValueChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInput {
    #[new]
    fn new(/* args */) -> AzTextInput {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_text(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_text(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_placeholder(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_placeholder(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_placeholder_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_placeholder_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_container_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_container_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_label_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_label_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzTextInput {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputStateWrapper {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputState {
    fn get_text(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzTextInputState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputSelectionEnumWrapper {
    #[classattr]
    fn All() -> AzTextInputSelectionEnumWrapper {
        AzTextInputSelectionEnumWrapper { inner: AzTextInputSelection::All }
    }
    #[staticmethod]
    fn FromTo(v: TextInputSelectionRange) -> AzTextInputSelectionEnumWrapper {
        AzTextInputSelectionEnumWrapper { inner: AzTextInputSelection::FromTo(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzTextInputSelection;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTextInputSelection::All => Ok(vec!["All".into_py(py), ().into_py(py)]),
            AzTextInputSelection::FromTo(v) => Ok(vec!["FromTo".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextInputSelectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputSelection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputSelection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputSelectionRange {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputSelectionRange {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputSelectionRange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputSelectionRange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnTextInput {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnTextInput {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputOnTextInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputOnTextInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnTextInputCallback {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnTextInputCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputOnTextInputCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputOnTextInputCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnVirtualKeyDown {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnVirtualKeyDown {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputOnVirtualKeyDown = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputOnVirtualKeyDown = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnVirtualKeyDownCallback {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnVirtualKeyDownCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputOnVirtualKeyDownCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputOnVirtualKeyDownCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnFocusLost {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnFocusLost {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputOnFocusLost = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputOnFocusLost = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnFocusLostCallback {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnFocusLostCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputOnFocusLostCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputOnFocusLostCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnTextInputReturn {
}

#[pyproto]
impl PyObjectProtocol for AzOnTextInputReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::OnTextInputReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::OnTextInputReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputValidEnumWrapper {
    #[classattr]
    const Yes: AzTextInputValid = AzTextInputValid::Yes;
    #[classattr]
    const No: AzTextInputValid = AzTextInputValid::No;
}

#[pyproto]
impl PyObjectProtocol for AzTextInputValidEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputValid = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::text_input::TextInputValid = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzTextInputValidEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzNumberInput {
    #[new]
    fn new(/* args */) -> AzNumberInput {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_placeholder_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_placeholder_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_container_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_container_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_label_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_label_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzNumberInput {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::number_input::NumberInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::number_input::NumberInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputStateWrapper {
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::number_input::NumberInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::number_input::NumberInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputState {
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::number_input::NumberInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::number_input::NumberInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputOnValueChange {
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputOnValueChange {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::number_input::NumberInputOnValueChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::number_input::NumberInputOnValueChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputOnValueChangeCallback {
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputOnValueChangeCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::number_input::NumberInputOnValueChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::number_input::NumberInputOnValueChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputOnFocusLost {
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputOnFocusLost {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::number_input::NumberInputOnFocusLost = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::number_input::NumberInputOnFocusLost = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputOnFocusLostCallback {
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputOnFocusLostCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::number_input::NumberInputOnFocusLostCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::number_input::NumberInputOnFocusLostCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzProgressBar {
    #[new]
    fn new(/* args */) -> AzProgressBar {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_height(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_height(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_container_background(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_container_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_bar_background(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_bar_background(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzProgressBar {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::progressbar::ProgressBar = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::progressbar::ProgressBar = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzProgressBarState {
}

#[pyproto]
impl PyObjectProtocol for AzProgressBarState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::progressbar::ProgressBarState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::progressbar::ProgressBarState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabHeader {
    #[new]
    fn new(/* args */) -> AzTabHeader {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_active_tab(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_active_tab(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzTabHeader {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::tabs::TabHeader = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::tabs::TabHeader = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabHeaderState {
}

#[pyproto]
impl PyObjectProtocol for AzTabHeaderState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::tabs::TabHeaderState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::tabs::TabHeaderState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabContent {
    #[new]
    fn new(/* args */) -> AzTabContent {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_padding(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_padding(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzTabContent {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::tabs::TabContent = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::tabs::TabContent = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabOnClick {
}

#[pyproto]
impl PyObjectProtocol for AzTabOnClick {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::tabs::TabOnClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::tabs::TabOnClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabOnClickCallback {
}

#[pyproto]
impl PyObjectProtocol for AzTabOnClickCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::tabs::TabOnClickCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::tabs::TabOnClickCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFrame {
    #[new]
    fn new(/* args */) -> AzFrame {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_flex_grow(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_flex_grow(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzFrame {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::frame::Frame = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::frame::Frame = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraph {
    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeGraph {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeGraph = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeGraph = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeIdInfoMap {
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeIdInfoMap {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeTypeIdInfoMap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeTypeIdInfoMap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeIdInfoMap {
}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeIdInfoMap {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::InputOutputTypeIdInfoMap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::InputOutputTypeIdInfoMap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdNodeMap {
}

#[pyproto]
impl PyObjectProtocol for AzNodeIdNodeMap {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeIdNodeMap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeIdNodeMap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphStyleEnumWrapper {
    #[classattr]
    const Default: AzNodeGraphStyle = AzNodeGraphStyle::Default;
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphStyleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeGraphStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeGraphStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzNodeGraphStyleEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzNodeGraphCallbacks {
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphCallbacks {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeGraphCallbacks = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeGraphCallbacks = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDropDownOnChoiceChange {
}

#[pyproto]
impl PyObjectProtocol for AzDropDownOnChoiceChange {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::drop_down::DropDownOnChoiceChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::drop_down::DropDownOnChoiceChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnNodeAddedCallback {
}

#[pyproto]
impl PyObjectProtocol for AzOnNodeAddedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeAddedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeAddedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnNodeAdded {
}

#[pyproto]
impl PyObjectProtocol for AzOnNodeAdded {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeAdded = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeAdded = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnNodeRemovedCallback {
}

#[pyproto]
impl PyObjectProtocol for AzOnNodeRemovedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeRemovedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeRemovedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnNodeRemoved {
}

#[pyproto]
impl PyObjectProtocol for AzOnNodeRemoved {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeRemoved = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeRemoved = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnNodeGraphDraggedCallback {
}

#[pyproto]
impl PyObjectProtocol for AzOnNodeGraphDraggedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeGraphDraggedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeGraphDraggedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnNodeGraphDragged {
}

#[pyproto]
impl PyObjectProtocol for AzOnNodeGraphDragged {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeGraphDragged = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeGraphDragged = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnNodeDraggedCallback {
}

#[pyproto]
impl PyObjectProtocol for AzOnNodeDraggedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeDraggedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeDraggedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnNodeDragged {
}

#[pyproto]
impl PyObjectProtocol for AzOnNodeDragged {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeDragged = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeDragged = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnNodeConnectedCallback {
}

#[pyproto]
impl PyObjectProtocol for AzOnNodeConnectedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeConnectedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeConnectedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnNodeConnected {
}

#[pyproto]
impl PyObjectProtocol for AzOnNodeConnected {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeConnected = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeConnected = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnNodeInputDisconnectedCallback {
}

#[pyproto]
impl PyObjectProtocol for AzOnNodeInputDisconnectedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeInputDisconnectedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeInputDisconnectedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnNodeInputDisconnected {
}

#[pyproto]
impl PyObjectProtocol for AzOnNodeInputDisconnected {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeInputDisconnected = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeInputDisconnected = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnNodeOutputDisconnectedCallback {
}

#[pyproto]
impl PyObjectProtocol for AzOnNodeOutputDisconnectedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeOutputDisconnectedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeOutputDisconnectedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnNodeOutputDisconnected {
}

#[pyproto]
impl PyObjectProtocol for AzOnNodeOutputDisconnected {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeOutputDisconnected = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeOutputDisconnected = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnNodeFieldEditedCallback {
}

#[pyproto]
impl PyObjectProtocol for AzOnNodeFieldEditedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeFieldEditedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeFieldEditedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeId {
}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::InputOutputTypeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::InputOutputTypeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeId {
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeTypeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeTypeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphNodeId {
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphNodeId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeGraphNodeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeGraphNodeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNode {
}

#[pyproto]
impl PyObjectProtocol for AzNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::Node = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::Node = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeField {
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeField {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeTypeField = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeTypeField = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeFieldValueEnumWrapper {
    #[staticmethod]
    fn TextInput(v: AzString) -> AzNodeTypeFieldValueEnumWrapper {
        AzNodeTypeFieldValueEnumWrapper { inner: AzNodeTypeFieldValue::TextInput(v) }}
    }
    #[staticmethod]
    fn NumberInput(v: f32) -> AzNodeTypeFieldValueEnumWrapper {
        AzNodeTypeFieldValueEnumWrapper { inner: AzNodeTypeFieldValue::NumberInput(v) }}
    }
    #[staticmethod]
    fn CheckBox(v: bool) -> AzNodeTypeFieldValueEnumWrapper {
        AzNodeTypeFieldValueEnumWrapper { inner: AzNodeTypeFieldValue::CheckBox(v) }}
    }
    #[staticmethod]
    fn ColorInput(v: ColorU) -> AzNodeTypeFieldValueEnumWrapper {
        AzNodeTypeFieldValueEnumWrapper { inner: AzNodeTypeFieldValue::ColorInput(v) }}
    }
    #[staticmethod]
    fn FileInput(v: OptionAzString) -> AzNodeTypeFieldValueEnumWrapper {
        AzNodeTypeFieldValueEnumWrapper { inner: AzNodeTypeFieldValue::FileInput(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeTypeFieldValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeTypeFieldValue::TextInput(v) => Ok(vec!["TextInput".into_py(py), v.into_py(py)]),
            AzNodeTypeFieldValue::NumberInput(v) => Ok(vec!["NumberInput".into_py(py), v.into_py(py)]),
            AzNodeTypeFieldValue::CheckBox(v) => Ok(vec!["CheckBox".into_py(py), v.into_py(py)]),
            AzNodeTypeFieldValue::ColorInput(v) => Ok(vec!["ColorInput".into_py(py), v.into_py(py)]),
            AzNodeTypeFieldValue::FileInput(v) => Ok(vec!["FileInput".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeFieldValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeTypeFieldValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeTypeFieldValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputConnection {
}

#[pyproto]
impl PyObjectProtocol for AzInputConnection {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::InputConnection = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::InputConnection = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputNodeAndIndex {
}

#[pyproto]
impl PyObjectProtocol for AzOutputNodeAndIndex {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OutputNodeAndIndex = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OutputNodeAndIndex = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputConnection {
}

#[pyproto]
impl PyObjectProtocol for AzOutputConnection {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OutputConnection = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OutputConnection = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputNodeAndIndex {
}

#[pyproto]
impl PyObjectProtocol for AzInputNodeAndIndex {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::InputNodeAndIndex = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::InputNodeAndIndex = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeInfo {
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeTypeInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeTypeInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputInfo {
}

#[pyproto]
impl PyObjectProtocol for AzInputOutputInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::InputOutputInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::InputOutputInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodePosition {
}

#[pyproto]
impl PyObjectProtocol for AzNodePosition {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodePosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodePosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGraphDragAmount {
}

#[pyproto]
impl PyObjectProtocol for AzGraphDragAmount {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::GraphDragAmount = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::GraphDragAmount = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDragAmount {
}

#[pyproto]
impl PyObjectProtocol for AzNodeDragAmount {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeDragAmount = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::NodeDragAmount = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListView {
    #[new]
    fn new(/* args */) -> AzListView {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn with_rows(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzListView {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListView = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListView = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewRow {
}

#[pyproto]
impl PyObjectProtocol for AzListViewRow {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListViewRow = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListViewRow = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewState {
}

#[pyproto]
impl PyObjectProtocol for AzListViewState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListViewState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListViewState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnLazyLoadScrollCallback {
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnLazyLoadScrollCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListViewOnLazyLoadScrollCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListViewOnLazyLoadScrollCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnLazyLoadScroll {
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnLazyLoadScroll {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListViewOnLazyLoadScroll = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListViewOnLazyLoadScroll = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnColumnClickCallback {
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnColumnClickCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListViewOnColumnClickCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListViewOnColumnClickCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnColumnClick {
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnColumnClick {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListViewOnColumnClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListViewOnColumnClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnRowClickCallback {
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnRowClickCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListViewOnRowClickCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListViewOnRowClickCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnRowClick {
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnRowClick {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListViewOnRowClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::list_view::ListViewOnRowClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTreeView {
    #[new]
    fn new(/* args */) -> AzTreeView {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzTreeView {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::tree_view::TreeView = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::tree_view::TreeView = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDropDown {
    #[new]
    fn new(/* args */) -> AzDropDown {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzDropDown {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::drop_down::DropDown = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::drop_down::DropDown = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDropDownOnChoiceChangeCallback {
}

#[pyproto]
impl PyObjectProtocol for AzDropDownOnChoiceChangeCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::drop_down::DropDownOnChoiceChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::drop_down::DropDownOnChoiceChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnNodeFieldEdited {
}

#[pyproto]
impl PyObjectProtocol for AzOnNodeFieldEdited {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeFieldEdited = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::node_graph::OnNodeFieldEdited = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeHierarchyItem {
}

#[pyproto]
impl PyObjectProtocol for AzNodeHierarchyItem {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeHierarchyItem = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeHierarchyItem = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCascadeInfo {
}

#[pyproto]
impl PyObjectProtocol for AzCascadeInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::style::CascadeInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::style::CascadeInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertySourceEnumWrapper {
    #[staticmethod]
    fn Css(v: CssPath) -> AzCssPropertySourceEnumWrapper {
        AzCssPropertySourceEnumWrapper { inner: AzCssPropertySource::Css(v) }}
    }
    #[classattr]
    fn Inline() -> AzCssPropertySourceEnumWrapper {
        AzCssPropertySourceEnumWrapper { inner: AzCssPropertySource::Inline }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssPropertySource;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPropertySource::Css(v) => Ok(vec!["Css".into_py(py), v.into_py(py)]),
            AzCssPropertySource::Inline => Ok(vec!["Inline".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertySourceEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::CssPropertySource = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::CssPropertySource = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledNodeState {
}

#[pyproto]
impl PyObjectProtocol for AzStyledNodeState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledNodeState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledNodeState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledNode {
}

#[pyproto]
impl PyObjectProtocol for AzStyledNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledDom {
    #[new]
    fn new(/* args */) -> AzStyledDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn default(/* args */) -> AzStyledDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn from_xml(/* args */) -> AzStyledDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn from_file(/* args */) -> AzStyledDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn append_child(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_child(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn restyle(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn node_count(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_html_string(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_html_string_test(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_menu_bar(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_menu_bar(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_context_menu(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_context_menu(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyledDom {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledDom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledDom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTagIdToNodeIdMapping {
}

#[pyproto]
impl PyObjectProtocol for AzTagIdToNodeIdMapping {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::TagIdToNodeIdMapping = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::TagIdToNodeIdMapping = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzParentWithNodeDepth {
}

#[pyproto]
impl PyObjectProtocol for AzParentWithNodeDepth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::ParentWithNodeDepth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::ParentWithNodeDepth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAzTagId {
}

#[pyproto]
impl PyObjectProtocol for AzAzTagId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::AzTagId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::AzTagId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyCachePtr {
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyCachePtr {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::CssPropertyCachePtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::CssPropertyCachePtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTexture {
    #[new]
    fn new(/* args */) -> AzTexture {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn allocate_rgba8(/* args */) -> AzTexture {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn allocate_clip_mask(/* args */) -> AzTexture {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn clear(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn draw_clip_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn apply_fxaa(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzTexture {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::Texture = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::Texture = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlVoidPtrConst {
}

#[pyproto]
impl PyObjectProtocol for AzGlVoidPtrConst {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlVoidPtrConst = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlVoidPtrConst = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlVoidPtrMut {
}

#[pyproto]
impl PyObjectProtocol for AzGlVoidPtrMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlVoidPtrMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlVoidPtrMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextureFlags {
    #[staticmethod]
    fn default(/* args */) -> AzTextureFlags {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzTextureFlags {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::TextureFlags = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::TextureFlags = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlShaderPrecisionFormatReturn {
}

#[pyproto]
impl PyObjectProtocol for AzGlShaderPrecisionFormatReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlShaderPrecisionFormatReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlShaderPrecisionFormatReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexAttributeTypeEnumWrapper {
    #[classattr]
    const Float: AzVertexAttributeType = AzVertexAttributeType::Float;
    #[classattr]
    const Double: AzVertexAttributeType = AzVertexAttributeType::Double;
    #[classattr]
    const UnsignedByte: AzVertexAttributeType = AzVertexAttributeType::UnsignedByte;
    #[classattr]
    const UnsignedShort: AzVertexAttributeType = AzVertexAttributeType::UnsignedShort;
    #[classattr]
    const UnsignedInt: AzVertexAttributeType = AzVertexAttributeType::UnsignedInt;
}

#[pyproto]
impl PyObjectProtocol for AzVertexAttributeTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexAttributeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexAttributeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzVertexAttributeTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzVertexAttribute {
}

#[pyproto]
impl PyObjectProtocol for AzVertexAttribute {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexAttribute = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexAttribute = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexLayout {
}

#[pyproto]
impl PyObjectProtocol for AzVertexLayout {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexLayout = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexLayout = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexArrayObject {
    #[new]
    fn new(/* args */) -> AzVertexArrayObject {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzVertexArrayObject {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexArrayObject = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexArrayObject = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIndexBufferFormatEnumWrapper {
    #[classattr]
    const Points: AzIndexBufferFormat = AzIndexBufferFormat::Points;
    #[classattr]
    const Lines: AzIndexBufferFormat = AzIndexBufferFormat::Lines;
    #[classattr]
    const LineStrip: AzIndexBufferFormat = AzIndexBufferFormat::LineStrip;
    #[classattr]
    const Triangles: AzIndexBufferFormat = AzIndexBufferFormat::Triangles;
    #[classattr]
    const TriangleStrip: AzIndexBufferFormat = AzIndexBufferFormat::TriangleStrip;
    #[classattr]
    const TriangleFan: AzIndexBufferFormat = AzIndexBufferFormat::TriangleFan;
}

#[pyproto]
impl PyObjectProtocol for AzIndexBufferFormatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::IndexBufferFormat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::IndexBufferFormat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzIndexBufferFormatEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzVertexBuffer {
    #[new]
    fn new(/* args */) -> AzVertexBuffer {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzVertexBuffer {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexBuffer = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexBuffer = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlContextPtr {
    #[classattr]
    const ACCUM: u32 = 0x0100;
    #[classattr]
    const ACCUM_ALPHA_BITS: u32 = 0x0D5B;
    #[classattr]
    const ACCUM_BLUE_BITS: u32 = 0x0D5A;
    #[classattr]
    const ACCUM_BUFFER_BIT: u32 = 0x00000200;
    #[classattr]
    const ACCUM_CLEAR_VALUE: u32 = 0x0B80;
    #[classattr]
    const ACCUM_GREEN_BITS: u32 = 0x0D59;
    #[classattr]
    const ACCUM_RED_BITS: u32 = 0x0D58;
    #[classattr]
    const ACTIVE_ATTRIBUTES: u32 = 0x8B89;
    #[classattr]
    const ACTIVE_ATTRIBUTE_MAX_LENGTH: u32 = 0x8B8A;
    #[classattr]
    const ACTIVE_TEXTURE: u32 = 0x84E0;
    #[classattr]
    const ACTIVE_UNIFORMS: u32 = 0x8B86;
    #[classattr]
    const ACTIVE_UNIFORM_BLOCKS: u32 = 0x8A36;
    #[classattr]
    const ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: u32 = 0x8A35;
    #[classattr]
    const ACTIVE_UNIFORM_MAX_LENGTH: u32 = 0x8B87;
    #[classattr]
    const ADD: u32 = 0x0104;
    #[classattr]
    const ADD_SIGNED: u32 = 0x8574;
    #[classattr]
    const ALIASED_LINE_WIDTH_RANGE: u32 = 0x846E;
    #[classattr]
    const ALIASED_POINT_SIZE_RANGE: u32 = 0x846D;
    #[classattr]
    const ALL_ATTRIB_BITS: u32 = 0xFFFFFFFF;
    #[classattr]
    const ALPHA: u32 = 0x1906;
    #[classattr]
    const ALPHA12: u32 = 0x803D;
    #[classattr]
    const ALPHA16: u32 = 0x803E;
    #[classattr]
    const ALPHA16F_EXT: u32 = 0x881C;
    #[classattr]
    const ALPHA32F_EXT: u32 = 0x8816;
    #[classattr]
    const ALPHA4: u32 = 0x803B;
    #[classattr]
    const ALPHA8: u32 = 0x803C;
    #[classattr]
    const ALPHA8_EXT: u32 = 0x803C;
    #[classattr]
    const ALPHA_BIAS: u32 = 0x0D1D;
    #[classattr]
    const ALPHA_BITS: u32 = 0x0D55;
    #[classattr]
    const ALPHA_INTEGER: u32 = 0x8D97;
    #[classattr]
    const ALPHA_SCALE: u32 = 0x0D1C;
    #[classattr]
    const ALPHA_TEST: u32 = 0x0BC0;
    #[classattr]
    const ALPHA_TEST_FUNC: u32 = 0x0BC1;
    #[classattr]
    const ALPHA_TEST_REF: u32 = 0x0BC2;
    #[classattr]
    const ALREADY_SIGNALED: u32 = 0x911A;
    #[classattr]
    const ALWAYS: u32 = 0x0207;
    #[classattr]
    const AMBIENT: u32 = 0x1200;
    #[classattr]
    const AMBIENT_AND_DIFFUSE: u32 = 0x1602;
    #[classattr]
    const AND: u32 = 0x1501;
    #[classattr]
    const AND_INVERTED: u32 = 0x1504;
    #[classattr]
    const AND_REVERSE: u32 = 0x1502;
    #[classattr]
    const ANY_SAMPLES_PASSED: u32 = 0x8C2F;
    #[classattr]
    const ANY_SAMPLES_PASSED_CONSERVATIVE: u32 = 0x8D6A;
    #[classattr]
    const ARRAY_BUFFER: u32 = 0x8892;
    #[classattr]
    const ARRAY_BUFFER_BINDING: u32 = 0x8894;
    #[classattr]
    const ATTACHED_SHADERS: u32 = 0x8B85;
    #[classattr]
    const ATTRIB_STACK_DEPTH: u32 = 0x0BB0;
    #[classattr]
    const AUTO_NORMAL: u32 = 0x0D80;
    #[classattr]
    const AUX0: u32 = 0x0409;
    #[classattr]
    const AUX1: u32 = 0x040A;
    #[classattr]
    const AUX2: u32 = 0x040B;
    #[classattr]
    const AUX3: u32 = 0x040C;
    #[classattr]
    const AUX_BUFFERS: u32 = 0x0C00;
    #[classattr]
    const BACK: u32 = 0x0405;
    #[classattr]
    const BACK_LEFT: u32 = 0x0402;
    #[classattr]
    const BACK_RIGHT: u32 = 0x0403;
    #[classattr]
    const BGR: u32 = 0x80E0;
    #[classattr]
    const BGRA: u32 = 0x80E1;
    #[classattr]
    const BGRA8_EXT: u32 = 0x93A1;
    #[classattr]
    const BGRA_EXT: u32 = 0x80E1;
    #[classattr]
    const BGRA_INTEGER: u32 = 0x8D9B;
    #[classattr]
    const BGR_INTEGER: u32 = 0x8D9A;
    #[classattr]
    const BITMAP: u32 = 0x1A00;
    #[classattr]
    const BITMAP_TOKEN: u32 = 0x0704;
    #[classattr]
    const BLEND: u32 = 0x0BE2;
    #[classattr]
    const BLEND_ADVANCED_COHERENT_KHR: u32 = 0x9285;
    #[classattr]
    const BLEND_COLOR: u32 = 0x8005;
    #[classattr]
    const BLEND_DST: u32 = 0x0BE0;
    #[classattr]
    const BLEND_DST_ALPHA: u32 = 0x80CA;
    #[classattr]
    const BLEND_DST_RGB: u32 = 0x80C8;
    #[classattr]
    const BLEND_EQUATION: u32 = 0x8009;
    #[classattr]
    const BLEND_EQUATION_ALPHA: u32 = 0x883D;
    #[classattr]
    const BLEND_EQUATION_RGB: u32 = 0x8009;
    #[classattr]
    const BLEND_SRC: u32 = 0x0BE1;
    #[classattr]
    const BLEND_SRC_ALPHA: u32 = 0x80CB;
    #[classattr]
    const BLEND_SRC_RGB: u32 = 0x80C9;
    #[classattr]
    const BLUE: u32 = 0x1905;
    #[classattr]
    const BLUE_BIAS: u32 = 0x0D1B;
    #[classattr]
    const BLUE_BITS: u32 = 0x0D54;
    #[classattr]
    const BLUE_INTEGER: u32 = 0x8D96;
    #[classattr]
    const BLUE_SCALE: u32 = 0x0D1A;
    #[classattr]
    const BOOL: u32 = 0x8B56;
    #[classattr]
    const BOOL_VEC2: u32 = 0x8B57;
    #[classattr]
    const BOOL_VEC3: u32 = 0x8B58;
    #[classattr]
    const BOOL_VEC4: u32 = 0x8B59;
    #[classattr]
    const BUFFER: u32 = 0x82E0;
    #[classattr]
    const BUFFER_ACCESS: u32 = 0x88BB;
    #[classattr]
    const BUFFER_ACCESS_FLAGS: u32 = 0x911F;
    #[classattr]
    const BUFFER_KHR: u32 = 0x82E0;
    #[classattr]
    const BUFFER_MAPPED: u32 = 0x88BC;
    #[classattr]
    const BUFFER_MAP_LENGTH: u32 = 0x9120;
    #[classattr]
    const BUFFER_MAP_OFFSET: u32 = 0x9121;
    #[classattr]
    const BUFFER_MAP_POINTER: u32 = 0x88BD;
    #[classattr]
    const BUFFER_SIZE: u32 = 0x8764;
    #[classattr]
    const BUFFER_USAGE: u32 = 0x8765;
    #[classattr]
    const BYTE: u32 = 0x1400;
    #[classattr]
    const C3F_V3F: u32 = 0x2A24;
    #[classattr]
    const C4F_N3F_V3F: u32 = 0x2A26;
    #[classattr]
    const C4UB_V2F: u32 = 0x2A22;
    #[classattr]
    const C4UB_V3F: u32 = 0x2A23;
    #[classattr]
    const CCW: u32 = 0x0901;
    #[classattr]
    const CLAMP: u32 = 0x2900;
    #[classattr]
    const CLAMP_FRAGMENT_COLOR: u32 = 0x891B;
    #[classattr]
    const CLAMP_READ_COLOR: u32 = 0x891C;
    #[classattr]
    const CLAMP_TO_BORDER: u32 = 0x812D;
    #[classattr]
    const CLAMP_TO_EDGE: u32 = 0x812F;
    #[classattr]
    const CLAMP_VERTEX_COLOR: u32 = 0x891A;
    #[classattr]
    const CLEAR: u32 = 0x1500;
    #[classattr]
    const CLIENT_ACTIVE_TEXTURE: u32 = 0x84E1;
    #[classattr]
    const CLIENT_ALL_ATTRIB_BITS: u32 = 0xFFFFFFFF;
    #[classattr]
    const CLIENT_ATTRIB_STACK_DEPTH: u32 = 0x0BB1;
    #[classattr]
    const CLIENT_PIXEL_STORE_BIT: u32 = 0x00000001;
    #[classattr]
    const CLIENT_VERTEX_ARRAY_BIT: u32 = 0x00000002;
    #[classattr]
    const CLIP_DISTANCE0: u32 = 0x3000;
    #[classattr]
    const CLIP_DISTANCE1: u32 = 0x3001;
    #[classattr]
    const CLIP_DISTANCE2: u32 = 0x3002;
    #[classattr]
    const CLIP_DISTANCE3: u32 = 0x3003;
    #[classattr]
    const CLIP_DISTANCE4: u32 = 0x3004;
    #[classattr]
    const CLIP_DISTANCE5: u32 = 0x3005;
    #[classattr]
    const CLIP_DISTANCE6: u32 = 0x3006;
    #[classattr]
    const CLIP_DISTANCE7: u32 = 0x3007;
    #[classattr]
    const CLIP_PLANE0: u32 = 0x3000;
    #[classattr]
    const CLIP_PLANE1: u32 = 0x3001;
    #[classattr]
    const CLIP_PLANE2: u32 = 0x3002;
    #[classattr]
    const CLIP_PLANE3: u32 = 0x3003;
    #[classattr]
    const CLIP_PLANE4: u32 = 0x3004;
    #[classattr]
    const CLIP_PLANE5: u32 = 0x3005;
    #[classattr]
    const COEFF: u32 = 0x0A00;
    #[classattr]
    const COLOR: u32 = 0x1800;
    #[classattr]
    const COLORBURN_KHR: u32 = 0x929A;
    #[classattr]
    const COLORDODGE_KHR: u32 = 0x9299;
    #[classattr]
    const COLOR_ARRAY: u32 = 0x8076;
    #[classattr]
    const COLOR_ARRAY_BUFFER_BINDING: u32 = 0x8898;
    #[classattr]
    const COLOR_ARRAY_POINTER: u32 = 0x8090;
    #[classattr]
    const COLOR_ARRAY_SIZE: u32 = 0x8081;
    #[classattr]
    const COLOR_ARRAY_STRIDE: u32 = 0x8083;
    #[classattr]
    const COLOR_ARRAY_TYPE: u32 = 0x8082;
    #[classattr]
    const COLOR_ATTACHMENT0: u32 = 0x8CE0;
    #[classattr]
    const COLOR_ATTACHMENT1: u32 = 0x8CE1;
    #[classattr]
    const COLOR_ATTACHMENT10: u32 = 0x8CEA;
    #[classattr]
    const COLOR_ATTACHMENT11: u32 = 0x8CEB;
    #[classattr]
    const COLOR_ATTACHMENT12: u32 = 0x8CEC;
    #[classattr]
    const COLOR_ATTACHMENT13: u32 = 0x8CED;
    #[classattr]
    const COLOR_ATTACHMENT14: u32 = 0x8CEE;
    #[classattr]
    const COLOR_ATTACHMENT15: u32 = 0x8CEF;
    #[classattr]
    const COLOR_ATTACHMENT16: u32 = 0x8CF0;
    #[classattr]
    const COLOR_ATTACHMENT17: u32 = 0x8CF1;
    #[classattr]
    const COLOR_ATTACHMENT18: u32 = 0x8CF2;
    #[classattr]
    const COLOR_ATTACHMENT19: u32 = 0x8CF3;
    #[classattr]
    const COLOR_ATTACHMENT2: u32 = 0x8CE2;
    #[classattr]
    const COLOR_ATTACHMENT20: u32 = 0x8CF4;
    #[classattr]
    const COLOR_ATTACHMENT21: u32 = 0x8CF5;
    #[classattr]
    const COLOR_ATTACHMENT22: u32 = 0x8CF6;
    #[classattr]
    const COLOR_ATTACHMENT23: u32 = 0x8CF7;
    #[classattr]
    const COLOR_ATTACHMENT24: u32 = 0x8CF8;
    #[classattr]
    const COLOR_ATTACHMENT25: u32 = 0x8CF9;
    #[classattr]
    const COLOR_ATTACHMENT26: u32 = 0x8CFA;
    #[classattr]
    const COLOR_ATTACHMENT27: u32 = 0x8CFB;
    #[classattr]
    const COLOR_ATTACHMENT28: u32 = 0x8CFC;
    #[classattr]
    const COLOR_ATTACHMENT29: u32 = 0x8CFD;
    #[classattr]
    const COLOR_ATTACHMENT3: u32 = 0x8CE3;
    #[classattr]
    const COLOR_ATTACHMENT30: u32 = 0x8CFE;
    #[classattr]
    const COLOR_ATTACHMENT31: u32 = 0x8CFF;
    #[classattr]
    const COLOR_ATTACHMENT4: u32 = 0x8CE4;
    #[classattr]
    const COLOR_ATTACHMENT5: u32 = 0x8CE5;
    #[classattr]
    const COLOR_ATTACHMENT6: u32 = 0x8CE6;
    #[classattr]
    const COLOR_ATTACHMENT7: u32 = 0x8CE7;
    #[classattr]
    const COLOR_ATTACHMENT8: u32 = 0x8CE8;
    #[classattr]
    const COLOR_ATTACHMENT9: u32 = 0x8CE9;
    #[classattr]
    const COLOR_BUFFER_BIT: u32 = 0x00004000;
    #[classattr]
    const COLOR_CLEAR_VALUE: u32 = 0x0C22;
    #[classattr]
    const COLOR_INDEX: u32 = 0x1900;
    #[classattr]
    const COLOR_INDEXES: u32 = 0x1603;
    #[classattr]
    const COLOR_LOGIC_OP: u32 = 0x0BF2;
    #[classattr]
    const COLOR_MATERIAL: u32 = 0x0B57;
    #[classattr]
    const COLOR_MATERIAL_FACE: u32 = 0x0B55;
    #[classattr]
    const COLOR_MATERIAL_PARAMETER: u32 = 0x0B56;
    #[classattr]
    const COLOR_SUM: u32 = 0x8458;
    #[classattr]
    const COLOR_WRITEMASK: u32 = 0x0C23;
    #[classattr]
    const COMBINE: u32 = 0x8570;
    #[classattr]
    const COMBINE_ALPHA: u32 = 0x8572;
    #[classattr]
    const COMBINE_RGB: u32 = 0x8571;
    #[classattr]
    const COMPARE_REF_TO_TEXTURE: u32 = 0x884E;
    #[classattr]
    const COMPARE_R_TO_TEXTURE: u32 = 0x884E;
    #[classattr]
    const COMPILE: u32 = 0x1300;
    #[classattr]
    const COMPILE_AND_EXECUTE: u32 = 0x1301;
    #[classattr]
    const COMPILE_STATUS: u32 = 0x8B81;
    #[classattr]
    const COMPRESSED_ALPHA: u32 = 0x84E9;
    #[classattr]
    const COMPRESSED_INTENSITY: u32 = 0x84EC;
    #[classattr]
    const COMPRESSED_LUMINANCE: u32 = 0x84EA;
    #[classattr]
    const COMPRESSED_LUMINANCE_ALPHA: u32 = 0x84EB;
    #[classattr]
    const COMPRESSED_R11_EAC: u32 = 0x9270;
    #[classattr]
    const COMPRESSED_RED: u32 = 0x8225;
    #[classattr]
    const COMPRESSED_RED_RGTC1: u32 = 0x8DBB;
    #[classattr]
    const COMPRESSED_RG: u32 = 0x8226;
    #[classattr]
    const COMPRESSED_RG11_EAC: u32 = 0x9272;
    #[classattr]
    const COMPRESSED_RGB: u32 = 0x84ED;
    #[classattr]
    const COMPRESSED_RGB8_ETC2: u32 = 0x9274;
    #[classattr]
    const COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9276;
    #[classattr]
    const COMPRESSED_RGBA: u32 = 0x84EE;
    #[classattr]
    const COMPRESSED_RGBA8_ETC2_EAC: u32 = 0x9278;
    #[classattr]
    const COMPRESSED_RG_RGTC2: u32 = 0x8DBD;
    #[classattr]
    const COMPRESSED_SIGNED_R11_EAC: u32 = 0x9271;
    #[classattr]
    const COMPRESSED_SIGNED_RED_RGTC1: u32 = 0x8DBC;
    #[classattr]
    const COMPRESSED_SIGNED_RG11_EAC: u32 = 0x9273;
    #[classattr]
    const COMPRESSED_SIGNED_RG_RGTC2: u32 = 0x8DBE;
    #[classattr]
    const COMPRESSED_SLUMINANCE: u32 = 0x8C4A;
    #[classattr]
    const COMPRESSED_SLUMINANCE_ALPHA: u32 = 0x8C4B;
    #[classattr]
    const COMPRESSED_SRGB: u32 = 0x8C48;
    #[classattr]
    const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: u32 = 0x9279;
    #[classattr]
    const COMPRESSED_SRGB8_ETC2: u32 = 0x9275;
    #[classattr]
    const COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9277;
    #[classattr]
    const COMPRESSED_SRGB_ALPHA: u32 = 0x8C49;
    #[classattr]
    const COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A3;
    #[classattr]
    const CONDITION_SATISFIED: u32 = 0x911C;
    #[classattr]
    const CONSTANT: u32 = 0x8576;
    #[classattr]
    const CONSTANT_ALPHA: u32 = 0x8003;
    #[classattr]
    const CONSTANT_ATTENUATION: u32 = 0x1207;
    #[classattr]
    const CONSTANT_COLOR: u32 = 0x8001;
    #[classattr]
    const CONTEXT_COMPATIBILITY_PROFILE_BIT: u32 = 0x00000002;
    #[classattr]
    const CONTEXT_CORE_PROFILE_BIT: u32 = 0x00000001;
    #[classattr]
    const CONTEXT_FLAGS: u32 = 0x821E;
    #[classattr]
    const CONTEXT_FLAG_DEBUG_BIT: u32 = 0x00000002;
    #[classattr]
    const CONTEXT_FLAG_DEBUG_BIT_KHR: u32 = 0x00000002;
    #[classattr]
    const CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: u32 = 0x00000001;
    #[classattr]
    const CONTEXT_PROFILE_MASK: u32 = 0x9126;
    #[classattr]
    const COORD_REPLACE: u32 = 0x8862;
    #[classattr]
    const COPY: u32 = 0x1503;
    #[classattr]
    const COPY_INVERTED: u32 = 0x150C;
    #[classattr]
    const COPY_PIXEL_TOKEN: u32 = 0x0706;
    #[classattr]
    const COPY_READ_BUFFER: u32 = 0x8F36;
    #[classattr]
    const COPY_READ_BUFFER_BINDING: u32 = 0x8F36;
    #[classattr]
    const COPY_WRITE_BUFFER: u32 = 0x8F37;
    #[classattr]
    const COPY_WRITE_BUFFER_BINDING: u32 = 0x8F37;
    #[classattr]
    const CULL_FACE: u32 = 0x0B44;
    #[classattr]
    const CULL_FACE_MODE: u32 = 0x0B45;
    #[classattr]
    const CURRENT_BIT: u32 = 0x00000001;
    #[classattr]
    const CURRENT_COLOR: u32 = 0x0B00;
    #[classattr]
    const CURRENT_FOG_COORD: u32 = 0x8453;
    #[classattr]
    const CURRENT_FOG_COORDINATE: u32 = 0x8453;
    #[classattr]
    const CURRENT_INDEX: u32 = 0x0B01;
    #[classattr]
    const CURRENT_NORMAL: u32 = 0x0B02;
    #[classattr]
    const CURRENT_PROGRAM: u32 = 0x8B8D;
    #[classattr]
    const CURRENT_QUERY: u32 = 0x8865;
    #[classattr]
    const CURRENT_QUERY_EXT: u32 = 0x8865;
    #[classattr]
    const CURRENT_RASTER_COLOR: u32 = 0x0B04;
    #[classattr]
    const CURRENT_RASTER_DISTANCE: u32 = 0x0B09;
    #[classattr]
    const CURRENT_RASTER_INDEX: u32 = 0x0B05;
    #[classattr]
    const CURRENT_RASTER_POSITION: u32 = 0x0B07;
    #[classattr]
    const CURRENT_RASTER_POSITION_VALID: u32 = 0x0B08;
    #[classattr]
    const CURRENT_RASTER_SECONDARY_COLOR: u32 = 0x845F;
    #[classattr]
    const CURRENT_RASTER_TEXTURE_COORDS: u32 = 0x0B06;
    #[classattr]
    const CURRENT_SECONDARY_COLOR: u32 = 0x8459;
    #[classattr]
    const CURRENT_TEXTURE_COORDS: u32 = 0x0B03;
    #[classattr]
    const CURRENT_VERTEX_ATTRIB: u32 = 0x8626;
    #[classattr]
    const CW: u32 = 0x0900;
    #[classattr]
    const DARKEN_KHR: u32 = 0x9297;
    #[classattr]
    const DEBUG_CALLBACK_FUNCTION: u32 = 0x8244;
    #[classattr]
    const DEBUG_CALLBACK_FUNCTION_KHR: u32 = 0x8244;
    #[classattr]
    const DEBUG_CALLBACK_USER_PARAM: u32 = 0x8245;
    #[classattr]
    const DEBUG_CALLBACK_USER_PARAM_KHR: u32 = 0x8245;
    #[classattr]
    const DEBUG_GROUP_STACK_DEPTH: u32 = 0x826D;
    #[classattr]
    const DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826D;
    #[classattr]
    const DEBUG_LOGGED_MESSAGES: u32 = 0x9145;
    #[classattr]
    const DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9145;
    #[classattr]
    const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: u32 = 0x8243;
    #[classattr]
    const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR: u32 = 0x8243;
    #[classattr]
    const DEBUG_OUTPUT: u32 = 0x92E0;
    #[classattr]
    const DEBUG_OUTPUT_KHR: u32 = 0x92E0;
    #[classattr]
    const DEBUG_OUTPUT_SYNCHRONOUS: u32 = 0x8242;
    #[classattr]
    const DEBUG_OUTPUT_SYNCHRONOUS_KHR: u32 = 0x8242;
    #[classattr]
    const DEBUG_SEVERITY_HIGH: u32 = 0x9146;
    #[classattr]
    const DEBUG_SEVERITY_HIGH_KHR: u32 = 0x9146;
    #[classattr]
    const DEBUG_SEVERITY_LOW: u32 = 0x9148;
    #[classattr]
    const DEBUG_SEVERITY_LOW_KHR: u32 = 0x9148;
    #[classattr]
    const DEBUG_SEVERITY_MEDIUM: u32 = 0x9147;
    #[classattr]
    const DEBUG_SEVERITY_MEDIUM_KHR: u32 = 0x9147;
    #[classattr]
    const DEBUG_SEVERITY_NOTIFICATION: u32 = 0x826B;
    #[classattr]
    const DEBUG_SEVERITY_NOTIFICATION_KHR: u32 = 0x826B;
    #[classattr]
    const DEBUG_SOURCE_API: u32 = 0x8246;
    #[classattr]
    const DEBUG_SOURCE_API_KHR: u32 = 0x8246;
    #[classattr]
    const DEBUG_SOURCE_APPLICATION: u32 = 0x824A;
    #[classattr]
    const DEBUG_SOURCE_APPLICATION_KHR: u32 = 0x824A;
    #[classattr]
    const DEBUG_SOURCE_OTHER: u32 = 0x824B;
    #[classattr]
    const DEBUG_SOURCE_OTHER_KHR: u32 = 0x824B;
    #[classattr]
    const DEBUG_SOURCE_SHADER_COMPILER: u32 = 0x8248;
    #[classattr]
    const DEBUG_SOURCE_SHADER_COMPILER_KHR: u32 = 0x8248;
    #[classattr]
    const DEBUG_SOURCE_THIRD_PARTY: u32 = 0x8249;
    #[classattr]
    const DEBUG_SOURCE_THIRD_PARTY_KHR: u32 = 0x8249;
    #[classattr]
    const DEBUG_SOURCE_WINDOW_SYSTEM: u32 = 0x8247;
    #[classattr]
    const DEBUG_SOURCE_WINDOW_SYSTEM_KHR: u32 = 0x8247;
    #[classattr]
    const DEBUG_TYPE_DEPRECATED_BEHAVIOR: u32 = 0x824D;
    #[classattr]
    const DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR: u32 = 0x824D;
    #[classattr]
    const DEBUG_TYPE_ERROR: u32 = 0x824C;
    #[classattr]
    const DEBUG_TYPE_ERROR_KHR: u32 = 0x824C;
    #[classattr]
    const DEBUG_TYPE_MARKER: u32 = 0x8268;
    #[classattr]
    const DEBUG_TYPE_MARKER_KHR: u32 = 0x8268;
    #[classattr]
    const DEBUG_TYPE_OTHER: u32 = 0x8251;
    #[classattr]
    const DEBUG_TYPE_OTHER_KHR: u32 = 0x8251;
    #[classattr]
    const DEBUG_TYPE_PERFORMANCE: u32 = 0x8250;
    #[classattr]
    const DEBUG_TYPE_PERFORMANCE_KHR: u32 = 0x8250;
    #[classattr]
    const DEBUG_TYPE_POP_GROUP: u32 = 0x826A;
    #[classattr]
    const DEBUG_TYPE_POP_GROUP_KHR: u32 = 0x826A;
    #[classattr]
    const DEBUG_TYPE_PORTABILITY: u32 = 0x824F;
    #[classattr]
    const DEBUG_TYPE_PORTABILITY_KHR: u32 = 0x824F;
    #[classattr]
    const DEBUG_TYPE_PUSH_GROUP: u32 = 0x8269;
    #[classattr]
    const DEBUG_TYPE_PUSH_GROUP_KHR: u32 = 0x8269;
    #[classattr]
    const DEBUG_TYPE_UNDEFINED_BEHAVIOR: u32 = 0x824E;
    #[classattr]
    const DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR: u32 = 0x824E;
    #[classattr]
    const DECAL: u32 = 0x2101;
    #[classattr]
    const DECR: u32 = 0x1E03;
    #[classattr]
    const DECR_WRAP: u32 = 0x8508;
    #[classattr]
    const DELETE_STATUS: u32 = 0x8B80;
    #[classattr]
    const DEPTH: u32 = 0x1801;
    #[classattr]
    const DEPTH24_STENCIL8: u32 = 0x88F0;
    #[classattr]
    const DEPTH32F_STENCIL8: u32 = 0x8CAD;
    #[classattr]
    const DEPTH_ATTACHMENT: u32 = 0x8D00;
    #[classattr]
    const DEPTH_BIAS: u32 = 0x0D1F;
    #[classattr]
    const DEPTH_BITS: u32 = 0x0D56;
    #[classattr]
    const DEPTH_BUFFER_BIT: u32 = 0x00000100;
    #[classattr]
    const DEPTH_CLAMP: u32 = 0x864F;
    #[classattr]
    const DEPTH_CLEAR_VALUE: u32 = 0x0B73;
    #[classattr]
    const DEPTH_COMPONENT: u32 = 0x1902;
    #[classattr]
    const DEPTH_COMPONENT16: u32 = 0x81A5;
    #[classattr]
    const DEPTH_COMPONENT24: u32 = 0x81A6;
    #[classattr]
    const DEPTH_COMPONENT32: u32 = 0x81A7;
    #[classattr]
    const DEPTH_COMPONENT32F: u32 = 0x8CAC;
    #[classattr]
    const DEPTH_FUNC: u32 = 0x0B74;
    #[classattr]
    const DEPTH_RANGE: u32 = 0x0B70;
    #[classattr]
    const DEPTH_SCALE: u32 = 0x0D1E;
    #[classattr]
    const DEPTH_STENCIL: u32 = 0x84F9;
    #[classattr]
    const DEPTH_STENCIL_ATTACHMENT: u32 = 0x821A;
    #[classattr]
    const DEPTH_TEST: u32 = 0x0B71;
    #[classattr]
    const DEPTH_TEXTURE_MODE: u32 = 0x884B;
    #[classattr]
    const DEPTH_WRITEMASK: u32 = 0x0B72;
    #[classattr]
    const DIFFERENCE_KHR: u32 = 0x929E;
    #[classattr]
    const DIFFUSE: u32 = 0x1201;
    #[classattr]
    const DISPLAY_LIST: u32 = 0x82E7;
    #[classattr]
    const DITHER: u32 = 0x0BD0;
    #[classattr]
    const DOMAIN: u32 = 0x0A02;
    #[classattr]
    const DONT_CARE: u32 = 0x1100;
    #[classattr]
    const DOT3_RGB: u32 = 0x86AE;
    #[classattr]
    const DOT3_RGBA: u32 = 0x86AF;
    #[classattr]
    const DOUBLE: u32 = 0x140A;
    #[classattr]
    const DOUBLEBUFFER: u32 = 0x0C32;
    #[classattr]
    const DRAW_BUFFER: u32 = 0x0C01;
    #[classattr]
    const DRAW_BUFFER0: u32 = 0x8825;
    #[classattr]
    const DRAW_BUFFER1: u32 = 0x8826;
    #[classattr]
    const DRAW_BUFFER10: u32 = 0x882F;
    #[classattr]
    const DRAW_BUFFER11: u32 = 0x8830;
    #[classattr]
    const DRAW_BUFFER12: u32 = 0x8831;
    #[classattr]
    const DRAW_BUFFER13: u32 = 0x8832;
    #[classattr]
    const DRAW_BUFFER14: u32 = 0x8833;
    #[classattr]
    const DRAW_BUFFER15: u32 = 0x8834;
    #[classattr]
    const DRAW_BUFFER2: u32 = 0x8827;
    #[classattr]
    const DRAW_BUFFER3: u32 = 0x8828;
    #[classattr]
    const DRAW_BUFFER4: u32 = 0x8829;
    #[classattr]
    const DRAW_BUFFER5: u32 = 0x882A;
    #[classattr]
    const DRAW_BUFFER6: u32 = 0x882B;
    #[classattr]
    const DRAW_BUFFER7: u32 = 0x882C;
    #[classattr]
    const DRAW_BUFFER8: u32 = 0x882D;
    #[classattr]
    const DRAW_BUFFER9: u32 = 0x882E;
    #[classattr]
    const DRAW_FRAMEBUFFER: u32 = 0x8CA9;
    #[classattr]
    const DRAW_FRAMEBUFFER_BINDING: u32 = 0x8CA6;
    #[classattr]
    const DRAW_PIXELS_APPLE: u32 = 0x8A0A;
    #[classattr]
    const DRAW_PIXEL_TOKEN: u32 = 0x0705;
    #[classattr]
    const DST_ALPHA: u32 = 0x0304;
    #[classattr]
    const DST_COLOR: u32 = 0x0306;
    #[classattr]
    const DYNAMIC_COPY: u32 = 0x88EA;
    #[classattr]
    const DYNAMIC_DRAW: u32 = 0x88E8;
    #[classattr]
    const DYNAMIC_READ: u32 = 0x88E9;
    #[classattr]
    const EDGE_FLAG: u32 = 0x0B43;
    #[classattr]
    const EDGE_FLAG_ARRAY: u32 = 0x8079;
    #[classattr]
    const EDGE_FLAG_ARRAY_BUFFER_BINDING: u32 = 0x889B;
    #[classattr]
    const EDGE_FLAG_ARRAY_POINTER: u32 = 0x8093;
    #[classattr]
    const EDGE_FLAG_ARRAY_STRIDE: u32 = 0x808C;
    #[classattr]
    const ELEMENT_ARRAY_BUFFER: u32 = 0x8893;
    #[classattr]
    const ELEMENT_ARRAY_BUFFER_BINDING: u32 = 0x8895;
    #[classattr]
    const EMISSION: u32 = 0x1600;
    #[classattr]
    const ENABLE_BIT: u32 = 0x00002000;
    #[classattr]
    const EQUAL: u32 = 0x0202;
    #[classattr]
    const EQUIV: u32 = 0x1509;
    #[classattr]
    const EVAL_BIT: u32 = 0x00010000;
    #[classattr]
    const EXCLUSION_KHR: u32 = 0x92A0;
    #[classattr]
    const EXP: u32 = 0x0800;
    #[classattr]
    const EXP2: u32 = 0x0801;
    #[classattr]
    const EXTENSIONS: u32 = 0x1F03;
    #[classattr]
    const EYE_LINEAR: u32 = 0x2400;
    #[classattr]
    const EYE_PLANE: u32 = 0x2502;
    #[classattr]
    const FALSE: u8 = 0;
    #[classattr]
    const FASTEST: u32 = 0x1101;
    #[classattr]
    const FEEDBACK: u32 = 0x1C01;
    #[classattr]
    const FEEDBACK_BUFFER_POINTER: u32 = 0x0DF0;
    #[classattr]
    const FEEDBACK_BUFFER_SIZE: u32 = 0x0DF1;
    #[classattr]
    const FEEDBACK_BUFFER_TYPE: u32 = 0x0DF2;
    #[classattr]
    const FENCE_APPLE: u32 = 0x8A0B;
    #[classattr]
    const FILL: u32 = 0x1B02;
    #[classattr]
    const FIRST_VERTEX_CONVENTION: u32 = 0x8E4D;
    #[classattr]
    const FIXED: u32 = 0x140C;
    #[classattr]
    const FIXED_ONLY: u32 = 0x891D;
    #[classattr]
    const FLAT: u32 = 0x1D00;
    #[classattr]
    const FLOAT: u32 = 0x1406;
    #[classattr]
    const FLOAT_32_UNSIGNED_INT_24_8_REV: u32 = 0x8DAD;
    #[classattr]
    const FLOAT_MAT2: u32 = 0x8B5A;
    #[classattr]
    const FLOAT_MAT2x3: u32 = 0x8B65;
    #[classattr]
    const FLOAT_MAT2x4: u32 = 0x8B66;
    #[classattr]
    const FLOAT_MAT3: u32 = 0x8B5B;
    #[classattr]
    const FLOAT_MAT3x2: u32 = 0x8B67;
    #[classattr]
    const FLOAT_MAT3x4: u32 = 0x8B68;
    #[classattr]
    const FLOAT_MAT4: u32 = 0x8B5C;
    #[classattr]
    const FLOAT_MAT4x2: u32 = 0x8B69;
    #[classattr]
    const FLOAT_MAT4x3: u32 = 0x8B6A;
    #[classattr]
    const FLOAT_VEC2: u32 = 0x8B50;
    #[classattr]
    const FLOAT_VEC3: u32 = 0x8B51;
    #[classattr]
    const FLOAT_VEC4: u32 = 0x8B52;
    #[classattr]
    const FOG: u32 = 0x0B60;
    #[classattr]
    const FOG_BIT: u32 = 0x00000080;
    #[classattr]
    const FOG_COLOR: u32 = 0x0B66;
    #[classattr]
    const FOG_COORD: u32 = 0x8451;
    #[classattr]
    const FOG_COORDINATE: u32 = 0x8451;
    #[classattr]
    const FOG_COORDINATE_ARRAY: u32 = 0x8457;
    #[classattr]
    const FOG_COORDINATE_ARRAY_BUFFER_BINDING: u32 = 0x889D;
    #[classattr]
    const FOG_COORDINATE_ARRAY_POINTER: u32 = 0x8456;
    #[classattr]
    const FOG_COORDINATE_ARRAY_STRIDE: u32 = 0x8455;
    #[classattr]
    const FOG_COORDINATE_ARRAY_TYPE: u32 = 0x8454;
    #[classattr]
    const FOG_COORDINATE_SOURCE: u32 = 0x8450;
    #[classattr]
    const FOG_COORD_ARRAY: u32 = 0x8457;
    #[classattr]
    const FOG_COORD_ARRAY_BUFFER_BINDING: u32 = 0x889D;
    #[classattr]
    const FOG_COORD_ARRAY_POINTER: u32 = 0x8456;
    #[classattr]
    const FOG_COORD_ARRAY_STRIDE: u32 = 0x8455;
    #[classattr]
    const FOG_COORD_ARRAY_TYPE: u32 = 0x8454;
    #[classattr]
    const FOG_COORD_SRC: u32 = 0x8450;
    #[classattr]
    const FOG_DENSITY: u32 = 0x0B62;
    #[classattr]
    const FOG_END: u32 = 0x0B64;
    #[classattr]
    const FOG_HINT: u32 = 0x0C54;
    #[classattr]
    const FOG_INDEX: u32 = 0x0B61;
    #[classattr]
    const FOG_MODE: u32 = 0x0B65;
    #[classattr]
    const FOG_START: u32 = 0x0B63;
    #[classattr]
    const FRAGMENT_DEPTH: u32 = 0x8452;
    #[classattr]
    const FRAGMENT_SHADER: u32 = 0x8B30;
    #[classattr]
    const FRAGMENT_SHADER_DERIVATIVE_HINT: u32 = 0x8B8B;
    #[classattr]
    const FRAMEBUFFER: u32 = 0x8D40;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: u32 = 0x8215;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_ANGLE: u32 = 0x93A3;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: u32 = 0x8214;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: u32 = 0x8210;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: u32 = 0x8211;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: u32 = 0x8216;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: u32 = 0x8213;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_LAYERED: u32 = 0x8DA7;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: u32 = 0x8CD1;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: u32 = 0x8CD0;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_RED_SIZE: u32 = 0x8212;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: u32 = 0x8217;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: u32 = 0x8CD3;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: u32 = 0x8CD4;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: u32 = 0x8CD2;
    #[classattr]
    const FRAMEBUFFER_BINDING: u32 = 0x8CA6;
    #[classattr]
    const FRAMEBUFFER_COMPLETE: u32 = 0x8CD5;
    #[classattr]
    const FRAMEBUFFER_DEFAULT: u32 = 0x8218;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_ATTACHMENT: u32 = 0x8CD6;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_DIMENSIONS: u32 = 0x8CD9;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: u32 = 0x8CDB;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS: u32 = 0x8DA8;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: u32 = 0x8CD7;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: u32 = 0x8D56;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_READ_BUFFER: u32 = 0x8CDC;
    #[classattr]
    const FRAMEBUFFER_SRGB: u32 = 0x8DB9;
    #[classattr]
    const FRAMEBUFFER_UNDEFINED: u32 = 0x8219;
    #[classattr]
    const FRAMEBUFFER_UNSUPPORTED: u32 = 0x8CDD;
    #[classattr]
    const FRONT: u32 = 0x0404;
    #[classattr]
    const FRONT_AND_BACK: u32 = 0x0408;
    #[classattr]
    const FRONT_FACE: u32 = 0x0B46;
    #[classattr]
    const FRONT_LEFT: u32 = 0x0400;
    #[classattr]
    const FRONT_RIGHT: u32 = 0x0401;
    #[classattr]
    const FUNC_ADD: u32 = 0x8006;
    #[classattr]
    const FUNC_REVERSE_SUBTRACT: u32 = 0x800B;
    #[classattr]
    const FUNC_SUBTRACT: u32 = 0x800A;
    #[classattr]
    const GENERATE_MIPMAP: u32 = 0x8191;
    #[classattr]
    const GENERATE_MIPMAP_HINT: u32 = 0x8192;
    #[classattr]
    const GEOMETRY_INPUT_TYPE: u32 = 0x8917;
    #[classattr]
    const GEOMETRY_OUTPUT_TYPE: u32 = 0x8918;
    #[classattr]
    const GEOMETRY_SHADER: u32 = 0x8DD9;
    #[classattr]
    const GEOMETRY_VERTICES_OUT: u32 = 0x8916;
    #[classattr]
    const GEQUAL: u32 = 0x0206;
    #[classattr]
    const GPU_DISJOINT_EXT: u32 = 0x8FBB;
    #[classattr]
    const GREATER: u32 = 0x0204;
    #[classattr]
    const GREEN: u32 = 0x1904;
    #[classattr]
    const GREEN_BIAS: u32 = 0x0D19;
    #[classattr]
    const GREEN_BITS: u32 = 0x0D53;
    #[classattr]
    const GREEN_INTEGER: u32 = 0x8D95;
    #[classattr]
    const GREEN_SCALE: u32 = 0x0D18;
    #[classattr]
    const HALF_FLOAT: u32 = 0x140B;
    #[classattr]
    const HALF_FLOAT_OES: u32 = 0x8D61;
    #[classattr]
    const HARDLIGHT_KHR: u32 = 0x929B;
    #[classattr]
    const HIGH_FLOAT: u32 = 0x8DF2;
    #[classattr]
    const HIGH_INT: u32 = 0x8DF5;
    #[classattr]
    const HINT_BIT: u32 = 0x00008000;
    #[classattr]
    const HSL_COLOR_KHR: u32 = 0x92AF;
    #[classattr]
    const HSL_HUE_KHR: u32 = 0x92AD;
    #[classattr]
    const HSL_LUMINOSITY_KHR: u32 = 0x92B0;
    #[classattr]
    const HSL_SATURATION_KHR: u32 = 0x92AE;
    #[classattr]
    const IMPLEMENTATION_COLOR_READ_FORMAT: u32 = 0x8B9B;
    #[classattr]
    const IMPLEMENTATION_COLOR_READ_TYPE: u32 = 0x8B9A;
    #[classattr]
    const INCR: u32 = 0x1E02;
    #[classattr]
    const INCR_WRAP: u32 = 0x8507;
    #[classattr]
    const INDEX: u32 = 0x8222;
    #[classattr]
    const INDEX_ARRAY: u32 = 0x8077;
    #[classattr]
    const INDEX_ARRAY_BUFFER_BINDING: u32 = 0x8899;
    #[classattr]
    const INDEX_ARRAY_POINTER: u32 = 0x8091;
    #[classattr]
    const INDEX_ARRAY_STRIDE: u32 = 0x8086;
    #[classattr]
    const INDEX_ARRAY_TYPE: u32 = 0x8085;
    #[classattr]
    const INDEX_BITS: u32 = 0x0D51;
    #[classattr]
    const INDEX_CLEAR_VALUE: u32 = 0x0C20;
    #[classattr]
    const INDEX_LOGIC_OP: u32 = 0x0BF1;
    #[classattr]
    const INDEX_MODE: u32 = 0x0C30;
    #[classattr]
    const INDEX_OFFSET: u32 = 0x0D13;
    #[classattr]
    const INDEX_SHIFT: u32 = 0x0D12;
    #[classattr]
    const INDEX_WRITEMASK: u32 = 0x0C21;
    #[classattr]
    const INFO_LOG_LENGTH: u32 = 0x8B84;
    #[classattr]
    const INT: u32 = 0x1404;
    #[classattr]
    const INTENSITY: u32 = 0x8049;
    #[classattr]
    const INTENSITY12: u32 = 0x804C;
    #[classattr]
    const INTENSITY16: u32 = 0x804D;
    #[classattr]
    const INTENSITY4: u32 = 0x804A;
    #[classattr]
    const INTENSITY8: u32 = 0x804B;
    #[classattr]
    const INTERLEAVED_ATTRIBS: u32 = 0x8C8C;
    #[classattr]
    const INTERPOLATE: u32 = 0x8575;
    #[classattr]
    const INT_2_10_10_10_REV: u32 = 0x8D9F;
    #[classattr]
    const INT_SAMPLER_1D: u32 = 0x8DC9;
    #[classattr]
    const INT_SAMPLER_1D_ARRAY: u32 = 0x8DCE;
    #[classattr]
    const INT_SAMPLER_2D: u32 = 0x8DCA;
    #[classattr]
    const INT_SAMPLER_2D_ARRAY: u32 = 0x8DCF;
    #[classattr]
    const INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x9109;
    #[classattr]
    const INT_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910C;
    #[classattr]
    const INT_SAMPLER_2D_RECT: u32 = 0x8DCD;
    #[classattr]
    const INT_SAMPLER_3D: u32 = 0x8DCB;
    #[classattr]
    const INT_SAMPLER_BUFFER: u32 = 0x8DD0;
    #[classattr]
    const INT_SAMPLER_CUBE: u32 = 0x8DCC;
    #[classattr]
    const INT_VEC2: u32 = 0x8B53;
    #[classattr]
    const INT_VEC3: u32 = 0x8B54;
    #[classattr]
    const INT_VEC4: u32 = 0x8B55;
    #[classattr]
    const INVALID_ENUM: u32 = 0x0500;
    #[classattr]
    const INVALID_FRAMEBUFFER_OPERATION: u32 = 0x0506;
    #[classattr]
    const INVALID_INDEX: u32 = 0xFFFFFFFF;
    #[classattr]
    const INVALID_OPERATION: u32 = 0x0502;
    #[classattr]
    const INVALID_VALUE: u32 = 0x0501;
    #[classattr]
    const INVERT: u32 = 0x150A;
    #[classattr]
    const KEEP: u32 = 0x1E00;
    #[classattr]
    const LAST_VERTEX_CONVENTION: u32 = 0x8E4E;
    #[classattr]
    const LEFT: u32 = 0x0406;
    #[classattr]
    const LEQUAL: u32 = 0x0203;
    #[classattr]
    const LESS: u32 = 0x0201;
    #[classattr]
    const LIGHT0: u32 = 0x4000;
    #[classattr]
    const LIGHT1: u32 = 0x4001;
    #[classattr]
    const LIGHT2: u32 = 0x4002;
    #[classattr]
    const LIGHT3: u32 = 0x4003;
    #[classattr]
    const LIGHT4: u32 = 0x4004;
    #[classattr]
    const LIGHT5: u32 = 0x4005;
    #[classattr]
    const LIGHT6: u32 = 0x4006;
    #[classattr]
    const LIGHT7: u32 = 0x4007;
    #[classattr]
    const LIGHTEN_KHR: u32 = 0x9298;
    #[classattr]
    const LIGHTING: u32 = 0x0B50;
    #[classattr]
    const LIGHTING_BIT: u32 = 0x00000040;
    #[classattr]
    const LIGHT_MODEL_AMBIENT: u32 = 0x0B53;
    #[classattr]
    const LIGHT_MODEL_COLOR_CONTROL: u32 = 0x81F8;
    #[classattr]
    const LIGHT_MODEL_LOCAL_VIEWER: u32 = 0x0B51;
    #[classattr]
    const LIGHT_MODEL_TWO_SIDE: u32 = 0x0B52;
    #[classattr]
    const LINE: u32 = 0x1B01;
    #[classattr]
    const LINEAR: u32 = 0x2601;
    #[classattr]
    const LINEAR_ATTENUATION: u32 = 0x1208;
    #[classattr]
    const LINEAR_MIPMAP_LINEAR: u32 = 0x2703;
    #[classattr]
    const LINEAR_MIPMAP_NEAREST: u32 = 0x2701;
    #[classattr]
    const LINES: u32 = 0x0001;
    #[classattr]
    const LINES_ADJACENCY: u32 = 0x000A;
    #[classattr]
    const LINE_BIT: u32 = 0x00000004;
    #[classattr]
    const LINE_LOOP: u32 = 0x0002;
    #[classattr]
    const LINE_RESET_TOKEN: u32 = 0x0707;
    #[classattr]
    const LINE_SMOOTH: u32 = 0x0B20;
    #[classattr]
    const LINE_SMOOTH_HINT: u32 = 0x0C52;
    #[classattr]
    const LINE_STIPPLE: u32 = 0x0B24;
    #[classattr]
    const LINE_STIPPLE_PATTERN: u32 = 0x0B25;
    #[classattr]
    const LINE_STIPPLE_REPEAT: u32 = 0x0B26;
    #[classattr]
    const LINE_STRIP: u32 = 0x0003;
    #[classattr]
    const LINE_STRIP_ADJACENCY: u32 = 0x000B;
    #[classattr]
    const LINE_TOKEN: u32 = 0x0702;
    #[classattr]
    const LINE_WIDTH: u32 = 0x0B21;
    #[classattr]
    const LINE_WIDTH_GRANULARITY: u32 = 0x0B23;
    #[classattr]
    const LINE_WIDTH_RANGE: u32 = 0x0B22;
    #[classattr]
    const LINK_STATUS: u32 = 0x8B82;
    #[classattr]
    const LIST_BASE: u32 = 0x0B32;
    #[classattr]
    const LIST_BIT: u32 = 0x00020000;
    #[classattr]
    const LIST_INDEX: u32 = 0x0B33;
    #[classattr]
    const LIST_MODE: u32 = 0x0B30;
    #[classattr]
    const LOAD: u32 = 0x0101;
    #[classattr]
    const LOGIC_OP: u32 = 0x0BF1;
    #[classattr]
    const LOGIC_OP_MODE: u32 = 0x0BF0;
    #[classattr]
    const LOWER_LEFT: u32 = 0x8CA1;
    #[classattr]
    const LOW_FLOAT: u32 = 0x8DF0;
    #[classattr]
    const LOW_INT: u32 = 0x8DF3;
    #[classattr]
    const LUMINANCE: u32 = 0x1909;
    #[classattr]
    const LUMINANCE12: u32 = 0x8041;
    #[classattr]
    const LUMINANCE12_ALPHA12: u32 = 0x8047;
    #[classattr]
    const LUMINANCE12_ALPHA4: u32 = 0x8046;
    #[classattr]
    const LUMINANCE16: u32 = 0x8042;
    #[classattr]
    const LUMINANCE16F_EXT: u32 = 0x881E;
    #[classattr]
    const LUMINANCE16_ALPHA16: u32 = 0x8048;
    #[classattr]
    const LUMINANCE32F_EXT: u32 = 0x8818;
    #[classattr]
    const LUMINANCE4: u32 = 0x803F;
    #[classattr]
    const LUMINANCE4_ALPHA4: u32 = 0x8043;
    #[classattr]
    const LUMINANCE6_ALPHA2: u32 = 0x8044;
    #[classattr]
    const LUMINANCE8: u32 = 0x8040;
    #[classattr]
    const LUMINANCE8_ALPHA8: u32 = 0x8045;
    #[classattr]
    const LUMINANCE8_ALPHA8_EXT: u32 = 0x8045;
    #[classattr]
    const LUMINANCE8_EXT: u32 = 0x8040;
    #[classattr]
    const LUMINANCE_ALPHA: u32 = 0x190A;
    #[classattr]
    const LUMINANCE_ALPHA16F_EXT: u32 = 0x881F;
    #[classattr]
    const LUMINANCE_ALPHA32F_EXT: u32 = 0x8819;
    #[classattr]
    const MAJOR_VERSION: u32 = 0x821B;
    #[classattr]
    const MAP1_COLOR_4: u32 = 0x0D90;
    #[classattr]
    const MAP1_GRID_DOMAIN: u32 = 0x0DD0;
    #[classattr]
    const MAP1_GRID_SEGMENTS: u32 = 0x0DD1;
    #[classattr]
    const MAP1_INDEX: u32 = 0x0D91;
    #[classattr]
    const MAP1_NORMAL: u32 = 0x0D92;
    #[classattr]
    const MAP1_TEXTURE_COORD_1: u32 = 0x0D93;
    #[classattr]
    const MAP1_TEXTURE_COORD_2: u32 = 0x0D94;
    #[classattr]
    const MAP1_TEXTURE_COORD_3: u32 = 0x0D95;
    #[classattr]
    const MAP1_TEXTURE_COORD_4: u32 = 0x0D96;
    #[classattr]
    const MAP1_VERTEX_3: u32 = 0x0D97;
    #[classattr]
    const MAP1_VERTEX_4: u32 = 0x0D98;
    #[classattr]
    const MAP2_COLOR_4: u32 = 0x0DB0;
    #[classattr]
    const MAP2_GRID_DOMAIN: u32 = 0x0DD2;
    #[classattr]
    const MAP2_GRID_SEGMENTS: u32 = 0x0DD3;
    #[classattr]
    const MAP2_INDEX: u32 = 0x0DB1;
    #[classattr]
    const MAP2_NORMAL: u32 = 0x0DB2;
    #[classattr]
    const MAP2_TEXTURE_COORD_1: u32 = 0x0DB3;
    #[classattr]
    const MAP2_TEXTURE_COORD_2: u32 = 0x0DB4;
    #[classattr]
    const MAP2_TEXTURE_COORD_3: u32 = 0x0DB5;
    #[classattr]
    const MAP2_TEXTURE_COORD_4: u32 = 0x0DB6;
    #[classattr]
    const MAP2_VERTEX_3: u32 = 0x0DB7;
    #[classattr]
    const MAP2_VERTEX_4: u32 = 0x0DB8;
    #[classattr]
    const MAP_COLOR: u32 = 0x0D10;
    #[classattr]
    const MAP_FLUSH_EXPLICIT_BIT: u32 = 0x0010;
    #[classattr]
    const MAP_INVALIDATE_BUFFER_BIT: u32 = 0x0008;
    #[classattr]
    const MAP_INVALIDATE_RANGE_BIT: u32 = 0x0004;
    #[classattr]
    const MAP_READ_BIT: u32 = 0x0001;
    #[classattr]
    const MAP_STENCIL: u32 = 0x0D11;
    #[classattr]
    const MAP_UNSYNCHRONIZED_BIT: u32 = 0x0020;
    #[classattr]
    const MAP_WRITE_BIT: u32 = 0x0002;
    #[classattr]
    const MATRIX_MODE: u32 = 0x0BA0;
    #[classattr]
    const MAX: u32 = 0x8008;
    #[classattr]
    const MAX_3D_TEXTURE_SIZE: u32 = 0x8073;
    #[classattr]
    const MAX_ARRAY_TEXTURE_LAYERS: u32 = 0x88FF;
    #[classattr]
    const MAX_ATTRIB_STACK_DEPTH: u32 = 0x0D35;
    #[classattr]
    const MAX_CLIENT_ATTRIB_STACK_DEPTH: u32 = 0x0D3B;
    #[classattr]
    const MAX_CLIP_DISTANCES: u32 = 0x0D32;
    #[classattr]
    const MAX_CLIP_PLANES: u32 = 0x0D32;
    #[classattr]
    const MAX_COLOR_ATTACHMENTS: u32 = 0x8CDF;
    #[classattr]
    const MAX_COLOR_TEXTURE_SAMPLES: u32 = 0x910E;
    #[classattr]
    const MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8A33;
    #[classattr]
    const MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS: u32 = 0x8A32;
    #[classattr]
    const MAX_COMBINED_TEXTURE_IMAGE_UNITS: u32 = 0x8B4D;
    #[classattr]
    const MAX_COMBINED_UNIFORM_BLOCKS: u32 = 0x8A2E;
    #[classattr]
    const MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8A31;
    #[classattr]
    const MAX_CUBE_MAP_TEXTURE_SIZE: u32 = 0x851C;
    #[classattr]
    const MAX_DEBUG_GROUP_STACK_DEPTH: u32 = 0x826C;
    #[classattr]
    const MAX_DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826C;
    #[classattr]
    const MAX_DEBUG_LOGGED_MESSAGES: u32 = 0x9144;
    #[classattr]
    const MAX_DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9144;
    #[classattr]
    const MAX_DEBUG_MESSAGE_LENGTH: u32 = 0x9143;
    #[classattr]
    const MAX_DEBUG_MESSAGE_LENGTH_KHR: u32 = 0x9143;
    #[classattr]
    const MAX_DEPTH_TEXTURE_SAMPLES: u32 = 0x910F;
    #[classattr]
    const MAX_DRAW_BUFFERS: u32 = 0x8824;
    #[classattr]
    const MAX_DUAL_SOURCE_DRAW_BUFFERS: u32 = 0x88FC;
    #[classattr]
    const MAX_ELEMENTS_INDICES: u32 = 0x80E9;
    #[classattr]
    const MAX_ELEMENTS_VERTICES: u32 = 0x80E8;
    #[classattr]
    const MAX_ELEMENT_INDEX: u32 = 0x8D6B;
    #[classattr]
    const MAX_EVAL_ORDER: u32 = 0x0D30;
    #[classattr]
    const MAX_FRAGMENT_INPUT_COMPONENTS: u32 = 0x9125;
    #[classattr]
    const MAX_FRAGMENT_UNIFORM_BLOCKS: u32 = 0x8A2D;
    #[classattr]
    const MAX_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8B49;
    #[classattr]
    const MAX_FRAGMENT_UNIFORM_VECTORS: u32 = 0x8DFD;
    #[classattr]
    const MAX_GEOMETRY_INPUT_COMPONENTS: u32 = 0x9123;
    #[classattr]
    const MAX_GEOMETRY_OUTPUT_COMPONENTS: u32 = 0x9124;
    #[classattr]
    const MAX_GEOMETRY_OUTPUT_VERTICES: u32 = 0x8DE0;
    #[classattr]
    const MAX_GEOMETRY_TEXTURE_IMAGE_UNITS: u32 = 0x8C29;
    #[classattr]
    const MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS: u32 = 0x8DE1;
    #[classattr]
    const MAX_GEOMETRY_UNIFORM_BLOCKS: u32 = 0x8A2C;
    #[classattr]
    const MAX_GEOMETRY_UNIFORM_COMPONENTS: u32 = 0x8DDF;
    #[classattr]
    const MAX_INTEGER_SAMPLES: u32 = 0x9110;
    #[classattr]
    const MAX_LABEL_LENGTH: u32 = 0x82E8;
    #[classattr]
    const MAX_LABEL_LENGTH_KHR: u32 = 0x82E8;
    #[classattr]
    const MAX_LIGHTS: u32 = 0x0D31;
    #[classattr]
    const MAX_LIST_NESTING: u32 = 0x0B31;
    #[classattr]
    const MAX_MODELVIEW_STACK_DEPTH: u32 = 0x0D36;
    #[classattr]
    const MAX_NAME_STACK_DEPTH: u32 = 0x0D37;
    #[classattr]
    const MAX_PIXEL_MAP_TABLE: u32 = 0x0D34;
    #[classattr]
    const MAX_PROGRAM_TEXEL_OFFSET: u32 = 0x8905;
    #[classattr]
    const MAX_PROJECTION_STACK_DEPTH: u32 = 0x0D38;
    #[classattr]
    const MAX_RECTANGLE_TEXTURE_SIZE: u32 = 0x84F8;
    #[classattr]
    const MAX_RECTANGLE_TEXTURE_SIZE_ARB: u32 = 0x84F8;
    #[classattr]
    const MAX_RENDERBUFFER_SIZE: u32 = 0x84E8;
    #[classattr]
    const MAX_SAMPLES: u32 = 0x8D57;
    #[classattr]
    const MAX_SAMPLE_MASK_WORDS: u32 = 0x8E59;
    #[classattr]
    const MAX_SERVER_WAIT_TIMEOUT: u32 = 0x9111;
    #[classattr]
    const MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT: u32 = 0x8F63;
    #[classattr]
    const MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT: u32 = 0x8F67;
    #[classattr]
    const MAX_TEXTURE_BUFFER_SIZE: u32 = 0x8C2B;
    #[classattr]
    const MAX_TEXTURE_COORDS: u32 = 0x8871;
    #[classattr]
    const MAX_TEXTURE_IMAGE_UNITS: u32 = 0x8872;
    #[classattr]
    const MAX_TEXTURE_LOD_BIAS: u32 = 0x84FD;
    #[classattr]
    const MAX_TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FF;
    #[classattr]
    const MAX_TEXTURE_SIZE: u32 = 0x0D33;
    #[classattr]
    const MAX_TEXTURE_STACK_DEPTH: u32 = 0x0D39;
    #[classattr]
    const MAX_TEXTURE_UNITS: u32 = 0x84E2;
    #[classattr]
    const MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: u32 = 0x8C8A;
    #[classattr]
    const MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: u32 = 0x8C8B;
    #[classattr]
    const MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: u32 = 0x8C80;
    #[classattr]
    const MAX_UNIFORM_BLOCK_SIZE: u32 = 0x8A30;
    #[classattr]
    const MAX_UNIFORM_BUFFER_BINDINGS: u32 = 0x8A2F;
    #[classattr]
    const MAX_VARYING_COMPONENTS: u32 = 0x8B4B;
    #[classattr]
    const MAX_VARYING_FLOATS: u32 = 0x8B4B;
    #[classattr]
    const MAX_VARYING_VECTORS: u32 = 0x8DFC;
    #[classattr]
    const MAX_VERTEX_ATTRIBS: u32 = 0x8869;
    #[classattr]
    const MAX_VERTEX_OUTPUT_COMPONENTS: u32 = 0x9122;
    #[classattr]
    const MAX_VERTEX_TEXTURE_IMAGE_UNITS: u32 = 0x8B4C;
    #[classattr]
    const MAX_VERTEX_UNIFORM_BLOCKS: u32 = 0x8A2B;
    #[classattr]
    const MAX_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8B4A;
    #[classattr]
    const MAX_VERTEX_UNIFORM_VECTORS: u32 = 0x8DFB;
    #[classattr]
    const MAX_VIEWPORT_DIMS: u32 = 0x0D3A;
    #[classattr]
    const MEDIUM_FLOAT: u32 = 0x8DF1;
    #[classattr]
    const MEDIUM_INT: u32 = 0x8DF4;
    #[classattr]
    const MIN: u32 = 0x8007;
    #[classattr]
    const MINOR_VERSION: u32 = 0x821C;
    #[classattr]
    const MIN_PROGRAM_TEXEL_OFFSET: u32 = 0x8904;
    #[classattr]
    const MIRRORED_REPEAT: u32 = 0x8370;
    #[classattr]
    const MODELVIEW: u32 = 0x1700;
    #[classattr]
    const MODELVIEW_MATRIX: u32 = 0x0BA6;
    #[classattr]
    const MODELVIEW_STACK_DEPTH: u32 = 0x0BA3;
    #[classattr]
    const MODULATE: u32 = 0x2100;
    #[classattr]
    const MULT: u32 = 0x0103;
    #[classattr]
    const MULTIPLY_KHR: u32 = 0x9294;
    #[classattr]
    const MULTISAMPLE: u32 = 0x809D;
    #[classattr]
    const MULTISAMPLE_BIT: u32 = 0x20000000;
    #[classattr]
    const N3F_V3F: u32 = 0x2A25;
    #[classattr]
    const NAME_STACK_DEPTH: u32 = 0x0D70;
    #[classattr]
    const NAND: u32 = 0x150E;
    #[classattr]
    const NEAREST: u32 = 0x2600;
    #[classattr]
    const NEAREST_MIPMAP_LINEAR: u32 = 0x2702;
    #[classattr]
    const NEAREST_MIPMAP_NEAREST: u32 = 0x2700;
    #[classattr]
    const NEVER: u32 = 0x0200;
    #[classattr]
    const NICEST: u32 = 0x1102;
    #[classattr]
    const NONE: u32 = 0;
    #[classattr]
    const NOOP: u32 = 0x1505;
    #[classattr]
    const NOR: u32 = 0x1508;
    #[classattr]
    const NORMALIZE: u32 = 0x0BA1;
    #[classattr]
    const NORMAL_ARRAY: u32 = 0x8075;
    #[classattr]
    const NORMAL_ARRAY_BUFFER_BINDING: u32 = 0x8897;
    #[classattr]
    const NORMAL_ARRAY_POINTER: u32 = 0x808F;
    #[classattr]
    const NORMAL_ARRAY_STRIDE: u32 = 0x807F;
    #[classattr]
    const NORMAL_ARRAY_TYPE: u32 = 0x807E;
    #[classattr]
    const NORMAL_MAP: u32 = 0x8511;
    #[classattr]
    const NOTEQUAL: u32 = 0x0205;
    #[classattr]
    const NO_ERROR: u32 = 0;
    #[classattr]
    const NUM_COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A2;
    #[classattr]
    const NUM_EXTENSIONS: u32 = 0x821D;
    #[classattr]
    const NUM_PROGRAM_BINARY_FORMATS: u32 = 0x87FE;
    #[classattr]
    const NUM_SAMPLE_COUNTS: u32 = 0x9380;
    #[classattr]
    const NUM_SHADER_BINARY_FORMATS: u32 = 0x8DF9;
    #[classattr]
    const OBJECT_LINEAR: u32 = 0x2401;
    #[classattr]
    const OBJECT_PLANE: u32 = 0x2501;
    #[classattr]
    const OBJECT_TYPE: u32 = 0x9112;
    #[classattr]
    const ONE: u32 = 1;
    #[classattr]
    const ONE_MINUS_CONSTANT_ALPHA: u32 = 0x8004;
    #[classattr]
    const ONE_MINUS_CONSTANT_COLOR: u32 = 0x8002;
    #[classattr]
    const ONE_MINUS_DST_ALPHA: u32 = 0x0305;
    #[classattr]
    const ONE_MINUS_DST_COLOR: u32 = 0x0307;
    #[classattr]
    const ONE_MINUS_SRC1_ALPHA: u32 = 0x88FB;
    #[classattr]
    const ONE_MINUS_SRC1_COLOR: u32 = 0x88FA;
    #[classattr]
    const ONE_MINUS_SRC_ALPHA: u32 = 0x0303;
    #[classattr]
    const ONE_MINUS_SRC_COLOR: u32 = 0x0301;
    #[classattr]
    const OPERAND0_ALPHA: u32 = 0x8598;
    #[classattr]
    const OPERAND0_RGB: u32 = 0x8590;
    #[classattr]
    const OPERAND1_ALPHA: u32 = 0x8599;
    #[classattr]
    const OPERAND1_RGB: u32 = 0x8591;
    #[classattr]
    const OPERAND2_ALPHA: u32 = 0x859A;
    #[classattr]
    const OPERAND2_RGB: u32 = 0x8592;
    #[classattr]
    const OR: u32 = 0x1507;
    #[classattr]
    const ORDER: u32 = 0x0A01;
    #[classattr]
    const OR_INVERTED: u32 = 0x150D;
    #[classattr]
    const OR_REVERSE: u32 = 0x150B;
    #[classattr]
    const OUT_OF_MEMORY: u32 = 0x0505;
    #[classattr]
    const OVERLAY_KHR: u32 = 0x9296;
    #[classattr]
    const PACK_ALIGNMENT: u32 = 0x0D05;
    #[classattr]
    const PACK_IMAGE_HEIGHT: u32 = 0x806C;
    #[classattr]
    const PACK_LSB_FIRST: u32 = 0x0D01;
    #[classattr]
    const PACK_ROW_LENGTH: u32 = 0x0D02;
    #[classattr]
    const PACK_SKIP_IMAGES: u32 = 0x806B;
    #[classattr]
    const PACK_SKIP_PIXELS: u32 = 0x0D04;
    #[classattr]
    const PACK_SKIP_ROWS: u32 = 0x0D03;
    #[classattr]
    const PACK_SWAP_BYTES: u32 = 0x0D00;
    #[classattr]
    const PASS_THROUGH_TOKEN: u32 = 0x0700;
    #[classattr]
    const PERSPECTIVE_CORRECTION_HINT: u32 = 0x0C50;
    #[classattr]
    const PIXEL_MAP_A_TO_A: u32 = 0x0C79;
    #[classattr]
    const PIXEL_MAP_A_TO_A_SIZE: u32 = 0x0CB9;
    #[classattr]
    const PIXEL_MAP_B_TO_B: u32 = 0x0C78;
    #[classattr]
    const PIXEL_MAP_B_TO_B_SIZE: u32 = 0x0CB8;
    #[classattr]
    const PIXEL_MAP_G_TO_G: u32 = 0x0C77;
    #[classattr]
    const PIXEL_MAP_G_TO_G_SIZE: u32 = 0x0CB7;
    #[classattr]
    const PIXEL_MAP_I_TO_A: u32 = 0x0C75;
    #[classattr]
    const PIXEL_MAP_I_TO_A_SIZE: u32 = 0x0CB5;
    #[classattr]
    const PIXEL_MAP_I_TO_B: u32 = 0x0C74;
    #[classattr]
    const PIXEL_MAP_I_TO_B_SIZE: u32 = 0x0CB4;
    #[classattr]
    const PIXEL_MAP_I_TO_G: u32 = 0x0C73;
    #[classattr]
    const PIXEL_MAP_I_TO_G_SIZE: u32 = 0x0CB3;
    #[classattr]
    const PIXEL_MAP_I_TO_I: u32 = 0x0C70;
    #[classattr]
    const PIXEL_MAP_I_TO_I_SIZE: u32 = 0x0CB0;
    #[classattr]
    const PIXEL_MAP_I_TO_R: u32 = 0x0C72;
    #[classattr]
    const PIXEL_MAP_I_TO_R_SIZE: u32 = 0x0CB2;
    #[classattr]
    const PIXEL_MAP_R_TO_R: u32 = 0x0C76;
    #[classattr]
    const PIXEL_MAP_R_TO_R_SIZE: u32 = 0x0CB6;
    #[classattr]
    const PIXEL_MAP_S_TO_S: u32 = 0x0C71;
    #[classattr]
    const PIXEL_MAP_S_TO_S_SIZE: u32 = 0x0CB1;
    #[classattr]
    const PIXEL_MODE_BIT: u32 = 0x00000020;
    #[classattr]
    const PIXEL_PACK_BUFFER: u32 = 0x88EB;
    #[classattr]
    const PIXEL_PACK_BUFFER_BINDING: u32 = 0x88ED;
    #[classattr]
    const PIXEL_UNPACK_BUFFER: u32 = 0x88EC;
    #[classattr]
    const PIXEL_UNPACK_BUFFER_BINDING: u32 = 0x88EF;
    #[classattr]
    const POINT: u32 = 0x1B00;
    #[classattr]
    const POINTS: u32 = 0x0000;
    #[classattr]
    const POINT_BIT: u32 = 0x00000002;
    #[classattr]
    const POINT_DISTANCE_ATTENUATION: u32 = 0x8129;
    #[classattr]
    const POINT_FADE_THRESHOLD_SIZE: u32 = 0x8128;
    #[classattr]
    const POINT_SIZE: u32 = 0x0B11;
    #[classattr]
    const POINT_SIZE_GRANULARITY: u32 = 0x0B13;
    #[classattr]
    const POINT_SIZE_MAX: u32 = 0x8127;
    #[classattr]
    const POINT_SIZE_MIN: u32 = 0x8126;
    #[classattr]
    const POINT_SIZE_RANGE: u32 = 0x0B12;
    #[classattr]
    const POINT_SMOOTH: u32 = 0x0B10;
    #[classattr]
    const POINT_SMOOTH_HINT: u32 = 0x0C51;
    #[classattr]
    const POINT_SPRITE: u32 = 0x8861;
    #[classattr]
    const POINT_SPRITE_COORD_ORIGIN: u32 = 0x8CA0;
    #[classattr]
    const POINT_TOKEN: u32 = 0x0701;
    #[classattr]
    const POLYGON: u32 = 0x0009;
    #[classattr]
    const POLYGON_BIT: u32 = 0x00000008;
    #[classattr]
    const POLYGON_MODE: u32 = 0x0B40;
    #[classattr]
    const POLYGON_OFFSET_FACTOR: u32 = 0x8038;
    #[classattr]
    const POLYGON_OFFSET_FILL: u32 = 0x8037;
    #[classattr]
    const POLYGON_OFFSET_LINE: u32 = 0x2A02;
    #[classattr]
    const POLYGON_OFFSET_POINT: u32 = 0x2A01;
    #[classattr]
    const POLYGON_OFFSET_UNITS: u32 = 0x2A00;
    #[classattr]
    const POLYGON_SMOOTH: u32 = 0x0B41;
    #[classattr]
    const POLYGON_SMOOTH_HINT: u32 = 0x0C53;
    #[classattr]
    const POLYGON_STIPPLE: u32 = 0x0B42;
    #[classattr]
    const POLYGON_STIPPLE_BIT: u32 = 0x00000010;
    #[classattr]
    const POLYGON_TOKEN: u32 = 0x0703;
    #[classattr]
    const POSITION: u32 = 0x1203;
    #[classattr]
    const PREVIOUS: u32 = 0x8578;
    #[classattr]
    const PRIMARY_COLOR: u32 = 0x8577;
    #[classattr]
    const PRIMITIVES_GENERATED: u32 = 0x8C87;
    #[classattr]
    const PRIMITIVE_RESTART: u32 = 0x8F9D;
    #[classattr]
    const PRIMITIVE_RESTART_FIXED_INDEX: u32 = 0x8D69;
    #[classattr]
    const PRIMITIVE_RESTART_INDEX: u32 = 0x8F9E;
    #[classattr]
    const PROGRAM: u32 = 0x82E2;
    #[classattr]
    const PROGRAM_BINARY_FORMATS: u32 = 0x87FF;
    #[classattr]
    const PROGRAM_BINARY_LENGTH: u32 = 0x8741;
    #[classattr]
    const PROGRAM_BINARY_RETRIEVABLE_HINT: u32 = 0x8257;
    #[classattr]
    const PROGRAM_KHR: u32 = 0x82E2;
    #[classattr]
    const PROGRAM_PIPELINE: u32 = 0x82E4;
    #[classattr]
    const PROGRAM_PIPELINE_KHR: u32 = 0x82E4;
    #[classattr]
    const PROGRAM_POINT_SIZE: u32 = 0x8642;
    #[classattr]
    const PROJECTION: u32 = 0x1701;
    #[classattr]
    const PROJECTION_MATRIX: u32 = 0x0BA7;
    #[classattr]
    const PROJECTION_STACK_DEPTH: u32 = 0x0BA4;
    #[classattr]
    const PROVOKING_VERTEX: u32 = 0x8E4F;
    #[classattr]
    const PROXY_TEXTURE_1D: u32 = 0x8063;
    #[classattr]
    const PROXY_TEXTURE_1D_ARRAY: u32 = 0x8C19;
    #[classattr]
    const PROXY_TEXTURE_2D: u32 = 0x8064;
    #[classattr]
    const PROXY_TEXTURE_2D_ARRAY: u32 = 0x8C1B;
    #[classattr]
    const PROXY_TEXTURE_2D_MULTISAMPLE: u32 = 0x9101;
    #[classattr]
    const PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: u32 = 0x9103;
    #[classattr]
    const PROXY_TEXTURE_3D: u32 = 0x8070;
    #[classattr]
    const PROXY_TEXTURE_CUBE_MAP: u32 = 0x851B;
    #[classattr]
    const PROXY_TEXTURE_RECTANGLE: u32 = 0x84F7;
    #[classattr]
    const PROXY_TEXTURE_RECTANGLE_ARB: u32 = 0x84F7;
    #[classattr]
    const Q: u32 = 0x2003;
    #[classattr]
    const QUADRATIC_ATTENUATION: u32 = 0x1209;
    #[classattr]
    const QUADS: u32 = 0x0007;
    #[classattr]
    const QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION: u32 = 0x8E4C;
    #[classattr]
    const QUAD_STRIP: u32 = 0x0008;
    #[classattr]
    const QUERY: u32 = 0x82E3;
    #[classattr]
    const QUERY_BY_REGION_NO_WAIT: u32 = 0x8E16;
    #[classattr]
    const QUERY_BY_REGION_WAIT: u32 = 0x8E15;
    #[classattr]
    const QUERY_COUNTER_BITS: u32 = 0x8864;
    #[classattr]
    const QUERY_COUNTER_BITS_EXT: u32 = 0x8864;
    #[classattr]
    const QUERY_KHR: u32 = 0x82E3;
    #[classattr]
    const QUERY_NO_WAIT: u32 = 0x8E14;
    #[classattr]
    const QUERY_RESULT: u32 = 0x8866;
    #[classattr]
    const QUERY_RESULT_AVAILABLE: u32 = 0x8867;
    #[classattr]
    const QUERY_RESULT_AVAILABLE_EXT: u32 = 0x8867;
    #[classattr]
    const QUERY_RESULT_EXT: u32 = 0x8866;
    #[classattr]
    const QUERY_WAIT: u32 = 0x8E13;
    #[classattr]
    const R: u32 = 0x2002;
    #[classattr]
    const R11F_G11F_B10F: u32 = 0x8C3A;
    #[classattr]
    const R16: u32 = 0x822A;
    #[classattr]
    const R16F: u32 = 0x822D;
    #[classattr]
    const R16F_EXT: u32 = 0x822D;
    #[classattr]
    const R16I: u32 = 0x8233;
    #[classattr]
    const R16UI: u32 = 0x8234;
    #[classattr]
    const R16_SNORM: u32 = 0x8F98;
    #[classattr]
    const R32F: u32 = 0x822E;
    #[classattr]
    const R32F_EXT: u32 = 0x822E;
    #[classattr]
    const R32I: u32 = 0x8235;
    #[classattr]
    const R32UI: u32 = 0x8236;
    #[classattr]
    const R3_G3_B2: u32 = 0x2A10;
    #[classattr]
    const R8: u32 = 0x8229;
    #[classattr]
    const R8I: u32 = 0x8231;
    #[classattr]
    const R8UI: u32 = 0x8232;
    #[classattr]
    const R8_EXT: u32 = 0x8229;
    #[classattr]
    const R8_SNORM: u32 = 0x8F94;
    #[classattr]
    const RASTERIZER_DISCARD: u32 = 0x8C89;
    #[classattr]
    const READ_BUFFER: u32 = 0x0C02;
    #[classattr]
    const READ_FRAMEBUFFER: u32 = 0x8CA8;
    #[classattr]
    const READ_FRAMEBUFFER_BINDING: u32 = 0x8CAA;
    #[classattr]
    const READ_ONLY: u32 = 0x88B8;
    #[classattr]
    const READ_WRITE: u32 = 0x88BA;
    #[classattr]
    const RED: u32 = 0x1903;
    #[classattr]
    const RED_BIAS: u32 = 0x0D15;
    #[classattr]
    const RED_BITS: u32 = 0x0D52;
    #[classattr]
    const RED_INTEGER: u32 = 0x8D94;
    #[classattr]
    const RED_SCALE: u32 = 0x0D14;
    #[classattr]
    const REFLECTION_MAP: u32 = 0x8512;
    #[classattr]
    const RENDER: u32 = 0x1C00;
    #[classattr]
    const RENDERBUFFER: u32 = 0x8D41;
    #[classattr]
    const RENDERBUFFER_ALPHA_SIZE: u32 = 0x8D53;
    #[classattr]
    const RENDERBUFFER_BINDING: u32 = 0x8CA7;
    #[classattr]
    const RENDERBUFFER_BLUE_SIZE: u32 = 0x8D52;
    #[classattr]
    const RENDERBUFFER_DEPTH_SIZE: u32 = 0x8D54;
    #[classattr]
    const RENDERBUFFER_GREEN_SIZE: u32 = 0x8D51;
    #[classattr]
    const RENDERBUFFER_HEIGHT: u32 = 0x8D43;
    #[classattr]
    const RENDERBUFFER_INTERNAL_FORMAT: u32 = 0x8D44;
    #[classattr]
    const RENDERBUFFER_RED_SIZE: u32 = 0x8D50;
    #[classattr]
    const RENDERBUFFER_SAMPLES: u32 = 0x8CAB;
    #[classattr]
    const RENDERBUFFER_STENCIL_SIZE: u32 = 0x8D55;
    #[classattr]
    const RENDERBUFFER_WIDTH: u32 = 0x8D42;
    #[classattr]
    const RENDERER: u32 = 0x1F01;
    #[classattr]
    const RENDER_MODE: u32 = 0x0C40;
    #[classattr]
    const REPEAT: u32 = 0x2901;
    #[classattr]
    const REPLACE: u32 = 0x1E01;
    #[classattr]
    const REQUIRED_TEXTURE_IMAGE_UNITS_OES: u32 = 0x8D68;
    #[classattr]
    const RESCALE_NORMAL: u32 = 0x803A;
    #[classattr]
    const RETURN: u32 = 0x0102;
    #[classattr]
    const RG: u32 = 0x8227;
    #[classattr]
    const RG16: u32 = 0x822C;
    #[classattr]
    const RG16F: u32 = 0x822F;
    #[classattr]
    const RG16F_EXT: u32 = 0x822F;
    #[classattr]
    const RG16I: u32 = 0x8239;
    #[classattr]
    const RG16UI: u32 = 0x823A;
    #[classattr]
    const RG16_SNORM: u32 = 0x8F99;
    #[classattr]
    const RG32F: u32 = 0x8230;
    #[classattr]
    const RG32F_EXT: u32 = 0x8230;
    #[classattr]
    const RG32I: u32 = 0x823B;
    #[classattr]
    const RG32UI: u32 = 0x823C;
    #[classattr]
    const RG8: u32 = 0x822B;
    #[classattr]
    const RG8I: u32 = 0x8237;
    #[classattr]
    const RG8UI: u32 = 0x8238;
    #[classattr]
    const RG8_EXT: u32 = 0x822B;
    #[classattr]
    const RG8_SNORM: u32 = 0x8F95;
    #[classattr]
    const RGB: u32 = 0x1907;
    #[classattr]
    const RGB10: u32 = 0x8052;
    #[classattr]
    const RGB10_A2: u32 = 0x8059;
    #[classattr]
    const RGB10_A2UI: u32 = 0x906F;
    #[classattr]
    const RGB10_A2_EXT: u32 = 0x8059;
    #[classattr]
    const RGB10_EXT: u32 = 0x8052;
    #[classattr]
    const RGB12: u32 = 0x8053;
    #[classattr]
    const RGB16: u32 = 0x8054;
    #[classattr]
    const RGB16F: u32 = 0x881B;
    #[classattr]
    const RGB16F_EXT: u32 = 0x881B;
    #[classattr]
    const RGB16I: u32 = 0x8D89;
    #[classattr]
    const RGB16UI: u32 = 0x8D77;
    #[classattr]
    const RGB16_SNORM: u32 = 0x8F9A;
    #[classattr]
    const RGB32F: u32 = 0x8815;
    #[classattr]
    const RGB32F_EXT: u32 = 0x8815;
    #[classattr]
    const RGB32I: u32 = 0x8D83;
    #[classattr]
    const RGB32UI: u32 = 0x8D71;
    #[classattr]
    const RGB4: u32 = 0x804F;
    #[classattr]
    const RGB5: u32 = 0x8050;
    #[classattr]
    const RGB565: u32 = 0x8D62;
    #[classattr]
    const RGB5_A1: u32 = 0x8057;
    #[classattr]
    const RGB8: u32 = 0x8051;
    #[classattr]
    const RGB8I: u32 = 0x8D8F;
    #[classattr]
    const RGB8UI: u32 = 0x8D7D;
    #[classattr]
    const RGB8_SNORM: u32 = 0x8F96;
    #[classattr]
    const RGB9_E5: u32 = 0x8C3D;
    #[classattr]
    const RGBA: u32 = 0x1908;
    #[classattr]
    const RGBA12: u32 = 0x805A;
    #[classattr]
    const RGBA16: u32 = 0x805B;
    #[classattr]
    const RGBA16F: u32 = 0x881A;
    #[classattr]
    const RGBA16F_EXT: u32 = 0x881A;
    #[classattr]
    const RGBA16I: u32 = 0x8D88;
    #[classattr]
    const RGBA16UI: u32 = 0x8D76;
    #[classattr]
    const RGBA16_SNORM: u32 = 0x8F9B;
    #[classattr]
    const RGBA2: u32 = 0x8055;
    #[classattr]
    const RGBA32F: u32 = 0x8814;
    #[classattr]
    const RGBA32F_EXT: u32 = 0x8814;
    #[classattr]
    const RGBA32I: u32 = 0x8D82;
    #[classattr]
    const RGBA32UI: u32 = 0x8D70;
    #[classattr]
    const RGBA4: u32 = 0x8056;
    #[classattr]
    const RGBA8: u32 = 0x8058;
    #[classattr]
    const RGBA8I: u32 = 0x8D8E;
    #[classattr]
    const RGBA8UI: u32 = 0x8D7C;
    #[classattr]
    const RGBA8_SNORM: u32 = 0x8F97;
    #[classattr]
    const RGBA_INTEGER: u32 = 0x8D99;
    #[classattr]
    const RGBA_MODE: u32 = 0x0C31;
    #[classattr]
    const RGB_INTEGER: u32 = 0x8D98;
    #[classattr]
    const RGB_SCALE: u32 = 0x8573;
    #[classattr]
    const RG_INTEGER: u32 = 0x8228;
    #[classattr]
    const RIGHT: u32 = 0x0407;
    #[classattr]
    const S: u32 = 0x2000;
    #[classattr]
    const SAMPLER: u32 = 0x82E6;
    #[classattr]
    const SAMPLER_1D: u32 = 0x8B5D;
    #[classattr]
    const SAMPLER_1D_ARRAY: u32 = 0x8DC0;
    #[classattr]
    const SAMPLER_1D_ARRAY_SHADOW: u32 = 0x8DC3;
    #[classattr]
    const SAMPLER_1D_SHADOW: u32 = 0x8B61;
    #[classattr]
    const SAMPLER_2D: u32 = 0x8B5E;
    #[classattr]
    const SAMPLER_2D_ARRAY: u32 = 0x8DC1;
    #[classattr]
    const SAMPLER_2D_ARRAY_SHADOW: u32 = 0x8DC4;
    #[classattr]
    const SAMPLER_2D_MULTISAMPLE: u32 = 0x9108;
    #[classattr]
    const SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910B;
    #[classattr]
    const SAMPLER_2D_RECT: u32 = 0x8B63;
    #[classattr]
    const SAMPLER_2D_RECT_SHADOW: u32 = 0x8B64;
    #[classattr]
    const SAMPLER_2D_SHADOW: u32 = 0x8B62;
    #[classattr]
    const SAMPLER_3D: u32 = 0x8B5F;
    #[classattr]
    const SAMPLER_BINDING: u32 = 0x8919;
    #[classattr]
    const SAMPLER_BUFFER: u32 = 0x8DC2;
    #[classattr]
    const SAMPLER_CUBE: u32 = 0x8B60;
    #[classattr]
    const SAMPLER_CUBE_SHADOW: u32 = 0x8DC5;
    #[classattr]
    const SAMPLER_EXTERNAL_OES: u32 = 0x8D66;
    #[classattr]
    const SAMPLER_KHR: u32 = 0x82E6;
    #[classattr]
    const SAMPLES: u32 = 0x80A9;
    #[classattr]
    const SAMPLES_PASSED: u32 = 0x8914;
    #[classattr]
    const SAMPLE_ALPHA_TO_COVERAGE: u32 = 0x809E;
    #[classattr]
    const SAMPLE_ALPHA_TO_ONE: u32 = 0x809F;
    #[classattr]
    const SAMPLE_BUFFERS: u32 = 0x80A8;
    #[classattr]
    const SAMPLE_COVERAGE: u32 = 0x80A0;
    #[classattr]
    const SAMPLE_COVERAGE_INVERT: u32 = 0x80AB;
    #[classattr]
    const SAMPLE_COVERAGE_VALUE: u32 = 0x80AA;
    #[classattr]
    const SAMPLE_MASK: u32 = 0x8E51;
    #[classattr]
    const SAMPLE_MASK_VALUE: u32 = 0x8E52;
    #[classattr]
    const SAMPLE_POSITION: u32 = 0x8E50;
    #[classattr]
    const SCISSOR_BIT: u32 = 0x00080000;
    #[classattr]
    const SCISSOR_BOX: u32 = 0x0C10;
    #[classattr]
    const SCISSOR_TEST: u32 = 0x0C11;
    #[classattr]
    const SCREEN_KHR: u32 = 0x9295;
    #[classattr]
    const SECONDARY_COLOR_ARRAY: u32 = 0x845E;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_BUFFER_BINDING: u32 = 0x889C;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_POINTER: u32 = 0x845D;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_SIZE: u32 = 0x845A;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_STRIDE: u32 = 0x845C;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_TYPE: u32 = 0x845B;
    #[classattr]
    const SELECT: u32 = 0x1C02;
    #[classattr]
    const SELECTION_BUFFER_POINTER: u32 = 0x0DF3;
    #[classattr]
    const SELECTION_BUFFER_SIZE: u32 = 0x0DF4;
    #[classattr]
    const SEPARATE_ATTRIBS: u32 = 0x8C8D;
    #[classattr]
    const SEPARATE_SPECULAR_COLOR: u32 = 0x81FA;
    #[classattr]
    const SET: u32 = 0x150F;
    #[classattr]
    const SHADER: u32 = 0x82E1;
    #[classattr]
    const SHADER_BINARY_FORMATS: u32 = 0x8DF8;
    #[classattr]
    const SHADER_COMPILER: u32 = 0x8DFA;
    #[classattr]
    const SHADER_KHR: u32 = 0x82E1;
    #[classattr]
    const SHADER_PIXEL_LOCAL_STORAGE_EXT: u32 = 0x8F64;
    #[classattr]
    const SHADER_SOURCE_LENGTH: u32 = 0x8B88;
    #[classattr]
    const SHADER_TYPE: u32 = 0x8B4F;
    #[classattr]
    const SHADE_MODEL: u32 = 0x0B54;
    #[classattr]
    const SHADING_LANGUAGE_VERSION: u32 = 0x8B8C;
    #[classattr]
    const SHININESS: u32 = 0x1601;
    #[classattr]
    const SHORT: u32 = 0x1402;
    #[classattr]
    const SIGNALED: u32 = 0x9119;
    #[classattr]
    const SIGNED_NORMALIZED: u32 = 0x8F9C;
    #[classattr]
    const SINGLE_COLOR: u32 = 0x81F9;
    #[classattr]
    const SLUMINANCE: u32 = 0x8C46;
    #[classattr]
    const SLUMINANCE8: u32 = 0x8C47;
    #[classattr]
    const SLUMINANCE8_ALPHA8: u32 = 0x8C45;
    #[classattr]
    const SLUMINANCE_ALPHA: u32 = 0x8C44;
    #[classattr]
    const SMOOTH: u32 = 0x1D01;
    #[classattr]
    const SMOOTH_LINE_WIDTH_GRANULARITY: u32 = 0x0B23;
    #[classattr]
    const SMOOTH_LINE_WIDTH_RANGE: u32 = 0x0B22;
    #[classattr]
    const SMOOTH_POINT_SIZE_GRANULARITY: u32 = 0x0B13;
    #[classattr]
    const SMOOTH_POINT_SIZE_RANGE: u32 = 0x0B12;
    #[classattr]
    const SOFTLIGHT_KHR: u32 = 0x929C;
    #[classattr]
    const SOURCE0_ALPHA: u32 = 0x8588;
    #[classattr]
    const SOURCE0_RGB: u32 = 0x8580;
    #[classattr]
    const SOURCE1_ALPHA: u32 = 0x8589;
    #[classattr]
    const SOURCE1_RGB: u32 = 0x8581;
    #[classattr]
    const SOURCE2_ALPHA: u32 = 0x858A;
    #[classattr]
    const SOURCE2_RGB: u32 = 0x8582;
    #[classattr]
    const SPECULAR: u32 = 0x1202;
    #[classattr]
    const SPHERE_MAP: u32 = 0x2402;
    #[classattr]
    const SPOT_CUTOFF: u32 = 0x1206;
    #[classattr]
    const SPOT_DIRECTION: u32 = 0x1204;
    #[classattr]
    const SPOT_EXPONENT: u32 = 0x1205;
    #[classattr]
    const SRC0_ALPHA: u32 = 0x8588;
    #[classattr]
    const SRC0_RGB: u32 = 0x8580;
    #[classattr]
    const SRC1_ALPHA: u32 = 0x8589;
    #[classattr]
    const SRC1_COLOR: u32 = 0x88F9;
    #[classattr]
    const SRC1_RGB: u32 = 0x8581;
    #[classattr]
    const SRC2_ALPHA: u32 = 0x858A;
    #[classattr]
    const SRC2_RGB: u32 = 0x8582;
    #[classattr]
    const SRC_ALPHA: u32 = 0x0302;
    #[classattr]
    const SRC_ALPHA_SATURATE: u32 = 0x0308;
    #[classattr]
    const SRC_COLOR: u32 = 0x0300;
    #[classattr]
    const SRGB: u32 = 0x8C40;
    #[classattr]
    const SRGB8: u32 = 0x8C41;
    #[classattr]
    const SRGB8_ALPHA8: u32 = 0x8C43;
    #[classattr]
    const SRGB_ALPHA: u32 = 0x8C42;
    #[classattr]
    const STACK_OVERFLOW: u32 = 0x0503;
    #[classattr]
    const STACK_OVERFLOW_KHR: u32 = 0x0503;
    #[classattr]
    const STACK_UNDERFLOW: u32 = 0x0504;
    #[classattr]
    const STACK_UNDERFLOW_KHR: u32 = 0x0504;
    #[classattr]
    const STATIC_COPY: u32 = 0x88E6;
    #[classattr]
    const STATIC_DRAW: u32 = 0x88E4;
    #[classattr]
    const STATIC_READ: u32 = 0x88E5;
    #[classattr]
    const STENCIL: u32 = 0x1802;
    #[classattr]
    const STENCIL_ATTACHMENT: u32 = 0x8D20;
    #[classattr]
    const STENCIL_BACK_FAIL: u32 = 0x8801;
    #[classattr]
    const STENCIL_BACK_FUNC: u32 = 0x8800;
    #[classattr]
    const STENCIL_BACK_PASS_DEPTH_FAIL: u32 = 0x8802;
    #[classattr]
    const STENCIL_BACK_PASS_DEPTH_PASS: u32 = 0x8803;
    #[classattr]
    const STENCIL_BACK_REF: u32 = 0x8CA3;
    #[classattr]
    const STENCIL_BACK_VALUE_MASK: u32 = 0x8CA4;
    #[classattr]
    const STENCIL_BACK_WRITEMASK: u32 = 0x8CA5;
    #[classattr]
    const STENCIL_BITS: u32 = 0x0D57;
    #[classattr]
    const STENCIL_BUFFER_BIT: u32 = 0x00000400;
    #[classattr]
    const STENCIL_CLEAR_VALUE: u32 = 0x0B91;
    #[classattr]
    const STENCIL_FAIL: u32 = 0x0B94;
    #[classattr]
    const STENCIL_FUNC: u32 = 0x0B92;
    #[classattr]
    const STENCIL_INDEX: u32 = 0x1901;
    #[classattr]
    const STENCIL_INDEX1: u32 = 0x8D46;
    #[classattr]
    const STENCIL_INDEX16: u32 = 0x8D49;
    #[classattr]
    const STENCIL_INDEX4: u32 = 0x8D47;
    #[classattr]
    const STENCIL_INDEX8: u32 = 0x8D48;
    #[classattr]
    const STENCIL_PASS_DEPTH_FAIL: u32 = 0x0B95;
    #[classattr]
    const STENCIL_PASS_DEPTH_PASS: u32 = 0x0B96;
    #[classattr]
    const STENCIL_REF: u32 = 0x0B97;
    #[classattr]
    const STENCIL_TEST: u32 = 0x0B90;
    #[classattr]
    const STENCIL_VALUE_MASK: u32 = 0x0B93;
    #[classattr]
    const STENCIL_WRITEMASK: u32 = 0x0B98;
    #[classattr]
    const STEREO: u32 = 0x0C33;
    #[classattr]
    const STORAGE_CACHED_APPLE: u32 = 0x85BE;
    #[classattr]
    const STORAGE_PRIVATE_APPLE: u32 = 0x85BD;
    #[classattr]
    const STORAGE_SHARED_APPLE: u32 = 0x85BF;
    #[classattr]
    const STREAM_COPY: u32 = 0x88E2;
    #[classattr]
    const STREAM_DRAW: u32 = 0x88E0;
    #[classattr]
    const STREAM_READ: u32 = 0x88E1;
    #[classattr]
    const SUBPIXEL_BITS: u32 = 0x0D50;
    #[classattr]
    const SUBTRACT: u32 = 0x84E7;
    #[classattr]
    const SYNC_CONDITION: u32 = 0x9113;
    #[classattr]
    const SYNC_FENCE: u32 = 0x9116;
    #[classattr]
    const SYNC_FLAGS: u32 = 0x9115;
    #[classattr]
    const SYNC_FLUSH_COMMANDS_BIT: u32 = 0x00000001;
    #[classattr]
    const SYNC_GPU_COMMANDS_COMPLETE: u32 = 0x9117;
    #[classattr]
    const SYNC_STATUS: u32 = 0x9114;
    #[classattr]
    const T: u32 = 0x2001;
    #[classattr]
    const T2F_C3F_V3F: u32 = 0x2A2A;
    #[classattr]
    const T2F_C4F_N3F_V3F: u32 = 0x2A2C;
    #[classattr]
    const T2F_C4UB_V3F: u32 = 0x2A29;
    #[classattr]
    const T2F_N3F_V3F: u32 = 0x2A2B;
    #[classattr]
    const T2F_V3F: u32 = 0x2A27;
    #[classattr]
    const T4F_C4F_N3F_V4F: u32 = 0x2A2D;
    #[classattr]
    const T4F_V4F: u32 = 0x2A28;
    #[classattr]
    const TEXTURE: u32 = 0x1702;
    #[classattr]
    const TEXTURE0: u32 = 0x84C0;
    #[classattr]
    const TEXTURE1: u32 = 0x84C1;
    #[classattr]
    const TEXTURE10: u32 = 0x84CA;
    #[classattr]
    const TEXTURE11: u32 = 0x84CB;
    #[classattr]
    const TEXTURE12: u32 = 0x84CC;
    #[classattr]
    const TEXTURE13: u32 = 0x84CD;
    #[classattr]
    const TEXTURE14: u32 = 0x84CE;
    #[classattr]
    const TEXTURE15: u32 = 0x84CF;
    #[classattr]
    const TEXTURE16: u32 = 0x84D0;
    #[classattr]
    const TEXTURE17: u32 = 0x84D1;
    #[classattr]
    const TEXTURE18: u32 = 0x84D2;
    #[classattr]
    const TEXTURE19: u32 = 0x84D3;
    #[classattr]
    const TEXTURE2: u32 = 0x84C2;
    #[classattr]
    const TEXTURE20: u32 = 0x84D4;
    #[classattr]
    const TEXTURE21: u32 = 0x84D5;
    #[classattr]
    const TEXTURE22: u32 = 0x84D6;
    #[classattr]
    const TEXTURE23: u32 = 0x84D7;
    #[classattr]
    const TEXTURE24: u32 = 0x84D8;
    #[classattr]
    const TEXTURE25: u32 = 0x84D9;
    #[classattr]
    const TEXTURE26: u32 = 0x84DA;
    #[classattr]
    const TEXTURE27: u32 = 0x84DB;
    #[classattr]
    const TEXTURE28: u32 = 0x84DC;
    #[classattr]
    const TEXTURE29: u32 = 0x84DD;
    #[classattr]
    const TEXTURE3: u32 = 0x84C3;
    #[classattr]
    const TEXTURE30: u32 = 0x84DE;
    #[classattr]
    const TEXTURE31: u32 = 0x84DF;
    #[classattr]
    const TEXTURE4: u32 = 0x84C4;
    #[classattr]
    const TEXTURE5: u32 = 0x84C5;
    #[classattr]
    const TEXTURE6: u32 = 0x84C6;
    #[classattr]
    const TEXTURE7: u32 = 0x84C7;
    #[classattr]
    const TEXTURE8: u32 = 0x84C8;
    #[classattr]
    const TEXTURE9: u32 = 0x84C9;
    #[classattr]
    const TEXTURE_1D: u32 = 0x0DE0;
    #[classattr]
    const TEXTURE_1D_ARRAY: u32 = 0x8C18;
    #[classattr]
    const TEXTURE_2D: u32 = 0x0DE1;
    #[classattr]
    const TEXTURE_2D_ARRAY: u32 = 0x8C1A;
    #[classattr]
    const TEXTURE_2D_MULTISAMPLE: u32 = 0x9100;
    #[classattr]
    const TEXTURE_2D_MULTISAMPLE_ARRAY: u32 = 0x9102;
    #[classattr]
    const TEXTURE_3D: u32 = 0x806F;
    #[classattr]
    const TEXTURE_ALPHA_SIZE: u32 = 0x805F;
    #[classattr]
    const TEXTURE_ALPHA_TYPE: u32 = 0x8C13;
    #[classattr]
    const TEXTURE_BASE_LEVEL: u32 = 0x813C;
    #[classattr]
    const TEXTURE_BINDING_1D: u32 = 0x8068;
    #[classattr]
    const TEXTURE_BINDING_1D_ARRAY: u32 = 0x8C1C;
    #[classattr]
    const TEXTURE_BINDING_2D: u32 = 0x8069;
    #[classattr]
    const TEXTURE_BINDING_2D_ARRAY: u32 = 0x8C1D;
    #[classattr]
    const TEXTURE_BINDING_2D_MULTISAMPLE: u32 = 0x9104;
    #[classattr]
    const TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY: u32 = 0x9105;
    #[classattr]
    const TEXTURE_BINDING_3D: u32 = 0x806A;
    #[classattr]
    const TEXTURE_BINDING_BUFFER: u32 = 0x8C2C;
    #[classattr]
    const TEXTURE_BINDING_CUBE_MAP: u32 = 0x8514;
    #[classattr]
    const TEXTURE_BINDING_EXTERNAL_OES: u32 = 0x8D67;
    #[classattr]
    const TEXTURE_BINDING_RECTANGLE: u32 = 0x84F6;
    #[classattr]
    const TEXTURE_BINDING_RECTANGLE_ARB: u32 = 0x84F6;
    #[classattr]
    const TEXTURE_BIT: u32 = 0x00040000;
    #[classattr]
    const TEXTURE_BLUE_SIZE: u32 = 0x805E;
    #[classattr]
    const TEXTURE_BLUE_TYPE: u32 = 0x8C12;
    #[classattr]
    const TEXTURE_BORDER: u32 = 0x1005;
    #[classattr]
    const TEXTURE_BORDER_COLOR: u32 = 0x1004;
    #[classattr]
    const TEXTURE_BUFFER: u32 = 0x8C2A;
    #[classattr]
    const TEXTURE_BUFFER_DATA_STORE_BINDING: u32 = 0x8C2D;
    #[classattr]
    const TEXTURE_COMPARE_FUNC: u32 = 0x884D;
    #[classattr]
    const TEXTURE_COMPARE_MODE: u32 = 0x884C;
    #[classattr]
    const TEXTURE_COMPONENTS: u32 = 0x1003;
    #[classattr]
    const TEXTURE_COMPRESSED: u32 = 0x86A1;
    #[classattr]
    const TEXTURE_COMPRESSED_IMAGE_SIZE: u32 = 0x86A0;
    #[classattr]
    const TEXTURE_COMPRESSION_HINT: u32 = 0x84EF;
    #[classattr]
    const TEXTURE_COORD_ARRAY: u32 = 0x8078;
    #[classattr]
    const TEXTURE_COORD_ARRAY_BUFFER_BINDING: u32 = 0x889A;
    #[classattr]
    const TEXTURE_COORD_ARRAY_POINTER: u32 = 0x8092;
    #[classattr]
    const TEXTURE_COORD_ARRAY_SIZE: u32 = 0x8088;
    #[classattr]
    const TEXTURE_COORD_ARRAY_STRIDE: u32 = 0x808A;
    #[classattr]
    const TEXTURE_COORD_ARRAY_TYPE: u32 = 0x8089;
    #[classattr]
    const TEXTURE_CUBE_MAP: u32 = 0x8513;
    #[classattr]
    const TEXTURE_CUBE_MAP_NEGATIVE_X: u32 = 0x8516;
    #[classattr]
    const TEXTURE_CUBE_MAP_NEGATIVE_Y: u32 = 0x8518;
    #[classattr]
    const TEXTURE_CUBE_MAP_NEGATIVE_Z: u32 = 0x851A;
    #[classattr]
    const TEXTURE_CUBE_MAP_POSITIVE_X: u32 = 0x8515;
    #[classattr]
    const TEXTURE_CUBE_MAP_POSITIVE_Y: u32 = 0x8517;
    #[classattr]
    const TEXTURE_CUBE_MAP_POSITIVE_Z: u32 = 0x8519;
    #[classattr]
    const TEXTURE_CUBE_MAP_SEAMLESS: u32 = 0x884F;
    #[classattr]
    const TEXTURE_DEPTH: u32 = 0x8071;
    #[classattr]
    const TEXTURE_DEPTH_SIZE: u32 = 0x884A;
    #[classattr]
    const TEXTURE_DEPTH_TYPE: u32 = 0x8C16;
    #[classattr]
    const TEXTURE_ENV: u32 = 0x2300;
    #[classattr]
    const TEXTURE_ENV_COLOR: u32 = 0x2201;
    #[classattr]
    const TEXTURE_ENV_MODE: u32 = 0x2200;
    #[classattr]
    const TEXTURE_EXTERNAL_OES: u32 = 0x8D65;
    #[classattr]
    const TEXTURE_FILTER_CONTROL: u32 = 0x8500;
    #[classattr]
    const TEXTURE_FIXED_SAMPLE_LOCATIONS: u32 = 0x9107;
    #[classattr]
    const TEXTURE_GEN_MODE: u32 = 0x2500;
    #[classattr]
    const TEXTURE_GEN_Q: u32 = 0x0C63;
    #[classattr]
    const TEXTURE_GEN_R: u32 = 0x0C62;
    #[classattr]
    const TEXTURE_GEN_S: u32 = 0x0C60;
    #[classattr]
    const TEXTURE_GEN_T: u32 = 0x0C61;
    #[classattr]
    const TEXTURE_GREEN_SIZE: u32 = 0x805D;
    #[classattr]
    const TEXTURE_GREEN_TYPE: u32 = 0x8C11;
    #[classattr]
    const TEXTURE_HEIGHT: u32 = 0x1001;
    #[classattr]
    const TEXTURE_IMMUTABLE_FORMAT: u32 = 0x912F;
    #[classattr]
    const TEXTURE_IMMUTABLE_FORMAT_EXT: u32 = 0x912F;
    #[classattr]
    const TEXTURE_IMMUTABLE_LEVELS: u32 = 0x82DF;
    #[classattr]
    const TEXTURE_INTENSITY_SIZE: u32 = 0x8061;
    #[classattr]
    const TEXTURE_INTENSITY_TYPE: u32 = 0x8C15;
    #[classattr]
    const TEXTURE_INTERNAL_FORMAT: u32 = 0x1003;
    #[classattr]
    const TEXTURE_LOD_BIAS: u32 = 0x8501;
    #[classattr]
    const TEXTURE_LUMINANCE_SIZE: u32 = 0x8060;
    #[classattr]
    const TEXTURE_LUMINANCE_TYPE: u32 = 0x8C14;
    #[classattr]
    const TEXTURE_MAG_FILTER: u32 = 0x2800;
    #[classattr]
    const TEXTURE_MATRIX: u32 = 0x0BA8;
    #[classattr]
    const TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FE;
    #[classattr]
    const TEXTURE_MAX_LEVEL: u32 = 0x813D;
    #[classattr]
    const TEXTURE_MAX_LOD: u32 = 0x813B;
    #[classattr]
    const TEXTURE_MIN_FILTER: u32 = 0x2801;
    #[classattr]
    const TEXTURE_MIN_LOD: u32 = 0x813A;
    #[classattr]
    const TEXTURE_PRIORITY: u32 = 0x8066;
    #[classattr]
    const TEXTURE_RANGE_LENGTH_APPLE: u32 = 0x85B7;
    #[classattr]
    const TEXTURE_RANGE_POINTER_APPLE: u32 = 0x85B8;
    #[classattr]
    const TEXTURE_RECTANGLE: u32 = 0x84F5;
    #[classattr]
    const TEXTURE_RECTANGLE_ARB: u32 = 0x84F5;
    #[classattr]
    const TEXTURE_RED_SIZE: u32 = 0x805C;
    #[classattr]
    const TEXTURE_RED_TYPE: u32 = 0x8C10;
    #[classattr]
    const TEXTURE_RESIDENT: u32 = 0x8067;
    #[classattr]
    const TEXTURE_SAMPLES: u32 = 0x9106;
    #[classattr]
    const TEXTURE_SHARED_SIZE: u32 = 0x8C3F;
    #[classattr]
    const TEXTURE_STACK_DEPTH: u32 = 0x0BA5;
    #[classattr]
    const TEXTURE_STENCIL_SIZE: u32 = 0x88F1;
    #[classattr]
    const TEXTURE_STORAGE_HINT_APPLE: u32 = 0x85BC;
    #[classattr]
    const TEXTURE_SWIZZLE_A: u32 = 0x8E45;
    #[classattr]
    const TEXTURE_SWIZZLE_B: u32 = 0x8E44;
    #[classattr]
    const TEXTURE_SWIZZLE_G: u32 = 0x8E43;
    #[classattr]
    const TEXTURE_SWIZZLE_R: u32 = 0x8E42;
    #[classattr]
    const TEXTURE_SWIZZLE_RGBA: u32 = 0x8E46;
    #[classattr]
    const TEXTURE_USAGE_ANGLE: u32 = 0x93A2;
    #[classattr]
    const TEXTURE_WIDTH: u32 = 0x1000;
    #[classattr]
    const TEXTURE_WRAP_R: u32 = 0x8072;
    #[classattr]
    const TEXTURE_WRAP_S: u32 = 0x2802;
    #[classattr]
    const TEXTURE_WRAP_T: u32 = 0x2803;
    #[classattr]
    const TIMEOUT_EXPIRED: u32 = 0x911B;
    #[classattr]
    const TIMEOUT_IGNORED: u64 = 0xFFFFFFFFFFFFFFFF;
    #[classattr]
    const TIMESTAMP: u32 = 0x8E28;
    #[classattr]
    const TIMESTAMP_EXT: u32 = 0x8E28;
    #[classattr]
    const TIME_ELAPSED: u32 = 0x88BF;
    #[classattr]
    const TIME_ELAPSED_EXT: u32 = 0x88BF;
    #[classattr]
    const TRANSFORM_BIT: u32 = 0x00001000;
    #[classattr]
    const TRANSFORM_FEEDBACK: u32 = 0x8E22;
    #[classattr]
    const TRANSFORM_FEEDBACK_ACTIVE: u32 = 0x8E24;
    #[classattr]
    const TRANSFORM_FEEDBACK_BINDING: u32 = 0x8E25;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER: u32 = 0x8C8E;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER_BINDING: u32 = 0x8C8F;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER_MODE: u32 = 0x8C7F;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER_SIZE: u32 = 0x8C85;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER_START: u32 = 0x8C84;
    #[classattr]
    const TRANSFORM_FEEDBACK_PAUSED: u32 = 0x8E23;
    #[classattr]
    const TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: u32 = 0x8C88;
    #[classattr]
    const TRANSFORM_FEEDBACK_VARYINGS: u32 = 0x8C83;
    #[classattr]
    const TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: u32 = 0x8C76;
    #[classattr]
    const TRANSPOSE_COLOR_MATRIX: u32 = 0x84E6;
    #[classattr]
    const TRANSPOSE_MODELVIEW_MATRIX: u32 = 0x84E3;
    #[classattr]
    const TRANSPOSE_PROJECTION_MATRIX: u32 = 0x84E4;
    #[classattr]
    const TRANSPOSE_TEXTURE_MATRIX: u32 = 0x84E5;
    #[classattr]
    const TRIANGLES: u32 = 0x0004;
    #[classattr]
    const TRIANGLES_ADJACENCY: u32 = 0x000C;
    #[classattr]
    const TRIANGLE_FAN: u32 = 0x0006;
    #[classattr]
    const TRIANGLE_STRIP: u32 = 0x0005;
    #[classattr]
    const TRIANGLE_STRIP_ADJACENCY: u32 = 0x000D;
    #[classattr]
    const TRUE: u8 = 1;
    #[classattr]
    const UNIFORM_ARRAY_STRIDE: u32 = 0x8A3C;
    #[classattr]
    const UNIFORM_BLOCK_ACTIVE_UNIFORMS: u32 = 0x8A42;
    #[classattr]
    const UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: u32 = 0x8A43;
    #[classattr]
    const UNIFORM_BLOCK_BINDING: u32 = 0x8A3F;
    #[classattr]
    const UNIFORM_BLOCK_DATA_SIZE: u32 = 0x8A40;
    #[classattr]
    const UNIFORM_BLOCK_INDEX: u32 = 0x8A3A;
    #[classattr]
    const UNIFORM_BLOCK_NAME_LENGTH: u32 = 0x8A41;
    #[classattr]
    const UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: u32 = 0x8A46;
    #[classattr]
    const UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER: u32 = 0x8A45;
    #[classattr]
    const UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: u32 = 0x8A44;
    #[classattr]
    const UNIFORM_BUFFER: u32 = 0x8A11;
    #[classattr]
    const UNIFORM_BUFFER_BINDING: u32 = 0x8A28;
    #[classattr]
    const UNIFORM_BUFFER_OFFSET_ALIGNMENT: u32 = 0x8A34;
    #[classattr]
    const UNIFORM_BUFFER_SIZE: u32 = 0x8A2A;
    #[classattr]
    const UNIFORM_BUFFER_START: u32 = 0x8A29;
    #[classattr]
    const UNIFORM_IS_ROW_MAJOR: u32 = 0x8A3E;
    #[classattr]
    const UNIFORM_MATRIX_STRIDE: u32 = 0x8A3D;
    #[classattr]
    const UNIFORM_NAME_LENGTH: u32 = 0x8A39;
    #[classattr]
    const UNIFORM_OFFSET: u32 = 0x8A3B;
    #[classattr]
    const UNIFORM_SIZE: u32 = 0x8A38;
    #[classattr]
    const UNIFORM_TYPE: u32 = 0x8A37;
    #[classattr]
    const UNPACK_ALIGNMENT: u32 = 0x0CF5;
    #[classattr]
    const UNPACK_CLIENT_STORAGE_APPLE: u32 = 0x85B2;
    #[classattr]
    const UNPACK_IMAGE_HEIGHT: u32 = 0x806E;
    #[classattr]
    const UNPACK_LSB_FIRST: u32 = 0x0CF1;
    #[classattr]
    const UNPACK_ROW_LENGTH: u32 = 0x0CF2;
    #[classattr]
    const UNPACK_SKIP_IMAGES: u32 = 0x806D;
    #[classattr]
    const UNPACK_SKIP_PIXELS: u32 = 0x0CF4;
    #[classattr]
    const UNPACK_SKIP_ROWS: u32 = 0x0CF3;
    #[classattr]
    const UNPACK_SWAP_BYTES: u32 = 0x0CF0;
    #[classattr]
    const UNSIGNALED: u32 = 0x9118;
    #[classattr]
    const UNSIGNED_BYTE: u32 = 0x1401;
    #[classattr]
    const UNSIGNED_BYTE_2_3_3_REV: u32 = 0x8362;
    #[classattr]
    const UNSIGNED_BYTE_3_3_2: u32 = 0x8032;
    #[classattr]
    const UNSIGNED_INT: u32 = 0x1405;
    #[classattr]
    const UNSIGNED_INT_10F_11F_11F_REV: u32 = 0x8C3B;
    #[classattr]
    const UNSIGNED_INT_10_10_10_2: u32 = 0x8036;
    #[classattr]
    const UNSIGNED_INT_24_8: u32 = 0x84FA;
    #[classattr]
    const UNSIGNED_INT_2_10_10_10_REV: u32 = 0x8368;
    #[classattr]
    const UNSIGNED_INT_5_9_9_9_REV: u32 = 0x8C3E;
    #[classattr]
    const UNSIGNED_INT_8_8_8_8: u32 = 0x8035;
    #[classattr]
    const UNSIGNED_INT_8_8_8_8_REV: u32 = 0x8367;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_1D: u32 = 0x8DD1;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_1D_ARRAY: u32 = 0x8DD6;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D: u32 = 0x8DD2;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D_ARRAY: u32 = 0x8DD7;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x910A;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910D;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D_RECT: u32 = 0x8DD5;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_3D: u32 = 0x8DD3;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_BUFFER: u32 = 0x8DD8;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_CUBE: u32 = 0x8DD4;
    #[classattr]
    const UNSIGNED_INT_VEC2: u32 = 0x8DC6;
    #[classattr]
    const UNSIGNED_INT_VEC3: u32 = 0x8DC7;
    #[classattr]
    const UNSIGNED_INT_VEC4: u32 = 0x8DC8;
    #[classattr]
    const UNSIGNED_NORMALIZED: u32 = 0x8C17;
    #[classattr]
    const UNSIGNED_SHORT: u32 = 0x1403;
    #[classattr]
    const UNSIGNED_SHORT_1_5_5_5_REV: u32 = 0x8366;
    #[classattr]
    const UNSIGNED_SHORT_4_4_4_4: u32 = 0x8033;
    #[classattr]
    const UNSIGNED_SHORT_4_4_4_4_REV: u32 = 0x8365;
    #[classattr]
    const UNSIGNED_SHORT_5_5_5_1: u32 = 0x8034;
    #[classattr]
    const UNSIGNED_SHORT_5_6_5: u32 = 0x8363;
    #[classattr]
    const UNSIGNED_SHORT_5_6_5_REV: u32 = 0x8364;
    #[classattr]
    const UPPER_LEFT: u32 = 0x8CA2;
    #[classattr]
    const V2F: u32 = 0x2A20;
    #[classattr]
    const V3F: u32 = 0x2A21;
    #[classattr]
    const VALIDATE_STATUS: u32 = 0x8B83;
    #[classattr]
    const VENDOR: u32 = 0x1F00;
    #[classattr]
    const VERSION: u32 = 0x1F02;
    #[classattr]
    const VERTEX_ARRAY: u32 = 0x8074;
    #[classattr]
    const VERTEX_ARRAY_BINDING: u32 = 0x85B5;
    #[classattr]
    const VERTEX_ARRAY_BINDING_APPLE: u32 = 0x85B5;
    #[classattr]
    const VERTEX_ARRAY_BUFFER_BINDING: u32 = 0x8896;
    #[classattr]
    const VERTEX_ARRAY_KHR: u32 = 0x8074;
    #[classattr]
    const VERTEX_ARRAY_POINTER: u32 = 0x808E;
    #[classattr]
    const VERTEX_ARRAY_SIZE: u32 = 0x807A;
    #[classattr]
    const VERTEX_ARRAY_STRIDE: u32 = 0x807C;
    #[classattr]
    const VERTEX_ARRAY_TYPE: u32 = 0x807B;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: u32 = 0x889F;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_DIVISOR: u32 = 0x88FE;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_ENABLED: u32 = 0x8622;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_INTEGER: u32 = 0x88FD;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_NORMALIZED: u32 = 0x886A;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_POINTER: u32 = 0x8645;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_SIZE: u32 = 0x8623;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_STRIDE: u32 = 0x8624;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_TYPE: u32 = 0x8625;
    #[classattr]
    const VERTEX_PROGRAM_POINT_SIZE: u32 = 0x8642;
    #[classattr]
    const VERTEX_PROGRAM_TWO_SIDE: u32 = 0x8643;
    #[classattr]
    const VERTEX_SHADER: u32 = 0x8B31;
    #[classattr]
    const VIEWPORT: u32 = 0x0BA2;
    #[classattr]
    const VIEWPORT_BIT: u32 = 0x00000800;
    #[classattr]
    const WAIT_FAILED: u32 = 0x911D;
    #[classattr]
    const WEIGHT_ARRAY_BUFFER_BINDING: u32 = 0x889E;
    #[classattr]
    const WRITE_ONLY: u32 = 0x88B9;
    #[classattr]
    const XOR: u32 = 0x1506;
    #[classattr]
    const ZERO: u32 = 0;
    #[classattr]
    const ZOOM_X: u32 = 0x0D16;
    #[classattr]
    const ZOOM_Y: u32 = 0x0D17;

    fn get_type(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn buffer_data_untyped(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn buffer_sub_data_untyped(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn map_buffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn map_buffer_range(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn unmap_buffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_buffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn shader_source(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn read_buffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn read_pixels_into_buffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn read_pixels(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn read_pixels_into_pbo(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn sample_coverage(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn polygon_offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn pixel_store_i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn gen_buffers(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn gen_renderbuffers(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn gen_framebuffers(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn gen_textures(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn gen_vertex_arrays(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn gen_queries(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn begin_query(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn end_query(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn query_counter(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_query_object_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_query_object_uiv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_query_object_i64v(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_query_object_ui64v(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_queries(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_vertex_arrays(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_buffers(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_renderbuffers(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_framebuffers(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_textures(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn framebuffer_renderbuffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn renderbuffer_storage(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn depth_func(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn active_texture(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn attach_shader(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_attrib_location(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_uniform_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_uniform_fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_uniform_block_index(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_uniform_indices(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_buffer_base(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_buffer_range(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_block_binding(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_buffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_vertex_array(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_renderbuffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_framebuffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_texture(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn draw_buffers(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_image_2d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn compressed_tex_image_2d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn compressed_tex_sub_image_2d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_image_3d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn copy_tex_image_2d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn copy_tex_sub_image_2d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn copy_tex_sub_image_3d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_sub_image_2d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_sub_image_2d_pbo(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_sub_image_3d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_sub_image_3d_pbo(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_storage_2d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_storage_3d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_tex_image_into_buffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn copy_image_sub_data(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn invalidate_framebuffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn invalidate_sub_framebuffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_integer_v(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_integer_64v(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_integer_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_integer_64iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_boolean_v(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_float_v(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_framebuffer_attachment_parameter_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_renderbuffer_parameter_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_tex_parameter_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_tex_parameter_fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_parameter_i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_parameter_f(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn framebuffer_texture_2d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn framebuffer_texture_layer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn blit_framebuffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn vertex_attrib_4f(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn vertex_attrib_pointer_f32(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn vertex_attrib_pointer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn vertex_attrib_i_pointer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn vertex_attrib_divisor(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn viewport(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn scissor(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn line_width(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn use_program(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn validate_program(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn draw_arrays(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn draw_arrays_instanced(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn draw_elements(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn draw_elements_instanced(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn blend_color(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn blend_func(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn blend_func_separate(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn blend_equation(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn blend_equation_separate(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn color_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn cull_face(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn front_face(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn enable(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn disable(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn hint(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_enabled(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_shader(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_texture(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_framebuffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_renderbuffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn check_frame_buffer_status(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn enable_vertex_attrib_array(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn disable_vertex_attrib_array(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_1f(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_1fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_1i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_1iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_1ui(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_2f(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_2fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_2i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_2iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_2ui(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_3f(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_3fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_3i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_3iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_3ui(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_4f(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_4i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_4iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_4ui(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_4fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_matrix_2fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_matrix_3fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_matrix_4fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn depth_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn depth_range(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_active_attrib(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_active_uniform(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_active_uniforms_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_active_uniform_block_i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_active_uniform_block_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_active_uniform_block_name(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_attrib_location(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_frag_data_location(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_uniform_location(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_program_info_log(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_program_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_program_binary(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn program_binary(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn program_parameter_i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_vertex_attrib_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_vertex_attrib_fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_vertex_attrib_pointer_v(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_buffer_parameter_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_shader_info_log(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_string(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_string_i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_shader_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_shader_precision_format(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn compile_shader(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn create_program(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_program(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn create_shader(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_shader(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn detach_shader(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn link_program(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn clear_color(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn clear(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn clear_depth(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn clear_stencil(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn flush(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn finish(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_error(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn stencil_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn stencil_mask_separate(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn stencil_func(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn stencil_func_separate(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn stencil_op(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn stencil_op_separate(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn egl_image_target_texture2d_oes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn generate_mipmap(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn insert_event_marker_ext(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn push_group_marker_ext(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn pop_group_marker_ext(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn debug_message_insert_khr(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn push_debug_group_khr(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn pop_debug_group_khr(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn fence_sync(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn client_wait_sync(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn wait_sync(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_sync(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn texture_range_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn gen_fences_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_fences_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_fence_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn finish_fence_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn test_fence_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn test_object_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn finish_object_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_frag_data_index(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn blend_barrier_khr(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_frag_data_location_indexed(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_debug_messages(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn provoking_vertex_angle(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn gen_vertex_arrays_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_vertex_array_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_vertex_arrays_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn copy_texture_chromium(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn copy_sub_texture_chromium(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn egl_image_target_renderbuffer_storage_oes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn copy_texture_3d_angle(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn copy_sub_texture_3d_angle(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn buffer_storage(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn flush_mapped_buffer_range(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzGlContextPtr {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlContextPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlContextPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAzGlTypeEnumWrapper {
    #[classattr]
    const Gl: AzAzGlType = AzAzGlType::Gl;
    #[classattr]
    const Gles: AzAzGlType = AzAzGlType::Gles;
}

#[pyproto]
impl PyObjectProtocol for AzAzGlTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::AzGlType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::AzGlType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAzGlTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzU8VecRef {
}

#[pyproto]
impl PyObjectProtocol for AzU8VecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::U8VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::U8VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU8VecRefMut {
}

#[pyproto]
impl PyObjectProtocol for AzU8VecRefMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::U8VecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::U8VecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzF32VecRef {
}

#[pyproto]
impl PyObjectProtocol for AzF32VecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::F32VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::F32VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzI32VecRef {
}

#[pyproto]
impl PyObjectProtocol for AzI32VecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::I32VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::I32VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLuintVecRef {
}

#[pyproto]
impl PyObjectProtocol for AzGLuintVecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLuintVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLuintVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLenumVecRef {
}

#[pyproto]
impl PyObjectProtocol for AzGLenumVecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLenumVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLenumVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLintVecRefMut {
}

#[pyproto]
impl PyObjectProtocol for AzGLintVecRefMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLintVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLintVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLint64VecRefMut {
}

#[pyproto]
impl PyObjectProtocol for AzGLint64VecRefMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLint64VecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLint64VecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLbooleanVecRefMut {
}

#[pyproto]
impl PyObjectProtocol for AzGLbooleanVecRefMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLbooleanVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLbooleanVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLfloatVecRefMut {
}

#[pyproto]
impl PyObjectProtocol for AzGLfloatVecRefMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLfloatVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLfloatVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRefstrVecRef {
}

#[pyproto]
impl PyObjectProtocol for AzRefstrVecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::RefstrVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::RefstrVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRefstr {
}

#[pyproto]
impl PyObjectProtocol for AzRefstr {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::Refstr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::Refstr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGetProgramBinaryReturn {
}

#[pyproto]
impl PyObjectProtocol for AzGetProgramBinaryReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GetProgramBinaryReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GetProgramBinaryReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGetActiveAttribReturn {
}

#[pyproto]
impl PyObjectProtocol for AzGetActiveAttribReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GetActiveAttribReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GetActiveAttribReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLsyncPtr {
}

#[pyproto]
impl PyObjectProtocol for AzGLsyncPtr {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLsyncPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLsyncPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGetActiveUniformReturn {
}

#[pyproto]
impl PyObjectProtocol for AzGetActiveUniformReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GetActiveUniformReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GetActiveUniformReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAzDebugMessage {
}

#[pyproto]
impl PyObjectProtocol for AzAzDebugMessage {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::AzDebugMessage = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::AzDebugMessage = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzImageRef {
    #[staticmethod]
    fn null_image(/* args */) -> AzImageRef {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn raw_image(/* args */) -> AzImageRef {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn gl_texture(/* args */) -> AzImageRef {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn clone_bytes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_invalid(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_gl_texture(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_raw_image(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_callback(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_raw_image(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_hash(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzImageRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::ImageRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::ImageRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRawImage {
    #[staticmethod]
    fn empty(/* args */) -> AzRawImage {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn allocate_clip_mask(/* args */) -> AzRawImage {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn decode_image_bytes_any(/* args */) -> AzRawImage {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn draw_clip_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn encode_bmp(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn encode_png(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn encode_jpeg(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn encode_tga(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn encode_pnm(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn encode_gif(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn encode_tiff(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzRawImage {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::RawImage = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::RawImage = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzImageMask {
}

#[pyproto]
impl PyObjectProtocol for AzImageMask {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::ImageMask = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::ImageMask = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRawImageFormatEnumWrapper {
    #[classattr]
    const R8: AzRawImageFormat = AzRawImageFormat::R8;
    #[classattr]
    const RG8: AzRawImageFormat = AzRawImageFormat::RG8;
    #[classattr]
    const RGB8: AzRawImageFormat = AzRawImageFormat::RGB8;
    #[classattr]
    const RGBA8: AzRawImageFormat = AzRawImageFormat::RGBA8;
    #[classattr]
    const R16: AzRawImageFormat = AzRawImageFormat::R16;
    #[classattr]
    const RG16: AzRawImageFormat = AzRawImageFormat::RG16;
    #[classattr]
    const RGB16: AzRawImageFormat = AzRawImageFormat::RGB16;
    #[classattr]
    const RGBA16: AzRawImageFormat = AzRawImageFormat::RGBA16;
    #[classattr]
    const BGR8: AzRawImageFormat = AzRawImageFormat::BGR8;
    #[classattr]
    const BGRA8: AzRawImageFormat = AzRawImageFormat::BGRA8;
    #[classattr]
    const RGBF32: AzRawImageFormat = AzRawImageFormat::RGBF32;
    #[classattr]
    const RGBAF32: AzRawImageFormat = AzRawImageFormat::RGBAF32;
}

#[pyproto]
impl PyObjectProtocol for AzRawImageFormatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::RawImageFormat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::RawImageFormat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzRawImageFormatEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzEncodeImageErrorEnumWrapper {
    #[classattr]
    const EncoderNotAvailable: AzEncodeImageError = AzEncodeImageError::EncoderNotAvailable;
    #[classattr]
    const InsufficientMemory: AzEncodeImageError = AzEncodeImageError::InsufficientMemory;
    #[classattr]
    const DimensionError: AzEncodeImageError = AzEncodeImageError::DimensionError;
    #[classattr]
    const InvalidData: AzEncodeImageError = AzEncodeImageError::InvalidData;
    #[classattr]
    const Unknown: AzEncodeImageError = AzEncodeImageError::Unknown;
}

#[pyproto]
impl PyObjectProtocol for AzEncodeImageErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::image::encode::EncodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::image::encode::EncodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzEncodeImageErrorEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzDecodeImageErrorEnumWrapper {
    #[classattr]
    const InsufficientMemory: AzDecodeImageError = AzDecodeImageError::InsufficientMemory;
    #[classattr]
    const DimensionError: AzDecodeImageError = AzDecodeImageError::DimensionError;
    #[classattr]
    const UnsupportedImageFormat: AzDecodeImageError = AzDecodeImageError::UnsupportedImageFormat;
    #[classattr]
    const Unknown: AzDecodeImageError = AzDecodeImageError::Unknown;
}

#[pyproto]
impl PyObjectProtocol for AzDecodeImageErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::image::decode::DecodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::image::decode::DecodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzDecodeImageErrorEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzRawImageDataEnumWrapper {
    #[staticmethod]
    fn U8(v: U8Vec) -> AzRawImageDataEnumWrapper {
        AzRawImageDataEnumWrapper { inner: AzRawImageData::U8(v) }}
    }
    #[staticmethod]
    fn U16(v: U16Vec) -> AzRawImageDataEnumWrapper {
        AzRawImageDataEnumWrapper { inner: AzRawImageData::U16(v) }}
    }
    #[staticmethod]
    fn F32(v: F32Vec) -> AzRawImageDataEnumWrapper {
        AzRawImageDataEnumWrapper { inner: AzRawImageData::F32(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzRawImageData;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzRawImageData::U8(v) => Ok(vec!["U8".into_py(py), v.into_py(py)]),
            AzRawImageData::U16(v) => Ok(vec!["U16".into_py(py), v.into_py(py)]),
            AzRawImageData::F32(v) => Ok(vec!["F32".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRawImageDataEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::RawImageData = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::RawImageData = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFontMetrics {
    #[staticmethod]
    fn zero(/* args */) -> AzFontMetrics {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn use_typo_metrics(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_ascender(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_descender(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_line_gap(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_x_min(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_min(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_x_max(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_max(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_advance_width_max(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_min_left_side_bearing(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_min_right_side_bearing(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_x_max_extent(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_x_avg_char_width(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_subscript_x_size(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_subscript_y_size(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_subscript_x_offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_subscript_y_offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_superscript_x_size(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_superscript_y_size(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_superscript_x_offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_superscript_y_offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_strikeout_size(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_strikeout_position(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzFontMetrics {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::FontMetrics = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::FontMetrics = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFontRef {
    #[staticmethod]
    fn parse(/* args */) -> AzFontRef {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn get_bytes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_font_metrics(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn shape_text(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_hash(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzFontRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::FontRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::FontRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLoadedFontSource {
}

#[pyproto]
impl PyObjectProtocol for AzLoadedFontSource {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::LoadedFontSource = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::app_resources::LoadedFontSource = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvg {
    #[staticmethod]
    fn from_string(/* args */) -> AzSvg {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn from_bytes(/* args */) -> AzSvg {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn get_root(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn render(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn to_string(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvg {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::xml::svg::Svg = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::xml::svg::Svg = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgXmlNode {
    #[staticmethod]
    fn parse_from(/* args */) -> AzSvgXmlNode {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgXmlNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::xml::svg::SvgXmlNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::xml::svg::SvgXmlNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgMultiPolygon {
    fn get_bounds(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn contains_point(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn union(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn intersection(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn difference(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn xor(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_fill(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_stroke(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgMultiPolygon {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgMultiPolygon = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgMultiPolygon = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgNodeEnumWrapper {
    #[staticmethod]
    fn MultiPolygonCollection(v: SvgMultiPolygonVec) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper { inner: AzSvgNode::MultiPolygonCollection(v) }}
    }
    #[staticmethod]
    fn MultiPolygon(v: SvgMultiPolygon) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper { inner: AzSvgNode::MultiPolygon(v) }}
    }
    #[staticmethod]
    fn MultiShape(v: SvgSimpleNodeVec) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper { inner: AzSvgNode::MultiShape(v) }}
    }
    #[staticmethod]
    fn Path(v: SvgPath) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper { inner: AzSvgNode::Path(v) }}
    }
    #[staticmethod]
    fn Circle(v: SvgCircle) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper { inner: AzSvgNode::Circle(v) }}
    }
    #[staticmethod]
    fn Rect(v: SvgRect) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper { inner: AzSvgNode::Rect(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgNode;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgNode::MultiPolygonCollection(v) => Ok(vec!["MultiPolygonCollection".into_py(py), v.into_py(py)]),
            AzSvgNode::MultiPolygon(v) => Ok(vec!["MultiPolygon".into_py(py), v.into_py(py)]),
            AzSvgNode::MultiShape(v) => Ok(vec!["MultiShape".into_py(py), v.into_py(py)]),
            AzSvgNode::Path(v) => Ok(vec!["Path".into_py(py), v.into_py(py)]),
            AzSvgNode::Circle(v) => Ok(vec!["Circle".into_py(py), v.into_py(py)]),
            AzSvgNode::Rect(v) => Ok(vec!["Rect".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgNodeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgNode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgNode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgSimpleNodeEnumWrapper {
    #[staticmethod]
    fn Path(v: SvgPath) -> AzSvgSimpleNodeEnumWrapper {
        AzSvgSimpleNodeEnumWrapper { inner: AzSvgSimpleNode::Path(v) }}
    }
    #[staticmethod]
    fn Circle(v: SvgCircle) -> AzSvgSimpleNodeEnumWrapper {
        AzSvgSimpleNodeEnumWrapper { inner: AzSvgSimpleNode::Circle(v) }}
    }
    #[staticmethod]
    fn Rect(v: SvgRect) -> AzSvgSimpleNodeEnumWrapper {
        AzSvgSimpleNodeEnumWrapper { inner: AzSvgSimpleNode::Rect(v) }}
    }
    #[staticmethod]
    fn CircleHole(v: SvgCircle) -> AzSvgSimpleNodeEnumWrapper {
        AzSvgSimpleNodeEnumWrapper { inner: AzSvgSimpleNode::CircleHole(v) }}
    }
    #[staticmethod]
    fn RectHole(v: SvgRect) -> AzSvgSimpleNodeEnumWrapper {
        AzSvgSimpleNodeEnumWrapper { inner: AzSvgSimpleNode::RectHole(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgSimpleNode;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgSimpleNode::Path(v) => Ok(vec!["Path".into_py(py), v.into_py(py)]),
            AzSvgSimpleNode::Circle(v) => Ok(vec!["Circle".into_py(py), v.into_py(py)]),
            AzSvgSimpleNode::Rect(v) => Ok(vec!["Rect".into_py(py), v.into_py(py)]),
            AzSvgSimpleNode::CircleHole(v) => Ok(vec!["CircleHole".into_py(py), v.into_py(py)]),
            AzSvgSimpleNode::RectHole(v) => Ok(vec!["RectHole".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgSimpleNodeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgSimpleNode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgSimpleNode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgStyledNode {
    fn tessellate(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgStyledNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgStyledNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgStyledNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgCircle {
    fn tessellate_fill(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_stroke(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgCircle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgCircle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgCircle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPath {
    fn is_closed(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn reverse(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_start(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_end(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_bounds(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn join_with(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bevel(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_fill(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_stroke(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgPath {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathElementEnumWrapper {
    #[staticmethod]
    fn Line(v: SvgLine) -> AzSvgPathElementEnumWrapper {
        AzSvgPathElementEnumWrapper { inner: AzSvgPathElement::Line(v) }}
    }
    #[staticmethod]
    fn QuadraticCurve(v: SvgQuadraticCurve) -> AzSvgPathElementEnumWrapper {
        AzSvgPathElementEnumWrapper { inner: AzSvgPathElement::QuadraticCurve(v) }}
    }
    #[staticmethod]
    fn CubicCurve(v: SvgCubicCurve) -> AzSvgPathElementEnumWrapper {
        AzSvgPathElementEnumWrapper { inner: AzSvgPathElement::CubicCurve(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgPathElement;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgPathElement::Line(v) => Ok(vec!["Line".into_py(py), v.into_py(py)]),
            AzSvgPathElement::QuadraticCurve(v) => Ok(vec!["QuadraticCurve".into_py(py), v.into_py(py)]),
            AzSvgPathElement::CubicCurve(v) => Ok(vec!["CubicCurve".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathElementEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathElement = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathElement = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPoint {
    fn distance(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgPoint {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::xml::svg::SvgPoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::xml::svg::SvgPoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgVector {
    fn angle_degrees(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn normalize(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn rotate_90deg_ccw(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgVector {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::xml::svg::SvgVector = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::xml::svg::SvgVector = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgLine {
    fn reverse(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_start(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_end(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_bounds(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_length(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_t_at_offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_x_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_tangent_vector_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn intersect(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_stroke(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgLine {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgLine = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgLine = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgQuadraticCurve {
    fn reverse(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_start(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_end(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_bounds(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_length(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_t_at_offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_x_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_tangent_vector_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_stroke(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgQuadraticCurve {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::xml::svg::SvgQuadraticCurve = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::xml::svg::SvgQuadraticCurve = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgCubicCurve {
    fn reverse(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_start(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_end(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_bounds(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_length(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_t_at_offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_x_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_tangent_vector_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_stroke(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgCubicCurve {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::xml::svg::SvgCubicCurve = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::xml::svg::SvgCubicCurve = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgRect {
    fn get_center(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn contains_point(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn expand(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_fill(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_stroke(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgRect {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::xml::svg::SvgRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::xml::svg::SvgRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgColoredVertex {
}

#[pyproto]
impl PyObjectProtocol for AzSvgColoredVertex {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgColoredVertex = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgColoredVertex = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedColoredSvgNode {
    #[staticmethod]
    fn empty(/* args */) -> AzTessellatedColoredSvgNode {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn from_nodes(/* args */) -> AzTessellatedColoredSvgNode {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzTessellatedColoredSvgNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedColoredSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedColoredSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedColoredSvgNodeVecRef {
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedColoredSvgNodeVecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedColoredSvgNodeVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedColoredSvgNodeVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedColoredGPUSvgNode {
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedColoredGPUSvgNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedColoredGPUSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedColoredGPUSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgVertex {
}

#[pyproto]
impl PyObjectProtocol for AzSvgVertex {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgVertex = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgVertex = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedSvgNode {
    #[staticmethod]
    fn empty(/* args */) -> AzTessellatedSvgNode {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn from_nodes(/* args */) -> AzTessellatedSvgNode {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzTessellatedSvgNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedSvgNodeVecRef {
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedSvgNodeVecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedSvgNodeVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedSvgNodeVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedGPUSvgNode {
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedGPUSvgNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedGPUSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedGPUSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgParseOptions {
    #[staticmethod]
    fn default(/* args */) -> AzSvgParseOptions {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgParseOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgParseOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgParseOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapeRenderingEnumWrapper {
    #[classattr]
    const OptimizeSpeed: AzShapeRendering = AzShapeRendering::OptimizeSpeed;
    #[classattr]
    const CrispEdges: AzShapeRendering = AzShapeRendering::CrispEdges;
    #[classattr]
    const GeometricPrecision: AzShapeRendering = AzShapeRendering::GeometricPrecision;
}

#[pyproto]
impl PyObjectProtocol for AzShapeRenderingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::ShapeRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::ShapeRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzShapeRenderingEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzTextRenderingEnumWrapper {
    #[classattr]
    const OptimizeSpeed: AzTextRendering = AzTextRendering::OptimizeSpeed;
    #[classattr]
    const OptimizeLegibility: AzTextRendering = AzTextRendering::OptimizeLegibility;
    #[classattr]
    const GeometricPrecision: AzTextRendering = AzTextRendering::GeometricPrecision;
}

#[pyproto]
impl PyObjectProtocol for AzTextRenderingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TextRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TextRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzTextRenderingEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzImageRenderingEnumWrapper {
    #[classattr]
    const OptimizeQuality: AzImageRendering = AzImageRendering::OptimizeQuality;
    #[classattr]
    const OptimizeSpeed: AzImageRendering = AzImageRendering::OptimizeSpeed;
}

#[pyproto]
impl PyObjectProtocol for AzImageRenderingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::ImageRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::ImageRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzImageRenderingEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzFontDatabaseEnumWrapper {
    #[classattr]
    const Empty: AzFontDatabase = AzFontDatabase::Empty;
    #[classattr]
    const System: AzFontDatabase = AzFontDatabase::System;
}

#[pyproto]
impl PyObjectProtocol for AzFontDatabaseEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::FontDatabase = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::FontDatabase = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzFontDatabaseEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSvgRenderOptions {
    #[staticmethod]
    fn default(/* args */) -> AzSvgRenderOptions {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgRenderOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgRenderOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgRenderOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgRenderTransform {
}

#[pyproto]
impl PyObjectProtocol for AzSvgRenderTransform {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgRenderTransform = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgRenderTransform = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgDashPattern {
}

#[pyproto]
impl PyObjectProtocol for AzSvgDashPattern {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgDashPattern = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgDashPattern = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIndentEnumWrapper {
    #[classattr]
    fn None() -> AzIndentEnumWrapper {
        AzIndentEnumWrapper { inner: AzIndent::None }
    }
    #[staticmethod]
    fn Spaces(v: u8) -> AzIndentEnumWrapper {
        AzIndentEnumWrapper { inner: AzIndent::Spaces(v) }}
    }
    #[classattr]
    fn Tabs() -> AzIndentEnumWrapper {
        AzIndentEnumWrapper { inner: AzIndent::Tabs }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzIndent;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzIndent::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzIndent::Spaces(v) => Ok(vec!["Spaces".into_py(py), v.into_py(py)]),
            AzIndent::Tabs => Ok(vec!["Tabs".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIndentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::Indent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::Indent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgFitToEnumWrapper {
    #[classattr]
    fn Original() -> AzSvgFitToEnumWrapper {
        AzSvgFitToEnumWrapper { inner: AzSvgFitTo::Original }
    }
    #[staticmethod]
    fn Width(v: u32) -> AzSvgFitToEnumWrapper {
        AzSvgFitToEnumWrapper { inner: AzSvgFitTo::Width(v) }}
    }
    #[staticmethod]
    fn Height(v: u32) -> AzSvgFitToEnumWrapper {
        AzSvgFitToEnumWrapper { inner: AzSvgFitTo::Height(v) }}
    }
    #[staticmethod]
    fn Zoom(v: f32) -> AzSvgFitToEnumWrapper {
        AzSvgFitToEnumWrapper { inner: AzSvgFitTo::Zoom(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgFitTo;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgFitTo::Original => Ok(vec!["Original".into_py(py), ().into_py(py)]),
            AzSvgFitTo::Width(v) => Ok(vec!["Width".into_py(py), v.into_py(py)]),
            AzSvgFitTo::Height(v) => Ok(vec!["Height".into_py(py), v.into_py(py)]),
            AzSvgFitTo::Zoom(v) => Ok(vec!["Zoom".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgFitToEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgFitTo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgFitTo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgStyleEnumWrapper {
    #[staticmethod]
    fn Fill(v: SvgFillStyle) -> AzSvgStyleEnumWrapper {
        AzSvgStyleEnumWrapper { inner: AzSvgStyle::Fill(v) }}
    }
    #[staticmethod]
    fn Stroke(v: SvgStrokeStyle) -> AzSvgStyleEnumWrapper {
        AzSvgStyleEnumWrapper { inner: AzSvgStyle::Stroke(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgStyle;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgStyle::Fill(v) => Ok(vec!["Fill".into_py(py), v.into_py(py)]),
            AzSvgStyle::Stroke(v) => Ok(vec!["Stroke".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgStyleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgFillRuleEnumWrapper {
    #[classattr]
    const Winding: AzSvgFillRule = AzSvgFillRule::Winding;
    #[classattr]
    const EvenOdd: AzSvgFillRule = AzSvgFillRule::EvenOdd;
}

#[pyproto]
impl PyObjectProtocol for AzSvgFillRuleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgFillRule = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgFillRule = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzSvgFillRuleEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSvgTransform {
}

#[pyproto]
impl PyObjectProtocol for AzSvgTransform {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgTransform = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgTransform = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgFillStyle {
    #[staticmethod]
    fn default(/* args */) -> AzSvgFillStyle {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgFillStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgFillStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgFillStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgStrokeStyle {
    #[staticmethod]
    fn default(/* args */) -> AzSvgStrokeStyle {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgStrokeStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgStrokeStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgStrokeStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgLineJoinEnumWrapper {
    #[classattr]
    const Miter: AzSvgLineJoin = AzSvgLineJoin::Miter;
    #[classattr]
    const MiterClip: AzSvgLineJoin = AzSvgLineJoin::MiterClip;
    #[classattr]
    const Round: AzSvgLineJoin = AzSvgLineJoin::Round;
    #[classattr]
    const Bevel: AzSvgLineJoin = AzSvgLineJoin::Bevel;
}

#[pyproto]
impl PyObjectProtocol for AzSvgLineJoinEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgLineJoin = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgLineJoin = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzSvgLineJoinEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSvgLineCapEnumWrapper {
    #[classattr]
    const Butt: AzSvgLineCap = AzSvgLineCap::Butt;
    #[classattr]
    const Square: AzSvgLineCap = AzSvgLineCap::Square;
    #[classattr]
    const Round: AzSvgLineCap = AzSvgLineCap::Round;
}

#[pyproto]
impl PyObjectProtocol for AzSvgLineCapEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgLineCap = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgLineCap = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzSvgLineCapEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSvgXmlOptions {
}

#[pyproto]
impl PyObjectProtocol for AzSvgXmlOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgXmlOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgXmlOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgParseErrorEnumWrapper {
    #[classattr]
    fn NoParserAvailable() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::NoParserAvailable }
    }
    #[classattr]
    fn ElementsLimitReached() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::ElementsLimitReached }
    }
    #[classattr]
    fn NotAnUtf8Str() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::NotAnUtf8Str }
    }
    #[classattr]
    fn MalformedGZip() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::MalformedGZip }
    }
    #[classattr]
    fn InvalidSize() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::InvalidSize }
    }
    #[staticmethod]
    fn ParsingFailed(v: XmlError) -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::ParsingFailed(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgParseError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgParseError::NoParserAvailable => Ok(vec!["NoParserAvailable".into_py(py), ().into_py(py)]),
            AzSvgParseError::ElementsLimitReached => Ok(vec!["ElementsLimitReached".into_py(py), ().into_py(py)]),
            AzSvgParseError::NotAnUtf8Str => Ok(vec!["NotAnUtf8Str".into_py(py), ().into_py(py)]),
            AzSvgParseError::MalformedGZip => Ok(vec!["MalformedGZip".into_py(py), ().into_py(py)]),
            AzSvgParseError::InvalidSize => Ok(vec!["InvalidSize".into_py(py), ().into_py(py)]),
            AzSvgParseError::ParsingFailed(v) => Ok(vec!["ParsingFailed".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgParseErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXml {
    #[staticmethod]
    fn from_str(/* args */) -> AzXml {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzXml {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::Xml = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::Xml = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlNode {
}

#[pyproto]
impl PyObjectProtocol for AzXmlNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFile {
    #[staticmethod]
    fn open(/* args */) -> AzFile {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn create(/* args */) -> AzFile {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn read_to_string(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn read_to_bytes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn write_string(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn write_bytes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn close(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzFile {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::azul_impl::file::File = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::azul_impl::file::File = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMsgBox {
    #[staticmethod]
    fn ok(/* args */) -> AzMsgBox {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn info(/* args */) -> AzMsgBox {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn warning(/* args */) -> AzMsgBox {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn error(/* args */) -> AzMsgBox {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn question(/* args */) -> AzMsgBox {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn ok_cancel(/* args */) -> AzMsgBox {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn yes_no(/* args */) -> AzMsgBox {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzMsgBox {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::azul_impl::dialogs::MsgBox = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::azul_impl::dialogs::MsgBox = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMsgBoxIconEnumWrapper {
    #[classattr]
    const Info: AzMsgBoxIcon = AzMsgBoxIcon::Info;
    #[classattr]
    const Warning: AzMsgBoxIcon = AzMsgBoxIcon::Warning;
    #[classattr]
    const Error: AzMsgBoxIcon = AzMsgBoxIcon::Error;
    #[classattr]
    const Question: AzMsgBoxIcon = AzMsgBoxIcon::Question;
}

#[pyproto]
impl PyObjectProtocol for AzMsgBoxIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::azul_impl::dialogs::MsgBoxIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::azul_impl::dialogs::MsgBoxIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzMsgBoxIconEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzColorPickerDialog {
    #[staticmethod]
    fn open(/* args */) -> AzColorPickerDialog {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzColorPickerDialog {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::azul_impl::dialogs::ColorPickerDialog = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::azul_impl::dialogs::ColorPickerDialog = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzYesNoEnumWrapper {
    #[classattr]
    const Yes: AzYesNo = AzYesNo::Yes;
    #[classattr]
    const No: AzYesNo = AzYesNo::No;
}

#[pyproto]
impl PyObjectProtocol for AzYesNoEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::azul_impl::dialogs::YesNo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::azul_impl::dialogs::YesNo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzYesNoEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzFileDialog {
    #[staticmethod]
    fn select_file(/* args */) -> AzFileDialog {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn select_multiple_files(/* args */) -> AzFileDialog {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn select_folder(/* args */) -> AzFileDialog {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn save_file(/* args */) -> AzFileDialog {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzFileDialog {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::azul_impl::dialogs::FileDialog = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::azul_impl::dialogs::FileDialog = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileTypeList {
}

#[pyproto]
impl PyObjectProtocol for AzFileTypeList {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::azul_impl::dialogs::FileTypeList = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::azul_impl::dialogs::FileTypeList = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOkCancelEnumWrapper {
    #[classattr]
    const Ok: AzOkCancel = AzOkCancel::Ok;
    #[classattr]
    const Cancel: AzOkCancel = AzOkCancel::Cancel;
}

#[pyproto]
impl PyObjectProtocol for AzOkCancelEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::azul_impl::dialogs::OkCancel = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::azul_impl::dialogs::OkCancel = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzOkCancelEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzInstantEnumWrapper {
    #[staticmethod]
    fn System(v: AzInstantPtr) -> AzInstantEnumWrapper {
        AzInstantEnumWrapper { inner: AzInstant::System(v) }}
    }
    #[staticmethod]
    fn Tick(v: SystemTick) -> AzInstantEnumWrapper {
        AzInstantEnumWrapper { inner: AzInstant::Tick(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInstant;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInstant::System(v) => Ok(vec!["System".into_py(py), v.into_py(py)]),
            AzInstant::Tick(v) => Ok(vec!["Tick".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInstantEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::Instant = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::Instant = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemTickDiff {
}

#[pyproto]
impl PyObjectProtocol for AzSystemTickDiff {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::SystemTickDiff = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::SystemTickDiff = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAzInstantPtr {
}

#[pyproto]
impl PyObjectProtocol for AzAzInstantPtr {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::AzInstantPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::AzInstantPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInstantPtrCloneCallback {
}

#[pyproto]
impl PyObjectProtocol for AzInstantPtrCloneCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::InstantPtrCloneCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::InstantPtrCloneCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemTick {
}

#[pyproto]
impl PyObjectProtocol for AzSystemTick {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::SystemTick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::SystemTick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDurationEnumWrapper {
    #[staticmethod]
    fn System(v: SystemTimeDiff) -> AzDurationEnumWrapper {
        AzDurationEnumWrapper { inner: AzDuration::System(v) }}
    }
    #[staticmethod]
    fn Tick(v: SystemTickDiff) -> AzDurationEnumWrapper {
        AzDurationEnumWrapper { inner: AzDuration::Tick(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzDuration;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzDuration::System(v) => Ok(vec!["System".into_py(py), v.into_py(py)]),
            AzDuration::Tick(v) => Ok(vec!["Tick".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDurationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::Duration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::Duration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemTimeDiff {
}

#[pyproto]
impl PyObjectProtocol for AzSystemTimeDiff {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::SystemTimeDiff = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::SystemTimeDiff = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInstantPtrDestructorCallback {
}

#[pyproto]
impl PyObjectProtocol for AzInstantPtrDestructorCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::InstantPtrDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::InstantPtrDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTimerId {
}

#[pyproto]
impl PyObjectProtocol for AzTimerId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::TimerId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::TimerId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTimer {
    fn with_delay(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_interval(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_timeout(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzTimer {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::Timer = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::Timer = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTerminateTimerEnumWrapper {
    #[classattr]
    const Terminate: AzTerminateTimer = AzTerminateTimer::Terminate;
    #[classattr]
    const Continue: AzTerminateTimer = AzTerminateTimer::Continue;
}

#[pyproto]
impl PyObjectProtocol for AzTerminateTimerEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::TerminateTimer = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::TerminateTimer = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzTerminateTimerEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzThreadId {
}

#[pyproto]
impl PyObjectProtocol for AzThreadId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThread {
}

#[pyproto]
impl PyObjectProtocol for AzThread {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::Thread = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::Thread = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadSender {
    fn send(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzThreadSender {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadSender = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadSender = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadReceiver {
    fn receive(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzThreadReceiver {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadReceiver = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadReceiver = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadSendMsgEnumWrapper {
    #[classattr]
    fn TerminateThread() -> AzThreadSendMsgEnumWrapper {
        AzThreadSendMsgEnumWrapper { inner: AzThreadSendMsg::TerminateThread }
    }
    #[classattr]
    fn Tick() -> AzThreadSendMsgEnumWrapper {
        AzThreadSendMsgEnumWrapper { inner: AzThreadSendMsg::Tick }
    }
    #[staticmethod]
    fn Custom(v: RefAny) -> AzThreadSendMsgEnumWrapper {
        AzThreadSendMsgEnumWrapper { inner: AzThreadSendMsg::Custom(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzThreadSendMsg;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzThreadSendMsg::TerminateThread => Ok(vec!["TerminateThread".into_py(py), ().into_py(py)]),
            AzThreadSendMsg::Tick => Ok(vec!["Tick".into_py(py), ().into_py(py)]),
            AzThreadSendMsg::Custom(v) => Ok(vec!["Custom".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzThreadSendMsgEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadSendMsg = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadSendMsg = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadReceiveMsgEnumWrapper {
    #[staticmethod]
    fn WriteBack(v: ThreadWriteBackMsg) -> AzThreadReceiveMsgEnumWrapper {
        AzThreadReceiveMsgEnumWrapper { inner: AzThreadReceiveMsg::WriteBack(v) }}
    }
    #[staticmethod]
    fn Update(v: Update) -> AzThreadReceiveMsgEnumWrapper {
        AzThreadReceiveMsgEnumWrapper { inner: AzThreadReceiveMsg::Update(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzThreadReceiveMsg;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzThreadReceiveMsg::WriteBack(v) => Ok(vec!["WriteBack".into_py(py), v.into_py(py)]),
            AzThreadReceiveMsg::Update(v) => Ok(vec!["Update".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzThreadReceiveMsgEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadReceiveMsg = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadReceiveMsg = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadWriteBackMsg {
}

#[pyproto]
impl PyObjectProtocol for AzThreadWriteBackMsg {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadWriteBackMsg = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadWriteBackMsg = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadReceiverDestructorCallback {
}

#[pyproto]
impl PyObjectProtocol for AzThreadReceiverDestructorCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadReceiverDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadReceiverDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCreateThreadCallback {
}

#[pyproto]
impl PyObjectProtocol for AzCreateThreadCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::CreateThreadCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::CreateThreadCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGetSystemTimeCallback {
}

#[pyproto]
impl PyObjectProtocol for AzGetSystemTimeCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::GetSystemTimeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::GetSystemTimeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckThreadFinishedCallback {
}

#[pyproto]
impl PyObjectProtocol for AzCheckThreadFinishedCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::CheckThreadFinishedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::CheckThreadFinishedCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLibrarySendThreadMsgCallback {
}

#[pyproto]
impl PyObjectProtocol for AzLibrarySendThreadMsgCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::LibrarySendThreadMsgCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::LibrarySendThreadMsgCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLibraryReceiveThreadMsgCallback {
}

#[pyproto]
impl PyObjectProtocol for AzLibraryReceiveThreadMsgCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::LibraryReceiveThreadMsgCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::LibraryReceiveThreadMsgCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadRecvCallback {
}

#[pyproto]
impl PyObjectProtocol for AzThreadRecvCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadRecvCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadRecvCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadSendCallback {
}

#[pyproto]
impl PyObjectProtocol for AzThreadSendCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadSendCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadSendCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadDestructorCallback {
}

#[pyproto]
impl PyObjectProtocol for AzThreadDestructorCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadSenderDestructorCallback {
}

#[pyproto]
impl PyObjectProtocol for AzThreadSenderDestructorCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadSenderDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::ThreadSenderDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFmtValueEnumWrapper {
    #[staticmethod]
    fn Bool(v: bool) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper { inner: AzFmtValue::Bool(v) }}
    }
    #[staticmethod]
    fn Uchar(v: u8) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper { inner: AzFmtValue::Uchar(v) }}
    }
    #[staticmethod]
    fn Schar(v: i8) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper { inner: AzFmtValue::Schar(v) }}
    }
    #[staticmethod]
    fn Ushort(v: u16) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper { inner: AzFmtValue::Ushort(v) }}
    }
    #[staticmethod]
    fn Sshort(v: i16) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper { inner: AzFmtValue::Sshort(v) }}
    }
    #[staticmethod]
    fn Uint(v: u32) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper { inner: AzFmtValue::Uint(v) }}
    }
    #[staticmethod]
    fn Sint(v: i32) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper { inner: AzFmtValue::Sint(v) }}
    }
    #[staticmethod]
    fn Ulong(v: u64) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper { inner: AzFmtValue::Ulong(v) }}
    }
    #[staticmethod]
    fn Slong(v: i64) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper { inner: AzFmtValue::Slong(v) }}
    }
    #[staticmethod]
    fn Isize(v: isize) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper { inner: AzFmtValue::Isize(v) }}
    }
    #[staticmethod]
    fn Usize(v: usize) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper { inner: AzFmtValue::Usize(v) }}
    }
    #[staticmethod]
    fn Float(v: f32) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper { inner: AzFmtValue::Float(v) }}
    }
    #[staticmethod]
    fn Double(v: f64) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper { inner: AzFmtValue::Double(v) }}
    }
    #[staticmethod]
    fn Str(v: AzString) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper { inner: AzFmtValue::Str(v) }}
    }
    #[staticmethod]
    fn StrVec(v: StringVec) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper { inner: AzFmtValue::StrVec(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzFmtValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzFmtValue::Bool(v) => Ok(vec!["Bool".into_py(py), v.into_py(py)]),
            AzFmtValue::Uchar(v) => Ok(vec!["Uchar".into_py(py), v.into_py(py)]),
            AzFmtValue::Schar(v) => Ok(vec!["Schar".into_py(py), v.into_py(py)]),
            AzFmtValue::Ushort(v) => Ok(vec!["Ushort".into_py(py), v.into_py(py)]),
            AzFmtValue::Sshort(v) => Ok(vec!["Sshort".into_py(py), v.into_py(py)]),
            AzFmtValue::Uint(v) => Ok(vec!["Uint".into_py(py), v.into_py(py)]),
            AzFmtValue::Sint(v) => Ok(vec!["Sint".into_py(py), v.into_py(py)]),
            AzFmtValue::Ulong(v) => Ok(vec!["Ulong".into_py(py), v.into_py(py)]),
            AzFmtValue::Slong(v) => Ok(vec!["Slong".into_py(py), v.into_py(py)]),
            AzFmtValue::Isize(v) => Ok(vec!["Isize".into_py(py), v.into_py(py)]),
            AzFmtValue::Usize(v) => Ok(vec!["Usize".into_py(py), v.into_py(py)]),
            AzFmtValue::Float(v) => Ok(vec!["Float".into_py(py), v.into_py(py)]),
            AzFmtValue::Double(v) => Ok(vec!["Double".into_py(py), v.into_py(py)]),
            AzFmtValue::Str(v) => Ok(vec!["Str".into_py(py), v.into_py(py)]),
            AzFmtValue::StrVec(v) => Ok(vec!["StrVec".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFmtValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::str::FmtValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::str::FmtValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFmtArg {
}

#[pyproto]
impl PyObjectProtocol for AzFmtArg {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::str::FmtArg = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::str::FmtArg = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAzString {
    #[staticmethod]
    fn format(/* args */) -> AzAzString {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn trim(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn as_refstr(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzAzString {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::AzString = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::AzString = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewRowVec {
}

#[pyproto]
impl PyObjectProtocol for AzListViewRowVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::list_view::ListViewRowVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::list_view::ListViewRowVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFilterVec {
}

#[pyproto]
impl PyObjectProtocol for AzStyleFilterVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleFilterVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleFilterVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalRectVec {
}

#[pyproto]
impl PyObjectProtocol for AzLogicalRectVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::LogicalRectVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::LogicalRectVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeIdInfoMapVec {
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeIdInfoMapVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMapVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMapVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeIdInfoMapVec {
}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeIdInfoMapVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdNodeMapVec {
}

#[pyproto]
impl PyObjectProtocol for AzNodeIdNodeMapVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeIdNodeMapVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeIdNodeMapVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeIdVec {
}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeIdVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeFieldVec {
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeFieldVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeFieldVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeFieldVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputConnectionVec {
}

#[pyproto]
impl PyObjectProtocol for AzInputConnectionVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputConnectionVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputConnectionVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputNodeAndIndexVec {
}

#[pyproto]
impl PyObjectProtocol for AzOutputNodeAndIndexVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputNodeAndIndexVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputNodeAndIndexVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputConnectionVec {
}

#[pyproto]
impl PyObjectProtocol for AzOutputConnectionVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputConnectionVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputConnectionVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputNodeAndIndexVec {
}

#[pyproto]
impl PyObjectProtocol for AzInputNodeAndIndexVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputNodeAndIndexVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputNodeAndIndexVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAccessibilityStateVec {
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityStateVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityStateVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityStateVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuItemVec {
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItemVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItemVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedSvgNodeVec {
    fn as_ref_vec(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzTessellatedSvgNodeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedSvgNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedSvgNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedColoredSvgNodeVec {
    fn as_ref_vec(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzTessellatedColoredSvgNodeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedColoredSvgNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedColoredSvgNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontFamilyVec {
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontFamilyVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontFamilyVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontFamilyVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlNodeVec {
}

#[pyproto]
impl PyObjectProtocol for AzXmlNodeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFmtArgVec {
}

#[pyproto]
impl PyObjectProtocol for AzFmtArgVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::str::FmtArgVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::str::FmtArgVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineLineVec {
}

#[pyproto]
impl PyObjectProtocol for AzInlineLineVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineLineVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineLineVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineWordVec {
}

#[pyproto]
impl PyObjectProtocol for AzInlineWordVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineWordVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineWordVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineGlyphVec {
}

#[pyproto]
impl PyObjectProtocol for AzInlineGlyphVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineGlyphVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineGlyphVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineTextHitVec {
}

#[pyproto]
impl PyObjectProtocol for AzInlineTextHitVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineTextHitVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineTextHitVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMonitorVec {
}

#[pyproto]
impl PyObjectProtocol for AzMonitorVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MonitorVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MonitorVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVideoModeVec {
}

#[pyproto]
impl PyObjectProtocol for AzVideoModeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoModeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoModeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomVec {
}

#[pyproto]
impl PyObjectProtocol for AzDomVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::DomVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::DomVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIdOrClassVec {
}

#[pyproto]
impl PyObjectProtocol for AzIdOrClassVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::IdOrClassVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::IdOrClassVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataInlineCssPropertyVec {
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataInlineCssPropertyVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataInlineCssPropertyVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataInlineCssPropertyVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundContentVec {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundContentVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundContentVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundContentVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundPositionVec {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundPositionVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundPositionVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundPositionVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundRepeatVec {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundRepeatVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundRepeatVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundRepeatVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundSizeVec {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundSizeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundSizeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundSizeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformVec {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyVec {
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::number_input::CssPropertyVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::widgets::number_input::CssPropertyVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgMultiPolygonVec {
}

#[pyproto]
impl PyObjectProtocol for AzSvgMultiPolygonVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgMultiPolygonVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgMultiPolygonVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgSimpleNodeVec {
}

#[pyproto]
impl PyObjectProtocol for AzSvgSimpleNodeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgSimpleNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgSimpleNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathVec {
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexAttributeVec {
}

#[pyproto]
impl PyObjectProtocol for AzVertexAttributeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexAttributeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexAttributeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathElementVec {
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathElementVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathElementVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathElementVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgVertexVec {
}

#[pyproto]
impl PyObjectProtocol for AzSvgVertexVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgVertexVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgVertexVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgColoredVertexVec {
}

#[pyproto]
impl PyObjectProtocol for AzSvgColoredVertexVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgColoredVertexVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgColoredVertexVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU32Vec {
}

#[pyproto]
impl PyObjectProtocol for AzU32Vec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U32Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U32Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXWindowTypeVec {
}

#[pyproto]
impl PyObjectProtocol for AzXWindowTypeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowTypeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowTypeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVirtualKeyCodeVec {
}

#[pyproto]
impl PyObjectProtocol for AzVirtualKeyCodeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCascadeInfoVec {
}

#[pyproto]
impl PyObjectProtocol for AzCascadeInfoVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::style::CascadeInfoVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::style::CascadeInfoVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScanCodeVec {
}

#[pyproto]
impl PyObjectProtocol for AzScanCodeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ScanCodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ScanCodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssDeclarationVec {
}

#[pyproto]
impl PyObjectProtocol for AzCssDeclarationVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssDeclarationVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssDeclarationVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPathSelectorVec {
}

#[pyproto]
impl PyObjectProtocol for AzCssPathSelectorVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPathSelectorVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPathSelectorVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylesheetVec {
}

#[pyproto]
impl PyObjectProtocol for AzStylesheetVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::StylesheetVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::StylesheetVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssRuleBlockVec {
}

#[pyproto]
impl PyObjectProtocol for AzCssRuleBlockVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssRuleBlockVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssRuleBlockVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU16Vec {
}

#[pyproto]
impl PyObjectProtocol for AzU16Vec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U16Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U16Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzF32Vec {
}

#[pyproto]
impl PyObjectProtocol for AzF32Vec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::F32Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::F32Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU8Vec {
    fn as_ref_vec(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzU8Vec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U8Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U8Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallbackDataVec {
}

#[pyproto]
impl PyObjectProtocol for AzCallbackDataVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::CallbackDataVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::CallbackDataVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLuintVec {
}

#[pyproto]
impl PyObjectProtocol for AzGLuintVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLuintVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLuintVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLintVec {
}

#[pyproto]
impl PyObjectProtocol for AzGLintVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLintVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLintVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringVec {
}

#[pyproto]
impl PyObjectProtocol for AzStringVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::StringVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::StringVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringPairVec {
}

#[pyproto]
impl PyObjectProtocol for AzStringPairVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::StringPairVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::StringPairVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedLinearColorStopVec {
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedLinearColorStopVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedLinearColorStopVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedLinearColorStopVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedRadialColorStopVec {
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedRadialColorStopVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedRadialColorStopVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedRadialColorStopVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdVec {
}

#[pyproto]
impl PyObjectProtocol for AzNodeIdVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeIdVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeIdVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeHierarchyItemVec {
}

#[pyproto]
impl PyObjectProtocol for AzNodeHierarchyItemVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeHierarchyItemVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeHierarchyItemVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledNodeVec {
}

#[pyproto]
impl PyObjectProtocol for AzStyledNodeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTagIdToNodeIdMappingVec {
}

#[pyproto]
impl PyObjectProtocol for AzTagIdToNodeIdMappingVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::TagIdToNodeIdMappingVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::TagIdToNodeIdMappingVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzParentWithNodeDepthVec {
}

#[pyproto]
impl PyObjectProtocol for AzParentWithNodeDepthVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::ParentWithNodeDepthVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::ParentWithNodeDepthVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataVec {
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontFamilyVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleFontFamilyVecDestructorEnumWrapper {
        AzStyleFontFamilyVecDestructorEnumWrapper { inner: AzStyleFontFamilyVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleFontFamilyVecDestructorEnumWrapper {
        AzStyleFontFamilyVecDestructorEnumWrapper { inner: AzStyleFontFamilyVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StyleFontFamilyVecDestructorType) -> AzStyleFontFamilyVecDestructorEnumWrapper {
        AzStyleFontFamilyVecDestructorEnumWrapper { inner: AzStyleFontFamilyVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleFontFamilyVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFontFamilyVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontFamilyVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontFamilyVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontFamilyVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewRowVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzListViewRowVecDestructorEnumWrapper {
        AzListViewRowVecDestructorEnumWrapper { inner: AzListViewRowVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzListViewRowVecDestructorEnumWrapper {
        AzListViewRowVecDestructorEnumWrapper { inner: AzListViewRowVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: ListViewRowVecDestructorType) -> AzListViewRowVecDestructorEnumWrapper {
        AzListViewRowVecDestructorEnumWrapper { inner: AzListViewRowVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzListViewRowVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzListViewRowVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzListViewRowVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzListViewRowVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzListViewRowVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::list_view::ListViewRowVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::list_view::ListViewRowVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFilterVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleFilterVecDestructorEnumWrapper {
        AzStyleFilterVecDestructorEnumWrapper { inner: AzStyleFilterVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleFilterVecDestructorEnumWrapper {
        AzStyleFilterVecDestructorEnumWrapper { inner: AzStyleFilterVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StyleFilterVecDestructorType) -> AzStyleFilterVecDestructorEnumWrapper {
        AzStyleFilterVecDestructorEnumWrapper { inner: AzStyleFilterVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleFilterVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFilterVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleFilterVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleFilterVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFilterVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleFilterVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleFilterVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalRectVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzLogicalRectVecDestructorEnumWrapper {
        AzLogicalRectVecDestructorEnumWrapper { inner: AzLogicalRectVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzLogicalRectVecDestructorEnumWrapper {
        AzLogicalRectVecDestructorEnumWrapper { inner: AzLogicalRectVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: LogicalRectVecDestructorType) -> AzLogicalRectVecDestructorEnumWrapper {
        AzLogicalRectVecDestructorEnumWrapper { inner: AzLogicalRectVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLogicalRectVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLogicalRectVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzLogicalRectVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzLogicalRectVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLogicalRectVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::LogicalRectVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::LogicalRectVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
        AzNodeTypeIdInfoMapVecDestructorEnumWrapper { inner: AzNodeTypeIdInfoMapVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
        AzNodeTypeIdInfoMapVecDestructorEnumWrapper { inner: AzNodeTypeIdInfoMapVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: NodeTypeIdInfoMapVecDestructorType) -> AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
        AzNodeTypeIdInfoMapVecDestructorEnumWrapper { inner: AzNodeTypeIdInfoMapVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeTypeIdInfoMapVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeTypeIdInfoMapVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeTypeIdInfoMapVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeTypeIdInfoMapVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMapVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMapVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
        AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper { inner: AzInputOutputTypeIdInfoMapVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
        AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper { inner: AzInputOutputTypeIdInfoMapVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: InputOutputTypeIdInfoMapVecDestructorType) -> AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
        AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper { inner: AzInputOutputTypeIdInfoMapVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInputOutputTypeIdInfoMapVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInputOutputTypeIdInfoMapVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzInputOutputTypeIdInfoMapVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzInputOutputTypeIdInfoMapVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdNodeMapVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeIdNodeMapVecDestructorEnumWrapper {
        AzNodeIdNodeMapVecDestructorEnumWrapper { inner: AzNodeIdNodeMapVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeIdNodeMapVecDestructorEnumWrapper {
        AzNodeIdNodeMapVecDestructorEnumWrapper { inner: AzNodeIdNodeMapVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: NodeIdNodeMapVecDestructorType) -> AzNodeIdNodeMapVecDestructorEnumWrapper {
        AzNodeIdNodeMapVecDestructorEnumWrapper { inner: AzNodeIdNodeMapVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeIdNodeMapVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeIdNodeMapVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeIdNodeMapVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeIdNodeMapVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeIdNodeMapVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeIdNodeMapVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeIdNodeMapVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeIdVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInputOutputTypeIdVecDestructorEnumWrapper {
        AzInputOutputTypeIdVecDestructorEnumWrapper { inner: AzInputOutputTypeIdVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzInputOutputTypeIdVecDestructorEnumWrapper {
        AzInputOutputTypeIdVecDestructorEnumWrapper { inner: AzInputOutputTypeIdVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: InputOutputTypeIdVecDestructorType) -> AzInputOutputTypeIdVecDestructorEnumWrapper {
        AzInputOutputTypeIdVecDestructorEnumWrapper { inner: AzInputOutputTypeIdVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInputOutputTypeIdVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInputOutputTypeIdVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzInputOutputTypeIdVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzInputOutputTypeIdVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeIdVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputOutputTypeIdVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeFieldVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeTypeFieldVecDestructorEnumWrapper {
        AzNodeTypeFieldVecDestructorEnumWrapper { inner: AzNodeTypeFieldVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeTypeFieldVecDestructorEnumWrapper {
        AzNodeTypeFieldVecDestructorEnumWrapper { inner: AzNodeTypeFieldVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: NodeTypeFieldVecDestructorType) -> AzNodeTypeFieldVecDestructorEnumWrapper {
        AzNodeTypeFieldVecDestructorEnumWrapper { inner: AzNodeTypeFieldVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeTypeFieldVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeTypeFieldVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeTypeFieldVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeTypeFieldVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeFieldVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeFieldVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::NodeTypeFieldVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputConnectionVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInputConnectionVecDestructorEnumWrapper {
        AzInputConnectionVecDestructorEnumWrapper { inner: AzInputConnectionVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzInputConnectionVecDestructorEnumWrapper {
        AzInputConnectionVecDestructorEnumWrapper { inner: AzInputConnectionVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: InputConnectionVecDestructorType) -> AzInputConnectionVecDestructorEnumWrapper {
        AzInputConnectionVecDestructorEnumWrapper { inner: AzInputConnectionVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInputConnectionVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInputConnectionVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzInputConnectionVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzInputConnectionVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputConnectionVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputConnectionVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputConnectionVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputNodeAndIndexVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzOutputNodeAndIndexVecDestructorEnumWrapper {
        AzOutputNodeAndIndexVecDestructorEnumWrapper { inner: AzOutputNodeAndIndexVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzOutputNodeAndIndexVecDestructorEnumWrapper {
        AzOutputNodeAndIndexVecDestructorEnumWrapper { inner: AzOutputNodeAndIndexVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: OutputNodeAndIndexVecDestructorType) -> AzOutputNodeAndIndexVecDestructorEnumWrapper {
        AzOutputNodeAndIndexVecDestructorEnumWrapper { inner: AzOutputNodeAndIndexVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOutputNodeAndIndexVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOutputNodeAndIndexVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzOutputNodeAndIndexVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzOutputNodeAndIndexVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOutputNodeAndIndexVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputNodeAndIndexVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputNodeAndIndexVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputConnectionVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzOutputConnectionVecDestructorEnumWrapper {
        AzOutputConnectionVecDestructorEnumWrapper { inner: AzOutputConnectionVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzOutputConnectionVecDestructorEnumWrapper {
        AzOutputConnectionVecDestructorEnumWrapper { inner: AzOutputConnectionVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: OutputConnectionVecDestructorType) -> AzOutputConnectionVecDestructorEnumWrapper {
        AzOutputConnectionVecDestructorEnumWrapper { inner: AzOutputConnectionVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOutputConnectionVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOutputConnectionVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzOutputConnectionVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzOutputConnectionVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOutputConnectionVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputConnectionVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OutputConnectionVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputNodeAndIndexVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInputNodeAndIndexVecDestructorEnumWrapper {
        AzInputNodeAndIndexVecDestructorEnumWrapper { inner: AzInputNodeAndIndexVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzInputNodeAndIndexVecDestructorEnumWrapper {
        AzInputNodeAndIndexVecDestructorEnumWrapper { inner: AzInputNodeAndIndexVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: InputNodeAndIndexVecDestructorType) -> AzInputNodeAndIndexVecDestructorEnumWrapper {
        AzInputNodeAndIndexVecDestructorEnumWrapper { inner: AzInputNodeAndIndexVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInputNodeAndIndexVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInputNodeAndIndexVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzInputNodeAndIndexVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzInputNodeAndIndexVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputNodeAndIndexVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputNodeAndIndexVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::InputNodeAndIndexVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAccessibilityStateVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzAccessibilityStateVecDestructorEnumWrapper {
        AzAccessibilityStateVecDestructorEnumWrapper { inner: AzAccessibilityStateVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzAccessibilityStateVecDestructorEnumWrapper {
        AzAccessibilityStateVecDestructorEnumWrapper { inner: AzAccessibilityStateVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: AccessibilityStateVecDestructorType) -> AzAccessibilityStateVecDestructorEnumWrapper {
        AzAccessibilityStateVecDestructorEnumWrapper { inner: AzAccessibilityStateVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzAccessibilityStateVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAccessibilityStateVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzAccessibilityStateVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzAccessibilityStateVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityStateVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityStateVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityStateVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuItemVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzMenuItemVecDestructorEnumWrapper {
        AzMenuItemVecDestructorEnumWrapper { inner: AzMenuItemVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzMenuItemVecDestructorEnumWrapper {
        AzMenuItemVecDestructorEnumWrapper { inner: AzMenuItemVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: MenuItemVecDestructorType) -> AzMenuItemVecDestructorEnumWrapper {
        AzMenuItemVecDestructorEnumWrapper { inner: AzMenuItemVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzMenuItemVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzMenuItemVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzMenuItemVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzMenuItemVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItemVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItemVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedSvgNodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzTessellatedSvgNodeVecDestructorEnumWrapper {
        AzTessellatedSvgNodeVecDestructorEnumWrapper { inner: AzTessellatedSvgNodeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzTessellatedSvgNodeVecDestructorEnumWrapper {
        AzTessellatedSvgNodeVecDestructorEnumWrapper { inner: AzTessellatedSvgNodeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: TessellatedSvgNodeVecDestructorType) -> AzTessellatedSvgNodeVecDestructorEnumWrapper {
        AzTessellatedSvgNodeVecDestructorEnumWrapper { inner: AzTessellatedSvgNodeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzTessellatedSvgNodeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTessellatedSvgNodeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzTessellatedSvgNodeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzTessellatedSvgNodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedSvgNodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedSvgNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedSvgNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedColoredSvgNodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzTessellatedColoredSvgNodeVecDestructorEnumWrapper {
        AzTessellatedColoredSvgNodeVecDestructorEnumWrapper { inner: AzTessellatedColoredSvgNodeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzTessellatedColoredSvgNodeVecDestructorEnumWrapper {
        AzTessellatedColoredSvgNodeVecDestructorEnumWrapper { inner: AzTessellatedColoredSvgNodeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: TessellatedColoredSvgNodeVecDestructorType) -> AzTessellatedColoredSvgNodeVecDestructorEnumWrapper {
        AzTessellatedColoredSvgNodeVecDestructorEnumWrapper { inner: AzTessellatedColoredSvgNodeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzTessellatedColoredSvgNodeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTessellatedColoredSvgNodeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzTessellatedColoredSvgNodeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzTessellatedColoredSvgNodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedColoredSvgNodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedColoredSvgNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedColoredSvgNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlNodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzXmlNodeVecDestructorEnumWrapper {
        AzXmlNodeVecDestructorEnumWrapper { inner: AzXmlNodeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzXmlNodeVecDestructorEnumWrapper {
        AzXmlNodeVecDestructorEnumWrapper { inner: AzXmlNodeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: XmlNodeVecDestructorType) -> AzXmlNodeVecDestructorEnumWrapper {
        AzXmlNodeVecDestructorEnumWrapper { inner: AzXmlNodeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzXmlNodeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlNodeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzXmlNodeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzXmlNodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlNodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFmtArgVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzFmtArgVecDestructorEnumWrapper {
        AzFmtArgVecDestructorEnumWrapper { inner: AzFmtArgVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzFmtArgVecDestructorEnumWrapper {
        AzFmtArgVecDestructorEnumWrapper { inner: AzFmtArgVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: FmtArgVecDestructorType) -> AzFmtArgVecDestructorEnumWrapper {
        AzFmtArgVecDestructorEnumWrapper { inner: AzFmtArgVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzFmtArgVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzFmtArgVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzFmtArgVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzFmtArgVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFmtArgVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::str::FmtArgVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::str::FmtArgVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineLineVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInlineLineVecDestructorEnumWrapper {
        AzInlineLineVecDestructorEnumWrapper { inner: AzInlineLineVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzInlineLineVecDestructorEnumWrapper {
        AzInlineLineVecDestructorEnumWrapper { inner: AzInlineLineVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: InlineLineVecDestructorType) -> AzInlineLineVecDestructorEnumWrapper {
        AzInlineLineVecDestructorEnumWrapper { inner: AzInlineLineVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInlineLineVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInlineLineVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzInlineLineVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzInlineLineVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineLineVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineLineVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineLineVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineWordVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInlineWordVecDestructorEnumWrapper {
        AzInlineWordVecDestructorEnumWrapper { inner: AzInlineWordVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzInlineWordVecDestructorEnumWrapper {
        AzInlineWordVecDestructorEnumWrapper { inner: AzInlineWordVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: InlineWordVecDestructorType) -> AzInlineWordVecDestructorEnumWrapper {
        AzInlineWordVecDestructorEnumWrapper { inner: AzInlineWordVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInlineWordVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInlineWordVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzInlineWordVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzInlineWordVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineWordVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineWordVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineWordVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineGlyphVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInlineGlyphVecDestructorEnumWrapper {
        AzInlineGlyphVecDestructorEnumWrapper { inner: AzInlineGlyphVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzInlineGlyphVecDestructorEnumWrapper {
        AzInlineGlyphVecDestructorEnumWrapper { inner: AzInlineGlyphVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: InlineGlyphVecDestructorType) -> AzInlineGlyphVecDestructorEnumWrapper {
        AzInlineGlyphVecDestructorEnumWrapper { inner: AzInlineGlyphVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInlineGlyphVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInlineGlyphVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzInlineGlyphVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzInlineGlyphVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineGlyphVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineGlyphVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineGlyphVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineTextHitVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInlineTextHitVecDestructorEnumWrapper {
        AzInlineTextHitVecDestructorEnumWrapper { inner: AzInlineTextHitVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzInlineTextHitVecDestructorEnumWrapper {
        AzInlineTextHitVecDestructorEnumWrapper { inner: AzInlineTextHitVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: InlineTextHitVecDestructorType) -> AzInlineTextHitVecDestructorEnumWrapper {
        AzInlineTextHitVecDestructorEnumWrapper { inner: AzInlineTextHitVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInlineTextHitVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInlineTextHitVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzInlineTextHitVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzInlineTextHitVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineTextHitVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineTextHitVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::InlineTextHitVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMonitorVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzMonitorVecDestructorEnumWrapper {
        AzMonitorVecDestructorEnumWrapper { inner: AzMonitorVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzMonitorVecDestructorEnumWrapper {
        AzMonitorVecDestructorEnumWrapper { inner: AzMonitorVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: MonitorVecDestructorType) -> AzMonitorVecDestructorEnumWrapper {
        AzMonitorVecDestructorEnumWrapper { inner: AzMonitorVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzMonitorVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzMonitorVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzMonitorVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzMonitorVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMonitorVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MonitorVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MonitorVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVideoModeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzVideoModeVecDestructorEnumWrapper {
        AzVideoModeVecDestructorEnumWrapper { inner: AzVideoModeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzVideoModeVecDestructorEnumWrapper {
        AzVideoModeVecDestructorEnumWrapper { inner: AzVideoModeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: VideoModeVecDestructorType) -> AzVideoModeVecDestructorEnumWrapper {
        AzVideoModeVecDestructorEnumWrapper { inner: AzVideoModeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzVideoModeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzVideoModeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzVideoModeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzVideoModeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVideoModeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoModeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoModeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzDomVecDestructorEnumWrapper {
        AzDomVecDestructorEnumWrapper { inner: AzDomVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzDomVecDestructorEnumWrapper {
        AzDomVecDestructorEnumWrapper { inner: AzDomVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: DomVecDestructorType) -> AzDomVecDestructorEnumWrapper {
        AzDomVecDestructorEnumWrapper { inner: AzDomVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzDomVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzDomVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzDomVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzDomVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDomVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::DomVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::DomVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIdOrClassVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzIdOrClassVecDestructorEnumWrapper {
        AzIdOrClassVecDestructorEnumWrapper { inner: AzIdOrClassVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzIdOrClassVecDestructorEnumWrapper {
        AzIdOrClassVecDestructorEnumWrapper { inner: AzIdOrClassVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: IdOrClassVecDestructorType) -> AzIdOrClassVecDestructorEnumWrapper {
        AzIdOrClassVecDestructorEnumWrapper { inner: AzIdOrClassVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzIdOrClassVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzIdOrClassVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzIdOrClassVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzIdOrClassVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIdOrClassVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::IdOrClassVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::IdOrClassVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
        AzNodeDataInlineCssPropertyVecDestructorEnumWrapper { inner: AzNodeDataInlineCssPropertyVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
        AzNodeDataInlineCssPropertyVecDestructorEnumWrapper { inner: AzNodeDataInlineCssPropertyVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: NodeDataInlineCssPropertyVecDestructorType) -> AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
        AzNodeDataInlineCssPropertyVecDestructorEnumWrapper { inner: AzNodeDataInlineCssPropertyVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeDataInlineCssPropertyVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeDataInlineCssPropertyVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeDataInlineCssPropertyVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeDataInlineCssPropertyVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataInlineCssPropertyVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataInlineCssPropertyVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundContentVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleBackgroundContentVecDestructorEnumWrapper {
        AzStyleBackgroundContentVecDestructorEnumWrapper { inner: AzStyleBackgroundContentVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleBackgroundContentVecDestructorEnumWrapper {
        AzStyleBackgroundContentVecDestructorEnumWrapper { inner: AzStyleBackgroundContentVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StyleBackgroundContentVecDestructorType) -> AzStyleBackgroundContentVecDestructorEnumWrapper {
        AzStyleBackgroundContentVecDestructorEnumWrapper { inner: AzStyleBackgroundContentVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundContentVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundContentVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleBackgroundContentVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleBackgroundContentVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundContentVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundContentVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundContentVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundPositionVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleBackgroundPositionVecDestructorEnumWrapper {
        AzStyleBackgroundPositionVecDestructorEnumWrapper { inner: AzStyleBackgroundPositionVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleBackgroundPositionVecDestructorEnumWrapper {
        AzStyleBackgroundPositionVecDestructorEnumWrapper { inner: AzStyleBackgroundPositionVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StyleBackgroundPositionVecDestructorType) -> AzStyleBackgroundPositionVecDestructorEnumWrapper {
        AzStyleBackgroundPositionVecDestructorEnumWrapper { inner: AzStyleBackgroundPositionVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundPositionVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundPositionVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleBackgroundPositionVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleBackgroundPositionVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundPositionVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundPositionVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundPositionVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundRepeatVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleBackgroundRepeatVecDestructorEnumWrapper {
        AzStyleBackgroundRepeatVecDestructorEnumWrapper { inner: AzStyleBackgroundRepeatVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleBackgroundRepeatVecDestructorEnumWrapper {
        AzStyleBackgroundRepeatVecDestructorEnumWrapper { inner: AzStyleBackgroundRepeatVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StyleBackgroundRepeatVecDestructorType) -> AzStyleBackgroundRepeatVecDestructorEnumWrapper {
        AzStyleBackgroundRepeatVecDestructorEnumWrapper { inner: AzStyleBackgroundRepeatVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundRepeatVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundRepeatVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleBackgroundRepeatVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleBackgroundRepeatVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundRepeatVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundRepeatVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundRepeatVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundSizeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleBackgroundSizeVecDestructorEnumWrapper {
        AzStyleBackgroundSizeVecDestructorEnumWrapper { inner: AzStyleBackgroundSizeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleBackgroundSizeVecDestructorEnumWrapper {
        AzStyleBackgroundSizeVecDestructorEnumWrapper { inner: AzStyleBackgroundSizeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StyleBackgroundSizeVecDestructorType) -> AzStyleBackgroundSizeVecDestructorEnumWrapper {
        AzStyleBackgroundSizeVecDestructorEnumWrapper { inner: AzStyleBackgroundSizeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundSizeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundSizeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSizeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSizeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundSizeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundSizeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundSizeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleTransformVecDestructorEnumWrapper {
        AzStyleTransformVecDestructorEnumWrapper { inner: AzStyleTransformVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleTransformVecDestructorEnumWrapper {
        AzStyleTransformVecDestructorEnumWrapper { inner: AzStyleTransformVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StyleTransformVecDestructorType) -> AzStyleTransformVecDestructorEnumWrapper {
        AzStyleTransformVecDestructorEnumWrapper { inner: AzStyleTransformVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTransformVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTransformVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleTransformVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleTransformVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCssPropertyVecDestructorEnumWrapper {
        AzCssPropertyVecDestructorEnumWrapper { inner: AzCssPropertyVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzCssPropertyVecDestructorEnumWrapper {
        AzCssPropertyVecDestructorEnumWrapper { inner: AzCssPropertyVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: CssPropertyVecDestructorType) -> AzCssPropertyVecDestructorEnumWrapper {
        AzCssPropertyVecDestructorEnumWrapper { inner: AzCssPropertyVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssPropertyVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPropertyVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCssPropertyVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCssPropertyVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::CssPropertyVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::CssPropertyVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgMultiPolygonVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgMultiPolygonVecDestructorEnumWrapper {
        AzSvgMultiPolygonVecDestructorEnumWrapper { inner: AzSvgMultiPolygonVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgMultiPolygonVecDestructorEnumWrapper {
        AzSvgMultiPolygonVecDestructorEnumWrapper { inner: AzSvgMultiPolygonVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: SvgMultiPolygonVecDestructorType) -> AzSvgMultiPolygonVecDestructorEnumWrapper {
        AzSvgMultiPolygonVecDestructorEnumWrapper { inner: AzSvgMultiPolygonVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgMultiPolygonVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgMultiPolygonVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzSvgMultiPolygonVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzSvgMultiPolygonVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgMultiPolygonVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgMultiPolygonVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgMultiPolygonVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgSimpleNodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgSimpleNodeVecDestructorEnumWrapper {
        AzSvgSimpleNodeVecDestructorEnumWrapper { inner: AzSvgSimpleNodeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgSimpleNodeVecDestructorEnumWrapper {
        AzSvgSimpleNodeVecDestructorEnumWrapper { inner: AzSvgSimpleNodeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: SvgSimpleNodeVecDestructorType) -> AzSvgSimpleNodeVecDestructorEnumWrapper {
        AzSvgSimpleNodeVecDestructorEnumWrapper { inner: AzSvgSimpleNodeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgSimpleNodeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgSimpleNodeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzSvgSimpleNodeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzSvgSimpleNodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgSimpleNodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgSimpleNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgSimpleNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgPathVecDestructorEnumWrapper {
        AzSvgPathVecDestructorEnumWrapper { inner: AzSvgPathVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgPathVecDestructorEnumWrapper {
        AzSvgPathVecDestructorEnumWrapper { inner: AzSvgPathVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: SvgPathVecDestructorType) -> AzSvgPathVecDestructorEnumWrapper {
        AzSvgPathVecDestructorEnumWrapper { inner: AzSvgPathVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgPathVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgPathVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzSvgPathVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzSvgPathVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexAttributeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzVertexAttributeVecDestructorEnumWrapper {
        AzVertexAttributeVecDestructorEnumWrapper { inner: AzVertexAttributeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzVertexAttributeVecDestructorEnumWrapper {
        AzVertexAttributeVecDestructorEnumWrapper { inner: AzVertexAttributeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: VertexAttributeVecDestructorType) -> AzVertexAttributeVecDestructorEnumWrapper {
        AzVertexAttributeVecDestructorEnumWrapper { inner: AzVertexAttributeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzVertexAttributeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzVertexAttributeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzVertexAttributeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzVertexAttributeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVertexAttributeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexAttributeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexAttributeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathElementVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgPathElementVecDestructorEnumWrapper {
        AzSvgPathElementVecDestructorEnumWrapper { inner: AzSvgPathElementVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgPathElementVecDestructorEnumWrapper {
        AzSvgPathElementVecDestructorEnumWrapper { inner: AzSvgPathElementVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: SvgPathElementVecDestructorType) -> AzSvgPathElementVecDestructorEnumWrapper {
        AzSvgPathElementVecDestructorEnumWrapper { inner: AzSvgPathElementVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgPathElementVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgPathElementVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzSvgPathElementVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzSvgPathElementVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathElementVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathElementVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathElementVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgVertexVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgVertexVecDestructorEnumWrapper {
        AzSvgVertexVecDestructorEnumWrapper { inner: AzSvgVertexVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgVertexVecDestructorEnumWrapper {
        AzSvgVertexVecDestructorEnumWrapper { inner: AzSvgVertexVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: SvgVertexVecDestructorType) -> AzSvgVertexVecDestructorEnumWrapper {
        AzSvgVertexVecDestructorEnumWrapper { inner: AzSvgVertexVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgVertexVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgVertexVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzSvgVertexVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzSvgVertexVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgVertexVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgVertexVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgVertexVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgColoredVertexVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgColoredVertexVecDestructorEnumWrapper {
        AzSvgColoredVertexVecDestructorEnumWrapper { inner: AzSvgColoredVertexVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgColoredVertexVecDestructorEnumWrapper {
        AzSvgColoredVertexVecDestructorEnumWrapper { inner: AzSvgColoredVertexVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: SvgColoredVertexVecDestructorType) -> AzSvgColoredVertexVecDestructorEnumWrapper {
        AzSvgColoredVertexVecDestructorEnumWrapper { inner: AzSvgColoredVertexVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgColoredVertexVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgColoredVertexVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzSvgColoredVertexVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzSvgColoredVertexVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgColoredVertexVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgColoredVertexVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgColoredVertexVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU32VecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzU32VecDestructorEnumWrapper {
        AzU32VecDestructorEnumWrapper { inner: AzU32VecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzU32VecDestructorEnumWrapper {
        AzU32VecDestructorEnumWrapper { inner: AzU32VecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: U32VecDestructorType) -> AzU32VecDestructorEnumWrapper {
        AzU32VecDestructorEnumWrapper { inner: AzU32VecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzU32VecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzU32VecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzU32VecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzU32VecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzU32VecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U32VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U32VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXWindowTypeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzXWindowTypeVecDestructorEnumWrapper {
        AzXWindowTypeVecDestructorEnumWrapper { inner: AzXWindowTypeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzXWindowTypeVecDestructorEnumWrapper {
        AzXWindowTypeVecDestructorEnumWrapper { inner: AzXWindowTypeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: XWindowTypeVecDestructorType) -> AzXWindowTypeVecDestructorEnumWrapper {
        AzXWindowTypeVecDestructorEnumWrapper { inner: AzXWindowTypeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzXWindowTypeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXWindowTypeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzXWindowTypeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzXWindowTypeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXWindowTypeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowTypeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowTypeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVirtualKeyCodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzVirtualKeyCodeVecDestructorEnumWrapper {
        AzVirtualKeyCodeVecDestructorEnumWrapper { inner: AzVirtualKeyCodeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzVirtualKeyCodeVecDestructorEnumWrapper {
        AzVirtualKeyCodeVecDestructorEnumWrapper { inner: AzVirtualKeyCodeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: VirtualKeyCodeVecDestructorType) -> AzVirtualKeyCodeVecDestructorEnumWrapper {
        AzVirtualKeyCodeVecDestructorEnumWrapper { inner: AzVirtualKeyCodeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzVirtualKeyCodeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzVirtualKeyCodeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzVirtualKeyCodeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzVirtualKeyCodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVirtualKeyCodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCascadeInfoVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCascadeInfoVecDestructorEnumWrapper {
        AzCascadeInfoVecDestructorEnumWrapper { inner: AzCascadeInfoVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzCascadeInfoVecDestructorEnumWrapper {
        AzCascadeInfoVecDestructorEnumWrapper { inner: AzCascadeInfoVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: CascadeInfoVecDestructorType) -> AzCascadeInfoVecDestructorEnumWrapper {
        AzCascadeInfoVecDestructorEnumWrapper { inner: AzCascadeInfoVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCascadeInfoVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCascadeInfoVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCascadeInfoVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCascadeInfoVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCascadeInfoVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::style::CascadeInfoVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::style::CascadeInfoVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScanCodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzScanCodeVecDestructorEnumWrapper {
        AzScanCodeVecDestructorEnumWrapper { inner: AzScanCodeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzScanCodeVecDestructorEnumWrapper {
        AzScanCodeVecDestructorEnumWrapper { inner: AzScanCodeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: ScanCodeVecDestructorType) -> AzScanCodeVecDestructorEnumWrapper {
        AzScanCodeVecDestructorEnumWrapper { inner: AzScanCodeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzScanCodeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzScanCodeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzScanCodeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzScanCodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzScanCodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ScanCodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ScanCodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssDeclarationVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCssDeclarationVecDestructorEnumWrapper {
        AzCssDeclarationVecDestructorEnumWrapper { inner: AzCssDeclarationVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzCssDeclarationVecDestructorEnumWrapper {
        AzCssDeclarationVecDestructorEnumWrapper { inner: AzCssDeclarationVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: CssDeclarationVecDestructorType) -> AzCssDeclarationVecDestructorEnumWrapper {
        AzCssDeclarationVecDestructorEnumWrapper { inner: AzCssDeclarationVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssDeclarationVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssDeclarationVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCssDeclarationVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCssDeclarationVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssDeclarationVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssDeclarationVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssDeclarationVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPathSelectorVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCssPathSelectorVecDestructorEnumWrapper {
        AzCssPathSelectorVecDestructorEnumWrapper { inner: AzCssPathSelectorVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzCssPathSelectorVecDestructorEnumWrapper {
        AzCssPathSelectorVecDestructorEnumWrapper { inner: AzCssPathSelectorVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: CssPathSelectorVecDestructorType) -> AzCssPathSelectorVecDestructorEnumWrapper {
        AzCssPathSelectorVecDestructorEnumWrapper { inner: AzCssPathSelectorVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssPathSelectorVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPathSelectorVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCssPathSelectorVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCssPathSelectorVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPathSelectorVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPathSelectorVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPathSelectorVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylesheetVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStylesheetVecDestructorEnumWrapper {
        AzStylesheetVecDestructorEnumWrapper { inner: AzStylesheetVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStylesheetVecDestructorEnumWrapper {
        AzStylesheetVecDestructorEnumWrapper { inner: AzStylesheetVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StylesheetVecDestructorType) -> AzStylesheetVecDestructorEnumWrapper {
        AzStylesheetVecDestructorEnumWrapper { inner: AzStylesheetVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStylesheetVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStylesheetVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStylesheetVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStylesheetVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStylesheetVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::StylesheetVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::StylesheetVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssRuleBlockVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCssRuleBlockVecDestructorEnumWrapper {
        AzCssRuleBlockVecDestructorEnumWrapper { inner: AzCssRuleBlockVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzCssRuleBlockVecDestructorEnumWrapper {
        AzCssRuleBlockVecDestructorEnumWrapper { inner: AzCssRuleBlockVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: CssRuleBlockVecDestructorType) -> AzCssRuleBlockVecDestructorEnumWrapper {
        AzCssRuleBlockVecDestructorEnumWrapper { inner: AzCssRuleBlockVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssRuleBlockVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssRuleBlockVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCssRuleBlockVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCssRuleBlockVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssRuleBlockVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssRuleBlockVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssRuleBlockVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzF32VecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzF32VecDestructorEnumWrapper {
        AzF32VecDestructorEnumWrapper { inner: AzF32VecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzF32VecDestructorEnumWrapper {
        AzF32VecDestructorEnumWrapper { inner: AzF32VecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: F32VecDestructorType) -> AzF32VecDestructorEnumWrapper {
        AzF32VecDestructorEnumWrapper { inner: AzF32VecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzF32VecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzF32VecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzF32VecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzF32VecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzF32VecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::F32VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::F32VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU16VecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzU16VecDestructorEnumWrapper {
        AzU16VecDestructorEnumWrapper { inner: AzU16VecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzU16VecDestructorEnumWrapper {
        AzU16VecDestructorEnumWrapper { inner: AzU16VecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: U16VecDestructorType) -> AzU16VecDestructorEnumWrapper {
        AzU16VecDestructorEnumWrapper { inner: AzU16VecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzU16VecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzU16VecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzU16VecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzU16VecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzU16VecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U16VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U16VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU8VecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzU8VecDestructorEnumWrapper {
        AzU8VecDestructorEnumWrapper { inner: AzU8VecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzU8VecDestructorEnumWrapper {
        AzU8VecDestructorEnumWrapper { inner: AzU8VecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: U8VecDestructorType) -> AzU8VecDestructorEnumWrapper {
        AzU8VecDestructorEnumWrapper { inner: AzU8VecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzU8VecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzU8VecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzU8VecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzU8VecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzU8VecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U8VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U8VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallbackDataVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCallbackDataVecDestructorEnumWrapper {
        AzCallbackDataVecDestructorEnumWrapper { inner: AzCallbackDataVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzCallbackDataVecDestructorEnumWrapper {
        AzCallbackDataVecDestructorEnumWrapper { inner: AzCallbackDataVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: CallbackDataVecDestructorType) -> AzCallbackDataVecDestructorEnumWrapper {
        AzCallbackDataVecDestructorEnumWrapper { inner: AzCallbackDataVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCallbackDataVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCallbackDataVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCallbackDataVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCallbackDataVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCallbackDataVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::CallbackDataVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::CallbackDataVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAzDebugMessageVec {
}

#[pyproto]
impl PyObjectProtocol for AzAzDebugMessageVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::AzDebugMessageVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::AzDebugMessageVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLuintVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzGLuintVecDestructorEnumWrapper {
        AzGLuintVecDestructorEnumWrapper { inner: AzGLuintVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzGLuintVecDestructorEnumWrapper {
        AzGLuintVecDestructorEnumWrapper { inner: AzGLuintVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: GLuintVecDestructorType) -> AzGLuintVecDestructorEnumWrapper {
        AzGLuintVecDestructorEnumWrapper { inner: AzGLuintVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzGLuintVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzGLuintVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzGLuintVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzGLuintVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGLuintVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLuintVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLuintVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLintVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzGLintVecDestructorEnumWrapper {
        AzGLintVecDestructorEnumWrapper { inner: AzGLintVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzGLintVecDestructorEnumWrapper {
        AzGLintVecDestructorEnumWrapper { inner: AzGLintVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: GLintVecDestructorType) -> AzGLintVecDestructorEnumWrapper {
        AzGLintVecDestructorEnumWrapper { inner: AzGLintVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzGLintVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzGLintVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzGLintVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzGLintVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGLintVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLintVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLintVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStringVecDestructorEnumWrapper {
        AzStringVecDestructorEnumWrapper { inner: AzStringVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStringVecDestructorEnumWrapper {
        AzStringVecDestructorEnumWrapper { inner: AzStringVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StringVecDestructorType) -> AzStringVecDestructorEnumWrapper {
        AzStringVecDestructorEnumWrapper { inner: AzStringVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStringVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStringVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStringVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStringVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStringVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::StringVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::StringVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringPairVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStringPairVecDestructorEnumWrapper {
        AzStringPairVecDestructorEnumWrapper { inner: AzStringPairVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStringPairVecDestructorEnumWrapper {
        AzStringPairVecDestructorEnumWrapper { inner: AzStringPairVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StringPairVecDestructorType) -> AzStringPairVecDestructorEnumWrapper {
        AzStringPairVecDestructorEnumWrapper { inner: AzStringPairVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStringPairVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStringPairVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStringPairVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStringPairVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStringPairVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::StringPairVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::StringPairVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedLinearColorStopVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNormalizedLinearColorStopVecDestructorEnumWrapper {
        AzNormalizedLinearColorStopVecDestructorEnumWrapper { inner: AzNormalizedLinearColorStopVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzNormalizedLinearColorStopVecDestructorEnumWrapper {
        AzNormalizedLinearColorStopVecDestructorEnumWrapper { inner: AzNormalizedLinearColorStopVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: NormalizedLinearColorStopVecDestructorType) -> AzNormalizedLinearColorStopVecDestructorEnumWrapper {
        AzNormalizedLinearColorStopVecDestructorEnumWrapper { inner: AzNormalizedLinearColorStopVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNormalizedLinearColorStopVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNormalizedLinearColorStopVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNormalizedLinearColorStopVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNormalizedLinearColorStopVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedLinearColorStopVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedLinearColorStopVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedLinearColorStopVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedRadialColorStopVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNormalizedRadialColorStopVecDestructorEnumWrapper {
        AzNormalizedRadialColorStopVecDestructorEnumWrapper { inner: AzNormalizedRadialColorStopVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzNormalizedRadialColorStopVecDestructorEnumWrapper {
        AzNormalizedRadialColorStopVecDestructorEnumWrapper { inner: AzNormalizedRadialColorStopVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: NormalizedRadialColorStopVecDestructorType) -> AzNormalizedRadialColorStopVecDestructorEnumWrapper {
        AzNormalizedRadialColorStopVecDestructorEnumWrapper { inner: AzNormalizedRadialColorStopVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNormalizedRadialColorStopVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNormalizedRadialColorStopVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNormalizedRadialColorStopVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNormalizedRadialColorStopVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedRadialColorStopVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedRadialColorStopVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedRadialColorStopVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeIdVecDestructorEnumWrapper {
        AzNodeIdVecDestructorEnumWrapper { inner: AzNodeIdVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeIdVecDestructorEnumWrapper {
        AzNodeIdVecDestructorEnumWrapper { inner: AzNodeIdVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: NodeIdVecDestructorType) -> AzNodeIdVecDestructorEnumWrapper {
        AzNodeIdVecDestructorEnumWrapper { inner: AzNodeIdVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeIdVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeIdVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeIdVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeIdVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeIdVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeIdVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeIdVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeHierarchyItemVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeHierarchyItemVecDestructorEnumWrapper {
        AzNodeHierarchyItemVecDestructorEnumWrapper { inner: AzNodeHierarchyItemVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeHierarchyItemVecDestructorEnumWrapper {
        AzNodeHierarchyItemVecDestructorEnumWrapper { inner: AzNodeHierarchyItemVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: NodeHierarchyItemVecDestructorType) -> AzNodeHierarchyItemVecDestructorEnumWrapper {
        AzNodeHierarchyItemVecDestructorEnumWrapper { inner: AzNodeHierarchyItemVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeHierarchyItemVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeHierarchyItemVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeHierarchyItemVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeHierarchyItemVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeHierarchyItemVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeHierarchyItemVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeHierarchyItemVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledNodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyledNodeVecDestructorEnumWrapper {
        AzStyledNodeVecDestructorEnumWrapper { inner: AzStyledNodeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStyledNodeVecDestructorEnumWrapper {
        AzStyledNodeVecDestructorEnumWrapper { inner: AzStyledNodeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StyledNodeVecDestructorType) -> AzStyledNodeVecDestructorEnumWrapper {
        AzStyledNodeVecDestructorEnumWrapper { inner: AzStyledNodeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyledNodeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyledNodeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyledNodeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyledNodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyledNodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
        AzTagIdToNodeIdMappingVecDestructorEnumWrapper { inner: AzTagIdToNodeIdMappingVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
        AzTagIdToNodeIdMappingVecDestructorEnumWrapper { inner: AzTagIdToNodeIdMappingVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: TagIdToNodeIdMappingVecDestructorType) -> AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
        AzTagIdToNodeIdMappingVecDestructorEnumWrapper { inner: AzTagIdToNodeIdMappingVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzTagIdToNodeIdMappingVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTagIdToNodeIdMappingVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzTagIdToNodeIdMappingVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzTagIdToNodeIdMappingVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::TagIdToNodeIdMappingVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::TagIdToNodeIdMappingVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzParentWithNodeDepthVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzParentWithNodeDepthVecDestructorEnumWrapper {
        AzParentWithNodeDepthVecDestructorEnumWrapper { inner: AzParentWithNodeDepthVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzParentWithNodeDepthVecDestructorEnumWrapper {
        AzParentWithNodeDepthVecDestructorEnumWrapper { inner: AzParentWithNodeDepthVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: ParentWithNodeDepthVecDestructorType) -> AzParentWithNodeDepthVecDestructorEnumWrapper {
        AzParentWithNodeDepthVecDestructorEnumWrapper { inner: AzParentWithNodeDepthVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzParentWithNodeDepthVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzParentWithNodeDepthVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzParentWithNodeDepthVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzParentWithNodeDepthVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzParentWithNodeDepthVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::ParentWithNodeDepthVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::ParentWithNodeDepthVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeDataVecDestructorEnumWrapper {
        AzNodeDataVecDestructorEnumWrapper { inner: AzNodeDataVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeDataVecDestructorEnumWrapper {
        AzNodeDataVecDestructorEnumWrapper { inner: AzNodeDataVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: NodeDataVecDestructorType) -> AzNodeDataVecDestructorEnumWrapper {
        AzNodeDataVecDestructorEnumWrapper { inner: AzNodeDataVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeDataVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeDataVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeDataVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeDataVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAzDebugMessageVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzAzDebugMessageVecDestructorEnumWrapper {
        AzAzDebugMessageVecDestructorEnumWrapper { inner: AzAzDebugMessageVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzAzDebugMessageVecDestructorEnumWrapper {
        AzAzDebugMessageVecDestructorEnumWrapper { inner: AzAzDebugMessageVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: DebugMessageVecDestructorType) -> AzAzDebugMessageVecDestructorEnumWrapper {
        AzAzDebugMessageVecDestructorEnumWrapper { inner: AzAzDebugMessageVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzAzDebugMessageVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAzDebugMessageVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzAzDebugMessageVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzAzDebugMessageVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAzDebugMessageVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::AzDebugMessageVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::AzDebugMessageVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionSvgPointEnumWrapper {
    #[classattr]
    fn None() -> AzOptionSvgPointEnumWrapper {
        AzOptionSvgPointEnumWrapper { inner: AzOptionSvgPoint::None }
    }
    #[staticmethod]
    fn Some(v: SvgPoint) -> AzOptionSvgPointEnumWrapper {
        AzOptionSvgPointEnumWrapper { inner: AzOptionSvgPoint::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionSvgPoint;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionSvgPoint::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionSvgPoint::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionSvgPointEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::OptionSvgPoint = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::OptionSvgPoint = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionStyleTextAlignEnumWrapper {
    #[classattr]
    fn None() -> AzOptionStyleTextAlignEnumWrapper {
        AzOptionStyleTextAlignEnumWrapper { inner: AzOptionStyleTextAlign::None }
    }
    #[staticmethod]
    fn Some(v: StyleTextAlign) -> AzOptionStyleTextAlignEnumWrapper {
        AzOptionStyleTextAlignEnumWrapper { inner: AzOptionStyleTextAlign::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionStyleTextAlign;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionStyleTextAlign::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionStyleTextAlign::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionStyleTextAlignEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::OptionStyleTextAlign = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::OptionStyleTextAlign = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionListViewOnRowClickEnumWrapper {
    #[classattr]
    fn None() -> AzOptionListViewOnRowClickEnumWrapper {
        AzOptionListViewOnRowClickEnumWrapper { inner: AzOptionListViewOnRowClick::None }
    }
    #[staticmethod]
    fn Some(v: ListViewOnRowClick) -> AzOptionListViewOnRowClickEnumWrapper {
        AzOptionListViewOnRowClickEnumWrapper { inner: AzOptionListViewOnRowClick::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionListViewOnRowClick;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionListViewOnRowClick::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionListViewOnRowClick::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionListViewOnRowClickEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::list_view::OptionListViewOnRowClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::list_view::OptionListViewOnRowClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionListViewOnColumnClickEnumWrapper {
    #[classattr]
    fn None() -> AzOptionListViewOnColumnClickEnumWrapper {
        AzOptionListViewOnColumnClickEnumWrapper { inner: AzOptionListViewOnColumnClick::None }
    }
    #[staticmethod]
    fn Some(v: ListViewOnColumnClick) -> AzOptionListViewOnColumnClickEnumWrapper {
        AzOptionListViewOnColumnClickEnumWrapper { inner: AzOptionListViewOnColumnClick::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionListViewOnColumnClick;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionListViewOnColumnClick::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionListViewOnColumnClick::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionListViewOnColumnClickEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::list_view::OptionListViewOnColumnClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::list_view::OptionListViewOnColumnClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionListViewOnLazyLoadScrollEnumWrapper {
    #[classattr]
    fn None() -> AzOptionListViewOnLazyLoadScrollEnumWrapper {
        AzOptionListViewOnLazyLoadScrollEnumWrapper { inner: AzOptionListViewOnLazyLoadScroll::None }
    }
    #[staticmethod]
    fn Some(v: ListViewOnLazyLoadScroll) -> AzOptionListViewOnLazyLoadScrollEnumWrapper {
        AzOptionListViewOnLazyLoadScrollEnumWrapper { inner: AzOptionListViewOnLazyLoadScroll::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionListViewOnLazyLoadScroll;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionListViewOnLazyLoadScroll::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionListViewOnLazyLoadScroll::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionListViewOnLazyLoadScrollEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::list_view::OptionListViewOnLazyLoadScroll = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::list_view::OptionListViewOnLazyLoadScroll = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMenuEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMenuEnumWrapper {
        AzOptionMenuEnumWrapper { inner: AzOptionMenu::None }
    }
    #[staticmethod]
    fn Some(v: Menu) -> AzOptionMenuEnumWrapper {
        AzOptionMenuEnumWrapper { inner: AzOptionMenu::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionMenu;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMenu::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMenu::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMenuEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::OptionMenu = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::OptionMenu = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionPixelValueNoPercentEnumWrapper {
    #[classattr]
    fn None() -> AzOptionPixelValueNoPercentEnumWrapper {
        AzOptionPixelValueNoPercentEnumWrapper { inner: AzOptionPixelValueNoPercent::None }
    }
    #[staticmethod]
    fn Some(v: PixelValueNoPercent) -> AzOptionPixelValueNoPercentEnumWrapper {
        AzOptionPixelValueNoPercentEnumWrapper { inner: AzOptionPixelValueNoPercent::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionPixelValueNoPercent;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionPixelValueNoPercent::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionPixelValueNoPercent::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionPixelValueNoPercentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::pixel::OptionPixelValueNoPercent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::pixel::OptionPixelValueNoPercent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionDropDownOnChoiceChangeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionDropDownOnChoiceChangeEnumWrapper {
        AzOptionDropDownOnChoiceChangeEnumWrapper { inner: AzOptionDropDownOnChoiceChange::None }
    }
    #[staticmethod]
    fn Some(v: DropDownOnChoiceChange) -> AzOptionDropDownOnChoiceChangeEnumWrapper {
        AzOptionDropDownOnChoiceChangeEnumWrapper { inner: AzOptionDropDownOnChoiceChange::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionDropDownOnChoiceChange;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionDropDownOnChoiceChange::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionDropDownOnChoiceChange::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionDropDownOnChoiceChangeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::drop_down::OptionDropDownOnChoiceChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::drop_down::OptionDropDownOnChoiceChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionResolvedTextLayoutOptionsEnumWrapper {
    #[classattr]
    fn None() -> AzOptionResolvedTextLayoutOptionsEnumWrapper {
        AzOptionResolvedTextLayoutOptionsEnumWrapper { inner: AzOptionResolvedTextLayoutOptions::None }
    }
    #[staticmethod]
    fn Some(v: ResolvedTextLayoutOptions) -> AzOptionResolvedTextLayoutOptionsEnumWrapper {
        AzOptionResolvedTextLayoutOptionsEnumWrapper { inner: AzOptionResolvedTextLayoutOptions::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionResolvedTextLayoutOptions;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionResolvedTextLayoutOptions::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionResolvedTextLayoutOptions::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionResolvedTextLayoutOptionsEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::ui_solver::OptionResolvedTextLayoutOptions = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::ui_solver::OptionResolvedTextLayoutOptions = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionU8VecRefEnumWrapper {
    #[classattr]
    fn None() -> AzOptionU8VecRefEnumWrapper {
        AzOptionU8VecRefEnumWrapper { inner: AzOptionU8VecRef::None }
    }
    #[staticmethod]
    fn Some(v: U8VecRef) -> AzOptionU8VecRefEnumWrapper {
        AzOptionU8VecRefEnumWrapper { inner: AzOptionU8VecRef::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionU8VecRef;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionU8VecRef::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionU8VecRef::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionU8VecRefEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::OptionU8VecRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::OptionU8VecRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionOnNodeAddedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionOnNodeAddedEnumWrapper {
        AzOptionOnNodeAddedEnumWrapper { inner: AzOptionOnNodeAdded::None }
    }
    #[staticmethod]
    fn Some(v: OnNodeAdded) -> AzOptionOnNodeAddedEnumWrapper {
        AzOptionOnNodeAddedEnumWrapper { inner: AzOptionOnNodeAdded::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionOnNodeAdded;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionOnNodeAdded::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionOnNodeAdded::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionOnNodeAddedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeAdded = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeAdded = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionOnNodeRemovedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionOnNodeRemovedEnumWrapper {
        AzOptionOnNodeRemovedEnumWrapper { inner: AzOptionOnNodeRemoved::None }
    }
    #[staticmethod]
    fn Some(v: OnNodeRemoved) -> AzOptionOnNodeRemovedEnumWrapper {
        AzOptionOnNodeRemovedEnumWrapper { inner: AzOptionOnNodeRemoved::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionOnNodeRemoved;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionOnNodeRemoved::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionOnNodeRemoved::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionOnNodeRemovedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeRemoved = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeRemoved = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionOnNodeGraphDraggedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionOnNodeGraphDraggedEnumWrapper {
        AzOptionOnNodeGraphDraggedEnumWrapper { inner: AzOptionOnNodeGraphDragged::None }
    }
    #[staticmethod]
    fn Some(v: OnNodeGraphDragged) -> AzOptionOnNodeGraphDraggedEnumWrapper {
        AzOptionOnNodeGraphDraggedEnumWrapper { inner: AzOptionOnNodeGraphDragged::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionOnNodeGraphDragged;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionOnNodeGraphDragged::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionOnNodeGraphDragged::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionOnNodeGraphDraggedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeGraphDragged = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeGraphDragged = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionOnNodeDraggedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionOnNodeDraggedEnumWrapper {
        AzOptionOnNodeDraggedEnumWrapper { inner: AzOptionOnNodeDragged::None }
    }
    #[staticmethod]
    fn Some(v: OnNodeDragged) -> AzOptionOnNodeDraggedEnumWrapper {
        AzOptionOnNodeDraggedEnumWrapper { inner: AzOptionOnNodeDragged::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionOnNodeDragged;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionOnNodeDragged::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionOnNodeDragged::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionOnNodeDraggedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeDragged = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeDragged = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionOnNodeConnectedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionOnNodeConnectedEnumWrapper {
        AzOptionOnNodeConnectedEnumWrapper { inner: AzOptionOnNodeConnected::None }
    }
    #[staticmethod]
    fn Some(v: OnNodeConnected) -> AzOptionOnNodeConnectedEnumWrapper {
        AzOptionOnNodeConnectedEnumWrapper { inner: AzOptionOnNodeConnected::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionOnNodeConnected;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionOnNodeConnected::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionOnNodeConnected::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionOnNodeConnectedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeConnected = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeConnected = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionOnNodeInputDisconnectedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionOnNodeInputDisconnectedEnumWrapper {
        AzOptionOnNodeInputDisconnectedEnumWrapper { inner: AzOptionOnNodeInputDisconnected::None }
    }
    #[staticmethod]
    fn Some(v: OnNodeInputDisconnected) -> AzOptionOnNodeInputDisconnectedEnumWrapper {
        AzOptionOnNodeInputDisconnectedEnumWrapper { inner: AzOptionOnNodeInputDisconnected::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionOnNodeInputDisconnected;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionOnNodeInputDisconnected::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionOnNodeInputDisconnected::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionOnNodeInputDisconnectedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeInputDisconnected = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeInputDisconnected = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionOnNodeOutputDisconnectedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionOnNodeOutputDisconnectedEnumWrapper {
        AzOptionOnNodeOutputDisconnectedEnumWrapper { inner: AzOptionOnNodeOutputDisconnected::None }
    }
    #[staticmethod]
    fn Some(v: OnNodeOutputDisconnected) -> AzOptionOnNodeOutputDisconnectedEnumWrapper {
        AzOptionOnNodeOutputDisconnectedEnumWrapper { inner: AzOptionOnNodeOutputDisconnected::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionOnNodeOutputDisconnected;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionOnNodeOutputDisconnected::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionOnNodeOutputDisconnected::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionOnNodeOutputDisconnectedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeOutputDisconnected = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeOutputDisconnected = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionColorInputOnValueChangeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionColorInputOnValueChangeEnumWrapper {
        AzOptionColorInputOnValueChangeEnumWrapper { inner: AzOptionColorInputOnValueChange::None }
    }
    #[staticmethod]
    fn Some(v: ColorInputOnValueChange) -> AzOptionColorInputOnValueChangeEnumWrapper {
        AzOptionColorInputOnValueChangeEnumWrapper { inner: AzOptionColorInputOnValueChange::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionColorInputOnValueChange;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionColorInputOnValueChange::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionColorInputOnValueChange::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionColorInputOnValueChangeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::color_input::OptionColorInputOnValueChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::color_input::OptionColorInputOnValueChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionButtonOnClickEnumWrapper {
    #[classattr]
    fn None() -> AzOptionButtonOnClickEnumWrapper {
        AzOptionButtonOnClickEnumWrapper { inner: AzOptionButtonOnClick::None }
    }
    #[staticmethod]
    fn Some(v: ButtonOnClick) -> AzOptionButtonOnClickEnumWrapper {
        AzOptionButtonOnClickEnumWrapper { inner: AzOptionButtonOnClick::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionButtonOnClick;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionButtonOnClick::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionButtonOnClick::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionButtonOnClickEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::button::OptionButtonOnClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::button::OptionButtonOnClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTabOnClickEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTabOnClickEnumWrapper {
        AzOptionTabOnClickEnumWrapper { inner: AzOptionTabOnClick::None }
    }
    #[staticmethod]
    fn Some(v: TabOnClick) -> AzOptionTabOnClickEnumWrapper {
        AzOptionTabOnClickEnumWrapper { inner: AzOptionTabOnClick::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTabOnClick;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTabOnClick::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTabOnClick::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTabOnClickEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::tabs::OptionTabOnClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::tabs::OptionTabOnClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionFileInputOnPathChangeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionFileInputOnPathChangeEnumWrapper {
        AzOptionFileInputOnPathChangeEnumWrapper { inner: AzOptionFileInputOnPathChange::None }
    }
    #[staticmethod]
    fn Some(v: FileInputOnPathChange) -> AzOptionFileInputOnPathChangeEnumWrapper {
        AzOptionFileInputOnPathChangeEnumWrapper { inner: AzOptionFileInputOnPathChange::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionFileInputOnPathChange;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionFileInputOnPathChange::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionFileInputOnPathChange::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionFileInputOnPathChangeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::file_input::OptionFileInputOnPathChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::file_input::OptionFileInputOnPathChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionCheckBoxOnToggleEnumWrapper {
    #[classattr]
    fn None() -> AzOptionCheckBoxOnToggleEnumWrapper {
        AzOptionCheckBoxOnToggleEnumWrapper { inner: AzOptionCheckBoxOnToggle::None }
    }
    #[staticmethod]
    fn Some(v: CheckBoxOnToggle) -> AzOptionCheckBoxOnToggleEnumWrapper {
        AzOptionCheckBoxOnToggleEnumWrapper { inner: AzOptionCheckBoxOnToggle::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionCheckBoxOnToggle;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionCheckBoxOnToggle::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionCheckBoxOnToggle::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionCheckBoxOnToggleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::check_box::OptionCheckBoxOnToggle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::check_box::OptionCheckBoxOnToggle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextInputOnTextInputEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextInputOnTextInputEnumWrapper {
        AzOptionTextInputOnTextInputEnumWrapper { inner: AzOptionTextInputOnTextInput::None }
    }
    #[staticmethod]
    fn Some(v: TextInputOnTextInput) -> AzOptionTextInputOnTextInputEnumWrapper {
        AzOptionTextInputOnTextInputEnumWrapper { inner: AzOptionTextInputOnTextInput::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTextInputOnTextInput;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTextInputOnTextInput::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTextInputOnTextInput::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextInputOnTextInputEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OptionTextInputOnTextInput = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OptionTextInputOnTextInput = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextInputOnVirtualKeyDownEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextInputOnVirtualKeyDownEnumWrapper {
        AzOptionTextInputOnVirtualKeyDownEnumWrapper { inner: AzOptionTextInputOnVirtualKeyDown::None }
    }
    #[staticmethod]
    fn Some(v: TextInputOnVirtualKeyDown) -> AzOptionTextInputOnVirtualKeyDownEnumWrapper {
        AzOptionTextInputOnVirtualKeyDownEnumWrapper { inner: AzOptionTextInputOnVirtualKeyDown::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTextInputOnVirtualKeyDown;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTextInputOnVirtualKeyDown::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTextInputOnVirtualKeyDown::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextInputOnVirtualKeyDownEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OptionTextInputOnVirtualKeyDown = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OptionTextInputOnVirtualKeyDown = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextInputOnFocusLostEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextInputOnFocusLostEnumWrapper {
        AzOptionTextInputOnFocusLostEnumWrapper { inner: AzOptionTextInputOnFocusLost::None }
    }
    #[staticmethod]
    fn Some(v: TextInputOnFocusLost) -> AzOptionTextInputOnFocusLostEnumWrapper {
        AzOptionTextInputOnFocusLostEnumWrapper { inner: AzOptionTextInputOnFocusLost::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTextInputOnFocusLost;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTextInputOnFocusLost::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTextInputOnFocusLost::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextInputOnFocusLostEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OptionTextInputOnFocusLost = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OptionTextInputOnFocusLost = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextInputSelectionEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextInputSelectionEnumWrapper {
        AzOptionTextInputSelectionEnumWrapper { inner: AzOptionTextInputSelection::None }
    }
    #[staticmethod]
    fn Some(v: TextInputSelection) -> AzOptionTextInputSelectionEnumWrapper {
        AzOptionTextInputSelectionEnumWrapper { inner: AzOptionTextInputSelection::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTextInputSelection;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTextInputSelection::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTextInputSelection::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextInputSelectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OptionTextInputSelection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::text_input::OptionTextInputSelection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNumberInputOnFocusLostEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNumberInputOnFocusLostEnumWrapper {
        AzOptionNumberInputOnFocusLostEnumWrapper { inner: AzOptionNumberInputOnFocusLost::None }
    }
    #[staticmethod]
    fn Some(v: NumberInputOnFocusLost) -> AzOptionNumberInputOnFocusLostEnumWrapper {
        AzOptionNumberInputOnFocusLostEnumWrapper { inner: AzOptionNumberInputOnFocusLost::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionNumberInputOnFocusLost;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNumberInputOnFocusLost::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNumberInputOnFocusLost::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNumberInputOnFocusLostEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::OptionNumberInputOnFocusLost = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::OptionNumberInputOnFocusLost = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNumberInputOnValueChangeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNumberInputOnValueChangeEnumWrapper {
        AzOptionNumberInputOnValueChangeEnumWrapper { inner: AzOptionNumberInputOnValueChange::None }
    }
    #[staticmethod]
    fn Some(v: NumberInputOnValueChange) -> AzOptionNumberInputOnValueChangeEnumWrapper {
        AzOptionNumberInputOnValueChangeEnumWrapper { inner: AzOptionNumberInputOnValueChange::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionNumberInputOnValueChange;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNumberInputOnValueChange::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNumberInputOnValueChange::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNumberInputOnValueChangeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::OptionNumberInputOnValueChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::number_input::OptionNumberInputOnValueChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMenuItemIconEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMenuItemIconEnumWrapper {
        AzOptionMenuItemIconEnumWrapper { inner: AzOptionMenuItemIcon::None }
    }
    #[staticmethod]
    fn Some(v: MenuItemIcon) -> AzOptionMenuItemIconEnumWrapper {
        AzOptionMenuItemIconEnumWrapper { inner: AzOptionMenuItemIcon::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionMenuItemIcon;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMenuItemIcon::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMenuItemIcon::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMenuItemIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::OptionMenuItemIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::OptionMenuItemIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMenuCallbackEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMenuCallbackEnumWrapper {
        AzOptionMenuCallbackEnumWrapper { inner: AzOptionMenuCallback::None }
    }
    #[staticmethod]
    fn Some(v: MenuCallback) -> AzOptionMenuCallbackEnumWrapper {
        AzOptionMenuCallbackEnumWrapper { inner: AzOptionMenuCallback::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionMenuCallback;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMenuCallback::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMenuCallback::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMenuCallbackEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::OptionMenuCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::OptionMenuCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionVirtualKeyCodeComboEnumWrapper {
    #[classattr]
    fn None() -> AzOptionVirtualKeyCodeComboEnumWrapper {
        AzOptionVirtualKeyCodeComboEnumWrapper { inner: AzOptionVirtualKeyCodeCombo::None }
    }
    #[staticmethod]
    fn Some(v: VirtualKeyCodeCombo) -> AzOptionVirtualKeyCodeComboEnumWrapper {
        AzOptionVirtualKeyCodeComboEnumWrapper { inner: AzOptionVirtualKeyCodeCombo::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionVirtualKeyCodeCombo;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionVirtualKeyCodeCombo::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionVirtualKeyCodeCombo::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionVirtualKeyCodeComboEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionVirtualKeyCodeCombo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionVirtualKeyCodeCombo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionCssPropertyEnumWrapper {
    #[classattr]
    fn None() -> AzOptionCssPropertyEnumWrapper {
        AzOptionCssPropertyEnumWrapper { inner: AzOptionCssProperty::None }
    }
    #[staticmethod]
    fn Some(v: CssProperty) -> AzOptionCssPropertyEnumWrapper {
        AzOptionCssPropertyEnumWrapper { inner: AzOptionCssProperty::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionCssProperty;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionCssProperty::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionCssProperty::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionCssPropertyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::OptionCssProperty = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::OptionCssProperty = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionPositionInfoEnumWrapper {
    #[classattr]
    fn None() -> AzOptionPositionInfoEnumWrapper {
        AzOptionPositionInfoEnumWrapper { inner: AzOptionPositionInfo::None }
    }
    #[staticmethod]
    fn Some(v: PositionInfo) -> AzOptionPositionInfoEnumWrapper {
        AzOptionPositionInfoEnumWrapper { inner: AzOptionPositionInfo::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionPositionInfo;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionPositionInfo::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionPositionInfo::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionPositionInfoEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::ui_solver::OptionPositionInfo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::ui_solver::OptionPositionInfo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTimerIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTimerIdEnumWrapper {
        AzOptionTimerIdEnumWrapper { inner: AzOptionTimerId::None }
    }
    #[staticmethod]
    fn Some(v: TimerId) -> AzOptionTimerIdEnumWrapper {
        AzOptionTimerIdEnumWrapper { inner: AzOptionTimerId::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTimerId;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTimerId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTimerId::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTimerIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::OptionTimerId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::OptionTimerId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionThreadIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionThreadIdEnumWrapper {
        AzOptionThreadIdEnumWrapper { inner: AzOptionThreadId::None }
    }
    #[staticmethod]
    fn Some(v: ThreadId) -> AzOptionThreadIdEnumWrapper {
        AzOptionThreadIdEnumWrapper { inner: AzOptionThreadId::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionThreadId;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionThreadId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionThreadId::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionThreadIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::OptionThreadId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::OptionThreadId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionI16EnumWrapper {
    #[classattr]
    fn None() -> AzOptionI16EnumWrapper {
        AzOptionI16EnumWrapper { inner: AzOptionI16::None }
    }
    #[staticmethod]
    fn Some(v: i16) -> AzOptionI16EnumWrapper {
        AzOptionI16EnumWrapper { inner: AzOptionI16::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionI16;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionI16::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionI16::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionI16EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionI16 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionI16 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionU16EnumWrapper {
    #[classattr]
    fn None() -> AzOptionU16EnumWrapper {
        AzOptionU16EnumWrapper { inner: AzOptionU16::None }
    }
    #[staticmethod]
    fn Some(v: u16) -> AzOptionU16EnumWrapper {
        AzOptionU16EnumWrapper { inner: AzOptionU16::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionU16;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionU16::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionU16::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionU16EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionU16 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionU16 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionU32EnumWrapper {
    #[classattr]
    fn None() -> AzOptionU32EnumWrapper {
        AzOptionU32EnumWrapper { inner: AzOptionU32::None }
    }
    #[staticmethod]
    fn Some(v: u32) -> AzOptionU32EnumWrapper {
        AzOptionU32EnumWrapper { inner: AzOptionU32::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionU32;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionU32::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionU32::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionU32EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionU32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionU32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionImageRefEnumWrapper {
    #[classattr]
    fn None() -> AzOptionImageRefEnumWrapper {
        AzOptionImageRefEnumWrapper { inner: AzOptionImageRef::None }
    }
    #[staticmethod]
    fn Some(v: ImageRef) -> AzOptionImageRefEnumWrapper {
        AzOptionImageRefEnumWrapper { inner: AzOptionImageRef::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionImageRef;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionImageRef::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionImageRef::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionImageRefEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::OptionImageRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::OptionImageRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionFontRefEnumWrapper {
    #[classattr]
    fn None() -> AzOptionFontRefEnumWrapper {
        AzOptionFontRefEnumWrapper { inner: AzOptionFontRef::None }
    }
    #[staticmethod]
    fn Some(v: FontRef) -> AzOptionFontRefEnumWrapper {
        AzOptionFontRefEnumWrapper { inner: AzOptionFontRef::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionFontRef;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionFontRef::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionFontRef::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionFontRefEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::OptionFontRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::OptionFontRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionOnNodeFieldEditedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionOnNodeFieldEditedEnumWrapper {
        AzOptionOnNodeFieldEditedEnumWrapper { inner: AzOptionOnNodeFieldEdited::None }
    }
    #[staticmethod]
    fn Some(v: OnNodeFieldEdited) -> AzOptionOnNodeFieldEditedEnumWrapper {
        AzOptionOnNodeFieldEditedEnumWrapper { inner: AzOptionOnNodeFieldEdited::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionOnNodeFieldEdited;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionOnNodeFieldEdited::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionOnNodeFieldEdited::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionOnNodeFieldEditedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeFieldEdited = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &crate::widgets::node_graph::OptionOnNodeFieldEdited = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionFileTypeListEnumWrapper {
    #[classattr]
    fn None() -> AzOptionFileTypeListEnumWrapper {
        AzOptionFileTypeListEnumWrapper { inner: AzOptionFileTypeList::None }
    }
    #[staticmethod]
    fn Some(v: FileTypeList) -> AzOptionFileTypeListEnumWrapper {
        AzOptionFileTypeListEnumWrapper { inner: AzOptionFileTypeList::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionFileTypeList;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionFileTypeList::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionFileTypeList::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionFileTypeListEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::desktop::dialogs::OptionFileTypeList = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::desktop::dialogs::OptionFileTypeList = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionWindowStateEnumWrapper {
    #[classattr]
    fn None() -> AzOptionWindowStateEnumWrapper {
        AzOptionWindowStateEnumWrapper { inner: AzOptionWindowState::None }
    }
    #[staticmethod]
    fn Some(v: WindowState) -> AzOptionWindowStateEnumWrapper {
        AzOptionWindowStateEnumWrapper { inner: AzOptionWindowState::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionWindowState;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionWindowState::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionWindowState::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionWindowStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::window_state::OptionWindowState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::window_state::OptionWindowState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMouseStateEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMouseStateEnumWrapper {
        AzOptionMouseStateEnumWrapper { inner: AzOptionMouseState::None }
    }
    #[staticmethod]
    fn Some(v: MouseState) -> AzOptionMouseStateEnumWrapper {
        AzOptionMouseStateEnumWrapper { inner: AzOptionMouseState::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionMouseState;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMouseState::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMouseState::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMouseStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionMouseState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionMouseState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionKeyboardStateEnumWrapper {
    #[classattr]
    fn None() -> AzOptionKeyboardStateEnumWrapper {
        AzOptionKeyboardStateEnumWrapper { inner: AzOptionKeyboardState::None }
    }
    #[staticmethod]
    fn Some(v: KeyboardState) -> AzOptionKeyboardStateEnumWrapper {
        AzOptionKeyboardStateEnumWrapper { inner: AzOptionKeyboardState::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionKeyboardState;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionKeyboardState::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionKeyboardState::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionKeyboardStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionKeyboardState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionKeyboardState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionStringVecEnumWrapper {
    #[classattr]
    fn None() -> AzOptionStringVecEnumWrapper {
        AzOptionStringVecEnumWrapper { inner: AzOptionStringVec::None }
    }
    #[staticmethod]
    fn Some(v: StringVec) -> AzOptionStringVecEnumWrapper {
        AzOptionStringVecEnumWrapper { inner: AzOptionStringVec::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionStringVec;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionStringVec::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionStringVec::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionStringVecEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::OptionStringVec = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::OptionStringVec = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionFileEnumWrapper {
    #[classattr]
    fn None() -> AzOptionFileEnumWrapper {
        AzOptionFileEnumWrapper { inner: AzOptionFile::None }
    }
    #[staticmethod]
    fn Some(v: File) -> AzOptionFileEnumWrapper {
        AzOptionFileEnumWrapper { inner: AzOptionFile::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionFile;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionFile::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionFile::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionFileEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::desktop::file::OptionFile = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::desktop::file::OptionFile = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionClipboardEnumWrapper {
    #[classattr]
    fn None() -> AzOptionClipboardEnumWrapper {
        AzOptionClipboardEnumWrapper { inner: AzOptionClipboard::None }
    }
    #[staticmethod]

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionClipboard;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionClipboard::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionClipboard::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionClipboardEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::desktop::app::OptionClipboard = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::desktop::app::OptionClipboard = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionThreadReceiveMsgEnumWrapper {
    #[classattr]
    fn None() -> AzOptionThreadReceiveMsgEnumWrapper {
        AzOptionThreadReceiveMsgEnumWrapper { inner: AzOptionThreadReceiveMsg::None }
    }
    #[staticmethod]
    fn Some(v: ThreadReceiveMsg) -> AzOptionThreadReceiveMsgEnumWrapper {
        AzOptionThreadReceiveMsgEnumWrapper { inner: AzOptionThreadReceiveMsg::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionThreadReceiveMsg;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionThreadReceiveMsg::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionThreadReceiveMsg::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionThreadReceiveMsgEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::thread::OptionThreadReceiveMsg = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::thread::OptionThreadReceiveMsg = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionPercentageValueEnumWrapper {
    #[classattr]
    fn None() -> AzOptionPercentageValueEnumWrapper {
        AzOptionPercentageValueEnumWrapper { inner: AzOptionPercentageValue::None }
    }
    #[staticmethod]
    fn Some(v: PercentageValue) -> AzOptionPercentageValueEnumWrapper {
        AzOptionPercentageValueEnumWrapper { inner: AzOptionPercentageValue::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionPercentageValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionPercentageValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionPercentageValue::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionPercentageValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::length::OptionPercentageValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::length::OptionPercentageValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionAngleValueEnumWrapper {
    #[classattr]
    fn None() -> AzOptionAngleValueEnumWrapper {
        AzOptionAngleValueEnumWrapper { inner: AzOptionAngleValue::None }
    }
    #[staticmethod]
    fn Some(v: AngleValue) -> AzOptionAngleValueEnumWrapper {
        AzOptionAngleValueEnumWrapper { inner: AzOptionAngleValue::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionAngleValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionAngleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionAngleValue::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionAngleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::angle::OptionAngleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::angle::OptionAngleValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionRendererOptionsEnumWrapper {
    #[classattr]
    fn None() -> AzOptionRendererOptionsEnumWrapper {
        AzOptionRendererOptionsEnumWrapper { inner: AzOptionRendererOptions::None }
    }
    #[staticmethod]
    fn Some(v: RendererOptions) -> AzOptionRendererOptionsEnumWrapper {
        AzOptionRendererOptionsEnumWrapper { inner: AzOptionRendererOptions::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionRendererOptions;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionRendererOptions::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionRendererOptions::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionRendererOptionsEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionRendererOptions = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionRendererOptions = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionCallbackEnumWrapper {
    #[classattr]
    fn None() -> AzOptionCallbackEnumWrapper {
        AzOptionCallbackEnumWrapper { inner: AzOptionCallback::None }
    }
    #[staticmethod]
    fn Some(v: Callback) -> AzOptionCallbackEnumWrapper {
        AzOptionCallbackEnumWrapper { inner: AzOptionCallback::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionCallback;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionCallback::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionCallback::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionCallbackEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::OptionCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::OptionCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionThreadSendMsgEnumWrapper {
    #[classattr]
    fn None() -> AzOptionThreadSendMsgEnumWrapper {
        AzOptionThreadSendMsgEnumWrapper { inner: AzOptionThreadSendMsg::None }
    }
    #[staticmethod]
    fn Some(v: ThreadSendMsg) -> AzOptionThreadSendMsgEnumWrapper {
        AzOptionThreadSendMsgEnumWrapper { inner: AzOptionThreadSendMsg::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionThreadSendMsg;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionThreadSendMsg::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionThreadSendMsg::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionThreadSendMsgEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::OptionThreadSendMsg = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::OptionThreadSendMsg = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLayoutRectEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLayoutRectEnumWrapper {
        AzOptionLayoutRectEnumWrapper { inner: AzOptionLayoutRect::None }
    }
    #[staticmethod]
    fn Some(v: LayoutRect) -> AzOptionLayoutRectEnumWrapper {
        AzOptionLayoutRectEnumWrapper { inner: AzOptionLayoutRect::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionLayoutRect;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLayoutRect::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLayoutRect::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLayoutRectEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::OptionLayoutRect = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::OptionLayoutRect = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionRefAnyEnumWrapper {
    #[classattr]
    fn None() -> AzOptionRefAnyEnumWrapper {
        AzOptionRefAnyEnumWrapper { inner: AzOptionRefAny::None }
    }
    #[staticmethod]
    fn Some(v: RefAny) -> AzOptionRefAnyEnumWrapper {
        AzOptionRefAnyEnumWrapper { inner: AzOptionRefAny::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionRefAny;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionRefAny::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionRefAny::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionRefAnyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::refany::OptionRefAny = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::refany::OptionRefAny = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionInlineTextEnumWrapper {
    #[classattr]
    fn None() -> AzOptionInlineTextEnumWrapper {
        AzOptionInlineTextEnumWrapper { inner: AzOptionInlineText::None }
    }
    #[staticmethod]
    fn Some(v: InlineText) -> AzOptionInlineTextEnumWrapper {
        AzOptionInlineTextEnumWrapper { inner: AzOptionInlineText::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionInlineText;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionInlineText::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionInlineText::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionInlineTextEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::OptionInlineText = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::OptionInlineText = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLayoutPointEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLayoutPointEnumWrapper {
        AzOptionLayoutPointEnumWrapper { inner: AzOptionLayoutPoint::None }
    }
    #[staticmethod]
    fn Some(v: LayoutPoint) -> AzOptionLayoutPointEnumWrapper {
        AzOptionLayoutPointEnumWrapper { inner: AzOptionLayoutPoint::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionLayoutPoint;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLayoutPoint::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLayoutPoint::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLayoutPointEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::OptionLayoutPoint = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::OptionLayoutPoint = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLayoutSizeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLayoutSizeEnumWrapper {
        AzOptionLayoutSizeEnumWrapper { inner: AzOptionLayoutSize::None }
    }
    #[staticmethod]
    fn Some(v: LayoutSize) -> AzOptionLayoutSizeEnumWrapper {
        AzOptionLayoutSizeEnumWrapper { inner: AzOptionLayoutSize::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionLayoutSize;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLayoutSize::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLayoutSize::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLayoutSizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::OptionLayoutSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::OptionLayoutSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionWindowThemeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionWindowThemeEnumWrapper {
        AzOptionWindowThemeEnumWrapper { inner: AzOptionWindowTheme::None }
    }
    #[staticmethod]
    fn Some(v: WindowTheme) -> AzOptionWindowThemeEnumWrapper {
        AzOptionWindowThemeEnumWrapper { inner: AzOptionWindowTheme::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionWindowTheme;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionWindowTheme::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionWindowTheme::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionWindowThemeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWindowTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWindowTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeIdEnumWrapper {
        AzOptionNodeIdEnumWrapper { inner: AzOptionNodeId::None }
    }
    #[staticmethod]
    fn Some(v: NodeHierarchyItemId) -> AzOptionNodeIdEnumWrapper {
        AzOptionNodeIdEnumWrapper { inner: AzOptionNodeId::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionNodeId;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNodeId::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::OptionNodeId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::OptionNodeId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionDomNodeIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionDomNodeIdEnumWrapper {
        AzOptionDomNodeIdEnumWrapper { inner: AzOptionDomNodeId::None }
    }
    #[staticmethod]
    fn Some(v: DomNodeId) -> AzOptionDomNodeIdEnumWrapper {
        AzOptionDomNodeIdEnumWrapper { inner: AzOptionDomNodeId::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionDomNodeId;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionDomNodeId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionDomNodeId::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionDomNodeIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::OptionDomNodeId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::OptionDomNodeId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionColorUEnumWrapper {
    #[classattr]
    fn None() -> AzOptionColorUEnumWrapper {
        AzOptionColorUEnumWrapper { inner: AzOptionColorU::None }
    }
    #[staticmethod]
    fn Some(v: ColorU) -> AzOptionColorUEnumWrapper {
        AzOptionColorUEnumWrapper { inner: AzOptionColorU::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionColorU;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionColorU::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionColorU::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionColorUEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::color::OptionColorU = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::color::OptionColorU = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionRawImageEnumWrapper {
    #[classattr]
    fn None() -> AzOptionRawImageEnumWrapper {
        AzOptionRawImageEnumWrapper { inner: AzOptionRawImage::None }
    }
    #[staticmethod]
    fn Some(v: RawImage) -> AzOptionRawImageEnumWrapper {
        AzOptionRawImageEnumWrapper { inner: AzOptionRawImage::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionRawImage;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionRawImage::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionRawImage::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionRawImageEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::OptionRawImage = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::OptionRawImage = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionSvgDashPatternEnumWrapper {
    #[classattr]
    fn None() -> AzOptionSvgDashPatternEnumWrapper {
        AzOptionSvgDashPatternEnumWrapper { inner: AzOptionSvgDashPattern::None }
    }
    #[staticmethod]
    fn Some(v: SvgDashPattern) -> AzOptionSvgDashPatternEnumWrapper {
        AzOptionSvgDashPatternEnumWrapper { inner: AzOptionSvgDashPattern::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionSvgDashPattern;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionSvgDashPattern::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionSvgDashPattern::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionSvgDashPatternEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::OptionSvgDashPattern = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::OptionSvgDashPattern = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionWaylandThemeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionWaylandThemeEnumWrapper {
        AzOptionWaylandThemeEnumWrapper { inner: AzOptionWaylandTheme::None }
    }
    #[staticmethod]
    fn Some(v: WaylandTheme) -> AzOptionWaylandThemeEnumWrapper {
        AzOptionWaylandThemeEnumWrapper { inner: AzOptionWaylandTheme::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionWaylandTheme;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionWaylandTheme::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionWaylandTheme::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionWaylandThemeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWaylandTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWaylandTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTaskBarIconEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTaskBarIconEnumWrapper {
        AzOptionTaskBarIconEnumWrapper { inner: AzOptionTaskBarIcon::None }
    }
    #[staticmethod]
    fn Some(v: TaskBarIcon) -> AzOptionTaskBarIconEnumWrapper {
        AzOptionTaskBarIconEnumWrapper { inner: AzOptionTaskBarIcon::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTaskBarIcon;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTaskBarIcon::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTaskBarIcon::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTaskBarIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionTaskBarIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionTaskBarIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionHwndHandleEnumWrapper {
    #[classattr]
    fn None() -> AzOptionHwndHandleEnumWrapper {
        AzOptionHwndHandleEnumWrapper { inner: AzOptionHwndHandle::None }
    }
    #[staticmethod]
    fn Some(v: *mut c_void) -> AzOptionHwndHandleEnumWrapper {
        AzOptionHwndHandleEnumWrapper { inner: AzOptionHwndHandle::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionHwndHandle;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionHwndHandle::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionHwndHandle::Some(v) => Ok(vec!["Some".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionHwndHandleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionHwndHandle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionHwndHandle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLogicalPositionEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLogicalPositionEnumWrapper {
        AzOptionLogicalPositionEnumWrapper { inner: AzOptionLogicalPosition::None }
    }
    #[staticmethod]
    fn Some(v: LogicalPosition) -> AzOptionLogicalPositionEnumWrapper {
        AzOptionLogicalPositionEnumWrapper { inner: AzOptionLogicalPosition::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionLogicalPosition;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLogicalPosition::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLogicalPosition::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLogicalPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::OptionLogicalPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::OptionLogicalPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionPhysicalPositionI32EnumWrapper {
    #[classattr]
    fn None() -> AzOptionPhysicalPositionI32EnumWrapper {
        AzOptionPhysicalPositionI32EnumWrapper { inner: AzOptionPhysicalPositionI32::None }
    }
    #[staticmethod]
    fn Some(v: PhysicalPositionI32) -> AzOptionPhysicalPositionI32EnumWrapper {
        AzOptionPhysicalPositionI32EnumWrapper { inner: AzOptionPhysicalPositionI32::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionPhysicalPositionI32;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionPhysicalPositionI32::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionPhysicalPositionI32::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionPhysicalPositionI32EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::OptionPhysicalPositionI32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::OptionPhysicalPositionI32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionWindowIconEnumWrapper {
    #[classattr]
    fn None() -> AzOptionWindowIconEnumWrapper {
        AzOptionWindowIconEnumWrapper { inner: AzOptionWindowIcon::None }
    }
    #[staticmethod]
    fn Some(v: WindowIcon) -> AzOptionWindowIconEnumWrapper {
        AzOptionWindowIconEnumWrapper { inner: AzOptionWindowIcon::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionWindowIcon;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionWindowIcon::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionWindowIcon::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionWindowIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWindowIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWindowIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionGlContextPtrEnumWrapper {
    #[classattr]
    fn None() -> AzOptionGlContextPtrEnumWrapper {
        AzOptionGlContextPtrEnumWrapper { inner: AzOptionGlContextPtr::None }
    }
    #[staticmethod]
    fn Some(v: GlContextPtr) -> AzOptionGlContextPtrEnumWrapper {
        AzOptionGlContextPtrEnumWrapper { inner: AzOptionGlContextPtr::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionGlContextPtr;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionGlContextPtr::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionGlContextPtr::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionGlContextPtrEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::OptionGlContextPtr = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::OptionGlContextPtr = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionX11VisualEnumWrapper {
    #[classattr]
    fn None() -> AzOptionX11VisualEnumWrapper {
        AzOptionX11VisualEnumWrapper { inner: AzOptionX11Visual::None }
    }
    #[staticmethod]
    fn Some(v: *const c_void) -> AzOptionX11VisualEnumWrapper {
        AzOptionX11VisualEnumWrapper { inner: AzOptionX11Visual::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionX11Visual;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionX11Visual::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionX11Visual::Some(v) => Ok(vec!["Some".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionX11VisualEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionX11Visual = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionX11Visual = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionI32EnumWrapper {
    #[classattr]
    fn None() -> AzOptionI32EnumWrapper {
        AzOptionI32EnumWrapper { inner: AzOptionI32::None }
    }
    #[staticmethod]
    fn Some(v: i32) -> AzOptionI32EnumWrapper {
        AzOptionI32EnumWrapper { inner: AzOptionI32::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionI32;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionI32::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionI32::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionI32EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionI32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionI32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionF32EnumWrapper {
    #[classattr]
    fn None() -> AzOptionF32EnumWrapper {
        AzOptionF32EnumWrapper { inner: AzOptionF32::None }
    }
    #[staticmethod]
    fn Some(v: f32) -> AzOptionF32EnumWrapper {
        AzOptionF32EnumWrapper { inner: AzOptionF32::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionF32;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionF32::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionF32::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionF32EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionF32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionF32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMouseCursorTypeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMouseCursorTypeEnumWrapper {
        AzOptionMouseCursorTypeEnumWrapper { inner: AzOptionMouseCursorType::None }
    }
    #[staticmethod]
    fn Some(v: MouseCursorType) -> AzOptionMouseCursorTypeEnumWrapper {
        AzOptionMouseCursorTypeEnumWrapper { inner: AzOptionMouseCursorType::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionMouseCursorType;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMouseCursorType::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMouseCursorType::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMouseCursorTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionMouseCursorType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionMouseCursorType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLogicalSizeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLogicalSizeEnumWrapper {
        AzOptionLogicalSizeEnumWrapper { inner: AzOptionLogicalSize::None }
    }
    #[staticmethod]
    fn Some(v: LogicalSize) -> AzOptionLogicalSizeEnumWrapper {
        AzOptionLogicalSizeEnumWrapper { inner: AzOptionLogicalSize::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionLogicalSize;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLogicalSize::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLogicalSize::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLogicalSizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::OptionLogicalSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::OptionLogicalSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionCharEnumWrapper {
    #[classattr]
    fn None() -> AzOptionCharEnumWrapper {
        AzOptionCharEnumWrapper { inner: AzOptionChar::None }
    }
    #[staticmethod]
    fn Some(v: u32) -> AzOptionCharEnumWrapper {
        AzOptionCharEnumWrapper { inner: AzOptionChar::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionChar;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionChar::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionChar::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionCharEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionChar = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionChar = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionVirtualKeyCodeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionVirtualKeyCodeEnumWrapper {
        AzOptionVirtualKeyCodeEnumWrapper { inner: AzOptionVirtualKeyCode::None }
    }
    #[staticmethod]
    fn Some(v: VirtualKeyCode) -> AzOptionVirtualKeyCodeEnumWrapper {
        AzOptionVirtualKeyCodeEnumWrapper { inner: AzOptionVirtualKeyCode::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionVirtualKeyCode;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionVirtualKeyCode::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionVirtualKeyCode::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionVirtualKeyCodeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionVirtualKeyCode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionVirtualKeyCode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionDomEnumWrapper {
    #[classattr]
    fn None() -> AzOptionDomEnumWrapper {
        AzOptionDomEnumWrapper { inner: AzOptionDom::None }
    }
    #[staticmethod]
    fn Some(v: Dom) -> AzOptionDomEnumWrapper {
        AzOptionDomEnumWrapper { inner: AzOptionDom::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionDom;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionDom::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionDom::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionDomEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::OptionDom = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::OptionDom = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextureEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextureEnumWrapper {
        AzOptionTextureEnumWrapper { inner: AzOptionTexture::None }
    }
    #[staticmethod]
    fn Some(v: Texture) -> AzOptionTextureEnumWrapper {
        AzOptionTextureEnumWrapper { inner: AzOptionTexture::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTexture;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTexture::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTexture::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextureEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::OptionTexture = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::OptionTexture = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionImageMaskEnumWrapper {
    #[classattr]
    fn None() -> AzOptionImageMaskEnumWrapper {
        AzOptionImageMaskEnumWrapper { inner: AzOptionImageMask::None }
    }
    #[staticmethod]
    fn Some(v: ImageMask) -> AzOptionImageMaskEnumWrapper {
        AzOptionImageMaskEnumWrapper { inner: AzOptionImageMask::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionImageMask;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionImageMask::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionImageMask::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionImageMaskEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::OptionImageMask = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::OptionImageMask = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTabIndexEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTabIndexEnumWrapper {
        AzOptionTabIndexEnumWrapper { inner: AzOptionTabIndex::None }
    }
    #[staticmethod]
    fn Some(v: TabIndex) -> AzOptionTabIndexEnumWrapper {
        AzOptionTabIndexEnumWrapper { inner: AzOptionTabIndex::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTabIndex;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTabIndex::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTabIndex::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTabIndexEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::OptionTabIndex = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::OptionTabIndex = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTagIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTagIdEnumWrapper {
        AzOptionTagIdEnumWrapper { inner: AzOptionTagId::None }
    }
    #[staticmethod]
    fn Some(v: AzTagId) -> AzOptionTagIdEnumWrapper {
        AzOptionTagIdEnumWrapper { inner: AzOptionTagId::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTagId;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTagId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTagId::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTagIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::OptionTagId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::OptionTagId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionDurationEnumWrapper {
    #[classattr]
    fn None() -> AzOptionDurationEnumWrapper {
        AzOptionDurationEnumWrapper { inner: AzOptionDuration::None }
    }
    #[staticmethod]
    fn Some(v: Duration) -> AzOptionDurationEnumWrapper {
        AzOptionDurationEnumWrapper { inner: AzOptionDuration::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionDuration;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionDuration::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionDuration::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionDurationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::OptionDuration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::OptionDuration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionInstantEnumWrapper {
    #[classattr]
    fn None() -> AzOptionInstantEnumWrapper {
        AzOptionInstantEnumWrapper { inner: AzOptionInstant::None }
    }
    #[staticmethod]
    fn Some(v: Instant) -> AzOptionInstantEnumWrapper {
        AzOptionInstantEnumWrapper { inner: AzOptionInstant::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionInstant;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionInstant::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionInstant::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionInstantEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::OptionInstant = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::OptionInstant = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionUsizeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionUsizeEnumWrapper {
        AzOptionUsizeEnumWrapper { inner: AzOptionUsize::None }
    }
    #[staticmethod]
    fn Some(v: usize) -> AzOptionUsizeEnumWrapper {
        AzOptionUsizeEnumWrapper { inner: AzOptionUsize::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionUsize;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionUsize::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionUsize::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionUsizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::OptionUsize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::OptionUsize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionU8VecEnumWrapper {
    #[classattr]
    fn None() -> AzOptionU8VecEnumWrapper {
        AzOptionU8VecEnumWrapper { inner: AzOptionU8Vec::None }
    }
    #[staticmethod]
    fn Some(v: U8Vec) -> AzOptionU8VecEnumWrapper {
        AzOptionU8VecEnumWrapper { inner: AzOptionU8Vec::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionU8Vec;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionU8Vec::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionU8Vec::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionU8VecEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::OptionU8Vec = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::OptionU8Vec = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionAzStringEnumWrapper {
    #[classattr]
    fn None() -> AzOptionAzStringEnumWrapper {
        AzOptionAzStringEnumWrapper { inner: AzOptionAzString::None }
    }
    #[staticmethod]
    fn Some(v: AzString) -> AzOptionAzStringEnumWrapper {
        AzOptionAzStringEnumWrapper { inner: AzOptionAzString::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionAzString;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionAzString::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionAzString::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionAzStringEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionAzString = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionAzString = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultXmlXmlErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: Xml) -> AzResultXmlXmlErrorEnumWrapper {
        AzResultXmlXmlErrorEnumWrapper { inner: AzResultXmlXmlError::Ok(v) }}
    }
    #[staticmethod]
    fn Err(v: XmlError) -> AzResultXmlXmlErrorEnumWrapper {
        AzResultXmlXmlErrorEnumWrapper { inner: AzResultXmlXmlError::Err(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzResultXmlXmlError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultXmlXmlError::Ok(v) => Ok(vec!["Ok".into_py(py), v.into_py(py)]),
            AzResultXmlXmlError::Err(v) => Ok(vec!["Err".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultXmlXmlErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::ResultXmlXmlError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::ResultXmlXmlError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultRawImageDecodeImageErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: RawImage) -> AzResultRawImageDecodeImageErrorEnumWrapper {
        AzResultRawImageDecodeImageErrorEnumWrapper { inner: AzResultRawImageDecodeImageError::Ok(v) }}
    }
    #[staticmethod]
    fn Err(v: DecodeImageError) -> AzResultRawImageDecodeImageErrorEnumWrapper {
        AzResultRawImageDecodeImageErrorEnumWrapper { inner: AzResultRawImageDecodeImageError::Err(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzResultRawImageDecodeImageError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultRawImageDecodeImageError::Ok(v) => Ok(vec!["Ok".into_py(py), v.into_py(py)]),
            AzResultRawImageDecodeImageError::Err(v) => Ok(vec!["Err".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultRawImageDecodeImageErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::image::decode::ResultRawImageDecodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::image::decode::ResultRawImageDecodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultU8VecEncodeImageErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: U8Vec) -> AzResultU8VecEncodeImageErrorEnumWrapper {
        AzResultU8VecEncodeImageErrorEnumWrapper { inner: AzResultU8VecEncodeImageError::Ok(v) }}
    }
    #[staticmethod]
    fn Err(v: EncodeImageError) -> AzResultU8VecEncodeImageErrorEnumWrapper {
        AzResultU8VecEncodeImageErrorEnumWrapper { inner: AzResultU8VecEncodeImageError::Err(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzResultU8VecEncodeImageError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultU8VecEncodeImageError::Ok(v) => Ok(vec!["Ok".into_py(py), v.into_py(py)]),
            AzResultU8VecEncodeImageError::Err(v) => Ok(vec!["Err".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultU8VecEncodeImageErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::image::encode::ResultU8VecEncodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::image::encode::ResultU8VecEncodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultSvgXmlNodeSvgParseErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: SvgXmlNode) -> AzResultSvgXmlNodeSvgParseErrorEnumWrapper {
        AzResultSvgXmlNodeSvgParseErrorEnumWrapper { inner: AzResultSvgXmlNodeSvgParseError::Ok(v) }}
    }
    #[staticmethod]
    fn Err(v: SvgParseError) -> AzResultSvgXmlNodeSvgParseErrorEnumWrapper {
        AzResultSvgXmlNodeSvgParseErrorEnumWrapper { inner: AzResultSvgXmlNodeSvgParseError::Err(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzResultSvgXmlNodeSvgParseError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultSvgXmlNodeSvgParseError::Ok(v) => Ok(vec!["Ok".into_py(py), v.into_py(py)]),
            AzResultSvgXmlNodeSvgParseError::Err(v) => Ok(vec!["Err".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultSvgXmlNodeSvgParseErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::ResultSvgXmlNodeSvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::ResultSvgXmlNodeSvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultSvgSvgParseErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: Svg) -> AzResultSvgSvgParseErrorEnumWrapper {
        AzResultSvgSvgParseErrorEnumWrapper { inner: AzResultSvgSvgParseError::Ok(v) }}
    }
    #[staticmethod]
    fn Err(v: SvgParseError) -> AzResultSvgSvgParseErrorEnumWrapper {
        AzResultSvgSvgParseErrorEnumWrapper { inner: AzResultSvgSvgParseError::Err(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzResultSvgSvgParseError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultSvgSvgParseError::Ok(v) => Ok(vec!["Ok".into_py(py), v.into_py(py)]),
            AzResultSvgSvgParseError::Err(v) => Ok(vec!["Err".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultSvgSvgParseErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::ResultSvgSvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::ResultSvgSvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgParseErrorEnumWrapper {
    #[classattr]
    fn NoParserAvailable() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::NoParserAvailable }
    }
    #[classattr]
    fn ElementsLimitReached() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::ElementsLimitReached }
    }
    #[classattr]
    fn NotAnUtf8Str() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::NotAnUtf8Str }
    }
    #[classattr]
    fn MalformedGZip() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::MalformedGZip }
    }
    #[classattr]
    fn InvalidSize() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::InvalidSize }
    }
    #[staticmethod]
    fn ParsingFailed(v: XmlError) -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::ParsingFailed(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgParseError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgParseError::NoParserAvailable => Ok(vec!["NoParserAvailable".into_py(py), ().into_py(py)]),
            AzSvgParseError::ElementsLimitReached => Ok(vec!["ElementsLimitReached".into_py(py), ().into_py(py)]),
            AzSvgParseError::NotAnUtf8Str => Ok(vec!["NotAnUtf8Str".into_py(py), ().into_py(py)]),
            AzSvgParseError::MalformedGZip => Ok(vec!["MalformedGZip".into_py(py), ().into_py(py)]),
            AzSvgParseError::InvalidSize => Ok(vec!["InvalidSize".into_py(py), ().into_py(py)]),
            AzSvgParseError::ParsingFailed(v) => Ok(vec!["ParsingFailed".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgParseErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::xml::svg::SvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::xml::svg::SvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlErrorEnumWrapper {
    #[classattr]
    fn NoParserAvailable() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::NoParserAvailable }
    }
    #[staticmethod]
    fn InvalidXmlPrefixUri(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidXmlPrefixUri(v) }}
    }
    #[staticmethod]
    fn UnexpectedXmlUri(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnexpectedXmlUri(v) }}
    }
    #[staticmethod]
    fn UnexpectedXmlnsUri(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnexpectedXmlnsUri(v) }}
    }
    #[staticmethod]
    fn InvalidElementNamePrefix(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidElementNamePrefix(v) }}
    }
    #[staticmethod]
    fn DuplicatedNamespace(v: DuplicatedNamespaceError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::DuplicatedNamespace(v) }}
    }
    #[staticmethod]
    fn UnknownNamespace(v: UnknownNamespaceError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnknownNamespace(v) }}
    }
    #[staticmethod]
    fn UnexpectedCloseTag(v: UnexpectedCloseTagError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnexpectedCloseTag(v) }}
    }
    #[staticmethod]
    fn UnexpectedEntityCloseTag(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnexpectedEntityCloseTag(v) }}
    }
    #[staticmethod]
    fn UnknownEntityReference(v: UnknownEntityReferenceError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnknownEntityReference(v) }}
    }
    #[staticmethod]
    fn MalformedEntityReference(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::MalformedEntityReference(v) }}
    }
    #[staticmethod]
    fn EntityReferenceLoop(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::EntityReferenceLoop(v) }}
    }
    #[staticmethod]
    fn InvalidAttributeValue(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidAttributeValue(v) }}
    }
    #[staticmethod]
    fn DuplicatedAttribute(v: DuplicatedAttributeError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::DuplicatedAttribute(v) }}
    }
    #[classattr]
    fn NoRootNode() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::NoRootNode }
    }
    #[classattr]
    fn SizeLimit() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::SizeLimit }
    }
    #[classattr]
    fn DtdDetected() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::DtdDetected }
    }
    #[staticmethod]
    #[staticmethod]
    fn ParserError(v: XmlParseError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::ParserError(v) }}
    }
    #[classattr]
    fn UnclosedRootNode() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnclosedRootNode }
    }
    #[staticmethod]
    fn UnexpectedDeclaration(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnexpectedDeclaration(v) }}
    }
    #[classattr]
    fn NodesLimitReached() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::NodesLimitReached }
    }
    #[classattr]
    fn AttributesLimitReached() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::AttributesLimitReached }
    }
    #[classattr]
    fn NamespacesLimitReached() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::NamespacesLimitReached }
    }
    #[staticmethod]
    fn InvalidName(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidName(v) }}
    }
    #[staticmethod]
    fn NonXmlChar(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::NonXmlChar(v) }}
    }
    #[staticmethod]
    fn InvalidChar(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidChar(v) }}
    }
    #[staticmethod]
    fn InvalidChar2(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidChar2(v) }}
    }
    #[staticmethod]
    fn InvalidString(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidString(v) }}
    }
    #[staticmethod]
    fn InvalidExternalID(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidExternalID(v) }}
    }
    #[staticmethod]
    fn InvalidComment(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidComment(v) }}
    }
    #[staticmethod]
    fn InvalidCharacterData(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidCharacterData(v) }}
    }
    #[staticmethod]
    fn UnknownToken(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnknownToken(v) }}
    }
    #[classattr]
    fn UnexpectedEndOfStream() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnexpectedEndOfStream }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzXmlError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlError::NoParserAvailable => Ok(vec!["NoParserAvailable".into_py(py), ().into_py(py)]),
            AzXmlError::InvalidXmlPrefixUri(v) => Ok(vec!["InvalidXmlPrefixUri".into_py(py), v.into_py(py)]),
            AzXmlError::UnexpectedXmlUri(v) => Ok(vec!["UnexpectedXmlUri".into_py(py), v.into_py(py)]),
            AzXmlError::UnexpectedXmlnsUri(v) => Ok(vec!["UnexpectedXmlnsUri".into_py(py), v.into_py(py)]),
            AzXmlError::InvalidElementNamePrefix(v) => Ok(vec!["InvalidElementNamePrefix".into_py(py), v.into_py(py)]),
            AzXmlError::DuplicatedNamespace(v) => Ok(vec!["DuplicatedNamespace".into_py(py), v.into_py(py)]),
            AzXmlError::UnknownNamespace(v) => Ok(vec!["UnknownNamespace".into_py(py), v.into_py(py)]),
            AzXmlError::UnexpectedCloseTag(v) => Ok(vec!["UnexpectedCloseTag".into_py(py), v.into_py(py)]),
            AzXmlError::UnexpectedEntityCloseTag(v) => Ok(vec!["UnexpectedEntityCloseTag".into_py(py), v.into_py(py)]),
            AzXmlError::UnknownEntityReference(v) => Ok(vec!["UnknownEntityReference".into_py(py), v.into_py(py)]),
            AzXmlError::MalformedEntityReference(v) => Ok(vec!["MalformedEntityReference".into_py(py), v.into_py(py)]),
            AzXmlError::EntityReferenceLoop(v) => Ok(vec!["EntityReferenceLoop".into_py(py), v.into_py(py)]),
            AzXmlError::InvalidAttributeValue(v) => Ok(vec!["InvalidAttributeValue".into_py(py), v.into_py(py)]),
            AzXmlError::DuplicatedAttribute(v) => Ok(vec!["DuplicatedAttribute".into_py(py), v.into_py(py)]),
            AzXmlError::NoRootNode => Ok(vec!["NoRootNode".into_py(py), ().into_py(py)]),
            AzXmlError::SizeLimit => Ok(vec!["SizeLimit".into_py(py), ().into_py(py)]),
            AzXmlError::DtdDetected => Ok(vec!["DtdDetected".into_py(py), ().into_py(py)]),
            AzXmlError::MalformedHierarchy(v) => Ok(vec!["MalformedHierarchy".into_py(py), v.into_py(py)]),
            AzXmlError::ParserError(v) => Ok(vec!["ParserError".into_py(py), v.into_py(py)]),
            AzXmlError::UnclosedRootNode => Ok(vec!["UnclosedRootNode".into_py(py), ().into_py(py)]),
            AzXmlError::UnexpectedDeclaration(v) => Ok(vec!["UnexpectedDeclaration".into_py(py), v.into_py(py)]),
            AzXmlError::NodesLimitReached => Ok(vec!["NodesLimitReached".into_py(py), ().into_py(py)]),
            AzXmlError::AttributesLimitReached => Ok(vec!["AttributesLimitReached".into_py(py), ().into_py(py)]),
            AzXmlError::NamespacesLimitReached => Ok(vec!["NamespacesLimitReached".into_py(py), ().into_py(py)]),
            AzXmlError::InvalidName(v) => Ok(vec!["InvalidName".into_py(py), v.into_py(py)]),
            AzXmlError::NonXmlChar(v) => Ok(vec!["NonXmlChar".into_py(py), v.into_py(py)]),
            AzXmlError::InvalidChar(v) => Ok(vec!["InvalidChar".into_py(py), v.into_py(py)]),
            AzXmlError::InvalidChar2(v) => Ok(vec!["InvalidChar2".into_py(py), v.into_py(py)]),
            AzXmlError::InvalidString(v) => Ok(vec!["InvalidString".into_py(py), v.into_py(py)]),
            AzXmlError::InvalidExternalID(v) => Ok(vec!["InvalidExternalID".into_py(py), v.into_py(py)]),
            AzXmlError::InvalidComment(v) => Ok(vec!["InvalidComment".into_py(py), v.into_py(py)]),
            AzXmlError::InvalidCharacterData(v) => Ok(vec!["InvalidCharacterData".into_py(py), v.into_py(py)]),
            AzXmlError::UnknownToken(v) => Ok(vec!["UnknownToken".into_py(py), v.into_py(py)]),
            AzXmlError::UnexpectedEndOfStream => Ok(vec!["UnexpectedEndOfStream".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDuplicatedNamespaceError {
}

#[pyproto]
impl PyObjectProtocol for AzDuplicatedNamespaceError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::DuplicatedNamespaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::DuplicatedNamespaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUnknownNamespaceError {
}

#[pyproto]
impl PyObjectProtocol for AzUnknownNamespaceError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::UnknownNamespaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::UnknownNamespaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUnexpectedCloseTagError {
}

#[pyproto]
impl PyObjectProtocol for AzUnexpectedCloseTagError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::UnexpectedCloseTagError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::UnexpectedCloseTagError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUnknownEntityReferenceError {
}

#[pyproto]
impl PyObjectProtocol for AzUnknownEntityReferenceError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::UnknownEntityReferenceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::UnknownEntityReferenceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDuplicatedAttributeError {
}

#[pyproto]
impl PyObjectProtocol for AzDuplicatedAttributeError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::DuplicatedAttributeError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::DuplicatedAttributeError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlParseErrorEnumWrapper {
    #[staticmethod]
    fn InvalidDeclaration(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidDeclaration(v) }}
    }
    #[staticmethod]
    fn InvalidComment(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidComment(v) }}
    }
    #[staticmethod]
    fn InvalidPI(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidPI(v) }}
    }
    #[staticmethod]
    fn InvalidDoctype(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidDoctype(v) }}
    }
    #[staticmethod]
    fn InvalidEntity(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidEntity(v) }}
    }
    #[staticmethod]
    fn InvalidElement(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidElement(v) }}
    }
    #[staticmethod]
    fn InvalidAttribute(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidAttribute(v) }}
    }
    #[staticmethod]
    fn InvalidCdata(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidCdata(v) }}
    }
    #[staticmethod]
    fn InvalidCharData(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidCharData(v) }}
    }
    #[staticmethod]
    fn UnknownToken(v: XmlTextPos) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::UnknownToken(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzXmlParseError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlParseError::InvalidDeclaration(v) => Ok(vec!["InvalidDeclaration".into_py(py), v.into_py(py)]),
            AzXmlParseError::InvalidComment(v) => Ok(vec!["InvalidComment".into_py(py), v.into_py(py)]),
            AzXmlParseError::InvalidPI(v) => Ok(vec!["InvalidPI".into_py(py), v.into_py(py)]),
            AzXmlParseError::InvalidDoctype(v) => Ok(vec!["InvalidDoctype".into_py(py), v.into_py(py)]),
            AzXmlParseError::InvalidEntity(v) => Ok(vec!["InvalidEntity".into_py(py), v.into_py(py)]),
            AzXmlParseError::InvalidElement(v) => Ok(vec!["InvalidElement".into_py(py), v.into_py(py)]),
            AzXmlParseError::InvalidAttribute(v) => Ok(vec!["InvalidAttribute".into_py(py), v.into_py(py)]),
            AzXmlParseError::InvalidCdata(v) => Ok(vec!["InvalidCdata".into_py(py), v.into_py(py)]),
            AzXmlParseError::InvalidCharData(v) => Ok(vec!["InvalidCharData".into_py(py), v.into_py(py)]),
            AzXmlParseError::UnknownToken(v) => Ok(vec!["UnknownToken".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlParseErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlTextError {
}

#[pyproto]
impl PyObjectProtocol for AzXmlTextError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlTextError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlTextError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlStreamErrorEnumWrapper {
    #[classattr]
    fn UnexpectedEndOfStream() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::UnexpectedEndOfStream }
    }
    #[classattr]
    fn InvalidName() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidName }
    }
    #[staticmethod]
    fn NonXmlChar(v: NonXmlCharError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::NonXmlChar(v) }}
    }
    #[staticmethod]
    fn InvalidChar(v: InvalidCharError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidChar(v) }}
    }
    #[staticmethod]
    fn InvalidCharMultiple(v: InvalidCharMultipleError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidCharMultiple(v) }}
    }
    #[staticmethod]
    fn InvalidQuote(v: InvalidQuoteError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidQuote(v) }}
    }
    #[staticmethod]
    fn InvalidSpace(v: InvalidSpaceError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidSpace(v) }}
    }
    #[staticmethod]
    fn InvalidString(v: InvalidStringError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidString(v) }}
    }
    #[classattr]
    fn InvalidReference() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidReference }
    }
    #[classattr]
    fn InvalidExternalID() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidExternalID }
    }
    #[classattr]
    fn InvalidCommentData() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidCommentData }
    }
    #[classattr]
    fn InvalidCommentEnd() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidCommentEnd }
    }
    #[classattr]
    fn InvalidCharacterData() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidCharacterData }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzXmlStreamError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlStreamError::UnexpectedEndOfStream => Ok(vec!["UnexpectedEndOfStream".into_py(py), ().into_py(py)]),
            AzXmlStreamError::InvalidName => Ok(vec!["InvalidName".into_py(py), ().into_py(py)]),
            AzXmlStreamError::NonXmlChar(v) => Ok(vec!["NonXmlChar".into_py(py), v.into_py(py)]),
            AzXmlStreamError::InvalidChar(v) => Ok(vec!["InvalidChar".into_py(py), v.into_py(py)]),
            AzXmlStreamError::InvalidCharMultiple(v) => Ok(vec!["InvalidCharMultiple".into_py(py), v.into_py(py)]),
            AzXmlStreamError::InvalidQuote(v) => Ok(vec!["InvalidQuote".into_py(py), v.into_py(py)]),
            AzXmlStreamError::InvalidSpace(v) => Ok(vec!["InvalidSpace".into_py(py), v.into_py(py)]),
            AzXmlStreamError::InvalidString(v) => Ok(vec!["InvalidString".into_py(py), v.into_py(py)]),
            AzXmlStreamError::InvalidReference => Ok(vec!["InvalidReference".into_py(py), ().into_py(py)]),
            AzXmlStreamError::InvalidExternalID => Ok(vec!["InvalidExternalID".into_py(py), ().into_py(py)]),
            AzXmlStreamError::InvalidCommentData => Ok(vec!["InvalidCommentData".into_py(py), ().into_py(py)]),
            AzXmlStreamError::InvalidCommentEnd => Ok(vec!["InvalidCommentEnd".into_py(py), ().into_py(py)]),
            AzXmlStreamError::InvalidCharacterData => Ok(vec!["InvalidCharacterData".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlStreamErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlStreamError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlStreamError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNonXmlCharError {
}

#[pyproto]
impl PyObjectProtocol for AzNonXmlCharError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::NonXmlCharError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::NonXmlCharError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidCharError {
}

#[pyproto]
impl PyObjectProtocol for AzInvalidCharError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidCharError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidCharError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidCharMultipleError {
}

#[pyproto]
impl PyObjectProtocol for AzInvalidCharMultipleError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidCharMultipleError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidCharMultipleError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidQuoteError {
}

#[pyproto]
impl PyObjectProtocol for AzInvalidQuoteError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidQuoteError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidQuoteError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidSpaceError {
}

#[pyproto]
impl PyObjectProtocol for AzInvalidSpaceError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidSpaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidSpaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidStringError {
}

#[pyproto]
impl PyObjectProtocol for AzInvalidStringError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidStringError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidStringError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlTextPos {
}

#[pyproto]
impl PyObjectProtocol for AzXmlTextPos {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlTextPos = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlTextPos = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzImageCache {
}

#[pyproto]
impl PyObjectProtocol for AzImageCache {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::ImageCache = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::ImageCache = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFontCache {
}

#[pyproto]
impl PyObjectProtocol for AzFontCache {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::FontCache = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::FontCache = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRawImageFormatEnumWrapper {
    #[classattr]
    const R8: AzRawImageFormat = AzRawImageFormat::R8;
    #[classattr]
    const RG8: AzRawImageFormat = AzRawImageFormat::RG8;
    #[classattr]
    const RGB8: AzRawImageFormat = AzRawImageFormat::RGB8;
    #[classattr]
    const RGBA8: AzRawImageFormat = AzRawImageFormat::RGBA8;
    #[classattr]
    const R16: AzRawImageFormat = AzRawImageFormat::R16;
    #[classattr]
    const RG16: AzRawImageFormat = AzRawImageFormat::RG16;
    #[classattr]
    const RGB16: AzRawImageFormat = AzRawImageFormat::RGB16;
    #[classattr]
    const RGBA16: AzRawImageFormat = AzRawImageFormat::RGBA16;
    #[classattr]
    const BGR8: AzRawImageFormat = AzRawImageFormat::BGR8;
    #[classattr]
    const BGRA8: AzRawImageFormat = AzRawImageFormat::BGRA8;
    #[classattr]
    const RGBF32: AzRawImageFormat = AzRawImageFormat::RGBF32;
    #[classattr]
    const RGBAF32: AzRawImageFormat = AzRawImageFormat::RGBAF32;
}

#[pyproto]
impl PyObjectProtocol for AzRawImageFormatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::RawImageFormat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::RawImageFormat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzRawImageFormatEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAppLogLevelEnumWrapper {
    #[classattr]
    const Off: AzAppLogLevel = AzAppLogLevel::Off;
    #[classattr]
    const Error: AzAppLogLevel = AzAppLogLevel::Error;
    #[classattr]
    const Warn: AzAppLogLevel = AzAppLogLevel::Warn;
    #[classattr]
    const Info: AzAppLogLevel = AzAppLogLevel::Info;
    #[classattr]
    const Debug: AzAppLogLevel = AzAppLogLevel::Debug;
    #[classattr]
    const Trace: AzAppLogLevel = AzAppLogLevel::Trace;
}

#[pyproto]
impl PyObjectProtocol for AzAppLogLevelEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::AppLogLevel = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::AppLogLevel = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAppLogLevelEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzRawImageDataEnumWrapper {
    #[staticmethod]
    fn U8(v: U8Vec) -> AzRawImageDataEnumWrapper {
        AzRawImageDataEnumWrapper { inner: AzRawImageData::U8(v) }}
    }
    #[staticmethod]
    fn U16(v: U16Vec) -> AzRawImageDataEnumWrapper {
        AzRawImageDataEnumWrapper { inner: AzRawImageData::U16(v) }}
    }
    #[staticmethod]
    fn F32(v: F32Vec) -> AzRawImageDataEnumWrapper {
        AzRawImageDataEnumWrapper { inner: AzRawImageData::F32(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzRawImageData;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzRawImageData::U8(v) => Ok(vec!["U8".into_py(py), v.into_py(py)]),
            AzRawImageData::U16(v) => Ok(vec!["U16".into_py(py), v.into_py(py)]),
            AzRawImageData::F32(v) => Ok(vec!["F32".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRawImageDataEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::RawImageData = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::RawImageData = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLoadedFontSource {
}

#[pyproto]
impl PyObjectProtocol for AzLoadedFontSource {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::LoadedFontSource = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::LoadedFontSource = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAppConfig {
}

#[pyproto]
impl PyObjectProtocol for AzAppConfig {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::AppConfig = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::AppConfig = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzImageMask {
}

#[pyproto]
impl PyObjectProtocol for AzImageMask {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::ImageMask = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::ImageMask = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzImageRef {
}

#[pyproto]
impl PyObjectProtocol for AzImageRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::ImageRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::ImageRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRawImage {
}

#[pyproto]
impl PyObjectProtocol for AzRawImage {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::RawImage = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::RawImage = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDpiScaleFactor {
}

#[pyproto]
impl PyObjectProtocol for AzDpiScaleFactor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::DpiScaleFactor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::DpiScaleFactor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAppTerminationBehaviorEnumWrapper {
    #[classattr]
    const ReturnToMain: AzAppTerminationBehavior = AzAppTerminationBehavior::ReturnToMain;
    #[classattr]
    const RunForever: AzAppTerminationBehavior = AzAppTerminationBehavior::RunForever;
    #[classattr]
    const EndProcess: AzAppTerminationBehavior = AzAppTerminationBehavior::EndProcess;
}

#[pyproto]
impl PyObjectProtocol for AzAppTerminationBehaviorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::AppTerminationBehavior = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::AppTerminationBehavior = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAppTerminationBehaviorEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

// Error type conversions
// Error type implementations would go here

#[pymodule]
fn azul(py: Python, m: &PyModule) -> PyResult<()> {

    #[cfg(all(feature = "use_pyo3_logger", not(feature = "use_fern_logger")))] {
        let mut filter = log::LevelFilter::Warn;

        if std::env::var("AZUL_PY_LOGLEVEL_ERROR").is_ok() { filter = log::LevelFilter::Error; }
        if std::env::var("AZUL_PY_LOGLEVEL_WARN").is_ok() { filter = log::LevelFilter::Warn; }
        if std::env::var("AZUL_PY_LOGLEVEL_INFO").is_ok() { filter = log::LevelFilter::Info; }
        if std::env::var("AZUL_PY_LOGLEVEL_DEBUG").is_ok() { filter = log::LevelFilter::Debug; }
        if std::env::var("AZUL_PY_LOGLEVEL_TRACE").is_ok() { filter = log::LevelFilter::Trace; }
        if std::env::var("AZUL_PY_LOGLEVEL_OFF").is_ok() { filter = log::LevelFilter::Off; }
    }

    m.add_class::<AzLayoutSolverVersionEnumWrapper>()?;
    m.add_class::<AzAppConfig>()?;
    m.add_class::<AzAppLogLevelEnumWrapper>()?;
    m.add_class::<AzAzAppPtr>()?;
    m.add_class::<AzExternalSystemCallbacks>()?;

    m.add_class::<AzWindowCreateOptions>()?;
    m.add_class::<AzRendererOptions>()?;
    m.add_class::<AzVsyncEnumWrapper>()?;
    m.add_class::<AzSrgbEnumWrapper>()?;
    m.add_class::<AzHwAccelerationEnumWrapper>()?;
    m.add_class::<AzLayoutPoint>()?;
    m.add_class::<AzLayoutSize>()?;
    m.add_class::<AzLayoutRect>()?;
    m.add_class::<AzRawWindowHandleEnumWrapper>()?;
    m.add_class::<AzIOSHandle>()?;
    m.add_class::<AzMacOSHandle>()?;
    m.add_class::<AzXlibHandle>()?;
    m.add_class::<AzXcbHandle>()?;
    m.add_class::<AzWaylandHandle>()?;
    m.add_class::<AzWindowsHandle>()?;
    m.add_class::<AzWebHandle>()?;
    m.add_class::<AzAndroidHandle>()?;
    m.add_class::<AzXWindowTypeEnumWrapper>()?;
    m.add_class::<AzPhysicalPositionI32>()?;
    m.add_class::<AzPhysicalSizeU32>()?;
    m.add_class::<AzLogicalRect>()?;
    m.add_class::<AzLogicalPosition>()?;
    m.add_class::<AzLogicalSize>()?;
    m.add_class::<AzIconKey>()?;
    m.add_class::<AzSmallWindowIconBytes>()?;
    m.add_class::<AzLargeWindowIconBytes>()?;
    m.add_class::<AzWindowIconEnumWrapper>()?;
    m.add_class::<AzTaskBarIcon>()?;
    m.add_class::<AzVirtualKeyCodeEnumWrapper>()?;
    m.add_class::<AzAcceleratorKeyEnumWrapper>()?;
    m.add_class::<AzWindowSize>()?;
    m.add_class::<AzWindowFlags>()?;
    m.add_class::<AzWindowFrameEnumWrapper>()?;
    m.add_class::<AzDebugState>()?;
    m.add_class::<AzKeyboardState>()?;
    m.add_class::<AzMouseCursorTypeEnumWrapper>()?;
    m.add_class::<AzCursorPositionEnumWrapper>()?;
    m.add_class::<AzMouseState>()?;
    m.add_class::<AzPlatformSpecificOptions>()?;
    m.add_class::<AzWindowsWindowOptions>()?;
    m.add_class::<AzWaylandTheme>()?;
    m.add_class::<AzRendererTypeEnumWrapper>()?;
    m.add_class::<AzWindowState>()?;
    m.add_class::<AzLinuxWindowOptions>()?;
    m.add_class::<AzMacWindowOptions>()?;
    m.add_class::<AzWasmWindowOptions>()?;
    m.add_class::<AzFullScreenModeEnumWrapper>()?;
    m.add_class::<AzWindowThemeEnumWrapper>()?;
    m.add_class::<AzWindowPositionEnumWrapper>()?;
    m.add_class::<AzImePositionEnumWrapper>()?;
    m.add_class::<AzTouchState>()?;
    m.add_class::<AzMonitor>()?;
    m.add_class::<AzVideoMode>()?;
    m.add_class::<AzAzStringPair>()?;
    m.add_class::<AzSystemCallbacks>()?;
    m.add_class::<AzUserAttentionTypeEnumWrapper>()?;
    m.add_class::<AzWindowDecorationsEnumWrapper>()?;
    m.add_class::<AzWindowBackgroundMaterialEnumWrapper>()?;
    m.add_class::<AzMonitorId>()?;
    m.add_class::<AzWindowTypeEnumWrapper>()?;

    m.add_class::<AzLayoutCallbackEnumWrapper>()?;
    m.add_class::<AzMarshaledLayoutCallback>()?;
    m.add_class::<AzMarshaledLayoutCallbackInner>()?;
    m.add_class::<AzLayoutCallbackInner>()?;
    m.add_class::<AzCallback>()?;
    m.add_class::<AzCallbackInfo>()?;
    m.add_class::<AzUpdateImageTypeEnumWrapper>()?;
    m.add_class::<AzUpdateEnumWrapper>()?;
    m.add_class::<AzLayoutCallbackInfo>()?;
    m.add_class::<AzDomId>()?;
    m.add_class::<AzDomNodeId>()?;
    m.add_class::<AzPositionInfoEnumWrapper>()?;
    m.add_class::<AzPositionInfoInner>()?;
    m.add_class::<AzHidpiAdjustedBounds>()?;
    m.add_class::<AzInlineText>()?;
    m.add_class::<AzInlineLine>()?;
    m.add_class::<AzInlineWordEnumWrapper>()?;
    m.add_class::<AzInlineTextContents>()?;
    m.add_class::<AzInlineGlyph>()?;
    m.add_class::<AzInlineTextHit>()?;
    m.add_class::<AzFocusTargetEnumWrapper>()?;
    m.add_class::<AzFocusTargetPath>()?;
    m.add_class::<AzScriptTypeEnumWrapper>()?;
    m.add_class::<AzResolvedTextLayoutOptions>()?;
    m.add_class::<AzAnimation>()?;
    m.add_class::<AzAnimationRepeatEnumWrapper>()?;
    m.add_class::<AzAnimationRepeatCountEnumWrapper>()?;
    m.add_class::<AzNodeHierarchyItemId>()?;
    m.add_class::<AzIFrameCallback>()?;
    m.add_class::<AzIFrameCallbackInfo>()?;
    m.add_class::<AzIFrameCallbackReturn>()?;
    m.add_class::<AzRenderImageCallback>()?;
    m.add_class::<AzRenderImageCallbackInfo>()?;
    m.add_class::<AzTimerCallback>()?;
    m.add_class::<AzTimerCallbackInfo>()?;
    m.add_class::<AzTimerCallbackReturn>()?;
    m.add_class::<AzWriteBackCallback>()?;
    m.add_class::<AzThreadCallback>()?;
    m.add_class::<AzRefCount>()?;
    m.add_class::<AzRefAny>()?;
    m.add_class::<AzEdgeTypeEnumWrapper>()?;
    m.add_class::<AzExternalSystemCallbacks>()?;
    m.add_class::<AzMenuCallback>()?;
    m.add_class::<AzIFrameCallbackReasonEnumWrapper>()?;

    m.add_class::<AzDom>()?;
    m.add_class::<AzIFrameNode>()?;
    m.add_class::<AzCallbackData>()?;
    m.add_class::<AzNodeData>()?;
    m.add_class::<AzNodeTypeEnumWrapper>()?;
    m.add_class::<AzOnEnumWrapper>()?;
    m.add_class::<AzEventFilterEnumWrapper>()?;
    m.add_class::<AzHoverEventFilterEnumWrapper>()?;
    m.add_class::<AzFocusEventFilterEnumWrapper>()?;
    m.add_class::<AzNotEventFilterEnumWrapper>()?;
    m.add_class::<AzWindowEventFilterEnumWrapper>()?;
    m.add_class::<AzComponentEventFilterEnumWrapper>()?;
    m.add_class::<AzApplicationEventFilterEnumWrapper>()?;
    m.add_class::<AzAccessibilityInfo>()?;
    m.add_class::<AzAccessibilityRoleEnumWrapper>()?;
    m.add_class::<AzAccessibilityStateEnumWrapper>()?;
    m.add_class::<AzTabIndexEnumWrapper>()?;
    m.add_class::<AzIdOrClassEnumWrapper>()?;
    m.add_class::<AzNodeDataInlineCssPropertyEnumWrapper>()?;
    m.add_class::<AzDomId>()?;
    m.add_class::<AzDomNodeId>()?;

    m.add_class::<AzMenu>()?;
    m.add_class::<AzContextMenuMouseButtonEnumWrapper>()?;
    m.add_class::<AzMenuPopupPositionEnumWrapper>()?;
    m.add_class::<AzMenuItemEnumWrapper>()?;
    m.add_class::<AzStringMenuItem>()?;
    m.add_class::<AzVirtualKeyCodeCombo>()?;
    m.add_class::<AzMenuCallback>()?;
    m.add_class::<AzMenuItemIconEnumWrapper>()?;
    m.add_class::<AzMenuItemStateEnumWrapper>()?;

    m.add_class::<AzCssRuleBlock>()?;
    m.add_class::<AzCssPath>()?;
    m.add_class::<AzCssPathSelectorEnumWrapper>()?;
    m.add_class::<AzCssPropertyEnumWrapper>()?;
    m.add_class::<AzCssPathPseudoSelectorEnumWrapper>()?;
    m.add_class::<AzCssNthChildSelectorEnumWrapper>()?;
    m.add_class::<AzCssNthChildPattern>()?;
    m.add_class::<AzStylesheet>()?;
    m.add_class::<AzCss>()?;
    m.add_class::<AzCssDeclarationEnumWrapper>()?;
    m.add_class::<AzDynamicCssProperty>()?;
    m.add_class::<AzCssPropertyTypeEnumWrapper>()?;
    m.add_class::<AzAnimationInterpolationFunctionEnumWrapper>()?;
    m.add_class::<AzNodeTypeTagEnumWrapper>()?;
    m.add_class::<AzColorU>()?;
    m.add_class::<AzSizeMetricEnumWrapper>()?;
    m.add_class::<AzPixelValue>()?;
    m.add_class::<AzPixelValueNoPercent>()?;
    m.add_class::<AzBoxShadowClipModeEnumWrapper>()?;
    m.add_class::<AzStyleBoxShadow>()?;
    m.add_class::<AzStyleMixBlendModeEnumWrapper>()?;
    m.add_class::<AzStyleFilterEnumWrapper>()?;
    m.add_class::<AzStyleBlur>()?;
    m.add_class::<AzStyleColorMatrix>()?;
    m.add_class::<AzStyleFilterOffset>()?;
    m.add_class::<AzStyleCompositeFilterEnumWrapper>()?;
    m.add_class::<AzLayoutAlignContentEnumWrapper>()?;
    m.add_class::<AzLayoutAlignItemsEnumWrapper>()?;
    m.add_class::<AzLayoutBottom>()?;
    m.add_class::<AzLayoutBoxSizingEnumWrapper>()?;
    m.add_class::<AzLayoutFlexDirectionEnumWrapper>()?;
    m.add_class::<AzLayoutDisplayEnumWrapper>()?;
    m.add_class::<AzLayoutFlexGrow>()?;
    m.add_class::<AzLayoutFlexShrink>()?;
    m.add_class::<AzLayoutFloatEnumWrapper>()?;
    m.add_class::<AzLayoutHeight>()?;
    m.add_class::<AzLayoutJustifyContentEnumWrapper>()?;
    m.add_class::<AzLayoutLeft>()?;
    m.add_class::<AzLayoutMarginBottom>()?;
    m.add_class::<AzLayoutMarginLeft>()?;
    m.add_class::<AzLayoutMarginRight>()?;
    m.add_class::<AzLayoutMarginTop>()?;
    m.add_class::<AzLayoutMaxHeight>()?;
    m.add_class::<AzLayoutMaxWidth>()?;
    m.add_class::<AzLayoutMinHeight>()?;
    m.add_class::<AzLayoutMinWidth>()?;
    m.add_class::<AzLayoutPaddingBottom>()?;
    m.add_class::<AzLayoutPaddingLeft>()?;
    m.add_class::<AzLayoutPaddingRight>()?;
    m.add_class::<AzLayoutPaddingTop>()?;
    m.add_class::<AzLayoutPositionEnumWrapper>()?;
    m.add_class::<AzLayoutRight>()?;
    m.add_class::<AzLayoutTop>()?;
    m.add_class::<AzLayoutWidth>()?;
    m.add_class::<AzLayoutFlexWrapEnumWrapper>()?;
    m.add_class::<AzLayoutOverflowEnumWrapper>()?;
    m.add_class::<AzFloatValue>()?;
    m.add_class::<AzPercentageValue>()?;
    m.add_class::<AzAngleMetricEnumWrapper>()?;
    m.add_class::<AzAngleValue>()?;
    m.add_class::<AzNormalizedLinearColorStop>()?;
    m.add_class::<AzNormalizedRadialColorStop>()?;
    m.add_class::<AzDirectionCornerEnumWrapper>()?;
    m.add_class::<AzDirectionCorners>()?;
    m.add_class::<AzDirectionEnumWrapper>()?;
    m.add_class::<AzExtendModeEnumWrapper>()?;
    m.add_class::<AzLinearGradient>()?;
    m.add_class::<AzShapeEnumWrapper>()?;
    m.add_class::<AzRadialGradientSizeEnumWrapper>()?;
    m.add_class::<AzRadialGradient>()?;
    m.add_class::<AzConicGradient>()?;
    m.add_class::<AzStyleBackgroundContentEnumWrapper>()?;
    m.add_class::<AzBackgroundPositionHorizontalEnumWrapper>()?;
    m.add_class::<AzBackgroundPositionVerticalEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundPosition>()?;
    m.add_class::<AzStyleBackgroundRepeatEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundSizeEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomColor>()?;
    m.add_class::<AzStyleBorderBottomLeftRadius>()?;
    m.add_class::<AzStyleBorderBottomRightRadius>()?;
    m.add_class::<AzBorderStyleEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomStyle>()?;
    m.add_class::<AzLayoutBorderBottomWidth>()?;
    m.add_class::<AzStyleBorderLeftColor>()?;
    m.add_class::<AzStyleBorderLeftStyle>()?;
    m.add_class::<AzLayoutBorderLeftWidth>()?;
    m.add_class::<AzStyleBorderRightColor>()?;
    m.add_class::<AzStyleBorderRightStyle>()?;
    m.add_class::<AzLayoutBorderRightWidth>()?;
    m.add_class::<AzStyleBorderTopColor>()?;
    m.add_class::<AzStyleBorderTopLeftRadius>()?;
    m.add_class::<AzStyleBorderTopRightRadius>()?;
    m.add_class::<AzStyleBorderTopStyle>()?;
    m.add_class::<AzLayoutBorderTopWidth>()?;
    m.add_class::<AzScrollbarInfo>()?;
    m.add_class::<AzScrollbarStyle>()?;
    m.add_class::<AzStyleCursorEnumWrapper>()?;
    m.add_class::<AzStyleFontFamilyEnumWrapper>()?;
    m.add_class::<AzStyleFontSize>()?;
    m.add_class::<AzStyleLetterSpacing>()?;
    m.add_class::<AzStyleLineHeight>()?;
    m.add_class::<AzStyleTabWidth>()?;
    m.add_class::<AzStyleOpacity>()?;
    m.add_class::<AzStyleTransformOrigin>()?;
    m.add_class::<AzInterpolateResolver>()?;
    m.add_class::<AzStyleBackfaceVisibilityEnumWrapper>()?;
    m.add_class::<AzStyleTransformEnumWrapper>()?;
    m.add_class::<AzStyleTransformMatrix2D>()?;
    m.add_class::<AzStyleTransformMatrix3D>()?;
    m.add_class::<AzStyleTransformTranslate2D>()?;
    m.add_class::<AzStyleTransformTranslate3D>()?;
    m.add_class::<AzStyleTransformRotate3D>()?;
    m.add_class::<AzStyleTransformScale2D>()?;
    m.add_class::<AzStyleTransformScale3D>()?;
    m.add_class::<AzStyleTransformSkew2D>()?;
    m.add_class::<AzStyleTextAlignEnumWrapper>()?;
    m.add_class::<AzStyleTextColor>()?;
    m.add_class::<AzStyleWordSpacing>()?;
    m.add_class::<AzStyleBoxShadowValueEnumWrapper>()?;
    m.add_class::<AzLayoutAlignContentValueEnumWrapper>()?;
    m.add_class::<AzLayoutAlignItemsValueEnumWrapper>()?;
    m.add_class::<AzLayoutBottomValueEnumWrapper>()?;
    m.add_class::<AzLayoutBoxSizingValueEnumWrapper>()?;
    m.add_class::<AzLayoutFlexDirectionValueEnumWrapper>()?;
    m.add_class::<AzLayoutDisplayValueEnumWrapper>()?;
    m.add_class::<AzLayoutFlexGrowValueEnumWrapper>()?;
    m.add_class::<AzLayoutFlexShrinkValueEnumWrapper>()?;
    m.add_class::<AzLayoutFloatValueEnumWrapper>()?;
    m.add_class::<AzLayoutHeightValueEnumWrapper>()?;
    m.add_class::<AzLayoutJustifyContentValueEnumWrapper>()?;
    m.add_class::<AzLayoutLeftValueEnumWrapper>()?;
    m.add_class::<AzLayoutMarginBottomValueEnumWrapper>()?;
    m.add_class::<AzLayoutMarginLeftValueEnumWrapper>()?;
    m.add_class::<AzLayoutMarginRightValueEnumWrapper>()?;
    m.add_class::<AzLayoutMarginTopValueEnumWrapper>()?;
    m.add_class::<AzLayoutMaxHeightValueEnumWrapper>()?;
    m.add_class::<AzLayoutMaxWidthValueEnumWrapper>()?;
    m.add_class::<AzLayoutMinHeightValueEnumWrapper>()?;
    m.add_class::<AzLayoutMinWidthValueEnumWrapper>()?;
    m.add_class::<AzLayoutPaddingBottomValueEnumWrapper>()?;
    m.add_class::<AzLayoutPaddingLeftValueEnumWrapper>()?;
    m.add_class::<AzLayoutPaddingRightValueEnumWrapper>()?;
    m.add_class::<AzLayoutPaddingTopValueEnumWrapper>()?;
    m.add_class::<AzLayoutPositionValueEnumWrapper>()?;
    m.add_class::<AzLayoutRightValueEnumWrapper>()?;
    m.add_class::<AzLayoutTopValueEnumWrapper>()?;
    m.add_class::<AzLayoutWidthValueEnumWrapper>()?;
    m.add_class::<AzLayoutFlexWrapValueEnumWrapper>()?;
    m.add_class::<AzLayoutOverflowValueEnumWrapper>()?;
    m.add_class::<AzScrollbarStyleValueEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundContentVecValueEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundPositionVecValueEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundRepeatVecValueEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundSizeVecValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomColorValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomLeftRadiusValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomRightRadiusValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomStyleValueEnumWrapper>()?;
    m.add_class::<AzLayoutBorderBottomWidthValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderLeftColorValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderLeftStyleValueEnumWrapper>()?;
    m.add_class::<AzLayoutBorderLeftWidthValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderRightColorValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderRightStyleValueEnumWrapper>()?;
    m.add_class::<AzLayoutBorderRightWidthValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderTopColorValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderTopLeftRadiusValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderTopRightRadiusValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderTopStyleValueEnumWrapper>()?;
    m.add_class::<AzLayoutBorderTopWidthValueEnumWrapper>()?;
    m.add_class::<AzStyleCursorValueEnumWrapper>()?;
    m.add_class::<AzStyleFontFamilyVecValueEnumWrapper>()?;
    m.add_class::<AzStyleFontSizeValueEnumWrapper>()?;
    m.add_class::<AzStyleLetterSpacingValueEnumWrapper>()?;
    m.add_class::<AzStyleLineHeightValueEnumWrapper>()?;
    m.add_class::<AzStyleTabWidthValueEnumWrapper>()?;
    m.add_class::<AzStyleTextAlignValueEnumWrapper>()?;
    m.add_class::<AzStyleTextColorValueEnumWrapper>()?;
    m.add_class::<AzStyleWordSpacingValueEnumWrapper>()?;
    m.add_class::<AzStyleOpacityValueEnumWrapper>()?;
    m.add_class::<AzStyleTransformVecValueEnumWrapper>()?;
    m.add_class::<AzStyleTransformOriginValueEnumWrapper>()?;
    m.add_class::<AzStylePerspectiveOriginValueEnumWrapper>()?;
    m.add_class::<AzStyleBackfaceVisibilityValueEnumWrapper>()?;
    m.add_class::<AzStyleMixBlendModeValueEnumWrapper>()?;
    m.add_class::<AzStyleFilterVecValueEnumWrapper>()?;
    m.add_class::<AzCssPropertyValueEnumWrapper>()?;
    m.add_class::<AzCounterReset>()?;
    m.add_class::<AzGridLineEnumWrapper>()?;
    m.add_class::<AzStylePerspectiveOrigin>()?;
    m.add_class::<AzLayoutZIndexEnumWrapper>()?;
    m.add_class::<AzLayoutJustifyItemsEnumWrapper>()?;
    m.add_class::<AzSelectionBackgroundColor>()?;
    m.add_class::<AzColumnRuleColor>()?;
    m.add_class::<AzFontRef>()?;
    m.add_class::<AzPlatformEnumWrapper>()?;
    m.add_class::<AzColumnSpanEnumWrapper>()?;
    m.add_class::<AzLayoutClearEnumWrapper>()?;
    m.add_class::<AzLayoutPoint>()?;
    m.add_class::<AzStyleWhiteSpaceEnumWrapper>()?;
    m.add_class::<AzSystemMetrics>()?;
    m.add_class::<AzSystemStyle>()?;
    m.add_class::<AzFontMetrics>()?;
    m.add_class::<AzBreakInsideEnumWrapper>()?;
    m.add_class::<AzLayoutAlignSelfEnumWrapper>()?;
    m.add_class::<AzCaretAnimationDuration>()?;
    m.add_class::<AzColumnRuleStyle>()?;
    m.add_class::<AzSvgPoint>()?;
    m.add_class::<AzGridPlacement>()?;
    m.add_class::<AzStringSet>()?;
    m.add_class::<AzShapeOutsideEnumWrapper>()?;
    m.add_class::<AzSvgVector>()?;
    m.add_class::<AzDesktopEnvironmentEnumWrapper>()?;
    m.add_class::<AzColumnCountEnumWrapper>()?;
    m.add_class::<AzLayoutWritingModeEnumWrapper>()?;
    m.add_class::<AzSvgRect>()?;
    m.add_class::<AzSystemColors>()?;
    m.add_class::<AzLayoutRect>()?;
    m.add_class::<AzStyleUserSelectEnumWrapper>()?;
    m.add_class::<AzFlowIntoEnumWrapper>()?;
    m.add_class::<AzGridTemplate>()?;
    m.add_class::<AzLayoutJustifySelfEnumWrapper>()?;
    m.add_class::<AzContent>()?;
    m.add_class::<AzStyleHyphensEnumWrapper>()?;
    m.add_class::<AzLayoutGap>()?;
    m.add_class::<AzStyleDirectionEnumWrapper>()?;
    m.add_class::<AzLayoutFlexBasisEnumWrapper>()?;
    m.add_class::<AzShapeMargin>()?;
    m.add_class::<AzLayoutTextJustifyEnumWrapper>()?;
    m.add_class::<AzColumnWidthEnumWrapper>()?;
    m.add_class::<AzCounterIncrement>()?;
    m.add_class::<AzBoxDecorationBreakEnumWrapper>()?;
    m.add_class::<AzSvgCubicCurve>()?;
    m.add_class::<AzSvgQuadraticCurve>()?;
    m.add_class::<AzSelectionColor>()?;
    m.add_class::<AzStyleVisibilityEnumWrapper>()?;
    m.add_class::<AzThemeEnumWrapper>()?;
    m.add_class::<AzShapeImageThreshold>()?;
    m.add_class::<AzLayoutGridAutoFlowEnumWrapper>()?;
    m.add_class::<AzColumnRuleWidth>()?;
    m.add_class::<AzAzString>()?;
    m.add_class::<AzStyleTextDecorationEnumWrapper>()?;
    m.add_class::<AzCaretColor>()?;
    m.add_class::<AzLayoutSize>()?;
    m.add_class::<AzColumnFillEnumWrapper>()?;
    m.add_class::<AzSystemFonts>()?;
    m.add_class::<AzFlowFromEnumWrapper>()?;
    m.add_class::<AzPageBreakEnumWrapper>()?;
    m.add_class::<AzLayoutScrollbarWidthEnumWrapper>()?;
    m.add_class::<AzStyleScrollbarColorEnumWrapper>()?;

    m.add_class::<AzRibbon>()?;
    m.add_class::<AzRibbonOnTabClickedCallback>()?;
    m.add_class::<AzButton>()?;
    m.add_class::<AzButtonOnClick>()?;
    m.add_class::<AzFileInput>()?;
    m.add_class::<AzFileInputStateWrapper>()?;
    m.add_class::<AzFileInputState>()?;
    m.add_class::<AzFileInputOnPathChange>()?;
    m.add_class::<AzFileInputOnPathChangeCallback>()?;
    m.add_class::<AzCheckBox>()?;
    m.add_class::<AzCheckBoxStateWrapper>()?;
    m.add_class::<AzCheckBoxOnToggle>()?;
    m.add_class::<AzCheckBoxOnToggleCallback>()?;
    m.add_class::<AzCheckBoxState>()?;
    m.add_class::<AzLabel>()?;
    m.add_class::<AzColorInput>()?;
    m.add_class::<AzColorInputStateWrapper>()?;
    m.add_class::<AzColorInputState>()?;
    m.add_class::<AzColorInputOnValueChange>()?;
    m.add_class::<AzColorInputOnValueChangeCallback>()?;
    m.add_class::<AzTextInput>()?;
    m.add_class::<AzTextInputStateWrapper>()?;
    m.add_class::<AzTextInputState>()?;
    m.add_class::<AzTextInputSelectionEnumWrapper>()?;
    m.add_class::<AzTextInputSelectionRange>()?;
    m.add_class::<AzTextInputOnTextInput>()?;
    m.add_class::<AzTextInputOnTextInputCallback>()?;
    m.add_class::<AzTextInputOnVirtualKeyDown>()?;
    m.add_class::<AzTextInputOnVirtualKeyDownCallback>()?;
    m.add_class::<AzTextInputOnFocusLost>()?;
    m.add_class::<AzTextInputOnFocusLostCallback>()?;
    m.add_class::<AzOnTextInputReturn>()?;
    m.add_class::<AzTextInputValidEnumWrapper>()?;
    m.add_class::<AzNumberInput>()?;
    m.add_class::<AzNumberInputStateWrapper>()?;
    m.add_class::<AzNumberInputState>()?;
    m.add_class::<AzNumberInputOnValueChange>()?;
    m.add_class::<AzNumberInputOnValueChangeCallback>()?;
    m.add_class::<AzNumberInputOnFocusLost>()?;
    m.add_class::<AzNumberInputOnFocusLostCallback>()?;
    m.add_class::<AzProgressBar>()?;
    m.add_class::<AzProgressBarState>()?;
    m.add_class::<AzTabHeader>()?;
    m.add_class::<AzTabHeaderState>()?;
    m.add_class::<AzTabContent>()?;
    m.add_class::<AzTabOnClick>()?;
    m.add_class::<AzTabOnClickCallback>()?;
    m.add_class::<AzFrame>()?;
    m.add_class::<AzNodeGraph>()?;
    m.add_class::<AzNodeTypeIdInfoMap>()?;
    m.add_class::<AzInputOutputTypeIdInfoMap>()?;
    m.add_class::<AzNodeIdNodeMap>()?;
    m.add_class::<AzNodeGraphStyleEnumWrapper>()?;
    m.add_class::<AzNodeGraphCallbacks>()?;
    m.add_class::<AzDropDownOnChoiceChange>()?;
    m.add_class::<AzOnNodeAddedCallback>()?;
    m.add_class::<AzOnNodeAdded>()?;
    m.add_class::<AzOnNodeRemovedCallback>()?;
    m.add_class::<AzOnNodeRemoved>()?;
    m.add_class::<AzOnNodeGraphDraggedCallback>()?;
    m.add_class::<AzOnNodeGraphDragged>()?;
    m.add_class::<AzOnNodeDraggedCallback>()?;
    m.add_class::<AzOnNodeDragged>()?;
    m.add_class::<AzOnNodeConnectedCallback>()?;
    m.add_class::<AzOnNodeConnected>()?;
    m.add_class::<AzOnNodeInputDisconnectedCallback>()?;
    m.add_class::<AzOnNodeInputDisconnected>()?;
    m.add_class::<AzOnNodeOutputDisconnectedCallback>()?;
    m.add_class::<AzOnNodeOutputDisconnected>()?;
    m.add_class::<AzOnNodeFieldEditedCallback>()?;
    m.add_class::<AzInputOutputTypeId>()?;
    m.add_class::<AzNodeTypeId>()?;
    m.add_class::<AzNodeGraphNodeId>()?;
    m.add_class::<AzNode>()?;
    m.add_class::<AzNodeTypeField>()?;
    m.add_class::<AzNodeTypeFieldValueEnumWrapper>()?;
    m.add_class::<AzInputConnection>()?;
    m.add_class::<AzOutputNodeAndIndex>()?;
    m.add_class::<AzOutputConnection>()?;
    m.add_class::<AzInputNodeAndIndex>()?;
    m.add_class::<AzNodeTypeInfo>()?;
    m.add_class::<AzInputOutputInfo>()?;
    m.add_class::<AzNodePosition>()?;
    m.add_class::<AzGraphDragAmount>()?;
    m.add_class::<AzNodeDragAmount>()?;
    m.add_class::<AzListView>()?;
    m.add_class::<AzListViewRow>()?;
    m.add_class::<AzListViewState>()?;
    m.add_class::<AzListViewOnLazyLoadScrollCallback>()?;
    m.add_class::<AzListViewOnLazyLoadScroll>()?;
    m.add_class::<AzListViewOnColumnClickCallback>()?;
    m.add_class::<AzListViewOnColumnClick>()?;
    m.add_class::<AzListViewOnRowClickCallback>()?;
    m.add_class::<AzListViewOnRowClick>()?;
    m.add_class::<AzTreeView>()?;
    m.add_class::<AzDropDown>()?;
    m.add_class::<AzDropDownOnChoiceChangeCallback>()?;
    m.add_class::<AzOnNodeFieldEdited>()?;

    m.add_class::<AzNodeHierarchyItem>()?;
    m.add_class::<AzCascadeInfo>()?;
    m.add_class::<AzCssPropertySourceEnumWrapper>()?;
    m.add_class::<AzStyledNodeState>()?;
    m.add_class::<AzStyledNode>()?;
    m.add_class::<AzStyledDom>()?;
    m.add_class::<AzTagIdToNodeIdMapping>()?;
    m.add_class::<AzParentWithNodeDepth>()?;
    m.add_class::<AzAzTagId>()?;
    m.add_class::<AzCssPropertyCachePtr>()?;

    m.add_class::<AzTexture>()?;
    m.add_class::<AzGlVoidPtrConst>()?;
    m.add_class::<AzGlVoidPtrMut>()?;
    m.add_class::<AzTextureFlags>()?;
    m.add_class::<AzGlShaderPrecisionFormatReturn>()?;
    m.add_class::<AzVertexAttributeTypeEnumWrapper>()?;
    m.add_class::<AzVertexAttribute>()?;
    m.add_class::<AzVertexLayout>()?;
    m.add_class::<AzVertexArrayObject>()?;
    m.add_class::<AzIndexBufferFormatEnumWrapper>()?;
    m.add_class::<AzVertexBuffer>()?;
    m.add_class::<AzGlContextPtr>()?;
    m.add_class::<AzAzGlTypeEnumWrapper>()?;
    m.add_class::<AzU8VecRef>()?;
    m.add_class::<AzU8VecRefMut>()?;
    m.add_class::<AzF32VecRef>()?;
    m.add_class::<AzI32VecRef>()?;
    m.add_class::<AzGLuintVecRef>()?;
    m.add_class::<AzGLenumVecRef>()?;
    m.add_class::<AzGLintVecRefMut>()?;
    m.add_class::<AzGLint64VecRefMut>()?;
    m.add_class::<AzGLbooleanVecRefMut>()?;
    m.add_class::<AzGLfloatVecRefMut>()?;
    m.add_class::<AzRefstrVecRef>()?;
    m.add_class::<AzRefstr>()?;
    m.add_class::<AzGetProgramBinaryReturn>()?;
    m.add_class::<AzGetActiveAttribReturn>()?;
    m.add_class::<AzGLsyncPtr>()?;
    m.add_class::<AzGetActiveUniformReturn>()?;
    m.add_class::<AzAzDebugMessage>()?;

    m.add_class::<AzImageRef>()?;
    m.add_class::<AzRawImage>()?;
    m.add_class::<AzImageMask>()?;
    m.add_class::<AzRawImageFormatEnumWrapper>()?;
    m.add_class::<AzEncodeImageErrorEnumWrapper>()?;
    m.add_class::<AzDecodeImageErrorEnumWrapper>()?;
    m.add_class::<AzRawImageDataEnumWrapper>()?;

    m.add_class::<AzFontMetrics>()?;
    m.add_class::<AzFontRef>()?;
    m.add_class::<AzLoadedFontSource>()?;

    m.add_class::<AzSvg>()?;
    m.add_class::<AzSvgXmlNode>()?;
    m.add_class::<AzSvgMultiPolygon>()?;
    m.add_class::<AzSvgNodeEnumWrapper>()?;
    m.add_class::<AzSvgSimpleNodeEnumWrapper>()?;
    m.add_class::<AzSvgStyledNode>()?;
    m.add_class::<AzSvgCircle>()?;
    m.add_class::<AzSvgPath>()?;
    m.add_class::<AzSvgPathElementEnumWrapper>()?;
    m.add_class::<AzSvgPoint>()?;
    m.add_class::<AzSvgVector>()?;
    m.add_class::<AzSvgLine>()?;
    m.add_class::<AzSvgQuadraticCurve>()?;
    m.add_class::<AzSvgCubicCurve>()?;
    m.add_class::<AzSvgRect>()?;
    m.add_class::<AzSvgColoredVertex>()?;
    m.add_class::<AzTessellatedColoredSvgNode>()?;
    m.add_class::<AzTessellatedColoredSvgNodeVecRef>()?;
    m.add_class::<AzTessellatedColoredGPUSvgNode>()?;
    m.add_class::<AzSvgVertex>()?;
    m.add_class::<AzTessellatedSvgNode>()?;
    m.add_class::<AzTessellatedSvgNodeVecRef>()?;
    m.add_class::<AzTessellatedGPUSvgNode>()?;
    m.add_class::<AzSvgParseOptions>()?;
    m.add_class::<AzShapeRenderingEnumWrapper>()?;
    m.add_class::<AzTextRenderingEnumWrapper>()?;
    m.add_class::<AzImageRenderingEnumWrapper>()?;
    m.add_class::<AzFontDatabaseEnumWrapper>()?;
    m.add_class::<AzSvgRenderOptions>()?;
    m.add_class::<AzSvgRenderTransform>()?;
    m.add_class::<AzSvgDashPattern>()?;
    m.add_class::<AzIndentEnumWrapper>()?;
    m.add_class::<AzSvgFitToEnumWrapper>()?;
    m.add_class::<AzSvgStyleEnumWrapper>()?;
    m.add_class::<AzSvgFillRuleEnumWrapper>()?;
    m.add_class::<AzSvgTransform>()?;
    m.add_class::<AzSvgFillStyle>()?;
    m.add_class::<AzSvgStrokeStyle>()?;
    m.add_class::<AzSvgLineJoinEnumWrapper>()?;
    m.add_class::<AzSvgLineCapEnumWrapper>()?;
    m.add_class::<AzSvgXmlOptions>()?;
    m.add_class::<AzSvgParseErrorEnumWrapper>()?;

    m.add_class::<AzXml>()?;
    m.add_class::<AzXmlNode>()?;

    m.add_class::<AzFile>()?;

    m.add_class::<AzMsgBox>()?;
    m.add_class::<AzMsgBoxIconEnumWrapper>()?;
    m.add_class::<AzColorPickerDialog>()?;
    m.add_class::<AzYesNoEnumWrapper>()?;
    m.add_class::<AzFileDialog>()?;
    m.add_class::<AzFileTypeList>()?;
    m.add_class::<AzOkCancelEnumWrapper>()?;

    m.add_class::<AzInstantEnumWrapper>()?;
    m.add_class::<AzSystemTickDiff>()?;
    m.add_class::<AzAzInstantPtr>()?;
    m.add_class::<AzInstantPtrCloneCallback>()?;
    m.add_class::<AzSystemTick>()?;
    m.add_class::<AzDurationEnumWrapper>()?;
    m.add_class::<AzSystemTimeDiff>()?;
    m.add_class::<AzInstantPtrDestructorCallback>()?;

    m.add_class::<AzTimerId>()?;
    m.add_class::<AzTimer>()?;
    m.add_class::<AzTerminateTimerEnumWrapper>()?;
    m.add_class::<AzThreadId>()?;
    m.add_class::<AzThread>()?;
    m.add_class::<AzThreadSender>()?;
    m.add_class::<AzThreadReceiver>()?;
    m.add_class::<AzThreadSendMsgEnumWrapper>()?;
    m.add_class::<AzThreadReceiveMsgEnumWrapper>()?;
    m.add_class::<AzThreadWriteBackMsg>()?;
    m.add_class::<AzThreadReceiverDestructorCallback>()?;
    m.add_class::<AzCreateThreadCallback>()?;
    m.add_class::<AzGetSystemTimeCallback>()?;
    m.add_class::<AzCheckThreadFinishedCallback>()?;
    m.add_class::<AzLibrarySendThreadMsgCallback>()?;
    m.add_class::<AzLibraryReceiveThreadMsgCallback>()?;
    m.add_class::<AzThreadRecvCallback>()?;
    m.add_class::<AzThreadSendCallback>()?;
    m.add_class::<AzThreadDestructorCallback>()?;
    m.add_class::<AzThreadSenderDestructorCallback>()?;

    m.add_class::<AzFmtValueEnumWrapper>()?;
    m.add_class::<AzFmtArg>()?;
    m.add_class::<AzAzString>()?;

    m.add_class::<AzListViewRowVec>()?;
    m.add_class::<AzStyleFilterVec>()?;
    m.add_class::<AzLogicalRectVec>()?;
    m.add_class::<AzNodeTypeIdInfoMapVec>()?;
    m.add_class::<AzInputOutputTypeIdInfoMapVec>()?;
    m.add_class::<AzNodeIdNodeMapVec>()?;
    m.add_class::<AzInputOutputTypeIdVec>()?;
    m.add_class::<AzNodeTypeFieldVec>()?;
    m.add_class::<AzInputConnectionVec>()?;
    m.add_class::<AzOutputNodeAndIndexVec>()?;
    m.add_class::<AzOutputConnectionVec>()?;
    m.add_class::<AzInputNodeAndIndexVec>()?;
    m.add_class::<AzAccessibilityStateVec>()?;
    m.add_class::<AzMenuItemVec>()?;
    m.add_class::<AzTessellatedSvgNodeVec>()?;
    m.add_class::<AzTessellatedColoredSvgNodeVec>()?;
    m.add_class::<AzStyleFontFamilyVec>()?;
    m.add_class::<AzXmlNodeVec>()?;
    m.add_class::<AzFmtArgVec>()?;
    m.add_class::<AzInlineLineVec>()?;
    m.add_class::<AzInlineWordVec>()?;
    m.add_class::<AzInlineGlyphVec>()?;
    m.add_class::<AzInlineTextHitVec>()?;
    m.add_class::<AzMonitorVec>()?;
    m.add_class::<AzVideoModeVec>()?;
    m.add_class::<AzDomVec>()?;
    m.add_class::<AzIdOrClassVec>()?;
    m.add_class::<AzNodeDataInlineCssPropertyVec>()?;
    m.add_class::<AzStyleBackgroundContentVec>()?;
    m.add_class::<AzStyleBackgroundPositionVec>()?;
    m.add_class::<AzStyleBackgroundRepeatVec>()?;
    m.add_class::<AzStyleBackgroundSizeVec>()?;
    m.add_class::<AzStyleTransformVec>()?;
    m.add_class::<AzCssPropertyVec>()?;
    m.add_class::<AzSvgMultiPolygonVec>()?;
    m.add_class::<AzSvgSimpleNodeVec>()?;
    m.add_class::<AzSvgPathVec>()?;
    m.add_class::<AzVertexAttributeVec>()?;
    m.add_class::<AzSvgPathElementVec>()?;
    m.add_class::<AzSvgVertexVec>()?;
    m.add_class::<AzSvgColoredVertexVec>()?;
    m.add_class::<AzU32Vec>()?;
    m.add_class::<AzXWindowTypeVec>()?;
    m.add_class::<AzVirtualKeyCodeVec>()?;
    m.add_class::<AzCascadeInfoVec>()?;
    m.add_class::<AzScanCodeVec>()?;
    m.add_class::<AzCssDeclarationVec>()?;
    m.add_class::<AzCssPathSelectorVec>()?;
    m.add_class::<AzStylesheetVec>()?;
    m.add_class::<AzCssRuleBlockVec>()?;
    m.add_class::<AzU16Vec>()?;
    m.add_class::<AzF32Vec>()?;
    m.add_class::<AzU8Vec>()?;
    m.add_class::<AzCallbackDataVec>()?;
    m.add_class::<AzGLuintVec>()?;
    m.add_class::<AzGLintVec>()?;
    m.add_class::<AzStringVec>()?;
    m.add_class::<AzStringPairVec>()?;
    m.add_class::<AzNormalizedLinearColorStopVec>()?;
    m.add_class::<AzNormalizedRadialColorStopVec>()?;
    m.add_class::<AzNodeIdVec>()?;
    m.add_class::<AzNodeHierarchyItemVec>()?;
    m.add_class::<AzStyledNodeVec>()?;
    m.add_class::<AzTagIdToNodeIdMappingVec>()?;
    m.add_class::<AzParentWithNodeDepthVec>()?;
    m.add_class::<AzNodeDataVec>()?;
    m.add_class::<AzStyleFontFamilyVecDestructorEnumWrapper>()?;
    m.add_class::<AzListViewRowVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleFilterVecDestructorEnumWrapper>()?;
    m.add_class::<AzLogicalRectVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeTypeIdInfoMapVecDestructorEnumWrapper>()?;
    m.add_class::<AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeIdNodeMapVecDestructorEnumWrapper>()?;
    m.add_class::<AzInputOutputTypeIdVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeTypeFieldVecDestructorEnumWrapper>()?;
    m.add_class::<AzInputConnectionVecDestructorEnumWrapper>()?;
    m.add_class::<AzOutputNodeAndIndexVecDestructorEnumWrapper>()?;
    m.add_class::<AzOutputConnectionVecDestructorEnumWrapper>()?;
    m.add_class::<AzInputNodeAndIndexVecDestructorEnumWrapper>()?;
    m.add_class::<AzAccessibilityStateVecDestructorEnumWrapper>()?;
    m.add_class::<AzMenuItemVecDestructorEnumWrapper>()?;
    m.add_class::<AzTessellatedSvgNodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzTessellatedColoredSvgNodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzXmlNodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzFmtArgVecDestructorEnumWrapper>()?;
    m.add_class::<AzInlineLineVecDestructorEnumWrapper>()?;
    m.add_class::<AzInlineWordVecDestructorEnumWrapper>()?;
    m.add_class::<AzInlineGlyphVecDestructorEnumWrapper>()?;
    m.add_class::<AzInlineTextHitVecDestructorEnumWrapper>()?;
    m.add_class::<AzMonitorVecDestructorEnumWrapper>()?;
    m.add_class::<AzVideoModeVecDestructorEnumWrapper>()?;
    m.add_class::<AzDomVecDestructorEnumWrapper>()?;
    m.add_class::<AzIdOrClassVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeDataInlineCssPropertyVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundContentVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundPositionVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundRepeatVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundSizeVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleTransformVecDestructorEnumWrapper>()?;
    m.add_class::<AzCssPropertyVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgMultiPolygonVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgSimpleNodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgPathVecDestructorEnumWrapper>()?;
    m.add_class::<AzVertexAttributeVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgPathElementVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgVertexVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgColoredVertexVecDestructorEnumWrapper>()?;
    m.add_class::<AzU32VecDestructorEnumWrapper>()?;
    m.add_class::<AzXWindowTypeVecDestructorEnumWrapper>()?;
    m.add_class::<AzVirtualKeyCodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzCascadeInfoVecDestructorEnumWrapper>()?;
    m.add_class::<AzScanCodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzCssDeclarationVecDestructorEnumWrapper>()?;
    m.add_class::<AzCssPathSelectorVecDestructorEnumWrapper>()?;
    m.add_class::<AzStylesheetVecDestructorEnumWrapper>()?;
    m.add_class::<AzCssRuleBlockVecDestructorEnumWrapper>()?;
    m.add_class::<AzF32VecDestructorEnumWrapper>()?;
    m.add_class::<AzU16VecDestructorEnumWrapper>()?;
    m.add_class::<AzU8VecDestructorEnumWrapper>()?;
    m.add_class::<AzCallbackDataVecDestructorEnumWrapper>()?;
    m.add_class::<AzAzDebugMessageVec>()?;
    m.add_class::<AzGLuintVecDestructorEnumWrapper>()?;
    m.add_class::<AzGLintVecDestructorEnumWrapper>()?;
    m.add_class::<AzStringVecDestructorEnumWrapper>()?;
    m.add_class::<AzStringPairVecDestructorEnumWrapper>()?;
    m.add_class::<AzNormalizedLinearColorStopVecDestructorEnumWrapper>()?;
    m.add_class::<AzNormalizedRadialColorStopVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeIdVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeHierarchyItemVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyledNodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzTagIdToNodeIdMappingVecDestructorEnumWrapper>()?;
    m.add_class::<AzParentWithNodeDepthVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeDataVecDestructorEnumWrapper>()?;
    m.add_class::<AzAzDebugMessageVecDestructorEnumWrapper>()?;

    m.add_class::<AzOptionSvgPointEnumWrapper>()?;
    m.add_class::<AzOptionStyleTextAlignEnumWrapper>()?;
    m.add_class::<AzOptionListViewOnRowClickEnumWrapper>()?;
    m.add_class::<AzOptionListViewOnColumnClickEnumWrapper>()?;
    m.add_class::<AzOptionListViewOnLazyLoadScrollEnumWrapper>()?;
    m.add_class::<AzOptionMenuEnumWrapper>()?;
    m.add_class::<AzOptionPixelValueNoPercentEnumWrapper>()?;
    m.add_class::<AzOptionDropDownOnChoiceChangeEnumWrapper>()?;
    m.add_class::<AzOptionResolvedTextLayoutOptionsEnumWrapper>()?;
    m.add_class::<AzOptionU8VecRefEnumWrapper>()?;
    m.add_class::<AzOptionOnNodeAddedEnumWrapper>()?;
    m.add_class::<AzOptionOnNodeRemovedEnumWrapper>()?;
    m.add_class::<AzOptionOnNodeGraphDraggedEnumWrapper>()?;
    m.add_class::<AzOptionOnNodeDraggedEnumWrapper>()?;
    m.add_class::<AzOptionOnNodeConnectedEnumWrapper>()?;
    m.add_class::<AzOptionOnNodeInputDisconnectedEnumWrapper>()?;
    m.add_class::<AzOptionOnNodeOutputDisconnectedEnumWrapper>()?;
    m.add_class::<AzOptionColorInputOnValueChangeEnumWrapper>()?;
    m.add_class::<AzOptionButtonOnClickEnumWrapper>()?;
    m.add_class::<AzOptionTabOnClickEnumWrapper>()?;
    m.add_class::<AzOptionFileInputOnPathChangeEnumWrapper>()?;
    m.add_class::<AzOptionCheckBoxOnToggleEnumWrapper>()?;
    m.add_class::<AzOptionTextInputOnTextInputEnumWrapper>()?;
    m.add_class::<AzOptionTextInputOnVirtualKeyDownEnumWrapper>()?;
    m.add_class::<AzOptionTextInputOnFocusLostEnumWrapper>()?;
    m.add_class::<AzOptionTextInputSelectionEnumWrapper>()?;
    m.add_class::<AzOptionNumberInputOnFocusLostEnumWrapper>()?;
    m.add_class::<AzOptionNumberInputOnValueChangeEnumWrapper>()?;
    m.add_class::<AzOptionMenuItemIconEnumWrapper>()?;
    m.add_class::<AzOptionMenuCallbackEnumWrapper>()?;
    m.add_class::<AzOptionVirtualKeyCodeComboEnumWrapper>()?;
    m.add_class::<AzOptionCssPropertyEnumWrapper>()?;
    m.add_class::<AzOptionPositionInfoEnumWrapper>()?;
    m.add_class::<AzOptionTimerIdEnumWrapper>()?;
    m.add_class::<AzOptionThreadIdEnumWrapper>()?;
    m.add_class::<AzOptionI16EnumWrapper>()?;
    m.add_class::<AzOptionU16EnumWrapper>()?;
    m.add_class::<AzOptionU32EnumWrapper>()?;
    m.add_class::<AzOptionImageRefEnumWrapper>()?;
    m.add_class::<AzOptionFontRefEnumWrapper>()?;
    m.add_class::<AzOptionOnNodeFieldEditedEnumWrapper>()?;
    m.add_class::<AzOptionFileTypeListEnumWrapper>()?;
    m.add_class::<AzOptionWindowStateEnumWrapper>()?;
    m.add_class::<AzOptionMouseStateEnumWrapper>()?;
    m.add_class::<AzOptionKeyboardStateEnumWrapper>()?;
    m.add_class::<AzOptionStringVecEnumWrapper>()?;
    m.add_class::<AzOptionFileEnumWrapper>()?;
    m.add_class::<AzOptionClipboardEnumWrapper>()?;
    m.add_class::<AzOptionThreadReceiveMsgEnumWrapper>()?;
    m.add_class::<AzOptionPercentageValueEnumWrapper>()?;
    m.add_class::<AzOptionAngleValueEnumWrapper>()?;
    m.add_class::<AzOptionRendererOptionsEnumWrapper>()?;
    m.add_class::<AzOptionCallbackEnumWrapper>()?;
    m.add_class::<AzOptionThreadSendMsgEnumWrapper>()?;
    m.add_class::<AzOptionLayoutRectEnumWrapper>()?;
    m.add_class::<AzOptionRefAnyEnumWrapper>()?;
    m.add_class::<AzOptionInlineTextEnumWrapper>()?;
    m.add_class::<AzOptionLayoutPointEnumWrapper>()?;
    m.add_class::<AzOptionLayoutSizeEnumWrapper>()?;
    m.add_class::<AzOptionWindowThemeEnumWrapper>()?;
    m.add_class::<AzOptionNodeIdEnumWrapper>()?;
    m.add_class::<AzOptionDomNodeIdEnumWrapper>()?;
    m.add_class::<AzOptionColorUEnumWrapper>()?;
    m.add_class::<AzOptionRawImageEnumWrapper>()?;
    m.add_class::<AzOptionSvgDashPatternEnumWrapper>()?;
    m.add_class::<AzOptionWaylandThemeEnumWrapper>()?;
    m.add_class::<AzOptionTaskBarIconEnumWrapper>()?;
    m.add_class::<AzOptionHwndHandleEnumWrapper>()?;
    m.add_class::<AzOptionLogicalPositionEnumWrapper>()?;
    m.add_class::<AzOptionPhysicalPositionI32EnumWrapper>()?;
    m.add_class::<AzOptionWindowIconEnumWrapper>()?;
    m.add_class::<AzOptionGlContextPtrEnumWrapper>()?;
    m.add_class::<AzOptionX11VisualEnumWrapper>()?;
    m.add_class::<AzOptionI32EnumWrapper>()?;
    m.add_class::<AzOptionF32EnumWrapper>()?;
    m.add_class::<AzOptionMouseCursorTypeEnumWrapper>()?;
    m.add_class::<AzOptionLogicalSizeEnumWrapper>()?;
    m.add_class::<AzOptionCharEnumWrapper>()?;
    m.add_class::<AzOptionVirtualKeyCodeEnumWrapper>()?;
    m.add_class::<AzOptionDomEnumWrapper>()?;
    m.add_class::<AzOptionTextureEnumWrapper>()?;
    m.add_class::<AzOptionImageMaskEnumWrapper>()?;
    m.add_class::<AzOptionTabIndexEnumWrapper>()?;
    m.add_class::<AzOptionTagIdEnumWrapper>()?;
    m.add_class::<AzOptionDurationEnumWrapper>()?;
    m.add_class::<AzOptionInstantEnumWrapper>()?;
    m.add_class::<AzOptionUsizeEnumWrapper>()?;
    m.add_class::<AzOptionU8VecEnumWrapper>()?;
    m.add_class::<AzOptionAzStringEnumWrapper>()?;

    m.add_class::<AzResultXmlXmlErrorEnumWrapper>()?;
    m.add_class::<AzResultRawImageDecodeImageErrorEnumWrapper>()?;
    m.add_class::<AzResultU8VecEncodeImageErrorEnumWrapper>()?;
    m.add_class::<AzResultSvgXmlNodeSvgParseErrorEnumWrapper>()?;
    m.add_class::<AzResultSvgSvgParseErrorEnumWrapper>()?;
    m.add_class::<AzSvgParseErrorEnumWrapper>()?;
    m.add_class::<AzXmlErrorEnumWrapper>()?;
    m.add_class::<AzDuplicatedNamespaceError>()?;
    m.add_class::<AzUnknownNamespaceError>()?;
    m.add_class::<AzUnexpectedCloseTagError>()?;
    m.add_class::<AzUnknownEntityReferenceError>()?;
    m.add_class::<AzDuplicatedAttributeError>()?;
    m.add_class::<AzXmlParseErrorEnumWrapper>()?;
    m.add_class::<AzXmlTextError>()?;
    m.add_class::<AzXmlStreamErrorEnumWrapper>()?;
    m.add_class::<AzNonXmlCharError>()?;
    m.add_class::<AzInvalidCharError>()?;
    m.add_class::<AzInvalidCharMultipleError>()?;
    m.add_class::<AzInvalidQuoteError>()?;
    m.add_class::<AzInvalidSpaceError>()?;
    m.add_class::<AzInvalidStringError>()?;
    m.add_class::<AzXmlTextPos>()?;

    m.add_class::<AzImageCache>()?;
    m.add_class::<AzFontCache>()?;
    m.add_class::<AzRawImageFormatEnumWrapper>()?;
    m.add_class::<AzAppLogLevelEnumWrapper>()?;
    m.add_class::<AzRawImageDataEnumWrapper>()?;
    m.add_class::<AzLoadedFontSource>()?;
    m.add_class::<AzAppConfig>()?;
    m.add_class::<AzImageMask>()?;
    m.add_class::<AzImageRef>()?;
    m.add_class::<AzRawImage>()?;
    m.add_class::<AzDpiScaleFactor>()?;
    m.add_class::<AzAppTerminationBehaviorEnumWrapper>()?;

    Ok(())
}
