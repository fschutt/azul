#![allow(non_snake_case)]


#[macro_use]
extern crate alloc;
extern crate azul_core;

#[cfg(not(target_arch = "wasm32"))]
pub mod desktop;
pub mod extra;
pub mod str;

pub mod azul_impl {
    #[cfg(not(target_arch = "wasm32"))]
    pub use super::desktop::*;
}

use core::ffi::c_void;
use core::mem;
use pyo3::prelude::*;
use pyo3::PyObjectProtocol;
use pyo3::types::*;
use pyo3::exceptions::PyException;

// GL type definitions
type GLuint = u32; type AzGLuint = GLuint;
type GLint = i32; type AzGLint = GLint;
type GLint64 = i64; type AzGLint64 = GLint64;
type GLuint64 = u64; type AzGLuint64 = GLuint64;
type GLenum = u32; type AzGLenum = GLenum;
type GLintptr = isize; type AzGLintptr = GLintptr;
type GLboolean = u8; type AzGLboolean = GLboolean;
type GLsizeiptr = isize; type AzGLsizeiptr = GLsizeiptr;
type GLvoid = c_void; type AzGLvoid = GLvoid;
type GLbitfield = u32; type AzGLbitfield = GLbitfield;
type GLsizei = i32; type AzGLsizei = GLsizei;
type GLclampf = f32; type AzGLclampf = GLclampf;
type GLfloat = f32; type AzGLfloat = GLfloat;
type AzF32 = f32;
type AzU16 = u16;
type AzU32 = u32;
type AzScanCode = u32;


use pyo3::{PyVisit, PyTraverseError, PyGCProtocol};

fn pystring_to_azstring(input: &String) -> AzString {
    input.clone().into()
}
fn az_string_to_py_string(input: AzString) -> String {
    input.into()
}
fn pystring_to_refstr(input: &str) -> AzRefstr {
    AzRefstr {
        ptr: input.as_ptr(),
        len: input.len(),
    }
}
fn az_vecu8_to_py_vecu8(input: AzU8Vec) -> Vec<u8> {
    let input: azul_impl::css::U8Vec = unsafe { mem::transmute(input) };
    input.into_library_owned_vec()
}
fn vec_string_to_vec_refstr(input: &Vec<&str>) -> Vec<AzRefstr> {
    input.iter().map(|i| pystring_to_refstr(i)).collect()
}
fn pybytesrefmut_to_vecu8refmut(input: &mut Vec<u8>) -> AzU8VecRefMut {
    AzU8VecRefMut { ptr: input.as_mut_ptr(), len: input.len() }
}
fn pybytesref_to_vecu8_ref(input: &Vec<u8>) -> AzU8VecRef {
    AzU8VecRef { ptr: input.as_ptr(), len: input.len() }
}
fn pylist_f32_to_rust(input: &Vec<f32>) -> AzF32VecRef {
    AzF32VecRef { ptr: input.as_ptr(), len: input.len() }
}
fn pylist_u32_to_rust(input: &Vec<u32>) -> AzGLuintVecRef {
    AzGLuintVecRef { ptr: input.as_ptr(), len: input.len() }
}
fn pylist_i32_to_rust(input: &mut Vec<i32>) -> AzGLintVecRefMut {
    AzGLintVecRefMut { ptr: input.as_mut_ptr(), len: input.len() }
}
fn pylist_i64_to_rust(input: &mut Vec<i64>) -> AzGLint64VecRefMut {
    AzGLint64VecRefMut { ptr: input.as_mut_ptr(), len: input.len() }
}
fn pylist_bool_to_rust(input: &mut Vec<u8>) -> AzGLbooleanVecRefMut {
    AzGLbooleanVecRefMut { ptr: input.as_mut_ptr(), len: input.len() }
}
fn pylist_glfoat_to_rust(input: &mut Vec<f32>) -> AzGLfloatVecRefMut {
    AzGLfloatVecRefMut { ptr: input.as_mut_ptr(), len: input.len() }
}
fn pylist_str_to_rust(input: &Vec<AzRefstr>) -> AzRefstrVecRef {
    AzRefstrVecRef { ptr: input.as_ptr(), len: input.len() }
}
fn pylist_tessellated_svg_node(input: &Vec<AzTessellatedSvgNode>) -> AzTessellatedSvgNodeVecRef {
    AzTessellatedSvgNodeVecRef { ptr: input.as_ptr(), len: input.len() }
}

impl From<String> for AzString {
    fn from(s: String) -> AzString {
        Self { vec: s.into_bytes().into() }
    }
}

impl From<AzString> for String {
    fn from(s: AzString) -> String {
        let s: azul_impl::css::AzString = unsafe { mem::transmute(s) };
        s.into_library_owned_string()
    }
}

// AzU8Vec
impl From<AzU8Vec> for Vec<u8> {
    fn from(input: AzU8Vec) -> Vec<u8> {
        let input: azul_impl::css::U8Vec = unsafe { mem::transmute(input) };
        input.into_library_owned_vec()
    }
}

impl From<Vec<u8>> for AzU8Vec {
    fn from(input: Vec<u8>) -> AzU8Vec {

        let ptr = input.as_ptr();
        let len = input.len();
        let cap = input.capacity();

        let _ = ::core::mem::ManuallyDrop::new(input);

        Self {
            ptr,
            len,
            cap,
            destructor: AzU8VecDestructorEnumWrapper::DefaultRust(),
        }

    }
}

// manually implement App::new, WindowState::new,
// WindowCreateOptions::new and LayoutCallback::new

#[pyproto]
impl PyGCProtocol for AzApp {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::app::AzAppPtr = unsafe { mem::transmute(self) };

        // NOTE: should not block - this should only succeed
        // AFTER the App has finished executing
        let mut app_lock = match data.ptr.try_lock().ok() {
            Some(s) => s,
            None => return Ok(()),
        };

        let data_ref = match app_lock.data.downcast_ref::<AppDataTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data_ref._py_app_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::app::AzAppPtr = unsafe { mem::transmute(self) };

        // NOTE: should not block - this should only succeed
        // AFTER the App has finished executing
        let mut app_lock = match data.ptr.try_lock().ok() {
            Some(s) => s,
            None => return,
        };

        let mut data = match app_lock.data.downcast_mut::<AppDataTy>() {
            Some(s) => s,
            None => return,
        };

        // Clear reference, this decrements Python ref counter.
        data._py_app_data = None;
    }
}

#[repr(C)]
pub struct AppDataTy {
    _py_app_data: Option<PyObject>,
}

#[repr(C)]
pub struct LayoutCallbackTy {
    // acual callable object from python
    _py_layout_callback: Option<PyObject>,
}

extern "C" fn invoke_py_marshaled_layout_callback(
    marshal_data: &mut AzRefAny,
    app_data: &mut AzRefAny,
    info: AzLayoutCallbackInfo
) -> AzStyledDom {

    let mut marshal_data: &mut azul_impl::callbacks::RefAny = unsafe { mem::transmute(marshal_data) };
    let mut app_data: &mut azul_impl::callbacks::RefAny = unsafe { mem::transmute(app_data) };

    let mut app_data_downcast = match app_data.downcast_mut::<AppDataTy>() {
        Some(s) => s,
        None => return AzStyledDom::default(),
    };

    let mut app_data_downcast = match app_data_downcast._py_app_data.as_mut() {
        Some(s) => s,
        None => return AzStyledDom::default(),
    };

    let mut pyfunction = match marshal_data.downcast_mut::<LayoutCallbackTy>() {
        Some(s) => s,
        None => return AzStyledDom::default(),
    };

    let mut pyfunction = match pyfunction._py_layout_callback.as_mut() {
        Some(s) => s,
        None => return AzStyledDom::default(),
    };

    // call layout callback into python
    let s: AzStyledDom = Python::with_gil(|py| {

        match pyfunction.call1(py.clone(), (app_data_downcast.clone_ref(py.clone()), info)) {
            Ok(o) => match o.as_ref(py).extract::<AzStyledDom>() {
                Ok(o) => o.clone(),
                Err(e) => {
                    #[cfg(feature = "logging")] {
                        let cb_any = o.as_ref(py);
                        let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
                        log::error!("ERROR: LayoutCallback returned object of type {}, expected azul.dom.StyledDom", type_name);
                    }
                    AzStyledDom::default()
                }
            },
            Err(e) => {
                #[cfg(feature = "logging")] {
                    log::error!("Exception caught when invoking LayoutCallback: {}", e);
                }
                AzStyledDom::default()
            }
        }
    });

    s
}

#[pyproto]
impl PyGCProtocol for AzMarshaledLayoutCallback {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let mut refany = data.marshal_data.clone();

        let data = match refany.downcast_ref::<LayoutCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_layout_callback.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) };

        let mut data = match data.marshal_data.downcast_mut::<LayoutCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_layout_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_layout_callback = None;
        }
    }
}

#[repr(C)]
pub struct IFrameCallbackTy {
    _py_iframe_data: Option<PyObject>,
    _py_iframe_callback: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzIFrameNode {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::dom::IFrameNode = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let mut refany = data.data.clone();

        let data = match refany.downcast_ref::<IFrameCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_iframe_data.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_iframe_callback.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::dom::IFrameNode = unsafe { mem::transmute(self) };

        let mut data = match data.data.downcast_mut::<IFrameCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_iframe_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_iframe_data = None;
        }

        if data._py_iframe_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_iframe_callback = None;
        }
    }
}

extern "C" fn invoke_python_iframe(data: &mut azul_impl::callbacks::RefAny, info: azul_impl::callbacks::IFrameCallbackInfo) -> azul_impl::callbacks::IFrameCallbackReturn {

    let default = azul_impl::callbacks::IFrameCallbackReturn {
         dom: azul_impl::styled_dom::StyledDom::default(),
         scroll_size: azul_core::window::LogicalSize::new(0.0, 0.0),
         scroll_offset: azul_core::window::LogicalPosition::new(0.0, 0.0),
         virtual_scroll_size: azul_core::window::LogicalSize::new(0.0, 0.0),
         virtual_scroll_offset: azul_core::window::LogicalPosition::new(0.0, 0.0),
    };

    let data: &mut azul_impl::callbacks::RefAny = unsafe { mem::transmute(data) };

    let mut iframe_cb = match data.downcast_mut::<IFrameCallbackTy>() {
        Some(s) => s,
        None => return default,
    };

    let mut iframe_cb = &mut *iframe_cb;

    let mut py_data = match iframe_cb._py_iframe_data.as_mut() {
        Some(s) => s,
        None => return default,
    };

    let mut py_function = match iframe_cb._py_iframe_callback.as_mut() {
        Some(s) => s,
        None => return default,
    };

    // call iframe callback into python
    let s: azul_impl::callbacks::IFrameCallbackReturn = Python::with_gil(|py| {
        let info: AzIFrameCallbackInfo = unsafe { mem::transmute(info) };
        match py_function.call1(py.clone(), (py_data.clone_ref(py.clone()), info)) {
            Ok(o) => match o.as_ref(py).extract::<AzIFrameCallbackReturn>() {
                Ok(o) => unsafe { mem::transmute(o.clone()) },
                Err(e) => {
                    #[cfg(feature = "logging")] {
                        let cb_any = o.as_ref(py);
                        let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
                        log::error!("ERROR: LayoutCallback returned object of type {}, expected azul.callbacks.AzIFrameCallbackReturn", type_name);
                    }
                    default
                }
            },
            Err(e) => {
                #[cfg(feature = "logging")] {
                    log::error!("Exception caught when invoking IFrameCallback: {}", e);
                }
                default
            }
        }
    });

    s
}

#[repr(C)]
pub struct CallbackTy {
    _py_callback: Option<PyObject>,
    _py_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzCallbackData {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::dom::CallbackData = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let mut refany = data.data.clone();

        let data = match refany.downcast_ref::<CallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_callback.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::dom::CallbackData = unsafe { mem::transmute(self) };

        let mut data = match data.data.downcast_mut::<CallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_callback = None;
        }

        if data._py_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_data = None;
        }
    }
}

extern "C" fn invoke_python_callback(data: &mut azul_impl::callbacks::RefAny, info: azul_impl::callbacks::CallbackInfo) -> azul_impl::callbacks::Update {

    let default: azul_impl::callbacks::Update = azul_impl::callbacks::Update::DoNothing;

    let data: &mut azul_impl::callbacks::RefAny = unsafe { mem::transmute(data) };

    let mut cb = match data.downcast_mut::<CallbackTy>() {
        Some(s) => s,
        None => return default,
    };

    let mut cb = &mut *cb;

    let mut py_data = match cb._py_data.as_mut() {
        Some(s) => s,
        None => return default,
    };

    let mut py_function = match cb._py_callback.as_mut() {
        Some(s) => s,
        None => return default,
    };

    // call callback into python
    let s: azul_impl::callbacks::Update = Python::with_gil(|py| {
        let info: AzCallbackInfo = unsafe { mem::transmute(info) };

        match py_function.call1(py.clone(), (py_data.clone_ref(py.clone()), info)) {
            Ok(o) => match o.as_ref(py).extract::<AzUpdateEnumWrapper>() {
                Ok(o) => unsafe { mem::transmute(o.clone()) },
                Err(e) => {
                    #[cfg(feature = "logging")] {
                        let cb_any = o.as_ref(py);
                        let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
                        log::error!("ERROR: Callback returned object of type {}, expected azul.callbacks.Update", type_name);
                    }
                    default
                }
            },
            Err(e) => {
                #[cfg(feature = "logging")] {
                    log::error!("Exception caught when invoking Callback: {}", e);
                }
                default
            }
        }
    });

    s
}

#[repr(C)]
pub struct TimerCallbackTy {
    _py_timer_callback: Option<PyObject>,
    _py_timer_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzTimer {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::task::Timer = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let mut refany = data.data.clone();

        let data = match refany.downcast_ref::<TimerCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_timer_callback.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_timer_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::task::Timer = unsafe { mem::transmute(self) };

        let mut data = match data.data.downcast_mut::<TimerCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_timer_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_timer_callback = None;
        }

        if data._py_timer_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_timer_data = None;
        }
    }
}

#[repr(C)]
pub struct ImageCallbackTy {
    _py_image_callback: Option<PyObject>,
    _py_image_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzImageRef {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::resources::ImageRef = unsafe { mem::transmute(self) };

        let image_callback = match data.get_image_callback() {
            Some(s) => s,
            None => return Ok(()),
        };

        // temporary clone since we can't borrow mutable here
        let mut refany = image_callback.data.clone();

        let data = match refany.downcast_ref::<ImageCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_image_callback.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_image_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::resources::ImageRef = unsafe { mem::transmute(self) };

        let image_callback = match data.get_image_callback_mut() {
            Some(s) => s,
            None => return,
        };

        let mut data = match image_callback.data.downcast_mut::<ImageCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_image_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_image_callback = None;
        }

        if data._py_image_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_image_data = None;
        }
    }
}

#[repr(C)]
pub struct ThreadWriteBackCallbackTy {
    _py_thread_callback: Option<PyObject>,
    _py_thread_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzThread {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::task::Thread = unsafe { mem::transmute(self) };

        let mut thread_inner = match data.ptr.try_lock().ok() {
            Some(o) => o,
            None => return Ok(()),
        };

        let mut data = match thread_inner.writeback_data.downcast_mut::<ThreadWriteBackCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_thread_callback.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_thread_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::task::Thread = unsafe { mem::transmute(self) };

        let mut thread_inner = match data.ptr.try_lock().ok() {
            Some(o) => o,
            None => return,
        };

        let mut data = match thread_inner.writeback_data.downcast_mut::<ThreadWriteBackCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_thread_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_thread_callback = None;
        }

        if data._py_thread_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_thread_data = None;
        }
    }
}

#[repr(C)]
pub struct DatasetTy {
    _py_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzNodeData {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {

        let data: &azul_impl::dom::NodeData = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let dataset = match data.get_dataset().as_ref() {
            Some(s) => s,
            None => return Ok(()),
        };

        let mut refany = dataset.clone();

        let data = match refany.downcast_ref::<DatasetTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {

        let mut data: &mut azul_impl::dom::NodeData = unsafe { mem::transmute(self) };

        let dataset = match data.get_dataset_mut().as_mut() {
            Some(s) => s,
            None => return,
        };

        let mut data = match dataset.downcast_mut::<DatasetTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_data = None;
        }
    }
}
/// `AzHidpiAdjustedBounds` struct
#[pyclass(name = "HidpiAdjustedBounds")]
pub struct AzHidpiAdjustedBounds {
    #[pyo3(get, set)]
    pub logical_size: LogicalSize, 
    #[pyo3(get, set)]
    pub hidpi_factor: DpiScaleFactor, 
}

/// `AzDpiScaleFactor` struct
#[pyclass(name = "DpiScaleFactor")]
pub struct AzDpiScaleFactor {
    #[pyo3(get, set)]
    pub inner: FloatValue, 
}

/// `AzLinuxWindowOptions` struct
#[pyclass(name = "LinuxWindowOptions")]
pub struct AzLinuxWindowOptions {
    #[pyo3(get, set)]
    pub x11_visual: OptionX11Visual, 
    #[pyo3(get, set)]
    pub x11_screen: OptionI32, 
    #[pyo3(get, set)]
    pub x11_wm_classes: StringPairVec, 
    #[pyo3(get, set)]
    pub x11_override_redirect: bool, 
    #[pyo3(get, set)]
    pub x11_window_types: XWindowTypeVec, 
    #[pyo3(get, set)]
    pub x11_gtk_theme_variant: OptionString, 
    #[pyo3(get, set)]
    pub x11_resize_increments: OptionLogicalSize, 
    #[pyo3(get, set)]
    pub x11_base_size: OptionLogicalSize, 
    #[pyo3(get, set)]
    pub wayland_app_id: OptionString, 
    #[pyo3(get, set)]
    pub wayland_theme: OptionWaylandTheme, 
    #[pyo3(get, set)]
    pub request_user_attention: UserAttentionType, 
    #[pyo3(get, set)]
    pub window_icon: OptionWindowIcon, 
    #[pyo3(get, set)]
    pub x11_decorations_state: OptionLinuxDecorationsState, 
}

/// `AzWaylandTheme` struct
#[pyclass(name = "WaylandTheme")]
pub struct AzWaylandTheme {
    #[pyo3(get, set)]
    pub title_bar_active_background_color: [u8; 4], 
    #[pyo3(get, set)]
    pub title_bar_active_separator_color: [u8; 4], 
    #[pyo3(get, set)]
    pub title_bar_active_text_color: [u8; 4], 
    #[pyo3(get, set)]
    pub title_bar_inactive_background_color: [u8; 4], 
    #[pyo3(get, set)]
    pub title_bar_inactive_separator_color: [u8; 4], 
    #[pyo3(get, set)]
    pub title_bar_inactive_text_color: [u8; 4], 
    #[pyo3(get, set)]
    pub maximize_idle_foreground_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub minimize_idle_foreground_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub close_idle_foreground_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub maximize_hovered_foreground_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub minimize_hovered_foreground_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub close_hovered_foreground_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub maximize_disabled_foreground_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub minimize_disabled_foreground_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub close_disabled_foreground_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub maximize_idle_background_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub minimize_idle_background_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub close_idle_background_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub maximize_hovered_background_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub minimize_hovered_background_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub close_hovered_background_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub maximize_disabled_background_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub minimize_disabled_background_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub close_disabled_background_inactive_color: [u8; 4], 
    #[pyo3(get, set)]
    pub maximize_idle_foreground_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub minimize_idle_foreground_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub close_idle_foreground_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub maximize_hovered_foreground_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub minimize_hovered_foreground_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub close_hovered_foreground_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub maximize_disabled_foreground_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub minimize_disabled_foreground_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub close_disabled_foreground_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub maximize_idle_background_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub minimize_idle_background_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub close_idle_background_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub maximize_hovered_background_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub minimize_hovered_background_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub close_hovered_background_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub maximize_disabled_background_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub minimize_disabled_background_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub close_disabled_background_active_color: [u8; 4], 
    #[pyo3(get, set)]
    pub title_bar_font: String, 
    #[pyo3(get, set)]
    pub title_bar_font_size: f32, 
}

/// `AzMonitorId` struct
#[pyclass(name = "MonitorId")]
pub struct AzMonitorId {
    #[pyo3(get, set)]
    pub index: usize, 
    #[pyo3(get, set)]
    pub hash: u64, 
}

/// `AzWindowFlags` struct
#[pyclass(name = "WindowFlags")]
pub struct AzWindowFlags {
    #[pyo3(get, set)]
    pub frame: WindowFrame, 
    #[pyo3(get, set)]
    pub close_requested: bool, 
    #[pyo3(get, set)]
    pub decorations: WindowDecorations, 
    #[pyo3(get, set)]
    pub is_visible: bool, 
    #[pyo3(get, set)]
    pub is_always_on_top: bool, 
    #[pyo3(get, set)]
    pub is_resizable: bool, 
    #[pyo3(get, set)]
    pub has_focus: bool, 
    #[pyo3(get, set)]
    pub background_material: WindowBackgroundMaterial, 
    #[pyo3(get, set)]
    pub smooth_scroll_enabled: bool, 
    #[pyo3(get, set)]
    pub autotab_enabled: bool, 
    #[pyo3(get, set)]
    pub window_type: WindowType, 
    #[pyo3(get, set)]
    pub has_decorations: bool, 
    #[pyo3(get, set)]
    pub use_native_menus: bool, 
    #[pyo3(get, set)]
    pub use_native_context_menus: bool, 
    #[pyo3(get, set)]
    pub is_top_level: bool, 
    #[pyo3(get, set)]
    pub prevent_system_sleep: bool, 
}

/// `AzTaskBarIcon` struct
#[pyclass(name = "TaskBarIcon")]
pub struct AzTaskBarIcon {
    #[pyo3(get, set)]
    pub key: IconKey, 
    #[pyo3(get, set)]
    pub rgba_bytes: U8Vec, 
}

/// `AzWasmWindowOptions` struct
#[pyclass(name = "WasmWindowOptions")]
pub struct AzWasmWindowOptions {
    #[pyo3(get, set)]
    pub _reserved: u8, 
}

/// `AzSmallWindowIconBytes` struct
#[pyclass(name = "SmallWindowIconBytes")]
pub struct AzSmallWindowIconBytes {
    #[pyo3(get, set)]
    pub key: IconKey, 
    #[pyo3(get, set)]
    pub rgba_bytes: U8Vec, 
}

/// `AzMonitor` struct
#[pyclass(name = "Monitor")]
pub struct AzMonitor {
    #[pyo3(get, set)]
    pub id: MonitorId, 
    #[pyo3(get, set)]
    pub name: OptionString, 
    #[pyo3(get, set)]
    pub size: LayoutSize, 
    #[pyo3(get, set)]
    pub position: LayoutPoint, 
    #[pyo3(get, set)]
    pub scale_factor: f64, 
    #[pyo3(get, set)]
    pub work_area: LayoutRect, 
    #[pyo3(get, set)]
    pub video_modes: VideoModeVec, 
    #[pyo3(get, set)]
    pub is_primary_monitor: bool, 
}

/// `AzIconKey` struct
#[pyclass(name = "IconKey")]
pub struct AzIconKey {
    #[pyo3(get, set)]
    pub id: usize, 
}

/// `AzMacWindowOptions` struct
#[pyclass(name = "MacWindowOptions")]
pub struct AzMacWindowOptions {
    #[pyo3(get, set)]
    pub _reserved: u8, 
}

/// `AzVideoMode` struct
#[pyclass(name = "VideoMode")]
pub struct AzVideoMode {
    #[pyo3(get, set)]
    pub size: LayoutSize, 
    #[pyo3(get, set)]
    pub bit_depth: u16, 
    #[pyo3(get, set)]
    pub refresh_rate: u16, 
}

/// `AzLargeWindowIconBytes` struct
#[pyclass(name = "LargeWindowIconBytes")]
pub struct AzLargeWindowIconBytes {
    #[pyo3(get, set)]
    pub key: IconKey, 
    #[pyo3(get, set)]
    pub rgba_bytes: U8Vec, 
}

/// `AzPlatformSpecificOptions` struct
#[pyclass(name = "PlatformSpecificOptions")]
pub struct AzPlatformSpecificOptions {
    #[pyo3(get, set)]
    pub windows_options: WindowsWindowOptions, 
    #[pyo3(get, set)]
    pub linux_options: LinuxWindowOptions, 
    #[pyo3(get, set)]
    pub mac_options: MacWindowOptions, 
    #[pyo3(get, set)]
    pub wasm_options: WasmWindowOptions, 
}

/// `AzWindowSize` struct
#[pyclass(name = "WindowSize")]
pub struct AzWindowSize {
    #[pyo3(get, set)]
    pub dimensions: LogicalSize, 
    #[pyo3(get, set)]
    pub dpi: u32, 
    #[pyo3(get, set)]
    pub min_dimensions: OptionLogicalSize, 
    #[pyo3(get, set)]
    pub max_dimensions: OptionLogicalSize, 
}

/// `AzWindowsWindowOptions` struct
#[pyclass(name = "WindowsWindowOptions")]
pub struct AzWindowsWindowOptions {
    #[pyo3(get, set)]
    pub allow_drag_and_drop: bool, 
    #[pyo3(get, set)]
    pub no_redirection_bitmap: bool, 
    #[pyo3(get, set)]
    pub window_icon: OptionWindowIcon, 
    #[pyo3(get, set)]
    pub taskbar_icon: OptionTaskBarIcon, 
    #[pyo3(get, set)]
    pub parent_window: OptionHwndHandle, 
}

/// `AzWindowCreateOptions` struct
#[pyclass(name = "WindowCreateOptions")]
pub struct AzWindowCreateOptions {
    #[pyo3(get, set)]
    pub state: FullWindowState, 
    #[pyo3(get, set)]
    pub size_to_content: bool, 
    #[pyo3(get, set)]
    pub renderer: OptionRendererOptions, 
    #[pyo3(get, set)]
    pub theme: OptionWindowTheme, 
    #[pyo3(get, set)]
    pub create_callback: OptionCallback, 
    #[pyo3(get, set)]
    pub hot_reload: bool, 
}

/// `AzFullWindowState` struct
#[pyclass(name = "FullWindowState")]
pub struct AzFullWindowState {
    #[pyo3(get, set)]
    pub theme: WindowTheme, 
    #[pyo3(get, set)]
    pub title: String, 
    #[pyo3(get, set)]
    pub size: WindowSize, 
    #[pyo3(get, set)]
    pub position: WindowPosition, 
    #[pyo3(get, set)]
    pub flags: WindowFlags, 
    #[pyo3(get, set)]
    pub debug_state: DebugState, 
    #[pyo3(get, set)]
    pub keyboard_state: KeyboardState, 
    #[pyo3(get, set)]
    pub mouse_state: MouseState, 
    #[pyo3(get, set)]
    pub touch_state: TouchState, 
    #[pyo3(get, set)]
    pub ime_position: ImePosition, 
    #[pyo3(get, set)]
    pub platform_specific_options: PlatformSpecificOptions, 
    #[pyo3(get, set)]
    pub renderer_options: RendererOptions, 
    #[pyo3(get, set)]
    pub background_color: ColorU, 
    #[pyo3(get, set)]
    pub layout_callback: LayoutCallback, 
    #[pyo3(get, set)]
    pub close_callback: OptionCallback, 
    #[pyo3(get, set)]
    pub monitor_id: OptionU32, 
    #[pyo3(get, set)]
    pub window_focused: bool, 
}

/// C-ABI wrapper over an `IFrameCallbackType`
#[pyclass(name = "IFrameCallback")]
pub struct AzIFrameCallback {
}

/// Return value for an IFrame rendering callback. # Dual Size Model IFrame callbacks return two size/offset pairs that enable lazy loading and virtualization: ## Actual Content (`scroll_size` + `scroll_offset`) The size and position of content that has **actually been rendered**. This is the content currently present in the returned DOM. **Example**: A table view might render only 20 visible rows out of 1000 total rows. ## Virtual Content (`virtual_scroll_size` + `virtual_scroll_offset`) The size and position of content that the IFrame **pretends to have**. This is used for scrollbar sizing and positioning, allowing the scrollbar to represent the full dataset even when only a subset is rendered. **Example**: The same table might pretend to have all 1000 rows for scrollbar sizing. # Conditional Re-invocation The IFrame callback will be re-invoked **only when necessary** to avoid performance overhead: 1. **Initial render** - First time the IFrame appears in the layout 2. **Parent DOM recreated** - The parent DOM was rebuilt from scratch (not just re-laid-out) 3. **Window resize (expansion only)** - Window grows and IFrame bounds exceed `scroll_size` - ✅ Only triggers **ONCE** per expansion (when bounds become uncovered) - Does **NOT** trigger when window shrinks (content is clipped, not re-rendered) - Does **NOT** trigger if expanded area is still within existing `scroll_size` 4. **Scroll near edge** - User scrolls within threshold (default 200px) of content edge - ✅ Only triggers **ONCE** per edge approach (prevents repeated calls) - Flag resets when: scroll moves away from edge, or callback returns expanded content 5. **Programmatic scroll** - `set_scroll_position()` scrolls beyond rendered `scroll_size` - Same constraints as rule #4 (threshold and once-per-edge) ## Window Resize Example ```text Frame 0: IFrame bounds = 800×600, scroll_size = 800×600 (perfectly covered) Frame 1: Window resizes to 1000×700 (larger) -> IFrame bounds = 1000×700 -> Bounds no longer fully covered by scroll_size (800×600) -> ✅ RE-INVOKE callback once Frame 2: Window resizes to 1100×800 (even larger) -> If callback returned scroll_size = 1100×800, fully covered again -> Do NOT re-invoke (content covers new bounds) -> If callback returned scroll_size = 1000×700, not fully covered -> ✅ RE-INVOKE again (new uncovered area) Frame 3: Window resizes to 900×650 (smaller) -> Bounds now smaller than scroll_size -> Do NOT re-invoke (content is just clipped by scrollbars) ``` ## Scroll Near Edge Example ```text scroll_size = 1000×2000 (width × height) Container = 800×600 Threshold = 200px Current scroll_offset = 0×0 User scrolls to scroll_offset = 0×1500: -> Bottom edge at 1500 + 600 = 2100 -> Within 200px of scroll_size.height (2000) -> Distance from edge: 2100 - 2000 = 100px < 200px -> ✅ RE-INVOKE callback to load more content Callback returns: -> New scroll_size = 1000×4000 (doubled) -> Flag reset (edge no longer near) -> User continues scrolling without re-invoke until near new edge ``` # Optimization: Returning None If the callback determines that no new content is needed (e.g., sufficient content has already been rendered ahead of the scroll position), it can return `OptionStyledDom::None` for the `dom` field. This signals the layout engine to keep using the current DOM and only update the scroll bounds. ```rust,ignore fn my_iframe_callback(data: &mut MyData, info: &mut IFrameCallbackInfo) -> IFrameCallbackReturn { let current_scroll = info.scroll_offset; // Check if we've already rendered content that covers this scroll position if data.already_rendered_area_covers(current_scroll, info.bounds.size) { return IFrameCallbackReturn { dom: OptionStyledDom::None, // Keep current DOM scroll_size: data.current_scroll_size, scroll_offset: data.current_scroll_offset, virtual_scroll_size: data.virtual_size, virtual_scroll_offset: LogicalPosition::zero(), }; } // Otherwise, render new content let new_dom = data.render_more_content(...); IFrameCallbackReturn { dom: OptionStyledDom::Some(new_dom), ... } } ``` # Example: Basic IFrame ```rust,ignore fn my_iframe_callback(data: &mut MyData, info: &mut IFrameCallbackInfo) -> IFrameCallbackReturn { let dom = Dom::body() .with_child(Dom::text("Hello from IFrame!")); let styled_dom = dom.style(Css::empty()); IFrameCallbackReturn { // The rendered content dom: OptionStyledDom::Some(styled_dom), // Size of actual rendered content (matches container) scroll_size: info.bounds.size, // Content starts at top-left scroll_offset: LogicalPosition::zero(), // Virtual size same as actual (no virtualization needed) virtual_scroll_size: info.bounds.size, virtual_scroll_offset: LogicalPosition::zero(), } } ``` # Example: Virtualized Table (Lazy Loading) ```rust,ignore struct TableData { total_rows: usize, // 1000 rows in full dataset row_height: f32, // 30px per row visible_rows: Vec<Row>, // Currently rendered rows (e.g., rows 0-29) first_visible_row: usize, // Index of first rendered row } fn table_iframe_callback(data: &mut TableData, info: &mut IFrameCallbackInfo) -> IFrameCallbackReturn { let container_height = info.bounds.size.height; let scroll_y = info.scroll_offset.y; // Calculate which rows should be visible based on scroll position let first_row = (scroll_y / data.row_height) as usize; let visible_count = (container_height / data.row_height).ceil() as usize + 2; // +2 for buffer // Fetch and render only the visible rows data.visible_rows = data.fetch_rows(first_row, visible_count); data.first_visible_row = first_row; let dom = Dom::body() .with_children( data.visible_rows.iter().map(|row| { Dom::div() .with_child(Dom::text(row.text.clone())) .with_inline_css_props(css_property_vec![ ("height", format!("{}px", data.row_height)), ]) }).collect() ); IFrameCallbackReturn { dom: OptionStyledDom::Some(dom.style(Css::empty())), // ACTUAL: Size of the ~30 rendered rows (e.g., 900px tall) scroll_size: LogicalSize::new( info.bounds.size.width, data.visible_rows.len() as f32 * data.row_height, ), // ACTUAL: Where these rows start in virtual space (e.g., y=300 if showing rows 10-30) scroll_offset: LogicalPosition::new( 0.0, first_row as f32 * data.row_height, ), // VIRTUAL: Size if all 1000 rows were rendered (30,000px tall) virtual_scroll_size: LogicalSize::new( info.bounds.size.width, data.total_rows as f32 * data.row_height, ), // VIRTUAL: Usually starts at origin virtual_scroll_offset: LogicalPosition::zero(), } } ``` In this example: - Only 20-30 rows are rendered at a time (~600-900px of DOM nodes) - The scrollbar represents all 1000 rows (30,000px virtual height) - When user scrolls near the bottom of rendered content, callback is re-invoked - New rows are rendered, and `scroll_size`/`scroll_offset` are updated - User experiences seamless scrolling through the full dataset # How the Layout Engine Uses These Values ## For Rendering - Uses `scroll_size` to determine the actual size of the IFrame's content box - Uses `scroll_offset` to position the content within the virtual space - Clips rendering to the visible viewport ## For Scrollbars - Uses `virtual_scroll_size` to calculate scrollbar thumb size and track length - Uses `virtual_scroll_offset` as the base for scroll position calculations - User sees scrollbar representing full virtual size, not just rendered content ## For Re-invocation Checks - Compares viewport bounds against `scroll_size` to detect edge proximity - Compares current scroll position against `scroll_offset + scroll_size` bounds - Triggers callback when user scrolls beyond the rendered content threshold
#[pyclass(name = "IFrameCallbackReturn")]
pub struct AzIFrameCallbackReturn {
    #[pyo3(get, set)]
    pub dom: OptionStyledDom, 
    #[pyo3(get, set)]
    pub scroll_size: LogicalSize, 
    #[pyo3(get, set)]
    pub scroll_offset: LogicalPosition, 
    #[pyo3(get, set)]
    pub virtual_scroll_size: LogicalSize, 
    #[pyo3(get, set)]
    pub virtual_scroll_offset: LogicalPosition, 
}

/// `AzIFrameCallbackInfo` struct
#[pyclass(name = "IFrameCallbackInfo")]
pub struct AzIFrameCallbackInfo {
    #[pyo3(get, set)]
    pub reason: IFrameCallbackReason, 
    #[pyo3(get, set)]
    pub system_fonts: c_void, 
    #[pyo3(get, set)]
    pub image_cache: c_void, 
    #[pyo3(get, set)]
    pub window_theme: WindowTheme, 
    #[pyo3(get, set)]
    pub bounds: HidpiAdjustedBounds, 
    #[pyo3(get, set)]
    pub scroll_size: LogicalSize, 
    #[pyo3(get, set)]
    pub scroll_offset: LogicalPosition, 
    #[pyo3(get, set)]
    pub virtual_scroll_size: LogicalSize, 
    #[pyo3(get, set)]
    pub virtual_scroll_offset: LogicalPosition, 
    #[pyo3(get, set)]
    pub _abi_ref: c_void, 
    #[pyo3(get, set)]
    pub _abi_mut: c_void, 
}

/// `AzCallbackInfo` struct
#[pyclass(name = "CallbackInfo")]
pub struct AzCallbackInfo {
    #[pyo3(get, set)]
    pub ref_data: c_void, 
    #[pyo3(get, set)]
    pub hit_dom_node: DomNodeId, 
    #[pyo3(get, set)]
    pub cursor_relative_to_item: OptionLogicalPosition, 
    #[pyo3(get, set)]
    pub cursor_in_viewport: OptionLogicalPosition, 
    #[pyo3(get, set)]
    pub changes: c_void, 
}

/// `AzRenderImageCallbackInfo` struct
#[pyclass(name = "RenderImageCallbackInfo")]
pub struct AzRenderImageCallbackInfo {
    #[pyo3(get, set)]
    pub callback_node_id: DomNodeId, 
    #[pyo3(get, set)]
    pub bounds: HidpiAdjustedBounds, 
    #[pyo3(get, set)]
    pub gl_context: c_void, 
    #[pyo3(get, set)]
    pub image_cache: c_void, 
    #[pyo3(get, set)]
    pub system_fonts: c_void, 
    #[pyo3(get, set)]
    pub _abi_ref: c_void, 
    #[pyo3(get, set)]
    pub _abi_mut: c_void, 
}

/// `AzMarshaledLayoutCallbackInner` struct
#[pyclass(name = "MarshaledLayoutCallbackInner")]
pub struct AzMarshaledLayoutCallbackInner {
}

/// `AzLayoutCallbackInner` struct
#[pyclass(name = "LayoutCallbackInner")]
pub struct AzLayoutCallbackInner {
}

/// `AzLayoutCallbackInfo` struct
#[pyclass(name = "LayoutCallbackInfo")]
pub struct AzLayoutCallbackInfo {
    #[pyo3(get, set)]
    pub ref_data: c_void, 
    #[pyo3(get, set)]
    pub window_size: WindowSize, 
    #[pyo3(get, set)]
    pub theme: WindowTheme, 
    #[pyo3(get, set)]
    pub _abi_ref: c_void, 
    #[pyo3(get, set)]
    pub _abi_mut: c_void, 
}

/// `AzMarshaledLayoutCallback` struct
#[pyclass(name = "MarshaledLayoutCallback")]
pub struct AzMarshaledLayoutCallback {
    #[pyo3(get, set)]
    pub marshal_data: RefAny, 
}

/// The document model, similar to HTML. This is a create-only structure, you don't actually read anything back from it. It's designed for ease of construction.
#[pyclass(name = "Dom")]
pub struct AzDom {
    #[pyo3(get, set)]
    pub root: NodeData, 
    #[pyo3(get, set)]
    pub children: DomVec, 
    #[pyo3(get, set)]
    pub estimated_total_children: usize, 
}

/// Represents all data associated with a single DOM node, such as its type, classes, IDs, callbacks, and inline styles.
#[pyclass(name = "NodeData")]
pub struct AzNodeData {
    #[pyo3(get, set)]
    pub node_type: NodeType, 
    #[pyo3(get, set)]
    pub dataset: OptionRefAny, 
    #[pyo3(get, set)]
    pub ids_and_classes: IdOrClassVec, 
    #[pyo3(get, set)]
    pub attributes: AttributeVec, 
    #[pyo3(get, set)]
    pub callbacks: CoreCallbackDataVec, 
    #[pyo3(get, set)]
    pub inline_css_props: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub tab_index: OptionTabIndex, 
    #[pyo3(get, set)]
    pub extra: c_void, 
}

/// Holds information about a UI element for accessibility purposes (e.g., screen readers). This is a wrapper for platform-specific accessibility APIs like MSAA.
#[pyclass(name = "AccessibilityInfo")]
pub struct AzAccessibilityInfo {
    #[pyo3(get, set)]
    pub name: OptionString, 
    #[pyo3(get, set)]
    pub value: OptionString, 
    #[pyo3(get, set)]
    pub role: AccessibilityRole, 
    #[pyo3(get, set)]
    pub states: AccessibilityStateVec, 
    #[pyo3(get, set)]
    pub accelerator: OptionVirtualKeyCodeCombo, 
    #[pyo3(get, set)]
    pub default_action: OptionString, 
    #[pyo3(get, set)]
    pub supported_actions: AccessibilityActionVec, 
    #[pyo3(get, set)]
    pub is_live_region: bool, 
    #[pyo3(get, set)]
    pub labelled_by: OptionDomNodeId, 
    #[pyo3(get, set)]
    pub described_by: OptionDomNodeId, 
}

/// A unique, runtime-generated identifier for a single `Dom` instance.
#[pyclass(name = "DomId")]
pub struct AzDomId {
    #[pyo3(get, set)]
    pub inner: usize, 
}

/// A UUID for a DOM node within a `LayoutWindow`.
#[pyclass(name = "DomNodeId")]
pub struct AzDomNodeId {
    #[pyo3(get, set)]
    pub dom: DomId, 
    #[pyo3(get, set)]
    pub node: NodeHierarchyItemId, 
}

/// `AzListViewOnColumnClickCallback` struct
#[pyclass(name = "ListViewOnColumnClickCallback")]
pub struct AzListViewOnColumnClickCallback {
}

/// `AzTagIdToNodeIdMapping` struct
#[pyclass(name = "TagIdToNodeIdMapping")]
pub struct AzTagIdToNodeIdMapping {
    #[pyo3(get, set)]
    pub tag_id: TagId, 
    #[pyo3(get, set)]
    pub node_id: NodeHierarchyItemId, 
    #[pyo3(get, set)]
    pub tab_index: OptionTabIndex, 
    #[pyo3(get, set)]
    pub parent_node_ids: NodeIdVec, 
}

/// `AzCoreCallback` struct
#[pyclass(name = "CoreCallback")]
pub struct AzCoreCallback {
}

/// `AzNodeHierarchyItemId` struct
#[pyclass(name = "NodeHierarchyItemId")]
pub struct AzNodeHierarchyItemId {
    #[pyo3(get, set)]
    pub inner: usize, 
}

/// `AzSvgXmlNode` struct
#[pyclass(name = "SvgXmlNode")]
pub struct AzSvgXmlNode {
    #[pyo3(get, set)]
    pub node: c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzCoreCallbackData` struct
#[pyclass(name = "CoreCallbackData")]
pub struct AzCoreCallbackData {
    #[pyo3(get, set)]
    pub event: EventFilter, 
    #[pyo3(get, set)]
    pub callback: CoreCallback, 
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// `AzListViewOnRowClickCallback` struct
#[pyclass(name = "ListViewOnRowClickCallback")]
pub struct AzListViewOnRowClickCallback {
}

/// `AzCoreMenuCallback` struct
#[pyclass(name = "CoreMenuCallback")]
pub struct AzCoreMenuCallback {
    #[pyo3(get, set)]
    pub data: RefAny, 
    #[pyo3(get, set)]
    pub callback: CoreCallback, 
}

/// `AzAttributeNameValue` struct
#[pyclass(name = "AttributeNameValue")]
pub struct AzAttributeNameValue {
    #[pyo3(get, set)]
    pub name: String, 
    #[pyo3(get, set)]
    pub value: String, 
}

/// `AzCheckBoxOnToggleCallback` struct
#[pyclass(name = "CheckBoxOnToggleCallback")]
pub struct AzCheckBoxOnToggleCallback {
}

/// `AzTabOnClickCallback` struct
#[pyclass(name = "TabOnClickCallback")]
pub struct AzTabOnClickCallback {
}

/// `AzParentWithNodeDepth` struct
#[pyclass(name = "ParentWithNodeDepth")]
pub struct AzParentWithNodeDepth {
    #[pyo3(get, set)]
    pub depth: usize, 
    #[pyo3(get, set)]
    pub node_id: NodeHierarchyItemId, 
}

/// `AzListViewOnLazyLoadScrollCallback` struct
#[pyclass(name = "ListViewOnLazyLoadScrollCallback")]
pub struct AzListViewOnLazyLoadScrollCallback {
}

/// `AzNodeHierarchyItem` struct
#[pyclass(name = "NodeHierarchyItem")]
pub struct AzNodeHierarchyItem {
    #[pyo3(get, set)]
    pub parent: usize, 
    #[pyo3(get, set)]
    pub previous_sibling: usize, 
    #[pyo3(get, set)]
    pub next_sibling: usize, 
    #[pyo3(get, set)]
    pub last_child: usize, 
}

/// `AzButtonOnClickCallback` struct
#[pyclass(name = "ButtonOnClickCallback")]
pub struct AzButtonOnClickCallback {
}

/// `AzXmlNode` struct
#[pyclass(name = "XmlNode")]
pub struct AzXmlNode {
    #[pyo3(get, set)]
    pub node_type: XmlTagName, 
    #[pyo3(get, set)]
    pub attributes: XmlAttributeMap, 
    #[pyo3(get, set)]
    pub children: XmlNodeChildVec, 
}

/// `AzTagId` struct
#[pyclass(name = "TagId")]
pub struct AzTagId {
    #[pyo3(get, set)]
    pub inner: u64, 
}

/// `AzVertexAttribute` struct
#[pyclass(name = "VertexAttribute")]
pub struct AzVertexAttribute {
    #[pyo3(get, set)]
    pub name: String, 
    #[pyo3(get, set)]
    pub layout_location: OptionUsize, 
    #[pyo3(get, set)]
    pub attribute_type: VertexAttributeType, 
    #[pyo3(get, set)]
    pub item_count: usize, 
}

/// `AzInstantPtrCloneCallback` struct
#[pyclass(name = "InstantPtrCloneCallback")]
pub struct AzInstantPtrCloneCallback {
}

/// `AzInstantPtrDestructorCallback` struct
#[pyclass(name = "InstantPtrDestructorCallback")]
pub struct AzInstantPtrDestructorCallback {
}

/// `AzCallback` struct
#[pyclass(name = "Callback")]
pub struct AzCallback {
}

/// `AzDebugState` struct
#[pyclass(name = "DebugState")]
pub struct AzDebugState {
    #[pyo3(get, set)]
    pub profiler_dbg: bool, 
    #[pyo3(get, set)]
    pub render_target_dbg: bool, 
    #[pyo3(get, set)]
    pub texture_cache_dbg: bool, 
    #[pyo3(get, set)]
    pub gpu_time_queries: bool, 
    #[pyo3(get, set)]
    pub gpu_sample_queries: bool, 
    #[pyo3(get, set)]
    pub disable_batching: bool, 
    #[pyo3(get, set)]
    pub epochs: bool, 
    #[pyo3(get, set)]
    pub echo_driver_messages: bool, 
    #[pyo3(get, set)]
    pub show_overdraw: bool, 
    #[pyo3(get, set)]
    pub gpu_cache_dbg: bool, 
    #[pyo3(get, set)]
    pub texture_cache_dbg_clear_evicted: bool, 
    #[pyo3(get, set)]
    pub picture_caching_dbg: bool, 
    #[pyo3(get, set)]
    pub primitive_dbg: bool, 
    #[pyo3(get, set)]
    pub zoom_dbg: bool, 
    #[pyo3(get, set)]
    pub small_screen: bool, 
    #[pyo3(get, set)]
    pub disable_opaque_pass: bool, 
    #[pyo3(get, set)]
    pub disable_alpha_pass: bool, 
    #[pyo3(get, set)]
    pub disable_clip_masks: bool, 
    #[pyo3(get, set)]
    pub disable_text_prims: bool, 
    #[pyo3(get, set)]
    pub disable_gradient_prims: bool, 
    #[pyo3(get, set)]
    pub obscure_images: bool, 
    #[pyo3(get, set)]
    pub glyph_flashing: bool, 
    #[pyo3(get, set)]
    pub smart_profiler: bool, 
    #[pyo3(get, set)]
    pub invalidation_dbg: bool, 
    #[pyo3(get, set)]
    pub tile_cache_logging_dbg: bool, 
    #[pyo3(get, set)]
    pub profiler_capture: bool, 
    #[pyo3(get, set)]
    pub force_picture_invalidation: bool, 
}

/// `AzKeyboardState` struct
#[pyclass(name = "KeyboardState")]
pub struct AzKeyboardState {
    #[pyo3(get, set)]
    pub current_virtual_keycode: OptionVirtualKeyCode, 
    #[pyo3(get, set)]
    pub pressed_virtual_keycodes: VirtualKeyCodeVec, 
    #[pyo3(get, set)]
    pub pressed_scancodes: ScanCodeVec, 
}

/// `AzTouchState` struct
#[pyclass(name = "TouchState")]
pub struct AzTouchState {
    #[pyo3(get, set)]
    pub num_touches: usize, 
}

/// `AzMouseState` struct
#[pyclass(name = "MouseState")]
pub struct AzMouseState {
    #[pyo3(get, set)]
    pub mouse_cursor_type: OptionMouseCursorType, 
    #[pyo3(get, set)]
    pub cursor_position: CursorPosition, 
    #[pyo3(get, set)]
    pub is_cursor_locked: bool, 
    #[pyo3(get, set)]
    pub left_down: bool, 
    #[pyo3(get, set)]
    pub right_down: bool, 
    #[pyo3(get, set)]
    pub middle_down: bool, 
}

/// Represents a menu (context menu, dropdown menu, or application menu). A menu consists of a list of items that can be displayed as a popup or attached to a window's menu bar. Modeled after the Windows API for cross-platform consistency. # Fields * `items` - The menu items to display * `position` - Where the menu should appear (for popups) * `context_mouse_btn` - Which mouse button triggers the context menu
#[pyclass(name = "Menu")]
pub struct AzMenu {
    #[pyo3(get, set)]
    pub items: MenuItemVec, 
    #[pyo3(get, set)]
    pub position: MenuPopupPosition, 
    #[pyo3(get, set)]
    pub context_mouse_btn: ContextMenuMouseButton, 
}

/// A menu item with a text label and optional features. `StringMenuItem` represents a clickable menu entry that can have: - A text label - An optional keyboard accelerator (e.g., Ctrl+C) - An optional callback function - An optional icon (checkbox or image) - A state (normal, greyed, or disabled) - Child menu items (for sub-menus) # Examples ```rust,no_run use azul_core::menu::StringMenuItem; use azul_css::AzString; let item = StringMenuItem::new(AzString::from_const_str("Copy")); ```
#[pyclass(name = "StringMenuItem")]
pub struct AzStringMenuItem {
    #[pyo3(get, set)]
    pub label: String, 
    #[pyo3(get, set)]
    pub accelerator: OptionVirtualKeyCodeCombo, 
    #[pyo3(get, set)]
    pub callback: OptionCoreMenuCallback, 
    #[pyo3(get, set)]
    pub state: MenuItemState, 
    #[pyo3(get, set)]
    pub icon: OptionMenuItemIcon, 
    #[pyo3(get, set)]
    pub children: MenuItemVec, 
}

/// One block of rules that applies a bunch of rules to a "path" in the style, i.e. `div#myid.myclass -> { ("justify-content", "center") }`
#[pyclass(name = "CssRuleBlock")]
pub struct AzCssRuleBlock {
    #[pyo3(get, set)]
    pub path: CssPath, 
    #[pyo3(get, set)]
    pub declarations: CssDeclarationVec, 
}

/// `AzCssNthChildPattern` struct
#[pyclass(name = "CssNthChildPattern")]
pub struct AzCssNthChildPattern {
    #[pyo3(get, set)]
    pub repeat: u32, 
    #[pyo3(get, set)]
    pub offset: u32, 
}

/// `AzStylesheet` struct
#[pyclass(name = "Stylesheet")]
pub struct AzStylesheet {
    #[pyo3(get, set)]
    pub rules: CssRuleBlockVec, 
}

/// Css stylesheet - contains a parsed CSS stylesheet in "rule blocks", i.e. blocks of key-value pairs associated with a selector path.
#[pyclass(name = "Css")]
pub struct AzCss {
    #[pyo3(get, set)]
    pub stylesheets: StylesheetVec, 
}

/// A `DynamicCssProperty` is a type of css property that can be changed on possibly every frame by the Rust code - for example to implement an `On::Hover` behaviour. The syntax for such a property looks like this: ```no_run,ignore #my_div { padding: var(--my_dynamic_property_id, 400px); } ``` Azul will register a dynamic property with the key "my_dynamic_property_id" and the default value of 400px. If the property gets overridden during one frame, the overridden property takes precedence. At runtime the style is immutable (which is a performance optimization - if we can assume that the property never changes at runtime), we can do some optimizations on it. Dynamic style properties can also be used for animations and conditional styles (i.e. `hover`, `focus`, etc.), thereby leading to cleaner code, since all of these special cases now use one single API.
#[pyclass(name = "DynamicCssProperty")]
pub struct AzDynamicCssProperty {
    #[pyo3(get, set)]
    pub dynamic_id: String, 
    #[pyo3(get, set)]
    pub default_value: CssProperty, 
}

/// u8-based color, range 0 to 255 (similar to webrenders ColorU)
#[pyclass(name = "ColorU")]
pub struct AzColorU {
    #[pyo3(get, set)]
    pub r: u8, 
    #[pyo3(get, set)]
    pub g: u8, 
    #[pyo3(get, set)]
    pub b: u8, 
    #[pyo3(get, set)]
    pub a: u8, 
}

/// `AzPixelValue` struct
#[pyclass(name = "PixelValue")]
pub struct AzPixelValue {
    #[pyo3(get, set)]
    pub metric: SizeMetric, 
    #[pyo3(get, set)]
    pub number: FloatValue, 
}

/// Same as PixelValue, but doesn't allow a "%" sign
#[pyclass(name = "PixelValueNoPercent")]
pub struct AzPixelValueNoPercent {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Represents a `box-shadow` or `text-shadow` property.
#[pyclass(name = "StyleBoxShadow")]
pub struct AzStyleBoxShadow {
    #[pyo3(get, set)]
    pub offset: [PixelValueNoPercent; 2], 
    #[pyo3(get, set)]
    pub color: ColorU, 
    #[pyo3(get, set)]
    pub blur_radius: PixelValueNoPercent, 
    #[pyo3(get, set)]
    pub spread_radius: PixelValueNoPercent, 
    #[pyo3(get, set)]
    pub clip_mode: BoxShadowClipMode, 
}

/// `AzStyleBlur` struct
#[pyclass(name = "StyleBlur")]
pub struct AzStyleBlur {
    #[pyo3(get, set)]
    pub width: PixelValue, 
    #[pyo3(get, set)]
    pub height: PixelValue, 
}

/// `AzStyleColorMatrix` struct
#[pyclass(name = "StyleColorMatrix")]
pub struct AzStyleColorMatrix {
    #[pyo3(get, set)]
    pub matrix: [FloatValue; 20], 
}

/// `AzStyleFilterOffset` struct
#[pyclass(name = "StyleFilterOffset")]
pub struct AzStyleFilterOffset {
    #[pyo3(get, set)]
    pub x: PixelValue, 
    #[pyo3(get, set)]
    pub y: PixelValue, 
}

/// `AzLayoutBottom` struct
#[pyclass(name = "LayoutBottom")]
pub struct AzLayoutBottom {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Represents a `flex-grow` attribute, which dictates what proportion of the remaining space in the flex container should be assigned to the item. Default: 0
#[pyclass(name = "LayoutFlexGrow")]
pub struct AzLayoutFlexGrow {
    #[pyo3(get, set)]
    pub inner: FloatValue, 
}

/// Represents a `flex-shrink` attribute, which dictates what proportion of the negative space in the flex container should be removed from the item. Default: 1
#[pyclass(name = "LayoutFlexShrink")]
pub struct AzLayoutFlexShrink {
    #[pyo3(get, set)]
    pub inner: FloatValue, 
}

/// `AzLayoutLeft` struct
#[pyclass(name = "LayoutLeft")]
pub struct AzLayoutLeft {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Layout margin bottom value
#[pyclass(name = "LayoutMarginBottom")]
pub struct AzLayoutMarginBottom {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Layout margin left value
#[pyclass(name = "LayoutMarginLeft")]
pub struct AzLayoutMarginLeft {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Layout margin right value
#[pyclass(name = "LayoutMarginRight")]
pub struct AzLayoutMarginRight {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Layout margin top value
#[pyclass(name = "LayoutMarginTop")]
pub struct AzLayoutMarginTop {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutMaxHeight` struct
#[pyclass(name = "LayoutMaxHeight")]
pub struct AzLayoutMaxHeight {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutMaxWidth` struct
#[pyclass(name = "LayoutMaxWidth")]
pub struct AzLayoutMaxWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutMinHeight` struct
#[pyclass(name = "LayoutMinHeight")]
pub struct AzLayoutMinHeight {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutMinWidth` struct
#[pyclass(name = "LayoutMinWidth")]
pub struct AzLayoutMinWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Layout padding bottom value
#[pyclass(name = "LayoutPaddingBottom")]
pub struct AzLayoutPaddingBottom {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutPaddingLeft` struct
#[pyclass(name = "LayoutPaddingLeft")]
pub struct AzLayoutPaddingLeft {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Layout padding right value
#[pyclass(name = "LayoutPaddingRight")]
pub struct AzLayoutPaddingRight {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Layout padding top value
#[pyclass(name = "LayoutPaddingTop")]
pub struct AzLayoutPaddingTop {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutRight` struct
#[pyclass(name = "LayoutRight")]
pub struct AzLayoutRight {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutTop` struct
#[pyclass(name = "LayoutTop")]
pub struct AzLayoutTop {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Wrapper around an f32 value that is internally casted to an isize, in order to provide hash-ability (to avoid numerical instability).
#[pyclass(name = "FloatValue")]
pub struct AzFloatValue {
    #[pyo3(get, set)]
    pub number: isize, 
}

/// Wrapper around FloatValue, represents a percentage instead of just being a regular floating-point value, i.e `5` = `5%`
#[pyclass(name = "PercentageValue")]
pub struct AzPercentageValue {
    #[pyo3(get, set)]
    pub number: FloatValue, 
}

/// FloatValue, but associated with a certain metric (i.e. deg, rad, etc.)
#[pyclass(name = "AngleValue")]
pub struct AzAngleValue {
    #[pyo3(get, set)]
    pub metric: AngleMetric, 
    #[pyo3(get, set)]
    pub number: FloatValue, 
}

/// `AzNormalizedLinearColorStop` struct
#[pyclass(name = "NormalizedLinearColorStop")]
pub struct AzNormalizedLinearColorStop {
    #[pyo3(get, set)]
    pub offset: PercentageValue, 
    #[pyo3(get, set)]
    pub color: ColorU, 
}

/// `AzNormalizedRadialColorStop` struct
#[pyclass(name = "NormalizedRadialColorStop")]
pub struct AzNormalizedRadialColorStop {
    #[pyo3(get, set)]
    pub angle: AngleValue, 
    #[pyo3(get, set)]
    pub color: ColorU, 
}

/// `AzDirectionCorners` struct
#[pyclass(name = "DirectionCorners")]
pub struct AzDirectionCorners {
    #[pyo3(get, set)]
    pub from: DirectionCorner, 
    #[pyo3(get, set)]
    pub to: DirectionCorner, 
}

/// `AzLinearGradient` struct
#[pyclass(name = "LinearGradient")]
pub struct AzLinearGradient {
    #[pyo3(get, set)]
    pub direction: Direction, 
    #[pyo3(get, set)]
    pub extend_mode: ExtendMode, 
    #[pyo3(get, set)]
    pub stops: NormalizedLinearColorStopVec, 
}

/// `AzRadialGradient` struct
#[pyclass(name = "RadialGradient")]
pub struct AzRadialGradient {
    #[pyo3(get, set)]
    pub shape: Shape, 
    #[pyo3(get, set)]
    pub size: RadialGradientSize, 
    #[pyo3(get, set)]
    pub position: StyleBackgroundPosition, 
    #[pyo3(get, set)]
    pub extend_mode: ExtendMode, 
    #[pyo3(get, set)]
    pub stops: NormalizedLinearColorStopVec, 
}

/// `AzConicGradient` struct
#[pyclass(name = "ConicGradient")]
pub struct AzConicGradient {
    #[pyo3(get, set)]
    pub extend_mode: ExtendMode, 
    #[pyo3(get, set)]
    pub center: StyleBackgroundPosition, 
    #[pyo3(get, set)]
    pub angle: AngleValue, 
    #[pyo3(get, set)]
    pub stops: NormalizedRadialColorStopVec, 
}

/// `AzStyleBackgroundPosition` struct
#[pyclass(name = "StyleBackgroundPosition")]
pub struct AzStyleBackgroundPosition {
    #[pyo3(get, set)]
    pub horizontal: BackgroundPositionHorizontal, 
    #[pyo3(get, set)]
    pub vertical: BackgroundPositionVertical, 
}

/// `AzStyleBorderBottomColor` struct
#[pyclass(name = "StyleBorderBottomColor")]
pub struct AzStyleBorderBottomColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// `AzStyleBorderBottomLeftRadius` struct
#[pyclass(name = "StyleBorderBottomLeftRadius")]
pub struct AzStyleBorderBottomLeftRadius {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzStyleBorderBottomRightRadius` struct
#[pyclass(name = "StyleBorderBottomRightRadius")]
pub struct AzStyleBorderBottomRightRadius {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzStyleBorderBottomStyle` struct
#[pyclass(name = "StyleBorderBottomStyle")]
pub struct AzStyleBorderBottomStyle {
    #[pyo3(get, set)]
    pub inner: BorderStyle, 
}

/// `AzLayoutBorderBottomWidth` struct
#[pyclass(name = "LayoutBorderBottomWidth")]
pub struct AzLayoutBorderBottomWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzStyleBorderLeftColor` struct
#[pyclass(name = "StyleBorderLeftColor")]
pub struct AzStyleBorderLeftColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// `AzStyleBorderLeftStyle` struct
#[pyclass(name = "StyleBorderLeftStyle")]
pub struct AzStyleBorderLeftStyle {
    #[pyo3(get, set)]
    pub inner: BorderStyle, 
}

/// `AzLayoutBorderLeftWidth` struct
#[pyclass(name = "LayoutBorderLeftWidth")]
pub struct AzLayoutBorderLeftWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzStyleBorderRightColor` struct
#[pyclass(name = "StyleBorderRightColor")]
pub struct AzStyleBorderRightColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// `AzStyleBorderRightStyle` struct
#[pyclass(name = "StyleBorderRightStyle")]
pub struct AzStyleBorderRightStyle {
    #[pyo3(get, set)]
    pub inner: BorderStyle, 
}

/// `AzLayoutBorderRightWidth` struct
#[pyclass(name = "LayoutBorderRightWidth")]
pub struct AzLayoutBorderRightWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzStyleBorderTopColor` struct
#[pyclass(name = "StyleBorderTopColor")]
pub struct AzStyleBorderTopColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// `AzStyleBorderTopLeftRadius` struct
#[pyclass(name = "StyleBorderTopLeftRadius")]
pub struct AzStyleBorderTopLeftRadius {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzStyleBorderTopRightRadius` struct
#[pyclass(name = "StyleBorderTopRightRadius")]
pub struct AzStyleBorderTopRightRadius {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzStyleBorderTopStyle` struct
#[pyclass(name = "StyleBorderTopStyle")]
pub struct AzStyleBorderTopStyle {
    #[pyo3(get, set)]
    pub inner: BorderStyle, 
}

/// `AzLayoutBorderTopWidth` struct
#[pyclass(name = "LayoutBorderTopWidth")]
pub struct AzLayoutBorderTopWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Holds info necessary for layouting / styling -webkit-scrollbar properties.
#[pyclass(name = "ScrollbarInfo")]
pub struct AzScrollbarInfo {
    #[pyo3(get, set)]
    pub width: LayoutWidth, 
    #[pyo3(get, set)]
    pub padding_left: LayoutPaddingLeft, 
    #[pyo3(get, set)]
    pub padding_right: LayoutPaddingRight, 
    #[pyo3(get, set)]
    pub track: StyleBackgroundContent, 
    #[pyo3(get, set)]
    pub thumb: StyleBackgroundContent, 
    #[pyo3(get, set)]
    pub button: StyleBackgroundContent, 
    #[pyo3(get, set)]
    pub corner: StyleBackgroundContent, 
    #[pyo3(get, set)]
    pub resizer: StyleBackgroundContent, 
}

/// Scrollbar style for both horizontal and vertical scrollbars.
#[pyclass(name = "ScrollbarStyle")]
pub struct AzScrollbarStyle {
    #[pyo3(get, set)]
    pub horizontal: ScrollbarInfo, 
    #[pyo3(get, set)]
    pub vertical: ScrollbarInfo, 
}

/// Represents a `font-size` attribute
#[pyclass(name = "StyleFontSize")]
pub struct AzStyleFontSize {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Represents a `letter-spacing` attribute
#[pyclass(name = "StyleLetterSpacing")]
pub struct AzStyleLetterSpacing {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Represents a `line-height` attribute
#[pyclass(name = "StyleLineHeight")]
pub struct AzStyleLineHeight {
    #[pyo3(get, set)]
    pub inner: PercentageValue, 
}

/// Represents a `tab-width` attribute
#[pyclass(name = "StyleTabWidth")]
pub struct AzStyleTabWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Represents an `opacity` attribute, a value from 0.0 to 1.0.
#[pyclass(name = "StyleOpacity")]
pub struct AzStyleOpacity {
    #[pyo3(get, set)]
    pub inner: PercentageValue, 
}

/// Represents a `transform-origin` attribute
#[pyclass(name = "StyleTransformOrigin")]
pub struct AzStyleTransformOrigin {
    #[pyo3(get, set)]
    pub x: PixelValue, 
    #[pyo3(get, set)]
    pub y: PixelValue, 
}

/// `AzStyleTransformMatrix2D` struct
#[pyclass(name = "StyleTransformMatrix2D")]
pub struct AzStyleTransformMatrix2D {
    #[pyo3(get, set)]
    pub a: FloatValue, 
    #[pyo3(get, set)]
    pub b: FloatValue, 
    #[pyo3(get, set)]
    pub c: FloatValue, 
    #[pyo3(get, set)]
    pub d: FloatValue, 
    #[pyo3(get, set)]
    pub tx: FloatValue, 
    #[pyo3(get, set)]
    pub ty: FloatValue, 
}

/// `AzStyleTransformMatrix3D` struct
#[pyclass(name = "StyleTransformMatrix3D")]
pub struct AzStyleTransformMatrix3D {
    #[pyo3(get, set)]
    pub m11: FloatValue, 
    #[pyo3(get, set)]
    pub m12: FloatValue, 
    #[pyo3(get, set)]
    pub m13: FloatValue, 
    #[pyo3(get, set)]
    pub m14: FloatValue, 
    #[pyo3(get, set)]
    pub m21: FloatValue, 
    #[pyo3(get, set)]
    pub m22: FloatValue, 
    #[pyo3(get, set)]
    pub m23: FloatValue, 
    #[pyo3(get, set)]
    pub m24: FloatValue, 
    #[pyo3(get, set)]
    pub m31: FloatValue, 
    #[pyo3(get, set)]
    pub m32: FloatValue, 
    #[pyo3(get, set)]
    pub m33: FloatValue, 
    #[pyo3(get, set)]
    pub m34: FloatValue, 
    #[pyo3(get, set)]
    pub m41: FloatValue, 
    #[pyo3(get, set)]
    pub m42: FloatValue, 
    #[pyo3(get, set)]
    pub m43: FloatValue, 
    #[pyo3(get, set)]
    pub m44: FloatValue, 
}

/// `AzStyleTransformTranslate2D` struct
#[pyclass(name = "StyleTransformTranslate2D")]
pub struct AzStyleTransformTranslate2D {
    #[pyo3(get, set)]
    pub x: PixelValue, 
    #[pyo3(get, set)]
    pub y: PixelValue, 
}

/// `AzStyleTransformTranslate3D` struct
#[pyclass(name = "StyleTransformTranslate3D")]
pub struct AzStyleTransformTranslate3D {
    #[pyo3(get, set)]
    pub x: PixelValue, 
    #[pyo3(get, set)]
    pub y: PixelValue, 
    #[pyo3(get, set)]
    pub z: PixelValue, 
}

/// `AzStyleTransformRotate3D` struct
#[pyclass(name = "StyleTransformRotate3D")]
pub struct AzStyleTransformRotate3D {
    #[pyo3(get, set)]
    pub x: FloatValue, 
    #[pyo3(get, set)]
    pub y: FloatValue, 
    #[pyo3(get, set)]
    pub z: FloatValue, 
    #[pyo3(get, set)]
    pub angle: AngleValue, 
}

/// `AzStyleTransformScale2D` struct
#[pyclass(name = "StyleTransformScale2D")]
pub struct AzStyleTransformScale2D {
    #[pyo3(get, set)]
    pub x: FloatValue, 
    #[pyo3(get, set)]
    pub y: FloatValue, 
}

/// `AzStyleTransformScale3D` struct
#[pyclass(name = "StyleTransformScale3D")]
pub struct AzStyleTransformScale3D {
    #[pyo3(get, set)]
    pub x: FloatValue, 
    #[pyo3(get, set)]
    pub y: FloatValue, 
    #[pyo3(get, set)]
    pub z: FloatValue, 
}

/// `AzStyleTransformSkew2D` struct
#[pyclass(name = "StyleTransformSkew2D")]
pub struct AzStyleTransformSkew2D {
    #[pyo3(get, set)]
    pub x: AngleValue, 
    #[pyo3(get, set)]
    pub y: AngleValue, 
}

/// Represents a `color` attribute.
#[pyclass(name = "StyleTextColor")]
pub struct AzStyleTextColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// Represents a `word-spacing` attribute
#[pyclass(name = "StyleWordSpacing")]
pub struct AzStyleWordSpacing {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzCounterReset` struct
#[pyclass(name = "CounterReset")]
pub struct AzCounterReset {
    #[pyo3(get, set)]
    pub counter_name: String, 
    #[pyo3(get, set)]
    pub value: i32, 
}

/// Represents a `perspective-origin` attribute
#[pyclass(name = "StylePerspectiveOrigin")]
pub struct AzStylePerspectiveOrigin {
    #[pyo3(get, set)]
    pub x: PixelValue, 
    #[pyo3(get, set)]
    pub y: PixelValue, 
}

/// `AzSelectionBackgroundColor` struct
#[pyclass(name = "SelectionBackgroundColor")]
pub struct AzSelectionBackgroundColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// `AzColumnRuleColor` struct
#[pyclass(name = "ColumnRuleColor")]
pub struct AzColumnRuleColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// `AzCaretAnimationDuration` struct
#[pyclass(name = "CaretAnimationDuration")]
pub struct AzCaretAnimationDuration {
    #[pyo3(get, set)]
    pub inner: CssDuration, 
}

/// `AzColumnRuleStyle` struct
#[pyclass(name = "ColumnRuleStyle")]
pub struct AzColumnRuleStyle {
    #[pyo3(get, set)]
    pub inner: BorderStyle, 
}

/// Represents `grid-row` or `grid-column` (start / end)
#[pyclass(name = "GridPlacement")]
pub struct AzGridPlacement {
    #[pyo3(get, set)]
    pub start: GridLine, 
    #[pyo3(get, set)]
    pub end: GridLine, 
}

/// Represents `grid-template-columns` or `grid-template-rows`
#[pyclass(name = "GridTemplate")]
pub struct AzGridTemplate {
    #[pyo3(get, set)]
    pub tracks: GridTrackSizingVec, 
}

/// `AzContent` struct
#[pyclass(name = "Content")]
pub struct AzContent {
    #[pyo3(get, set)]
    pub inner: String, 
}

/// `AzLayoutGap` struct
#[pyclass(name = "LayoutGap")]
pub struct AzLayoutGap {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzShapeMargin` struct
#[pyclass(name = "ShapeMargin")]
pub struct AzShapeMargin {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzCounterIncrement` struct
#[pyclass(name = "CounterIncrement")]
pub struct AzCounterIncrement {
    #[pyo3(get, set)]
    pub counter_name: String, 
    #[pyo3(get, set)]
    pub value: i32, 
}

/// `AzSelectionColor` struct
#[pyclass(name = "SelectionColor")]
pub struct AzSelectionColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// `AzShapeImageThreshold` struct
#[pyclass(name = "ShapeImageThreshold")]
pub struct AzShapeImageThreshold {
    #[pyo3(get, set)]
    pub inner: FloatValue, 
}

/// `AzColumnRuleWidth` struct
#[pyclass(name = "ColumnRuleWidth")]
pub struct AzColumnRuleWidth {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzCaretColor` struct
#[pyclass(name = "CaretColor")]
pub struct AzCaretColor {
    #[pyo3(get, set)]
    pub inner: ColorU, 
}

/// Only used for calculations: Size (width, height) in layout space.
#[pyclass(name = "LayoutSize")]
pub struct AzLayoutSize {
    #[pyo3(get, set)]
    pub width: isize, 
    #[pyo3(get, set)]
    pub height: isize, 
}

/// line-clamp property for limiting visible lines
#[pyclass(name = "StyleLineClamp")]
pub struct AzStyleLineClamp {
    #[pyo3(get, set)]
    pub max_lines: usize, 
}

/// `AzSelectionRadius` struct
#[pyclass(name = "SelectionRadius")]
pub struct AzSelectionRadius {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzOrphans` struct
#[pyclass(name = "Orphans")]
pub struct AzOrphans {
    #[pyo3(get, set)]
    pub inner: u32, 
}

/// Represents a `text-indent` attribute (indentation of first line in a block).
#[pyclass(name = "StyleTextIndent")]
pub struct AzStyleTextIndent {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// Sets the distance between the borders of adjacent cells. The `border-spacing` property is only applicable when `border-collapse` is set to `separate`. It can have one or two values: - One value: Sets both horizontal and vertical spacing - Two values: First is horizontal, second is vertical This struct represents a single spacing value (either horizontal or vertical).
#[pyclass(name = "LayoutBorderSpacing")]
pub struct AzLayoutBorderSpacing {
    #[pyo3(get, set)]
    pub horizontal: PixelValue, 
    #[pyo3(get, set)]
    pub vertical: PixelValue, 
}

/// `AzLayoutPaddingInlineStart` struct
#[pyclass(name = "LayoutPaddingInlineStart")]
pub struct AzLayoutPaddingInlineStart {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `-azul-exclusion-margin` property: defines margin around shape exclusions This property controls the spacing between text and shapes that text flows around. It's similar to `shape-margin` but specifically for exclusions (text wrapping). # Example ```css .element { -azul-exclusion-margin: 10.5; } ```
#[pyclass(name = "StyleExclusionMargin")]
pub struct AzStyleExclusionMargin {
    #[pyo3(get, set)]
    pub inner: FloatValue, 
}

/// `AzWidows` struct
#[pyclass(name = "Widows")]
pub struct AzWidows {
    #[pyo3(get, set)]
    pub inner: u32, 
}

/// `AzLayoutColumnGap` struct
#[pyclass(name = "LayoutColumnGap")]
pub struct AzLayoutColumnGap {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `AzLayoutPaddingInlineEnd` struct
#[pyclass(name = "LayoutPaddingInlineEnd")]
pub struct AzLayoutPaddingInlineEnd {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// `-azul-hyphenation-language` property: specifies language for hyphenation This property defines the language code (BCP 47 format) used for automatic hyphenation. Examples: "en-US", "de-DE", "fr-FR" # Example ```css .element { -azul-hyphenation-language: "en-US"; } ```
#[pyclass(name = "StyleHyphenationLanguage")]
pub struct AzStyleHyphenationLanguage {
    #[pyo3(get, set)]
    pub inner: String, 
}

/// `AzLayoutRowGap` struct
#[pyclass(name = "LayoutRowGap")]
pub struct AzLayoutRowGap {
    #[pyo3(get, set)]
    pub inner: PixelValue, 
}

/// hanging-punctuation property for hanging punctuation marks
#[pyclass(name = "StyleHangingPunctuation")]
pub struct AzStyleHangingPunctuation {
    #[pyo3(get, set)]
    pub enabled: bool, 
}

/// initial-letter property for drop caps
#[pyclass(name = "StyleInitialLetter")]
pub struct AzStyleInitialLetter {
    #[pyo3(get, set)]
    pub size: u32, 
    #[pyo3(get, set)]
    pub sink: OptionU32, 
}

/// Physical size with u32 dimensions
#[pyclass(name = "PhysicalSizeU32")]
pub struct AzPhysicalSizeU32 {
    #[pyo3(get, set)]
    pub width: u32, 
    #[pyo3(get, set)]
    pub height: u32, 
}

/// `AzTextSelectionStartEnd` struct
#[pyclass(name = "TextSelectionStartEnd")]
pub struct AzTextSelectionStartEnd {
    #[pyo3(get, set)]
    pub start: usize, 
    #[pyo3(get, set)]
    pub end: usize, 
}

/// `AzSvgFillStyle` struct
#[pyclass(name = "SvgFillStyle")]
pub struct AzSvgFillStyle {
    #[pyo3(get, set)]
    pub line_join: SvgLineJoin, 
    #[pyo3(get, set)]
    pub miter_limit: f32, 
    #[pyo3(get, set)]
    pub tolerance: f32, 
    #[pyo3(get, set)]
    pub fill_rule: SvgFillRule, 
    #[pyo3(get, set)]
    pub transform: SvgTransform, 
    #[pyo3(get, set)]
    pub anti_alias: bool, 
    #[pyo3(get, set)]
    pub high_quality_aa: bool, 
}

/// `AzXmlTextPos` struct
#[pyclass(name = "XmlTextPos")]
pub struct AzXmlTextPos {
    #[pyo3(get, set)]
    pub row: u32, 
    #[pyo3(get, set)]
    pub col: u32, 
}

/// `AzLogicalSize` struct
#[pyclass(name = "LogicalSize")]
pub struct AzLogicalSize {
    #[pyo3(get, set)]
    pub width: f32, 
    #[pyo3(get, set)]
    pub height: f32, 
}

/// `AzStyledNodeState` struct
#[pyclass(name = "StyledNodeState")]
pub struct AzStyledNodeState {
    #[pyo3(get, set)]
    pub normal: bool, 
    #[pyo3(get, set)]
    pub hover: bool, 
    #[pyo3(get, set)]
    pub active: bool, 
    #[pyo3(get, set)]
    pub focused: bool, 
}

/// `AzCssPropertyCachePtr` struct
#[pyclass(name = "CssPropertyCachePtr")]
pub struct AzCssPropertyCachePtr {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzSvgRenderTransform` struct
#[pyclass(name = "SvgRenderTransform")]
pub struct AzSvgRenderTransform {
    #[pyo3(get, set)]
    pub sx: f32, 
    #[pyo3(get, set)]
    pub kx: f32, 
    #[pyo3(get, set)]
    pub ky: f32, 
    #[pyo3(get, set)]
    pub sy: f32, 
    #[pyo3(get, set)]
    pub tx: f32, 
    #[pyo3(get, set)]
    pub ty: f32, 
}

/// `AzLogicalPosition` struct
#[pyclass(name = "LogicalPosition")]
pub struct AzLogicalPosition {
    #[pyo3(get, set)]
    pub x: f32, 
    #[pyo3(get, set)]
    pub y: f32, 
}

/// `AzPhysicalSize` struct
#[pyclass(name = "PhysicalSize")]
pub struct AzPhysicalSize {
    #[pyo3(get, set)]
    pub width: T, 
    #[pyo3(get, set)]
    pub height: T, 
}

/// `AzStyledDom` struct
#[pyclass(name = "StyledDom")]
pub struct AzStyledDom {
    #[pyo3(get, set)]
    pub root: NodeHierarchyItemId, 
    #[pyo3(get, set)]
    pub node_hierarchy: NodeHierarchyItemVec, 
    #[pyo3(get, set)]
    pub node_data: NodeDataVec, 
    #[pyo3(get, set)]
    pub styled_nodes: StyledNodeVec, 
    #[pyo3(get, set)]
    pub cascade_info: CascadeInfoVec, 
    #[pyo3(get, set)]
    pub nodes_with_window_callbacks: NodeIdVec, 
    #[pyo3(get, set)]
    pub nodes_with_not_callbacks: NodeIdVec, 
    #[pyo3(get, set)]
    pub nodes_with_datasets: NodeIdVec, 
    #[pyo3(get, set)]
    pub tag_ids_to_node_ids: TagIdToNodeIdMappingVec, 
    #[pyo3(get, set)]
    pub non_leaf_nodes: ParentWithNodeDepthVec, 
    #[pyo3(get, set)]
    pub css_property_cache: CssPropertyCachePtr, 
    #[pyo3(get, set)]
    pub dom_id: DomId, 
}

/// `AzStyledNode` struct
#[pyclass(name = "StyledNode")]
pub struct AzStyledNode {
    #[pyo3(get, set)]
    pub state: StyledNodeState, 
    #[pyo3(get, set)]
    pub tag_id: OptionTagId, 
}

/// `AzSvgTransform` struct
#[pyclass(name = "SvgTransform")]
pub struct AzSvgTransform {
    #[pyo3(get, set)]
    pub sx: f32, 
    #[pyo3(get, set)]
    pub kx: f32, 
    #[pyo3(get, set)]
    pub ky: f32, 
    #[pyo3(get, set)]
    pub sy: f32, 
    #[pyo3(get, set)]
    pub tx: f32, 
    #[pyo3(get, set)]
    pub ty: f32, 
}

/// `AzVertexLayout` struct
#[pyclass(name = "VertexLayout")]
pub struct AzVertexLayout {
    #[pyo3(get, set)]
    pub fields: VertexAttributeVec, 
}

/// `AzGridMinMax` struct
#[pyclass(name = "GridMinMax")]
pub struct AzGridMinMax {
    #[pyo3(get, set)]
    pub min: c_void, 
    #[pyo3(get, set)]
    pub max: c_void, 
}

/// `AzNamedGridLine` struct
#[pyclass(name = "NamedGridLine")]
pub struct AzNamedGridLine {
    #[pyo3(get, set)]
    pub name: String, 
    #[pyo3(get, set)]
    pub span_count: i32, 
}

/// `AzScrollbarColorCustom` struct
#[pyclass(name = "ScrollbarColorCustom")]
pub struct AzScrollbarColorCustom {
    #[pyo3(get, set)]
    pub thumb: ColorU, 
    #[pyo3(get, set)]
    pub track: ColorU, 
}

/// `AzShapeInset` struct
#[pyclass(name = "ShapeInset")]
pub struct AzShapeInset {
    #[pyo3(get, set)]
    pub top: f32, 
    #[pyo3(get, set)]
    pub right: f32, 
    #[pyo3(get, set)]
    pub bottom: f32, 
    #[pyo3(get, set)]
    pub left: f32, 
    #[pyo3(get, set)]
    pub border_radius: OptionF32, 
}

/// `AzShapePath` struct
#[pyclass(name = "ShapePath")]
pub struct AzShapePath {
    #[pyo3(get, set)]
    pub data: String, 
}

/// `AzShapeEllipse` struct
#[pyclass(name = "ShapeEllipse")]
pub struct AzShapeEllipse {
    #[pyo3(get, set)]
    pub center: ShapePoint, 
    #[pyo3(get, set)]
    pub radius_x: f32, 
    #[pyo3(get, set)]
    pub radius_y: f32, 
}

/// `AzShapePoint` struct
#[pyclass(name = "ShapePoint")]
pub struct AzShapePoint {
    #[pyo3(get, set)]
    pub x: f32, 
    #[pyo3(get, set)]
    pub y: f32, 
}

/// `AzLayoutRect` struct
#[pyclass(name = "LayoutRect")]
pub struct AzLayoutRect {
    #[pyo3(get, set)]
    pub origin: LayoutPoint, 
    #[pyo3(get, set)]
    pub size: LayoutSize, 
}

/// `AzLayoutPoint` struct
#[pyclass(name = "LayoutPoint")]
pub struct AzLayoutPoint {
    #[pyo3(get, set)]
    pub x: isize, 
    #[pyo3(get, set)]
    pub y: isize, 
}

/// `AzPhysicalPosition` struct
#[pyclass(name = "PhysicalPosition")]
pub struct AzPhysicalPosition {
    #[pyo3(get, set)]
    pub x: T, 
    #[pyo3(get, set)]
    pub y: T, 
}

/// `AzLinuxDecorationsState` struct
#[pyclass(name = "LinuxDecorationsState")]
pub struct AzLinuxDecorationsState {
    #[pyo3(get, set)]
    pub is_dragging_titlebar: bool, 
    #[pyo3(get, set)]
    pub close_button_hover: bool, 
    #[pyo3(get, set)]
    pub maximize_button_hover: bool, 
    #[pyo3(get, set)]
    pub minimize_button_hover: bool, 
}

/// `AzButton` struct
#[pyclass(name = "Button")]
pub struct AzButton {
    #[pyo3(get, set)]
    pub label: String, 
    #[pyo3(get, set)]
    pub image: OptionImageRef, 
    #[pyo3(get, set)]
    pub container_style: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub label_style: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub image_style: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub on_click: OptionButtonOnClick, 
}

/// `AzButtonOnClick` struct
#[pyclass(name = "ButtonOnClick")]
pub struct AzButtonOnClick {
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// `AzFileInput` struct
#[pyclass(name = "FileInput")]
pub struct AzFileInput {
    #[pyo3(get, set)]
    pub state: FileInputStateWrapper, 
    #[pyo3(get, set)]
    pub default_text: String, 
    #[pyo3(get, set)]
    pub image: OptionImageRef, 
    #[pyo3(get, set)]
    pub container_style: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub label_style: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub image_style: NodeDataInlineCssPropertyVec, 
}

/// `AzFileInputStateWrapper` struct
#[pyclass(name = "FileInputStateWrapper")]
pub struct AzFileInputStateWrapper {
    #[pyo3(get, set)]
    pub inner: FileInputState, 
    #[pyo3(get, set)]
    pub on_path_change: OptionFileInputOnPathChange, 
    #[pyo3(get, set)]
    pub file_dialog_title: String, 
    #[pyo3(get, set)]
    pub default_dir: OptionString, 
}

/// `AzFileInputState` struct
#[pyclass(name = "FileInputState")]
pub struct AzFileInputState {
    #[pyo3(get, set)]
    pub path: OptionString, 
}

/// `AzFileInputOnPathChange` struct
#[pyclass(name = "FileInputOnPathChange")]
pub struct AzFileInputOnPathChange {
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// `AzFileInputOnPathChangeCallback` struct
#[pyclass(name = "FileInputOnPathChangeCallback")]
pub struct AzFileInputOnPathChangeCallback {
}

/// `AzCheckBox` struct
#[pyclass(name = "CheckBox")]
pub struct AzCheckBox {
    #[pyo3(get, set)]
    pub state: CheckBoxStateWrapper, 
    #[pyo3(get, set)]
    pub container_style: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub content_style: NodeDataInlineCssPropertyVec, 
}

/// `AzCheckBoxStateWrapper` struct
#[pyclass(name = "CheckBoxStateWrapper")]
pub struct AzCheckBoxStateWrapper {
    #[pyo3(get, set)]
    pub inner: CheckBoxState, 
    #[pyo3(get, set)]
    pub on_toggle: OptionCheckBoxOnToggle, 
}

/// `AzCheckBoxOnToggle` struct
#[pyclass(name = "CheckBoxOnToggle")]
pub struct AzCheckBoxOnToggle {
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// `AzCheckBoxState` struct
#[pyclass(name = "CheckBoxState")]
pub struct AzCheckBoxState {
    #[pyo3(get, set)]
    pub checked: bool, 
}

/// `AzColorInput` struct
#[pyclass(name = "ColorInput")]
pub struct AzColorInput {
    #[pyo3(get, set)]
    pub state: ColorInputStateWrapper, 
    #[pyo3(get, set)]
    pub style: NodeDataInlineCssPropertyVec, 
}

/// `AzColorInputStateWrapper` struct
#[pyclass(name = "ColorInputStateWrapper")]
pub struct AzColorInputStateWrapper {
    #[pyo3(get, set)]
    pub inner: ColorInputState, 
    #[pyo3(get, set)]
    pub title: String, 
    #[pyo3(get, set)]
    pub on_value_change: OptionColorInputOnValueChange, 
}

/// `AzColorInputState` struct
#[pyclass(name = "ColorInputState")]
pub struct AzColorInputState {
    #[pyo3(get, set)]
    pub color: ColorU, 
}

/// `AzColorInputOnValueChange` struct
#[pyclass(name = "ColorInputOnValueChange")]
pub struct AzColorInputOnValueChange {
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// `AzColorInputOnValueChangeCallback` struct
#[pyclass(name = "ColorInputOnValueChangeCallback")]
pub struct AzColorInputOnValueChangeCallback {
}

/// `AzTextInput` struct
#[pyclass(name = "TextInput")]
pub struct AzTextInput {
    #[pyo3(get, set)]
    pub state: TextInputStateWrapper, 
    #[pyo3(get, set)]
    pub placeholder_style: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub container_style: NodeDataInlineCssPropertyVec, 
    #[pyo3(get, set)]
    pub label_style: NodeDataInlineCssPropertyVec, 
}

/// `AzTextInputStateWrapper` struct
#[pyclass(name = "TextInputStateWrapper")]
pub struct AzTextInputStateWrapper {
    #[pyo3(get, set)]
    pub inner: TextInputState, 
    #[pyo3(get, set)]
    pub on_text_input: OptionTextInputOnTextInput, 
    #[pyo3(get, set)]
    pub on_virtual_key_down: OptionTextInputOnVirtualKeyDown, 
    #[pyo3(get, set)]
    pub on_focus_lost: OptionTextInputOnFocusLost, 
    #[pyo3(get, set)]
    pub update_text_input_before_calling_focus_lost_fn: bool, 
    #[pyo3(get, set)]
    pub update_text_input_before_calling_vk_down_fn: bool, 
    #[pyo3(get, set)]
    pub cursor_animation: OptionTimerId, 
}

/// `AzTextInputState` struct
#[pyclass(name = "TextInputState")]
pub struct AzTextInputState {
    #[pyo3(get, set)]
    pub text: U32Vec, 
    #[pyo3(get, set)]
    pub placeholder: OptionString, 
    #[pyo3(get, set)]
    pub max_len: usize, 
    #[pyo3(get, set)]
    pub selection: OptionTextInputSelection, 
    #[pyo3(get, set)]
    pub cursor_pos: usize, 
}

/// `AzTextInputSelectionRange` struct
#[pyclass(name = "TextInputSelectionRange")]
pub struct AzTextInputSelectionRange {
    #[pyo3(get, set)]
    pub from: usize, 
    #[pyo3(get, set)]
    pub to: usize, 
}

/// `AzTextInputOnTextInput` struct
#[pyclass(name = "TextInputOnTextInput")]
pub struct AzTextInputOnTextInput {
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// `AzTextInputOnTextInputCallback` struct
#[pyclass(name = "TextInputOnTextInputCallback")]
pub struct AzTextInputOnTextInputCallback {
}

/// `AzTextInputOnVirtualKeyDown` struct
#[pyclass(name = "TextInputOnVirtualKeyDown")]
pub struct AzTextInputOnVirtualKeyDown {
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// `AzTextInputOnVirtualKeyDownCallback` struct
#[pyclass(name = "TextInputOnVirtualKeyDownCallback")]
pub struct AzTextInputOnVirtualKeyDownCallback {
}

/// `AzTextInputOnFocusLost` struct
#[pyclass(name = "TextInputOnFocusLost")]
pub struct AzTextInputOnFocusLost {
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// `AzTextInputOnFocusLostCallback` struct
#[pyclass(name = "TextInputOnFocusLostCallback")]
pub struct AzTextInputOnFocusLostCallback {
}

/// `AzOnTextInputReturn` struct
#[pyclass(name = "OnTextInputReturn")]
pub struct AzOnTextInputReturn {
    #[pyo3(get, set)]
    pub update: Update, 
    #[pyo3(get, set)]
    pub valid: TextInputValid, 
}

/// `AzNumberInput` struct
#[pyclass(name = "NumberInput")]
pub struct AzNumberInput {
    #[pyo3(get, set)]
    pub text_input: TextInput, 
    #[pyo3(get, set)]
    pub state: NumberInputStateWrapper, 
}

/// `AzNumberInputStateWrapper` struct
#[pyclass(name = "NumberInputStateWrapper")]
pub struct AzNumberInputStateWrapper {
    #[pyo3(get, set)]
    pub inner: NumberInputState, 
    #[pyo3(get, set)]
    pub on_value_change: OptionNumberInputOnValueChange, 
    #[pyo3(get, set)]
    pub on_focus_lost: OptionNumberInputOnFocusLost, 
}

/// `AzNumberInputState` struct
#[pyclass(name = "NumberInputState")]
pub struct AzNumberInputState {
    #[pyo3(get, set)]
    pub previous: f32, 
    #[pyo3(get, set)]
    pub number: f32, 
    #[pyo3(get, set)]
    pub min: f32, 
    #[pyo3(get, set)]
    pub max: f32, 
}

/// `AzNumberInputOnValueChange` struct
#[pyclass(name = "NumberInputOnValueChange")]
pub struct AzNumberInputOnValueChange {
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// `AzNumberInputOnValueChangeCallback` struct
#[pyclass(name = "NumberInputOnValueChangeCallback")]
pub struct AzNumberInputOnValueChangeCallback {
}

/// `AzNumberInputOnFocusLost` struct
#[pyclass(name = "NumberInputOnFocusLost")]
pub struct AzNumberInputOnFocusLost {
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// `AzNumberInputOnFocusLostCallback` struct
#[pyclass(name = "NumberInputOnFocusLostCallback")]
pub struct AzNumberInputOnFocusLostCallback {
}

/// `AzProgressBar` struct
#[pyclass(name = "ProgressBar")]
pub struct AzProgressBar {
    #[pyo3(get, set)]
    pub state: ProgressBarState, 
    #[pyo3(get, set)]
    pub height: PixelValue, 
    #[pyo3(get, set)]
    pub bar_background: StyleBackgroundContentVec, 
    #[pyo3(get, set)]
    pub container_background: StyleBackgroundContentVec, 
}

/// `AzProgressBarState` struct
#[pyclass(name = "ProgressBarState")]
pub struct AzProgressBarState {
    #[pyo3(get, set)]
    pub percent_done: f32, 
    #[pyo3(get, set)]
    pub display_percentage: bool, 
}

/// `AzTabHeader` struct
#[pyclass(name = "TabHeader")]
pub struct AzTabHeader {
    #[pyo3(get, set)]
    pub tabs: StringVec, 
    #[pyo3(get, set)]
    pub active_tab: usize, 
    #[pyo3(get, set)]
    pub on_click: OptionTabOnClick, 
}

/// `AzTabOnClick` struct
#[pyclass(name = "TabOnClick")]
pub struct AzTabOnClick {
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// `AzFrame` struct
#[pyclass(name = "Frame")]
pub struct AzFrame {
    #[pyo3(get, set)]
    pub title: String, 
    #[pyo3(get, set)]
    pub flex_grow: f32, 
    #[pyo3(get, set)]
    pub content: Dom, 
}

/// List view, optionally able to lazy-load data
#[pyclass(name = "ListView")]
pub struct AzListView {
    #[pyo3(get, set)]
    pub columns: StringVec, 
    #[pyo3(get, set)]
    pub rows: ListViewRowVec, 
    #[pyo3(get, set)]
    pub sorted_by: OptionUsize, 
    #[pyo3(get, set)]
    pub scroll_offset: PixelValueNoPercent, 
    #[pyo3(get, set)]
    pub content_height: OptionPixelValueNoPercent, 
    #[pyo3(get, set)]
    pub column_context_menu: OptionMenu, 
    #[pyo3(get, set)]
    pub on_lazy_load_scroll: OptionListViewOnLazyLoadScroll, 
    #[pyo3(get, set)]
    pub on_column_click: OptionListViewOnColumnClick, 
    #[pyo3(get, set)]
    pub on_row_click: OptionListViewOnRowClick, 
}

/// Row of the ListView
#[pyclass(name = "ListViewRow")]
pub struct AzListViewRow {
    #[pyo3(get, set)]
    pub cells: DomVec, 
    #[pyo3(get, set)]
    pub height: OptionPixelValueNoPercent, 
}

/// `AzListViewOnLazyLoadScroll` struct
#[pyclass(name = "ListViewOnLazyLoadScroll")]
pub struct AzListViewOnLazyLoadScroll {
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// `AzListViewOnColumnClick` struct
#[pyclass(name = "ListViewOnColumnClick")]
pub struct AzListViewOnColumnClick {
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// `AzListViewOnRowClick` struct
#[pyclass(name = "ListViewOnRowClick")]
pub struct AzListViewOnRowClick {
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// `AzIFrameNode` struct
#[pyclass(name = "IFrameNode")]
pub struct AzIFrameNode {
    #[pyo3(get, set)]
    pub callback: IFrameCallback, 
    #[pyo3(get, set)]
    pub data: RefAny, 
}

/// `AzListViewState` struct
#[pyclass(name = "ListViewState")]
pub struct AzListViewState {
    #[pyo3(get, set)]
    pub columns: StringVec, 
    #[pyo3(get, set)]
    pub sorted_by: OptionUsize, 
    #[pyo3(get, set)]
    pub current_row_count: usize, 
    #[pyo3(get, set)]
    pub scroll_offset: PixelValueNoPercent, 
    #[pyo3(get, set)]
    pub current_scroll_position: LogicalPosition, 
    #[pyo3(get, set)]
    pub current_content_height: LogicalSize, 
}

/// `AzTabHeaderState` struct
#[pyclass(name = "TabHeaderState")]
pub struct AzTabHeaderState {
    #[pyo3(get, set)]
    pub active_tab: usize, 
}

/// OpenGL texture, use `ReadOnlyWindow::create_texture` to create a texture
#[pyclass(name = "Texture")]
pub struct AzTexture {
    #[pyo3(get, set)]
    pub texture_id: GLuint, 
    #[pyo3(get, set)]
    pub flags: TextureFlags, 
    #[pyo3(get, set)]
    pub size: PhysicalSizeU32, 
    #[pyo3(get, set)]
    pub background_color: ColorU, 
    #[pyo3(get, set)]
    pub gl_context: GlContextPtr, 
    #[pyo3(get, set)]
    pub format: RawImageFormat, 
    #[pyo3(get, set)]
    pub refcount: c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// Passing *const c_void is not easily possible when generating APIs, so this wrapper struct is for easier API generation
#[pyclass(name = "GlVoidPtrConst")]
pub struct AzGlVoidPtrConst {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzGlVoidPtrMut` struct
#[pyclass(name = "GlVoidPtrMut")]
pub struct AzGlVoidPtrMut {
    #[pyo3(get, set)]
    pub ptr: c_void, 
}

/// `AzTextureFlags` struct
#[pyclass(name = "TextureFlags")]
pub struct AzTextureFlags {
    #[pyo3(get, set)]
    pub is_opaque: bool, 
    #[pyo3(get, set)]
    pub is_video_texture: bool, 
}

/// For .get_gl_precision_format(), but ABI-safe - returning an array or a tuple is not ABI-safe
#[pyclass(name = "GlShaderPrecisionFormatReturn")]
pub struct AzGlShaderPrecisionFormatReturn {
    #[pyo3(get, set)]
    pub _0: GLint, 
    #[pyo3(get, set)]
    pub _1: GLint, 
    #[pyo3(get, set)]
    pub _2: GLint, 
}

/// `AzGlContextPtr` struct
#[pyclass(name = "GlContextPtr")]
pub struct AzGlContextPtr {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub renderer_type: RendererType, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// C-ABI stable reexport of `(U8Vec, u32)`
#[pyclass(name = "GetProgramBinaryReturn")]
pub struct AzGetProgramBinaryReturn {
    #[pyo3(get, set)]
    pub _0: U8Vec, 
    #[pyo3(get, set)]
    pub _1: u32, 
}

/// C-ABI stable reexport of `(i32, u32, AzString)`
#[pyclass(name = "GetActiveAttribReturn")]
pub struct AzGetActiveAttribReturn {
    #[pyo3(get, set)]
    pub _0: i32, 
    #[pyo3(get, set)]
    pub _1: u32, 
    #[pyo3(get, set)]
    pub _2: String, 
}

/// C-ABI stable reexport of `*const gleam::gl::GLsync`
#[pyclass(name = "GLsyncPtr")]
pub struct AzGLsyncPtr {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// C-ABI stable reexport of `(i32, u32, AzString)`
#[pyclass(name = "GetActiveUniformReturn")]
pub struct AzGetActiveUniformReturn {
    #[pyo3(get, set)]
    pub _0: i32, 
    #[pyo3(get, set)]
    pub _1: u32, 
    #[pyo3(get, set)]
    pub _2: String, 
}

/// `AzSvgVertex` struct
#[pyclass(name = "SvgVertex")]
pub struct AzSvgVertex {
    #[pyo3(get, set)]
    pub x: f32, 
    #[pyo3(get, set)]
    pub y: f32, 
}

/// `AzVertexArrayObject` struct
#[pyclass(name = "VertexArrayObject")]
pub struct AzVertexArrayObject {
    #[pyo3(get, set)]
    pub vertex_layout: VertexLayout, 
    #[pyo3(get, set)]
    pub vao_id: GLuint, 
    #[pyo3(get, set)]
    pub gl_context: GlContextPtr, 
    #[pyo3(get, set)]
    pub refcount: c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzVertexBuffer` struct
#[pyclass(name = "VertexBuffer")]
pub struct AzVertexBuffer {
    #[pyo3(get, set)]
    pub vertex_buffer_id: GLuint, 
    #[pyo3(get, set)]
    pub vertex_buffer_len: usize, 
    #[pyo3(get, set)]
    pub vao: VertexArrayObject, 
    #[pyo3(get, set)]
    pub index_buffer_id: GLuint, 
    #[pyo3(get, set)]
    pub index_buffer_len: usize, 
    #[pyo3(get, set)]
    pub index_buffer_format: IndexBufferFormat, 
    #[pyo3(get, set)]
    pub refcount: c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzImageRef` struct
#[pyclass(name = "ImageRef")]
pub struct AzImageRef {
    #[pyo3(get, set)]
    pub data: c_void, 
    #[pyo3(get, set)]
    pub copies: c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzRawImage` struct
#[pyclass(name = "RawImage")]
pub struct AzRawImage {
    #[pyo3(get, set)]
    pub pixels: RawImageData, 
    #[pyo3(get, set)]
    pub width: usize, 
    #[pyo3(get, set)]
    pub height: usize, 
    #[pyo3(get, set)]
    pub premultiplied_alpha: bool, 
    #[pyo3(get, set)]
    pub data_format: RawImageFormat, 
    #[pyo3(get, set)]
    pub tag: U8Vec, 
}

/// `AzImageMask` struct
#[pyclass(name = "ImageMask")]
pub struct AzImageMask {
    #[pyo3(get, set)]
    pub image: ImageRef, 
    #[pyo3(get, set)]
    pub rect: LogicalRect, 
    #[pyo3(get, set)]
    pub repeat: bool, 
}

/// Font metrics structure containing all font-related measurements from the font file tables (head, hhea, and os/2 tables).
#[pyclass(name = "FontMetrics")]
pub struct AzFontMetrics {
    #[pyo3(get, set)]
    pub units_per_em: u16, 
    #[pyo3(get, set)]
    pub font_flags: u16, 
    #[pyo3(get, set)]
    pub x_min: i16, 
    #[pyo3(get, set)]
    pub y_min: i16, 
    #[pyo3(get, set)]
    pub x_max: i16, 
    #[pyo3(get, set)]
    pub y_max: i16, 
    #[pyo3(get, set)]
    pub ascender: i16, 
    #[pyo3(get, set)]
    pub descender: i16, 
    #[pyo3(get, set)]
    pub line_gap: i16, 
    #[pyo3(get, set)]
    pub advance_width_max: u16, 
    #[pyo3(get, set)]
    pub min_left_side_bearing: i16, 
    #[pyo3(get, set)]
    pub min_right_side_bearing: i16, 
    #[pyo3(get, set)]
    pub x_max_extent: i16, 
    #[pyo3(get, set)]
    pub caret_slope_rise: i16, 
    #[pyo3(get, set)]
    pub caret_slope_run: i16, 
    #[pyo3(get, set)]
    pub caret_offset: i16, 
    #[pyo3(get, set)]
    pub num_h_metrics: u16, 
    #[pyo3(get, set)]
    pub x_avg_char_width: i16, 
    #[pyo3(get, set)]
    pub us_weight_class: u16, 
    #[pyo3(get, set)]
    pub us_width_class: u16, 
    #[pyo3(get, set)]
    pub fs_type: u16, 
    #[pyo3(get, set)]
    pub y_subscript_x_size: i16, 
    #[pyo3(get, set)]
    pub y_subscript_y_size: i16, 
    #[pyo3(get, set)]
    pub y_subscript_x_offset: i16, 
    #[pyo3(get, set)]
    pub y_subscript_y_offset: i16, 
    #[pyo3(get, set)]
    pub y_superscript_x_size: i16, 
    #[pyo3(get, set)]
    pub y_superscript_y_size: i16, 
    #[pyo3(get, set)]
    pub y_superscript_x_offset: i16, 
    #[pyo3(get, set)]
    pub y_superscript_y_offset: i16, 
    #[pyo3(get, set)]
    pub y_strikeout_size: i16, 
    #[pyo3(get, set)]
    pub y_strikeout_position: i16, 
    #[pyo3(get, set)]
    pub s_family_class: i16, 
    #[pyo3(get, set)]
    pub panose: [u8; 10], 
    #[pyo3(get, set)]
    pub ul_unicode_range1: u32, 
    #[pyo3(get, set)]
    pub ul_unicode_range2: u32, 
    #[pyo3(get, set)]
    pub ul_unicode_range3: u32, 
    #[pyo3(get, set)]
    pub ul_unicode_range4: u32, 
    #[pyo3(get, set)]
    pub ach_vend_id: u32, 
    #[pyo3(get, set)]
    pub fs_selection: u16, 
    #[pyo3(get, set)]
    pub us_first_char_index: u16, 
    #[pyo3(get, set)]
    pub us_last_char_index: u16, 
    #[pyo3(get, set)]
    pub s_typo_ascender: OptionI16, 
    #[pyo3(get, set)]
    pub s_typo_descender: OptionI16, 
    #[pyo3(get, set)]
    pub s_typo_line_gap: OptionI16, 
    #[pyo3(get, set)]
    pub us_win_ascent: OptionU16, 
    #[pyo3(get, set)]
    pub us_win_descent: OptionU16, 
    #[pyo3(get, set)]
    pub ul_code_page_range1: OptionU32, 
    #[pyo3(get, set)]
    pub ul_code_page_range2: OptionU32, 
    #[pyo3(get, set)]
    pub sx_height: OptionI16, 
    #[pyo3(get, set)]
    pub s_cap_height: OptionI16, 
    #[pyo3(get, set)]
    pub us_default_char: OptionU16, 
    #[pyo3(get, set)]
    pub us_break_char: OptionU16, 
    #[pyo3(get, set)]
    pub us_max_context: OptionU16, 
    #[pyo3(get, set)]
    pub us_lower_optical_point_size: OptionU16, 
    #[pyo3(get, set)]
    pub us_upper_optical_point_size: OptionU16, 
}

/// FontRef is a reference-counted pointer to a parsed font. It holds a *const c_void that points to the actual parsed font data (typically a ParsedFont from the layout crate). The parsed data is managed via atomic reference counting, allowing safe sharing across threads without duplicating the font data.
#[pyclass(name = "FontRef")]
pub struct AzFontRef {
    #[pyo3(get, set)]
    pub parsed: c_void, 
    #[pyo3(get, set)]
    pub copies: c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
    #[pyo3(get, set)]
    pub parsed_destructor: FontRefDestructorCallbackType, 
}

/// Source data of a font file (bytes)
#[pyclass(name = "LoadedFontSource")]
pub struct AzLoadedFontSource {
    #[pyo3(get, set)]
    pub data: U8Vec, 
    #[pyo3(get, set)]
    pub index: u32, 
    #[pyo3(get, set)]
    pub load_outlines: bool, 
}

/// `AzSvg` struct
#[pyclass(name = "Svg")]
pub struct AzSvg {
    #[pyo3(get, set)]
    pub tree: c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzSvgMultiPolygon` struct
#[pyclass(name = "SvgMultiPolygon")]
pub struct AzSvgMultiPolygon {
    #[pyo3(get, set)]
    pub rings: SvgPathVec, 
}

/// `AzSvgCircle` struct
#[pyclass(name = "SvgCircle")]
pub struct AzSvgCircle {
    #[pyo3(get, set)]
    pub center_x: f32, 
    #[pyo3(get, set)]
    pub center_y: f32, 
    #[pyo3(get, set)]
    pub radius: f32, 
}

/// `AzSvgPath` struct
#[pyclass(name = "SvgPath")]
pub struct AzSvgPath {
    #[pyo3(get, set)]
    pub items: SvgPathElementVec, 
}

/// `AzSvgPoint` struct
#[pyclass(name = "SvgPoint")]
pub struct AzSvgPoint {
    #[pyo3(get, set)]
    pub x: f32, 
    #[pyo3(get, set)]
    pub y: f32, 
}

/// `AzSvgVector` struct
#[pyclass(name = "SvgVector")]
pub struct AzSvgVector {
    #[pyo3(get, set)]
    pub x: f64, 
    #[pyo3(get, set)]
    pub y: f64, 
}

/// A line segment in 2D space.
#[pyclass(name = "SvgLine")]
pub struct AzSvgLine {
    #[pyo3(get, set)]
    pub start: SvgPoint, 
    #[pyo3(get, set)]
    pub end: SvgPoint, 
}

/// `AzSvgQuadraticCurve` struct
#[pyclass(name = "SvgQuadraticCurve")]
pub struct AzSvgQuadraticCurve {
    #[pyo3(get, set)]
    pub start: SvgPoint, 
    #[pyo3(get, set)]
    pub ctrl: SvgPoint, 
    #[pyo3(get, set)]
    pub end: SvgPoint, 
}

/// `AzSvgCubicCurve` struct
#[pyclass(name = "SvgCubicCurve")]
pub struct AzSvgCubicCurve {
    #[pyo3(get, set)]
    pub start: SvgPoint, 
    #[pyo3(get, set)]
    pub ctrl_1: SvgPoint, 
    #[pyo3(get, set)]
    pub ctrl_2: SvgPoint, 
    #[pyo3(get, set)]
    pub end: SvgPoint, 
}

/// `AzSvgRect` struct
#[pyclass(name = "SvgRect")]
pub struct AzSvgRect {
    #[pyo3(get, set)]
    pub width: f32, 
    #[pyo3(get, set)]
    pub height: f32, 
    #[pyo3(get, set)]
    pub x: f32, 
    #[pyo3(get, set)]
    pub y: f32, 
    #[pyo3(get, set)]
    pub radius_top_left: f32, 
    #[pyo3(get, set)]
    pub radius_top_right: f32, 
    #[pyo3(get, set)]
    pub radius_bottom_left: f32, 
    #[pyo3(get, set)]
    pub radius_bottom_right: f32, 
}

/// `AzTessellatedSvgNode` struct
#[pyclass(name = "TessellatedSvgNode")]
pub struct AzTessellatedSvgNode {
    #[pyo3(get, set)]
    pub vertices: SvgVertexVec, 
    #[pyo3(get, set)]
    pub indices: U32Vec, 
}

/// `AzSvgDashPattern` struct
#[pyclass(name = "SvgDashPattern")]
pub struct AzSvgDashPattern {
    #[pyo3(get, set)]
    pub offset: f32, 
    #[pyo3(get, set)]
    pub length_1: f32, 
    #[pyo3(get, set)]
    pub gap_1: f32, 
    #[pyo3(get, set)]
    pub length_2: f32, 
    #[pyo3(get, set)]
    pub gap_2: f32, 
    #[pyo3(get, set)]
    pub length_3: f32, 
    #[pyo3(get, set)]
    pub gap_3: f32, 
}

/// `AzSvgStrokeStyle` struct
#[pyclass(name = "SvgStrokeStyle")]
pub struct AzSvgStrokeStyle {
    #[pyo3(get, set)]
    pub start_cap: SvgLineCap, 
    #[pyo3(get, set)]
    pub end_cap: SvgLineCap, 
    #[pyo3(get, set)]
    pub line_join: SvgLineJoin, 
    #[pyo3(get, set)]
    pub dash_pattern: OptionSvgDashPattern, 
    #[pyo3(get, set)]
    pub line_width: f32, 
    #[pyo3(get, set)]
    pub miter_limit: f32, 
    #[pyo3(get, set)]
    pub tolerance: f32, 
    #[pyo3(get, set)]
    pub apply_line_width: bool, 
    #[pyo3(get, set)]
    pub transform: SvgTransform, 
    #[pyo3(get, set)]
    pub anti_alias: bool, 
    #[pyo3(get, set)]
    pub high_quality_aa: bool, 
}

/// `AzLogicalRect` struct
#[pyclass(name = "LogicalRect")]
pub struct AzLogicalRect {
    #[pyo3(get, set)]
    pub origin: LogicalPosition, 
    #[pyo3(get, set)]
    pub size: LogicalSize, 
}

/// `AzCssPath` struct
#[pyclass(name = "CssPath")]
pub struct AzCssPath {
    #[pyo3(get, set)]
    pub selectors: CssPathSelectorVec, 
}

/// `AzTessellatedGPUSvgNode` struct
#[pyclass(name = "TessellatedGPUSvgNode")]
pub struct AzTessellatedGPUSvgNode {
    #[pyo3(get, set)]
    pub vertex_index_buffer: VertexBuffer, 
}

/// `AzTessellatedColoredGPUSvgNode` struct
#[pyclass(name = "TessellatedColoredGPUSvgNode")]
pub struct AzTessellatedColoredGPUSvgNode {
    #[pyo3(get, set)]
    pub vertex_index_buffer: VertexBuffer, 
}

/// `AzShapeCircle` struct
#[pyclass(name = "ShapeCircle")]
pub struct AzShapeCircle {
    #[pyo3(get, set)]
    pub center: ShapePoint, 
    #[pyo3(get, set)]
    pub radius: f32, 
}

/// `AzShapePolygon` struct
#[pyclass(name = "ShapePolygon")]
pub struct AzShapePolygon {
    #[pyo3(get, set)]
    pub points: ShapePointVec, 
}

/// `AzXml` struct
#[pyclass(name = "Xml")]
pub struct AzXml {
    #[pyo3(get, set)]
    pub root: XmlNodeChildVec, 
}

/// `AzSystemTickDiff` struct
#[pyclass(name = "SystemTickDiff")]
pub struct AzSystemTickDiff {
    #[pyo3(get, set)]
    pub tick_diff: u64, 
}

/// `AzSystemTick` struct
#[pyclass(name = "SystemTick")]
pub struct AzSystemTick {
    #[pyo3(get, set)]
    pub tick_counter: u64, 
}

/// `AzSystemTimeDiff` struct
#[pyclass(name = "SystemTimeDiff")]
pub struct AzSystemTimeDiff {
    #[pyo3(get, set)]
    pub secs: u64, 
    #[pyo3(get, set)]
    pub nanos: u32, 
}

/// `AzTimerId` struct
#[pyclass(name = "TimerId")]
pub struct AzTimerId {
    #[pyo3(get, set)]
    pub id: usize, 
}

/// `AzInstantPtr` struct
#[pyclass(name = "InstantPtr")]
pub struct AzInstantPtr {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub clone_fn: InstantPtrCloneCallback, 
    #[pyo3(get, set)]
    pub destructor: InstantPtrDestructorCallback, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzCssDuration` struct
#[pyclass(name = "CssDuration")]
pub struct AzCssDuration {
    #[pyo3(get, set)]
    pub inner: u32, 
}

/// `AzString` struct
#[pyclass(name = "String")]
pub struct AzString {
    #[pyo3(get, set)]
    pub vec: U8Vec, 
}

/// `AzRefstr` struct
#[pyclass(name = "Refstr")]
pub struct AzRefstr {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
}

/// `AzStringPair` struct
#[pyclass(name = "StringPair")]
pub struct AzStringPair {
    #[pyo3(get, set)]
    pub key: String, 
    #[pyo3(get, set)]
    pub value: String, 
}

/// `AzStringSet` struct
#[pyclass(name = "StringSet")]
pub struct AzStringSet {
    #[pyo3(get, set)]
    pub inner: String, 
}

/// Wrapper over a Rust-allocated `Vec<ListViewRow>
#[pyclass(name = "ListViewRowVec")]
pub struct AzListViewRowVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: ListViewRowVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<StyleFilter>
#[pyclass(name = "StyleFilterVec")]
pub struct AzStyleFilterVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StyleFilterVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<AccessibilityState>
#[pyclass(name = "AccessibilityStateVec")]
pub struct AzAccessibilityStateVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: AccessibilityStateVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<MenuItem>
#[pyclass(name = "MenuItemVec")]
pub struct AzMenuItemVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: MenuItemVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<StyleFontFamily>
#[pyclass(name = "StyleFontFamilyVec")]
pub struct AzStyleFontFamilyVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StyleFontFamilyVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<Dom>
#[pyclass(name = "DomVec")]
pub struct AzDomVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: DomVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<IdOrClass>
#[pyclass(name = "IdOrClassVec")]
pub struct AzIdOrClassVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: IdOrClassVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<NodeDataInlineCssProperty>
#[pyclass(name = "NodeDataInlineCssPropertyVec")]
pub struct AzNodeDataInlineCssPropertyVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: NodeDataInlineCssPropertyVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundContent>
#[pyclass(name = "StyleBackgroundContentVec")]
pub struct AzStyleBackgroundContentVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StyleBackgroundContentVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundPosition>
#[pyclass(name = "StyleBackgroundPositionVec")]
pub struct AzStyleBackgroundPositionVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StyleBackgroundPositionVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundRepeat>
#[pyclass(name = "StyleBackgroundRepeatVec")]
pub struct AzStyleBackgroundRepeatVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StyleBackgroundRepeatVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundSize>
#[pyclass(name = "StyleBackgroundSizeVec")]
pub struct AzStyleBackgroundSizeVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StyleBackgroundSizeVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<StyleTransform>
#[pyclass(name = "StyleTransformVec")]
pub struct AzStyleTransformVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StyleTransformVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<SvgMultiPolygon>
#[pyclass(name = "SvgMultiPolygonVec")]
pub struct AzSvgMultiPolygonVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: SvgMultiPolygonVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<SvgSimpleNode>
#[pyclass(name = "SvgSimpleNodeVec")]
pub struct AzSvgSimpleNodeVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: SvgSimpleNodeVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<SvgPath>
#[pyclass(name = "SvgPathVec")]
pub struct AzSvgPathVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: SvgPathVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<SvgPathElement>
#[pyclass(name = "SvgPathElementVec")]
pub struct AzSvgPathElementVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: SvgPathElementVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<SvgVertex>
#[pyclass(name = "SvgVertexVec")]
pub struct AzSvgVertexVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: SvgVertexVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<u32>
#[pyclass(name = "U32Vec")]
pub struct AzU32Vec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: U32VecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<VirtualKeyCode>
#[pyclass(name = "VirtualKeyCodeVec")]
pub struct AzVirtualKeyCodeVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: VirtualKeyCodeVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<CascadeInfo>
#[pyclass(name = "CascadeInfoVec")]
pub struct AzCascadeInfoVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: CascadeInfoVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<CssDeclaration>
#[pyclass(name = "CssDeclarationVec")]
pub struct AzCssDeclarationVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: CssDeclarationVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<CssPathSelector>
#[pyclass(name = "CssPathSelectorVec")]
pub struct AzCssPathSelectorVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: CssPathSelectorVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<Stylesheet>
#[pyclass(name = "StylesheetVec")]
pub struct AzStylesheetVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StylesheetVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<CssRuleBlock>
#[pyclass(name = "CssRuleBlockVec")]
pub struct AzCssRuleBlockVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: CssRuleBlockVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<u16>
#[pyclass(name = "U16Vec")]
pub struct AzU16Vec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: U16VecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<f32>
#[pyclass(name = "F32Vec")]
pub struct AzF32Vec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: F32VecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<u8>
#[pyclass(name = "U8Vec")]
pub struct AzU8Vec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: U8VecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<GLuint>
#[pyclass(name = "GLuintVec")]
pub struct AzGLuintVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: GLuintVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<GLint>
#[pyclass(name = "GLintVec")]
pub struct AzGLintVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: GLintVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<String>
#[pyclass(name = "StringVec")]
pub struct AzStringVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StringVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<StringPair>
#[pyclass(name = "StringPairVec")]
pub struct AzStringPairVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StringPairVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<NormalizedLinearColorStop>
#[pyclass(name = "NormalizedLinearColorStopVec")]
pub struct AzNormalizedLinearColorStopVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: NormalizedLinearColorStopVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<NormalizedRadialColorStop>
#[pyclass(name = "NormalizedRadialColorStopVec")]
pub struct AzNormalizedRadialColorStopVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: NormalizedRadialColorStopVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<NodeId>
#[pyclass(name = "NodeIdVec")]
pub struct AzNodeIdVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: NodeIdVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<NodeHierarchyItem>
#[pyclass(name = "NodeHierarchyItemVec")]
pub struct AzNodeHierarchyItemVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: NodeHierarchyItemVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<StyledNode>
#[pyclass(name = "StyledNodeVec")]
pub struct AzStyledNodeVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: StyledNodeVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<TagIdToNodeIdMapping>
#[pyclass(name = "TagIdToNodeIdMappingVec")]
pub struct AzTagIdToNodeIdMappingVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: TagIdToNodeIdMappingVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<ParentWithNodeDepth>
#[pyclass(name = "ParentWithNodeDepthVec")]
pub struct AzParentWithNodeDepthVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: ParentWithNodeDepthVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<NodeData>
#[pyclass(name = "NodeDataVec")]
pub struct AzNodeDataVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: NodeDataVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<Attribute>
#[pyclass(name = "AttributeVec")]
pub struct AzAttributeVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: AttributeVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<CoreCallbackData>
#[pyclass(name = "CoreCallbackDataVec")]
pub struct AzCoreCallbackDataVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: CoreCallbackDataVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<AccessibilityAction>
#[pyclass(name = "AccessibilityActionVec")]
pub struct AzAccessibilityActionVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: AccessibilityActionVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<XmlNodeChild>
#[pyclass(name = "XmlNodeChildVec")]
pub struct AzXmlNodeChildVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: XmlNodeChildVecDestructor, 
}

/// Wrapper over a Rust-allocated `Vec<GridTrackSizing>
#[pyclass(name = "GridTrackSizingVec")]
pub struct AzGridTrackSizingVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: GridTrackSizingVecDestructor, 
}

/// `AzGLbooleanVecRefMut` struct
#[pyclass(name = "GLbooleanVecRefMut")]
pub struct AzGLbooleanVecRefMut {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
}

/// `AzRefstrVecRef` struct
#[pyclass(name = "RefstrVecRef")]
pub struct AzRefstrVecRef {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
}

/// `AzGLfloatVecRefMut` struct
#[pyclass(name = "GLfloatVecRefMut")]
pub struct AzGLfloatVecRefMut {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
}

/// `AzU8VecRefMut` struct
#[pyclass(name = "U8VecRefMut")]
pub struct AzU8VecRefMut {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
}

/// `AzTessellatedSvgNodeVecRef` struct
#[pyclass(name = "TessellatedSvgNodeVecRef")]
pub struct AzTessellatedSvgNodeVecRef {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
}

/// `AzF32VecRef` struct
#[pyclass(name = "F32VecRef")]
pub struct AzF32VecRef {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
}

/// `AzGLuintVecRef` struct
#[pyclass(name = "GLuintVecRef")]
pub struct AzGLuintVecRef {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
}

/// `AzI32VecRef` struct
#[pyclass(name = "I32VecRef")]
pub struct AzI32VecRef {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
}

/// `AzU8VecRef` struct
#[pyclass(name = "U8VecRef")]
pub struct AzU8VecRef {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
}

/// `AzGLintVecRefMut` struct
#[pyclass(name = "GLintVecRefMut")]
pub struct AzGLintVecRefMut {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
}

/// `AzGLenumVecRef` struct
#[pyclass(name = "GLenumVecRef")]
pub struct AzGLenumVecRef {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
}

/// `AzGLint64VecRefMut` struct
#[pyclass(name = "GLint64VecRefMut")]
pub struct AzGLint64VecRefMut {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
}

/// `AzVertexAttributeVec` struct
#[pyclass(name = "VertexAttributeVec")]
pub struct AzVertexAttributeVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: VertexAttributeVecDestructor, 
}

/// `AzDebugMessageVec` struct
#[pyclass(name = "DebugMessageVec")]
pub struct AzDebugMessageVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: DebugMessageVecDestructor, 
}

/// `AzShapePointVec` struct
#[pyclass(name = "ShapePointVec")]
pub struct AzShapePointVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: ShapePointVecDestructor, 
}

/// `AzMonitorVec` struct
#[pyclass(name = "MonitorVec")]
pub struct AzMonitorVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: MonitorVecDestructor, 
}

/// `AzVideoModeVec` struct
#[pyclass(name = "VideoModeVec")]
pub struct AzVideoModeVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: VideoModeVecDestructor, 
}

/// `AzXWindowTypeVec` struct
#[pyclass(name = "XWindowTypeVec")]
pub struct AzXWindowTypeVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: XWindowTypeVecDestructor, 
}

/// `AzScanCodeVec` struct
#[pyclass(name = "ScanCodeVec")]
pub struct AzScanCodeVec {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub len: usize, 
    #[pyo3(get, set)]
    pub cap: usize, 
    #[pyo3(get, set)]
    pub destructor: ScanCodeVecDestructor, 
}

/// `AzSvgParseOptions` struct
#[pyclass(name = "SvgParseOptions")]
pub struct AzSvgParseOptions {
    #[pyo3(get, set)]
    pub relative_image_path: OptionString, 
    #[pyo3(get, set)]
    pub dpi: f32, 
    #[pyo3(get, set)]
    pub default_font_family: String, 
    #[pyo3(get, set)]
    pub font_size: f32, 
    #[pyo3(get, set)]
    pub languages: StringVec, 
    #[pyo3(get, set)]
    pub shape_rendering: ShapeRendering, 
    #[pyo3(get, set)]
    pub text_rendering: TextRendering, 
    #[pyo3(get, set)]
    pub image_rendering: ImageRendering, 
    #[pyo3(get, set)]
    pub keep_named_groups: bool, 
    #[pyo3(get, set)]
    pub fontdb: FontDatabase, 
}

/// `AzSvgXmlOptions` struct
#[pyclass(name = "SvgXmlOptions")]
pub struct AzSvgXmlOptions {
    #[pyo3(get, set)]
    pub use_single_quote: bool, 
    #[pyo3(get, set)]
    pub indent: Indent, 
    #[pyo3(get, set)]
    pub attributes_indent: Indent, 
}

/// `AzSvgRenderOptions` struct
#[pyclass(name = "SvgRenderOptions")]
pub struct AzSvgRenderOptions {
    #[pyo3(get, set)]
    pub target_size: OptionLayoutSize, 
    #[pyo3(get, set)]
    pub background_color: OptionColorU, 
    #[pyo3(get, set)]
    pub fit: SvgFitTo, 
    #[pyo3(get, set)]
    pub transform: SvgRenderTransform, 
}

/// `AzRendererOptions` struct
#[pyclass(name = "RendererOptions")]
pub struct AzRendererOptions {
    #[pyo3(get, set)]
    pub vsync: Vsync, 
    #[pyo3(get, set)]
    pub srgb: Srgb, 
    #[pyo3(get, set)]
    pub hw_accel: HwAcceleration, 
}

/// `AzDuplicatedNamespaceError` struct
#[pyclass(name = "DuplicatedNamespaceError")]
pub struct AzDuplicatedNamespaceError {
    #[pyo3(get, set)]
    pub ns: String, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzUnknownNamespaceError` struct
#[pyclass(name = "UnknownNamespaceError")]
pub struct AzUnknownNamespaceError {
    #[pyo3(get, set)]
    pub ns: String, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzUnexpectedCloseTagError` struct
#[pyclass(name = "UnexpectedCloseTagError")]
pub struct AzUnexpectedCloseTagError {
    #[pyo3(get, set)]
    pub expected: String, 
    #[pyo3(get, set)]
    pub actual: String, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzUnknownEntityReferenceError` struct
#[pyclass(name = "UnknownEntityReferenceError")]
pub struct AzUnknownEntityReferenceError {
    #[pyo3(get, set)]
    pub entity: String, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzDuplicatedAttributeError` struct
#[pyclass(name = "DuplicatedAttributeError")]
pub struct AzDuplicatedAttributeError {
    #[pyo3(get, set)]
    pub attribute: String, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzXmlTextError` struct
#[pyclass(name = "XmlTextError")]
pub struct AzXmlTextError {
    #[pyo3(get, set)]
    pub stream_error: XmlStreamError, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzNonXmlCharError` struct
#[pyclass(name = "NonXmlCharError")]
pub struct AzNonXmlCharError {
    #[pyo3(get, set)]
    pub ch: u32, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzInvalidCharError` struct
#[pyclass(name = "InvalidCharError")]
pub struct AzInvalidCharError {
    #[pyo3(get, set)]
    pub expected: u8, 
    #[pyo3(get, set)]
    pub got: u8, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzInvalidCharMultipleError` struct
#[pyclass(name = "InvalidCharMultipleError")]
pub struct AzInvalidCharMultipleError {
    #[pyo3(get, set)]
    pub expected: u8, 
    #[pyo3(get, set)]
    pub got: U8Vec, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzInvalidQuoteError` struct
#[pyclass(name = "InvalidQuoteError")]
pub struct AzInvalidQuoteError {
    #[pyo3(get, set)]
    pub got: u8, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzInvalidSpaceError` struct
#[pyclass(name = "InvalidSpaceError")]
pub struct AzInvalidSpaceError {
    #[pyo3(get, set)]
    pub got: u8, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzInvalidStringError` struct
#[pyclass(name = "InvalidStringError")]
pub struct AzInvalidStringError {
    #[pyo3(get, set)]
    pub got: String, 
    #[pyo3(get, set)]
    pub pos: XmlTextPos, 
}

/// `AzMalformedHierarchyError` struct
#[pyclass(name = "MalformedHierarchyError")]
pub struct AzMalformedHierarchyError {
    #[pyo3(get, set)]
    pub expected: String, 
    #[pyo3(get, set)]
    pub got: String, 
}

/// Has all the necessary information about the style CSS path
#[pyclass(name = "CascadeInfo")]
pub struct AzCascadeInfo {
    #[pyo3(get, set)]
    pub index_in_parent: u32, 
    #[pyo3(get, set)]
    pub is_last_child: bool, 
}

/// `AzVirtualKeyCodeCombo` struct
#[pyclass(name = "VirtualKeyCodeCombo")]
pub struct AzVirtualKeyCodeCombo {
    #[pyo3(get, set)]
    pub keys: VirtualKeyCodeVec, 
}

/// `AzInterpolateResolver` struct
#[pyclass(name = "InterpolateResolver")]
pub struct AzInterpolateResolver {
    #[pyo3(get, set)]
    pub interpolate_func: AnimationInterpolationFunction, 
    #[pyo3(get, set)]
    pub parent_rect_width: f32, 
    #[pyo3(get, set)]
    pub parent_rect_height: f32, 
    #[pyo3(get, set)]
    pub current_rect_width: f32, 
    #[pyo3(get, set)]
    pub current_rect_height: f32, 
}

/// `AzRefCount` struct
#[pyclass(name = "RefCount")]
pub struct AzRefCount {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzRefAny` struct
#[pyclass(name = "RefAny")]
pub struct AzRefAny {
    #[pyo3(get, set)]
    pub _internal_ptr: c_void, 
    #[pyo3(get, set)]
    pub sharing_info: RefCount, 
    #[pyo3(get, set)]
    pub instance_id: u64, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzDebugMessage` struct
#[pyclass(name = "DebugMessage")]
pub struct AzDebugMessage {
    #[pyo3(get, set)]
    pub message: String, 
    #[pyo3(get, set)]
    pub source: GLenum, 
    #[pyo3(get, set)]
    pub ty: GLenum, 
    #[pyo3(get, set)]
    pub id: GLenum, 
    #[pyo3(get, set)]
    pub severity: GLenum, 
}

/// `AzAppConfig` struct
#[pyclass(name = "AppConfig")]
pub struct AzAppConfig {
    #[pyo3(get, set)]
    pub log_level: AppLogLevel, 
    #[pyo3(get, set)]
    pub enable_visual_panic_hook: bool, 
    #[pyo3(get, set)]
    pub enable_logging_on_panic: bool, 
    #[pyo3(get, set)]
    pub enable_tab_navigation: bool, 
    #[pyo3(get, set)]
    pub termination_behavior: AppTerminationBehavior, 
}

/// `AzApp` struct
#[pyclass(name = "App")]
pub struct AzApp {
    #[pyo3(get, set)]
    pub ptr: c_void, 
    #[pyo3(get, set)]
    pub run_destructor: bool, 
}

/// `AzStyleCursor` enum
#[pyclass(name = "StyleCursor")]
#[repr(transparent)]
pub struct AzStyleCursorEnumWrapper {
    pub inner: AzStyleCursor,
}

/// `AzWindowEventFilter` enum
#[pyclass(name = "WindowEventFilter")]
#[repr(transparent)]
pub struct AzWindowEventFilterEnumWrapper {
    pub inner: AzWindowEventFilter,
}

/// `AzWindowTheme` enum
#[pyclass(name = "WindowTheme")]
#[repr(transparent)]
pub struct AzWindowThemeEnumWrapper {
    pub inner: AzWindowTheme,
}

/// `AzMouseCursorType` enum
#[pyclass(name = "MouseCursorType")]
#[repr(transparent)]
pub struct AzMouseCursorTypeEnumWrapper {
    pub inner: AzMouseCursorType,
}

/// `AzWindowFrame` enum
#[pyclass(name = "WindowFrame")]
#[repr(transparent)]
pub struct AzWindowFrameEnumWrapper {
    pub inner: AzWindowFrame,
}

/// `AzUserAttentionType` enum
#[pyclass(name = "UserAttentionType")]
#[repr(transparent)]
pub struct AzUserAttentionTypeEnumWrapper {
    pub inner: AzUserAttentionType,
}

/// `AzHwAcceleration` enum
#[pyclass(name = "HwAcceleration")]
#[repr(transparent)]
pub struct AzHwAccelerationEnumWrapper {
    pub inner: AzHwAcceleration,
}

/// `AzVsync` enum
#[pyclass(name = "Vsync")]
#[repr(transparent)]
pub struct AzVsyncEnumWrapper {
    pub inner: AzVsync,
}

/// `AzXWindowType` enum
#[pyclass(name = "XWindowType")]
#[repr(transparent)]
pub struct AzXWindowTypeEnumWrapper {
    pub inner: AzXWindowType,
}

/// `AzWindowIcon` enum
#[pyclass(name = "WindowIcon")]
#[repr(transparent)]
pub struct AzWindowIconEnumWrapper {
    pub inner: AzWindowIcon,
}

/// `AzWindowType` enum
#[pyclass(name = "WindowType")]
#[repr(transparent)]
pub struct AzWindowTypeEnumWrapper {
    pub inner: AzWindowType,
}

/// `AzIFrameCallbackReason` enum
#[pyclass(name = "IFrameCallbackReason")]
#[repr(transparent)]
pub struct AzIFrameCallbackReasonEnumWrapper {
    pub inner: AzIFrameCallbackReason,
}

/// `AzLayoutCallback` enum
#[pyclass(name = "LayoutCallback")]
#[repr(transparent)]
pub struct AzLayoutCallbackEnumWrapper {
    pub inner: AzLayoutCallback,
}

/// List of core DOM node types built into `azul`. This enum defines the building blocks of the UI, similar to HTML tags.
#[pyclass(name = "NodeType")]
#[repr(transparent)]
pub struct AzNodeTypeEnumWrapper {
    pub inner: AzNodeType,
}

/// Defines the element's purpose for accessibility APIs, informing assistive technologies like screen readers about the function of a UI element. Each variant corresponds to a standard control type or UI structure. For more details, see the [MSDN Role Constants page](https://docs.microsoft.com/en-us/windows/winauto/object-roles).
#[pyclass(name = "AccessibilityRole")]
#[repr(transparent)]
pub struct AzAccessibilityRoleEnumWrapper {
    pub inner: AzAccessibilityRole,
}

/// Defines the current state of an element for accessibility APIs (e.g., focused, checked). These states provide dynamic information to assistive technologies about the element's condition. See the [MSDN State Constants page](https://docs.microsoft.com/en-us/windows/win32/winauto/object-state-constants) for more details.
#[pyclass(name = "AccessibilityState")]
#[repr(transparent)]
pub struct AzAccessibilityStateEnumWrapper {
    pub inner: AzAccessibilityState,
}

/// Determines the behavior of an element in sequential focus navigation
#[pyclass(name = "TabIndex")]
#[repr(transparent)]
pub struct AzTabIndexEnumWrapper {
    pub inner: AzTabIndex,
}

/// Represents an inline CSS property attached to a node for a specific interaction state. This allows defining styles for `:hover`, `:focus`, etc., directly on a DOM node.
#[pyclass(name = "NodeDataInlineCssProperty")]
#[repr(transparent)]
pub struct AzNodeDataInlineCssPropertyEnumWrapper {
    pub inner: AzNodeDataInlineCssProperty,
}

/// `AzAccessibilityAction` enum
#[pyclass(name = "AccessibilityAction")]
#[repr(transparent)]
pub struct AzAccessibilityActionEnumWrapper {
    pub inner: AzAccessibilityAction,
}

/// `AzSvgSimpleNode` enum
#[pyclass(name = "SvgSimpleNode")]
#[repr(transparent)]
pub struct AzSvgSimpleNodeEnumWrapper {
    pub inner: AzSvgSimpleNode,
}

/// `AzAttributeType` enum
#[pyclass(name = "AttributeType")]
#[repr(transparent)]
pub struct AzAttributeTypeEnumWrapper {
    pub inner: AzAttributeType,
}

/// `AzXmlNodeChild` enum
#[pyclass(name = "XmlNodeChild")]
#[repr(transparent)]
pub struct AzXmlNodeChildEnumWrapper {
    pub inner: AzXmlNodeChild,
}

/// `AzNodeTypeTag` enum
#[pyclass(name = "NodeTypeTag")]
#[repr(transparent)]
pub struct AzNodeTypeTagEnumWrapper {
    pub inner: AzNodeTypeTag,
}

/// `AzVertexAttributeType` enum
#[pyclass(name = "VertexAttributeType")]
#[repr(transparent)]
pub struct AzVertexAttributeTypeEnumWrapper {
    pub inner: AzVertexAttributeType,
}

/// Determines whether this context menu should pop up on a left, right or middle click
#[pyclass(name = "ContextMenuMouseButton")]
#[repr(transparent)]
pub struct AzContextMenuMouseButtonEnumWrapper {
    pub inner: AzContextMenuMouseButton,
}

/// Specifies where a popup menu should appear relative to the cursor or clicked element. This positioning information is ignored for application-level menus (menu bars) and only applies to context menus and dropdowns.
#[pyclass(name = "MenuPopupPosition")]
#[repr(transparent)]
pub struct AzMenuPopupPositionEnumWrapper {
    pub inner: AzMenuPopupPosition,
}

/// Represents a single item in a menu. Menu items can be regular text items with labels and callbacks, visual separators, or line breaks for horizontal menu layouts.
#[pyclass(name = "MenuItem")]
#[repr(transparent)]
pub struct AzMenuItemEnumWrapper {
    pub inner: AzMenuItem,
}

/// Optional icon displayed next to a menu item. Icons can be either: - A checkbox (checked or unchecked) - A custom image (typically 16x16 pixels)
#[pyclass(name = "MenuItemIcon")]
#[repr(transparent)]
pub struct AzMenuItemIconEnumWrapper {
    pub inner: AzMenuItemIcon,
}

/// Describes the interactive state of a menu item. Menu items can be in different states that affect their appearance and behavior: - Normal items are clickable and render normally - Greyed items are visually disabled (greyed out) and non-clickable - Disabled items are non-clickable but retain normal appearance
#[pyclass(name = "MenuItemState")]
#[repr(transparent)]
pub struct AzMenuItemStateEnumWrapper {
    pub inner: AzMenuItemState,
}

/// Represents one parsed CSS key-value pair, such as `"width: 20px"` => `CssProperty::Width(LayoutWidth::px(20.0))`
#[pyclass(name = "CssProperty")]
#[repr(transparent)]
pub struct AzCssPropertyEnumWrapper {
    pub inner: AzCssProperty,
}

/// `AzCssNthChildSelector` enum
#[pyclass(name = "CssNthChildSelector")]
#[repr(transparent)]
pub struct AzCssNthChildSelectorEnumWrapper {
    pub inner: AzCssNthChildSelector,
}

/// Contains one parsed `key: value` pair, static or dynamic
#[pyclass(name = "CssDeclaration")]
#[repr(transparent)]
pub struct AzCssDeclarationEnumWrapper {
    pub inner: AzCssDeclaration,
}

/// Represents an animation timing function.
#[pyclass(name = "AnimationInterpolationFunction")]
#[repr(transparent)]
pub struct AzAnimationInterpolationFunctionEnumWrapper {
    pub inner: AzAnimationInterpolationFunction,
}

/// Enum representing the metric associated with a number (px, pt, em, etc.)
#[pyclass(name = "SizeMetric")]
#[repr(transparent)]
pub struct AzSizeMetricEnumWrapper {
    pub inner: AzSizeMetric,
}

/// What direction should a `box-shadow` be clipped in (inset or outset).
#[pyclass(name = "BoxShadowClipMode")]
#[repr(transparent)]
pub struct AzBoxShadowClipModeEnumWrapper {
    pub inner: AzBoxShadowClipMode,
}

/// Represents a `mix-blend-mode` attribute, which determines how an element's content should blend with the content of the element's parent.
#[pyclass(name = "StyleMixBlendMode")]
#[repr(transparent)]
pub struct AzStyleMixBlendModeEnumWrapper {
    pub inner: AzStyleMixBlendMode,
}

/// `AzStyleFilter` enum
#[pyclass(name = "StyleFilter")]
#[repr(transparent)]
pub struct AzStyleFilterEnumWrapper {
    pub inner: AzStyleFilter,
}

/// `AzStyleCompositeFilter` enum
#[pyclass(name = "StyleCompositeFilter")]
#[repr(transparent)]
pub struct AzStyleCompositeFilterEnumWrapper {
    pub inner: AzStyleCompositeFilter,
}

/// Represents an `align-content` attribute, which aligns a flex container's lines within it when there is extra space in the cross-axis. Default: `Stretch`
#[pyclass(name = "LayoutAlignContent")]
#[repr(transparent)]
pub struct AzLayoutAlignContentEnumWrapper {
    pub inner: AzLayoutAlignContent,
}

/// Represents an `align-items` attribute, which defines the default behavior for how flex items are laid out along the cross axis on the current line. Default: `Stretch`
#[pyclass(name = "LayoutAlignItems")]
#[repr(transparent)]
pub struct AzLayoutAlignItemsEnumWrapper {
    pub inner: AzLayoutAlignItems,
}

/// Represents a `box-sizing` attribute
#[pyclass(name = "LayoutBoxSizing")]
#[repr(transparent)]
pub struct AzLayoutBoxSizingEnumWrapper {
    pub inner: AzLayoutBoxSizing,
}

/// Represents a `flex-direction` attribute, which establishes the main-axis, thus defining the direction flex items are placed in the flex container. Default: `Row`
#[pyclass(name = "LayoutFlexDirection")]
#[repr(transparent)]
pub struct AzLayoutFlexDirectionEnumWrapper {
    pub inner: AzLayoutFlexDirection,
}

/// Represents a `display` CSS property value
#[pyclass(name = "LayoutDisplay")]
#[repr(transparent)]
pub struct AzLayoutDisplayEnumWrapper {
    pub inner: AzLayoutDisplay,
}

/// Represents a `float` attribute
#[pyclass(name = "LayoutFloat")]
#[repr(transparent)]
pub struct AzLayoutFloatEnumWrapper {
    pub inner: AzLayoutFloat,
}

/// `AzLayoutHeight` enum
#[pyclass(name = "LayoutHeight")]
#[repr(transparent)]
pub struct AzLayoutHeightEnumWrapper {
    pub inner: AzLayoutHeight,
}

/// Represents a `justify-content` attribute, which defines the alignment along the main axis. Default: `Start` (flex-start)
#[pyclass(name = "LayoutJustifyContent")]
#[repr(transparent)]
pub struct AzLayoutJustifyContentEnumWrapper {
    pub inner: AzLayoutJustifyContent,
}

/// Represents a `position` attribute - default: `Static`
#[pyclass(name = "LayoutPosition")]
#[repr(transparent)]
pub struct AzLayoutPositionEnumWrapper {
    pub inner: AzLayoutPosition,
}

/// `AzLayoutWidth` enum
#[pyclass(name = "LayoutWidth")]
#[repr(transparent)]
pub struct AzLayoutWidthEnumWrapper {
    pub inner: AzLayoutWidth,
}

/// Represents a `flex-wrap` attribute, which determines whether flex items are forced onto one line or can wrap onto multiple lines. Default: `NoWrap`
#[pyclass(name = "LayoutFlexWrap")]
#[repr(transparent)]
pub struct AzLayoutFlexWrapEnumWrapper {
    pub inner: AzLayoutFlexWrap,
}

/// Represents an `overflow-x` or `overflow-y` property. Determines what to do when content overflows an element's box.
#[pyclass(name = "LayoutOverflow")]
#[repr(transparent)]
pub struct AzLayoutOverflowEnumWrapper {
    pub inner: AzLayoutOverflow,
}

/// Enum representing the metric associated with an angle (deg, rad, etc.)
#[pyclass(name = "AngleMetric")]
#[repr(transparent)]
pub struct AzAngleMetricEnumWrapper {
    pub inner: AzAngleMetric,
}

/// `AzDirectionCorner` enum
#[pyclass(name = "DirectionCorner")]
#[repr(transparent)]
pub struct AzDirectionCornerEnumWrapper {
    pub inner: AzDirectionCorner,
}

/// CSS direction (necessary for gradients). Can either be a fixed angle or a direction ("to right" / "to left", etc.).
#[pyclass(name = "Direction")]
#[repr(transparent)]
pub struct AzDirectionEnumWrapper {
    pub inner: AzDirection,
}

/// `AzShape` enum
#[pyclass(name = "Shape")]
#[repr(transparent)]
pub struct AzShapeEnumWrapper {
    pub inner: AzShape,
}

/// `AzRadialGradientSize` enum
#[pyclass(name = "RadialGradientSize")]
#[repr(transparent)]
pub struct AzRadialGradientSizeEnumWrapper {
    pub inner: AzRadialGradientSize,
}

/// `AzStyleBackgroundContent` enum
#[pyclass(name = "StyleBackgroundContent")]
#[repr(transparent)]
pub struct AzStyleBackgroundContentEnumWrapper {
    pub inner: AzStyleBackgroundContent,
}

/// `AzBackgroundPositionHorizontal` enum
#[pyclass(name = "BackgroundPositionHorizontal")]
#[repr(transparent)]
pub struct AzBackgroundPositionHorizontalEnumWrapper {
    pub inner: AzBackgroundPositionHorizontal,
}

/// `AzBackgroundPositionVertical` enum
#[pyclass(name = "BackgroundPositionVertical")]
#[repr(transparent)]
pub struct AzBackgroundPositionVerticalEnumWrapper {
    pub inner: AzBackgroundPositionVertical,
}

/// `AzStyleBackgroundRepeat` enum
#[pyclass(name = "StyleBackgroundRepeat")]
#[repr(transparent)]
pub struct AzStyleBackgroundRepeatEnumWrapper {
    pub inner: AzStyleBackgroundRepeat,
}

/// `AzStyleBackgroundSize` enum
#[pyclass(name = "StyleBackgroundSize")]
#[repr(transparent)]
pub struct AzStyleBackgroundSizeEnumWrapper {
    pub inner: AzStyleBackgroundSize,
}

/// Style of a `border`: solid, double, dash, ridge, etc.
#[pyclass(name = "BorderStyle")]
#[repr(transparent)]
pub struct AzBorderStyleEnumWrapper {
    pub inner: AzBorderStyle,
}

/// Represents a `font-family` attribute
#[pyclass(name = "StyleFontFamily")]
#[repr(transparent)]
pub struct AzStyleFontFamilyEnumWrapper {
    pub inner: AzStyleFontFamily,
}

/// Represents a `backface-visibility` attribute
#[pyclass(name = "StyleBackfaceVisibility")]
#[repr(transparent)]
pub struct AzStyleBackfaceVisibilityEnumWrapper {
    pub inner: AzStyleBackfaceVisibility,
}

/// Represents one component of a `transform` attribute
#[pyclass(name = "StyleTransform")]
#[repr(transparent)]
pub struct AzStyleTransformEnumWrapper {
    pub inner: AzStyleTransform,
}

/// Horizontal text alignment enum (left, center, right) - default: `Left`
#[pyclass(name = "StyleTextAlign")]
#[repr(transparent)]
pub struct AzStyleTextAlignEnumWrapper {
    pub inner: AzStyleTextAlign,
}

/// Generic CSS property value that can be Auto, None, Initial, Inherit, or an exact value
#[pyclass(name = "CssPropertyValue")]
#[repr(transparent)]
pub struct AzCssPropertyValueEnumWrapper {
    pub inner: AzCssPropertyValue,
}

/// Represents a grid line position (start or end)
#[pyclass(name = "GridLine")]
#[repr(transparent)]
pub struct AzGridLineEnumWrapper {
    pub inner: AzGridLine,
}

/// Represents a `z-index` attribute - controls stacking order of positioned elements
#[pyclass(name = "LayoutZIndex")]
#[repr(transparent)]
pub struct AzLayoutZIndexEnumWrapper {
    pub inner: AzLayoutZIndex,
}

/// Represents `justify-items` for grid containers
#[pyclass(name = "LayoutJustifyItems")]
#[repr(transparent)]
pub struct AzLayoutJustifyItemsEnumWrapper {
    pub inner: AzLayoutJustifyItems,
}

/// `AzColumnSpan` enum
#[pyclass(name = "ColumnSpan")]
#[repr(transparent)]
pub struct AzColumnSpanEnumWrapper {
    pub inner: AzColumnSpan,
}

/// Represents a `clear` attribute
#[pyclass(name = "LayoutClear")]
#[repr(transparent)]
pub struct AzLayoutClearEnumWrapper {
    pub inner: AzLayoutClear,
}

/// How to handle white space inside an element.
#[pyclass(name = "StyleWhiteSpace")]
#[repr(transparent)]
pub struct AzStyleWhiteSpaceEnumWrapper {
    pub inner: AzStyleWhiteSpace,
}

/// Represents a `break-inside` CSS property value.
#[pyclass(name = "BreakInside")]
#[repr(transparent)]
pub struct AzBreakInsideEnumWrapper {
    pub inner: AzBreakInside,
}

/// Represents an `align-self` attribute, which allows the default alignment (or the one specified by align-items) to be overridden for individual flex items. Default: `Auto`
#[pyclass(name = "LayoutAlignSelf")]
#[repr(transparent)]
pub struct AzLayoutAlignSelfEnumWrapper {
    pub inner: AzLayoutAlignSelf,
}

/// CSS shape-outside property for wrapping text around shapes
#[pyclass(name = "ShapeOutside")]
#[repr(transparent)]
pub struct AzShapeOutsideEnumWrapper {
    pub inner: AzShapeOutside,
}

/// `AzColumnCount` enum
#[pyclass(name = "ColumnCount")]
#[repr(transparent)]
pub struct AzColumnCountEnumWrapper {
    pub inner: AzColumnCount,
}

/// Represents a `writing-mode` attribute
#[pyclass(name = "LayoutWritingMode")]
#[repr(transparent)]
pub struct AzLayoutWritingModeEnumWrapper {
    pub inner: AzLayoutWritingMode,
}

/// Controls whether the user can select text. Used to prevent accidental text selection on UI controls like buttons.
#[pyclass(name = "StyleUserSelect")]
#[repr(transparent)]
pub struct AzStyleUserSelectEnumWrapper {
    pub inner: AzStyleUserSelect,
}

/// Represents `justify-self` for grid items
#[pyclass(name = "LayoutJustifySelf")]
#[repr(transparent)]
pub struct AzLayoutJustifySelfEnumWrapper {
    pub inner: AzLayoutJustifySelf,
}

/// Hyphenation rules.
#[pyclass(name = "StyleHyphens")]
#[repr(transparent)]
pub struct AzStyleHyphensEnumWrapper {
    pub inner: AzStyleHyphens,
}

/// Text direction.
#[pyclass(name = "StyleDirection")]
#[repr(transparent)]
pub struct AzStyleDirectionEnumWrapper {
    pub inner: AzStyleDirection,
}

/// Represents a `flex-basis` attribute
#[pyclass(name = "LayoutFlexBasis")]
#[repr(transparent)]
pub struct AzLayoutFlexBasisEnumWrapper {
    pub inner: AzLayoutFlexBasis,
}

/// `AzLayoutTextJustify` enum
#[pyclass(name = "LayoutTextJustify")]
#[repr(transparent)]
pub struct AzLayoutTextJustifyEnumWrapper {
    pub inner: AzLayoutTextJustify,
}

/// `AzColumnWidth` enum
#[pyclass(name = "ColumnWidth")]
#[repr(transparent)]
pub struct AzColumnWidthEnumWrapper {
    pub inner: AzColumnWidth,
}

/// Represents a `box-decoration-break` CSS property value.
#[pyclass(name = "BoxDecorationBreak")]
#[repr(transparent)]
pub struct AzBoxDecorationBreakEnumWrapper {
    pub inner: AzBoxDecorationBreak,
}

/// Represents a `visibility` attribute, controlling element visibility.
#[pyclass(name = "StyleVisibility")]
#[repr(transparent)]
pub struct AzStyleVisibilityEnumWrapper {
    pub inner: AzStyleVisibility,
}

/// Represents the `grid-auto-flow` property
#[pyclass(name = "LayoutGridAutoFlow")]
#[repr(transparent)]
pub struct AzLayoutGridAutoFlowEnumWrapper {
    pub inner: AzLayoutGridAutoFlow,
}

/// Text decoration (underline, overline, line-through).
#[pyclass(name = "StyleTextDecoration")]
#[repr(transparent)]
pub struct AzStyleTextDecorationEnumWrapper {
    pub inner: AzStyleTextDecoration,
}

/// `AzColumnFill` enum
#[pyclass(name = "ColumnFill")]
#[repr(transparent)]
pub struct AzColumnFillEnumWrapper {
    pub inner: AzColumnFill,
}

/// Represents a `break-before` or `break-after` CSS property value.
#[pyclass(name = "PageBreak")]
#[repr(transparent)]
pub struct AzPageBreakEnumWrapper {
    pub inner: AzPageBreak,
}

/// Represents the standard `scrollbar-width` property.
#[pyclass(name = "LayoutScrollbarWidth")]
#[repr(transparent)]
pub struct AzLayoutScrollbarWidthEnumWrapper {
    pub inner: AzLayoutScrollbarWidth,
}

/// Represents the standard `scrollbar-color` property.
#[pyclass(name = "StyleScrollbarColor")]
#[repr(transparent)]
pub struct AzStyleScrollbarColorEnumWrapper {
    pub inner: AzStyleScrollbarColor,
}

/// Vertical text alignment enum (top, center, bottom) - default: `Top`
#[pyclass(name = "StyleVerticalAlign")]
#[repr(transparent)]
pub struct AzStyleVerticalAlignEnumWrapper {
    pub inner: AzStyleVerticalAlign,
}

/// CSS shape-inside property for flowing text within shapes
#[pyclass(name = "ShapeInside")]
#[repr(transparent)]
pub struct AzShapeInsideEnumWrapper {
    pub inner: AzShapeInside,
}

/// Represents the `font-weight` property.
#[pyclass(name = "StyleFontWeight")]
#[repr(transparent)]
pub struct AzStyleFontWeightEnumWrapper {
    pub inner: AzStyleFontWeight,
}

/// `AzStyleListStyleType` enum
#[pyclass(name = "StyleListStyleType")]
#[repr(transparent)]
pub struct AzStyleListStyleTypeEnumWrapper {
    pub inner: AzStyleListStyleType,
}

/// CSS clip-path property for clipping element rendering
#[pyclass(name = "ClipPath")]
#[repr(transparent)]
pub struct AzClipPathEnumWrapper {
    pub inner: AzClipPath,
}

/// `AzStyleListStylePosition` enum
#[pyclass(name = "StyleListStylePosition")]
#[repr(transparent)]
pub struct AzStyleListStylePositionEnumWrapper {
    pub inner: AzStyleListStylePosition,
}

/// Specifies whether cell borders are collapsed into a single border or separated. The `border-collapse` property determines the border rendering model: - **separate**: Each cell has its own border (default, uses border-spacing) - **collapse**: Adjacent cells share borders (ignores border-spacing)
#[pyclass(name = "StyleBorderCollapse")]
#[repr(transparent)]
pub struct AzStyleBorderCollapseEnumWrapper {
    pub inner: AzStyleBorderCollapse,
}

/// Specifies the placement of a table caption. The `caption-side` property positions the caption either above or below the table.
#[pyclass(name = "StyleCaptionSide")]
#[repr(transparent)]
pub struct AzStyleCaptionSideEnumWrapper {
    pub inner: AzStyleCaptionSide,
}

/// Controls the algorithm used to lay out table cells, rows, and columns. The `table-layout` property determines whether the browser should use: - **auto**: Column widths are determined by the content (slower but flexible) - **fixed**: Column widths are determined by the first row (faster and predictable)
#[pyclass(name = "LayoutTableLayout")]
#[repr(transparent)]
pub struct AzLayoutTableLayoutEnumWrapper {
    pub inner: AzLayoutTableLayout,
}

/// Specifies whether or not to display borders and background on empty cells. The `empty-cells` property only applies when `border-collapse` is set to `separate`. A cell is considered empty if it contains no visible content.
#[pyclass(name = "StyleEmptyCells")]
#[repr(transparent)]
pub struct AzStyleEmptyCellsEnumWrapper {
    pub inner: AzStyleEmptyCells,
}

/// Represents the `font-style` property.
#[pyclass(name = "StyleFontStyle")]
#[repr(transparent)]
pub struct AzStyleFontStyleEnumWrapper {
    pub inner: AzStyleFontStyle,
}

/// text-combine-upright property for combining horizontal text in vertical layout
#[pyclass(name = "StyleTextCombineUpright")]
#[repr(transparent)]
pub struct AzStyleTextCombineUprightEnumWrapper {
    pub inner: AzStyleTextCombineUpright,
}

/// `AzGridTrackSizing` enum
#[pyclass(name = "GridTrackSizing")]
#[repr(transparent)]
pub struct AzGridTrackSizingEnumWrapper {
    pub inner: AzGridTrackSizing,
}

/// `AzHoverEventFilter` enum
#[pyclass(name = "HoverEventFilter")]
#[repr(transparent)]
pub struct AzHoverEventFilterEnumWrapper {
    pub inner: AzHoverEventFilter,
}

/// `AzShapeRendering` enum
#[pyclass(name = "ShapeRendering")]
#[repr(transparent)]
pub struct AzShapeRenderingEnumWrapper {
    pub inner: AzShapeRendering,
}

/// `AzApplicationEventFilter` enum
#[pyclass(name = "ApplicationEventFilter")]
#[repr(transparent)]
pub struct AzApplicationEventFilterEnumWrapper {
    pub inner: AzApplicationEventFilter,
}

/// `AzTextRendering` enum
#[pyclass(name = "TextRendering")]
#[repr(transparent)]
pub struct AzTextRenderingEnumWrapper {
    pub inner: AzTextRendering,
}

/// `AzFocusEventFilter` enum
#[pyclass(name = "FocusEventFilter")]
#[repr(transparent)]
pub struct AzFocusEventFilterEnumWrapper {
    pub inner: AzFocusEventFilter,
}

/// `AzEventFilter` enum
#[pyclass(name = "EventFilter")]
#[repr(transparent)]
pub struct AzEventFilterEnumWrapper {
    pub inner: AzEventFilter,
}

/// `AzSvgStyle` enum
#[pyclass(name = "SvgStyle")]
#[repr(transparent)]
pub struct AzSvgStyleEnumWrapper {
    pub inner: AzSvgStyle,
}

/// `AzIndent` enum
#[pyclass(name = "Indent")]
#[repr(transparent)]
pub struct AzIndentEnumWrapper {
    pub inner: AzIndent,
}

/// `AzFontDatabase` enum
#[pyclass(name = "FontDatabase")]
#[repr(transparent)]
pub struct AzFontDatabaseEnumWrapper {
    pub inner: AzFontDatabase,
}

/// `AzNotEventFilter` enum
#[pyclass(name = "NotEventFilter")]
#[repr(transparent)]
pub struct AzNotEventFilterEnumWrapper {
    pub inner: AzNotEventFilter,
}

/// `AzComponentEventFilter` enum
#[pyclass(name = "ComponentEventFilter")]
#[repr(transparent)]
pub struct AzComponentEventFilterEnumWrapper {
    pub inner: AzComponentEventFilter,
}

/// `AzCssShape` enum
#[pyclass(name = "CssShape")]
#[repr(transparent)]
pub struct AzCssShapeEnumWrapper {
    pub inner: AzCssShape,
}

/// `AzWindowBackgroundMaterial` enum
#[pyclass(name = "WindowBackgroundMaterial")]
#[repr(transparent)]
pub struct AzWindowBackgroundMaterialEnumWrapper {
    pub inner: AzWindowBackgroundMaterial,
}

/// `AzWindowPosition` enum
#[pyclass(name = "WindowPosition")]
#[repr(transparent)]
pub struct AzWindowPositionEnumWrapper {
    pub inner: AzWindowPosition,
}

/// `AzCursorPosition` enum
#[pyclass(name = "CursorPosition")]
#[repr(transparent)]
pub struct AzCursorPositionEnumWrapper {
    pub inner: AzCursorPosition,
}

/// `AzImePosition` enum
#[pyclass(name = "ImePosition")]
#[repr(transparent)]
pub struct AzImePositionEnumWrapper {
    pub inner: AzImePosition,
}

/// `AzWindowDecorations` enum
#[pyclass(name = "WindowDecorations")]
#[repr(transparent)]
pub struct AzWindowDecorationsEnumWrapper {
    pub inner: AzWindowDecorations,
}

/// `AzSrgb` enum
#[pyclass(name = "Srgb")]
#[repr(transparent)]
pub struct AzSrgbEnumWrapper {
    pub inner: AzSrgb,
}

/// `AzTextInputSelection` enum
#[pyclass(name = "TextInputSelection")]
#[repr(transparent)]
pub struct AzTextInputSelectionEnumWrapper {
    pub inner: AzTextInputSelection,
}

/// `AzTextInputValid` enum
#[pyclass(name = "TextInputValid")]
#[repr(transparent)]
pub struct AzTextInputValidEnumWrapper {
    pub inner: AzTextInputValid,
}

/// `AzIndexBufferFormat` enum
#[pyclass(name = "IndexBufferFormat")]
#[repr(transparent)]
pub struct AzIndexBufferFormatEnumWrapper {
    pub inner: AzIndexBufferFormat,
}

/// `AzGlType` enum
#[pyclass(name = "GlType")]
#[repr(transparent)]
pub struct AzGlTypeEnumWrapper {
    pub inner: AzGlType,
}

/// `AzRawImageFormat` enum
#[pyclass(name = "RawImageFormat")]
#[repr(transparent)]
pub struct AzRawImageFormatEnumWrapper {
    pub inner: AzRawImageFormat,
}

/// `AzRawImageData` enum
#[pyclass(name = "RawImageData")]
#[repr(transparent)]
pub struct AzRawImageDataEnumWrapper {
    pub inner: AzRawImageData,
}

/// `AzImageRendering` enum
#[pyclass(name = "ImageRendering")]
#[repr(transparent)]
pub struct AzImageRenderingEnumWrapper {
    pub inner: AzImageRendering,
}

/// One `SvgNode` corresponds to one SVG `<path></path>` element
#[pyclass(name = "SvgNode")]
#[repr(transparent)]
pub struct AzSvgNodeEnumWrapper {
    pub inner: AzSvgNode,
}

/// `AzSvgPathElement` enum
#[pyclass(name = "SvgPathElement")]
#[repr(transparent)]
pub struct AzSvgPathElementEnumWrapper {
    pub inner: AzSvgPathElement,
}

/// `AzSvgFitTo` enum
#[pyclass(name = "SvgFitTo")]
#[repr(transparent)]
pub struct AzSvgFitToEnumWrapper {
    pub inner: AzSvgFitTo,
}

/// `AzSvgFillRule` enum
#[pyclass(name = "SvgFillRule")]
#[repr(transparent)]
pub struct AzSvgFillRuleEnumWrapper {
    pub inner: AzSvgFillRule,
}

/// `AzSvgLineJoin` enum
#[pyclass(name = "SvgLineJoin")]
#[repr(transparent)]
pub struct AzSvgLineJoinEnumWrapper {
    pub inner: AzSvgLineJoin,
}

/// `AzSvgLineCap` enum
#[pyclass(name = "SvgLineCap")]
#[repr(transparent)]
pub struct AzSvgLineCapEnumWrapper {
    pub inner: AzSvgLineCap,
}

/// `AzCssPathPseudoSelector` enum
#[pyclass(name = "CssPathPseudoSelector")]
#[repr(transparent)]
pub struct AzCssPathPseudoSelectorEnumWrapper {
    pub inner: AzCssPathPseudoSelector,
}

/// `AzCssPathSelector` enum
#[pyclass(name = "CssPathSelector")]
#[repr(transparent)]
pub struct AzCssPathSelectorEnumWrapper {
    pub inner: AzCssPathSelector,
}

/// `AzInstant` enum
#[pyclass(name = "Instant")]
#[repr(transparent)]
pub struct AzInstantEnumWrapper {
    pub inner: AzInstant,
}

/// `AzDuration` enum
#[pyclass(name = "Duration")]
#[repr(transparent)]
pub struct AzDurationEnumWrapper {
    pub inner: AzDuration,
}

/// `AzOptionU8VecRef` enum
#[pyclass(name = "OptionU8VecRef")]
#[repr(transparent)]
pub struct AzOptionU8VecRefEnumWrapper {
    pub inner: AzOptionU8VecRef,
}

/// `AzSvgPathVecDestructor` enum
#[pyclass(name = "SvgPathVecDestructor")]
#[repr(transparent)]
pub struct AzSvgPathVecDestructorEnumWrapper {
    pub inner: AzSvgPathVecDestructor,
}

/// `AzStyleFilterVecDestructor` enum
#[pyclass(name = "StyleFilterVecDestructor")]
#[repr(transparent)]
pub struct AzStyleFilterVecDestructorEnumWrapper {
    pub inner: AzStyleFilterVecDestructor,
}

/// `AzStyleTransformVecDestructor` enum
#[pyclass(name = "StyleTransformVecDestructor")]
#[repr(transparent)]
pub struct AzStyleTransformVecDestructorEnumWrapper {
    pub inner: AzStyleTransformVecDestructor,
}

/// `AzGLuintVecDestructor` enum
#[pyclass(name = "GLuintVecDestructor")]
#[repr(transparent)]
pub struct AzGLuintVecDestructorEnumWrapper {
    pub inner: AzGLuintVecDestructor,
}

/// `AzXmlNodeChildVecDestructor` enum
#[pyclass(name = "XmlNodeChildVecDestructor")]
#[repr(transparent)]
pub struct AzXmlNodeChildVecDestructorEnumWrapper {
    pub inner: AzXmlNodeChildVecDestructor,
}

/// `AzStyleBackgroundContentVecDestructor` enum
#[pyclass(name = "StyleBackgroundContentVecDestructor")]
#[repr(transparent)]
pub struct AzStyleBackgroundContentVecDestructorEnumWrapper {
    pub inner: AzStyleBackgroundContentVecDestructor,
}

/// `AzCascadeInfoVecDestructor` enum
#[pyclass(name = "CascadeInfoVecDestructor")]
#[repr(transparent)]
pub struct AzCascadeInfoVecDestructorEnumWrapper {
    pub inner: AzCascadeInfoVecDestructor,
}

/// `AzAccessibilityStateVecDestructor` enum
#[pyclass(name = "AccessibilityStateVecDestructor")]
#[repr(transparent)]
pub struct AzAccessibilityStateVecDestructorEnumWrapper {
    pub inner: AzAccessibilityStateVecDestructor,
}

/// `AzDomVecDestructor` enum
#[pyclass(name = "DomVecDestructor")]
#[repr(transparent)]
pub struct AzDomVecDestructorEnumWrapper {
    pub inner: AzDomVecDestructor,
}

/// `AzStringVecDestructor` enum
#[pyclass(name = "StringVecDestructor")]
#[repr(transparent)]
pub struct AzStringVecDestructorEnumWrapper {
    pub inner: AzStringVecDestructor,
}

/// `AzNodeDataVecDestructor` enum
#[pyclass(name = "NodeDataVecDestructor")]
#[repr(transparent)]
pub struct AzNodeDataVecDestructorEnumWrapper {
    pub inner: AzNodeDataVecDestructor,
}

/// `AzMenuItemVecDestructor` enum
#[pyclass(name = "MenuItemVecDestructor")]
#[repr(transparent)]
pub struct AzMenuItemVecDestructorEnumWrapper {
    pub inner: AzMenuItemVecDestructor,
}

/// `AzSvgMultiPolygonVecDestructor` enum
#[pyclass(name = "SvgMultiPolygonVecDestructor")]
#[repr(transparent)]
pub struct AzSvgMultiPolygonVecDestructorEnumWrapper {
    pub inner: AzSvgMultiPolygonVecDestructor,
}

/// `AzListViewRowVecDestructor` enum
#[pyclass(name = "ListViewRowVecDestructor")]
#[repr(transparent)]
pub struct AzListViewRowVecDestructorEnumWrapper {
    pub inner: AzListViewRowVecDestructor,
}

/// `AzSvgVertexVecDestructor` enum
#[pyclass(name = "SvgVertexVecDestructor")]
#[repr(transparent)]
pub struct AzSvgVertexVecDestructorEnumWrapper {
    pub inner: AzSvgVertexVecDestructor,
}

/// `AzStylesheetVecDestructor` enum
#[pyclass(name = "StylesheetVecDestructor")]
#[repr(transparent)]
pub struct AzStylesheetVecDestructorEnumWrapper {
    pub inner: AzStylesheetVecDestructor,
}

/// `AzU32VecDestructor` enum
#[pyclass(name = "U32VecDestructor")]
#[repr(transparent)]
pub struct AzU32VecDestructorEnumWrapper {
    pub inner: AzU32VecDestructor,
}

/// `AzCssRuleBlockVecDestructor` enum
#[pyclass(name = "CssRuleBlockVecDestructor")]
#[repr(transparent)]
pub struct AzCssRuleBlockVecDestructorEnumWrapper {
    pub inner: AzCssRuleBlockVecDestructor,
}

/// `AzNormalizedLinearColorStopVecDestructor` enum
#[pyclass(name = "NormalizedLinearColorStopVecDestructor")]
#[repr(transparent)]
pub struct AzNormalizedLinearColorStopVecDestructorEnumWrapper {
    pub inner: AzNormalizedLinearColorStopVecDestructor,
}

/// `AzStyleFontFamilyVecDestructor` enum
#[pyclass(name = "StyleFontFamilyVecDestructor")]
#[repr(transparent)]
pub struct AzStyleFontFamilyVecDestructorEnumWrapper {
    pub inner: AzStyleFontFamilyVecDestructor,
}

/// `AzCssPathSelectorVecDestructor` enum
#[pyclass(name = "CssPathSelectorVecDestructor")]
#[repr(transparent)]
pub struct AzCssPathSelectorVecDestructorEnumWrapper {
    pub inner: AzCssPathSelectorVecDestructor,
}

/// `AzNodeHierarchyItemVecDestructor` enum
#[pyclass(name = "NodeHierarchyItemVecDestructor")]
#[repr(transparent)]
pub struct AzNodeHierarchyItemVecDestructorEnumWrapper {
    pub inner: AzNodeHierarchyItemVecDestructor,
}

/// `AzVirtualKeyCodeVecDestructor` enum
#[pyclass(name = "VirtualKeyCodeVecDestructor")]
#[repr(transparent)]
pub struct AzVirtualKeyCodeVecDestructorEnumWrapper {
    pub inner: AzVirtualKeyCodeVecDestructor,
}

/// `AzF32VecDestructor` enum
#[pyclass(name = "F32VecDestructor")]
#[repr(transparent)]
pub struct AzF32VecDestructorEnumWrapper {
    pub inner: AzF32VecDestructor,
}

/// `AzStyleBackgroundRepeatVecDestructor` enum
#[pyclass(name = "StyleBackgroundRepeatVecDestructor")]
#[repr(transparent)]
pub struct AzStyleBackgroundRepeatVecDestructorEnumWrapper {
    pub inner: AzStyleBackgroundRepeatVecDestructor,
}

/// `AzAccessibilityActionVecDestructor` enum
#[pyclass(name = "AccessibilityActionVecDestructor")]
#[repr(transparent)]
pub struct AzAccessibilityActionVecDestructorEnumWrapper {
    pub inner: AzAccessibilityActionVecDestructor,
}

/// `AzU16VecDestructor` enum
#[pyclass(name = "U16VecDestructor")]
#[repr(transparent)]
pub struct AzU16VecDestructorEnumWrapper {
    pub inner: AzU16VecDestructor,
}

/// `AzTagIdToNodeIdMappingVecDestructor` enum
#[pyclass(name = "TagIdToNodeIdMappingVecDestructor")]
#[repr(transparent)]
pub struct AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
    pub inner: AzTagIdToNodeIdMappingVecDestructor,
}

/// `AzNodeIdVecDestructor` enum
#[pyclass(name = "NodeIdVecDestructor")]
#[repr(transparent)]
pub struct AzNodeIdVecDestructorEnumWrapper {
    pub inner: AzNodeIdVecDestructor,
}

/// `AzParentWithNodeDepthVecDestructor` enum
#[pyclass(name = "ParentWithNodeDepthVecDestructor")]
#[repr(transparent)]
pub struct AzParentWithNodeDepthVecDestructorEnumWrapper {
    pub inner: AzParentWithNodeDepthVecDestructor,
}

/// `AzGLintVecDestructor` enum
#[pyclass(name = "GLintVecDestructor")]
#[repr(transparent)]
pub struct AzGLintVecDestructorEnumWrapper {
    pub inner: AzGLintVecDestructor,
}

/// `AzNodeDataInlineCssPropertyVecDestructor` enum
#[pyclass(name = "NodeDataInlineCssPropertyVecDestructor")]
#[repr(transparent)]
pub struct AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
    pub inner: AzNodeDataInlineCssPropertyVecDestructor,
}

/// `AzNormalizedRadialColorStopVecDestructor` enum
#[pyclass(name = "NormalizedRadialColorStopVecDestructor")]
#[repr(transparent)]
pub struct AzNormalizedRadialColorStopVecDestructorEnumWrapper {
    pub inner: AzNormalizedRadialColorStopVecDestructor,
}

/// `AzStyledNodeVecDestructor` enum
#[pyclass(name = "StyledNodeVecDestructor")]
#[repr(transparent)]
pub struct AzStyledNodeVecDestructorEnumWrapper {
    pub inner: AzStyledNodeVecDestructor,
}

/// `AzStyleBackgroundPositionVecDestructor` enum
#[pyclass(name = "StyleBackgroundPositionVecDestructor")]
#[repr(transparent)]
pub struct AzStyleBackgroundPositionVecDestructorEnumWrapper {
    pub inner: AzStyleBackgroundPositionVecDestructor,
}

/// `AzSvgSimpleNodeVecDestructor` enum
#[pyclass(name = "SvgSimpleNodeVecDestructor")]
#[repr(transparent)]
pub struct AzSvgSimpleNodeVecDestructorEnumWrapper {
    pub inner: AzSvgSimpleNodeVecDestructor,
}

/// `AzAttributeVecDestructor` enum
#[pyclass(name = "AttributeVecDestructor")]
#[repr(transparent)]
pub struct AzAttributeVecDestructorEnumWrapper {
    pub inner: AzAttributeVecDestructor,
}

/// `AzCssDeclarationVecDestructor` enum
#[pyclass(name = "CssDeclarationVecDestructor")]
#[repr(transparent)]
pub struct AzCssDeclarationVecDestructorEnumWrapper {
    pub inner: AzCssDeclarationVecDestructor,
}

/// `AzIdOrClassVecDestructor` enum
#[pyclass(name = "IdOrClassVecDestructor")]
#[repr(transparent)]
pub struct AzIdOrClassVecDestructorEnumWrapper {
    pub inner: AzIdOrClassVecDestructor,
}

/// `AzStyleBackgroundSizeVecDestructor` enum
#[pyclass(name = "StyleBackgroundSizeVecDestructor")]
#[repr(transparent)]
pub struct AzStyleBackgroundSizeVecDestructorEnumWrapper {
    pub inner: AzStyleBackgroundSizeVecDestructor,
}

/// `AzStringPairVecDestructor` enum
#[pyclass(name = "StringPairVecDestructor")]
#[repr(transparent)]
pub struct AzStringPairVecDestructorEnumWrapper {
    pub inner: AzStringPairVecDestructor,
}

/// `AzCoreCallbackDataVecDestructor` enum
#[pyclass(name = "CoreCallbackDataVecDestructor")]
#[repr(transparent)]
pub struct AzCoreCallbackDataVecDestructorEnumWrapper {
    pub inner: AzCoreCallbackDataVecDestructor,
}

/// `AzSvgPathElementVecDestructor` enum
#[pyclass(name = "SvgPathElementVecDestructor")]
#[repr(transparent)]
pub struct AzSvgPathElementVecDestructorEnumWrapper {
    pub inner: AzSvgPathElementVecDestructor,
}

/// `AzU8VecDestructor` enum
#[pyclass(name = "U8VecDestructor")]
#[repr(transparent)]
pub struct AzU8VecDestructorEnumWrapper {
    pub inner: AzU8VecDestructor,
}

/// `AzGridTrackSizingVecDestructor` enum
#[pyclass(name = "GridTrackSizingVecDestructor")]
#[repr(transparent)]
pub struct AzGridTrackSizingVecDestructorEnumWrapper {
    pub inner: AzGridTrackSizingVecDestructor,
}

/// `AzVertexAttributeVecDestructor` enum
#[pyclass(name = "VertexAttributeVecDestructor")]
#[repr(transparent)]
pub struct AzVertexAttributeVecDestructorEnumWrapper {
    pub inner: AzVertexAttributeVecDestructor,
}

/// `AzDebugMessageVecDestructor` enum
#[pyclass(name = "DebugMessageVecDestructor")]
#[repr(transparent)]
pub struct AzDebugMessageVecDestructorEnumWrapper {
    pub inner: AzDebugMessageVecDestructor,
}

/// `AzShapePointVecDestructor` enum
#[pyclass(name = "ShapePointVecDestructor")]
#[repr(transparent)]
pub struct AzShapePointVecDestructorEnumWrapper {
    pub inner: AzShapePointVecDestructor,
}

/// `AzXWindowTypeVecDestructor` enum
#[pyclass(name = "XWindowTypeVecDestructor")]
#[repr(transparent)]
pub struct AzXWindowTypeVecDestructorEnumWrapper {
    pub inner: AzXWindowTypeVecDestructor,
}

/// `AzMonitorVecDestructor` enum
#[pyclass(name = "MonitorVecDestructor")]
#[repr(transparent)]
pub struct AzMonitorVecDestructorEnumWrapper {
    pub inner: AzMonitorVecDestructor,
}

/// `AzVideoModeVecDestructor` enum
#[pyclass(name = "VideoModeVecDestructor")]
#[repr(transparent)]
pub struct AzVideoModeVecDestructorEnumWrapper {
    pub inner: AzVideoModeVecDestructor,
}

/// `AzScanCodeVecDestructor` enum
#[pyclass(name = "ScanCodeVecDestructor")]
#[repr(transparent)]
pub struct AzScanCodeVecDestructorEnumWrapper {
    pub inner: AzScanCodeVecDestructor,
}

/// `AzOptionSvgPoint` enum
#[pyclass(name = "OptionSvgPoint")]
#[repr(transparent)]
pub struct AzOptionSvgPointEnumWrapper {
    pub inner: AzOptionSvgPoint,
}

/// `AzOptionListViewOnRowClick` enum
#[pyclass(name = "OptionListViewOnRowClick")]
#[repr(transparent)]
pub struct AzOptionListViewOnRowClickEnumWrapper {
    pub inner: AzOptionListViewOnRowClick,
}

/// `AzOptionListViewOnColumnClick` enum
#[pyclass(name = "OptionListViewOnColumnClick")]
#[repr(transparent)]
pub struct AzOptionListViewOnColumnClickEnumWrapper {
    pub inner: AzOptionListViewOnColumnClick,
}

/// `AzOptionListViewOnLazyLoadScroll` enum
#[pyclass(name = "OptionListViewOnLazyLoadScroll")]
#[repr(transparent)]
pub struct AzOptionListViewOnLazyLoadScrollEnumWrapper {
    pub inner: AzOptionListViewOnLazyLoadScroll,
}

/// `AzOptionMenu` enum
#[pyclass(name = "OptionMenu")]
#[repr(transparent)]
pub struct AzOptionMenuEnumWrapper {
    pub inner: AzOptionMenu,
}

/// `AzOptionPixelValueNoPercent` enum
#[pyclass(name = "OptionPixelValueNoPercent")]
#[repr(transparent)]
pub struct AzOptionPixelValueNoPercentEnumWrapper {
    pub inner: AzOptionPixelValueNoPercent,
}

/// `AzOptionColorInputOnValueChange` enum
#[pyclass(name = "OptionColorInputOnValueChange")]
#[repr(transparent)]
pub struct AzOptionColorInputOnValueChangeEnumWrapper {
    pub inner: AzOptionColorInputOnValueChange,
}

/// `AzOptionButtonOnClick` enum
#[pyclass(name = "OptionButtonOnClick")]
#[repr(transparent)]
pub struct AzOptionButtonOnClickEnumWrapper {
    pub inner: AzOptionButtonOnClick,
}

/// `AzOptionTabOnClick` enum
#[pyclass(name = "OptionTabOnClick")]
#[repr(transparent)]
pub struct AzOptionTabOnClickEnumWrapper {
    pub inner: AzOptionTabOnClick,
}

/// `AzOptionFileInputOnPathChange` enum
#[pyclass(name = "OptionFileInputOnPathChange")]
#[repr(transparent)]
pub struct AzOptionFileInputOnPathChangeEnumWrapper {
    pub inner: AzOptionFileInputOnPathChange,
}

/// `AzOptionCheckBoxOnToggle` enum
#[pyclass(name = "OptionCheckBoxOnToggle")]
#[repr(transparent)]
pub struct AzOptionCheckBoxOnToggleEnumWrapper {
    pub inner: AzOptionCheckBoxOnToggle,
}

/// `AzOptionTextInputOnTextInput` enum
#[pyclass(name = "OptionTextInputOnTextInput")]
#[repr(transparent)]
pub struct AzOptionTextInputOnTextInputEnumWrapper {
    pub inner: AzOptionTextInputOnTextInput,
}

/// `AzOptionTextInputOnVirtualKeyDown` enum
#[pyclass(name = "OptionTextInputOnVirtualKeyDown")]
#[repr(transparent)]
pub struct AzOptionTextInputOnVirtualKeyDownEnumWrapper {
    pub inner: AzOptionTextInputOnVirtualKeyDown,
}

/// `AzOptionTextInputOnFocusLost` enum
#[pyclass(name = "OptionTextInputOnFocusLost")]
#[repr(transparent)]
pub struct AzOptionTextInputOnFocusLostEnumWrapper {
    pub inner: AzOptionTextInputOnFocusLost,
}

/// `AzOptionTextInputSelection` enum
#[pyclass(name = "OptionTextInputSelection")]
#[repr(transparent)]
pub struct AzOptionTextInputSelectionEnumWrapper {
    pub inner: AzOptionTextInputSelection,
}

/// `AzOptionNumberInputOnFocusLost` enum
#[pyclass(name = "OptionNumberInputOnFocusLost")]
#[repr(transparent)]
pub struct AzOptionNumberInputOnFocusLostEnumWrapper {
    pub inner: AzOptionNumberInputOnFocusLost,
}

/// `AzOptionNumberInputOnValueChange` enum
#[pyclass(name = "OptionNumberInputOnValueChange")]
#[repr(transparent)]
pub struct AzOptionNumberInputOnValueChangeEnumWrapper {
    pub inner: AzOptionNumberInputOnValueChange,
}

/// `AzOptionMenuItemIcon` enum
#[pyclass(name = "OptionMenuItemIcon")]
#[repr(transparent)]
pub struct AzOptionMenuItemIconEnumWrapper {
    pub inner: AzOptionMenuItemIcon,
}

/// `AzOptionVirtualKeyCodeCombo` enum
#[pyclass(name = "OptionVirtualKeyCodeCombo")]
#[repr(transparent)]
pub struct AzOptionVirtualKeyCodeComboEnumWrapper {
    pub inner: AzOptionVirtualKeyCodeCombo,
}

/// `AzOptionTimerId` enum
#[pyclass(name = "OptionTimerId")]
#[repr(transparent)]
pub struct AzOptionTimerIdEnumWrapper {
    pub inner: AzOptionTimerId,
}

/// `AzOptionI16` enum
#[pyclass(name = "OptionI16")]
#[repr(transparent)]
pub struct AzOptionI16EnumWrapper {
    pub inner: AzOptionI16,
}

/// `AzOptionU16` enum
#[pyclass(name = "OptionU16")]
#[repr(transparent)]
pub struct AzOptionU16EnumWrapper {
    pub inner: AzOptionU16,
}

/// `AzOptionU32` enum
#[pyclass(name = "OptionU32")]
#[repr(transparent)]
pub struct AzOptionU32EnumWrapper {
    pub inner: AzOptionU32,
}

/// `AzOptionImageRef` enum
#[pyclass(name = "OptionImageRef")]
#[repr(transparent)]
pub struct AzOptionImageRefEnumWrapper {
    pub inner: AzOptionImageRef,
}

/// `AzOptionFontRef` enum
#[pyclass(name = "OptionFontRef")]
#[repr(transparent)]
pub struct AzOptionFontRefEnumWrapper {
    pub inner: AzOptionFontRef,
}

/// `AzOptionRefAny` enum
#[pyclass(name = "OptionRefAny")]
#[repr(transparent)]
pub struct AzOptionRefAnyEnumWrapper {
    pub inner: AzOptionRefAny,
}

/// `AzOptionLayoutSize` enum
#[pyclass(name = "OptionLayoutSize")]
#[repr(transparent)]
pub struct AzOptionLayoutSizeEnumWrapper {
    pub inner: AzOptionLayoutSize,
}

/// `AzOptionDomNodeId` enum
#[pyclass(name = "OptionDomNodeId")]
#[repr(transparent)]
pub struct AzOptionDomNodeIdEnumWrapper {
    pub inner: AzOptionDomNodeId,
}

/// `AzOptionColorU` enum
#[pyclass(name = "OptionColorU")]
#[repr(transparent)]
pub struct AzOptionColorUEnumWrapper {
    pub inner: AzOptionColorU,
}

/// `AzOptionRawImage` enum
#[pyclass(name = "OptionRawImage")]
#[repr(transparent)]
pub struct AzOptionRawImageEnumWrapper {
    pub inner: AzOptionRawImage,
}

/// `AzOptionSvgDashPattern` enum
#[pyclass(name = "OptionSvgDashPattern")]
#[repr(transparent)]
pub struct AzOptionSvgDashPatternEnumWrapper {
    pub inner: AzOptionSvgDashPattern,
}

/// `AzOptionTabIndex` enum
#[pyclass(name = "OptionTabIndex")]
#[repr(transparent)]
pub struct AzOptionTabIndexEnumWrapper {
    pub inner: AzOptionTabIndex,
}

/// `AzOptionTagId` enum
#[pyclass(name = "OptionTagId")]
#[repr(transparent)]
pub struct AzOptionTagIdEnumWrapper {
    pub inner: AzOptionTagId,
}

/// `AzOptionDuration` enum
#[pyclass(name = "OptionDuration")]
#[repr(transparent)]
pub struct AzOptionDurationEnumWrapper {
    pub inner: AzOptionDuration,
}

/// `AzOptionUsize` enum
#[pyclass(name = "OptionUsize")]
#[repr(transparent)]
pub struct AzOptionUsizeEnumWrapper {
    pub inner: AzOptionUsize,
}

/// `AzOptionCoreMenuCallback` enum
#[pyclass(name = "OptionCoreMenuCallback")]
#[repr(transparent)]
pub struct AzOptionCoreMenuCallbackEnumWrapper {
    pub inner: AzOptionCoreMenuCallback,
}

/// `AzOptionStyledDom` enum
#[pyclass(name = "OptionStyledDom")]
#[repr(transparent)]
pub struct AzOptionStyledDomEnumWrapper {
    pub inner: AzOptionStyledDom,
}

/// `AzOptionLogicalPosition` enum
#[pyclass(name = "OptionLogicalPosition")]
#[repr(transparent)]
pub struct AzOptionLogicalPositionEnumWrapper {
    pub inner: AzOptionLogicalPosition,
}

/// `AzOptionString` enum
#[pyclass(name = "OptionString")]
#[repr(transparent)]
pub struct AzOptionStringEnumWrapper {
    pub inner: AzOptionString,
}

/// `AzOptionF32` enum
#[pyclass(name = "OptionF32")]
#[repr(transparent)]
pub struct AzOptionF32EnumWrapper {
    pub inner: AzOptionF32,
}

/// `AzOptionWaylandTheme` enum
#[pyclass(name = "OptionWaylandTheme")]
#[repr(transparent)]
pub struct AzOptionWaylandThemeEnumWrapper {
    pub inner: AzOptionWaylandTheme,
}

/// `AzOptionMouseCursorType` enum
#[pyclass(name = "OptionMouseCursorType")]
#[repr(transparent)]
pub struct AzOptionMouseCursorTypeEnumWrapper {
    pub inner: AzOptionMouseCursorType,
}

/// `AzOptionWindowIcon` enum
#[pyclass(name = "OptionWindowIcon")]
#[repr(transparent)]
pub struct AzOptionWindowIconEnumWrapper {
    pub inner: AzOptionWindowIcon,
}

/// `AzOptionCallback` enum
#[pyclass(name = "OptionCallback")]
#[repr(transparent)]
pub struct AzOptionCallbackEnumWrapper {
    pub inner: AzOptionCallback,
}

/// `AzOptionTaskBarIcon` enum
#[pyclass(name = "OptionTaskBarIcon")]
#[repr(transparent)]
pub struct AzOptionTaskBarIconEnumWrapper {
    pub inner: AzOptionTaskBarIcon,
}

/// `AzOptionHwndHandle` enum
#[pyclass(name = "OptionHwndHandle")]
#[repr(transparent)]
pub struct AzOptionHwndHandleEnumWrapper {
    pub inner: AzOptionHwndHandle,
}

/// `AzOptionLinuxDecorationsState` enum
#[pyclass(name = "OptionLinuxDecorationsState")]
#[repr(transparent)]
pub struct AzOptionLinuxDecorationsStateEnumWrapper {
    pub inner: AzOptionLinuxDecorationsState,
}

/// `AzOptionI32` enum
#[pyclass(name = "OptionI32")]
#[repr(transparent)]
pub struct AzOptionI32EnumWrapper {
    pub inner: AzOptionI32,
}

/// `AzOptionLogicalSize` enum
#[pyclass(name = "OptionLogicalSize")]
#[repr(transparent)]
pub struct AzOptionLogicalSizeEnumWrapper {
    pub inner: AzOptionLogicalSize,
}

/// `AzOptionVirtualKeyCode` enum
#[pyclass(name = "OptionVirtualKeyCode")]
#[repr(transparent)]
pub struct AzOptionVirtualKeyCodeEnumWrapper {
    pub inner: AzOptionVirtualKeyCode,
}

/// `AzOptionX11Visual` enum
#[pyclass(name = "OptionX11Visual")]
#[repr(transparent)]
pub struct AzOptionX11VisualEnumWrapper {
    pub inner: AzOptionX11Visual,
}

/// `AzOptionRendererOptions` enum
#[pyclass(name = "OptionRendererOptions")]
#[repr(transparent)]
pub struct AzOptionRendererOptionsEnumWrapper {
    pub inner: AzOptionRendererOptions,
}

/// `AzOptionWindowTheme` enum
#[pyclass(name = "OptionWindowTheme")]
#[repr(transparent)]
pub struct AzOptionWindowThemeEnumWrapper {
    pub inner: AzOptionWindowTheme,
}

/// `AzResultXmlXmlError` enum
#[pyclass(name = "ResultXmlXmlError")]
#[repr(transparent)]
pub struct AzResultXmlXmlErrorEnumWrapper {
    pub inner: AzResultXmlXmlError,
}

/// `AzResultSvgSvgParseError` enum
#[pyclass(name = "ResultSvgSvgParseError")]
#[repr(transparent)]
pub struct AzResultSvgSvgParseErrorEnumWrapper {
    pub inner: AzResultSvgSvgParseError,
}

/// `AzSvgParseError` enum
#[pyclass(name = "SvgParseError")]
#[repr(transparent)]
pub struct AzSvgParseErrorEnumWrapper {
    pub inner: AzSvgParseError,
}

/// `AzXmlError` enum
#[pyclass(name = "XmlError")]
#[repr(transparent)]
pub struct AzXmlErrorEnumWrapper {
    pub inner: AzXmlError,
}

/// `AzXmlParseError` enum
#[pyclass(name = "XmlParseError")]
#[repr(transparent)]
pub struct AzXmlParseErrorEnumWrapper {
    pub inner: AzXmlParseError,
}

/// `AzXmlStreamError` enum
#[pyclass(name = "XmlStreamError")]
#[repr(transparent)]
pub struct AzXmlStreamErrorEnumWrapper {
    pub inner: AzXmlStreamError,
}

/// `AzEncodeImageError` enum
#[pyclass(name = "EncodeImageError")]
#[repr(transparent)]
pub struct AzEncodeImageErrorEnumWrapper {
    pub inner: AzEncodeImageError,
}

/// `AzResultRawImageDecodeImageError` enum
#[pyclass(name = "ResultRawImageDecodeImageError")]
#[repr(transparent)]
pub struct AzResultRawImageDecodeImageErrorEnumWrapper {
    pub inner: AzResultRawImageDecodeImageError,
}

/// `AzDecodeImageError` enum
#[pyclass(name = "DecodeImageError")]
#[repr(transparent)]
pub struct AzDecodeImageErrorEnumWrapper {
    pub inner: AzDecodeImageError,
}

/// `AzResultU8VecEncodeImageError` enum
#[pyclass(name = "ResultU8VecEncodeImageError")]
#[repr(transparent)]
pub struct AzResultU8VecEncodeImageErrorEnumWrapper {
    pub inner: AzResultU8VecEncodeImageError,
}

/// `AzRendererType` enum
#[pyclass(name = "RendererType")]
#[repr(transparent)]
pub struct AzRendererTypeEnumWrapper {
    pub inner: AzRendererType,
}

/// `AzExtendMode` enum
#[pyclass(name = "ExtendMode")]
#[repr(transparent)]
pub struct AzExtendModeEnumWrapper {
    pub inner: AzExtendMode,
}

/// `AzFlowInto` enum
#[pyclass(name = "FlowInto")]
#[repr(transparent)]
pub struct AzFlowIntoEnumWrapper {
    pub inner: AzFlowInto,
}

/// `AzVirtualKeyCode` enum
#[pyclass(name = "VirtualKeyCode")]
#[repr(transparent)]
pub struct AzVirtualKeyCodeEnumWrapper {
    pub inner: AzVirtualKeyCode,
}

/// `AzIdOrClass` enum
#[pyclass(name = "IdOrClass")]
#[repr(transparent)]
pub struct AzIdOrClassEnumWrapper {
    pub inner: AzIdOrClass,
}

/// `AzFlowFrom` enum
#[pyclass(name = "FlowFrom")]
#[repr(transparent)]
pub struct AzFlowFromEnumWrapper {
    pub inner: AzFlowFrom,
}

/// `AzUpdate` enum
#[pyclass(name = "Update")]
#[repr(transparent)]
pub struct AzUpdateEnumWrapper {
    pub inner: AzUpdate,
}

/// `AzEdgeType` enum
#[pyclass(name = "EdgeType")]
#[repr(transparent)]
pub struct AzEdgeTypeEnumWrapper {
    pub inner: AzEdgeType,
}

/// `AzAppTerminationBehavior` enum
#[pyclass(name = "AppTerminationBehavior")]
#[repr(transparent)]
pub struct AzAppTerminationBehaviorEnumWrapper {
    pub inner: AzAppTerminationBehavior,
}

/// `AzAppLogLevel` enum
#[pyclass(name = "AppLogLevel")]
#[repr(transparent)]
pub struct AzAppLogLevelEnumWrapper {
    pub inner: AzAppLogLevel,
}


// Necessary because the Python interpreter may send structs across different threads


// Python objects must implement Clone at minimum
impl Clone for AzHidpiAdjustedBounds { fn clone(&self) -> Self { let r: &azul_core::callbacks::HidpiAdjustedBounds = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDpiScaleFactor { fn clone(&self) -> Self { let r: &azul_core::resources::DpiScaleFactor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLinuxWindowOptions { fn clone(&self) -> Self { let r: &azul_core::window::LinuxWindowOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWaylandTheme { fn clone(&self) -> Self { let r: &azul_core::window::WaylandTheme = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMonitorId { fn clone(&self) -> Self { let r: &azul_core::window::MonitorId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowFlags { fn clone(&self) -> Self { let r: &azul_core::window::WindowFlags = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTaskBarIcon { fn clone(&self) -> Self { let r: &azul_core::window::TaskBarIcon = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWasmWindowOptions { fn clone(&self) -> Self { let r: &azul_core::window::WasmWindowOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSmallWindowIconBytes { fn clone(&self) -> Self { let r: &azul_core::window::SmallWindowIconBytes = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMonitor { fn clone(&self) -> Self { let r: &azul_core::window::Monitor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIconKey { fn clone(&self) -> Self { let r: &azul_core::window::IconKey = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMacWindowOptions { fn clone(&self) -> Self { let r: &azul_core::window::MacWindowOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVideoMode { fn clone(&self) -> Self { let r: &azul_core::window::VideoMode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLargeWindowIconBytes { fn clone(&self) -> Self { let r: &azul_core::window::LargeWindowIconBytes = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPlatformSpecificOptions { fn clone(&self) -> Self { let r: &azul_core::window::PlatformSpecificOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowSize { fn clone(&self) -> Self { let r: &azul_core::window::WindowSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowsWindowOptions { fn clone(&self) -> Self { let r: &azul_core::window::WindowsWindowOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowCreateOptions { fn clone(&self) -> Self { let r: &azul_layout::window_state::WindowCreateOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFullWindowState { fn clone(&self) -> Self { let r: &azul_layout::window_state::FullWindowState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIFrameCallback { fn clone(&self) -> Self { let r: &azul_core::callbacks::IFrameCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIFrameCallbackReturn { fn clone(&self) -> Self { let r: &azul_core::callbacks::IFrameCallbackReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIFrameCallbackInfo { fn clone(&self) -> Self { let r: &azul_core::callbacks::IFrameCallbackInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCallbackInfo { fn clone(&self) -> Self { let r: &azul_layout::callbacks::CallbackInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRenderImageCallbackInfo { fn clone(&self) -> Self { let r: &azul_layout::callbacks::RenderImageCallbackInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMarshaledLayoutCallbackInner { fn clone(&self) -> Self { let r: &azul_core::callbacks::MarshaledLayoutCallbackInner = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutCallbackInner { fn clone(&self) -> Self { let r: &azul_core::callbacks::LayoutCallbackInner = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutCallbackInfo { fn clone(&self) -> Self { let r: &azul_core::callbacks::LayoutCallbackInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMarshaledLayoutCallback { fn clone(&self) -> Self { let r: &azul_core::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDom { fn clone(&self) -> Self { let r: &azul_core::dom::Dom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeData { fn clone(&self) -> Self { let r: &azul_core::dom::NodeData = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityInfo { fn clone(&self) -> Self { let r: &azul_core::dom::AccessibilityInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDomId { fn clone(&self) -> Self { let r: &azul_core::dom::DomId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDomNodeId { fn clone(&self) -> Self { let r: &azul_core::dom::DomNodeId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewOnColumnClickCallback { fn clone(&self) -> Self { let r: &azul_layout::widgets::list_view::ListViewOnColumnClickCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTagIdToNodeIdMapping { fn clone(&self) -> Self { let r: &azul_core::styled_dom::TagIdToNodeIdMapping = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCoreCallback { fn clone(&self) -> Self { let r: &azul_core::callbacks::CoreCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeHierarchyItemId { fn clone(&self) -> Self { let r: &azul_core::styled_dom::NodeHierarchyItemId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgXmlNode { fn clone(&self) -> Self { let r: &azul_core::svg::SvgXmlNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCoreCallbackData { fn clone(&self) -> Self { let r: &azul_core::callbacks::CoreCallbackData = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewOnRowClickCallback { fn clone(&self) -> Self { let r: &azul_layout::widgets::list_view::ListViewOnRowClickCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCoreMenuCallback { fn clone(&self) -> Self { let r: &azul_core::menu::CoreMenuCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAttributeNameValue { fn clone(&self) -> Self { let r: &azul_core::dom::AttributeNameValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckBoxOnToggleCallback { fn clone(&self) -> Self { let r: &azul_layout::widgets::check_box::CheckBoxOnToggleCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTabOnClickCallback { fn clone(&self) -> Self { let r: &azul_layout::widgets::tabs::TabOnClickCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzParentWithNodeDepth { fn clone(&self) -> Self { let r: &azul_core::styled_dom::ParentWithNodeDepth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewOnLazyLoadScrollCallback { fn clone(&self) -> Self { let r: &azul_layout::widgets::list_view::ListViewOnLazyLoadScrollCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeHierarchyItem { fn clone(&self) -> Self { let r: &azul_core::styled_dom::NodeHierarchyItem = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzButtonOnClickCallback { fn clone(&self) -> Self { let r: &azul_layout::widgets::button::ButtonOnClickCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlNode { fn clone(&self) -> Self { let r: &azul_core::xml::XmlNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTagId { fn clone(&self) -> Self { let r: &azul_core::dom::TagId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexAttribute { fn clone(&self) -> Self { let r: &azul_core::gl::VertexAttribute = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInstantPtrCloneCallback { fn clone(&self) -> Self { let r: &azul_core::task::InstantPtrCloneCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInstantPtrDestructorCallback { fn clone(&self) -> Self { let r: &azul_core::task::InstantPtrDestructorCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCallback { fn clone(&self) -> Self { let r: &azul_layout::callbacks::Callback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDebugState { fn clone(&self) -> Self { let r: &azul_core::window::DebugState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzKeyboardState { fn clone(&self) -> Self { let r: &azul_core::window::KeyboardState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTouchState { fn clone(&self) -> Self { let r: &azul_core::window::TouchState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMouseState { fn clone(&self) -> Self { let r: &azul_core::window::MouseState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenu { fn clone(&self) -> Self { let r: &azul_core::menu::Menu = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringMenuItem { fn clone(&self) -> Self { let r: &azul_core::menu::StringMenuItem = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssRuleBlock { fn clone(&self) -> Self { let r: &azul_css::css::CssRuleBlock = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssNthChildPattern { fn clone(&self) -> Self { let r: &azul_css::css::CssNthChildPattern = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStylesheet { fn clone(&self) -> Self { let r: &azul_css::css::Stylesheet = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCss { fn clone(&self) -> Self { let r: &azul_css::css::Css = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDynamicCssProperty { fn clone(&self) -> Self { let r: &azul_css::css::DynamicCssProperty = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorU { fn clone(&self) -> Self { let r: &azul_css::props::basic::color::ColorU = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPixelValue { fn clone(&self) -> Self { let r: &azul_css::props::basic::pixel::PixelValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPixelValueNoPercent { fn clone(&self) -> Self { let r: &azul_css::props::basic::pixel::PixelValueNoPercent = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBoxShadow { fn clone(&self) -> Self { let r: &azul_css::props::style::box_shadow::StyleBoxShadow = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBlur { fn clone(&self) -> Self { let r: &azul_css::props::style::filter::StyleBlur = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleColorMatrix { fn clone(&self) -> Self { let r: &azul_css::props::style::filter::StyleColorMatrix = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFilterOffset { fn clone(&self) -> Self { let r: &azul_css::props::style::filter::StyleFilterOffset = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBottom { fn clone(&self) -> Self { let r: &azul_css::props::layout::position::LayoutBottom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexGrow { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutFlexGrow = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexShrink { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutFlexShrink = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutLeft { fn clone(&self) -> Self { let r: &azul_css::props::layout::position::LayoutLeft = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginBottom { fn clone(&self) -> Self { let r: &azul_css::props::layout::spacing::LayoutMarginBottom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginLeft { fn clone(&self) -> Self { let r: &azul_css::props::layout::spacing::LayoutMarginLeft = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginRight { fn clone(&self) -> Self { let r: &azul_css::props::layout::spacing::LayoutMarginRight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMarginTop { fn clone(&self) -> Self { let r: &azul_css::props::layout::spacing::LayoutMarginTop = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMaxHeight { fn clone(&self) -> Self { let r: &azul_css::props::layout::dimensions::LayoutMaxHeight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMaxWidth { fn clone(&self) -> Self { let r: &azul_css::props::layout::dimensions::LayoutMaxWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMinHeight { fn clone(&self) -> Self { let r: &azul_css::props::layout::dimensions::LayoutMinHeight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutMinWidth { fn clone(&self) -> Self { let r: &azul_css::props::layout::dimensions::LayoutMinWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingBottom { fn clone(&self) -> Self { let r: &azul_css::props::layout::spacing::LayoutPaddingBottom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingLeft { fn clone(&self) -> Self { let r: &azul_css::props::layout::spacing::LayoutPaddingLeft = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingRight { fn clone(&self) -> Self { let r: &azul_css::props::layout::spacing::LayoutPaddingRight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingTop { fn clone(&self) -> Self { let r: &azul_css::props::layout::spacing::LayoutPaddingTop = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutRight { fn clone(&self) -> Self { let r: &azul_css::props::layout::position::LayoutRight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutTop { fn clone(&self) -> Self { let r: &azul_css::props::layout::position::LayoutTop = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFloatValue { fn clone(&self) -> Self { let r: &azul_css::props::basic::length::FloatValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPercentageValue { fn clone(&self) -> Self { let r: &azul_css::props::basic::length::PercentageValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAngleValue { fn clone(&self) -> Self { let r: &azul_css::props::basic::angle::AngleValue = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedLinearColorStop { fn clone(&self) -> Self { let r: &azul_css::props::style::background::NormalizedLinearColorStop = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedRadialColorStop { fn clone(&self) -> Self { let r: &azul_css::props::style::background::NormalizedRadialColorStop = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDirectionCorners { fn clone(&self) -> Self { let r: &azul_css::props::basic::direction::DirectionCorners = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLinearGradient { fn clone(&self) -> Self { let r: &azul_css::props::style::background::LinearGradient = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRadialGradient { fn clone(&self) -> Self { let r: &azul_css::props::style::background::RadialGradient = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzConicGradient { fn clone(&self) -> Self { let r: &azul_css::props::style::background::ConicGradient = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundPosition { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundPosition = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomColor { fn clone(&self) -> Self { let r: &azul_css::props::style::border::StyleBorderBottomColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomLeftRadius { fn clone(&self) -> Self { let r: &azul_css::props::style::border_radius::StyleBorderBottomLeftRadius = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomRightRadius { fn clone(&self) -> Self { let r: &azul_css::props::style::border_radius::StyleBorderBottomRightRadius = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderBottomStyle { fn clone(&self) -> Self { let r: &azul_css::props::style::border::StyleBorderBottomStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderBottomWidth { fn clone(&self) -> Self { let r: &azul_css::props::style::border::LayoutBorderBottomWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderLeftColor { fn clone(&self) -> Self { let r: &azul_css::props::style::border::StyleBorderLeftColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderLeftStyle { fn clone(&self) -> Self { let r: &azul_css::props::style::border::StyleBorderLeftStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderLeftWidth { fn clone(&self) -> Self { let r: &azul_css::props::style::border::LayoutBorderLeftWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderRightColor { fn clone(&self) -> Self { let r: &azul_css::props::style::border::StyleBorderRightColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderRightStyle { fn clone(&self) -> Self { let r: &azul_css::props::style::border::StyleBorderRightStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderRightWidth { fn clone(&self) -> Self { let r: &azul_css::props::style::border::LayoutBorderRightWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopColor { fn clone(&self) -> Self { let r: &azul_css::props::style::border::StyleBorderTopColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopLeftRadius { fn clone(&self) -> Self { let r: &azul_css::props::style::border_radius::StyleBorderTopLeftRadius = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopRightRadius { fn clone(&self) -> Self { let r: &azul_css::props::style::border_radius::StyleBorderTopRightRadius = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderTopStyle { fn clone(&self) -> Self { let r: &azul_css::props::style::border::StyleBorderTopStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderTopWidth { fn clone(&self) -> Self { let r: &azul_css::props::style::border::LayoutBorderTopWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzScrollbarInfo { fn clone(&self) -> Self { let r: &azul_css::props::style::scrollbar::ScrollbarInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzScrollbarStyle { fn clone(&self) -> Self { let r: &azul_css::props::style::scrollbar::ScrollbarStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontSize { fn clone(&self) -> Self { let r: &azul_css::props::basic::font::StyleFontSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleLetterSpacing { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleLetterSpacing = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleLineHeight { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleLineHeight = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTabWidth { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleTabWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleOpacity { fn clone(&self) -> Self { let r: &azul_css::props::style::effects::StyleOpacity = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformOrigin { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformOrigin = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformMatrix2D { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformMatrix2D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformMatrix3D { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformMatrix3D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformTranslate2D { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformTranslate2D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformTranslate3D { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformTranslate3D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformRotate3D { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformRotate3D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformScale2D { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformScale2D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformScale3D { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformScale3D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformSkew2D { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformSkew2D = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTextColor { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleTextColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleWordSpacing { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleWordSpacing = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCounterReset { fn clone(&self) -> Self { let r: &azul_css::props::style::content::CounterReset = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStylePerspectiveOrigin { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StylePerspectiveOrigin = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSelectionBackgroundColor { fn clone(&self) -> Self { let r: &azul_css::props::style::selection::SelectionBackgroundColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColumnRuleColor { fn clone(&self) -> Self { let r: &azul_css::props::layout::column::ColumnRuleColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCaretAnimationDuration { fn clone(&self) -> Self { let r: &azul_css::props::style::text::CaretAnimationDuration = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColumnRuleStyle { fn clone(&self) -> Self { let r: &azul_css::props::layout::column::ColumnRuleStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGridPlacement { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::GridPlacement = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGridTemplate { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::GridTemplate = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzContent { fn clone(&self) -> Self { let r: &azul_css::props::style::content::Content = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutGap { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::LayoutGap = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapeMargin { fn clone(&self) -> Self { let r: &azul_css::props::layout::shape::ShapeMargin = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCounterIncrement { fn clone(&self) -> Self { let r: &azul_css::props::style::content::CounterIncrement = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSelectionColor { fn clone(&self) -> Self { let r: &azul_css::props::style::selection::SelectionColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapeImageThreshold { fn clone(&self) -> Self { let r: &azul_css::props::layout::shape::ShapeImageThreshold = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColumnRuleWidth { fn clone(&self) -> Self { let r: &azul_css::props::layout::column::ColumnRuleWidth = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCaretColor { fn clone(&self) -> Self { let r: &azul_css::props::style::text::CaretColor = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutSize { fn clone(&self) -> Self { let r: &azul_css::props::basic::geometry::LayoutSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleLineClamp { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleLineClamp = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSelectionRadius { fn clone(&self) -> Self { let r: &azul_css::props::style::selection::SelectionRadius = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOrphans { fn clone(&self) -> Self { let r: &azul_css::props::layout::fragmentation::Orphans = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTextIndent { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleTextIndent = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBorderSpacing { fn clone(&self) -> Self { let r: &azul_css::props::layout::table::LayoutBorderSpacing = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingInlineStart { fn clone(&self) -> Self { let r: &azul_css::props::layout::spacing::LayoutPaddingInlineStart = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleExclusionMargin { fn clone(&self) -> Self { let r: &azul_css::props::style::azul_exclusion::StyleExclusionMargin = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWidows { fn clone(&self) -> Self { let r: &azul_css::props::layout::fragmentation::Widows = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutColumnGap { fn clone(&self) -> Self { let r: &azul_css::props::layout::spacing::LayoutColumnGap = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPaddingInlineEnd { fn clone(&self) -> Self { let r: &azul_css::props::layout::spacing::LayoutPaddingInlineEnd = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleHyphenationLanguage { fn clone(&self) -> Self { let r: &azul_css::props::style::azul_exclusion::StyleHyphenationLanguage = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutRowGap { fn clone(&self) -> Self { let r: &azul_css::props::layout::spacing::LayoutRowGap = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleHangingPunctuation { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleHangingPunctuation = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleInitialLetter { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleInitialLetter = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPhysicalSizeU32 { fn clone(&self) -> Self { let r: &azul_core::geom::PhysicalSizeU32 = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextSelectionStartEnd { fn clone(&self) -> Self { let r: &azul_core::dom::TextSelectionStartEnd = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgFillStyle { fn clone(&self) -> Self { let r: &azul_core::svg::SvgFillStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlTextPos { fn clone(&self) -> Self { let r: &azul_core::xml::XmlTextPos = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLogicalSize { fn clone(&self) -> Self { let r: &azul_core::geom::LogicalSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyledNodeState { fn clone(&self) -> Self { let r: &azul_core::styled_dom::StyledNodeState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPropertyCachePtr { fn clone(&self) -> Self { let r: &azul_core::prop_cache::CssPropertyCachePtr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgRenderTransform { fn clone(&self) -> Self { let r: &azul_core::svg::SvgRenderTransform = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLogicalPosition { fn clone(&self) -> Self { let r: &azul_core::geom::LogicalPosition = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPhysicalSize { fn clone(&self) -> Self { let r: &azul_core::geom::PhysicalSize = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyledDom { fn clone(&self) -> Self { let r: &azul_core::styled_dom::StyledDom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyledNode { fn clone(&self) -> Self { let r: &azul_core::styled_dom::StyledNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgTransform { fn clone(&self) -> Self { let r: &azul_core::svg::SvgTransform = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexLayout { fn clone(&self) -> Self { let r: &azul_core::gl::VertexLayout = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGridMinMax { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::GridMinMax = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNamedGridLine { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::NamedGridLine = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzScrollbarColorCustom { fn clone(&self) -> Self { let r: &azul_css::props::style::scrollbar::ScrollbarColorCustom = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapeInset { fn clone(&self) -> Self { let r: &azul_css::shape::ShapeInset = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapePath { fn clone(&self) -> Self { let r: &azul_css::shape::ShapePath = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapeEllipse { fn clone(&self) -> Self { let r: &azul_css::shape::ShapeEllipse = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapePoint { fn clone(&self) -> Self { let r: &azul_css::shape::ShapePoint = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutRect { fn clone(&self) -> Self { let r: &azul_css::props::basic::geometry::LayoutRect = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPoint { fn clone(&self) -> Self { let r: &azul_css::props::basic::geometry::LayoutPoint = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPhysicalPosition { fn clone(&self) -> Self { let r: &azul_core::geom::PhysicalPosition = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLinuxDecorationsState { fn clone(&self) -> Self { let r: &azul_core::window::LinuxDecorationsState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzButton { fn clone(&self) -> Self { let r: &azul_layout::widgets::button::Button = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzButtonOnClick { fn clone(&self) -> Self { let r: &azul_layout::widgets::button::ButtonOnClick = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFileInput { fn clone(&self) -> Self { let r: &azul_layout::widgets::file_input::FileInput = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFileInputStateWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::file_input::FileInputStateWrapper = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFileInputState { fn clone(&self) -> Self { let r: &azul_layout::widgets::file_input::FileInputState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFileInputOnPathChange { fn clone(&self) -> Self { let r: &azul_layout::widgets::file_input::FileInputOnPathChange = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFileInputOnPathChangeCallback { fn clone(&self) -> Self { let r: &azul_layout::widgets::file_input::FileInputOnPathChangeCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckBox { fn clone(&self) -> Self { let r: &azul_layout::widgets::check_box::CheckBox = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckBoxStateWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::check_box::CheckBoxStateWrapper = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckBoxOnToggle { fn clone(&self) -> Self { let r: &azul_layout::widgets::check_box::CheckBoxOnToggle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCheckBoxState { fn clone(&self) -> Self { let r: &azul_layout::widgets::check_box::CheckBoxState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorInput { fn clone(&self) -> Self { let r: &azul_layout::widgets::color_input::ColorInput = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorInputStateWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::color_input::ColorInputStateWrapper = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorInputState { fn clone(&self) -> Self { let r: &azul_layout::widgets::color_input::ColorInputState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorInputOnValueChange { fn clone(&self) -> Self { let r: &azul_layout::widgets::color_input::ColorInputOnValueChange = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColorInputOnValueChangeCallback { fn clone(&self) -> Self { let r: &azul_layout::widgets::color_input::ColorInputOnValueChangeCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInput { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::TextInput = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputStateWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::TextInputStateWrapper = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputState { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::TextInputState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputSelectionRange { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::TextInputSelectionRange = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnTextInput { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::TextInputOnTextInput = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnTextInputCallback { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::TextInputOnTextInputCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnVirtualKeyDown { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::TextInputOnVirtualKeyDown = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnVirtualKeyDownCallback { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::TextInputOnVirtualKeyDownCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnFocusLost { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::TextInputOnFocusLost = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputOnFocusLostCallback { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::TextInputOnFocusLostCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOnTextInputReturn { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::OnTextInputReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInput { fn clone(&self) -> Self { let r: &azul_layout::widgets::number_input::NumberInput = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputStateWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::number_input::NumberInputStateWrapper = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputState { fn clone(&self) -> Self { let r: &azul_layout::widgets::number_input::NumberInputState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputOnValueChange { fn clone(&self) -> Self { let r: &azul_layout::widgets::number_input::NumberInputOnValueChange = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputOnValueChangeCallback { fn clone(&self) -> Self { let r: &azul_layout::widgets::number_input::NumberInputOnValueChangeCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputOnFocusLost { fn clone(&self) -> Self { let r: &azul_layout::widgets::number_input::NumberInputOnFocusLost = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNumberInputOnFocusLostCallback { fn clone(&self) -> Self { let r: &azul_layout::widgets::number_input::NumberInputOnFocusLostCallback = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzProgressBar { fn clone(&self) -> Self { let r: &azul_layout::widgets::progressbar::ProgressBar = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzProgressBarState { fn clone(&self) -> Self { let r: &azul_layout::widgets::progressbar::ProgressBarState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTabHeader { fn clone(&self) -> Self { let r: &azul_layout::widgets::tabs::TabHeader = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTabOnClick { fn clone(&self) -> Self { let r: &azul_layout::widgets::tabs::TabOnClick = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFrame { fn clone(&self) -> Self { let r: &azul_layout::widgets::frame::Frame = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListView { fn clone(&self) -> Self { let r: &azul_layout::widgets::list_view::ListView = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewRow { fn clone(&self) -> Self { let r: &azul_layout::widgets::list_view::ListViewRow = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewOnLazyLoadScroll { fn clone(&self) -> Self { let r: &azul_layout::widgets::list_view::ListViewOnLazyLoadScroll = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewOnColumnClick { fn clone(&self) -> Self { let r: &azul_layout::widgets::list_view::ListViewOnColumnClick = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewOnRowClick { fn clone(&self) -> Self { let r: &azul_layout::widgets::list_view::ListViewOnRowClick = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIFrameNode { fn clone(&self) -> Self { let r: &azul_core::dom::IFrameNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewState { fn clone(&self) -> Self { let r: &azul_layout::widgets::list_view::ListViewState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTabHeaderState { fn clone(&self) -> Self { let r: &azul_layout::widgets::tabs::TabHeaderState = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTexture { fn clone(&self) -> Self { let r: &azul_core::gl::Texture = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGlVoidPtrConst { fn clone(&self) -> Self { let r: &azul_core::gl::GlVoidPtrConst = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGlVoidPtrMut { fn clone(&self) -> Self { let r: &azul_core::gl::GlVoidPtrMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextureFlags { fn clone(&self) -> Self { let r: &azul_core::gl::TextureFlags = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGlShaderPrecisionFormatReturn { fn clone(&self) -> Self { let r: &azul_core::gl::GlShaderPrecisionFormatReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGlContextPtr { fn clone(&self) -> Self { let r: &azul_core::gl::GlContextPtr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGetProgramBinaryReturn { fn clone(&self) -> Self { let r: &azul_core::gl::GetProgramBinaryReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGetActiveAttribReturn { fn clone(&self) -> Self { let r: &azul_core::gl::GetActiveAttribReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLsyncPtr { fn clone(&self) -> Self { let r: &azul_core::gl::GLsyncPtr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGetActiveUniformReturn { fn clone(&self) -> Self { let r: &azul_core::gl::GetActiveUniformReturn = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgVertex { fn clone(&self) -> Self { let r: &azul_core::svg::SvgVertex = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexArrayObject { fn clone(&self) -> Self { let r: &azul_core::gl::VertexArrayObject = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexBuffer { fn clone(&self) -> Self { let r: &azul_core::gl::VertexBuffer = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzImageRef { fn clone(&self) -> Self { let r: &azul_core::resources::ImageRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRawImage { fn clone(&self) -> Self { let r: &azul_core::resources::RawImage = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzImageMask { fn clone(&self) -> Self { let r: &azul_core::resources::ImageMask = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFontMetrics { fn clone(&self) -> Self { let r: &azul_css::props::basic::font::FontMetrics = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFontRef { fn clone(&self) -> Self { let r: &azul_css::props::basic::font::FontRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLoadedFontSource { fn clone(&self) -> Self { let r: &azul_core::resources::LoadedFontSource = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvg { fn clone(&self) -> Self { let r: &azul_core::svg::Svg = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgMultiPolygon { fn clone(&self) -> Self { let r: &azul_core::svg::SvgMultiPolygon = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgCircle { fn clone(&self) -> Self { let r: &azul_core::svg::SvgCircle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPath { fn clone(&self) -> Self { let r: &azul_core::svg::SvgPath = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPoint { fn clone(&self) -> Self { let r: &azul_css::props::basic::animation::SvgPoint = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgVector { fn clone(&self) -> Self { let r: &azul_css::props::basic::animation::SvgVector = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgLine { fn clone(&self) -> Self { let r: &azul_core::svg::SvgLine = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgQuadraticCurve { fn clone(&self) -> Self { let r: &azul_css::props::basic::animation::SvgQuadraticCurve = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgCubicCurve { fn clone(&self) -> Self { let r: &azul_css::props::basic::animation::SvgCubicCurve = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgRect { fn clone(&self) -> Self { let r: &azul_css::props::basic::animation::SvgRect = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedSvgNode { fn clone(&self) -> Self { let r: &azul_core::svg::TessellatedSvgNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgDashPattern { fn clone(&self) -> Self { let r: &azul_core::svg::SvgDashPattern = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgStrokeStyle { fn clone(&self) -> Self { let r: &azul_core::svg::SvgStrokeStyle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLogicalRect { fn clone(&self) -> Self { let r: &azul_core::geom::LogicalRect = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPath { fn clone(&self) -> Self { let r: &azul_css::css::CssPath = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedGPUSvgNode { fn clone(&self) -> Self { let r: &azul_core::svg::TessellatedGPUSvgNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedColoredGPUSvgNode { fn clone(&self) -> Self { let r: &azul_core::svg::TessellatedColoredGPUSvgNode = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapeCircle { fn clone(&self) -> Self { let r: &azul_css::shape::ShapeCircle = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapePolygon { fn clone(&self) -> Self { let r: &azul_css::shape::ShapePolygon = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXml { fn clone(&self) -> Self { let r: &azul_core::xml::Xml = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSystemTickDiff { fn clone(&self) -> Self { let r: &azul_core::task::SystemTickDiff = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSystemTick { fn clone(&self) -> Self { let r: &azul_core::task::SystemTick = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSystemTimeDiff { fn clone(&self) -> Self { let r: &azul_core::task::SystemTimeDiff = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTimerId { fn clone(&self) -> Self { let r: &azul_core::task::TimerId = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInstantPtr { fn clone(&self) -> Self { let r: &azul_core::task::InstantPtr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssDuration { fn clone(&self) -> Self { let r: &azul_css::props::basic::time::CssDuration = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzString { fn clone(&self) -> Self { let r: &azul_css::corety::AzString = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRefstr { fn clone(&self) -> Self { let r: &azul_core::gl::Refstr = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringPair { fn clone(&self) -> Self { let r: &azul_core::window::AzStringPair = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringSet { fn clone(&self) -> Self { let r: &azul_css::props::style::content::StringSet = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewRowVec { fn clone(&self) -> Self { let r: &azul_layout::widgets::list_view::ListViewRowVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFilterVec { fn clone(&self) -> Self { let r: &azul_css::props::style::filter::StyleFilterVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityStateVec { fn clone(&self) -> Self { let r: &azul_core::dom::AccessibilityStateVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuItemVec { fn clone(&self) -> Self { let r: &azul_core::menu::MenuItemVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontFamilyVec { fn clone(&self) -> Self { let r: &azul_css::props::basic::font::StyleFontFamilyVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDomVec { fn clone(&self) -> Self { let r: &azul_core::dom::DomVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIdOrClassVec { fn clone(&self) -> Self { let r: &azul_core::dom::IdOrClassVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDataInlineCssPropertyVec { fn clone(&self) -> Self { let r: &azul_core::dom::NodeDataInlineCssPropertyVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundContentVec { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundContentVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundPositionVec { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundPositionVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundRepeatVec { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundRepeatVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundSizeVec { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundSizeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformVec { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgMultiPolygonVec { fn clone(&self) -> Self { let r: &azul_core::svg::SvgMultiPolygonVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgSimpleNodeVec { fn clone(&self) -> Self { let r: &azul_core::svg::SvgSimpleNodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPathVec { fn clone(&self) -> Self { let r: &azul_core::svg::SvgPathVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPathElementVec { fn clone(&self) -> Self { let r: &azul_core::svg::SvgPathElementVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgVertexVec { fn clone(&self) -> Self { let r: &azul_core::svg::SvgVertexVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU32Vec { fn clone(&self) -> Self { let r: &azul_css::corety::U32Vec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVirtualKeyCodeVec { fn clone(&self) -> Self { let r: &azul_core::window::VirtualKeyCodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCascadeInfoVec { fn clone(&self) -> Self { let r: &azul_core::style::CascadeInfoVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssDeclarationVec { fn clone(&self) -> Self { let r: &azul_css::css::CssDeclarationVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPathSelectorVec { fn clone(&self) -> Self { let r: &azul_css::css::CssPathSelectorVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStylesheetVec { fn clone(&self) -> Self { let r: &azul_css::css::StylesheetVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssRuleBlockVec { fn clone(&self) -> Self { let r: &azul_css::css::CssRuleBlockVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU16Vec { fn clone(&self) -> Self { let r: &azul_css::corety::U16Vec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzF32Vec { fn clone(&self) -> Self { let r: &azul_css::corety::F32Vec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU8Vec { fn clone(&self) -> Self { let r: &azul_css::corety::U8Vec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLuintVec { fn clone(&self) -> Self { let r: &azul_core::gl::GLuintVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLintVec { fn clone(&self) -> Self { let r: &azul_core::gl::GLintVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringVec { fn clone(&self) -> Self { let r: &azul_css::corety::StringVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringPairVec { fn clone(&self) -> Self { let r: &azul_core::window::StringPairVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedLinearColorStopVec { fn clone(&self) -> Self { let r: &azul_css::props::style::background::NormalizedLinearColorStopVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedRadialColorStopVec { fn clone(&self) -> Self { let r: &azul_css::props::style::background::NormalizedRadialColorStopVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeIdVec { fn clone(&self) -> Self { let r: &azul_core::styled_dom::NodeIdVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeHierarchyItemVec { fn clone(&self) -> Self { let r: &azul_core::styled_dom::NodeHierarchyItemVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyledNodeVec { fn clone(&self) -> Self { let r: &azul_core::styled_dom::StyledNodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTagIdToNodeIdMappingVec { fn clone(&self) -> Self { let r: &azul_core::styled_dom::TagIdToNodeIdMappingVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzParentWithNodeDepthVec { fn clone(&self) -> Self { let r: &azul_core::styled_dom::ParentWithNodeDepthVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDataVec { fn clone(&self) -> Self { let r: &azul_core::dom::NodeDataVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAttributeVec { fn clone(&self) -> Self { let r: &azul_core::dom::AttributeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCoreCallbackDataVec { fn clone(&self) -> Self { let r: &azul_core::callbacks::CoreCallbackDataVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityActionVec { fn clone(&self) -> Self { let r: &azul_core::dom::AccessibilityActionVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlNodeChildVec { fn clone(&self) -> Self { let r: &azul_core::xml::XmlNodeChildVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGridTrackSizingVec { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::GridTrackSizingVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLbooleanVecRefMut { fn clone(&self) -> Self { let r: &azul_core::gl::GLbooleanVecRefMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRefstrVecRef { fn clone(&self) -> Self { let r: &azul_core::gl::RefstrVecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLfloatVecRefMut { fn clone(&self) -> Self { let r: &azul_core::gl::GLfloatVecRefMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU8VecRefMut { fn clone(&self) -> Self { let r: &azul_core::gl::U8VecRefMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTessellatedSvgNodeVecRef { fn clone(&self) -> Self { let r: &azul_core::svg::TessellatedSvgNodeVecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzF32VecRef { fn clone(&self) -> Self { let r: &azul_core::gl::F32VecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLuintVecRef { fn clone(&self) -> Self { let r: &azul_core::gl::GLuintVecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzI32VecRef { fn clone(&self) -> Self { let r: &azul_core::gl::I32VecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU8VecRef { fn clone(&self) -> Self { let r: &azul_core::gl::U8VecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLintVecRefMut { fn clone(&self) -> Self { let r: &azul_core::gl::GLintVecRefMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLenumVecRef { fn clone(&self) -> Self { let r: &azul_core::gl::GLenumVecRef = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLint64VecRefMut { fn clone(&self) -> Self { let r: &azul_core::gl::GLint64VecRefMut = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexAttributeVec { fn clone(&self) -> Self { let r: &azul_core::gl::VertexAttributeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDebugMessageVec { fn clone(&self) -> Self { let r: &azul_core::gl::DebugMessageVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapePointVec { fn clone(&self) -> Self { let r: &azul_css::shape::ShapePointVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMonitorVec { fn clone(&self) -> Self { let r: &azul_core::window::MonitorVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVideoModeVec { fn clone(&self) -> Self { let r: &azul_core::window::VideoModeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXWindowTypeVec { fn clone(&self) -> Self { let r: &azul_core::window::XWindowTypeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzScanCodeVec { fn clone(&self) -> Self { let r: &azul_core::window::ScanCodeVec = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgParseOptions { fn clone(&self) -> Self { let r: &azul_core::svg::SvgParseOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgXmlOptions { fn clone(&self) -> Self { let r: &azul_core::svg::SvgXmlOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgRenderOptions { fn clone(&self) -> Self { let r: &azul_core::svg::SvgRenderOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRendererOptions { fn clone(&self) -> Self { let r: &azul_core::window::RendererOptions = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDuplicatedNamespaceError { fn clone(&self) -> Self { let r: &azul_core::xml::DuplicatedNamespaceError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzUnknownNamespaceError { fn clone(&self) -> Self { let r: &azul_core::xml::UnknownNamespaceError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzUnexpectedCloseTagError { fn clone(&self) -> Self { let r: &azul_core::xml::UnexpectedCloseTagError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzUnknownEntityReferenceError { fn clone(&self) -> Self { let r: &azul_core::xml::UnknownEntityReferenceError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDuplicatedAttributeError { fn clone(&self) -> Self { let r: &azul_core::xml::DuplicatedAttributeError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlTextError { fn clone(&self) -> Self { let r: &azul_core::xml::XmlTextError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNonXmlCharError { fn clone(&self) -> Self { let r: &azul_core::xml::NonXmlCharError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInvalidCharError { fn clone(&self) -> Self { let r: &azul_core::xml::InvalidCharError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInvalidCharMultipleError { fn clone(&self) -> Self { let r: &azul_core::xml::InvalidCharMultipleError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInvalidQuoteError { fn clone(&self) -> Self { let r: &azul_core::xml::InvalidQuoteError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInvalidSpaceError { fn clone(&self) -> Self { let r: &azul_core::xml::InvalidSpaceError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInvalidStringError { fn clone(&self) -> Self { let r: &azul_core::xml::InvalidStringError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMalformedHierarchyError { fn clone(&self) -> Self { let r: &azul_core::xml::MalformedHierarchyError = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCascadeInfo { fn clone(&self) -> Self { let r: &azul_core::style::CascadeInfo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVirtualKeyCodeCombo { fn clone(&self) -> Self { let r: &azul_core::window::VirtualKeyCodeCombo = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInterpolateResolver { fn clone(&self) -> Self { let r: &azul_css::props::basic::animation::InterpolateResolver = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRefCount { fn clone(&self) -> Self { let r: &azul_core::refany::RefCount = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRefAny { fn clone(&self) -> Self { let r: &azul_core::refany::RefAny = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDebugMessage { fn clone(&self) -> Self { let r: &azul_core::gl::DebugMessage = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAppConfig { fn clone(&self) -> Self { let r: &azul_core::resources::AppConfig = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzApp { fn clone(&self) -> Self { let r: &azul_dll::desktop::app::App = unsafe { mem::transmute(self) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleCursorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::effects::StyleCursor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::events::WindowEventFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowThemeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowTheme = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMouseCursorTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::MouseCursorType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowFrameEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowFrame = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzUserAttentionTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::UserAttentionType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzHwAccelerationEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::HwAcceleration = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVsyncEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::Vsync = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXWindowTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::XWindowType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowIconEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowIcon = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIFrameCallbackReasonEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::IFrameCallbackReason = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutCallbackEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::LayoutCallback = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::NodeType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityRoleEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::AccessibilityRole = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityStateEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::AccessibilityState = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTabIndexEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::TabIndex = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDataInlineCssPropertyEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::NodeDataInlineCssProperty = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityActionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::AccessibilityAction = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgSimpleNodeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgSimpleNode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAttributeTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::AttributeType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlNodeChildEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::xml::XmlNodeChild = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeTypeTagEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::NodeTypeTag = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexAttributeTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::VertexAttributeType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzContextMenuMouseButtonEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::ContextMenuMouseButton = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuPopupPositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::menu::MenuPopupPosition = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuItemEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::menu::MenuItem = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuItemIconEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::menu::MenuItemIcon = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuItemStateEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::menu::MenuItemState = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPropertyEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::property::CssProperty = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssNthChildSelectorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::CssNthChildSelector = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssDeclarationEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::CssDeclaration = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAnimationInterpolationFunctionEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::animation::AnimationInterpolationFunction = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSizeMetricEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::length::SizeMetric = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzBoxShadowClipModeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::box_shadow::BoxShadowClipMode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleMixBlendModeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::effects::StyleMixBlendMode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::filter::StyleFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleCompositeFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::filter::StyleCompositeFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutAlignContentEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutAlignContent = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutAlignItemsEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutAlignItems = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutBoxSizingEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::dimensions::LayoutBoxSizing = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexDirectionEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutFlexDirection = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutDisplayEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::display::LayoutDisplay = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFloatEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::display::LayoutFloat = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutHeightEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::dimensions::LayoutHeight = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutJustifyContentEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutJustifyContent = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutPositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::position::LayoutPosition = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutWidthEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::dimensions::LayoutWidth = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexWrapEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutFlexWrap = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutOverflowEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::overflow::LayoutOverflow = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAngleMetricEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::angle::AngleMetric = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDirectionCornerEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::direction::DirectionCorner = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDirectionEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::direction::Direction = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::Shape = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRadialGradientSizeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::RadialGradientSize = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundContentEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundContent = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzBackgroundPositionHorizontalEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::BackgroundPositionHorizontal = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzBackgroundPositionVerticalEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::BackgroundPositionVertical = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundRepeatEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundRepeat = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundSizeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundSize = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzBorderStyleEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::border::BorderStyle = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontFamilyEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::font::StyleFontFamily = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackfaceVisibilityEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleBackfaceVisibility = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransform = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTextAlignEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleTextAlign = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPropertyValueEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::CssPropertyValue = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGridLineEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::GridLine = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutZIndexEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::position::LayoutZIndex = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutJustifyItemsEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::LayoutJustifyItems = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColumnSpanEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::column::ColumnSpan = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutClearEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::wrapping::LayoutClear = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleWhiteSpaceEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleWhiteSpace = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzBreakInsideEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::fragmentation::BreakInside = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutAlignSelfEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutAlignSelf = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapeOutsideEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::shape::ShapeOutside = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColumnCountEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::column::ColumnCount = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutWritingModeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::wrapping::LayoutWritingMode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleUserSelectEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleUserSelect = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutJustifySelfEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::LayoutJustifySelf = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleHyphensEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleHyphens = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleDirectionEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleDirection = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutFlexBasisEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flex::LayoutFlexBasis = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutTextJustifyEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::text::LayoutTextJustify = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColumnWidthEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::column::ColumnWidth = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzBoxDecorationBreakEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::fragmentation::BoxDecorationBreak = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleVisibilityEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::effects::StyleVisibility = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutGridAutoFlowEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::LayoutGridAutoFlow = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTextDecorationEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleTextDecoration = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzColumnFillEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::column::ColumnFill = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzPageBreakEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::fragmentation::PageBreak = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutScrollbarWidthEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::scrollbar::LayoutScrollbarWidth = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleScrollbarColorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::scrollbar::StyleScrollbarColor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleVerticalAlignEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleVerticalAlign = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapeInsideEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::shape::ShapeInside = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontWeightEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::font::StyleFontWeight = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleListStyleTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::lists::StyleListStyleType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzClipPathEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::shape::ClipPath = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleListStylePositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::lists::StyleListStylePosition = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBorderCollapseEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::table::StyleBorderCollapse = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleCaptionSideEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::table::StyleCaptionSide = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzLayoutTableLayoutEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::table::LayoutTableLayout = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleEmptyCellsEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::table::StyleEmptyCells = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontStyleEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::font::StyleFontStyle = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTextCombineUprightEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::text::StyleTextCombineUpright = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGridTrackSizingEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::GridTrackSizing = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzHoverEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::events::HoverEventFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapeRenderingEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::ShapeRendering = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzApplicationEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::events::ApplicationEventFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextRenderingEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::TextRendering = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFocusEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::events::FocusEventFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::events::EventFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgStyleEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgStyle = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIndentEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::Indent = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFontDatabaseEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::FontDatabase = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNotEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::events::NotEventFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzComponentEventFilterEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::events::ComponentEventFilter = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssShapeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::shape::CssShape = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowBackgroundMaterialEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowBackgroundMaterial = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowPositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowPosition = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCursorPositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::CursorPosition = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzImePositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::ImePosition = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzWindowDecorationsEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::WindowDecorations = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSrgbEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::Srgb = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputSelectionEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::TextInputSelection = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTextInputValidEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::TextInputValid = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIndexBufferFormatEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::IndexBufferFormat = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGlTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::GlType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRawImageFormatEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::resources::RawImageFormat = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRawImageDataEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::resources::RawImageData = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzImageRenderingEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::ImageRendering = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgNodeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgNode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPathElementEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgPathElement = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgFitToEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgFitTo = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgFillRuleEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgFillRule = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgLineJoinEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgLineJoin = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgLineCapEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgLineCap = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPathPseudoSelectorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::CssPathPseudoSelector = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPathSelectorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::CssPathSelector = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzInstantEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::task::Instant = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDurationEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::task::Duration = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionU8VecRefEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::OptionU8VecRef = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPathVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgPathVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFilterVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::filter::StyleFilterVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleTransformVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::transform::StyleTransformVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLuintVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::GLuintVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlNodeChildVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::xml::XmlNodeChildVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundContentVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundContentVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCascadeInfoVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::style::CascadeInfoVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityStateVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::AccessibilityStateVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDomVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::DomVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::StringVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDataVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::NodeDataVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMenuItemVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::menu::MenuItemVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgMultiPolygonVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgMultiPolygonVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzListViewRowVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::list_view::ListViewRowVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgVertexVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgVertexVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStylesheetVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::StylesheetVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU32VecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::U32VecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssRuleBlockVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::CssRuleBlockVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedLinearColorStopVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::NormalizedLinearColorStopVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleFontFamilyVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::font::StyleFontFamilyVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssPathSelectorVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::CssPathSelectorVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeHierarchyItemVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::styled_dom::NodeHierarchyItemVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVirtualKeyCodeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::VirtualKeyCodeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzF32VecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::F32VecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundRepeatVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundRepeatVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAccessibilityActionVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::AccessibilityActionVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU16VecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::U16VecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzTagIdToNodeIdMappingVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::styled_dom::TagIdToNodeIdMappingVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeIdVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::styled_dom::NodeIdVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzParentWithNodeDepthVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::styled_dom::ParentWithNodeDepthVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGLintVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::GLintVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNodeDataInlineCssPropertyVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::NodeDataInlineCssPropertyVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzNormalizedRadialColorStopVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::NormalizedRadialColorStopVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyledNodeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::styled_dom::StyledNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundPositionVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundPositionVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgSimpleNodeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgSimpleNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAttributeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::AttributeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCssDeclarationVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::css::CssDeclarationVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIdOrClassVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::IdOrClassVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStyleBackgroundSizeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::StyleBackgroundSizeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzStringPairVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::StringPairVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzCoreCallbackDataVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::CoreCallbackDataVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgPathElementVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgPathElementVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzU8VecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::U8VecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzGridTrackSizingVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::grid::GridTrackSizingVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVertexAttributeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::VertexAttributeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDebugMessageVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::DebugMessageVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzShapePointVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::shape::ShapePointVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXWindowTypeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::XWindowTypeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzMonitorVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::MonitorVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVideoModeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::VideoModeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzScanCodeVecDestructorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::ScanCodeVecDestructor = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionSvgPointEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::animation::OptionSvgPoint = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionListViewOnRowClickEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::list_view::OptionListViewOnRowClick = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionListViewOnColumnClickEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::list_view::OptionListViewOnColumnClick = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionListViewOnLazyLoadScrollEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::list_view::OptionListViewOnLazyLoadScroll = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionMenuEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::menu::OptionMenu = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionPixelValueNoPercentEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::pixel::OptionPixelValueNoPercent = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionColorInputOnValueChangeEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::color_input::OptionColorInputOnValueChange = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionButtonOnClickEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::button::OptionButtonOnClick = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTabOnClickEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::tabs::OptionTabOnClick = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionFileInputOnPathChangeEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::file_input::OptionFileInputOnPathChange = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionCheckBoxOnToggleEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::check_box::OptionCheckBoxOnToggle = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTextInputOnTextInputEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::OptionTextInputOnTextInput = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTextInputOnVirtualKeyDownEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::OptionTextInputOnVirtualKeyDown = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTextInputOnFocusLostEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::OptionTextInputOnFocusLost = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTextInputSelectionEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::text_input::OptionTextInputSelection = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionNumberInputOnFocusLostEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::number_input::OptionNumberInputOnFocusLost = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionNumberInputOnValueChangeEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::widgets::number_input::OptionNumberInputOnValueChange = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionMenuItemIconEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::menu::OptionMenuItemIcon = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionVirtualKeyCodeComboEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionVirtualKeyCodeCombo = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTimerIdEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::task::OptionTimerId = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionI16EnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::OptionI16 = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionU16EnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::OptionU16 = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionU32EnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::OptionU32 = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionImageRefEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::resources::OptionImageRef = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionFontRefEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::font::OptionFontRef = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionRefAnyEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::refany::OptionRefAny = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionLayoutSizeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::geometry::OptionLayoutSize = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionDomNodeIdEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::OptionDomNodeId = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionColorUEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::basic::color::OptionColorU = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionRawImageEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::resources::OptionRawImage = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionSvgDashPatternEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::OptionSvgDashPattern = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTabIndexEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::OptionTabIndex = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTagIdEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::OptionTagId = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionDurationEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::task::OptionDuration = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionUsizeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::gl::OptionUsize = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionCoreMenuCallbackEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::menu::OptionCoreMenuCallback = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionStyledDomEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::styled_dom::OptionStyledDom = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionLogicalPositionEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::geom::OptionLogicalPosition = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionStringEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::OptionString = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionF32EnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::OptionF32 = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionWaylandThemeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionWaylandTheme = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionMouseCursorTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionMouseCursorType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionWindowIconEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionWindowIcon = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionCallbackEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::callbacks::OptionCallback = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionTaskBarIconEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionTaskBarIcon = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionHwndHandleEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionHwndHandle = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionLinuxDecorationsStateEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionLinuxDecorationsState = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionI32EnumWrapper { fn clone(&self) -> Self { let r: &azul_css::corety::OptionI32 = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionLogicalSizeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::geom::OptionLogicalSize = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionVirtualKeyCodeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionVirtualKeyCode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionX11VisualEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionX11Visual = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionRendererOptionsEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionRendererOptions = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzOptionWindowThemeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::OptionWindowTheme = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzResultXmlXmlErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::xml::ResultXmlXmlError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzResultSvgSvgParseErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::ResultSvgSvgParseError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzSvgParseErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::svg::SvgParseError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::xml::XmlError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlParseErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::xml::XmlParseError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzXmlStreamErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::xml::XmlStreamError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzEncodeImageErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::image::encode::EncodeImageError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzResultRawImageDecodeImageErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::image::decode::ResultRawImageDecodeImageError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzDecodeImageErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::image::decode::DecodeImageError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzResultU8VecEncodeImageErrorEnumWrapper { fn clone(&self) -> Self { let r: &azul_layout::image::encode::ResultU8VecEncodeImageError = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzRendererTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::RendererType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzExtendModeEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::style::background::ExtendMode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFlowIntoEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flow::FlowInto = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzVirtualKeyCodeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::window::VirtualKeyCode = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzIdOrClassEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::dom::IdOrClass = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzFlowFromEnumWrapper { fn clone(&self) -> Self { let r: &azul_css::props::layout::flow::FlowFrom = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzUpdateEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::Update = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzEdgeTypeEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::callbacks::EdgeType = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAppTerminationBehaviorEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::resources::AppTerminationBehavior = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }
impl Clone for AzAppLogLevelEnumWrapper { fn clone(&self) -> Self { let r: &azul_core::resources::AppLogLevel = unsafe { mem::transmute(&self.inner) }; unsafe { mem::transmute(r.clone()) } } }

// Implement Drop for all objects with drop constructors
impl Drop for AzTexture { fn drop(&mut self) { crate::AzTexture_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzGlVoidPtrConst { fn drop(&mut self) { crate::AzGlVoidPtrConst_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzGlContextPtr { fn drop(&mut self) { crate::AzGlContextPtr_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzGLsyncPtr { fn drop(&mut self) { crate::AzGLsyncPtr_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzImageRef { fn drop(&mut self) { crate::AzImageRef_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzFontRef { fn drop(&mut self) { crate::AzFontRef_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvg { fn drop(&mut self) { crate::AzSvg_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzListViewRowVec { fn drop(&mut self) { crate::AzListViewRowVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleFilterVec { fn drop(&mut self) { crate::AzStyleFilterVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzAccessibilityStateVec { fn drop(&mut self) { crate::AzAccessibilityStateVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzMenuItemVec { fn drop(&mut self) { crate::AzMenuItemVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleFontFamilyVec { fn drop(&mut self) { crate::AzStyleFontFamilyVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzDomVec { fn drop(&mut self) { crate::AzDomVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzIdOrClassVec { fn drop(&mut self) { crate::AzIdOrClassVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeDataInlineCssPropertyVec { fn drop(&mut self) { crate::AzNodeDataInlineCssPropertyVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleBackgroundContentVec { fn drop(&mut self) { crate::AzStyleBackgroundContentVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleBackgroundPositionVec { fn drop(&mut self) { crate::AzStyleBackgroundPositionVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleBackgroundRepeatVec { fn drop(&mut self) { crate::AzStyleBackgroundRepeatVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleBackgroundSizeVec { fn drop(&mut self) { crate::AzStyleBackgroundSizeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyleTransformVec { fn drop(&mut self) { crate::AzStyleTransformVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgMultiPolygonVec { fn drop(&mut self) { crate::AzSvgMultiPolygonVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgSimpleNodeVec { fn drop(&mut self) { crate::AzSvgSimpleNodeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgPathVec { fn drop(&mut self) { crate::AzSvgPathVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgPathElementVec { fn drop(&mut self) { crate::AzSvgPathElementVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzSvgVertexVec { fn drop(&mut self) { crate::AzSvgVertexVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzU32Vec { fn drop(&mut self) { crate::AzU32Vec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzVirtualKeyCodeVec { fn drop(&mut self) { crate::AzVirtualKeyCodeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCascadeInfoVec { fn drop(&mut self) { crate::AzCascadeInfoVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCssDeclarationVec { fn drop(&mut self) { crate::AzCssDeclarationVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCssPathSelectorVec { fn drop(&mut self) { crate::AzCssPathSelectorVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStylesheetVec { fn drop(&mut self) { crate::AzStylesheetVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCssRuleBlockVec { fn drop(&mut self) { crate::AzCssRuleBlockVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzU16Vec { fn drop(&mut self) { crate::AzU16Vec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzF32Vec { fn drop(&mut self) { crate::AzF32Vec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzU8Vec { fn drop(&mut self) { crate::AzU8Vec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzGLuintVec { fn drop(&mut self) { crate::AzGLuintVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzGLintVec { fn drop(&mut self) { crate::AzGLintVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStringVec { fn drop(&mut self) { crate::AzStringVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStringPairVec { fn drop(&mut self) { crate::AzStringPairVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNormalizedLinearColorStopVec { fn drop(&mut self) { crate::AzNormalizedLinearColorStopVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNormalizedRadialColorStopVec { fn drop(&mut self) { crate::AzNormalizedRadialColorStopVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeIdVec { fn drop(&mut self) { crate::AzNodeIdVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeHierarchyItemVec { fn drop(&mut self) { crate::AzNodeHierarchyItemVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzStyledNodeVec { fn drop(&mut self) { crate::AzStyledNodeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzTagIdToNodeIdMappingVec { fn drop(&mut self) { crate::AzTagIdToNodeIdMappingVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzParentWithNodeDepthVec { fn drop(&mut self) { crate::AzParentWithNodeDepthVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzNodeDataVec { fn drop(&mut self) { crate::AzNodeDataVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzAttributeVec { fn drop(&mut self) { crate::AzAttributeVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzCoreCallbackDataVec { fn drop(&mut self) { crate::AzCoreCallbackDataVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzAccessibilityActionVec { fn drop(&mut self) { crate::AzAccessibilityActionVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzXmlNodeChildVec { fn drop(&mut self) { crate::AzXmlNodeChildVec_delete(unsafe { mem::transmute(self) }); } }
impl Drop for AzGridTrackSizingVec { fn drop(&mut self) { crate::AzGridTrackSizingVec_delete(unsafe { mem::transmute(self) }); } }

#[pymethods]
impl AzStyleCursorEnumWrapper {
    #[classattr]
    const Alias: AzStyleCursor = AzStyleCursor::Alias;
    #[classattr]
    const AllScroll: AzStyleCursor = AzStyleCursor::AllScroll;
    #[classattr]
    const Cell: AzStyleCursor = AzStyleCursor::Cell;
    #[classattr]
    const ColResize: AzStyleCursor = AzStyleCursor::ColResize;
    #[classattr]
    const ContextMenu: AzStyleCursor = AzStyleCursor::ContextMenu;
    #[classattr]
    const Copy: AzStyleCursor = AzStyleCursor::Copy;
    #[classattr]
    const Crosshair: AzStyleCursor = AzStyleCursor::Crosshair;
    #[classattr]
    const Default: AzStyleCursor = AzStyleCursor::Default;
    #[classattr]
    const EResize: AzStyleCursor = AzStyleCursor::EResize;
    #[classattr]
    const EwResize: AzStyleCursor = AzStyleCursor::EwResize;
    #[classattr]
    const Grab: AzStyleCursor = AzStyleCursor::Grab;
    #[classattr]
    const Grabbing: AzStyleCursor = AzStyleCursor::Grabbing;
    #[classattr]
    const Help: AzStyleCursor = AzStyleCursor::Help;
    #[classattr]
    const Move: AzStyleCursor = AzStyleCursor::Move;
    #[classattr]
    const NResize: AzStyleCursor = AzStyleCursor::NResize;
    #[classattr]
    const NsResize: AzStyleCursor = AzStyleCursor::NsResize;
    #[classattr]
    const NeswResize: AzStyleCursor = AzStyleCursor::NeswResize;
    #[classattr]
    const NwseResize: AzStyleCursor = AzStyleCursor::NwseResize;
    #[classattr]
    const Pointer: AzStyleCursor = AzStyleCursor::Pointer;
    #[classattr]
    const Progress: AzStyleCursor = AzStyleCursor::Progress;
    #[classattr]
    const RowResize: AzStyleCursor = AzStyleCursor::RowResize;
    #[classattr]
    const SResize: AzStyleCursor = AzStyleCursor::SResize;
    #[classattr]
    const SeResize: AzStyleCursor = AzStyleCursor::SeResize;
    #[classattr]
    const Text: AzStyleCursor = AzStyleCursor::Text;
    #[classattr]
    const Unset: AzStyleCursor = AzStyleCursor::Unset;
    #[classattr]
    const VerticalText: AzStyleCursor = AzStyleCursor::VerticalText;
    #[classattr]
    const WResize: AzStyleCursor = AzStyleCursor::WResize;
    #[classattr]
    const Wait: AzStyleCursor = AzStyleCursor::Wait;
    #[classattr]
    const ZoomIn: AzStyleCursor = AzStyleCursor::ZoomIn;
    #[classattr]
    const ZoomOut: AzStyleCursor = AzStyleCursor::ZoomOut;
}

#[pyproto]
impl PyObjectProtocol for AzStyleCursorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::effects::StyleCursor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::effects::StyleCursor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleCursorEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzWindowEventFilterEnumWrapper {
    #[classattr]
    const MouseOver: AzWindowEventFilter = AzWindowEventFilter::MouseOver;
    #[classattr]
    const MouseDown: AzWindowEventFilter = AzWindowEventFilter::MouseDown;
    #[classattr]
    const LeftMouseDown: AzWindowEventFilter = AzWindowEventFilter::LeftMouseDown;
    #[classattr]
    const RightMouseDown: AzWindowEventFilter = AzWindowEventFilter::RightMouseDown;
    #[classattr]
    const MiddleMouseDown: AzWindowEventFilter = AzWindowEventFilter::MiddleMouseDown;
    #[classattr]
    const MouseUp: AzWindowEventFilter = AzWindowEventFilter::MouseUp;
    #[classattr]
    const LeftMouseUp: AzWindowEventFilter = AzWindowEventFilter::LeftMouseUp;
    #[classattr]
    const RightMouseUp: AzWindowEventFilter = AzWindowEventFilter::RightMouseUp;
    #[classattr]
    const MiddleMouseUp: AzWindowEventFilter = AzWindowEventFilter::MiddleMouseUp;
    #[classattr]
    const MouseEnter: AzWindowEventFilter = AzWindowEventFilter::MouseEnter;
    #[classattr]
    const MouseLeave: AzWindowEventFilter = AzWindowEventFilter::MouseLeave;
    #[classattr]
    const Scroll: AzWindowEventFilter = AzWindowEventFilter::Scroll;
    #[classattr]
    const ScrollStart: AzWindowEventFilter = AzWindowEventFilter::ScrollStart;
    #[classattr]
    const ScrollEnd: AzWindowEventFilter = AzWindowEventFilter::ScrollEnd;
    #[classattr]
    const TextInput: AzWindowEventFilter = AzWindowEventFilter::TextInput;
    #[classattr]
    const VirtualKeyDown: AzWindowEventFilter = AzWindowEventFilter::VirtualKeyDown;
    #[classattr]
    const VirtualKeyUp: AzWindowEventFilter = AzWindowEventFilter::VirtualKeyUp;
    #[classattr]
    const HoveredFile: AzWindowEventFilter = AzWindowEventFilter::HoveredFile;
    #[classattr]
    const DroppedFile: AzWindowEventFilter = AzWindowEventFilter::DroppedFile;
    #[classattr]
    const HoveredFileCancelled: AzWindowEventFilter = AzWindowEventFilter::HoveredFileCancelled;
    #[classattr]
    const Resized: AzWindowEventFilter = AzWindowEventFilter::Resized;
    #[classattr]
    const Moved: AzWindowEventFilter = AzWindowEventFilter::Moved;
    #[classattr]
    const TouchStart: AzWindowEventFilter = AzWindowEventFilter::TouchStart;
    #[classattr]
    const TouchMove: AzWindowEventFilter = AzWindowEventFilter::TouchMove;
    #[classattr]
    const TouchEnd: AzWindowEventFilter = AzWindowEventFilter::TouchEnd;
    #[classattr]
    const TouchCancel: AzWindowEventFilter = AzWindowEventFilter::TouchCancel;
    #[classattr]
    const FocusReceived: AzWindowEventFilter = AzWindowEventFilter::FocusReceived;
    #[classattr]
    const FocusLost: AzWindowEventFilter = AzWindowEventFilter::FocusLost;
    #[classattr]
    const CloseRequested: AzWindowEventFilter = AzWindowEventFilter::CloseRequested;
    #[classattr]
    const ThemeChanged: AzWindowEventFilter = AzWindowEventFilter::ThemeChanged;
    #[classattr]
    const WindowFocusReceived: AzWindowEventFilter = AzWindowEventFilter::WindowFocusReceived;
    #[classattr]
    const WindowFocusLost: AzWindowEventFilter = AzWindowEventFilter::WindowFocusLost;
    #[classattr]
    const PenDown: AzWindowEventFilter = AzWindowEventFilter::PenDown;
    #[classattr]
    const PenMove: AzWindowEventFilter = AzWindowEventFilter::PenMove;
    #[classattr]
    const PenUp: AzWindowEventFilter = AzWindowEventFilter::PenUp;
    #[classattr]
    const PenEnter: AzWindowEventFilter = AzWindowEventFilter::PenEnter;
    #[classattr]
    const PenLeave: AzWindowEventFilter = AzWindowEventFilter::PenLeave;
    #[classattr]
    const DragStart: AzWindowEventFilter = AzWindowEventFilter::DragStart;
    #[classattr]
    const Drag: AzWindowEventFilter = AzWindowEventFilter::Drag;
    #[classattr]
    const DragEnd: AzWindowEventFilter = AzWindowEventFilter::DragEnd;
    #[classattr]
    const DoubleClick: AzWindowEventFilter = AzWindowEventFilter::DoubleClick;
    #[classattr]
    const LongPress: AzWindowEventFilter = AzWindowEventFilter::LongPress;
    #[classattr]
    const SwipeLeft: AzWindowEventFilter = AzWindowEventFilter::SwipeLeft;
    #[classattr]
    const SwipeRight: AzWindowEventFilter = AzWindowEventFilter::SwipeRight;
    #[classattr]
    const SwipeUp: AzWindowEventFilter = AzWindowEventFilter::SwipeUp;
    #[classattr]
    const SwipeDown: AzWindowEventFilter = AzWindowEventFilter::SwipeDown;
    #[classattr]
    const PinchIn: AzWindowEventFilter = AzWindowEventFilter::PinchIn;
    #[classattr]
    const PinchOut: AzWindowEventFilter = AzWindowEventFilter::PinchOut;
    #[classattr]
    const RotateClockwise: AzWindowEventFilter = AzWindowEventFilter::RotateClockwise;
    #[classattr]
    const RotateCounterClockwise: AzWindowEventFilter = AzWindowEventFilter::RotateCounterClockwise;
}

#[pyproto]
impl PyObjectProtocol for AzWindowEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::events::WindowEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::events::WindowEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzWindowEventFilterEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzHidpiAdjustedBounds {
}

#[pyproto]
impl PyObjectProtocol for AzHidpiAdjustedBounds {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::HidpiAdjustedBounds = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::HidpiAdjustedBounds = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowThemeEnumWrapper {
    #[classattr]
    const DarkMode: AzWindowTheme = AzWindowTheme::DarkMode;
    #[classattr]
    const LightMode: AzWindowTheme = AzWindowTheme::LightMode;
}

#[pyproto]
impl PyObjectProtocol for AzWindowThemeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzWindowThemeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzDpiScaleFactor {
}

#[pyproto]
impl PyObjectProtocol for AzDpiScaleFactor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::DpiScaleFactor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::DpiScaleFactor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMouseCursorTypeEnumWrapper {
    #[classattr]
    const Default: AzMouseCursorType = AzMouseCursorType::Default;
    #[classattr]
    const Crosshair: AzMouseCursorType = AzMouseCursorType::Crosshair;
    #[classattr]
    const Hand: AzMouseCursorType = AzMouseCursorType::Hand;
    #[classattr]
    const Arrow: AzMouseCursorType = AzMouseCursorType::Arrow;
    #[classattr]
    const Move: AzMouseCursorType = AzMouseCursorType::Move;
    #[classattr]
    const Text: AzMouseCursorType = AzMouseCursorType::Text;
    #[classattr]
    const Wait: AzMouseCursorType = AzMouseCursorType::Wait;
    #[classattr]
    const Help: AzMouseCursorType = AzMouseCursorType::Help;
    #[classattr]
    const Progress: AzMouseCursorType = AzMouseCursorType::Progress;
    #[classattr]
    const NotAllowed: AzMouseCursorType = AzMouseCursorType::NotAllowed;
    #[classattr]
    const ContextMenu: AzMouseCursorType = AzMouseCursorType::ContextMenu;
    #[classattr]
    const Cell: AzMouseCursorType = AzMouseCursorType::Cell;
    #[classattr]
    const VerticalText: AzMouseCursorType = AzMouseCursorType::VerticalText;
    #[classattr]
    const Alias: AzMouseCursorType = AzMouseCursorType::Alias;
    #[classattr]
    const Copy: AzMouseCursorType = AzMouseCursorType::Copy;
    #[classattr]
    const NoDrop: AzMouseCursorType = AzMouseCursorType::NoDrop;
    #[classattr]
    const Grab: AzMouseCursorType = AzMouseCursorType::Grab;
    #[classattr]
    const Grabbing: AzMouseCursorType = AzMouseCursorType::Grabbing;
    #[classattr]
    const AllScroll: AzMouseCursorType = AzMouseCursorType::AllScroll;
    #[classattr]
    const ZoomIn: AzMouseCursorType = AzMouseCursorType::ZoomIn;
    #[classattr]
    const ZoomOut: AzMouseCursorType = AzMouseCursorType::ZoomOut;
    #[classattr]
    const EResize: AzMouseCursorType = AzMouseCursorType::EResize;
    #[classattr]
    const NResize: AzMouseCursorType = AzMouseCursorType::NResize;
    #[classattr]
    const NeResize: AzMouseCursorType = AzMouseCursorType::NeResize;
    #[classattr]
    const NwResize: AzMouseCursorType = AzMouseCursorType::NwResize;
    #[classattr]
    const SResize: AzMouseCursorType = AzMouseCursorType::SResize;
    #[classattr]
    const SeResize: AzMouseCursorType = AzMouseCursorType::SeResize;
    #[classattr]
    const SwResize: AzMouseCursorType = AzMouseCursorType::SwResize;
    #[classattr]
    const WResize: AzMouseCursorType = AzMouseCursorType::WResize;
    #[classattr]
    const EwResize: AzMouseCursorType = AzMouseCursorType::EwResize;
    #[classattr]
    const NsResize: AzMouseCursorType = AzMouseCursorType::NsResize;
    #[classattr]
    const NeswResize: AzMouseCursorType = AzMouseCursorType::NeswResize;
    #[classattr]
    const NwseResize: AzMouseCursorType = AzMouseCursorType::NwseResize;
    #[classattr]
    const ColResize: AzMouseCursorType = AzMouseCursorType::ColResize;
    #[classattr]
    const RowResize: AzMouseCursorType = AzMouseCursorType::RowResize;
}

#[pyproto]
impl PyObjectProtocol for AzMouseCursorTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MouseCursorType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MouseCursorType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzMouseCursorTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzWindowFrameEnumWrapper {
    #[classattr]
    const Normal: AzWindowFrame = AzWindowFrame::Normal;
    #[classattr]
    const Minimized: AzWindowFrame = AzWindowFrame::Minimized;
    #[classattr]
    const Maximized: AzWindowFrame = AzWindowFrame::Maximized;
    #[classattr]
    const Fullscreen: AzWindowFrame = AzWindowFrame::Fullscreen;
}

#[pyproto]
impl PyObjectProtocol for AzWindowFrameEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowFrame = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowFrame = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzWindowFrameEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLinuxWindowOptions {
}

#[pyproto]
impl PyObjectProtocol for AzLinuxWindowOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LinuxWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LinuxWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWaylandTheme {
}

#[pyproto]
impl PyObjectProtocol for AzWaylandTheme {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WaylandTheme = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WaylandTheme = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUserAttentionTypeEnumWrapper {
    #[classattr]
    const None: AzUserAttentionType = AzUserAttentionType::None;
    #[classattr]
    const Critical: AzUserAttentionType = AzUserAttentionType::Critical;
    #[classattr]
    const Informational: AzUserAttentionType = AzUserAttentionType::Informational;
}

#[pyproto]
impl PyObjectProtocol for AzUserAttentionTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::UserAttentionType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::UserAttentionType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzUserAttentionTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzMonitorId {
}

#[pyproto]
impl PyObjectProtocol for AzMonitorId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MonitorId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MonitorId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowFlags {
}

#[pyproto]
impl PyObjectProtocol for AzWindowFlags {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowFlags = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowFlags = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTaskBarIcon {
}

#[pyproto]
impl PyObjectProtocol for AzTaskBarIcon {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::TaskBarIcon = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::TaskBarIcon = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWasmWindowOptions {
}

#[pyproto]
impl PyObjectProtocol for AzWasmWindowOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WasmWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WasmWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSmallWindowIconBytes {
}

#[pyproto]
impl PyObjectProtocol for AzSmallWindowIconBytes {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::SmallWindowIconBytes = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::SmallWindowIconBytes = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMonitor {
}

#[pyproto]
impl PyObjectProtocol for AzMonitor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Monitor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Monitor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIconKey {
}

#[pyproto]
impl PyObjectProtocol for AzIconKey {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::IconKey = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::IconKey = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzHwAccelerationEnumWrapper {
    #[classattr]
    const Enabled: AzHwAcceleration = AzHwAcceleration::Enabled;
    #[classattr]
    const Disabled: AzHwAcceleration = AzHwAcceleration::Disabled;
    #[classattr]
    const DontCare: AzHwAcceleration = AzHwAcceleration::DontCare;
}

#[pyproto]
impl PyObjectProtocol for AzHwAccelerationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::HwAcceleration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::HwAcceleration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzHwAccelerationEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzMacWindowOptions {
}

#[pyproto]
impl PyObjectProtocol for AzMacWindowOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MacWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MacWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVsyncEnumWrapper {
    #[classattr]
    const Enabled: AzVsync = AzVsync::Enabled;
    #[classattr]
    const Disabled: AzVsync = AzVsync::Disabled;
    #[classattr]
    const DontCare: AzVsync = AzVsync::DontCare;
}

#[pyproto]
impl PyObjectProtocol for AzVsyncEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Vsync = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Vsync = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzVsyncEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzVideoMode {
}

#[pyproto]
impl PyObjectProtocol for AzVideoMode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoMode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoMode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLargeWindowIconBytes {
}

#[pyproto]
impl PyObjectProtocol for AzLargeWindowIconBytes {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LargeWindowIconBytes = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LargeWindowIconBytes = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXWindowTypeEnumWrapper {
    #[classattr]
    const Desktop: AzXWindowType = AzXWindowType::Desktop;
    #[classattr]
    const Dock: AzXWindowType = AzXWindowType::Dock;
    #[classattr]
    const Toolbar: AzXWindowType = AzXWindowType::Toolbar;
    #[classattr]
    const Menu: AzXWindowType = AzXWindowType::Menu;
    #[classattr]
    const Utility: AzXWindowType = AzXWindowType::Utility;
    #[classattr]
    const Splash: AzXWindowType = AzXWindowType::Splash;
    #[classattr]
    const Dialog: AzXWindowType = AzXWindowType::Dialog;
    #[classattr]
    const DropdownMenu: AzXWindowType = AzXWindowType::DropdownMenu;
    #[classattr]
    const PopupMenu: AzXWindowType = AzXWindowType::PopupMenu;
    #[classattr]
    const Tooltip: AzXWindowType = AzXWindowType::Tooltip;
    #[classattr]
    const Notification: AzXWindowType = AzXWindowType::Notification;
    #[classattr]
    const Combo: AzXWindowType = AzXWindowType::Combo;
    #[classattr]
    const Dnd: AzXWindowType = AzXWindowType::Dnd;
    #[classattr]
    const Normal: AzXWindowType = AzXWindowType::Normal;
}

#[pyproto]
impl PyObjectProtocol for AzXWindowTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzXWindowTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzPlatformSpecificOptions {
}

#[pyproto]
impl PyObjectProtocol for AzPlatformSpecificOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::PlatformSpecificOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::PlatformSpecificOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowIconEnumWrapper {
    #[staticmethod]
    fn Small(v: SmallWindowIconBytes) -> AzWindowIconEnumWrapper {
        AzWindowIconEnumWrapper { inner: AzWindowIcon::Small(v) }}
    }
    #[staticmethod]
    fn Large(v: LargeWindowIconBytes) -> AzWindowIconEnumWrapper {
        AzWindowIconEnumWrapper { inner: AzWindowIcon::Large(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzWindowIcon;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzWindowIcon::Small(v) => Ok(vec!["Small".into_py(py), v.into_py(py)]),
            AzWindowIcon::Large(v) => Ok(vec!["Large".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzWindowIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowSize {
}

#[pyproto]
impl PyObjectProtocol for AzWindowSize {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowsWindowOptions {
}

#[pyproto]
impl PyObjectProtocol for AzWindowsWindowOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowsWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowsWindowOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowTypeEnumWrapper {
    #[classattr]
    const Normal: AzWindowType = AzWindowType::Normal;
    #[classattr]
    const Menu: AzWindowType = AzWindowType::Menu;
    #[classattr]
    const Tooltip: AzWindowType = AzWindowType::Tooltip;
    #[classattr]
    const Dialog: AzWindowType = AzWindowType::Dialog;
}

#[pyproto]
impl PyObjectProtocol for AzWindowTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzWindowTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzWindowCreateOptions {
    #[new]
    fn new(/* args */) -> AzWindowCreateOptions {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzWindowCreateOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::window_state::WindowCreateOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::window_state::WindowCreateOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFullWindowState {
}

#[pyproto]
impl PyObjectProtocol for AzFullWindowState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::window_state::FullWindowState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::window_state::FullWindowState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameCallback {
}

#[pyproto]
impl PyObjectProtocol for AzIFrameCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::IFrameCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::IFrameCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameCallbackReturn {
}

#[pyproto]
impl PyObjectProtocol for AzIFrameCallbackReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::IFrameCallbackReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::IFrameCallbackReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameCallbackInfo {
}

#[pyproto]
impl PyObjectProtocol for AzIFrameCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::IFrameCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::IFrameCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallbackInfo {
}

#[pyproto]
impl PyObjectProtocol for AzCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::CallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::CallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRenderImageCallbackInfo {
}

#[pyproto]
impl PyObjectProtocol for AzRenderImageCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::RenderImageCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::RenderImageCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameCallbackReasonEnumWrapper {
    #[classattr]
    fn InitialRender() -> AzIFrameCallbackReasonEnumWrapper {
        AzIFrameCallbackReasonEnumWrapper { inner: AzIFrameCallbackReason::InitialRender }
    }
    #[classattr]
    fn DomRecreated() -> AzIFrameCallbackReasonEnumWrapper {
        AzIFrameCallbackReasonEnumWrapper { inner: AzIFrameCallbackReason::DomRecreated }
    }
    #[classattr]
    fn BoundsExpanded() -> AzIFrameCallbackReasonEnumWrapper {
        AzIFrameCallbackReasonEnumWrapper { inner: AzIFrameCallbackReason::BoundsExpanded }
    }
    #[staticmethod]
    fn EdgeScrolled(v: EdgeType) -> AzIFrameCallbackReasonEnumWrapper {
        AzIFrameCallbackReasonEnumWrapper { inner: AzIFrameCallbackReason::EdgeScrolled(v) }}
    }
    #[classattr]
    fn ScrollBeyondContent() -> AzIFrameCallbackReasonEnumWrapper {
        AzIFrameCallbackReasonEnumWrapper { inner: AzIFrameCallbackReason::ScrollBeyondContent }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzIFrameCallbackReason;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzIFrameCallbackReason::InitialRender => Ok(vec!["InitialRender".into_py(py), ().into_py(py)]),
            AzIFrameCallbackReason::DomRecreated => Ok(vec!["DomRecreated".into_py(py), ().into_py(py)]),
            AzIFrameCallbackReason::BoundsExpanded => Ok(vec!["BoundsExpanded".into_py(py), ().into_py(py)]),
            AzIFrameCallbackReason::EdgeScrolled(v) => Ok(vec!["EdgeScrolled".into_py(py), v.into_py(py)]),
            AzIFrameCallbackReason::ScrollBeyondContent => Ok(vec!["ScrollBeyondContent".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIFrameCallbackReasonEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::IFrameCallbackReason = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::IFrameCallbackReason = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMarshaledLayoutCallbackInner {
}

#[pyproto]
impl PyObjectProtocol for AzMarshaledLayoutCallbackInner {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::MarshaledLayoutCallbackInner = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::MarshaledLayoutCallbackInner = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutCallbackInner {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutCallbackInner {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::LayoutCallbackInner = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::LayoutCallbackInner = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutCallbackEnumWrapper {
    #[staticmethod]
    fn Raw(v: LayoutCallbackInner) -> AzLayoutCallbackEnumWrapper {
        AzLayoutCallbackEnumWrapper { inner: AzLayoutCallback::Raw(v) }}
    }
    #[staticmethod]
    fn Marshaled(v: MarshaledLayoutCallback) -> AzLayoutCallbackEnumWrapper {
        AzLayoutCallbackEnumWrapper { inner: AzLayoutCallback::Marshaled(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutCallback;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutCallback::Raw(v) => Ok(vec!["Raw".into_py(py), v.into_py(py)]),
            AzLayoutCallback::Marshaled(v) => Ok(vec!["Marshaled".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutCallbackEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::LayoutCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::LayoutCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutCallbackInfo {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::LayoutCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::LayoutCallbackInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMarshaledLayoutCallback {
}

#[pyproto]
impl PyObjectProtocol for AzMarshaledLayoutCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDom {
    #[new]
    fn new(/* args */) -> AzDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn body(/* args */) -> AzDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn div(/* args */) -> AzDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn br(/* args */) -> AzDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn text(/* args */) -> AzDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn image(/* args */) -> AzDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_node_type(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_node_type(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_ids_and_classes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_ids_and_classes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_callbacks(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_callbacks(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_css_props(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_css_props(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn add_child(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_child(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_children(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_children(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn add_id(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_id(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn add_class(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_class(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn add_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn add_hover_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_hover_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn add_active_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_active_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn add_focus_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_focus_css_property(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_hover_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_hover_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_active_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_active_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_focus_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_focus_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_clip_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_clip_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_tab_index(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_tab_index(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_accessibility_info(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_accessibility_info(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_menu_bar(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_menu_bar(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_context_menu(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_context_menu(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn hash(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn node_count(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_html_string(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_html_string_test(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzDom {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::Dom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::Dom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeData {
    #[new]
    fn new(/* args */) -> AzNodeData {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn body(/* args */) -> AzNodeData {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn div(/* args */) -> AzNodeData {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn br(/* args */) -> AzNodeData {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn text(/* args */) -> AzNodeData {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn image(/* args */) -> AzNodeData {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_node_type(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_node_type(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_ids_and_classes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_ids_and_classes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_callbacks(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_callbacks(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_css_props(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_css_props(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_hover_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_hover_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_active_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_active_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_inline_focus_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_inline_focus_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_clip_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_tab_index(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_accessibility_info(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_menu_bar(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_context_menu(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn hash(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzNodeData {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeData = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeData = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeEnumWrapper {
    #[classattr]
    fn Html() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Html }
    }
    #[classattr]
    fn Head() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Head }
    }
    #[classattr]
    fn Body() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Body }
    }
    #[classattr]
    fn Div() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Div }
    }
    #[classattr]
    fn P() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::P }
    }
    #[classattr]
    fn Article() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Article }
    }
    #[classattr]
    fn Section() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Section }
    }
    #[classattr]
    fn Nav() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Nav }
    }
    #[classattr]
    fn Aside() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Aside }
    }
    #[classattr]
    fn Header() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Header }
    }
    #[classattr]
    fn Footer() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Footer }
    }
    #[classattr]
    fn Main() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Main }
    }
    #[classattr]
    fn Figure() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Figure }
    }
    #[classattr]
    fn FigCaption() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::FigCaption }
    }
    #[classattr]
    fn H1() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::H1 }
    }
    #[classattr]
    fn H2() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::H2 }
    }
    #[classattr]
    fn H3() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::H3 }
    }
    #[classattr]
    fn H4() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::H4 }
    }
    #[classattr]
    fn H5() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::H5 }
    }
    #[classattr]
    fn H6() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::H6 }
    }
    #[classattr]
    fn Br() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Br }
    }
    #[classattr]
    fn Hr() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Hr }
    }
    #[classattr]
    fn Pre() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Pre }
    }
    #[classattr]
    fn BlockQuote() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::BlockQuote }
    }
    #[classattr]
    fn Address() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Address }
    }
    #[classattr]
    fn Details() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Details }
    }
    #[classattr]
    fn Summary() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Summary }
    }
    #[classattr]
    fn Dialog() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Dialog }
    }
    #[classattr]
    fn Ul() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Ul }
    }
    #[classattr]
    fn Ol() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Ol }
    }
    #[classattr]
    fn Li() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Li }
    }
    #[classattr]
    fn Dl() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Dl }
    }
    #[classattr]
    fn Dt() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Dt }
    }
    #[classattr]
    fn Dd() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Dd }
    }
    #[classattr]
    fn Menu() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Menu }
    }
    #[classattr]
    fn MenuItem() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::MenuItem }
    }
    #[classattr]
    fn Dir() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Dir }
    }
    #[classattr]
    fn Table() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Table }
    }
    #[classattr]
    fn Caption() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Caption }
    }
    #[classattr]
    fn THead() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::THead }
    }
    #[classattr]
    fn TBody() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::TBody }
    }
    #[classattr]
    fn TFoot() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::TFoot }
    }
    #[classattr]
    fn Tr() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Tr }
    }
    #[classattr]
    fn Th() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Th }
    }
    #[classattr]
    fn Td() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Td }
    }
    #[classattr]
    fn ColGroup() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::ColGroup }
    }
    #[classattr]
    fn Col() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Col }
    }
    #[classattr]
    fn Form() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Form }
    }
    #[classattr]
    fn FieldSet() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::FieldSet }
    }
    #[classattr]
    fn Legend() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Legend }
    }
    #[classattr]
    fn Label() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Label }
    }
    #[classattr]
    fn Input() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Input }
    }
    #[classattr]
    fn Button() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Button }
    }
    #[classattr]
    fn Select() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Select }
    }
    #[classattr]
    fn OptGroup() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::OptGroup }
    }
    #[classattr]
    fn SelectOption() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::SelectOption }
    }
    #[classattr]
    fn TextArea() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::TextArea }
    }
    #[classattr]
    fn Output() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Output }
    }
    #[classattr]
    fn Progress() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Progress }
    }
    #[classattr]
    fn Meter() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Meter }
    }
    #[classattr]
    fn DataList() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::DataList }
    }
    #[classattr]
    fn Span() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Span }
    }
    #[classattr]
    fn A() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::A }
    }
    #[classattr]
    fn Em() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Em }
    }
    #[classattr]
    fn Strong() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Strong }
    }
    #[classattr]
    fn B() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::B }
    }
    #[classattr]
    fn I() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::I }
    }
    #[classattr]
    fn U() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::U }
    }
    #[classattr]
    fn S() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::S }
    }
    #[classattr]
    fn Mark() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Mark }
    }
    #[classattr]
    fn Del() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Del }
    }
    #[classattr]
    fn Ins() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Ins }
    }
    #[classattr]
    fn Code() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Code }
    }
    #[classattr]
    fn Samp() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Samp }
    }
    #[classattr]
    fn Kbd() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Kbd }
    }
    #[classattr]
    fn Var() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Var }
    }
    #[classattr]
    fn Cite() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Cite }
    }
    #[classattr]
    fn Dfn() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Dfn }
    }
    #[classattr]
    fn Abbr() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Abbr }
    }
    #[classattr]
    fn Acronym() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Acronym }
    }
    #[classattr]
    fn Q() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Q }
    }
    #[classattr]
    fn Time() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Time }
    }
    #[classattr]
    fn Sub() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Sub }
    }
    #[classattr]
    fn Sup() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Sup }
    }
    #[classattr]
    fn Small() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Small }
    }
    #[classattr]
    fn Big() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Big }
    }
    #[classattr]
    fn Bdo() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Bdo }
    }
    #[classattr]
    fn Bdi() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Bdi }
    }
    #[classattr]
    fn Wbr() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Wbr }
    }
    #[classattr]
    fn Ruby() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Ruby }
    }
    #[classattr]
    fn Rt() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Rt }
    }
    #[classattr]
    fn Rtc() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Rtc }
    }
    #[classattr]
    fn Rp() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Rp }
    }
    #[classattr]
    fn Data() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Data }
    }
    #[classattr]
    fn Canvas() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Canvas }
    }
    #[classattr]
    fn Object() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Object }
    }
    #[classattr]
    fn Param() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Param }
    }
    #[classattr]
    fn Embed() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Embed }
    }
    #[classattr]
    fn Audio() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Audio }
    }
    #[classattr]
    fn Video() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Video }
    }
    #[classattr]
    fn Source() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Source }
    }
    #[classattr]
    fn Track() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Track }
    }
    #[classattr]
    fn Map() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Map }
    }
    #[classattr]
    fn Area() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Area }
    }
    #[classattr]
    fn Svg() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Svg }
    }
    #[classattr]
    fn Title() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Title }
    }
    #[classattr]
    fn Meta() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Meta }
    }
    #[classattr]
    fn Link() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Link }
    }
    #[classattr]
    fn Script() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Script }
    }
    #[classattr]
    fn Style() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Style }
    }
    #[classattr]
    fn Base() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Base }
    }
    #[classattr]
    fn Before() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Before }
    }
    #[classattr]
    fn After() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::After }
    }
    #[classattr]
    fn Marker() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Marker }
    }
    #[classattr]
    fn Placeholder() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Placeholder }
    }
    #[staticmethod]
    fn Text(v: String) -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Text(v) }}
    }
    #[staticmethod]
    fn Image(v: ImageRef) -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::Image(v) }}
    }
    #[staticmethod]
    fn IFrame(v: IFrameNode) -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper { inner: AzNodeType::IFrame(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeType;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeType::Html => Ok(vec!["Html".into_py(py), ().into_py(py)]),
            AzNodeType::Head => Ok(vec!["Head".into_py(py), ().into_py(py)]),
            AzNodeType::Body => Ok(vec!["Body".into_py(py), ().into_py(py)]),
            AzNodeType::Div => Ok(vec!["Div".into_py(py), ().into_py(py)]),
            AzNodeType::P => Ok(vec!["P".into_py(py), ().into_py(py)]),
            AzNodeType::Article => Ok(vec!["Article".into_py(py), ().into_py(py)]),
            AzNodeType::Section => Ok(vec!["Section".into_py(py), ().into_py(py)]),
            AzNodeType::Nav => Ok(vec!["Nav".into_py(py), ().into_py(py)]),
            AzNodeType::Aside => Ok(vec!["Aside".into_py(py), ().into_py(py)]),
            AzNodeType::Header => Ok(vec!["Header".into_py(py), ().into_py(py)]),
            AzNodeType::Footer => Ok(vec!["Footer".into_py(py), ().into_py(py)]),
            AzNodeType::Main => Ok(vec!["Main".into_py(py), ().into_py(py)]),
            AzNodeType::Figure => Ok(vec!["Figure".into_py(py), ().into_py(py)]),
            AzNodeType::FigCaption => Ok(vec!["FigCaption".into_py(py), ().into_py(py)]),
            AzNodeType::H1 => Ok(vec!["H1".into_py(py), ().into_py(py)]),
            AzNodeType::H2 => Ok(vec!["H2".into_py(py), ().into_py(py)]),
            AzNodeType::H3 => Ok(vec!["H3".into_py(py), ().into_py(py)]),
            AzNodeType::H4 => Ok(vec!["H4".into_py(py), ().into_py(py)]),
            AzNodeType::H5 => Ok(vec!["H5".into_py(py), ().into_py(py)]),
            AzNodeType::H6 => Ok(vec!["H6".into_py(py), ().into_py(py)]),
            AzNodeType::Br => Ok(vec!["Br".into_py(py), ().into_py(py)]),
            AzNodeType::Hr => Ok(vec!["Hr".into_py(py), ().into_py(py)]),
            AzNodeType::Pre => Ok(vec!["Pre".into_py(py), ().into_py(py)]),
            AzNodeType::BlockQuote => Ok(vec!["BlockQuote".into_py(py), ().into_py(py)]),
            AzNodeType::Address => Ok(vec!["Address".into_py(py), ().into_py(py)]),
            AzNodeType::Details => Ok(vec!["Details".into_py(py), ().into_py(py)]),
            AzNodeType::Summary => Ok(vec!["Summary".into_py(py), ().into_py(py)]),
            AzNodeType::Dialog => Ok(vec!["Dialog".into_py(py), ().into_py(py)]),
            AzNodeType::Ul => Ok(vec!["Ul".into_py(py), ().into_py(py)]),
            AzNodeType::Ol => Ok(vec!["Ol".into_py(py), ().into_py(py)]),
            AzNodeType::Li => Ok(vec!["Li".into_py(py), ().into_py(py)]),
            AzNodeType::Dl => Ok(vec!["Dl".into_py(py), ().into_py(py)]),
            AzNodeType::Dt => Ok(vec!["Dt".into_py(py), ().into_py(py)]),
            AzNodeType::Dd => Ok(vec!["Dd".into_py(py), ().into_py(py)]),
            AzNodeType::Menu => Ok(vec!["Menu".into_py(py), ().into_py(py)]),
            AzNodeType::MenuItem => Ok(vec!["MenuItem".into_py(py), ().into_py(py)]),
            AzNodeType::Dir => Ok(vec!["Dir".into_py(py), ().into_py(py)]),
            AzNodeType::Table => Ok(vec!["Table".into_py(py), ().into_py(py)]),
            AzNodeType::Caption => Ok(vec!["Caption".into_py(py), ().into_py(py)]),
            AzNodeType::THead => Ok(vec!["THead".into_py(py), ().into_py(py)]),
            AzNodeType::TBody => Ok(vec!["TBody".into_py(py), ().into_py(py)]),
            AzNodeType::TFoot => Ok(vec!["TFoot".into_py(py), ().into_py(py)]),
            AzNodeType::Tr => Ok(vec!["Tr".into_py(py), ().into_py(py)]),
            AzNodeType::Th => Ok(vec!["Th".into_py(py), ().into_py(py)]),
            AzNodeType::Td => Ok(vec!["Td".into_py(py), ().into_py(py)]),
            AzNodeType::ColGroup => Ok(vec!["ColGroup".into_py(py), ().into_py(py)]),
            AzNodeType::Col => Ok(vec!["Col".into_py(py), ().into_py(py)]),
            AzNodeType::Form => Ok(vec!["Form".into_py(py), ().into_py(py)]),
            AzNodeType::FieldSet => Ok(vec!["FieldSet".into_py(py), ().into_py(py)]),
            AzNodeType::Legend => Ok(vec!["Legend".into_py(py), ().into_py(py)]),
            AzNodeType::Label => Ok(vec!["Label".into_py(py), ().into_py(py)]),
            AzNodeType::Input => Ok(vec!["Input".into_py(py), ().into_py(py)]),
            AzNodeType::Button => Ok(vec!["Button".into_py(py), ().into_py(py)]),
            AzNodeType::Select => Ok(vec!["Select".into_py(py), ().into_py(py)]),
            AzNodeType::OptGroup => Ok(vec!["OptGroup".into_py(py), ().into_py(py)]),
            AzNodeType::SelectOption => Ok(vec!["SelectOption".into_py(py), ().into_py(py)]),
            AzNodeType::TextArea => Ok(vec!["TextArea".into_py(py), ().into_py(py)]),
            AzNodeType::Output => Ok(vec!["Output".into_py(py), ().into_py(py)]),
            AzNodeType::Progress => Ok(vec!["Progress".into_py(py), ().into_py(py)]),
            AzNodeType::Meter => Ok(vec!["Meter".into_py(py), ().into_py(py)]),
            AzNodeType::DataList => Ok(vec!["DataList".into_py(py), ().into_py(py)]),
            AzNodeType::Span => Ok(vec!["Span".into_py(py), ().into_py(py)]),
            AzNodeType::A => Ok(vec!["A".into_py(py), ().into_py(py)]),
            AzNodeType::Em => Ok(vec!["Em".into_py(py), ().into_py(py)]),
            AzNodeType::Strong => Ok(vec!["Strong".into_py(py), ().into_py(py)]),
            AzNodeType::B => Ok(vec!["B".into_py(py), ().into_py(py)]),
            AzNodeType::I => Ok(vec!["I".into_py(py), ().into_py(py)]),
            AzNodeType::U => Ok(vec!["U".into_py(py), ().into_py(py)]),
            AzNodeType::S => Ok(vec!["S".into_py(py), ().into_py(py)]),
            AzNodeType::Mark => Ok(vec!["Mark".into_py(py), ().into_py(py)]),
            AzNodeType::Del => Ok(vec!["Del".into_py(py), ().into_py(py)]),
            AzNodeType::Ins => Ok(vec!["Ins".into_py(py), ().into_py(py)]),
            AzNodeType::Code => Ok(vec!["Code".into_py(py), ().into_py(py)]),
            AzNodeType::Samp => Ok(vec!["Samp".into_py(py), ().into_py(py)]),
            AzNodeType::Kbd => Ok(vec!["Kbd".into_py(py), ().into_py(py)]),
            AzNodeType::Var => Ok(vec!["Var".into_py(py), ().into_py(py)]),
            AzNodeType::Cite => Ok(vec!["Cite".into_py(py), ().into_py(py)]),
            AzNodeType::Dfn => Ok(vec!["Dfn".into_py(py), ().into_py(py)]),
            AzNodeType::Abbr => Ok(vec!["Abbr".into_py(py), ().into_py(py)]),
            AzNodeType::Acronym => Ok(vec!["Acronym".into_py(py), ().into_py(py)]),
            AzNodeType::Q => Ok(vec!["Q".into_py(py), ().into_py(py)]),
            AzNodeType::Time => Ok(vec!["Time".into_py(py), ().into_py(py)]),
            AzNodeType::Sub => Ok(vec!["Sub".into_py(py), ().into_py(py)]),
            AzNodeType::Sup => Ok(vec!["Sup".into_py(py), ().into_py(py)]),
            AzNodeType::Small => Ok(vec!["Small".into_py(py), ().into_py(py)]),
            AzNodeType::Big => Ok(vec!["Big".into_py(py), ().into_py(py)]),
            AzNodeType::Bdo => Ok(vec!["Bdo".into_py(py), ().into_py(py)]),
            AzNodeType::Bdi => Ok(vec!["Bdi".into_py(py), ().into_py(py)]),
            AzNodeType::Wbr => Ok(vec!["Wbr".into_py(py), ().into_py(py)]),
            AzNodeType::Ruby => Ok(vec!["Ruby".into_py(py), ().into_py(py)]),
            AzNodeType::Rt => Ok(vec!["Rt".into_py(py), ().into_py(py)]),
            AzNodeType::Rtc => Ok(vec!["Rtc".into_py(py), ().into_py(py)]),
            AzNodeType::Rp => Ok(vec!["Rp".into_py(py), ().into_py(py)]),
            AzNodeType::Data => Ok(vec!["Data".into_py(py), ().into_py(py)]),
            AzNodeType::Canvas => Ok(vec!["Canvas".into_py(py), ().into_py(py)]),
            AzNodeType::Object => Ok(vec!["Object".into_py(py), ().into_py(py)]),
            AzNodeType::Param => Ok(vec!["Param".into_py(py), ().into_py(py)]),
            AzNodeType::Embed => Ok(vec!["Embed".into_py(py), ().into_py(py)]),
            AzNodeType::Audio => Ok(vec!["Audio".into_py(py), ().into_py(py)]),
            AzNodeType::Video => Ok(vec!["Video".into_py(py), ().into_py(py)]),
            AzNodeType::Source => Ok(vec!["Source".into_py(py), ().into_py(py)]),
            AzNodeType::Track => Ok(vec!["Track".into_py(py), ().into_py(py)]),
            AzNodeType::Map => Ok(vec!["Map".into_py(py), ().into_py(py)]),
            AzNodeType::Area => Ok(vec!["Area".into_py(py), ().into_py(py)]),
            AzNodeType::Svg => Ok(vec!["Svg".into_py(py), ().into_py(py)]),
            AzNodeType::Title => Ok(vec!["Title".into_py(py), ().into_py(py)]),
            AzNodeType::Meta => Ok(vec!["Meta".into_py(py), ().into_py(py)]),
            AzNodeType::Link => Ok(vec!["Link".into_py(py), ().into_py(py)]),
            AzNodeType::Script => Ok(vec!["Script".into_py(py), ().into_py(py)]),
            AzNodeType::Style => Ok(vec!["Style".into_py(py), ().into_py(py)]),
            AzNodeType::Base => Ok(vec!["Base".into_py(py), ().into_py(py)]),
            AzNodeType::Before => Ok(vec!["Before".into_py(py), ().into_py(py)]),
            AzNodeType::After => Ok(vec!["After".into_py(py), ().into_py(py)]),
            AzNodeType::Marker => Ok(vec!["Marker".into_py(py), ().into_py(py)]),
            AzNodeType::Placeholder => Ok(vec!["Placeholder".into_py(py), ().into_py(py)]),
            AzNodeType::Text(v) => Ok(vec!["Text".into_py(py), v.into_py(py)]),
            AzNodeType::Image(v) => Ok(vec!["Image".into_py(py), v.into_py(py)]),
            AzNodeType::IFrame(v) => Ok(vec!["IFrame".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAccessibilityInfo {
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAccessibilityRoleEnumWrapper {
    #[classattr]
    const TitleBar: AzAccessibilityRole = AzAccessibilityRole::TitleBar;
    #[classattr]
    const MenuBar: AzAccessibilityRole = AzAccessibilityRole::MenuBar;
    #[classattr]
    const ScrollBar: AzAccessibilityRole = AzAccessibilityRole::ScrollBar;
    #[classattr]
    const Grip: AzAccessibilityRole = AzAccessibilityRole::Grip;
    #[classattr]
    const Sound: AzAccessibilityRole = AzAccessibilityRole::Sound;
    #[classattr]
    const Cursor: AzAccessibilityRole = AzAccessibilityRole::Cursor;
    #[classattr]
    const Caret: AzAccessibilityRole = AzAccessibilityRole::Caret;
    #[classattr]
    const Alert: AzAccessibilityRole = AzAccessibilityRole::Alert;
    #[classattr]
    const Window: AzAccessibilityRole = AzAccessibilityRole::Window;
    #[classattr]
    const Client: AzAccessibilityRole = AzAccessibilityRole::Client;
    #[classattr]
    const MenuPopup: AzAccessibilityRole = AzAccessibilityRole::MenuPopup;
    #[classattr]
    const MenuItem: AzAccessibilityRole = AzAccessibilityRole::MenuItem;
    #[classattr]
    const Tooltip: AzAccessibilityRole = AzAccessibilityRole::Tooltip;
    #[classattr]
    const Application: AzAccessibilityRole = AzAccessibilityRole::Application;
    #[classattr]
    const Document: AzAccessibilityRole = AzAccessibilityRole::Document;
    #[classattr]
    const Pane: AzAccessibilityRole = AzAccessibilityRole::Pane;
    #[classattr]
    const Chart: AzAccessibilityRole = AzAccessibilityRole::Chart;
    #[classattr]
    const Dialog: AzAccessibilityRole = AzAccessibilityRole::Dialog;
    #[classattr]
    const Border: AzAccessibilityRole = AzAccessibilityRole::Border;
    #[classattr]
    const Grouping: AzAccessibilityRole = AzAccessibilityRole::Grouping;
    #[classattr]
    const Separator: AzAccessibilityRole = AzAccessibilityRole::Separator;
    #[classattr]
    const Toolbar: AzAccessibilityRole = AzAccessibilityRole::Toolbar;
    #[classattr]
    const StatusBar: AzAccessibilityRole = AzAccessibilityRole::StatusBar;
    #[classattr]
    const Table: AzAccessibilityRole = AzAccessibilityRole::Table;
    #[classattr]
    const ColumnHeader: AzAccessibilityRole = AzAccessibilityRole::ColumnHeader;
    #[classattr]
    const RowHeader: AzAccessibilityRole = AzAccessibilityRole::RowHeader;
    #[classattr]
    const Column: AzAccessibilityRole = AzAccessibilityRole::Column;
    #[classattr]
    const Row: AzAccessibilityRole = AzAccessibilityRole::Row;
    #[classattr]
    const Cell: AzAccessibilityRole = AzAccessibilityRole::Cell;
    #[classattr]
    const Link: AzAccessibilityRole = AzAccessibilityRole::Link;
    #[classattr]
    const HelpBalloon: AzAccessibilityRole = AzAccessibilityRole::HelpBalloon;
    #[classattr]
    const Character: AzAccessibilityRole = AzAccessibilityRole::Character;
    #[classattr]
    const List: AzAccessibilityRole = AzAccessibilityRole::List;
    #[classattr]
    const ListItem: AzAccessibilityRole = AzAccessibilityRole::ListItem;
    #[classattr]
    const Outline: AzAccessibilityRole = AzAccessibilityRole::Outline;
    #[classattr]
    const OutlineItem: AzAccessibilityRole = AzAccessibilityRole::OutlineItem;
    #[classattr]
    const PageTab: AzAccessibilityRole = AzAccessibilityRole::PageTab;
    #[classattr]
    const PropertyPage: AzAccessibilityRole = AzAccessibilityRole::PropertyPage;
    #[classattr]
    const Indicator: AzAccessibilityRole = AzAccessibilityRole::Indicator;
    #[classattr]
    const Graphic: AzAccessibilityRole = AzAccessibilityRole::Graphic;
    #[classattr]
    const StaticText: AzAccessibilityRole = AzAccessibilityRole::StaticText;
    #[classattr]
    const Text: AzAccessibilityRole = AzAccessibilityRole::Text;
    #[classattr]
    const PushButton: AzAccessibilityRole = AzAccessibilityRole::PushButton;
    #[classattr]
    const CheckButton: AzAccessibilityRole = AzAccessibilityRole::CheckButton;
    #[classattr]
    const RadioButton: AzAccessibilityRole = AzAccessibilityRole::RadioButton;
    #[classattr]
    const ComboBox: AzAccessibilityRole = AzAccessibilityRole::ComboBox;
    #[classattr]
    const DropList: AzAccessibilityRole = AzAccessibilityRole::DropList;
    #[classattr]
    const ProgressBar: AzAccessibilityRole = AzAccessibilityRole::ProgressBar;
    #[classattr]
    const Dial: AzAccessibilityRole = AzAccessibilityRole::Dial;
    #[classattr]
    const HotkeyField: AzAccessibilityRole = AzAccessibilityRole::HotkeyField;
    #[classattr]
    const Slider: AzAccessibilityRole = AzAccessibilityRole::Slider;
    #[classattr]
    const SpinButton: AzAccessibilityRole = AzAccessibilityRole::SpinButton;
    #[classattr]
    const Diagram: AzAccessibilityRole = AzAccessibilityRole::Diagram;
    #[classattr]
    const Animation: AzAccessibilityRole = AzAccessibilityRole::Animation;
    #[classattr]
    const Equation: AzAccessibilityRole = AzAccessibilityRole::Equation;
    #[classattr]
    const ButtonDropdown: AzAccessibilityRole = AzAccessibilityRole::ButtonDropdown;
    #[classattr]
    const ButtonMenu: AzAccessibilityRole = AzAccessibilityRole::ButtonMenu;
    #[classattr]
    const ButtonDropdownGrid: AzAccessibilityRole = AzAccessibilityRole::ButtonDropdownGrid;
    #[classattr]
    const Whitespace: AzAccessibilityRole = AzAccessibilityRole::Whitespace;
    #[classattr]
    const PageTabList: AzAccessibilityRole = AzAccessibilityRole::PageTabList;
    #[classattr]
    const Clock: AzAccessibilityRole = AzAccessibilityRole::Clock;
    #[classattr]
    const SplitButton: AzAccessibilityRole = AzAccessibilityRole::SplitButton;
    #[classattr]
    const IpAddress: AzAccessibilityRole = AzAccessibilityRole::IpAddress;
    #[classattr]
    const Nothing: AzAccessibilityRole = AzAccessibilityRole::Nothing;
    #[classattr]
    const Unknown: AzAccessibilityRole = AzAccessibilityRole::Unknown;
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityRoleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityRole = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityRole = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAccessibilityRoleEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAccessibilityStateEnumWrapper {
    #[classattr]
    const Unavailable: AzAccessibilityState = AzAccessibilityState::Unavailable;
    #[classattr]
    const Selected: AzAccessibilityState = AzAccessibilityState::Selected;
    #[classattr]
    const Focused: AzAccessibilityState = AzAccessibilityState::Focused;
    #[classattr]
    const Checked: AzAccessibilityState = AzAccessibilityState::Checked;
    #[classattr]
    const Readonly: AzAccessibilityState = AzAccessibilityState::Readonly;
    #[classattr]
    const Default: AzAccessibilityState = AzAccessibilityState::Default;
    #[classattr]
    const Expanded: AzAccessibilityState = AzAccessibilityState::Expanded;
    #[classattr]
    const Collapsed: AzAccessibilityState = AzAccessibilityState::Collapsed;
    #[classattr]
    const Busy: AzAccessibilityState = AzAccessibilityState::Busy;
    #[classattr]
    const Offscreen: AzAccessibilityState = AzAccessibilityState::Offscreen;
    #[classattr]
    const Focusable: AzAccessibilityState = AzAccessibilityState::Focusable;
    #[classattr]
    const Selectable: AzAccessibilityState = AzAccessibilityState::Selectable;
    #[classattr]
    const Linked: AzAccessibilityState = AzAccessibilityState::Linked;
    #[classattr]
    const Traversed: AzAccessibilityState = AzAccessibilityState::Traversed;
    #[classattr]
    const Multiselectable: AzAccessibilityState = AzAccessibilityState::Multiselectable;
    #[classattr]
    const Protected: AzAccessibilityState = AzAccessibilityState::Protected;
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAccessibilityStateEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzTabIndexEnumWrapper {
    #[classattr]
    fn Auto() -> AzTabIndexEnumWrapper {
        AzTabIndexEnumWrapper { inner: AzTabIndex::Auto }
    }
    #[staticmethod]
    fn OverrideInParent(v: u32) -> AzTabIndexEnumWrapper {
        AzTabIndexEnumWrapper { inner: AzTabIndex::OverrideInParent(v) }}
    }
    #[classattr]
    fn NoKeyboardFocus() -> AzTabIndexEnumWrapper {
        AzTabIndexEnumWrapper { inner: AzTabIndex::NoKeyboardFocus }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzTabIndex;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTabIndex::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzTabIndex::OverrideInParent(v) => Ok(vec!["OverrideInParent".into_py(py), v.into_py(py)]),
            AzTabIndex::NoKeyboardFocus => Ok(vec!["NoKeyboardFocus".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTabIndexEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::TabIndex = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::TabIndex = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataInlineCssPropertyEnumWrapper {
    #[staticmethod]
    fn Normal(v: CssProperty) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Normal(v) }}
    }
    #[staticmethod]
    fn Active(v: CssProperty) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Active(v) }}
    }
    #[staticmethod]
    fn Focus(v: CssProperty) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Focus(v) }}
    }
    #[staticmethod]
    fn Hover(v: CssProperty) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Hover(v) }}
    }
    #[staticmethod]
    fn Disabled(v: CssProperty) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Disabled(v) }}
    }
    #[staticmethod]
    fn Checked(v: CssProperty) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Checked(v) }}
    }
    #[staticmethod]
    fn FocusWithin(v: CssProperty) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::FocusWithin(v) }}
    }
    #[staticmethod]
    fn Visited(v: CssProperty) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper { inner: AzNodeDataInlineCssProperty::Visited(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeDataInlineCssProperty;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeDataInlineCssProperty::Normal(v) => Ok(vec!["Normal".into_py(py), v.into_py(py)]),
            AzNodeDataInlineCssProperty::Active(v) => Ok(vec!["Active".into_py(py), v.into_py(py)]),
            AzNodeDataInlineCssProperty::Focus(v) => Ok(vec!["Focus".into_py(py), v.into_py(py)]),
            AzNodeDataInlineCssProperty::Hover(v) => Ok(vec!["Hover".into_py(py), v.into_py(py)]),
            AzNodeDataInlineCssProperty::Disabled(v) => Ok(vec!["Disabled".into_py(py), v.into_py(py)]),
            AzNodeDataInlineCssProperty::Checked(v) => Ok(vec!["Checked".into_py(py), v.into_py(py)]),
            AzNodeDataInlineCssProperty::FocusWithin(v) => Ok(vec!["FocusWithin".into_py(py), v.into_py(py)]),
            AzNodeDataInlineCssProperty::Visited(v) => Ok(vec!["Visited".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataInlineCssPropertyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataInlineCssProperty = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataInlineCssProperty = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomId {
}

#[pyproto]
impl PyObjectProtocol for AzDomId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::DomId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::DomId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomNodeId {
}

#[pyproto]
impl PyObjectProtocol for AzDomNodeId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::DomNodeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::DomNodeId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAccessibilityActionEnumWrapper {
    #[classattr]
    fn Default() -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::Default }
    }
    #[classattr]
    fn Focus() -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::Focus }
    }
    #[classattr]
    fn Blur() -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::Blur }
    }
    #[classattr]
    fn Collapse() -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::Collapse }
    }
    #[classattr]
    fn Expand() -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::Expand }
    }
    #[classattr]
    fn ScrollIntoView() -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::ScrollIntoView }
    }
    #[classattr]
    fn Increment() -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::Increment }
    }
    #[classattr]
    fn Decrement() -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::Decrement }
    }
    #[classattr]
    fn ShowContextMenu() -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::ShowContextMenu }
    }
    #[classattr]
    fn HideTooltip() -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::HideTooltip }
    }
    #[classattr]
    fn ShowTooltip() -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::ShowTooltip }
    }
    #[classattr]
    fn ScrollUp() -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::ScrollUp }
    }
    #[classattr]
    fn ScrollDown() -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::ScrollDown }
    }
    #[classattr]
    fn ScrollLeft() -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::ScrollLeft }
    }
    #[classattr]
    fn ScrollRight() -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::ScrollRight }
    }
    #[staticmethod]
    fn ReplaceSelectedText(v: String) -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::ReplaceSelectedText(v) }}
    }
    #[staticmethod]
    fn ScrollToPoint(v: LogicalPosition) -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::ScrollToPoint(v) }}
    }
    #[staticmethod]
    fn SetScrollOffset(v: LogicalPosition) -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::SetScrollOffset(v) }}
    }
    #[staticmethod]
    fn SetTextSelection(v: TextSelectionStartEnd) -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::SetTextSelection(v) }}
    }
    #[classattr]
    fn SetSequentialFocusNavigationStartingPoint() -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::SetSequentialFocusNavigationStartingPoint }
    }
    #[staticmethod]
    fn SetValue(v: String) -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::SetValue(v) }}
    }
    #[staticmethod]
    fn SetNumericValue(v: FloatValue) -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::SetNumericValue(v) }}
    }
    #[staticmethod]
    fn CustomAction(v: i32) -> AzAccessibilityActionEnumWrapper {
        AzAccessibilityActionEnumWrapper { inner: AzAccessibilityAction::CustomAction(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzAccessibilityAction;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAccessibilityAction::Default => Ok(vec!["Default".into_py(py), ().into_py(py)]),
            AzAccessibilityAction::Focus => Ok(vec!["Focus".into_py(py), ().into_py(py)]),
            AzAccessibilityAction::Blur => Ok(vec!["Blur".into_py(py), ().into_py(py)]),
            AzAccessibilityAction::Collapse => Ok(vec!["Collapse".into_py(py), ().into_py(py)]),
            AzAccessibilityAction::Expand => Ok(vec!["Expand".into_py(py), ().into_py(py)]),
            AzAccessibilityAction::ScrollIntoView => Ok(vec!["ScrollIntoView".into_py(py), ().into_py(py)]),
            AzAccessibilityAction::Increment => Ok(vec!["Increment".into_py(py), ().into_py(py)]),
            AzAccessibilityAction::Decrement => Ok(vec!["Decrement".into_py(py), ().into_py(py)]),
            AzAccessibilityAction::ShowContextMenu => Ok(vec!["ShowContextMenu".into_py(py), ().into_py(py)]),
            AzAccessibilityAction::HideTooltip => Ok(vec!["HideTooltip".into_py(py), ().into_py(py)]),
            AzAccessibilityAction::ShowTooltip => Ok(vec!["ShowTooltip".into_py(py), ().into_py(py)]),
            AzAccessibilityAction::ScrollUp => Ok(vec!["ScrollUp".into_py(py), ().into_py(py)]),
            AzAccessibilityAction::ScrollDown => Ok(vec!["ScrollDown".into_py(py), ().into_py(py)]),
            AzAccessibilityAction::ScrollLeft => Ok(vec!["ScrollLeft".into_py(py), ().into_py(py)]),
            AzAccessibilityAction::ScrollRight => Ok(vec!["ScrollRight".into_py(py), ().into_py(py)]),
            AzAccessibilityAction::ReplaceSelectedText(v) => Ok(vec!["ReplaceSelectedText".into_py(py), v.into_py(py)]),
            AzAccessibilityAction::ScrollToPoint(v) => Ok(vec!["ScrollToPoint".into_py(py), v.into_py(py)]),
            AzAccessibilityAction::SetScrollOffset(v) => Ok(vec!["SetScrollOffset".into_py(py), v.into_py(py)]),
            AzAccessibilityAction::SetTextSelection(v) => Ok(vec!["SetTextSelection".into_py(py), v.into_py(py)]),
            AzAccessibilityAction::SetSequentialFocusNavigationStartingPoint => Ok(vec!["SetSequentialFocusNavigationStartingPoint".into_py(py), ().into_py(py)]),
            AzAccessibilityAction::SetValue(v) => Ok(vec!["SetValue".into_py(py), v.into_py(py)]),
            AzAccessibilityAction::SetNumericValue(v) => Ok(vec!["SetNumericValue".into_py(py), v.into_py(py)]),
            AzAccessibilityAction::CustomAction(v) => Ok(vec!["CustomAction".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityActionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityAction = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityAction = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnColumnClickCallback {
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnColumnClickCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewOnColumnClickCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewOnColumnClickCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTagIdToNodeIdMapping {
}

#[pyproto]
impl PyObjectProtocol for AzTagIdToNodeIdMapping {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::TagIdToNodeIdMapping = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::TagIdToNodeIdMapping = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCoreCallback {
}

#[pyproto]
impl PyObjectProtocol for AzCoreCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::CoreCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::CoreCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeHierarchyItemId {
}

#[pyproto]
impl PyObjectProtocol for AzNodeHierarchyItemId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeHierarchyItemId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeHierarchyItemId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgXmlNode {
}

#[pyproto]
impl PyObjectProtocol for AzSvgXmlNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgXmlNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgXmlNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCoreCallbackData {
}

#[pyproto]
impl PyObjectProtocol for AzCoreCallbackData {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::CoreCallbackData = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::CoreCallbackData = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnRowClickCallback {
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnRowClickCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewOnRowClickCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewOnRowClickCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgSimpleNodeEnumWrapper {
    #[staticmethod]
    fn Path(v: SvgPath) -> AzSvgSimpleNodeEnumWrapper {
        AzSvgSimpleNodeEnumWrapper { inner: AzSvgSimpleNode::Path(v) }}
    }
    #[staticmethod]
    fn Circle(v: SvgCircle) -> AzSvgSimpleNodeEnumWrapper {
        AzSvgSimpleNodeEnumWrapper { inner: AzSvgSimpleNode::Circle(v) }}
    }
    #[staticmethod]
    fn Rect(v: SvgRect) -> AzSvgSimpleNodeEnumWrapper {
        AzSvgSimpleNodeEnumWrapper { inner: AzSvgSimpleNode::Rect(v) }}
    }
    #[staticmethod]
    fn CircleHole(v: SvgCircle) -> AzSvgSimpleNodeEnumWrapper {
        AzSvgSimpleNodeEnumWrapper { inner: AzSvgSimpleNode::CircleHole(v) }}
    }
    #[staticmethod]
    fn RectHole(v: SvgRect) -> AzSvgSimpleNodeEnumWrapper {
        AzSvgSimpleNodeEnumWrapper { inner: AzSvgSimpleNode::RectHole(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgSimpleNode;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgSimpleNode::Path(v) => Ok(vec!["Path".into_py(py), v.into_py(py)]),
            AzSvgSimpleNode::Circle(v) => Ok(vec!["Circle".into_py(py), v.into_py(py)]),
            AzSvgSimpleNode::Rect(v) => Ok(vec!["Rect".into_py(py), v.into_py(py)]),
            AzSvgSimpleNode::CircleHole(v) => Ok(vec!["CircleHole".into_py(py), v.into_py(py)]),
            AzSvgSimpleNode::RectHole(v) => Ok(vec!["RectHole".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgSimpleNodeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgSimpleNode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgSimpleNode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCoreMenuCallback {
}

#[pyproto]
impl PyObjectProtocol for AzCoreMenuCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::CoreMenuCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::CoreMenuCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAttributeNameValue {
}

#[pyproto]
impl PyObjectProtocol for AzAttributeNameValue {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AttributeNameValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AttributeNameValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBoxOnToggleCallback {
}

#[pyproto]
impl PyObjectProtocol for AzCheckBoxOnToggleCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::check_box::CheckBoxOnToggleCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::check_box::CheckBoxOnToggleCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabOnClickCallback {
}

#[pyproto]
impl PyObjectProtocol for AzTabOnClickCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::tabs::TabOnClickCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::tabs::TabOnClickCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzParentWithNodeDepth {
}

#[pyproto]
impl PyObjectProtocol for AzParentWithNodeDepth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::ParentWithNodeDepth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::ParentWithNodeDepth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnLazyLoadScrollCallback {
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnLazyLoadScrollCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewOnLazyLoadScrollCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewOnLazyLoadScrollCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAttributeTypeEnumWrapper {
    #[staticmethod]
    fn Id(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Id(v) }}
    }
    #[staticmethod]
    fn Class(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Class(v) }}
    }
    #[staticmethod]
    fn AriaLabel(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::AriaLabel(v) }}
    }
    #[staticmethod]
    fn AriaLabelledBy(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::AriaLabelledBy(v) }}
    }
    #[staticmethod]
    fn AriaDescribedBy(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::AriaDescribedBy(v) }}
    }
    #[staticmethod]
    fn AriaRole(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::AriaRole(v) }}
    }
    #[staticmethod]
    fn AriaState(v: AttributeNameValue) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::AriaState(v) }}
    }
    #[staticmethod]
    fn AriaProperty(v: AttributeNameValue) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::AriaProperty(v) }}
    }
    #[staticmethod]
    fn Href(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Href(v) }}
    }
    #[staticmethod]
    fn Rel(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Rel(v) }}
    }
    #[staticmethod]
    fn Target(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Target(v) }}
    }
    #[staticmethod]
    fn Src(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Src(v) }}
    }
    #[staticmethod]
    fn Alt(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Alt(v) }}
    }
    #[staticmethod]
    fn Title(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Title(v) }}
    }
    #[staticmethod]
    fn Name(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Name(v) }}
    }
    #[staticmethod]
    fn Value(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Value(v) }}
    }
    #[staticmethod]
    fn InputType(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::InputType(v) }}
    }
    #[staticmethod]
    fn Placeholder(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Placeholder(v) }}
    }
    #[classattr]
    fn Required() -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Required }
    }
    #[classattr]
    fn Disabled() -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Disabled }
    }
    #[classattr]
    fn Readonly() -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Readonly }
    }
    #[classattr]
    fn Checked() -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Checked }
    }
    #[classattr]
    fn Selected() -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Selected }
    }
    #[staticmethod]
    fn Max(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Max(v) }}
    }
    #[staticmethod]
    fn Min(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Min(v) }}
    }
    #[staticmethod]
    fn Step(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Step(v) }}
    }
    #[staticmethod]
    fn Pattern(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Pattern(v) }}
    }
    #[staticmethod]
    fn MinLength(v: i32) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::MinLength(v) }}
    }
    #[staticmethod]
    fn MaxLength(v: i32) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::MaxLength(v) }}
    }
    #[staticmethod]
    fn Autocomplete(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Autocomplete(v) }}
    }
    #[staticmethod]
    fn Scope(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Scope(v) }}
    }
    #[staticmethod]
    fn ColSpan(v: i32) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::ColSpan(v) }}
    }
    #[staticmethod]
    fn RowSpan(v: i32) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::RowSpan(v) }}
    }
    #[staticmethod]
    fn TabIndex(v: i32) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::TabIndex(v) }}
    }
    #[classattr]
    fn Focusable() -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Focusable }
    }
    #[staticmethod]
    fn Lang(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Lang(v) }}
    }
    #[staticmethod]
    fn Dir(v: String) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Dir(v) }}
    }
    #[staticmethod]
    fn ContentEditable(v: bool) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::ContentEditable(v) }}
    }
    #[staticmethod]
    fn Draggable(v: bool) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Draggable(v) }}
    }
    #[classattr]
    fn Hidden() -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Hidden }
    }
    #[staticmethod]
    fn Data(v: AttributeNameValue) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Data(v) }}
    }
    #[staticmethod]
    fn Custom(v: AttributeNameValue) -> AzAttributeTypeEnumWrapper {
        AzAttributeTypeEnumWrapper { inner: AzAttributeType::Custom(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzAttributeType;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAttributeType::Id(v) => Ok(vec!["Id".into_py(py), v.into_py(py)]),
            AzAttributeType::Class(v) => Ok(vec!["Class".into_py(py), v.into_py(py)]),
            AzAttributeType::AriaLabel(v) => Ok(vec!["AriaLabel".into_py(py), v.into_py(py)]),
            AzAttributeType::AriaLabelledBy(v) => Ok(vec!["AriaLabelledBy".into_py(py), v.into_py(py)]),
            AzAttributeType::AriaDescribedBy(v) => Ok(vec!["AriaDescribedBy".into_py(py), v.into_py(py)]),
            AzAttributeType::AriaRole(v) => Ok(vec!["AriaRole".into_py(py), v.into_py(py)]),
            AzAttributeType::AriaState(v) => Ok(vec!["AriaState".into_py(py), v.into_py(py)]),
            AzAttributeType::AriaProperty(v) => Ok(vec!["AriaProperty".into_py(py), v.into_py(py)]),
            AzAttributeType::Href(v) => Ok(vec!["Href".into_py(py), v.into_py(py)]),
            AzAttributeType::Rel(v) => Ok(vec!["Rel".into_py(py), v.into_py(py)]),
            AzAttributeType::Target(v) => Ok(vec!["Target".into_py(py), v.into_py(py)]),
            AzAttributeType::Src(v) => Ok(vec!["Src".into_py(py), v.into_py(py)]),
            AzAttributeType::Alt(v) => Ok(vec!["Alt".into_py(py), v.into_py(py)]),
            AzAttributeType::Title(v) => Ok(vec!["Title".into_py(py), v.into_py(py)]),
            AzAttributeType::Name(v) => Ok(vec!["Name".into_py(py), v.into_py(py)]),
            AzAttributeType::Value(v) => Ok(vec!["Value".into_py(py), v.into_py(py)]),
            AzAttributeType::InputType(v) => Ok(vec!["InputType".into_py(py), v.into_py(py)]),
            AzAttributeType::Placeholder(v) => Ok(vec!["Placeholder".into_py(py), v.into_py(py)]),
            AzAttributeType::Required => Ok(vec!["Required".into_py(py), ().into_py(py)]),
            AzAttributeType::Disabled => Ok(vec!["Disabled".into_py(py), ().into_py(py)]),
            AzAttributeType::Readonly => Ok(vec!["Readonly".into_py(py), ().into_py(py)]),
            AzAttributeType::Checked => Ok(vec!["Checked".into_py(py), ().into_py(py)]),
            AzAttributeType::Selected => Ok(vec!["Selected".into_py(py), ().into_py(py)]),
            AzAttributeType::Max(v) => Ok(vec!["Max".into_py(py), v.into_py(py)]),
            AzAttributeType::Min(v) => Ok(vec!["Min".into_py(py), v.into_py(py)]),
            AzAttributeType::Step(v) => Ok(vec!["Step".into_py(py), v.into_py(py)]),
            AzAttributeType::Pattern(v) => Ok(vec!["Pattern".into_py(py), v.into_py(py)]),
            AzAttributeType::MinLength(v) => Ok(vec!["MinLength".into_py(py), v.into_py(py)]),
            AzAttributeType::MaxLength(v) => Ok(vec!["MaxLength".into_py(py), v.into_py(py)]),
            AzAttributeType::Autocomplete(v) => Ok(vec!["Autocomplete".into_py(py), v.into_py(py)]),
            AzAttributeType::Scope(v) => Ok(vec!["Scope".into_py(py), v.into_py(py)]),
            AzAttributeType::ColSpan(v) => Ok(vec!["ColSpan".into_py(py), v.into_py(py)]),
            AzAttributeType::RowSpan(v) => Ok(vec!["RowSpan".into_py(py), v.into_py(py)]),
            AzAttributeType::TabIndex(v) => Ok(vec!["TabIndex".into_py(py), v.into_py(py)]),
            AzAttributeType::Focusable => Ok(vec!["Focusable".into_py(py), ().into_py(py)]),
            AzAttributeType::Lang(v) => Ok(vec!["Lang".into_py(py), v.into_py(py)]),
            AzAttributeType::Dir(v) => Ok(vec!["Dir".into_py(py), v.into_py(py)]),
            AzAttributeType::ContentEditable(v) => Ok(vec!["ContentEditable".into_py(py), v.into_py(py)]),
            AzAttributeType::Draggable(v) => Ok(vec!["Draggable".into_py(py), v.into_py(py)]),
            AzAttributeType::Hidden => Ok(vec!["Hidden".into_py(py), ().into_py(py)]),
            AzAttributeType::Data(v) => Ok(vec!["Data".into_py(py), v.into_py(py)]),
            AzAttributeType::Custom(v) => Ok(vec!["Custom".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAttributeTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AttributeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AttributeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlNodeChildEnumWrapper {
    #[staticmethod]
    fn Text(v: String) -> AzXmlNodeChildEnumWrapper {
        AzXmlNodeChildEnumWrapper { inner: AzXmlNodeChild::Text(v) }}
    }
    #[staticmethod]
    fn Element(v: XmlNode) -> AzXmlNodeChildEnumWrapper {
        AzXmlNodeChildEnumWrapper { inner: AzXmlNodeChild::Element(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzXmlNodeChild;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlNodeChild::Text(v) => Ok(vec!["Text".into_py(py), v.into_py(py)]),
            AzXmlNodeChild::Element(v) => Ok(vec!["Element".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlNodeChildEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlNodeChild = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlNodeChild = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeHierarchyItem {
}

#[pyproto]
impl PyObjectProtocol for AzNodeHierarchyItem {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeHierarchyItem = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeHierarchyItem = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzButtonOnClickCallback {
}

#[pyproto]
impl PyObjectProtocol for AzButtonOnClickCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::button::ButtonOnClickCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::button::ButtonOnClickCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlNode {
}

#[pyproto]
impl PyObjectProtocol for AzXmlNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTagId {
}

#[pyproto]
impl PyObjectProtocol for AzTagId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::TagId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::TagId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeTagEnumWrapper {
    #[classattr]
    const Html: AzNodeTypeTag = AzNodeTypeTag::Html;
    #[classattr]
    const Head: AzNodeTypeTag = AzNodeTypeTag::Head;
    #[classattr]
    const Body: AzNodeTypeTag = AzNodeTypeTag::Body;
    #[classattr]
    const Div: AzNodeTypeTag = AzNodeTypeTag::Div;
    #[classattr]
    const P: AzNodeTypeTag = AzNodeTypeTag::P;
    #[classattr]
    const Article: AzNodeTypeTag = AzNodeTypeTag::Article;
    #[classattr]
    const Section: AzNodeTypeTag = AzNodeTypeTag::Section;
    #[classattr]
    const Nav: AzNodeTypeTag = AzNodeTypeTag::Nav;
    #[classattr]
    const Aside: AzNodeTypeTag = AzNodeTypeTag::Aside;
    #[classattr]
    const Header: AzNodeTypeTag = AzNodeTypeTag::Header;
    #[classattr]
    const Footer: AzNodeTypeTag = AzNodeTypeTag::Footer;
    #[classattr]
    const Main: AzNodeTypeTag = AzNodeTypeTag::Main;
    #[classattr]
    const Figure: AzNodeTypeTag = AzNodeTypeTag::Figure;
    #[classattr]
    const FigCaption: AzNodeTypeTag = AzNodeTypeTag::FigCaption;
    #[classattr]
    const H1: AzNodeTypeTag = AzNodeTypeTag::H1;
    #[classattr]
    const H2: AzNodeTypeTag = AzNodeTypeTag::H2;
    #[classattr]
    const H3: AzNodeTypeTag = AzNodeTypeTag::H3;
    #[classattr]
    const H4: AzNodeTypeTag = AzNodeTypeTag::H4;
    #[classattr]
    const H5: AzNodeTypeTag = AzNodeTypeTag::H5;
    #[classattr]
    const H6: AzNodeTypeTag = AzNodeTypeTag::H6;
    #[classattr]
    const Br: AzNodeTypeTag = AzNodeTypeTag::Br;
    #[classattr]
    const Hr: AzNodeTypeTag = AzNodeTypeTag::Hr;
    #[classattr]
    const Pre: AzNodeTypeTag = AzNodeTypeTag::Pre;
    #[classattr]
    const BlockQuote: AzNodeTypeTag = AzNodeTypeTag::BlockQuote;
    #[classattr]
    const Address: AzNodeTypeTag = AzNodeTypeTag::Address;
    #[classattr]
    const Details: AzNodeTypeTag = AzNodeTypeTag::Details;
    #[classattr]
    const Summary: AzNodeTypeTag = AzNodeTypeTag::Summary;
    #[classattr]
    const Dialog: AzNodeTypeTag = AzNodeTypeTag::Dialog;
    #[classattr]
    const Ul: AzNodeTypeTag = AzNodeTypeTag::Ul;
    #[classattr]
    const Ol: AzNodeTypeTag = AzNodeTypeTag::Ol;
    #[classattr]
    const Li: AzNodeTypeTag = AzNodeTypeTag::Li;
    #[classattr]
    const Dl: AzNodeTypeTag = AzNodeTypeTag::Dl;
    #[classattr]
    const Dt: AzNodeTypeTag = AzNodeTypeTag::Dt;
    #[classattr]
    const Dd: AzNodeTypeTag = AzNodeTypeTag::Dd;
    #[classattr]
    const Menu: AzNodeTypeTag = AzNodeTypeTag::Menu;
    #[classattr]
    const MenuItem: AzNodeTypeTag = AzNodeTypeTag::MenuItem;
    #[classattr]
    const Dir: AzNodeTypeTag = AzNodeTypeTag::Dir;
    #[classattr]
    const Table: AzNodeTypeTag = AzNodeTypeTag::Table;
    #[classattr]
    const Caption: AzNodeTypeTag = AzNodeTypeTag::Caption;
    #[classattr]
    const THead: AzNodeTypeTag = AzNodeTypeTag::THead;
    #[classattr]
    const TBody: AzNodeTypeTag = AzNodeTypeTag::TBody;
    #[classattr]
    const TFoot: AzNodeTypeTag = AzNodeTypeTag::TFoot;
    #[classattr]
    const Tr: AzNodeTypeTag = AzNodeTypeTag::Tr;
    #[classattr]
    const Th: AzNodeTypeTag = AzNodeTypeTag::Th;
    #[classattr]
    const Td: AzNodeTypeTag = AzNodeTypeTag::Td;
    #[classattr]
    const ColGroup: AzNodeTypeTag = AzNodeTypeTag::ColGroup;
    #[classattr]
    const Col: AzNodeTypeTag = AzNodeTypeTag::Col;
    #[classattr]
    const Form: AzNodeTypeTag = AzNodeTypeTag::Form;
    #[classattr]
    const FieldSet: AzNodeTypeTag = AzNodeTypeTag::FieldSet;
    #[classattr]
    const Legend: AzNodeTypeTag = AzNodeTypeTag::Legend;
    #[classattr]
    const Label: AzNodeTypeTag = AzNodeTypeTag::Label;
    #[classattr]
    const Input: AzNodeTypeTag = AzNodeTypeTag::Input;
    #[classattr]
    const Button: AzNodeTypeTag = AzNodeTypeTag::Button;
    #[classattr]
    const Select: AzNodeTypeTag = AzNodeTypeTag::Select;
    #[classattr]
    const OptGroup: AzNodeTypeTag = AzNodeTypeTag::OptGroup;
    #[classattr]
    const SelectOption: AzNodeTypeTag = AzNodeTypeTag::SelectOption;
    #[classattr]
    const TextArea: AzNodeTypeTag = AzNodeTypeTag::TextArea;
    #[classattr]
    const Output: AzNodeTypeTag = AzNodeTypeTag::Output;
    #[classattr]
    const Progress: AzNodeTypeTag = AzNodeTypeTag::Progress;
    #[classattr]
    const Meter: AzNodeTypeTag = AzNodeTypeTag::Meter;
    #[classattr]
    const DataList: AzNodeTypeTag = AzNodeTypeTag::DataList;
    #[classattr]
    const Span: AzNodeTypeTag = AzNodeTypeTag::Span;
    #[classattr]
    const A: AzNodeTypeTag = AzNodeTypeTag::A;
    #[classattr]
    const Em: AzNodeTypeTag = AzNodeTypeTag::Em;
    #[classattr]
    const Strong: AzNodeTypeTag = AzNodeTypeTag::Strong;
    #[classattr]
    const B: AzNodeTypeTag = AzNodeTypeTag::B;
    #[classattr]
    const I: AzNodeTypeTag = AzNodeTypeTag::I;
    #[classattr]
    const U: AzNodeTypeTag = AzNodeTypeTag::U;
    #[classattr]
    const S: AzNodeTypeTag = AzNodeTypeTag::S;
    #[classattr]
    const Mark: AzNodeTypeTag = AzNodeTypeTag::Mark;
    #[classattr]
    const Del: AzNodeTypeTag = AzNodeTypeTag::Del;
    #[classattr]
    const Ins: AzNodeTypeTag = AzNodeTypeTag::Ins;
    #[classattr]
    const Code: AzNodeTypeTag = AzNodeTypeTag::Code;
    #[classattr]
    const Samp: AzNodeTypeTag = AzNodeTypeTag::Samp;
    #[classattr]
    const Kbd: AzNodeTypeTag = AzNodeTypeTag::Kbd;
    #[classattr]
    const Var: AzNodeTypeTag = AzNodeTypeTag::Var;
    #[classattr]
    const Cite: AzNodeTypeTag = AzNodeTypeTag::Cite;
    #[classattr]
    const Dfn: AzNodeTypeTag = AzNodeTypeTag::Dfn;
    #[classattr]
    const Abbr: AzNodeTypeTag = AzNodeTypeTag::Abbr;
    #[classattr]
    const Acronym: AzNodeTypeTag = AzNodeTypeTag::Acronym;
    #[classattr]
    const Q: AzNodeTypeTag = AzNodeTypeTag::Q;
    #[classattr]
    const Time: AzNodeTypeTag = AzNodeTypeTag::Time;
    #[classattr]
    const Sub: AzNodeTypeTag = AzNodeTypeTag::Sub;
    #[classattr]
    const Sup: AzNodeTypeTag = AzNodeTypeTag::Sup;
    #[classattr]
    const Small: AzNodeTypeTag = AzNodeTypeTag::Small;
    #[classattr]
    const Big: AzNodeTypeTag = AzNodeTypeTag::Big;
    #[classattr]
    const Bdo: AzNodeTypeTag = AzNodeTypeTag::Bdo;
    #[classattr]
    const Bdi: AzNodeTypeTag = AzNodeTypeTag::Bdi;
    #[classattr]
    const Wbr: AzNodeTypeTag = AzNodeTypeTag::Wbr;
    #[classattr]
    const Ruby: AzNodeTypeTag = AzNodeTypeTag::Ruby;
    #[classattr]
    const Rt: AzNodeTypeTag = AzNodeTypeTag::Rt;
    #[classattr]
    const Rtc: AzNodeTypeTag = AzNodeTypeTag::Rtc;
    #[classattr]
    const Rp: AzNodeTypeTag = AzNodeTypeTag::Rp;
    #[classattr]
    const Data: AzNodeTypeTag = AzNodeTypeTag::Data;
    #[classattr]
    const Canvas: AzNodeTypeTag = AzNodeTypeTag::Canvas;
    #[classattr]
    const Object: AzNodeTypeTag = AzNodeTypeTag::Object;
    #[classattr]
    const Param: AzNodeTypeTag = AzNodeTypeTag::Param;
    #[classattr]
    const Embed: AzNodeTypeTag = AzNodeTypeTag::Embed;
    #[classattr]
    const Audio: AzNodeTypeTag = AzNodeTypeTag::Audio;
    #[classattr]
    const Video: AzNodeTypeTag = AzNodeTypeTag::Video;
    #[classattr]
    const Source: AzNodeTypeTag = AzNodeTypeTag::Source;
    #[classattr]
    const Track: AzNodeTypeTag = AzNodeTypeTag::Track;
    #[classattr]
    const Map: AzNodeTypeTag = AzNodeTypeTag::Map;
    #[classattr]
    const Area: AzNodeTypeTag = AzNodeTypeTag::Area;
    #[classattr]
    const Svg: AzNodeTypeTag = AzNodeTypeTag::Svg;
    #[classattr]
    const Title: AzNodeTypeTag = AzNodeTypeTag::Title;
    #[classattr]
    const Meta: AzNodeTypeTag = AzNodeTypeTag::Meta;
    #[classattr]
    const Link: AzNodeTypeTag = AzNodeTypeTag::Link;
    #[classattr]
    const Script: AzNodeTypeTag = AzNodeTypeTag::Script;
    #[classattr]
    const Style: AzNodeTypeTag = AzNodeTypeTag::Style;
    #[classattr]
    const Base: AzNodeTypeTag = AzNodeTypeTag::Base;
    #[classattr]
    const Text: AzNodeTypeTag = AzNodeTypeTag::Text;
    #[classattr]
    const Img: AzNodeTypeTag = AzNodeTypeTag::Img;
    #[classattr]
    const IFrame: AzNodeTypeTag = AzNodeTypeTag::IFrame;
    #[classattr]
    const Before: AzNodeTypeTag = AzNodeTypeTag::Before;
    #[classattr]
    const After: AzNodeTypeTag = AzNodeTypeTag::After;
    #[classattr]
    const Marker: AzNodeTypeTag = AzNodeTypeTag::Marker;
    #[classattr]
    const Placeholder: AzNodeTypeTag = AzNodeTypeTag::Placeholder;
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeTagEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::NodeTypeTag = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::NodeTypeTag = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzNodeTypeTagEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzVertexAttributeTypeEnumWrapper {
    #[classattr]
    const Float: AzVertexAttributeType = AzVertexAttributeType::Float;
    #[classattr]
    const Double: AzVertexAttributeType = AzVertexAttributeType::Double;
    #[classattr]
    const UnsignedByte: AzVertexAttributeType = AzVertexAttributeType::UnsignedByte;
    #[classattr]
    const UnsignedShort: AzVertexAttributeType = AzVertexAttributeType::UnsignedShort;
    #[classattr]
    const UnsignedInt: AzVertexAttributeType = AzVertexAttributeType::UnsignedInt;
}

#[pyproto]
impl PyObjectProtocol for AzVertexAttributeTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexAttributeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexAttributeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzVertexAttributeTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzVertexAttribute {
}

#[pyproto]
impl PyObjectProtocol for AzVertexAttribute {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexAttribute = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexAttribute = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInstantPtrCloneCallback {
}

#[pyproto]
impl PyObjectProtocol for AzInstantPtrCloneCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::InstantPtrCloneCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::InstantPtrCloneCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInstantPtrDestructorCallback {
}

#[pyproto]
impl PyObjectProtocol for AzInstantPtrDestructorCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::InstantPtrDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::InstantPtrDestructorCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallback {
}

#[pyproto]
impl PyObjectProtocol for AzCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::Callback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::Callback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDebugState {
}

#[pyproto]
impl PyObjectProtocol for AzDebugState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::DebugState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::DebugState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzKeyboardState {
}

#[pyproto]
impl PyObjectProtocol for AzKeyboardState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::KeyboardState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::KeyboardState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTouchState {
}

#[pyproto]
impl PyObjectProtocol for AzTouchState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::TouchState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::TouchState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMouseState {
}

#[pyproto]
impl PyObjectProtocol for AzMouseState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MouseState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MouseState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenu {
    #[new]
    fn new(/* args */) -> AzMenu {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_popup_position(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_popup_position(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzMenu {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::Menu = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::Menu = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzContextMenuMouseButtonEnumWrapper {
    #[classattr]
    const Right: AzContextMenuMouseButton = AzContextMenuMouseButton::Right;
    #[classattr]
    const Middle: AzContextMenuMouseButton = AzContextMenuMouseButton::Middle;
    #[classattr]
    const Left: AzContextMenuMouseButton = AzContextMenuMouseButton::Left;
}

#[pyproto]
impl PyObjectProtocol for AzContextMenuMouseButtonEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ContextMenuMouseButton = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ContextMenuMouseButton = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzContextMenuMouseButtonEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzMenuPopupPositionEnumWrapper {
    #[classattr]
    const BottomLeftOfCursor: AzMenuPopupPosition = AzMenuPopupPosition::BottomLeftOfCursor;
    #[classattr]
    const BottomRightOfCursor: AzMenuPopupPosition = AzMenuPopupPosition::BottomRightOfCursor;
    #[classattr]
    const TopLeftOfCursor: AzMenuPopupPosition = AzMenuPopupPosition::TopLeftOfCursor;
    #[classattr]
    const TopRightOfCursor: AzMenuPopupPosition = AzMenuPopupPosition::TopRightOfCursor;
    #[classattr]
    const BottomOfHitRect: AzMenuPopupPosition = AzMenuPopupPosition::BottomOfHitRect;
    #[classattr]
    const LeftOfHitRect: AzMenuPopupPosition = AzMenuPopupPosition::LeftOfHitRect;
    #[classattr]
    const TopOfHitRect: AzMenuPopupPosition = AzMenuPopupPosition::TopOfHitRect;
    #[classattr]
    const RightOfHitRect: AzMenuPopupPosition = AzMenuPopupPosition::RightOfHitRect;
    #[classattr]
    const AutoCursor: AzMenuPopupPosition = AzMenuPopupPosition::AutoCursor;
    #[classattr]
    const AutoHitRect: AzMenuPopupPosition = AzMenuPopupPosition::AutoHitRect;
}

#[pyproto]
impl PyObjectProtocol for AzMenuPopupPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuPopupPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuPopupPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzMenuPopupPositionEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzMenuItemEnumWrapper {
    #[staticmethod]
    fn String(v: StringMenuItem) -> AzMenuItemEnumWrapper {
        AzMenuItemEnumWrapper { inner: AzMenuItem::String(v) }}
    }
    #[classattr]
    fn Separator() -> AzMenuItemEnumWrapper {
        AzMenuItemEnumWrapper { inner: AzMenuItem::Separator }
    }
    #[classattr]
    fn BreakLine() -> AzMenuItemEnumWrapper {
        AzMenuItemEnumWrapper { inner: AzMenuItem::BreakLine }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzMenuItem;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzMenuItem::String(v) => Ok(vec!["String".into_py(py), v.into_py(py)]),
            AzMenuItem::Separator => Ok(vec!["Separator".into_py(py), ().into_py(py)]),
            AzMenuItem::BreakLine => Ok(vec!["BreakLine".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItem = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItem = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringMenuItem {
    #[new]
    fn new(/* args */) -> AzStringMenuItem {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn add_child(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_child(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_children(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_children(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzStringMenuItem {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::StringMenuItem = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::StringMenuItem = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuItemIconEnumWrapper {
    #[staticmethod]
    fn Checkbox(v: bool) -> AzMenuItemIconEnumWrapper {
        AzMenuItemIconEnumWrapper { inner: AzMenuItemIcon::Checkbox(v) }}
    }
    #[staticmethod]
    fn Image(v: ImageRef) -> AzMenuItemIconEnumWrapper {
        AzMenuItemIconEnumWrapper { inner: AzMenuItemIcon::Image(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzMenuItemIcon;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzMenuItemIcon::Checkbox(v) => Ok(vec!["Checkbox".into_py(py), v.into_py(py)]),
            AzMenuItemIcon::Image(v) => Ok(vec!["Image".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItemIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItemIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuItemStateEnumWrapper {
    #[classattr]
    const Normal: AzMenuItemState = AzMenuItemState::Normal;
    #[classattr]
    const Greyed: AzMenuItemState = AzMenuItemState::Greyed;
    #[classattr]
    const Disabled: AzMenuItemState = AzMenuItemState::Disabled;
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItemState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItemState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzMenuItemStateEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzCssRuleBlock {
}

#[pyproto]
impl PyObjectProtocol for AzCssRuleBlock {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssRuleBlock = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssRuleBlock = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyEnumWrapper {
    #[staticmethod]
    fn CaretColor(v: CaretColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::CaretColor(v) }}
    }
    #[staticmethod]
    fn CaretAnimationDuration(v: CaretAnimationDurationValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::CaretAnimationDuration(v) }}
    }
    #[staticmethod]
    fn SelectionBackgroundColor(v: SelectionBackgroundColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::SelectionBackgroundColor(v) }}
    }
    #[staticmethod]
    fn SelectionColor(v: SelectionColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::SelectionColor(v) }}
    }
    #[staticmethod]
    fn SelectionRadius(v: SelectionRadiusValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::SelectionRadius(v) }}
    }
    #[staticmethod]
    fn TextColor(v: StyleTextColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TextColor(v) }}
    }
    #[staticmethod]
    fn FontSize(v: StyleFontSizeValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FontSize(v) }}
    }
    #[staticmethod]
    fn FontFamily(v: StyleFontFamilyVecValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FontFamily(v) }}
    }
    #[staticmethod]
    fn FontWeight(v: StyleFontWeightValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FontWeight(v) }}
    }
    #[staticmethod]
    fn FontStyle(v: StyleFontStyleValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FontStyle(v) }}
    }
    #[staticmethod]
    fn TextAlign(v: StyleTextAlignValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TextAlign(v) }}
    }
    #[staticmethod]
    fn TextJustify(v: LayoutTextJustifyValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TextJustify(v) }}
    }
    #[staticmethod]
    fn VerticalAlign(v: StyleVerticalAlignValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::VerticalAlign(v) }}
    }
    #[staticmethod]
    fn LetterSpacing(v: StyleLetterSpacingValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::LetterSpacing(v) }}
    }
    #[staticmethod]
    fn TextIndent(v: StyleTextIndentValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TextIndent(v) }}
    }
    #[staticmethod]
    fn InitialLetter(v: StyleInitialLetterValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::InitialLetter(v) }}
    }
    #[staticmethod]
    fn LineClamp(v: StyleLineClampValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::LineClamp(v) }}
    }
    #[staticmethod]
    fn HangingPunctuation(v: StyleHangingPunctuationValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::HangingPunctuation(v) }}
    }
    #[staticmethod]
    fn TextCombineUpright(v: StyleTextCombineUprightValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TextCombineUpright(v) }}
    }
    #[staticmethod]
    fn ExclusionMargin(v: StyleExclusionMarginValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ExclusionMargin(v) }}
    }
    #[staticmethod]
    fn HyphenationLanguage(v: StyleHyphenationLanguageValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::HyphenationLanguage(v) }}
    }
    #[staticmethod]
    fn LineHeight(v: StyleLineHeightValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::LineHeight(v) }}
    }
    #[staticmethod]
    fn WordSpacing(v: StyleWordSpacingValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::WordSpacing(v) }}
    }
    #[staticmethod]
    fn TabWidth(v: StyleTabWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TabWidth(v) }}
    }
    #[staticmethod]
    fn WhiteSpace(v: StyleWhiteSpaceValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::WhiteSpace(v) }}
    }
    #[staticmethod]
    fn Hyphens(v: StyleHyphensValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Hyphens(v) }}
    }
    #[staticmethod]
    fn Direction(v: StyleDirectionValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Direction(v) }}
    }
    #[staticmethod]
    fn UserSelect(v: StyleUserSelectValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::UserSelect(v) }}
    }
    #[staticmethod]
    fn TextDecoration(v: StyleTextDecorationValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TextDecoration(v) }}
    }
    #[staticmethod]
    fn Cursor(v: StyleCursorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Cursor(v) }}
    }
    #[staticmethod]
    fn Display(v: LayoutDisplayValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Display(v) }}
    }
    #[staticmethod]
    fn Float(v: LayoutFloatValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Float(v) }}
    }
    #[staticmethod]
    fn BoxSizing(v: LayoutBoxSizingValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxSizing(v) }}
    }
    #[staticmethod]
    fn Width(v: LayoutWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Width(v) }}
    }
    #[staticmethod]
    fn Height(v: LayoutHeightValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Height(v) }}
    }
    #[staticmethod]
    fn MinWidth(v: LayoutMinWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MinWidth(v) }}
    }
    #[staticmethod]
    fn MinHeight(v: LayoutMinHeightValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MinHeight(v) }}
    }
    #[staticmethod]
    fn MaxWidth(v: LayoutMaxWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MaxWidth(v) }}
    }
    #[staticmethod]
    fn MaxHeight(v: LayoutMaxHeightValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MaxHeight(v) }}
    }
    #[staticmethod]
    fn Position(v: LayoutPositionValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Position(v) }}
    }
    #[staticmethod]
    fn Top(v: LayoutTopValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Top(v) }}
    }
    #[staticmethod]
    fn Right(v: LayoutRightValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Right(v) }}
    }
    #[staticmethod]
    fn Left(v: LayoutLeftValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Left(v) }}
    }
    #[staticmethod]
    fn Bottom(v: LayoutBottomValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Bottom(v) }}
    }
    #[staticmethod]
    fn ZIndex(v: LayoutZIndexValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ZIndex(v) }}
    }
    #[staticmethod]
    fn FlexWrap(v: LayoutFlexWrapValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FlexWrap(v) }}
    }
    #[staticmethod]
    fn FlexDirection(v: LayoutFlexDirectionValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FlexDirection(v) }}
    }
    #[staticmethod]
    fn FlexGrow(v: LayoutFlexGrowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FlexGrow(v) }}
    }
    #[staticmethod]
    fn FlexShrink(v: LayoutFlexShrinkValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FlexShrink(v) }}
    }
    #[staticmethod]
    fn FlexBasis(v: LayoutFlexBasisValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FlexBasis(v) }}
    }
    #[staticmethod]
    fn JustifyContent(v: LayoutJustifyContentValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::JustifyContent(v) }}
    }
    #[staticmethod]
    fn AlignItems(v: LayoutAlignItemsValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::AlignItems(v) }}
    }
    #[staticmethod]
    fn AlignContent(v: LayoutAlignContentValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::AlignContent(v) }}
    }
    #[staticmethod]
    fn ColumnGap(v: LayoutColumnGapValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ColumnGap(v) }}
    }
    #[staticmethod]
    fn RowGap(v: LayoutRowGapValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::RowGap(v) }}
    }
    #[staticmethod]
    fn GridTemplateColumns(v: LayoutGridTemplateColumnsValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::GridTemplateColumns(v) }}
    }
    #[staticmethod]
    fn GridTemplateRows(v: LayoutGridTemplateRowsValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::GridTemplateRows(v) }}
    }
    #[staticmethod]
    fn GridAutoColumns(v: LayoutGridAutoColumnsValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::GridAutoColumns(v) }}
    }
    #[staticmethod]
    fn GridAutoRows(v: LayoutGridAutoRowsValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::GridAutoRows(v) }}
    }
    #[staticmethod]
    fn GridColumn(v: LayoutGridColumnValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::GridColumn(v) }}
    }
    #[staticmethod]
    fn GridRow(v: LayoutGridRowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::GridRow(v) }}
    }
    #[staticmethod]
    fn WritingMode(v: LayoutWritingModeValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::WritingMode(v) }}
    }
    #[staticmethod]
    fn Clear(v: LayoutClearValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Clear(v) }}
    }
    #[staticmethod]
    fn BackgroundContent(v: StyleBackgroundContentVecValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BackgroundContent(v) }}
    }
    #[staticmethod]
    fn BackgroundPosition(v: StyleBackgroundPositionVecValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BackgroundPosition(v) }}
    }
    #[staticmethod]
    fn BackgroundSize(v: StyleBackgroundSizeVecValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BackgroundSize(v) }}
    }
    #[staticmethod]
    fn BackgroundRepeat(v: StyleBackgroundRepeatVecValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BackgroundRepeat(v) }}
    }
    #[staticmethod]
    fn OverflowX(v: LayoutOverflowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::OverflowX(v) }}
    }
    #[staticmethod]
    fn OverflowY(v: LayoutOverflowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::OverflowY(v) }}
    }
    #[staticmethod]
    fn GridAutoFlow(v: LayoutGridAutoFlowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::GridAutoFlow(v) }}
    }
    #[staticmethod]
    fn JustifySelf(v: LayoutJustifySelfValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::JustifySelf(v) }}
    }
    #[staticmethod]
    fn JustifyItems(v: LayoutJustifyItemsValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::JustifyItems(v) }}
    }
    #[staticmethod]
    fn Gap(v: LayoutGapValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Gap(v) }}
    }
    #[staticmethod]
    fn GridGap(v: LayoutGapValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::GridGap(v) }}
    }
    #[staticmethod]
    fn AlignSelf(v: LayoutAlignSelfValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::AlignSelf(v) }}
    }
    #[staticmethod]
    fn Font(v: StyleFontValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Font(v) }}
    }
    #[staticmethod]
    fn PaddingTop(v: LayoutPaddingTopValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::PaddingTop(v) }}
    }
    #[staticmethod]
    fn PaddingLeft(v: LayoutPaddingLeftValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::PaddingLeft(v) }}
    }
    #[staticmethod]
    fn PaddingRight(v: LayoutPaddingRightValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::PaddingRight(v) }}
    }
    #[staticmethod]
    fn PaddingBottom(v: LayoutPaddingBottomValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::PaddingBottom(v) }}
    }
    #[staticmethod]
    fn PaddingInlineStart(v: LayoutPaddingInlineStartValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::PaddingInlineStart(v) }}
    }
    #[staticmethod]
    fn PaddingInlineEnd(v: LayoutPaddingInlineEndValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::PaddingInlineEnd(v) }}
    }
    #[staticmethod]
    fn MarginTop(v: LayoutMarginTopValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MarginTop(v) }}
    }
    #[staticmethod]
    fn MarginLeft(v: LayoutMarginLeftValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MarginLeft(v) }}
    }
    #[staticmethod]
    fn MarginRight(v: LayoutMarginRightValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MarginRight(v) }}
    }
    #[staticmethod]
    fn MarginBottom(v: LayoutMarginBottomValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MarginBottom(v) }}
    }
    #[staticmethod]
    fn BorderTopLeftRadius(v: StyleBorderTopLeftRadiusValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderTopLeftRadius(v) }}
    }
    #[staticmethod]
    fn LayoutTextJustify(v: LayoutTextJustifyValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::LayoutTextJustify(v) }}
    }
    #[staticmethod]
    fn BorderTopRightRadius(v: StyleBorderTopRightRadiusValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderTopRightRadius(v) }}
    }
    #[staticmethod]
    fn BorderBottomLeftRadius(v: StyleBorderBottomLeftRadiusValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderBottomLeftRadius(v) }}
    }
    #[staticmethod]
    fn BorderBottomRightRadius(v: StyleBorderBottomRightRadiusValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderBottomRightRadius(v) }}
    }
    #[staticmethod]
    fn BorderTopColor(v: StyleBorderTopColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderTopColor(v) }}
    }
    #[staticmethod]
    fn BorderRightColor(v: StyleBorderRightColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderRightColor(v) }}
    }
    #[staticmethod]
    fn BorderLeftColor(v: StyleBorderLeftColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderLeftColor(v) }}
    }
    #[staticmethod]
    fn BorderBottomColor(v: StyleBorderBottomColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderBottomColor(v) }}
    }
    #[staticmethod]
    fn BorderTopStyle(v: StyleBorderTopStyleValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderTopStyle(v) }}
    }
    #[staticmethod]
    fn BorderRightStyle(v: StyleBorderRightStyleValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderRightStyle(v) }}
    }
    #[staticmethod]
    fn BorderLeftStyle(v: StyleBorderLeftStyleValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderLeftStyle(v) }}
    }
    #[staticmethod]
    fn BorderBottomStyle(v: StyleBorderBottomStyleValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderBottomStyle(v) }}
    }
    #[staticmethod]
    fn BorderTopWidth(v: LayoutBorderTopWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderTopWidth(v) }}
    }
    #[staticmethod]
    fn BorderRightWidth(v: LayoutBorderRightWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderRightWidth(v) }}
    }
    #[staticmethod]
    fn BorderLeftWidth(v: LayoutBorderLeftWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderLeftWidth(v) }}
    }
    #[staticmethod]
    fn BorderBottomWidth(v: LayoutBorderBottomWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderBottomWidth(v) }}
    }
    #[staticmethod]
    fn BoxShadowLeft(v: StyleBoxShadowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxShadowLeft(v) }}
    }
    #[staticmethod]
    fn BoxShadowRight(v: StyleBoxShadowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxShadowRight(v) }}
    }
    #[staticmethod]
    fn BoxShadowTop(v: StyleBoxShadowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxShadowTop(v) }}
    }
    #[staticmethod]
    fn BoxShadowBottom(v: StyleBoxShadowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxShadowBottom(v) }}
    }
    #[staticmethod]
    fn Scrollbar(v: ScrollbarStyleValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Scrollbar(v) }}
    }
    #[staticmethod]
    fn ScrollbarWidth(v: LayoutScrollbarWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ScrollbarWidth(v) }}
    }
    #[staticmethod]
    fn ScrollbarColor(v: StyleScrollbarColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ScrollbarColor(v) }}
    }
    #[staticmethod]
    fn Opacity(v: StyleOpacityValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Opacity(v) }}
    }
    #[staticmethod]
    fn Visibility(v: StyleVisibilityValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Visibility(v) }}
    }
    #[staticmethod]
    fn Transform(v: StyleTransformVecValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Transform(v) }}
    }
    #[staticmethod]
    fn TransformOrigin(v: StyleTransformOriginValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TransformOrigin(v) }}
    }
    #[staticmethod]
    fn PerspectiveOrigin(v: StylePerspectiveOriginValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::PerspectiveOrigin(v) }}
    }
    #[staticmethod]
    fn BackfaceVisibility(v: StyleBackfaceVisibilityValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BackfaceVisibility(v) }}
    }
    #[staticmethod]
    fn MixBlendMode(v: StyleMixBlendModeValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::MixBlendMode(v) }}
    }
    #[staticmethod]
    fn Filter(v: StyleFilterVecValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Filter(v) }}
    }
    #[staticmethod]
    fn BackdropFilter(v: StyleFilterVecValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BackdropFilter(v) }}
    }
    #[staticmethod]
    fn TextShadow(v: StyleBoxShadowValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TextShadow(v) }}
    }
    #[staticmethod]
    fn BreakBefore(v: PageBreakValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BreakBefore(v) }}
    }
    #[staticmethod]
    fn BreakAfter(v: PageBreakValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BreakAfter(v) }}
    }
    #[staticmethod]
    fn BreakInside(v: BreakInsideValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BreakInside(v) }}
    }
    #[staticmethod]
    fn Orphans(v: OrphansValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Orphans(v) }}
    }
    #[staticmethod]
    fn Widows(v: WidowsValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Widows(v) }}
    }
    #[staticmethod]
    fn BoxDecorationBreak(v: BoxDecorationBreakValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BoxDecorationBreak(v) }}
    }
    #[staticmethod]
    fn ColumnCount(v: ColumnCountValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ColumnCount(v) }}
    }
    #[staticmethod]
    fn ColumnWidth(v: ColumnWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ColumnWidth(v) }}
    }
    #[staticmethod]
    fn ColumnSpan(v: ColumnSpanValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ColumnSpan(v) }}
    }
    #[staticmethod]
    fn ColumnFill(v: ColumnFillValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ColumnFill(v) }}
    }
    #[staticmethod]
    fn ColumnRuleWidth(v: ColumnRuleWidthValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ColumnRuleWidth(v) }}
    }
    #[staticmethod]
    fn ColumnRuleStyle(v: ColumnRuleStyleValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ColumnRuleStyle(v) }}
    }
    #[staticmethod]
    fn ColumnRuleColor(v: ColumnRuleColorValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ColumnRuleColor(v) }}
    }
    #[staticmethod]
    fn FlowInto(v: FlowIntoValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FlowInto(v) }}
    }
    #[staticmethod]
    fn FlowFrom(v: FlowFromValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::FlowFrom(v) }}
    }
    #[staticmethod]
    fn ShapeOutside(v: ShapeOutsideValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ShapeOutside(v) }}
    }
    #[staticmethod]
    fn ShapeInside(v: ShapeInsideValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ShapeInside(v) }}
    }
    #[staticmethod]
    fn ClipPath(v: ClipPathValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ClipPath(v) }}
    }
    #[staticmethod]
    fn ShapeMargin(v: ShapeMarginValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ShapeMargin(v) }}
    }
    #[staticmethod]
    fn ShapeImageThreshold(v: ShapeImageThresholdValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ShapeImageThreshold(v) }}
    }
    #[staticmethod]
    fn TableLayout(v: LayoutTableLayoutValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::TableLayout(v) }}
    }
    #[staticmethod]
    fn BorderCollapse(v: StyleBorderCollapseValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderCollapse(v) }}
    }
    #[staticmethod]
    fn BorderSpacing(v: LayoutBorderSpacingValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::BorderSpacing(v) }}
    }
    #[staticmethod]
    fn CaptionSide(v: StyleCaptionSideValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::CaptionSide(v) }}
    }
    #[staticmethod]
    fn EmptyCells(v: StyleEmptyCellsValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::EmptyCells(v) }}
    }
    #[staticmethod]
    fn Content(v: ContentValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::Content(v) }}
    }
    #[staticmethod]
    fn CounterReset(v: CounterResetValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::CounterReset(v) }}
    }
    #[staticmethod]
    fn CounterIncrement(v: CounterIncrementValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::CounterIncrement(v) }}
    }
    #[staticmethod]
    fn ListStyleType(v: StyleListStyleTypeValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ListStyleType(v) }}
    }
    #[staticmethod]
    fn ListStylePosition(v: StyleListStylePositionValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::ListStylePosition(v) }}
    }
    #[staticmethod]
    fn StringSet(v: StringSetValue) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper { inner: AzCssProperty::StringSet(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssProperty;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssProperty::CaretColor(v) => Ok(vec!["CaretColor".into_py(py), v.into_py(py)]),
            AzCssProperty::CaretAnimationDuration(v) => Ok(vec!["CaretAnimationDuration".into_py(py), v.into_py(py)]),
            AzCssProperty::SelectionBackgroundColor(v) => Ok(vec!["SelectionBackgroundColor".into_py(py), v.into_py(py)]),
            AzCssProperty::SelectionColor(v) => Ok(vec!["SelectionColor".into_py(py), v.into_py(py)]),
            AzCssProperty::SelectionRadius(v) => Ok(vec!["SelectionRadius".into_py(py), v.into_py(py)]),
            AzCssProperty::TextColor(v) => Ok(vec!["TextColor".into_py(py), v.into_py(py)]),
            AzCssProperty::FontSize(v) => Ok(vec!["FontSize".into_py(py), v.into_py(py)]),
            AzCssProperty::FontFamily(v) => Ok(vec!["FontFamily".into_py(py), v.into_py(py)]),
            AzCssProperty::FontWeight(v) => Ok(vec!["FontWeight".into_py(py), v.into_py(py)]),
            AzCssProperty::FontStyle(v) => Ok(vec!["FontStyle".into_py(py), v.into_py(py)]),
            AzCssProperty::TextAlign(v) => Ok(vec!["TextAlign".into_py(py), v.into_py(py)]),
            AzCssProperty::TextJustify(v) => Ok(vec!["TextJustify".into_py(py), v.into_py(py)]),
            AzCssProperty::VerticalAlign(v) => Ok(vec!["VerticalAlign".into_py(py), v.into_py(py)]),
            AzCssProperty::LetterSpacing(v) => Ok(vec!["LetterSpacing".into_py(py), v.into_py(py)]),
            AzCssProperty::TextIndent(v) => Ok(vec!["TextIndent".into_py(py), v.into_py(py)]),
            AzCssProperty::InitialLetter(v) => Ok(vec!["InitialLetter".into_py(py), v.into_py(py)]),
            AzCssProperty::LineClamp(v) => Ok(vec!["LineClamp".into_py(py), v.into_py(py)]),
            AzCssProperty::HangingPunctuation(v) => Ok(vec!["HangingPunctuation".into_py(py), v.into_py(py)]),
            AzCssProperty::TextCombineUpright(v) => Ok(vec!["TextCombineUpright".into_py(py), v.into_py(py)]),
            AzCssProperty::ExclusionMargin(v) => Ok(vec!["ExclusionMargin".into_py(py), v.into_py(py)]),
            AzCssProperty::HyphenationLanguage(v) => Ok(vec!["HyphenationLanguage".into_py(py), v.into_py(py)]),
            AzCssProperty::LineHeight(v) => Ok(vec!["LineHeight".into_py(py), v.into_py(py)]),
            AzCssProperty::WordSpacing(v) => Ok(vec!["WordSpacing".into_py(py), v.into_py(py)]),
            AzCssProperty::TabWidth(v) => Ok(vec!["TabWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::WhiteSpace(v) => Ok(vec!["WhiteSpace".into_py(py), v.into_py(py)]),
            AzCssProperty::Hyphens(v) => Ok(vec!["Hyphens".into_py(py), v.into_py(py)]),
            AzCssProperty::Direction(v) => Ok(vec!["Direction".into_py(py), v.into_py(py)]),
            AzCssProperty::UserSelect(v) => Ok(vec!["UserSelect".into_py(py), v.into_py(py)]),
            AzCssProperty::TextDecoration(v) => Ok(vec!["TextDecoration".into_py(py), v.into_py(py)]),
            AzCssProperty::Cursor(v) => Ok(vec!["Cursor".into_py(py), v.into_py(py)]),
            AzCssProperty::Display(v) => Ok(vec!["Display".into_py(py), v.into_py(py)]),
            AzCssProperty::Float(v) => Ok(vec!["Float".into_py(py), v.into_py(py)]),
            AzCssProperty::BoxSizing(v) => Ok(vec!["BoxSizing".into_py(py), v.into_py(py)]),
            AzCssProperty::Width(v) => Ok(vec!["Width".into_py(py), v.into_py(py)]),
            AzCssProperty::Height(v) => Ok(vec!["Height".into_py(py), v.into_py(py)]),
            AzCssProperty::MinWidth(v) => Ok(vec!["MinWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::MinHeight(v) => Ok(vec!["MinHeight".into_py(py), v.into_py(py)]),
            AzCssProperty::MaxWidth(v) => Ok(vec!["MaxWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::MaxHeight(v) => Ok(vec!["MaxHeight".into_py(py), v.into_py(py)]),
            AzCssProperty::Position(v) => Ok(vec!["Position".into_py(py), v.into_py(py)]),
            AzCssProperty::Top(v) => Ok(vec!["Top".into_py(py), v.into_py(py)]),
            AzCssProperty::Right(v) => Ok(vec!["Right".into_py(py), v.into_py(py)]),
            AzCssProperty::Left(v) => Ok(vec!["Left".into_py(py), v.into_py(py)]),
            AzCssProperty::Bottom(v) => Ok(vec!["Bottom".into_py(py), v.into_py(py)]),
            AzCssProperty::ZIndex(v) => Ok(vec!["ZIndex".into_py(py), v.into_py(py)]),
            AzCssProperty::FlexWrap(v) => Ok(vec!["FlexWrap".into_py(py), v.into_py(py)]),
            AzCssProperty::FlexDirection(v) => Ok(vec!["FlexDirection".into_py(py), v.into_py(py)]),
            AzCssProperty::FlexGrow(v) => Ok(vec!["FlexGrow".into_py(py), v.into_py(py)]),
            AzCssProperty::FlexShrink(v) => Ok(vec!["FlexShrink".into_py(py), v.into_py(py)]),
            AzCssProperty::FlexBasis(v) => Ok(vec!["FlexBasis".into_py(py), v.into_py(py)]),
            AzCssProperty::JustifyContent(v) => Ok(vec!["JustifyContent".into_py(py), v.into_py(py)]),
            AzCssProperty::AlignItems(v) => Ok(vec!["AlignItems".into_py(py), v.into_py(py)]),
            AzCssProperty::AlignContent(v) => Ok(vec!["AlignContent".into_py(py), v.into_py(py)]),
            AzCssProperty::ColumnGap(v) => Ok(vec!["ColumnGap".into_py(py), v.into_py(py)]),
            AzCssProperty::RowGap(v) => Ok(vec!["RowGap".into_py(py), v.into_py(py)]),
            AzCssProperty::GridTemplateColumns(v) => Ok(vec!["GridTemplateColumns".into_py(py), v.into_py(py)]),
            AzCssProperty::GridTemplateRows(v) => Ok(vec!["GridTemplateRows".into_py(py), v.into_py(py)]),
            AzCssProperty::GridAutoColumns(v) => Ok(vec!["GridAutoColumns".into_py(py), v.into_py(py)]),
            AzCssProperty::GridAutoRows(v) => Ok(vec!["GridAutoRows".into_py(py), v.into_py(py)]),
            AzCssProperty::GridColumn(v) => Ok(vec!["GridColumn".into_py(py), v.into_py(py)]),
            AzCssProperty::GridRow(v) => Ok(vec!["GridRow".into_py(py), v.into_py(py)]),
            AzCssProperty::WritingMode(v) => Ok(vec!["WritingMode".into_py(py), v.into_py(py)]),
            AzCssProperty::Clear(v) => Ok(vec!["Clear".into_py(py), v.into_py(py)]),
            AzCssProperty::BackgroundContent(v) => Ok(vec!["BackgroundContent".into_py(py), v.into_py(py)]),
            AzCssProperty::BackgroundPosition(v) => Ok(vec!["BackgroundPosition".into_py(py), v.into_py(py)]),
            AzCssProperty::BackgroundSize(v) => Ok(vec!["BackgroundSize".into_py(py), v.into_py(py)]),
            AzCssProperty::BackgroundRepeat(v) => Ok(vec!["BackgroundRepeat".into_py(py), v.into_py(py)]),
            AzCssProperty::OverflowX(v) => Ok(vec!["OverflowX".into_py(py), v.into_py(py)]),
            AzCssProperty::OverflowY(v) => Ok(vec!["OverflowY".into_py(py), v.into_py(py)]),
            AzCssProperty::GridAutoFlow(v) => Ok(vec!["GridAutoFlow".into_py(py), v.into_py(py)]),
            AzCssProperty::JustifySelf(v) => Ok(vec!["JustifySelf".into_py(py), v.into_py(py)]),
            AzCssProperty::JustifyItems(v) => Ok(vec!["JustifyItems".into_py(py), v.into_py(py)]),
            AzCssProperty::Gap(v) => Ok(vec!["Gap".into_py(py), v.into_py(py)]),
            AzCssProperty::GridGap(v) => Ok(vec!["GridGap".into_py(py), v.into_py(py)]),
            AzCssProperty::AlignSelf(v) => Ok(vec!["AlignSelf".into_py(py), v.into_py(py)]),
            AzCssProperty::Font(v) => Ok(vec!["Font".into_py(py), v.into_py(py)]),
            AzCssProperty::PaddingTop(v) => Ok(vec!["PaddingTop".into_py(py), v.into_py(py)]),
            AzCssProperty::PaddingLeft(v) => Ok(vec!["PaddingLeft".into_py(py), v.into_py(py)]),
            AzCssProperty::PaddingRight(v) => Ok(vec!["PaddingRight".into_py(py), v.into_py(py)]),
            AzCssProperty::PaddingBottom(v) => Ok(vec!["PaddingBottom".into_py(py), v.into_py(py)]),
            AzCssProperty::PaddingInlineStart(v) => Ok(vec!["PaddingInlineStart".into_py(py), v.into_py(py)]),
            AzCssProperty::PaddingInlineEnd(v) => Ok(vec!["PaddingInlineEnd".into_py(py), v.into_py(py)]),
            AzCssProperty::MarginTop(v) => Ok(vec!["MarginTop".into_py(py), v.into_py(py)]),
            AzCssProperty::MarginLeft(v) => Ok(vec!["MarginLeft".into_py(py), v.into_py(py)]),
            AzCssProperty::MarginRight(v) => Ok(vec!["MarginRight".into_py(py), v.into_py(py)]),
            AzCssProperty::MarginBottom(v) => Ok(vec!["MarginBottom".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderTopLeftRadius(v) => Ok(vec!["BorderTopLeftRadius".into_py(py), v.into_py(py)]),
            AzCssProperty::LayoutTextJustify(v) => Ok(vec!["LayoutTextJustify".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderTopRightRadius(v) => Ok(vec!["BorderTopRightRadius".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderBottomLeftRadius(v) => Ok(vec!["BorderBottomLeftRadius".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderBottomRightRadius(v) => Ok(vec!["BorderBottomRightRadius".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderTopColor(v) => Ok(vec!["BorderTopColor".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderRightColor(v) => Ok(vec!["BorderRightColor".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderLeftColor(v) => Ok(vec!["BorderLeftColor".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderBottomColor(v) => Ok(vec!["BorderBottomColor".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderTopStyle(v) => Ok(vec!["BorderTopStyle".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderRightStyle(v) => Ok(vec!["BorderRightStyle".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderLeftStyle(v) => Ok(vec!["BorderLeftStyle".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderBottomStyle(v) => Ok(vec!["BorderBottomStyle".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderTopWidth(v) => Ok(vec!["BorderTopWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderRightWidth(v) => Ok(vec!["BorderRightWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderLeftWidth(v) => Ok(vec!["BorderLeftWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderBottomWidth(v) => Ok(vec!["BorderBottomWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::BoxShadowLeft(v) => Ok(vec!["BoxShadowLeft".into_py(py), v.into_py(py)]),
            AzCssProperty::BoxShadowRight(v) => Ok(vec!["BoxShadowRight".into_py(py), v.into_py(py)]),
            AzCssProperty::BoxShadowTop(v) => Ok(vec!["BoxShadowTop".into_py(py), v.into_py(py)]),
            AzCssProperty::BoxShadowBottom(v) => Ok(vec!["BoxShadowBottom".into_py(py), v.into_py(py)]),
            AzCssProperty::Scrollbar(v) => Ok(vec!["Scrollbar".into_py(py), v.into_py(py)]),
            AzCssProperty::ScrollbarWidth(v) => Ok(vec!["ScrollbarWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::ScrollbarColor(v) => Ok(vec!["ScrollbarColor".into_py(py), v.into_py(py)]),
            AzCssProperty::Opacity(v) => Ok(vec!["Opacity".into_py(py), v.into_py(py)]),
            AzCssProperty::Visibility(v) => Ok(vec!["Visibility".into_py(py), v.into_py(py)]),
            AzCssProperty::Transform(v) => Ok(vec!["Transform".into_py(py), v.into_py(py)]),
            AzCssProperty::TransformOrigin(v) => Ok(vec!["TransformOrigin".into_py(py), v.into_py(py)]),
            AzCssProperty::PerspectiveOrigin(v) => Ok(vec!["PerspectiveOrigin".into_py(py), v.into_py(py)]),
            AzCssProperty::BackfaceVisibility(v) => Ok(vec!["BackfaceVisibility".into_py(py), v.into_py(py)]),
            AzCssProperty::MixBlendMode(v) => Ok(vec!["MixBlendMode".into_py(py), v.into_py(py)]),
            AzCssProperty::Filter(v) => Ok(vec!["Filter".into_py(py), v.into_py(py)]),
            AzCssProperty::BackdropFilter(v) => Ok(vec!["BackdropFilter".into_py(py), v.into_py(py)]),
            AzCssProperty::TextShadow(v) => Ok(vec!["TextShadow".into_py(py), v.into_py(py)]),
            AzCssProperty::BreakBefore(v) => Ok(vec!["BreakBefore".into_py(py), v.into_py(py)]),
            AzCssProperty::BreakAfter(v) => Ok(vec!["BreakAfter".into_py(py), v.into_py(py)]),
            AzCssProperty::BreakInside(v) => Ok(vec!["BreakInside".into_py(py), v.into_py(py)]),
            AzCssProperty::Orphans(v) => Ok(vec!["Orphans".into_py(py), v.into_py(py)]),
            AzCssProperty::Widows(v) => Ok(vec!["Widows".into_py(py), v.into_py(py)]),
            AzCssProperty::BoxDecorationBreak(v) => Ok(vec!["BoxDecorationBreak".into_py(py), v.into_py(py)]),
            AzCssProperty::ColumnCount(v) => Ok(vec!["ColumnCount".into_py(py), v.into_py(py)]),
            AzCssProperty::ColumnWidth(v) => Ok(vec!["ColumnWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::ColumnSpan(v) => Ok(vec!["ColumnSpan".into_py(py), v.into_py(py)]),
            AzCssProperty::ColumnFill(v) => Ok(vec!["ColumnFill".into_py(py), v.into_py(py)]),
            AzCssProperty::ColumnRuleWidth(v) => Ok(vec!["ColumnRuleWidth".into_py(py), v.into_py(py)]),
            AzCssProperty::ColumnRuleStyle(v) => Ok(vec!["ColumnRuleStyle".into_py(py), v.into_py(py)]),
            AzCssProperty::ColumnRuleColor(v) => Ok(vec!["ColumnRuleColor".into_py(py), v.into_py(py)]),
            AzCssProperty::FlowInto(v) => Ok(vec!["FlowInto".into_py(py), v.into_py(py)]),
            AzCssProperty::FlowFrom(v) => Ok(vec!["FlowFrom".into_py(py), v.into_py(py)]),
            AzCssProperty::ShapeOutside(v) => Ok(vec!["ShapeOutside".into_py(py), v.into_py(py)]),
            AzCssProperty::ShapeInside(v) => Ok(vec!["ShapeInside".into_py(py), v.into_py(py)]),
            AzCssProperty::ClipPath(v) => Ok(vec!["ClipPath".into_py(py), v.into_py(py)]),
            AzCssProperty::ShapeMargin(v) => Ok(vec!["ShapeMargin".into_py(py), v.into_py(py)]),
            AzCssProperty::ShapeImageThreshold(v) => Ok(vec!["ShapeImageThreshold".into_py(py), v.into_py(py)]),
            AzCssProperty::TableLayout(v) => Ok(vec!["TableLayout".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderCollapse(v) => Ok(vec!["BorderCollapse".into_py(py), v.into_py(py)]),
            AzCssProperty::BorderSpacing(v) => Ok(vec!["BorderSpacing".into_py(py), v.into_py(py)]),
            AzCssProperty::CaptionSide(v) => Ok(vec!["CaptionSide".into_py(py), v.into_py(py)]),
            AzCssProperty::EmptyCells(v) => Ok(vec!["EmptyCells".into_py(py), v.into_py(py)]),
            AzCssProperty::Content(v) => Ok(vec!["Content".into_py(py), v.into_py(py)]),
            AzCssProperty::CounterReset(v) => Ok(vec!["CounterReset".into_py(py), v.into_py(py)]),
            AzCssProperty::CounterIncrement(v) => Ok(vec!["CounterIncrement".into_py(py), v.into_py(py)]),
            AzCssProperty::ListStyleType(v) => Ok(vec!["ListStyleType".into_py(py), v.into_py(py)]),
            AzCssProperty::ListStylePosition(v) => Ok(vec!["ListStylePosition".into_py(py), v.into_py(py)]),
            AzCssProperty::StringSet(v) => Ok(vec!["StringSet".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::CssProperty = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::property::CssProperty = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssNthChildSelectorEnumWrapper {
    #[staticmethod]
    fn Number(v: u32) -> AzCssNthChildSelectorEnumWrapper {
        AzCssNthChildSelectorEnumWrapper { inner: AzCssNthChildSelector::Number(v) }}
    }
    #[classattr]
    fn Even() -> AzCssNthChildSelectorEnumWrapper {
        AzCssNthChildSelectorEnumWrapper { inner: AzCssNthChildSelector::Even }
    }
    #[classattr]
    fn Odd() -> AzCssNthChildSelectorEnumWrapper {
        AzCssNthChildSelectorEnumWrapper { inner: AzCssNthChildSelector::Odd }
    }
    #[staticmethod]
    fn Pattern(v: CssNthChildPattern) -> AzCssNthChildSelectorEnumWrapper {
        AzCssNthChildSelectorEnumWrapper { inner: AzCssNthChildSelector::Pattern(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssNthChildSelector;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssNthChildSelector::Number(v) => Ok(vec!["Number".into_py(py), v.into_py(py)]),
            AzCssNthChildSelector::Even => Ok(vec!["Even".into_py(py), ().into_py(py)]),
            AzCssNthChildSelector::Odd => Ok(vec!["Odd".into_py(py), ().into_py(py)]),
            AzCssNthChildSelector::Pattern(v) => Ok(vec!["Pattern".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssNthChildSelectorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssNthChildSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssNthChildSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssNthChildPattern {
}

#[pyproto]
impl PyObjectProtocol for AzCssNthChildPattern {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssNthChildPattern = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssNthChildPattern = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylesheet {
}

#[pyproto]
impl PyObjectProtocol for AzStylesheet {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::Stylesheet = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::Stylesheet = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCss {
    #[staticmethod]
    fn empty(/* args */) -> AzCss {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn from_string(/* args */) -> AzCss {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzCss {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::Css = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::Css = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssDeclarationEnumWrapper {
    #[staticmethod]
    fn Static(v: CssProperty) -> AzCssDeclarationEnumWrapper {
        AzCssDeclarationEnumWrapper { inner: AzCssDeclaration::Static(v) }}
    }
    #[staticmethod]
    fn Dynamic(v: DynamicCssProperty) -> AzCssDeclarationEnumWrapper {
        AzCssDeclarationEnumWrapper { inner: AzCssDeclaration::Dynamic(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssDeclaration;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssDeclaration::Static(v) => Ok(vec!["Static".into_py(py), v.into_py(py)]),
            AzCssDeclaration::Dynamic(v) => Ok(vec!["Dynamic".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssDeclarationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssDeclaration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssDeclaration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDynamicCssProperty {
}

#[pyproto]
impl PyObjectProtocol for AzDynamicCssProperty {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::DynamicCssProperty = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::DynamicCssProperty = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAnimationInterpolationFunctionEnumWrapper {
    #[classattr]
    fn Ease() -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::Ease }
    }
    #[classattr]
    fn Linear() -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::Linear }
    }
    #[classattr]
    fn EaseIn() -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::EaseIn }
    }
    #[classattr]
    fn EaseOut() -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::EaseOut }
    }
    #[classattr]
    fn EaseInOut() -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::EaseInOut }
    }
    #[staticmethod]
    fn CubicBezier(v: SvgCubicCurve) -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper { inner: AzAnimationInterpolationFunction::CubicBezier(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzAnimationInterpolationFunction;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAnimationInterpolationFunction::Ease => Ok(vec!["Ease".into_py(py), ().into_py(py)]),
            AzAnimationInterpolationFunction::Linear => Ok(vec!["Linear".into_py(py), ().into_py(py)]),
            AzAnimationInterpolationFunction::EaseIn => Ok(vec!["EaseIn".into_py(py), ().into_py(py)]),
            AzAnimationInterpolationFunction::EaseOut => Ok(vec!["EaseOut".into_py(py), ().into_py(py)]),
            AzAnimationInterpolationFunction::EaseInOut => Ok(vec!["EaseInOut".into_py(py), ().into_py(py)]),
            AzAnimationInterpolationFunction::CubicBezier(v) => Ok(vec!["CubicBezier".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAnimationInterpolationFunctionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::AnimationInterpolationFunction = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::AnimationInterpolationFunction = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorU {
    #[staticmethod]
    fn from_str(/* args */) -> AzColorU {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn transparent(/* args */) -> AzColorU {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn white(/* args */) -> AzColorU {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn black(/* args */) -> AzColorU {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn to_hash(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzColorU {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::color::ColorU = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::color::ColorU = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSizeMetricEnumWrapper {
    #[classattr]
    const Px: AzSizeMetric = AzSizeMetric::Px;
    #[classattr]
    const Pt: AzSizeMetric = AzSizeMetric::Pt;
    #[classattr]
    const Em: AzSizeMetric = AzSizeMetric::Em;
    #[classattr]
    const Rem: AzSizeMetric = AzSizeMetric::Rem;
    #[classattr]
    const In: AzSizeMetric = AzSizeMetric::In;
    #[classattr]
    const Cm: AzSizeMetric = AzSizeMetric::Cm;
    #[classattr]
    const Mm: AzSizeMetric = AzSizeMetric::Mm;
    #[classattr]
    const Percent: AzSizeMetric = AzSizeMetric::Percent;
    #[classattr]
    const Vw: AzSizeMetric = AzSizeMetric::Vw;
    #[classattr]
    const Vh: AzSizeMetric = AzSizeMetric::Vh;
    #[classattr]
    const Vmin: AzSizeMetric = AzSizeMetric::Vmin;
    #[classattr]
    const Vmax: AzSizeMetric = AzSizeMetric::Vmax;
}

#[pyproto]
impl PyObjectProtocol for AzSizeMetricEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::length::SizeMetric = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::length::SizeMetric = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzSizeMetricEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzPixelValue {
}

#[pyproto]
impl PyObjectProtocol for AzPixelValue {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::pixel::PixelValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::pixel::PixelValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPixelValueNoPercent {
}

#[pyproto]
impl PyObjectProtocol for AzPixelValueNoPercent {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::pixel::PixelValueNoPercent = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::pixel::PixelValueNoPercent = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBoxShadowClipModeEnumWrapper {
    #[classattr]
    const Outset: AzBoxShadowClipMode = AzBoxShadowClipMode::Outset;
    #[classattr]
    const Inset: AzBoxShadowClipMode = AzBoxShadowClipMode::Inset;
}

#[pyproto]
impl PyObjectProtocol for AzBoxShadowClipModeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::box_shadow::BoxShadowClipMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::box_shadow::BoxShadowClipMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzBoxShadowClipModeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleBoxShadow {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBoxShadow {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::box_shadow::StyleBoxShadow = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::box_shadow::StyleBoxShadow = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleMixBlendModeEnumWrapper {
    #[classattr]
    const Normal: AzStyleMixBlendMode = AzStyleMixBlendMode::Normal;
    #[classattr]
    const Multiply: AzStyleMixBlendMode = AzStyleMixBlendMode::Multiply;
    #[classattr]
    const Screen: AzStyleMixBlendMode = AzStyleMixBlendMode::Screen;
    #[classattr]
    const Overlay: AzStyleMixBlendMode = AzStyleMixBlendMode::Overlay;
    #[classattr]
    const Darken: AzStyleMixBlendMode = AzStyleMixBlendMode::Darken;
    #[classattr]
    const Lighten: AzStyleMixBlendMode = AzStyleMixBlendMode::Lighten;
    #[classattr]
    const ColorDodge: AzStyleMixBlendMode = AzStyleMixBlendMode::ColorDodge;
    #[classattr]
    const ColorBurn: AzStyleMixBlendMode = AzStyleMixBlendMode::ColorBurn;
    #[classattr]
    const HardLight: AzStyleMixBlendMode = AzStyleMixBlendMode::HardLight;
    #[classattr]
    const SoftLight: AzStyleMixBlendMode = AzStyleMixBlendMode::SoftLight;
    #[classattr]
    const Difference: AzStyleMixBlendMode = AzStyleMixBlendMode::Difference;
    #[classattr]
    const Exclusion: AzStyleMixBlendMode = AzStyleMixBlendMode::Exclusion;
    #[classattr]
    const Hue: AzStyleMixBlendMode = AzStyleMixBlendMode::Hue;
    #[classattr]
    const Saturation: AzStyleMixBlendMode = AzStyleMixBlendMode::Saturation;
    #[classattr]
    const Color: AzStyleMixBlendMode = AzStyleMixBlendMode::Color;
    #[classattr]
    const Luminosity: AzStyleMixBlendMode = AzStyleMixBlendMode::Luminosity;
}

#[pyproto]
impl PyObjectProtocol for AzStyleMixBlendModeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::effects::StyleMixBlendMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::effects::StyleMixBlendMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleMixBlendModeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleFilterEnumWrapper {
    #[staticmethod]
    fn Blend(v: StyleMixBlendMode) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::Blend(v) }}
    }
    #[staticmethod]
    fn Flood(v: ColorU) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::Flood(v) }}
    }
    #[staticmethod]
    fn Blur(v: StyleBlur) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::Blur(v) }}
    }
    #[staticmethod]
    fn Opacity(v: PercentageValue) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::Opacity(v) }}
    }
    #[staticmethod]
    fn ColorMatrix(v: StyleColorMatrix) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::ColorMatrix(v) }}
    }
    #[staticmethod]
    fn DropShadow(v: StyleBoxShadow) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::DropShadow(v) }}
    }
    #[classattr]
    fn ComponentTransfer() -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::ComponentTransfer }
    }
    #[staticmethod]
    fn Offset(v: StyleFilterOffset) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::Offset(v) }}
    }
    #[staticmethod]
    fn Composite(v: StyleCompositeFilter) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper { inner: AzStyleFilter::Composite(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleFilter;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFilter::Blend(v) => Ok(vec!["Blend".into_py(py), v.into_py(py)]),
            AzStyleFilter::Flood(v) => Ok(vec!["Flood".into_py(py), v.into_py(py)]),
            AzStyleFilter::Blur(v) => Ok(vec!["Blur".into_py(py), v.into_py(py)]),
            AzStyleFilter::Opacity(v) => Ok(vec!["Opacity".into_py(py), v.into_py(py)]),
            AzStyleFilter::ColorMatrix(v) => Ok(vec!["ColorMatrix".into_py(py), v.into_py(py)]),
            AzStyleFilter::DropShadow(v) => Ok(vec!["DropShadow".into_py(py), v.into_py(py)]),
            AzStyleFilter::ComponentTransfer => Ok(vec!["ComponentTransfer".into_py(py), ().into_py(py)]),
            AzStyleFilter::Offset(v) => Ok(vec!["Offset".into_py(py), v.into_py(py)]),
            AzStyleFilter::Composite(v) => Ok(vec!["Composite".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBlur {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBlur {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleBlur = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleBlur = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleColorMatrix {
}

#[pyproto]
impl PyObjectProtocol for AzStyleColorMatrix {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleColorMatrix = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleColorMatrix = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFilterOffset {
}

#[pyproto]
impl PyObjectProtocol for AzStyleFilterOffset {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleFilterOffset = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleFilterOffset = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleCompositeFilterEnumWrapper {
    #[classattr]
    fn Over() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper { inner: AzStyleCompositeFilter::Over }
    }
    #[classattr]
    fn In() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper { inner: AzStyleCompositeFilter::In }
    }
    #[classattr]
    fn Atop() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper { inner: AzStyleCompositeFilter::Atop }
    }
    #[classattr]
    fn Out() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper { inner: AzStyleCompositeFilter::Out }
    }
    #[classattr]
    fn Xor() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper { inner: AzStyleCompositeFilter::Xor }
    }
    #[classattr]
    fn Lighter() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper { inner: AzStyleCompositeFilter::Lighter }
    }
    #[staticmethod]
    fn Arithmetic(v: [FloatValue) -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper { inner: AzStyleCompositeFilter::Arithmetic(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleCompositeFilter;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleCompositeFilter::Over => Ok(vec!["Over".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::In => Ok(vec!["In".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::Atop => Ok(vec!["Atop".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::Out => Ok(vec!["Out".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::Xor => Ok(vec!["Xor".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::Lighter => Ok(vec!["Lighter".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::Arithmetic(v) => Ok(vec!["Arithmetic".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleCompositeFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleCompositeFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleCompositeFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutAlignContentEnumWrapper {
    #[classattr]
    const Stretch: AzLayoutAlignContent = AzLayoutAlignContent::Stretch;
    #[classattr]
    const Center: AzLayoutAlignContent = AzLayoutAlignContent::Center;
    #[classattr]
    const Start: AzLayoutAlignContent = AzLayoutAlignContent::Start;
    #[classattr]
    const End: AzLayoutAlignContent = AzLayoutAlignContent::End;
    #[classattr]
    const SpaceBetween: AzLayoutAlignContent = AzLayoutAlignContent::SpaceBetween;
    #[classattr]
    const SpaceAround: AzLayoutAlignContent = AzLayoutAlignContent::SpaceAround;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutAlignContentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutAlignContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutAlignContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutAlignContentEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutAlignItemsEnumWrapper {
    #[classattr]
    const Stretch: AzLayoutAlignItems = AzLayoutAlignItems::Stretch;
    #[classattr]
    const Center: AzLayoutAlignItems = AzLayoutAlignItems::Center;
    #[classattr]
    const Start: AzLayoutAlignItems = AzLayoutAlignItems::Start;
    #[classattr]
    const End: AzLayoutAlignItems = AzLayoutAlignItems::End;
    #[classattr]
    const Baseline: AzLayoutAlignItems = AzLayoutAlignItems::Baseline;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutAlignItemsEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutAlignItems = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutAlignItems = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutAlignItemsEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutBottom {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBottom {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::position::LayoutBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::position::LayoutBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBoxSizingEnumWrapper {
    #[classattr]
    const ContentBox: AzLayoutBoxSizing = AzLayoutBoxSizing::ContentBox;
    #[classattr]
    const BorderBox: AzLayoutBoxSizing = AzLayoutBoxSizing::BorderBox;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBoxSizingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutBoxSizing = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutBoxSizing = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutBoxSizingEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutFlexDirectionEnumWrapper {
    #[classattr]
    const Row: AzLayoutFlexDirection = AzLayoutFlexDirection::Row;
    #[classattr]
    const RowReverse: AzLayoutFlexDirection = AzLayoutFlexDirection::RowReverse;
    #[classattr]
    const Column: AzLayoutFlexDirection = AzLayoutFlexDirection::Column;
    #[classattr]
    const ColumnReverse: AzLayoutFlexDirection = AzLayoutFlexDirection::ColumnReverse;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexDirectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexDirection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexDirection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutFlexDirectionEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutDisplayEnumWrapper {
    #[classattr]
    const None: AzLayoutDisplay = AzLayoutDisplay::None;
    #[classattr]
    const Block: AzLayoutDisplay = AzLayoutDisplay::Block;
    #[classattr]
    const Inline: AzLayoutDisplay = AzLayoutDisplay::Inline;
    #[classattr]
    const InlineBlock: AzLayoutDisplay = AzLayoutDisplay::InlineBlock;
    #[classattr]
    const Flex: AzLayoutDisplay = AzLayoutDisplay::Flex;
    #[classattr]
    const InlineFlex: AzLayoutDisplay = AzLayoutDisplay::InlineFlex;
    #[classattr]
    const Table: AzLayoutDisplay = AzLayoutDisplay::Table;
    #[classattr]
    const InlineTable: AzLayoutDisplay = AzLayoutDisplay::InlineTable;
    #[classattr]
    const TableRowGroup: AzLayoutDisplay = AzLayoutDisplay::TableRowGroup;
    #[classattr]
    const TableHeaderGroup: AzLayoutDisplay = AzLayoutDisplay::TableHeaderGroup;
    #[classattr]
    const TableFooterGroup: AzLayoutDisplay = AzLayoutDisplay::TableFooterGroup;
    #[classattr]
    const TableRow: AzLayoutDisplay = AzLayoutDisplay::TableRow;
    #[classattr]
    const TableColumnGroup: AzLayoutDisplay = AzLayoutDisplay::TableColumnGroup;
    #[classattr]
    const TableColumn: AzLayoutDisplay = AzLayoutDisplay::TableColumn;
    #[classattr]
    const TableCell: AzLayoutDisplay = AzLayoutDisplay::TableCell;
    #[classattr]
    const TableCaption: AzLayoutDisplay = AzLayoutDisplay::TableCaption;
    #[classattr]
    const FlowRoot: AzLayoutDisplay = AzLayoutDisplay::FlowRoot;
    #[classattr]
    const ListItem: AzLayoutDisplay = AzLayoutDisplay::ListItem;
    #[classattr]
    const RunIn: AzLayoutDisplay = AzLayoutDisplay::RunIn;
    #[classattr]
    const Marker: AzLayoutDisplay = AzLayoutDisplay::Marker;
    #[classattr]
    const Grid: AzLayoutDisplay = AzLayoutDisplay::Grid;
    #[classattr]
    const InlineGrid: AzLayoutDisplay = AzLayoutDisplay::InlineGrid;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutDisplayEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::display::LayoutDisplay = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::display::LayoutDisplay = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutDisplayEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutFlexGrow {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexGrow {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexGrow = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexGrow = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexShrink {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexShrink {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexShrink = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexShrink = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFloatEnumWrapper {
    #[classattr]
    const Left: AzLayoutFloat = AzLayoutFloat::Left;
    #[classattr]
    const Right: AzLayoutFloat = AzLayoutFloat::Right;
    #[classattr]
    const None: AzLayoutFloat = AzLayoutFloat::None;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFloatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::display::LayoutFloat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::display::LayoutFloat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutFloatEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutHeightEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutHeightEnumWrapper {
        AzLayoutHeightEnumWrapper { inner: AzLayoutHeight::Auto }
    }
    #[staticmethod]
    fn Px(v: PixelValue) -> AzLayoutHeightEnumWrapper {
        AzLayoutHeightEnumWrapper { inner: AzLayoutHeight::Px(v) }}
    }
    #[classattr]
    fn MinContent() -> AzLayoutHeightEnumWrapper {
        AzLayoutHeightEnumWrapper { inner: AzLayoutHeight::MinContent }
    }
    #[classattr]
    fn MaxContent() -> AzLayoutHeightEnumWrapper {
        AzLayoutHeightEnumWrapper { inner: AzLayoutHeight::MaxContent }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutHeight;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutHeight::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutHeight::Px(v) => Ok(vec!["Px".into_py(py), v.into_py(py)]),
            AzLayoutHeight::MinContent => Ok(vec!["MinContent".into_py(py), ().into_py(py)]),
            AzLayoutHeight::MaxContent => Ok(vec!["MaxContent".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutHeightEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutHeight = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutHeight = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutJustifyContentEnumWrapper {
    #[classattr]
    const FlexStart: AzLayoutJustifyContent = AzLayoutJustifyContent::FlexStart;
    #[classattr]
    const FlexEnd: AzLayoutJustifyContent = AzLayoutJustifyContent::FlexEnd;
    #[classattr]
    const Start: AzLayoutJustifyContent = AzLayoutJustifyContent::Start;
    #[classattr]
    const End: AzLayoutJustifyContent = AzLayoutJustifyContent::End;
    #[classattr]
    const Center: AzLayoutJustifyContent = AzLayoutJustifyContent::Center;
    #[classattr]
    const SpaceBetween: AzLayoutJustifyContent = AzLayoutJustifyContent::SpaceBetween;
    #[classattr]
    const SpaceAround: AzLayoutJustifyContent = AzLayoutJustifyContent::SpaceAround;
    #[classattr]
    const SpaceEvenly: AzLayoutJustifyContent = AzLayoutJustifyContent::SpaceEvenly;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutJustifyContentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutJustifyContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutJustifyContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutJustifyContentEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutLeft {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutLeft {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::position::LayoutLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::position::LayoutLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginBottom {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginBottom {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutMarginBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutMarginBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginLeft {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginLeft {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutMarginLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutMarginLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginRight {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginRight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutMarginRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutMarginRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginTop {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginTop {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutMarginTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutMarginTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMaxHeight {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMaxHeight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutMaxHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutMaxHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMaxWidth {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMaxWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutMaxWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutMaxWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMinHeight {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMinHeight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutMinHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutMinHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMinWidth {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMinWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutMinWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutMinWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingBottom {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingBottom {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutPaddingBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutPaddingBottom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingLeft {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingLeft {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutPaddingLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutPaddingLeft = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingRight {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingRight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutPaddingRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutPaddingRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingTop {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingTop {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutPaddingTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutPaddingTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPositionEnumWrapper {
    #[classattr]
    const Static: AzLayoutPosition = AzLayoutPosition::Static;
    #[classattr]
    const Relative: AzLayoutPosition = AzLayoutPosition::Relative;
    #[classattr]
    const Absolute: AzLayoutPosition = AzLayoutPosition::Absolute;
    #[classattr]
    const Fixed: AzLayoutPosition = AzLayoutPosition::Fixed;
    #[classattr]
    const Sticky: AzLayoutPosition = AzLayoutPosition::Sticky;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::position::LayoutPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::position::LayoutPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutPositionEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutRight {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutRight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::position::LayoutRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::position::LayoutRight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutTop {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutTop {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::position::LayoutTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::position::LayoutTop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutWidthEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutWidthEnumWrapper {
        AzLayoutWidthEnumWrapper { inner: AzLayoutWidth::Auto }
    }
    #[staticmethod]
    fn Px(v: PixelValue) -> AzLayoutWidthEnumWrapper {
        AzLayoutWidthEnumWrapper { inner: AzLayoutWidth::Px(v) }}
    }
    #[classattr]
    fn MinContent() -> AzLayoutWidthEnumWrapper {
        AzLayoutWidthEnumWrapper { inner: AzLayoutWidth::MinContent }
    }
    #[classattr]
    fn MaxContent() -> AzLayoutWidthEnumWrapper {
        AzLayoutWidthEnumWrapper { inner: AzLayoutWidth::MaxContent }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutWidth;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutWidth::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutWidth::Px(v) => Ok(vec!["Px".into_py(py), v.into_py(py)]),
            AzLayoutWidth::MinContent => Ok(vec!["MinContent".into_py(py), ().into_py(py)]),
            AzLayoutWidth::MaxContent => Ok(vec!["MaxContent".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutWidthEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutWidth = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::dimensions::LayoutWidth = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexWrapEnumWrapper {
    #[classattr]
    const Wrap: AzLayoutFlexWrap = AzLayoutFlexWrap::Wrap;
    #[classattr]
    const NoWrap: AzLayoutFlexWrap = AzLayoutFlexWrap::NoWrap;
    #[classattr]
    const WrapReverse: AzLayoutFlexWrap = AzLayoutFlexWrap::WrapReverse;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexWrapEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexWrap = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexWrap = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutFlexWrapEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutOverflowEnumWrapper {
    #[classattr]
    const Scroll: AzLayoutOverflow = AzLayoutOverflow::Scroll;
    #[classattr]
    const Auto: AzLayoutOverflow = AzLayoutOverflow::Auto;
    #[classattr]
    const Hidden: AzLayoutOverflow = AzLayoutOverflow::Hidden;
    #[classattr]
    const Visible: AzLayoutOverflow = AzLayoutOverflow::Visible;
    #[classattr]
    const Clip: AzLayoutOverflow = AzLayoutOverflow::Clip;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutOverflowEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::overflow::LayoutOverflow = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::overflow::LayoutOverflow = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutOverflowEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzFloatValue {
}

#[pyproto]
impl PyObjectProtocol for AzFloatValue {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::length::FloatValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::length::FloatValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPercentageValue {
}

#[pyproto]
impl PyObjectProtocol for AzPercentageValue {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::length::PercentageValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::length::PercentageValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAngleMetricEnumWrapper {
    #[classattr]
    const Degree: AzAngleMetric = AzAngleMetric::Degree;
    #[classattr]
    const Radians: AzAngleMetric = AzAngleMetric::Radians;
    #[classattr]
    const Grad: AzAngleMetric = AzAngleMetric::Grad;
    #[classattr]
    const Turn: AzAngleMetric = AzAngleMetric::Turn;
    #[classattr]
    const Percent: AzAngleMetric = AzAngleMetric::Percent;
}

#[pyproto]
impl PyObjectProtocol for AzAngleMetricEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::angle::AngleMetric = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::angle::AngleMetric = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAngleMetricEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAngleValue {
    fn get_degrees(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzAngleValue {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::angle::AngleValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::angle::AngleValue = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedLinearColorStop {
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedLinearColorStop {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedLinearColorStop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedLinearColorStop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedRadialColorStop {
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedRadialColorStop {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedRadialColorStop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedRadialColorStop = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDirectionCornerEnumWrapper {
    #[classattr]
    const Right: AzDirectionCorner = AzDirectionCorner::Right;
    #[classattr]
    const Left: AzDirectionCorner = AzDirectionCorner::Left;
    #[classattr]
    const Top: AzDirectionCorner = AzDirectionCorner::Top;
    #[classattr]
    const Bottom: AzDirectionCorner = AzDirectionCorner::Bottom;
    #[classattr]
    const TopRight: AzDirectionCorner = AzDirectionCorner::TopRight;
    #[classattr]
    const TopLeft: AzDirectionCorner = AzDirectionCorner::TopLeft;
    #[classattr]
    const BottomRight: AzDirectionCorner = AzDirectionCorner::BottomRight;
    #[classattr]
    const BottomLeft: AzDirectionCorner = AzDirectionCorner::BottomLeft;
}

#[pyproto]
impl PyObjectProtocol for AzDirectionCornerEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::direction::DirectionCorner = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::direction::DirectionCorner = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzDirectionCornerEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzDirectionCorners {
}

#[pyproto]
impl PyObjectProtocol for AzDirectionCorners {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::direction::DirectionCorners = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::direction::DirectionCorners = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDirectionEnumWrapper {
    #[staticmethod]
    fn Angle(v: AngleValue) -> AzDirectionEnumWrapper {
        AzDirectionEnumWrapper { inner: AzDirection::Angle(v) }}
    }
    #[staticmethod]
    fn FromTo(v: DirectionCorners) -> AzDirectionEnumWrapper {
        AzDirectionEnumWrapper { inner: AzDirection::FromTo(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzDirection;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzDirection::Angle(v) => Ok(vec!["Angle".into_py(py), v.into_py(py)]),
            AzDirection::FromTo(v) => Ok(vec!["FromTo".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDirectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::direction::Direction = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::direction::Direction = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLinearGradient {
}

#[pyproto]
impl PyObjectProtocol for AzLinearGradient {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::LinearGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::LinearGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapeEnumWrapper {
    #[classattr]
    const Ellipse: AzShape = AzShape::Ellipse;
    #[classattr]
    const Circle: AzShape = AzShape::Circle;
}

#[pyproto]
impl PyObjectProtocol for AzShapeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::Shape = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::Shape = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzShapeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzRadialGradientSizeEnumWrapper {
    #[classattr]
    const ClosestSide: AzRadialGradientSize = AzRadialGradientSize::ClosestSide;
    #[classattr]
    const ClosestCorner: AzRadialGradientSize = AzRadialGradientSize::ClosestCorner;
    #[classattr]
    const FarthestSide: AzRadialGradientSize = AzRadialGradientSize::FarthestSide;
    #[classattr]
    const FarthestCorner: AzRadialGradientSize = AzRadialGradientSize::FarthestCorner;
}

#[pyproto]
impl PyObjectProtocol for AzRadialGradientSizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::RadialGradientSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::RadialGradientSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzRadialGradientSizeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzRadialGradient {
}

#[pyproto]
impl PyObjectProtocol for AzRadialGradient {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::RadialGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::RadialGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzConicGradient {
}

#[pyproto]
impl PyObjectProtocol for AzConicGradient {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::ConicGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::ConicGradient = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundContentEnumWrapper {
    #[staticmethod]
    fn LinearGradient(v: LinearGradient) -> AzStyleBackgroundContentEnumWrapper {
        AzStyleBackgroundContentEnumWrapper { inner: AzStyleBackgroundContent::LinearGradient(v) }}
    }
    #[staticmethod]
    fn RadialGradient(v: RadialGradient) -> AzStyleBackgroundContentEnumWrapper {
        AzStyleBackgroundContentEnumWrapper { inner: AzStyleBackgroundContent::RadialGradient(v) }}
    }
    #[staticmethod]
    fn ConicGradient(v: ConicGradient) -> AzStyleBackgroundContentEnumWrapper {
        AzStyleBackgroundContentEnumWrapper { inner: AzStyleBackgroundContent::ConicGradient(v) }}
    }
    #[staticmethod]
    fn Image(v: String) -> AzStyleBackgroundContentEnumWrapper {
        AzStyleBackgroundContentEnumWrapper { inner: AzStyleBackgroundContent::Image(v) }}
    }
    #[staticmethod]
    fn Color(v: ColorU) -> AzStyleBackgroundContentEnumWrapper {
        AzStyleBackgroundContentEnumWrapper { inner: AzStyleBackgroundContent::Color(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundContent;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundContent::LinearGradient(v) => Ok(vec!["LinearGradient".into_py(py), v.into_py(py)]),
            AzStyleBackgroundContent::RadialGradient(v) => Ok(vec!["RadialGradient".into_py(py), v.into_py(py)]),
            AzStyleBackgroundContent::ConicGradient(v) => Ok(vec!["ConicGradient".into_py(py), v.into_py(py)]),
            AzStyleBackgroundContent::Image(v) => Ok(vec!["Image".into_py(py), v.into_py(py)]),
            AzStyleBackgroundContent::Color(v) => Ok(vec!["Color".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundContentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundContent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBackgroundPositionHorizontalEnumWrapper {
    #[classattr]
    fn Left() -> AzBackgroundPositionHorizontalEnumWrapper {
        AzBackgroundPositionHorizontalEnumWrapper { inner: AzBackgroundPositionHorizontal::Left }
    }
    #[classattr]
    fn Center() -> AzBackgroundPositionHorizontalEnumWrapper {
        AzBackgroundPositionHorizontalEnumWrapper { inner: AzBackgroundPositionHorizontal::Center }
    }
    #[classattr]
    fn Right() -> AzBackgroundPositionHorizontalEnumWrapper {
        AzBackgroundPositionHorizontalEnumWrapper { inner: AzBackgroundPositionHorizontal::Right }
    }
    #[staticmethod]
    fn Exact(v: PixelValue) -> AzBackgroundPositionHorizontalEnumWrapper {
        AzBackgroundPositionHorizontalEnumWrapper { inner: AzBackgroundPositionHorizontal::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzBackgroundPositionHorizontal;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzBackgroundPositionHorizontal::Left => Ok(vec!["Left".into_py(py), ().into_py(py)]),
            AzBackgroundPositionHorizontal::Center => Ok(vec!["Center".into_py(py), ().into_py(py)]),
            AzBackgroundPositionHorizontal::Right => Ok(vec!["Right".into_py(py), ().into_py(py)]),
            AzBackgroundPositionHorizontal::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzBackgroundPositionHorizontalEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::BackgroundPositionHorizontal = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::BackgroundPositionHorizontal = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBackgroundPositionVerticalEnumWrapper {
    #[classattr]
    fn Top() -> AzBackgroundPositionVerticalEnumWrapper {
        AzBackgroundPositionVerticalEnumWrapper { inner: AzBackgroundPositionVertical::Top }
    }
    #[classattr]
    fn Center() -> AzBackgroundPositionVerticalEnumWrapper {
        AzBackgroundPositionVerticalEnumWrapper { inner: AzBackgroundPositionVertical::Center }
    }
    #[classattr]
    fn Bottom() -> AzBackgroundPositionVerticalEnumWrapper {
        AzBackgroundPositionVerticalEnumWrapper { inner: AzBackgroundPositionVertical::Bottom }
    }
    #[staticmethod]
    fn Exact(v: PixelValue) -> AzBackgroundPositionVerticalEnumWrapper {
        AzBackgroundPositionVerticalEnumWrapper { inner: AzBackgroundPositionVertical::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzBackgroundPositionVertical;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzBackgroundPositionVertical::Top => Ok(vec!["Top".into_py(py), ().into_py(py)]),
            AzBackgroundPositionVertical::Center => Ok(vec!["Center".into_py(py), ().into_py(py)]),
            AzBackgroundPositionVertical::Bottom => Ok(vec!["Bottom".into_py(py), ().into_py(py)]),
            AzBackgroundPositionVertical::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzBackgroundPositionVerticalEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::BackgroundPositionVertical = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::BackgroundPositionVertical = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundPosition {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundPosition {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundPosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundPosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundRepeatEnumWrapper {
    #[classattr]
    const NoRepeat: AzStyleBackgroundRepeat = AzStyleBackgroundRepeat::NoRepeat;
    #[classattr]
    const Repeat: AzStyleBackgroundRepeat = AzStyleBackgroundRepeat::Repeat;
    #[classattr]
    const RepeatX: AzStyleBackgroundRepeat = AzStyleBackgroundRepeat::RepeatX;
    #[classattr]
    const RepeatY: AzStyleBackgroundRepeat = AzStyleBackgroundRepeat::RepeatY;
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundRepeatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundRepeat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundRepeat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleBackgroundRepeatEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleBackgroundSizeEnumWrapper {
    #[staticmethod]
    fn ExactSize(v: [PixelValue) -> AzStyleBackgroundSizeEnumWrapper {
        AzStyleBackgroundSizeEnumWrapper { inner: AzStyleBackgroundSize::ExactSize(v) }}
    }
    #[classattr]
    fn Contain() -> AzStyleBackgroundSizeEnumWrapper {
        AzStyleBackgroundSizeEnumWrapper { inner: AzStyleBackgroundSize::Contain }
    }
    #[classattr]
    fn Cover() -> AzStyleBackgroundSizeEnumWrapper {
        AzStyleBackgroundSizeEnumWrapper { inner: AzStyleBackgroundSize::Cover }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundSize;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundSize::ExactSize(v) => Ok(vec!["ExactSize".into_py(py), v.into_py(py)]),
            AzStyleBackgroundSize::Contain => Ok(vec!["Contain".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSize::Cover => Ok(vec!["Cover".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundSizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomColor {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::StyleBorderBottomColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::StyleBorderBottomColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomLeftRadius {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomLeftRadius {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border_radius::StyleBorderBottomLeftRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border_radius::StyleBorderBottomLeftRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomRightRadius {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomRightRadius {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border_radius::StyleBorderBottomRightRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border_radius::StyleBorderBottomRightRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBorderStyleEnumWrapper {
    #[classattr]
    const None: AzBorderStyle = AzBorderStyle::None;
    #[classattr]
    const Solid: AzBorderStyle = AzBorderStyle::Solid;
    #[classattr]
    const Double: AzBorderStyle = AzBorderStyle::Double;
    #[classattr]
    const Dotted: AzBorderStyle = AzBorderStyle::Dotted;
    #[classattr]
    const Dashed: AzBorderStyle = AzBorderStyle::Dashed;
    #[classattr]
    const Hidden: AzBorderStyle = AzBorderStyle::Hidden;
    #[classattr]
    const Groove: AzBorderStyle = AzBorderStyle::Groove;
    #[classattr]
    const Ridge: AzBorderStyle = AzBorderStyle::Ridge;
    #[classattr]
    const Inset: AzBorderStyle = AzBorderStyle::Inset;
    #[classattr]
    const Outset: AzBorderStyle = AzBorderStyle::Outset;
}

#[pyproto]
impl PyObjectProtocol for AzBorderStyleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::BorderStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::BorderStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzBorderStyleEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleBorderBottomStyle {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::StyleBorderBottomStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::StyleBorderBottomStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderBottomWidth {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderBottomWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::LayoutBorderBottomWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::LayoutBorderBottomWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderLeftColor {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderLeftColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::StyleBorderLeftColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::StyleBorderLeftColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderLeftStyle {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderLeftStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::StyleBorderLeftStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::StyleBorderLeftStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderLeftWidth {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderLeftWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::LayoutBorderLeftWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::LayoutBorderLeftWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderRightColor {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderRightColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::StyleBorderRightColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::StyleBorderRightColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderRightStyle {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderRightStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::StyleBorderRightStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::StyleBorderRightStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderRightWidth {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderRightWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::LayoutBorderRightWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::LayoutBorderRightWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopColor {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::StyleBorderTopColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::StyleBorderTopColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopLeftRadius {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopLeftRadius {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border_radius::StyleBorderTopLeftRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border_radius::StyleBorderTopLeftRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopRightRadius {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopRightRadius {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border_radius::StyleBorderTopRightRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border_radius::StyleBorderTopRightRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopStyle {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::StyleBorderTopStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::StyleBorderTopStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderTopWidth {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderTopWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::LayoutBorderTopWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::border::LayoutBorderTopWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScrollbarInfo {
}

#[pyproto]
impl PyObjectProtocol for AzScrollbarInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::ScrollbarInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::ScrollbarInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScrollbarStyle {
}

#[pyproto]
impl PyObjectProtocol for AzScrollbarStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::ScrollbarStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::ScrollbarStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontFamilyEnumWrapper {
    #[staticmethod]
    fn System(v: String) -> AzStyleFontFamilyEnumWrapper {
        AzStyleFontFamilyEnumWrapper { inner: AzStyleFontFamily::System(v) }}
    }
    #[staticmethod]
    fn File(v: String) -> AzStyleFontFamilyEnumWrapper {
        AzStyleFontFamilyEnumWrapper { inner: AzStyleFontFamily::File(v) }}
    }
    #[staticmethod]
    fn Ref(v: FontRef) -> AzStyleFontFamilyEnumWrapper {
        AzStyleFontFamilyEnumWrapper { inner: AzStyleFontFamily::Ref(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleFontFamily;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFontFamily::System(v) => Ok(vec!["System".into_py(py), v.into_py(py)]),
            AzStyleFontFamily::File(v) => Ok(vec!["File".into_py(py), v.into_py(py)]),
            AzStyleFontFamily::Ref(v) => Ok(vec!["Ref".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontFamilyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontFamily = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontFamily = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontSize {
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontSize {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleLetterSpacing {
}

#[pyproto]
impl PyObjectProtocol for AzStyleLetterSpacing {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleLetterSpacing = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleLetterSpacing = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleLineHeight {
}

#[pyproto]
impl PyObjectProtocol for AzStyleLineHeight {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleLineHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleLineHeight = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTabWidth {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTabWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTabWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTabWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleOpacity {
}

#[pyproto]
impl PyObjectProtocol for AzStyleOpacity {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::effects::StyleOpacity = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::effects::StyleOpacity = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformOrigin {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformOrigin {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformOrigin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformOrigin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackfaceVisibilityEnumWrapper {
    #[classattr]
    const Visible: AzStyleBackfaceVisibility = AzStyleBackfaceVisibility::Visible;
    #[classattr]
    const Hidden: AzStyleBackfaceVisibility = AzStyleBackfaceVisibility::Hidden;
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackfaceVisibilityEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleBackfaceVisibility = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleBackfaceVisibility = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleBackfaceVisibilityEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleTransformEnumWrapper {
    #[staticmethod]
    fn Matrix(v: StyleTransformMatrix2D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Matrix(v) }}
    }
    #[staticmethod]
    fn Matrix3D(v: StyleTransformMatrix3D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Matrix3D(v) }}
    }
    #[staticmethod]
    fn Translate(v: StyleTransformTranslate2D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Translate(v) }}
    }
    #[staticmethod]
    fn Translate3D(v: StyleTransformTranslate3D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Translate3D(v) }}
    }
    #[staticmethod]
    fn TranslateX(v: PixelValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::TranslateX(v) }}
    }
    #[staticmethod]
    fn TranslateY(v: PixelValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::TranslateY(v) }}
    }
    #[staticmethod]
    fn TranslateZ(v: PixelValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::TranslateZ(v) }}
    }
    #[staticmethod]
    fn Rotate(v: AngleValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Rotate(v) }}
    }
    #[staticmethod]
    fn Rotate3D(v: StyleTransformRotate3D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Rotate3D(v) }}
    }
    #[staticmethod]
    fn RotateX(v: AngleValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::RotateX(v) }}
    }
    #[staticmethod]
    fn RotateY(v: AngleValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::RotateY(v) }}
    }
    #[staticmethod]
    fn RotateZ(v: AngleValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::RotateZ(v) }}
    }
    #[staticmethod]
    fn Scale(v: StyleTransformScale2D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Scale(v) }}
    }
    #[staticmethod]
    fn Scale3D(v: StyleTransformScale3D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Scale3D(v) }}
    }
    #[staticmethod]
    fn ScaleX(v: PercentageValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::ScaleX(v) }}
    }
    #[staticmethod]
    fn ScaleY(v: PercentageValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::ScaleY(v) }}
    }
    #[staticmethod]
    fn ScaleZ(v: PercentageValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::ScaleZ(v) }}
    }
    #[staticmethod]
    fn Skew(v: StyleTransformSkew2D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Skew(v) }}
    }
    #[staticmethod]
    fn SkewX(v: AngleValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::SkewX(v) }}
    }
    #[staticmethod]
    fn SkewY(v: AngleValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::SkewY(v) }}
    }
    #[staticmethod]
    fn Perspective(v: PixelValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper { inner: AzStyleTransform::Perspective(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTransform;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTransform::Matrix(v) => Ok(vec!["Matrix".into_py(py), v.into_py(py)]),
            AzStyleTransform::Matrix3D(v) => Ok(vec!["Matrix3D".into_py(py), v.into_py(py)]),
            AzStyleTransform::Translate(v) => Ok(vec!["Translate".into_py(py), v.into_py(py)]),
            AzStyleTransform::Translate3D(v) => Ok(vec!["Translate3D".into_py(py), v.into_py(py)]),
            AzStyleTransform::TranslateX(v) => Ok(vec!["TranslateX".into_py(py), v.into_py(py)]),
            AzStyleTransform::TranslateY(v) => Ok(vec!["TranslateY".into_py(py), v.into_py(py)]),
            AzStyleTransform::TranslateZ(v) => Ok(vec!["TranslateZ".into_py(py), v.into_py(py)]),
            AzStyleTransform::Rotate(v) => Ok(vec!["Rotate".into_py(py), v.into_py(py)]),
            AzStyleTransform::Rotate3D(v) => Ok(vec!["Rotate3D".into_py(py), v.into_py(py)]),
            AzStyleTransform::RotateX(v) => Ok(vec!["RotateX".into_py(py), v.into_py(py)]),
            AzStyleTransform::RotateY(v) => Ok(vec!["RotateY".into_py(py), v.into_py(py)]),
            AzStyleTransform::RotateZ(v) => Ok(vec!["RotateZ".into_py(py), v.into_py(py)]),
            AzStyleTransform::Scale(v) => Ok(vec!["Scale".into_py(py), v.into_py(py)]),
            AzStyleTransform::Scale3D(v) => Ok(vec!["Scale3D".into_py(py), v.into_py(py)]),
            AzStyleTransform::ScaleX(v) => Ok(vec!["ScaleX".into_py(py), v.into_py(py)]),
            AzStyleTransform::ScaleY(v) => Ok(vec!["ScaleY".into_py(py), v.into_py(py)]),
            AzStyleTransform::ScaleZ(v) => Ok(vec!["ScaleZ".into_py(py), v.into_py(py)]),
            AzStyleTransform::Skew(v) => Ok(vec!["Skew".into_py(py), v.into_py(py)]),
            AzStyleTransform::SkewX(v) => Ok(vec!["SkewX".into_py(py), v.into_py(py)]),
            AzStyleTransform::SkewY(v) => Ok(vec!["SkewY".into_py(py), v.into_py(py)]),
            AzStyleTransform::Perspective(v) => Ok(vec!["Perspective".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransform = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransform = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformMatrix2D {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformMatrix2D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformMatrix2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformMatrix2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformMatrix3D {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformMatrix3D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformMatrix3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformMatrix3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformTranslate2D {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformTranslate2D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformTranslate2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformTranslate2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformTranslate3D {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformTranslate3D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformTranslate3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformTranslate3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformRotate3D {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformRotate3D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformRotate3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformRotate3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformScale2D {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformScale2D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformScale2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformScale2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformScale3D {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformScale3D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformScale3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformScale3D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformSkew2D {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformSkew2D {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformSkew2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformSkew2D = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTextAlignEnumWrapper {
    #[classattr]
    const Left: AzStyleTextAlign = AzStyleTextAlign::Left;
    #[classattr]
    const Center: AzStyleTextAlign = AzStyleTextAlign::Center;
    #[classattr]
    const Right: AzStyleTextAlign = AzStyleTextAlign::Right;
    #[classattr]
    const Justify: AzStyleTextAlign = AzStyleTextAlign::Justify;
    #[classattr]
    const Start: AzStyleTextAlign = AzStyleTextAlign::Start;
    #[classattr]
    const End: AzStyleTextAlign = AzStyleTextAlign::End;
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextAlignEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTextAlign = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTextAlign = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleTextAlignEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleTextColor {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTextColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTextColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleWordSpacing {
}

#[pyproto]
impl PyObjectProtocol for AzStyleWordSpacing {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleWordSpacing = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleWordSpacing = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzCssPropertyValueEnumWrapper {
        AzCssPropertyValueEnumWrapper { inner: AzCssPropertyValue::Auto }
    }
    #[classattr]
    fn None() -> AzCssPropertyValueEnumWrapper {
        AzCssPropertyValueEnumWrapper { inner: AzCssPropertyValue::None }
    }
    #[classattr]
    fn Initial() -> AzCssPropertyValueEnumWrapper {
        AzCssPropertyValueEnumWrapper { inner: AzCssPropertyValue::Initial }
    }
    #[classattr]
    fn Inherit() -> AzCssPropertyValueEnumWrapper {
        AzCssPropertyValueEnumWrapper { inner: AzCssPropertyValue::Inherit }
    }
    #[classattr]
    fn Revert() -> AzCssPropertyValueEnumWrapper {
        AzCssPropertyValueEnumWrapper { inner: AzCssPropertyValue::Revert }
    }
    #[classattr]
    fn Unset() -> AzCssPropertyValueEnumWrapper {
        AzCssPropertyValueEnumWrapper { inner: AzCssPropertyValue::Unset }
    }
    #[staticmethod]

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssPropertyValue;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPropertyValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzCssPropertyValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzCssPropertyValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzCssPropertyValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzCssPropertyValue::Revert => Ok(vec!["Revert".into_py(py), ().into_py(py)]),
            AzCssPropertyValue::Unset => Ok(vec!["Unset".into_py(py), ().into_py(py)]),
            AzCssPropertyValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPropertyValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPropertyValue = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCounterReset {
}

#[pyproto]
impl PyObjectProtocol for AzCounterReset {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::content::CounterReset = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::content::CounterReset = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGridLineEnumWrapper {
    #[classattr]
    fn Auto() -> AzGridLineEnumWrapper {
        AzGridLineEnumWrapper { inner: AzGridLine::Auto }
    }
    #[staticmethod]
    fn Line(v: i32) -> AzGridLineEnumWrapper {
        AzGridLineEnumWrapper { inner: AzGridLine::Line(v) }}
    }
    #[staticmethod]
    fn Named(v: NamedGridLine) -> AzGridLineEnumWrapper {
        AzGridLineEnumWrapper { inner: AzGridLine::Named(v) }}
    }
    #[staticmethod]
    fn Span(v: i32) -> AzGridLineEnumWrapper {
        AzGridLineEnumWrapper { inner: AzGridLine::Span(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzGridLine;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzGridLine::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzGridLine::Line(v) => Ok(vec!["Line".into_py(py), v.into_py(py)]),
            AzGridLine::Named(v) => Ok(vec!["Named".into_py(py), v.into_py(py)]),
            AzGridLine::Span(v) => Ok(vec!["Span".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGridLineEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridLine = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridLine = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylePerspectiveOrigin {
}

#[pyproto]
impl PyObjectProtocol for AzStylePerspectiveOrigin {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StylePerspectiveOrigin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StylePerspectiveOrigin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutZIndexEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutZIndexEnumWrapper {
        AzLayoutZIndexEnumWrapper { inner: AzLayoutZIndex::Auto }
    }
    #[staticmethod]
    fn Integer(v: i32) -> AzLayoutZIndexEnumWrapper {
        AzLayoutZIndexEnumWrapper { inner: AzLayoutZIndex::Integer(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutZIndex;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutZIndex::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutZIndex::Integer(v) => Ok(vec!["Integer".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutZIndexEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::position::LayoutZIndex = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::position::LayoutZIndex = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutJustifyItemsEnumWrapper {
    #[classattr]
    const Start: AzLayoutJustifyItems = AzLayoutJustifyItems::Start;
    #[classattr]
    const End: AzLayoutJustifyItems = AzLayoutJustifyItems::End;
    #[classattr]
    const Center: AzLayoutJustifyItems = AzLayoutJustifyItems::Center;
    #[classattr]
    const Stretch: AzLayoutJustifyItems = AzLayoutJustifyItems::Stretch;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutJustifyItemsEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::LayoutJustifyItems = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::LayoutJustifyItems = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutJustifyItemsEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSelectionBackgroundColor {
}

#[pyproto]
impl PyObjectProtocol for AzSelectionBackgroundColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::selection::SelectionBackgroundColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::selection::SelectionBackgroundColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColumnRuleColor {
}

#[pyproto]
impl PyObjectProtocol for AzColumnRuleColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnRuleColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnRuleColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColumnSpanEnumWrapper {
    #[classattr]
    const None: AzColumnSpan = AzColumnSpan::None;
    #[classattr]
    const All: AzColumnSpan = AzColumnSpan::All;
}

#[pyproto]
impl PyObjectProtocol for AzColumnSpanEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnSpan = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnSpan = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzColumnSpanEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutClearEnumWrapper {
    #[classattr]
    const None: AzLayoutClear = AzLayoutClear::None;
    #[classattr]
    const Left: AzLayoutClear = AzLayoutClear::Left;
    #[classattr]
    const Right: AzLayoutClear = AzLayoutClear::Right;
    #[classattr]
    const Both: AzLayoutClear = AzLayoutClear::Both;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutClearEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::wrapping::LayoutClear = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::wrapping::LayoutClear = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutClearEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleWhiteSpaceEnumWrapper {
    #[classattr]
    const Normal: AzStyleWhiteSpace = AzStyleWhiteSpace::Normal;
    #[classattr]
    const Pre: AzStyleWhiteSpace = AzStyleWhiteSpace::Pre;
    #[classattr]
    const Nowrap: AzStyleWhiteSpace = AzStyleWhiteSpace::Nowrap;
}

#[pyproto]
impl PyObjectProtocol for AzStyleWhiteSpaceEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleWhiteSpace = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleWhiteSpace = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleWhiteSpaceEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzBreakInsideEnumWrapper {
    #[classattr]
    const Auto: AzBreakInside = AzBreakInside::Auto;
    #[classattr]
    const Avoid: AzBreakInside = AzBreakInside::Avoid;
    #[classattr]
    const AvoidPage: AzBreakInside = AzBreakInside::AvoidPage;
    #[classattr]
    const AvoidColumn: AzBreakInside = AzBreakInside::AvoidColumn;
}

#[pyproto]
impl PyObjectProtocol for AzBreakInsideEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::fragmentation::BreakInside = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::fragmentation::BreakInside = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzBreakInsideEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutAlignSelfEnumWrapper {
    #[classattr]
    const Auto: AzLayoutAlignSelf = AzLayoutAlignSelf::Auto;
    #[classattr]
    const Stretch: AzLayoutAlignSelf = AzLayoutAlignSelf::Stretch;
    #[classattr]
    const Center: AzLayoutAlignSelf = AzLayoutAlignSelf::Center;
    #[classattr]
    const Start: AzLayoutAlignSelf = AzLayoutAlignSelf::Start;
    #[classattr]
    const End: AzLayoutAlignSelf = AzLayoutAlignSelf::End;
    #[classattr]
    const Baseline: AzLayoutAlignSelf = AzLayoutAlignSelf::Baseline;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutAlignSelfEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutAlignSelf = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutAlignSelf = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutAlignSelfEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzCaretAnimationDuration {
}

#[pyproto]
impl PyObjectProtocol for AzCaretAnimationDuration {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::CaretAnimationDuration = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::CaretAnimationDuration = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColumnRuleStyle {
}

#[pyproto]
impl PyObjectProtocol for AzColumnRuleStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnRuleStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnRuleStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGridPlacement {
}

#[pyproto]
impl PyObjectProtocol for AzGridPlacement {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridPlacement = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridPlacement = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapeOutsideEnumWrapper {
    #[classattr]
    fn None() -> AzShapeOutsideEnumWrapper {
        AzShapeOutsideEnumWrapper { inner: AzShapeOutside::None }
    }
    #[staticmethod]
    fn Shape(v: CssShape) -> AzShapeOutsideEnumWrapper {
        AzShapeOutsideEnumWrapper { inner: AzShapeOutside::Shape(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzShapeOutside;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzShapeOutside::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzShapeOutside::Shape(v) => Ok(vec!["Shape".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzShapeOutsideEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::shape::ShapeOutside = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::shape::ShapeOutside = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColumnCountEnumWrapper {
    #[classattr]
    fn Auto() -> AzColumnCountEnumWrapper {
        AzColumnCountEnumWrapper { inner: AzColumnCount::Auto }
    }
    #[staticmethod]
    fn Integer(v: u32) -> AzColumnCountEnumWrapper {
        AzColumnCountEnumWrapper { inner: AzColumnCount::Integer(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzColumnCount;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzColumnCount::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzColumnCount::Integer(v) => Ok(vec!["Integer".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzColumnCountEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnCount = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnCount = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutWritingModeEnumWrapper {
    #[classattr]
    const HorizontalTb: AzLayoutWritingMode = AzLayoutWritingMode::HorizontalTb;
    #[classattr]
    const VerticalRl: AzLayoutWritingMode = AzLayoutWritingMode::VerticalRl;
    #[classattr]
    const VerticalLr: AzLayoutWritingMode = AzLayoutWritingMode::VerticalLr;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutWritingModeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::wrapping::LayoutWritingMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::wrapping::LayoutWritingMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutWritingModeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleUserSelectEnumWrapper {
    #[classattr]
    const Auto: AzStyleUserSelect = AzStyleUserSelect::Auto;
    #[classattr]
    const Text: AzStyleUserSelect = AzStyleUserSelect::Text;
    #[classattr]
    const None: AzStyleUserSelect = AzStyleUserSelect::None;
    #[classattr]
    const All: AzStyleUserSelect = AzStyleUserSelect::All;
}

#[pyproto]
impl PyObjectProtocol for AzStyleUserSelectEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleUserSelect = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleUserSelect = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleUserSelectEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzGridTemplate {
}

#[pyproto]
impl PyObjectProtocol for AzGridTemplate {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridTemplate = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridTemplate = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutJustifySelfEnumWrapper {
    #[classattr]
    const Auto: AzLayoutJustifySelf = AzLayoutJustifySelf::Auto;
    #[classattr]
    const Start: AzLayoutJustifySelf = AzLayoutJustifySelf::Start;
    #[classattr]
    const End: AzLayoutJustifySelf = AzLayoutJustifySelf::End;
    #[classattr]
    const Center: AzLayoutJustifySelf = AzLayoutJustifySelf::Center;
    #[classattr]
    const Stretch: AzLayoutJustifySelf = AzLayoutJustifySelf::Stretch;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutJustifySelfEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::LayoutJustifySelf = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::LayoutJustifySelf = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutJustifySelfEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzContent {
}

#[pyproto]
impl PyObjectProtocol for AzContent {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::content::Content = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::content::Content = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleHyphensEnumWrapper {
    #[classattr]
    const Auto: AzStyleHyphens = AzStyleHyphens::Auto;
    #[classattr]
    const None: AzStyleHyphens = AzStyleHyphens::None;
}

#[pyproto]
impl PyObjectProtocol for AzStyleHyphensEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleHyphens = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleHyphens = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleHyphensEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutGap {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutGap {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::LayoutGap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::LayoutGap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleDirectionEnumWrapper {
    #[classattr]
    const Ltr: AzStyleDirection = AzStyleDirection::Ltr;
    #[classattr]
    const Rtl: AzStyleDirection = AzStyleDirection::Rtl;
}

#[pyproto]
impl PyObjectProtocol for AzStyleDirectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleDirection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleDirection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleDirectionEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutFlexBasisEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFlexBasisEnumWrapper {
        AzLayoutFlexBasisEnumWrapper { inner: AzLayoutFlexBasis::Auto }
    }
    #[staticmethod]
    fn Exact(v: PixelValue) -> AzLayoutFlexBasisEnumWrapper {
        AzLayoutFlexBasisEnumWrapper { inner: AzLayoutFlexBasis::Exact(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzLayoutFlexBasis;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFlexBasis::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFlexBasis::Exact(v) => Ok(vec!["Exact".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexBasisEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexBasis = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flex::LayoutFlexBasis = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapeMargin {
}

#[pyproto]
impl PyObjectProtocol for AzShapeMargin {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::shape::ShapeMargin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::shape::ShapeMargin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutTextJustifyEnumWrapper {
    #[classattr]
    const Auto: AzLayoutTextJustify = AzLayoutTextJustify::Auto;
    #[classattr]
    const None: AzLayoutTextJustify = AzLayoutTextJustify::None;
    #[classattr]
    const InterWord: AzLayoutTextJustify = AzLayoutTextJustify::InterWord;
    #[classattr]
    const InterCharacter: AzLayoutTextJustify = AzLayoutTextJustify::InterCharacter;
    #[classattr]
    const Distribute: AzLayoutTextJustify = AzLayoutTextJustify::Distribute;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutTextJustifyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::text::LayoutTextJustify = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::text::LayoutTextJustify = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutTextJustifyEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzColumnWidthEnumWrapper {
    #[classattr]
    fn Auto() -> AzColumnWidthEnumWrapper {
        AzColumnWidthEnumWrapper { inner: AzColumnWidth::Auto }
    }
    #[staticmethod]
    fn Length(v: PixelValue) -> AzColumnWidthEnumWrapper {
        AzColumnWidthEnumWrapper { inner: AzColumnWidth::Length(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzColumnWidth;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzColumnWidth::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzColumnWidth::Length(v) => Ok(vec!["Length".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzColumnWidthEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnWidth = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnWidth = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCounterIncrement {
}

#[pyproto]
impl PyObjectProtocol for AzCounterIncrement {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::content::CounterIncrement = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::content::CounterIncrement = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBoxDecorationBreakEnumWrapper {
    #[classattr]
    const Slice: AzBoxDecorationBreak = AzBoxDecorationBreak::Slice;
    #[classattr]
    const Clone: AzBoxDecorationBreak = AzBoxDecorationBreak::Clone;
}

#[pyproto]
impl PyObjectProtocol for AzBoxDecorationBreakEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::fragmentation::BoxDecorationBreak = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::fragmentation::BoxDecorationBreak = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzBoxDecorationBreakEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSelectionColor {
}

#[pyproto]
impl PyObjectProtocol for AzSelectionColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::selection::SelectionColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::selection::SelectionColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleVisibilityEnumWrapper {
    #[classattr]
    const Visible: AzStyleVisibility = AzStyleVisibility::Visible;
    #[classattr]
    const Hidden: AzStyleVisibility = AzStyleVisibility::Hidden;
    #[classattr]
    const Collapse: AzStyleVisibility = AzStyleVisibility::Collapse;
}

#[pyproto]
impl PyObjectProtocol for AzStyleVisibilityEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::effects::StyleVisibility = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::effects::StyleVisibility = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleVisibilityEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzShapeImageThreshold {
}

#[pyproto]
impl PyObjectProtocol for AzShapeImageThreshold {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::shape::ShapeImageThreshold = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::shape::ShapeImageThreshold = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutGridAutoFlowEnumWrapper {
    #[classattr]
    const Row: AzLayoutGridAutoFlow = AzLayoutGridAutoFlow::Row;
    #[classattr]
    const Column: AzLayoutGridAutoFlow = AzLayoutGridAutoFlow::Column;
    #[classattr]
    const RowDense: AzLayoutGridAutoFlow = AzLayoutGridAutoFlow::RowDense;
    #[classattr]
    const ColumnDense: AzLayoutGridAutoFlow = AzLayoutGridAutoFlow::ColumnDense;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutGridAutoFlowEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::LayoutGridAutoFlow = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::LayoutGridAutoFlow = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutGridAutoFlowEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzColumnRuleWidth {
}

#[pyproto]
impl PyObjectProtocol for AzColumnRuleWidth {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnRuleWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnRuleWidth = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTextDecorationEnumWrapper {
    #[classattr]
    const None: AzStyleTextDecoration = AzStyleTextDecoration::None;
    #[classattr]
    const Underline: AzStyleTextDecoration = AzStyleTextDecoration::Underline;
    #[classattr]
    const Overline: AzStyleTextDecoration = AzStyleTextDecoration::Overline;
    #[classattr]
    const LineThrough: AzStyleTextDecoration = AzStyleTextDecoration::LineThrough;
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextDecorationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTextDecoration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTextDecoration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleTextDecorationEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzCaretColor {
}

#[pyproto]
impl PyObjectProtocol for AzCaretColor {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::CaretColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::CaretColor = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutSize {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutSize {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::LayoutSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::LayoutSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColumnFillEnumWrapper {
    #[classattr]
    const Auto: AzColumnFill = AzColumnFill::Auto;
    #[classattr]
    const Balance: AzColumnFill = AzColumnFill::Balance;
}

#[pyproto]
impl PyObjectProtocol for AzColumnFillEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnFill = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::column::ColumnFill = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzColumnFillEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzPageBreakEnumWrapper {
    #[classattr]
    const Auto: AzPageBreak = AzPageBreak::Auto;
    #[classattr]
    const Avoid: AzPageBreak = AzPageBreak::Avoid;
    #[classattr]
    const Always: AzPageBreak = AzPageBreak::Always;
    #[classattr]
    const All: AzPageBreak = AzPageBreak::All;
    #[classattr]
    const Page: AzPageBreak = AzPageBreak::Page;
    #[classattr]
    const AvoidPage: AzPageBreak = AzPageBreak::AvoidPage;
    #[classattr]
    const Left: AzPageBreak = AzPageBreak::Left;
    #[classattr]
    const Right: AzPageBreak = AzPageBreak::Right;
    #[classattr]
    const Recto: AzPageBreak = AzPageBreak::Recto;
    #[classattr]
    const Verso: AzPageBreak = AzPageBreak::Verso;
    #[classattr]
    const Column: AzPageBreak = AzPageBreak::Column;
    #[classattr]
    const AvoidColumn: AzPageBreak = AzPageBreak::AvoidColumn;
}

#[pyproto]
impl PyObjectProtocol for AzPageBreakEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::fragmentation::PageBreak = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::fragmentation::PageBreak = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzPageBreakEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutScrollbarWidthEnumWrapper {
    #[classattr]
    const Auto: AzLayoutScrollbarWidth = AzLayoutScrollbarWidth::Auto;
    #[classattr]
    const Thin: AzLayoutScrollbarWidth = AzLayoutScrollbarWidth::Thin;
    #[classattr]
    const None: AzLayoutScrollbarWidth = AzLayoutScrollbarWidth::None;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutScrollbarWidthEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::LayoutScrollbarWidth = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::LayoutScrollbarWidth = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutScrollbarWidthEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleScrollbarColorEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleScrollbarColorEnumWrapper {
        AzStyleScrollbarColorEnumWrapper { inner: AzStyleScrollbarColor::Auto }
    }
    #[staticmethod]
    fn Custom(v: ScrollbarColorCustom) -> AzStyleScrollbarColorEnumWrapper {
        AzStyleScrollbarColorEnumWrapper { inner: AzStyleScrollbarColor::Custom(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleScrollbarColor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleScrollbarColor::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleScrollbarColor::Custom(v) => Ok(vec!["Custom".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleScrollbarColorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::StyleScrollbarColor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::StyleScrollbarColor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleVerticalAlignEnumWrapper {
    #[classattr]
    const Top: AzStyleVerticalAlign = AzStyleVerticalAlign::Top;
    #[classattr]
    const Center: AzStyleVerticalAlign = AzStyleVerticalAlign::Center;
    #[classattr]
    const Bottom: AzStyleVerticalAlign = AzStyleVerticalAlign::Bottom;
}

#[pyproto]
impl PyObjectProtocol for AzStyleVerticalAlignEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleVerticalAlign = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleVerticalAlign = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleVerticalAlignEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleLineClamp {
}

#[pyproto]
impl PyObjectProtocol for AzStyleLineClamp {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleLineClamp = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleLineClamp = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapeInsideEnumWrapper {
    #[classattr]
    fn None() -> AzShapeInsideEnumWrapper {
        AzShapeInsideEnumWrapper { inner: AzShapeInside::None }
    }
    #[staticmethod]
    fn Shape(v: CssShape) -> AzShapeInsideEnumWrapper {
        AzShapeInsideEnumWrapper { inner: AzShapeInside::Shape(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzShapeInside;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzShapeInside::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzShapeInside::Shape(v) => Ok(vec!["Shape".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzShapeInsideEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::shape::ShapeInside = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::shape::ShapeInside = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSelectionRadius {
}

#[pyproto]
impl PyObjectProtocol for AzSelectionRadius {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::selection::SelectionRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::selection::SelectionRadius = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOrphans {
}

#[pyproto]
impl PyObjectProtocol for AzOrphans {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::fragmentation::Orphans = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::fragmentation::Orphans = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTextIndent {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextIndent {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTextIndent = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTextIndent = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderSpacing {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderSpacing {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::table::LayoutBorderSpacing = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::table::LayoutBorderSpacing = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingInlineStart {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingInlineStart {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutPaddingInlineStart = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutPaddingInlineStart = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontWeightEnumWrapper {
    #[classattr]
    const Lighter: AzStyleFontWeight = AzStyleFontWeight::Lighter;
    #[classattr]
    const W100: AzStyleFontWeight = AzStyleFontWeight::W100;
    #[classattr]
    const W200: AzStyleFontWeight = AzStyleFontWeight::W200;
    #[classattr]
    const W300: AzStyleFontWeight = AzStyleFontWeight::W300;
    #[classattr]
    const Normal: AzStyleFontWeight = AzStyleFontWeight::Normal;
    #[classattr]
    const W500: AzStyleFontWeight = AzStyleFontWeight::W500;
    #[classattr]
    const W600: AzStyleFontWeight = AzStyleFontWeight::W600;
    #[classattr]
    const Bold: AzStyleFontWeight = AzStyleFontWeight::Bold;
    #[classattr]
    const W800: AzStyleFontWeight = AzStyleFontWeight::W800;
    #[classattr]
    const W900: AzStyleFontWeight = AzStyleFontWeight::W900;
    #[classattr]
    const Bolder: AzStyleFontWeight = AzStyleFontWeight::Bolder;
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontWeightEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontWeight = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontWeight = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleFontWeightEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleExclusionMargin {
}

#[pyproto]
impl PyObjectProtocol for AzStyleExclusionMargin {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::azul_exclusion::StyleExclusionMargin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::azul_exclusion::StyleExclusionMargin = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWidows {
}

#[pyproto]
impl PyObjectProtocol for AzWidows {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::fragmentation::Widows = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::fragmentation::Widows = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutColumnGap {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutColumnGap {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutColumnGap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutColumnGap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingInlineEnd {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingInlineEnd {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutPaddingInlineEnd = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutPaddingInlineEnd = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleListStyleTypeEnumWrapper {
    #[classattr]
    const None: AzStyleListStyleType = AzStyleListStyleType::None;
    #[classattr]
    const Disc: AzStyleListStyleType = AzStyleListStyleType::Disc;
    #[classattr]
    const Circle: AzStyleListStyleType = AzStyleListStyleType::Circle;
    #[classattr]
    const Square: AzStyleListStyleType = AzStyleListStyleType::Square;
    #[classattr]
    const Decimal: AzStyleListStyleType = AzStyleListStyleType::Decimal;
    #[classattr]
    const DecimalLeadingZero: AzStyleListStyleType = AzStyleListStyleType::DecimalLeadingZero;
    #[classattr]
    const LowerRoman: AzStyleListStyleType = AzStyleListStyleType::LowerRoman;
    #[classattr]
    const UpperRoman: AzStyleListStyleType = AzStyleListStyleType::UpperRoman;
    #[classattr]
    const LowerGreek: AzStyleListStyleType = AzStyleListStyleType::LowerGreek;
    #[classattr]
    const UpperGreek: AzStyleListStyleType = AzStyleListStyleType::UpperGreek;
    #[classattr]
    const LowerAlpha: AzStyleListStyleType = AzStyleListStyleType::LowerAlpha;
    #[classattr]
    const UpperAlpha: AzStyleListStyleType = AzStyleListStyleType::UpperAlpha;
}

#[pyproto]
impl PyObjectProtocol for AzStyleListStyleTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::lists::StyleListStyleType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::lists::StyleListStyleType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleListStyleTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzClipPathEnumWrapper {
    #[classattr]
    fn None() -> AzClipPathEnumWrapper {
        AzClipPathEnumWrapper { inner: AzClipPath::None }
    }
    #[staticmethod]
    fn Shape(v: CssShape) -> AzClipPathEnumWrapper {
        AzClipPathEnumWrapper { inner: AzClipPath::Shape(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzClipPath;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzClipPath::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzClipPath::Shape(v) => Ok(vec!["Shape".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzClipPathEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::shape::ClipPath = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::shape::ClipPath = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleHyphenationLanguage {
}

#[pyproto]
impl PyObjectProtocol for AzStyleHyphenationLanguage {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::azul_exclusion::StyleHyphenationLanguage = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::azul_exclusion::StyleHyphenationLanguage = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleListStylePositionEnumWrapper {
    #[classattr]
    const Inside: AzStyleListStylePosition = AzStyleListStylePosition::Inside;
    #[classattr]
    const Outside: AzStyleListStylePosition = AzStyleListStylePosition::Outside;
}

#[pyproto]
impl PyObjectProtocol for AzStyleListStylePositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::lists::StyleListStylePosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::lists::StyleListStylePosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleListStylePositionEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleBorderCollapseEnumWrapper {
    #[classattr]
    const Separate: AzStyleBorderCollapse = AzStyleBorderCollapse::Separate;
    #[classattr]
    const Collapse: AzStyleBorderCollapse = AzStyleBorderCollapse::Collapse;
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderCollapseEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::table::StyleBorderCollapse = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::table::StyleBorderCollapse = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleBorderCollapseEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleCaptionSideEnumWrapper {
    #[classattr]
    const Top: AzStyleCaptionSide = AzStyleCaptionSide::Top;
    #[classattr]
    const Bottom: AzStyleCaptionSide = AzStyleCaptionSide::Bottom;
}

#[pyproto]
impl PyObjectProtocol for AzStyleCaptionSideEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::table::StyleCaptionSide = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::table::StyleCaptionSide = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleCaptionSideEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutRowGap {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutRowGap {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutRowGap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::spacing::LayoutRowGap = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleHangingPunctuation {
}

#[pyproto]
impl PyObjectProtocol for AzStyleHangingPunctuation {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleHangingPunctuation = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleHangingPunctuation = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutTableLayoutEnumWrapper {
    #[classattr]
    const Auto: AzLayoutTableLayout = AzLayoutTableLayout::Auto;
    #[classattr]
    const Fixed: AzLayoutTableLayout = AzLayoutTableLayout::Fixed;
}

#[pyproto]
impl PyObjectProtocol for AzLayoutTableLayoutEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::table::LayoutTableLayout = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::table::LayoutTableLayout = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzLayoutTableLayoutEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleInitialLetter {
}

#[pyproto]
impl PyObjectProtocol for AzStyleInitialLetter {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleInitialLetter = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleInitialLetter = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleEmptyCellsEnumWrapper {
    #[classattr]
    const Show: AzStyleEmptyCells = AzStyleEmptyCells::Show;
    #[classattr]
    const Hide: AzStyleEmptyCells = AzStyleEmptyCells::Hide;
}

#[pyproto]
impl PyObjectProtocol for AzStyleEmptyCellsEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::table::StyleEmptyCells = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::table::StyleEmptyCells = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleEmptyCellsEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleFontStyleEnumWrapper {
    #[classattr]
    const Normal: AzStyleFontStyle = AzStyleFontStyle::Normal;
    #[classattr]
    const Italic: AzStyleFontStyle = AzStyleFontStyle::Italic;
    #[classattr]
    const Oblique: AzStyleFontStyle = AzStyleFontStyle::Oblique;
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontStyleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzStyleFontStyleEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyleTextCombineUprightEnumWrapper {
    #[classattr]
    fn None() -> AzStyleTextCombineUprightEnumWrapper {
        AzStyleTextCombineUprightEnumWrapper { inner: AzStyleTextCombineUpright::None }
    }
    #[classattr]
    fn All() -> AzStyleTextCombineUprightEnumWrapper {
        AzStyleTextCombineUprightEnumWrapper { inner: AzStyleTextCombineUpright::All }
    }
    #[staticmethod]
    fn Digits(v: u8) -> AzStyleTextCombineUprightEnumWrapper {
        AzStyleTextCombineUprightEnumWrapper { inner: AzStyleTextCombineUpright::Digits(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTextCombineUpright;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTextCombineUpright::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleTextCombineUpright::All => Ok(vec!["All".into_py(py), ().into_py(py)]),
            AzStyleTextCombineUpright::Digits(v) => Ok(vec!["Digits".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextCombineUprightEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTextCombineUpright = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::text::StyleTextCombineUpright = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGridTrackSizingEnumWrapper {
    #[staticmethod]
    fn Fixed(v: PixelValue) -> AzGridTrackSizingEnumWrapper {
        AzGridTrackSizingEnumWrapper { inner: AzGridTrackSizing::Fixed(v) }}
    }
    #[staticmethod]
    fn Fr(v: i32) -> AzGridTrackSizingEnumWrapper {
        AzGridTrackSizingEnumWrapper { inner: AzGridTrackSizing::Fr(v) }}
    }
    #[classattr]
    fn MinContent() -> AzGridTrackSizingEnumWrapper {
        AzGridTrackSizingEnumWrapper { inner: AzGridTrackSizing::MinContent }
    }
    #[classattr]
    fn MaxContent() -> AzGridTrackSizingEnumWrapper {
        AzGridTrackSizingEnumWrapper { inner: AzGridTrackSizing::MaxContent }
    }
    #[classattr]
    fn Auto() -> AzGridTrackSizingEnumWrapper {
        AzGridTrackSizingEnumWrapper { inner: AzGridTrackSizing::Auto }
    }
    #[staticmethod]
    fn MinMax(v: GridMinMax) -> AzGridTrackSizingEnumWrapper {
        AzGridTrackSizingEnumWrapper { inner: AzGridTrackSizing::MinMax(v) }}
    }
    #[staticmethod]
    fn FitContent(v: PixelValue) -> AzGridTrackSizingEnumWrapper {
        AzGridTrackSizingEnumWrapper { inner: AzGridTrackSizing::FitContent(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzGridTrackSizing;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzGridTrackSizing::Fixed(v) => Ok(vec!["Fixed".into_py(py), v.into_py(py)]),
            AzGridTrackSizing::Fr(v) => Ok(vec!["Fr".into_py(py), v.into_py(py)]),
            AzGridTrackSizing::MinContent => Ok(vec!["MinContent".into_py(py), ().into_py(py)]),
            AzGridTrackSizing::MaxContent => Ok(vec!["MaxContent".into_py(py), ().into_py(py)]),
            AzGridTrackSizing::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzGridTrackSizing::MinMax(v) => Ok(vec!["MinMax".into_py(py), v.into_py(py)]),
            AzGridTrackSizing::FitContent(v) => Ok(vec!["FitContent".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGridTrackSizingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridTrackSizing = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridTrackSizing = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPhysicalSizeU32 {
}

#[pyproto]
impl PyObjectProtocol for AzPhysicalSizeU32 {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::PhysicalSizeU32 = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::PhysicalSizeU32 = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzHoverEventFilterEnumWrapper {
    #[classattr]
    const MouseOver: AzHoverEventFilter = AzHoverEventFilter::MouseOver;
    #[classattr]
    const MouseDown: AzHoverEventFilter = AzHoverEventFilter::MouseDown;
    #[classattr]
    const LeftMouseDown: AzHoverEventFilter = AzHoverEventFilter::LeftMouseDown;
    #[classattr]
    const RightMouseDown: AzHoverEventFilter = AzHoverEventFilter::RightMouseDown;
    #[classattr]
    const MiddleMouseDown: AzHoverEventFilter = AzHoverEventFilter::MiddleMouseDown;
    #[classattr]
    const MouseUp: AzHoverEventFilter = AzHoverEventFilter::MouseUp;
    #[classattr]
    const LeftMouseUp: AzHoverEventFilter = AzHoverEventFilter::LeftMouseUp;
    #[classattr]
    const RightMouseUp: AzHoverEventFilter = AzHoverEventFilter::RightMouseUp;
    #[classattr]
    const MiddleMouseUp: AzHoverEventFilter = AzHoverEventFilter::MiddleMouseUp;
    #[classattr]
    const MouseEnter: AzHoverEventFilter = AzHoverEventFilter::MouseEnter;
    #[classattr]
    const MouseLeave: AzHoverEventFilter = AzHoverEventFilter::MouseLeave;
    #[classattr]
    const Scroll: AzHoverEventFilter = AzHoverEventFilter::Scroll;
    #[classattr]
    const ScrollStart: AzHoverEventFilter = AzHoverEventFilter::ScrollStart;
    #[classattr]
    const ScrollEnd: AzHoverEventFilter = AzHoverEventFilter::ScrollEnd;
    #[classattr]
    const TextInput: AzHoverEventFilter = AzHoverEventFilter::TextInput;
    #[classattr]
    const VirtualKeyDown: AzHoverEventFilter = AzHoverEventFilter::VirtualKeyDown;
    #[classattr]
    const VirtualKeyUp: AzHoverEventFilter = AzHoverEventFilter::VirtualKeyUp;
    #[classattr]
    const HoveredFile: AzHoverEventFilter = AzHoverEventFilter::HoveredFile;
    #[classattr]
    const DroppedFile: AzHoverEventFilter = AzHoverEventFilter::DroppedFile;
    #[classattr]
    const HoveredFileCancelled: AzHoverEventFilter = AzHoverEventFilter::HoveredFileCancelled;
    #[classattr]
    const TouchStart: AzHoverEventFilter = AzHoverEventFilter::TouchStart;
    #[classattr]
    const TouchMove: AzHoverEventFilter = AzHoverEventFilter::TouchMove;
    #[classattr]
    const TouchEnd: AzHoverEventFilter = AzHoverEventFilter::TouchEnd;
    #[classattr]
    const TouchCancel: AzHoverEventFilter = AzHoverEventFilter::TouchCancel;
    #[classattr]
    const PenDown: AzHoverEventFilter = AzHoverEventFilter::PenDown;
    #[classattr]
    const PenMove: AzHoverEventFilter = AzHoverEventFilter::PenMove;
    #[classattr]
    const PenUp: AzHoverEventFilter = AzHoverEventFilter::PenUp;
    #[classattr]
    const PenEnter: AzHoverEventFilter = AzHoverEventFilter::PenEnter;
    #[classattr]
    const PenLeave: AzHoverEventFilter = AzHoverEventFilter::PenLeave;
    #[classattr]
    const DragStart: AzHoverEventFilter = AzHoverEventFilter::DragStart;
    #[classattr]
    const Drag: AzHoverEventFilter = AzHoverEventFilter::Drag;
    #[classattr]
    const DragEnd: AzHoverEventFilter = AzHoverEventFilter::DragEnd;
    #[classattr]
    const DoubleClick: AzHoverEventFilter = AzHoverEventFilter::DoubleClick;
    #[classattr]
    const LongPress: AzHoverEventFilter = AzHoverEventFilter::LongPress;
    #[classattr]
    const SwipeLeft: AzHoverEventFilter = AzHoverEventFilter::SwipeLeft;
    #[classattr]
    const SwipeRight: AzHoverEventFilter = AzHoverEventFilter::SwipeRight;
    #[classattr]
    const SwipeUp: AzHoverEventFilter = AzHoverEventFilter::SwipeUp;
    #[classattr]
    const SwipeDown: AzHoverEventFilter = AzHoverEventFilter::SwipeDown;
    #[classattr]
    const PinchIn: AzHoverEventFilter = AzHoverEventFilter::PinchIn;
    #[classattr]
    const PinchOut: AzHoverEventFilter = AzHoverEventFilter::PinchOut;
    #[classattr]
    const RotateClockwise: AzHoverEventFilter = AzHoverEventFilter::RotateClockwise;
    #[classattr]
    const RotateCounterClockwise: AzHoverEventFilter = AzHoverEventFilter::RotateCounterClockwise;
    #[classattr]
    const SystemTextSingleClick: AzHoverEventFilter = AzHoverEventFilter::SystemTextSingleClick;
    #[classattr]
    const SystemTextDoubleClick: AzHoverEventFilter = AzHoverEventFilter::SystemTextDoubleClick;
    #[classattr]
    const SystemTextTripleClick: AzHoverEventFilter = AzHoverEventFilter::SystemTextTripleClick;
}

#[pyproto]
impl PyObjectProtocol for AzHoverEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::events::HoverEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::events::HoverEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzHoverEventFilterEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzTextSelectionStartEnd {
}

#[pyproto]
impl PyObjectProtocol for AzTextSelectionStartEnd {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::TextSelectionStartEnd = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::TextSelectionStartEnd = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapeRenderingEnumWrapper {
    #[classattr]
    const OptimizeSpeed: AzShapeRendering = AzShapeRendering::OptimizeSpeed;
    #[classattr]
    const CrispEdges: AzShapeRendering = AzShapeRendering::CrispEdges;
    #[classattr]
    const GeometricPrecision: AzShapeRendering = AzShapeRendering::GeometricPrecision;
}

#[pyproto]
impl PyObjectProtocol for AzShapeRenderingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::ShapeRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::ShapeRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzShapeRenderingEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzApplicationEventFilterEnumWrapper {
    #[classattr]
    const DeviceConnected: AzApplicationEventFilter = AzApplicationEventFilter::DeviceConnected;
    #[classattr]
    const DeviceDisconnected: AzApplicationEventFilter = AzApplicationEventFilter::DeviceDisconnected;
}

#[pyproto]
impl PyObjectProtocol for AzApplicationEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::events::ApplicationEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::events::ApplicationEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzApplicationEventFilterEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSvgFillStyle {
}

#[pyproto]
impl PyObjectProtocol for AzSvgFillStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgFillStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgFillStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlTextPos {
}

#[pyproto]
impl PyObjectProtocol for AzXmlTextPos {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlTextPos = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlTextPos = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalSize {
}

#[pyproto]
impl PyObjectProtocol for AzLogicalSize {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::LogicalSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::LogicalSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledNodeState {
}

#[pyproto]
impl PyObjectProtocol for AzStyledNodeState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledNodeState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledNodeState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyCachePtr {
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyCachePtr {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::prop_cache::CssPropertyCachePtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::prop_cache::CssPropertyCachePtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgRenderTransform {
}

#[pyproto]
impl PyObjectProtocol for AzSvgRenderTransform {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgRenderTransform = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgRenderTransform = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextRenderingEnumWrapper {
    #[classattr]
    const OptimizeSpeed: AzTextRendering = AzTextRendering::OptimizeSpeed;
    #[classattr]
    const OptimizeLegibility: AzTextRendering = AzTextRendering::OptimizeLegibility;
    #[classattr]
    const GeometricPrecision: AzTextRendering = AzTextRendering::GeometricPrecision;
}

#[pyproto]
impl PyObjectProtocol for AzTextRenderingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TextRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TextRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzTextRenderingEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzFocusEventFilterEnumWrapper {
    #[classattr]
    const MouseOver: AzFocusEventFilter = AzFocusEventFilter::MouseOver;
    #[classattr]
    const MouseDown: AzFocusEventFilter = AzFocusEventFilter::MouseDown;
    #[classattr]
    const LeftMouseDown: AzFocusEventFilter = AzFocusEventFilter::LeftMouseDown;
    #[classattr]
    const RightMouseDown: AzFocusEventFilter = AzFocusEventFilter::RightMouseDown;
    #[classattr]
    const MiddleMouseDown: AzFocusEventFilter = AzFocusEventFilter::MiddleMouseDown;
    #[classattr]
    const MouseUp: AzFocusEventFilter = AzFocusEventFilter::MouseUp;
    #[classattr]
    const LeftMouseUp: AzFocusEventFilter = AzFocusEventFilter::LeftMouseUp;
    #[classattr]
    const RightMouseUp: AzFocusEventFilter = AzFocusEventFilter::RightMouseUp;
    #[classattr]
    const MiddleMouseUp: AzFocusEventFilter = AzFocusEventFilter::MiddleMouseUp;
    #[classattr]
    const MouseEnter: AzFocusEventFilter = AzFocusEventFilter::MouseEnter;
    #[classattr]
    const MouseLeave: AzFocusEventFilter = AzFocusEventFilter::MouseLeave;
    #[classattr]
    const Scroll: AzFocusEventFilter = AzFocusEventFilter::Scroll;
    #[classattr]
    const ScrollStart: AzFocusEventFilter = AzFocusEventFilter::ScrollStart;
    #[classattr]
    const ScrollEnd: AzFocusEventFilter = AzFocusEventFilter::ScrollEnd;
    #[classattr]
    const TextInput: AzFocusEventFilter = AzFocusEventFilter::TextInput;
    #[classattr]
    const VirtualKeyDown: AzFocusEventFilter = AzFocusEventFilter::VirtualKeyDown;
    #[classattr]
    const VirtualKeyUp: AzFocusEventFilter = AzFocusEventFilter::VirtualKeyUp;
    #[classattr]
    const FocusReceived: AzFocusEventFilter = AzFocusEventFilter::FocusReceived;
    #[classattr]
    const FocusLost: AzFocusEventFilter = AzFocusEventFilter::FocusLost;
    #[classattr]
    const PenDown: AzFocusEventFilter = AzFocusEventFilter::PenDown;
    #[classattr]
    const PenMove: AzFocusEventFilter = AzFocusEventFilter::PenMove;
    #[classattr]
    const PenUp: AzFocusEventFilter = AzFocusEventFilter::PenUp;
    #[classattr]
    const DragStart: AzFocusEventFilter = AzFocusEventFilter::DragStart;
    #[classattr]
    const Drag: AzFocusEventFilter = AzFocusEventFilter::Drag;
    #[classattr]
    const DragEnd: AzFocusEventFilter = AzFocusEventFilter::DragEnd;
    #[classattr]
    const DoubleClick: AzFocusEventFilter = AzFocusEventFilter::DoubleClick;
    #[classattr]
    const LongPress: AzFocusEventFilter = AzFocusEventFilter::LongPress;
    #[classattr]
    const SwipeLeft: AzFocusEventFilter = AzFocusEventFilter::SwipeLeft;
    #[classattr]
    const SwipeRight: AzFocusEventFilter = AzFocusEventFilter::SwipeRight;
    #[classattr]
    const SwipeUp: AzFocusEventFilter = AzFocusEventFilter::SwipeUp;
    #[classattr]
    const SwipeDown: AzFocusEventFilter = AzFocusEventFilter::SwipeDown;
    #[classattr]
    const PinchIn: AzFocusEventFilter = AzFocusEventFilter::PinchIn;
    #[classattr]
    const PinchOut: AzFocusEventFilter = AzFocusEventFilter::PinchOut;
    #[classattr]
    const RotateClockwise: AzFocusEventFilter = AzFocusEventFilter::RotateClockwise;
    #[classattr]
    const RotateCounterClockwise: AzFocusEventFilter = AzFocusEventFilter::RotateCounterClockwise;
}

#[pyproto]
impl PyObjectProtocol for AzFocusEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::events::FocusEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::events::FocusEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzFocusEventFilterEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLogicalPosition {
}

#[pyproto]
impl PyObjectProtocol for AzLogicalPosition {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::LogicalPosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::LogicalPosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzEventFilterEnumWrapper {
    #[staticmethod]
    fn Hover(v: HoverEventFilter) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper { inner: AzEventFilter::Hover(v) }}
    }
    #[staticmethod]
    fn Not(v: NotEventFilter) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper { inner: AzEventFilter::Not(v) }}
    }
    #[staticmethod]
    fn Focus(v: FocusEventFilter) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper { inner: AzEventFilter::Focus(v) }}
    }
    #[staticmethod]
    fn Window(v: WindowEventFilter) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper { inner: AzEventFilter::Window(v) }}
    }
    #[staticmethod]
    fn Component(v: ComponentEventFilter) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper { inner: AzEventFilter::Component(v) }}
    }
    #[staticmethod]
    fn Application(v: ApplicationEventFilter) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper { inner: AzEventFilter::Application(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzEventFilter;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzEventFilter::Hover(v) => Ok(vec!["Hover".into_py(py), v.into_py(py)]),
            AzEventFilter::Not(v) => Ok(vec!["Not".into_py(py), v.into_py(py)]),
            AzEventFilter::Focus(v) => Ok(vec!["Focus".into_py(py), v.into_py(py)]),
            AzEventFilter::Window(v) => Ok(vec!["Window".into_py(py), v.into_py(py)]),
            AzEventFilter::Component(v) => Ok(vec!["Component".into_py(py), v.into_py(py)]),
            AzEventFilter::Application(v) => Ok(vec!["Application".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::events::EventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::events::EventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPhysicalSize {
}

#[pyproto]
impl PyObjectProtocol for AzPhysicalSize {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::PhysicalSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::PhysicalSize = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgStyleEnumWrapper {
    #[staticmethod]
    fn Fill(v: SvgFillStyle) -> AzSvgStyleEnumWrapper {
        AzSvgStyleEnumWrapper { inner: AzSvgStyle::Fill(v) }}
    }
    #[staticmethod]
    fn Stroke(v: SvgStrokeStyle) -> AzSvgStyleEnumWrapper {
        AzSvgStyleEnumWrapper { inner: AzSvgStyle::Stroke(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgStyle;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgStyle::Fill(v) => Ok(vec!["Fill".into_py(py), v.into_py(py)]),
            AzSvgStyle::Stroke(v) => Ok(vec!["Stroke".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgStyleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgStyle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIndentEnumWrapper {
    #[classattr]
    fn None() -> AzIndentEnumWrapper {
        AzIndentEnumWrapper { inner: AzIndent::None }
    }
    #[staticmethod]
    fn Spaces(v: u8) -> AzIndentEnumWrapper {
        AzIndentEnumWrapper { inner: AzIndent::Spaces(v) }}
    }
    #[classattr]
    fn Tabs() -> AzIndentEnumWrapper {
        AzIndentEnumWrapper { inner: AzIndent::Tabs }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzIndent;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzIndent::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzIndent::Spaces(v) => Ok(vec!["Spaces".into_py(py), v.into_py(py)]),
            AzIndent::Tabs => Ok(vec!["Tabs".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIndentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::Indent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::Indent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFontDatabaseEnumWrapper {
    #[classattr]
    const Empty: AzFontDatabase = AzFontDatabase::Empty;
    #[classattr]
    const System: AzFontDatabase = AzFontDatabase::System;
}

#[pyproto]
impl PyObjectProtocol for AzFontDatabaseEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::FontDatabase = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::FontDatabase = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzFontDatabaseEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzStyledDom {
    #[new]
    fn new(/* args */) -> AzStyledDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn default(/* args */) -> AzStyledDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn from_xml(/* args */) -> AzStyledDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn from_file(/* args */) -> AzStyledDom {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn append_child(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_child(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn restyle(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn node_count(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_html_string(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_html_string_test(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_menu_bar(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_menu_bar(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_context_menu(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_context_menu(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzStyledDom {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledDom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledDom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledNode {
}

#[pyproto]
impl PyObjectProtocol for AzStyledNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNotEventFilterEnumWrapper {
    #[staticmethod]
    fn Hover(v: HoverEventFilter) -> AzNotEventFilterEnumWrapper {
        AzNotEventFilterEnumWrapper { inner: AzNotEventFilter::Hover(v) }}
    }
    #[staticmethod]
    fn Focus(v: FocusEventFilter) -> AzNotEventFilterEnumWrapper {
        AzNotEventFilterEnumWrapper { inner: AzNotEventFilter::Focus(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNotEventFilter;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNotEventFilter::Hover(v) => Ok(vec!["Hover".into_py(py), v.into_py(py)]),
            AzNotEventFilter::Focus(v) => Ok(vec!["Focus".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNotEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::events::NotEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::events::NotEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzComponentEventFilterEnumWrapper {
    #[classattr]
    const AfterMount: AzComponentEventFilter = AzComponentEventFilter::AfterMount;
    #[classattr]
    const BeforeUnmount: AzComponentEventFilter = AzComponentEventFilter::BeforeUnmount;
    #[classattr]
    const NodeResized: AzComponentEventFilter = AzComponentEventFilter::NodeResized;
    #[classattr]
    const DefaultAction: AzComponentEventFilter = AzComponentEventFilter::DefaultAction;
    #[classattr]
    const Selected: AzComponentEventFilter = AzComponentEventFilter::Selected;
}

#[pyproto]
impl PyObjectProtocol for AzComponentEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::events::ComponentEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::events::ComponentEventFilter = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzComponentEventFilterEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSvgTransform {
}

#[pyproto]
impl PyObjectProtocol for AzSvgTransform {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgTransform = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgTransform = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexLayout {
}

#[pyproto]
impl PyObjectProtocol for AzVertexLayout {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexLayout = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexLayout = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGridMinMax {
}

#[pyproto]
impl PyObjectProtocol for AzGridMinMax {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridMinMax = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridMinMax = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNamedGridLine {
}

#[pyproto]
impl PyObjectProtocol for AzNamedGridLine {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::NamedGridLine = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::NamedGridLine = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScrollbarColorCustom {
}

#[pyproto]
impl PyObjectProtocol for AzScrollbarColorCustom {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::ScrollbarColorCustom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::scrollbar::ScrollbarColorCustom = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapeInset {
}

#[pyproto]
impl PyObjectProtocol for AzShapeInset {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::ShapeInset = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::ShapeInset = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssShapeEnumWrapper {
    #[staticmethod]
    fn Circle(v: ShapeCircle) -> AzCssShapeEnumWrapper {
        AzCssShapeEnumWrapper { inner: AzCssShape::Circle(v) }}
    }
    #[staticmethod]
    fn Ellipse(v: ShapeEllipse) -> AzCssShapeEnumWrapper {
        AzCssShapeEnumWrapper { inner: AzCssShape::Ellipse(v) }}
    }
    #[staticmethod]
    fn Polygon(v: ShapePolygon) -> AzCssShapeEnumWrapper {
        AzCssShapeEnumWrapper { inner: AzCssShape::Polygon(v) }}
    }
    #[staticmethod]
    fn Inset(v: ShapeInset) -> AzCssShapeEnumWrapper {
        AzCssShapeEnumWrapper { inner: AzCssShape::Inset(v) }}
    }
    #[staticmethod]
    fn Path(v: ShapePath) -> AzCssShapeEnumWrapper {
        AzCssShapeEnumWrapper { inner: AzCssShape::Path(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssShape;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssShape::Circle(v) => Ok(vec!["Circle".into_py(py), v.into_py(py)]),
            AzCssShape::Ellipse(v) => Ok(vec!["Ellipse".into_py(py), v.into_py(py)]),
            AzCssShape::Polygon(v) => Ok(vec!["Polygon".into_py(py), v.into_py(py)]),
            AzCssShape::Inset(v) => Ok(vec!["Inset".into_py(py), v.into_py(py)]),
            AzCssShape::Path(v) => Ok(vec!["Path".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssShapeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::CssShape = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::CssShape = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapePath {
}

#[pyproto]
impl PyObjectProtocol for AzShapePath {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::ShapePath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::ShapePath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapeEllipse {
}

#[pyproto]
impl PyObjectProtocol for AzShapeEllipse {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::ShapeEllipse = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::ShapeEllipse = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapePoint {
}

#[pyproto]
impl PyObjectProtocol for AzShapePoint {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::ShapePoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::ShapePoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowBackgroundMaterialEnumWrapper {
    #[classattr]
    const Opaque: AzWindowBackgroundMaterial = AzWindowBackgroundMaterial::Opaque;
    #[classattr]
    const Transparent: AzWindowBackgroundMaterial = AzWindowBackgroundMaterial::Transparent;
    #[classattr]
    const Sidebar: AzWindowBackgroundMaterial = AzWindowBackgroundMaterial::Sidebar;
    #[classattr]
    const Menu: AzWindowBackgroundMaterial = AzWindowBackgroundMaterial::Menu;
    #[classattr]
    const HUD: AzWindowBackgroundMaterial = AzWindowBackgroundMaterial::HUD;
    #[classattr]
    const Titlebar: AzWindowBackgroundMaterial = AzWindowBackgroundMaterial::Titlebar;
    #[classattr]
    const MicaAlt: AzWindowBackgroundMaterial = AzWindowBackgroundMaterial::MicaAlt;
}

#[pyproto]
impl PyObjectProtocol for AzWindowBackgroundMaterialEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowBackgroundMaterial = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowBackgroundMaterial = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzWindowBackgroundMaterialEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzLayoutRect {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutRect {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::LayoutRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::LayoutRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowPositionEnumWrapper {
    #[classattr]
    fn Uninitialized() -> AzWindowPositionEnumWrapper {
        AzWindowPositionEnumWrapper { inner: AzWindowPosition::Uninitialized }
    }
    #[staticmethod]
    fn Initialized(v: PhysicalPositionI32) -> AzWindowPositionEnumWrapper {
        AzWindowPositionEnumWrapper { inner: AzWindowPosition::Initialized(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzWindowPosition;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzWindowPosition::Uninitialized => Ok(vec!["Uninitialized".into_py(py), ().into_py(py)]),
            AzWindowPosition::Initialized(v) => Ok(vec!["Initialized".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzWindowPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPoint {
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPoint {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::LayoutPoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::LayoutPoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCursorPositionEnumWrapper {
    #[staticmethod]
    fn OutOfWindow(v: LogicalPosition) -> AzCursorPositionEnumWrapper {
        AzCursorPositionEnumWrapper { inner: AzCursorPosition::OutOfWindow(v) }}
    }
    #[classattr]
    fn Uninitialized() -> AzCursorPositionEnumWrapper {
        AzCursorPositionEnumWrapper { inner: AzCursorPosition::Uninitialized }
    }
    #[staticmethod]
    fn InWindow(v: LogicalPosition) -> AzCursorPositionEnumWrapper {
        AzCursorPositionEnumWrapper { inner: AzCursorPosition::InWindow(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCursorPosition;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCursorPosition::OutOfWindow(v) => Ok(vec!["OutOfWindow".into_py(py), v.into_py(py)]),
            AzCursorPosition::Uninitialized => Ok(vec!["Uninitialized".into_py(py), ().into_py(py)]),
            AzCursorPosition::InWindow(v) => Ok(vec!["InWindow".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCursorPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::CursorPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::CursorPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzImePositionEnumWrapper {
    #[classattr]
    fn Uninitialized() -> AzImePositionEnumWrapper {
        AzImePositionEnumWrapper { inner: AzImePosition::Uninitialized }
    }
    #[staticmethod]
    fn Initialized(v: LogicalRect) -> AzImePositionEnumWrapper {
        AzImePositionEnumWrapper { inner: AzImePosition::Initialized(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzImePosition;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzImePosition::Uninitialized => Ok(vec!["Uninitialized".into_py(py), ().into_py(py)]),
            AzImePosition::Initialized(v) => Ok(vec!["Initialized".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzImePositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ImePosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ImePosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowDecorationsEnumWrapper {
    #[classattr]
    const Normal: AzWindowDecorations = AzWindowDecorations::Normal;
    #[classattr]
    const NoTitle: AzWindowDecorations = AzWindowDecorations::NoTitle;
    #[classattr]
    const NoControls: AzWindowDecorations = AzWindowDecorations::NoControls;
    #[classattr]
    const None: AzWindowDecorations = AzWindowDecorations::None;
}

#[pyproto]
impl PyObjectProtocol for AzWindowDecorationsEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowDecorations = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::WindowDecorations = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzWindowDecorationsEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzPhysicalPosition {
}

#[pyproto]
impl PyObjectProtocol for AzPhysicalPosition {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::PhysicalPosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::PhysicalPosition = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLinuxDecorationsState {
}

#[pyproto]
impl PyObjectProtocol for AzLinuxDecorationsState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LinuxDecorationsState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::LinuxDecorationsState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSrgbEnumWrapper {
    #[classattr]
    const Enabled: AzSrgb = AzSrgb::Enabled;
    #[classattr]
    const Disabled: AzSrgb = AzSrgb::Disabled;
    #[classattr]
    const DontCare: AzSrgb = AzSrgb::DontCare;
}

#[pyproto]
impl PyObjectProtocol for AzSrgbEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Srgb = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::Srgb = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzSrgbEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzButton {
    #[new]
    fn new(/* args */) -> AzButton {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzButton {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::button::Button = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::button::Button = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzButtonOnClick {
}

#[pyproto]
impl PyObjectProtocol for AzButtonOnClick {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::button::ButtonOnClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::button::ButtonOnClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileInput {
    #[new]
    fn new(/* args */) -> AzFileInput {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_default_text(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_default_text(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzFileInput {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::file_input::FileInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::file_input::FileInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileInputStateWrapper {
}

#[pyproto]
impl PyObjectProtocol for AzFileInputStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::file_input::FileInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::file_input::FileInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileInputState {
}

#[pyproto]
impl PyObjectProtocol for AzFileInputState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::file_input::FileInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::file_input::FileInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileInputOnPathChange {
}

#[pyproto]
impl PyObjectProtocol for AzFileInputOnPathChange {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::file_input::FileInputOnPathChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::file_input::FileInputOnPathChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileInputOnPathChangeCallback {
}

#[pyproto]
impl PyObjectProtocol for AzFileInputOnPathChangeCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::file_input::FileInputOnPathChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::file_input::FileInputOnPathChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBox {
    #[new]
    fn new(/* args */) -> AzCheckBox {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzCheckBox {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::check_box::CheckBox = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::check_box::CheckBox = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBoxStateWrapper {
}

#[pyproto]
impl PyObjectProtocol for AzCheckBoxStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::check_box::CheckBoxStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::check_box::CheckBoxStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBoxOnToggle {
}

#[pyproto]
impl PyObjectProtocol for AzCheckBoxOnToggle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::check_box::CheckBoxOnToggle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::check_box::CheckBoxOnToggle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBoxState {
}

#[pyproto]
impl PyObjectProtocol for AzCheckBoxState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::check_box::CheckBoxState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::check_box::CheckBoxState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInput {
    #[new]
    fn new(/* args */) -> AzColorInput {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzColorInput {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::color_input::ColorInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::color_input::ColorInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInputStateWrapper {
}

#[pyproto]
impl PyObjectProtocol for AzColorInputStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::color_input::ColorInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::color_input::ColorInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInputState {
}

#[pyproto]
impl PyObjectProtocol for AzColorInputState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::color_input::ColorInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::color_input::ColorInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInputOnValueChange {
}

#[pyproto]
impl PyObjectProtocol for AzColorInputOnValueChange {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::color_input::ColorInputOnValueChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::color_input::ColorInputOnValueChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInputOnValueChangeCallback {
}

#[pyproto]
impl PyObjectProtocol for AzColorInputOnValueChangeCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::color_input::ColorInputOnValueChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::color_input::ColorInputOnValueChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInput {
    #[new]
    fn new(/* args */) -> AzTextInput {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_text(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_text(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_placeholder(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_placeholder(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_placeholder_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_placeholder_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_container_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_container_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_label_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_label_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzTextInput {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputStateWrapper {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputState {
    fn get_text(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzTextInputState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputSelectionEnumWrapper {
    #[classattr]
    fn All() -> AzTextInputSelectionEnumWrapper {
        AzTextInputSelectionEnumWrapper { inner: AzTextInputSelection::All }
    }
    #[staticmethod]
    fn FromTo(v: TextInputSelectionRange) -> AzTextInputSelectionEnumWrapper {
        AzTextInputSelectionEnumWrapper { inner: AzTextInputSelection::FromTo(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzTextInputSelection;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTextInputSelection::All => Ok(vec!["All".into_py(py), ().into_py(py)]),
            AzTextInputSelection::FromTo(v) => Ok(vec!["FromTo".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextInputSelectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputSelection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputSelection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputSelectionRange {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputSelectionRange {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputSelectionRange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputSelectionRange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnTextInput {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnTextInput {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputOnTextInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputOnTextInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnTextInputCallback {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnTextInputCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputOnTextInputCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputOnTextInputCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnVirtualKeyDown {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnVirtualKeyDown {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputOnVirtualKeyDown = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputOnVirtualKeyDown = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnVirtualKeyDownCallback {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnVirtualKeyDownCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputOnVirtualKeyDownCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputOnVirtualKeyDownCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnFocusLost {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnFocusLost {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputOnFocusLost = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputOnFocusLost = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnFocusLostCallback {
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnFocusLostCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputOnFocusLostCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputOnFocusLostCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnTextInputReturn {
}

#[pyproto]
impl PyObjectProtocol for AzOnTextInputReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::OnTextInputReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::OnTextInputReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputValidEnumWrapper {
    #[classattr]
    const Yes: AzTextInputValid = AzTextInputValid::Yes;
    #[classattr]
    const No: AzTextInputValid = AzTextInputValid::No;
}

#[pyproto]
impl PyObjectProtocol for AzTextInputValidEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputValid = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::TextInputValid = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzTextInputValidEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzNumberInput {
    #[new]
    fn new(/* args */) -> AzNumberInput {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_placeholder_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_placeholder_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_container_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_container_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_label_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_label_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzNumberInput {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::NumberInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::NumberInput = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputStateWrapper {
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::NumberInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::NumberInputStateWrapper = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputState {
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::NumberInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::NumberInputState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputOnValueChange {
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputOnValueChange {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::NumberInputOnValueChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::NumberInputOnValueChange = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputOnValueChangeCallback {
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputOnValueChangeCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::NumberInputOnValueChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::NumberInputOnValueChangeCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputOnFocusLost {
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputOnFocusLost {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::NumberInputOnFocusLost = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::NumberInputOnFocusLost = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputOnFocusLostCallback {
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputOnFocusLostCallback {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::NumberInputOnFocusLostCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::NumberInputOnFocusLostCallback = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzProgressBar {
    #[new]
    fn new(/* args */) -> AzProgressBar {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_height(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_height(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_container_background(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_container_style(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_bar_background(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_bar_background(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzProgressBar {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::progressbar::ProgressBar = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::progressbar::ProgressBar = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzProgressBarState {
}

#[pyproto]
impl PyObjectProtocol for AzProgressBarState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::progressbar::ProgressBarState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::progressbar::ProgressBarState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabHeader {
    #[new]
    fn new(/* args */) -> AzTabHeader {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_active_tab(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_active_tab(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzTabHeader {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::tabs::TabHeader = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::tabs::TabHeader = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabOnClick {
}

#[pyproto]
impl PyObjectProtocol for AzTabOnClick {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::tabs::TabOnClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::tabs::TabOnClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFrame {
    #[new]
    fn new(/* args */) -> AzFrame {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn set_flex_grow(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn with_flex_grow(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzFrame {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::frame::Frame = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::frame::Frame = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListView {
    #[new]
    fn new(/* args */) -> AzListView {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn with_rows(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn dom(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzListView {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListView = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListView = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewRow {
}

#[pyproto]
impl PyObjectProtocol for AzListViewRow {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewRow = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewRow = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnLazyLoadScroll {
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnLazyLoadScroll {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewOnLazyLoadScroll = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewOnLazyLoadScroll = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnColumnClick {
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnColumnClick {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewOnColumnClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewOnColumnClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnRowClick {
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnRowClick {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewOnRowClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewOnRowClick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameNode {
}

#[pyproto]
impl PyObjectProtocol for AzIFrameNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::IFrameNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::IFrameNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewState {
}

#[pyproto]
impl PyObjectProtocol for AzListViewState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabHeaderState {
}

#[pyproto]
impl PyObjectProtocol for AzTabHeaderState {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::tabs::TabHeaderState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::tabs::TabHeaderState = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTexture {
    #[new]
    fn new(/* args */) -> AzTexture {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn allocate_rgba8(/* args */) -> AzTexture {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn allocate_clip_mask(/* args */) -> AzTexture {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn clear(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn draw_clip_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn apply_fxaa(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzTexture {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::Texture = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::Texture = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlVoidPtrConst {
}

#[pyproto]
impl PyObjectProtocol for AzGlVoidPtrConst {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlVoidPtrConst = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlVoidPtrConst = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlVoidPtrMut {
}

#[pyproto]
impl PyObjectProtocol for AzGlVoidPtrMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlVoidPtrMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlVoidPtrMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextureFlags {
    #[staticmethod]
    fn default(/* args */) -> AzTextureFlags {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzTextureFlags {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::TextureFlags = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::TextureFlags = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlShaderPrecisionFormatReturn {
}

#[pyproto]
impl PyObjectProtocol for AzGlShaderPrecisionFormatReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlShaderPrecisionFormatReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlShaderPrecisionFormatReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlContextPtr {
    #[classattr]
    const ACCUM: u32 = 0x0100;
    #[classattr]
    const ACCUM_ALPHA_BITS: u32 = 0x0D5B;
    #[classattr]
    const ACCUM_BLUE_BITS: u32 = 0x0D5A;
    #[classattr]
    const ACCUM_BUFFER_BIT: u32 = 0x00000200;
    #[classattr]
    const ACCUM_CLEAR_VALUE: u32 = 0x0B80;
    #[classattr]
    const ACCUM_GREEN_BITS: u32 = 0x0D59;
    #[classattr]
    const ACCUM_RED_BITS: u32 = 0x0D58;
    #[classattr]
    const ACTIVE_ATTRIBUTES: u32 = 0x8B89;
    #[classattr]
    const ACTIVE_ATTRIBUTE_MAX_LENGTH: u32 = 0x8B8A;
    #[classattr]
    const ACTIVE_TEXTURE: u32 = 0x84E0;
    #[classattr]
    const ACTIVE_UNIFORMS: u32 = 0x8B86;
    #[classattr]
    const ACTIVE_UNIFORM_BLOCKS: u32 = 0x8A36;
    #[classattr]
    const ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: u32 = 0x8A35;
    #[classattr]
    const ACTIVE_UNIFORM_MAX_LENGTH: u32 = 0x8B87;
    #[classattr]
    const ADD: u32 = 0x0104;
    #[classattr]
    const ADD_SIGNED: u32 = 0x8574;
    #[classattr]
    const ALIASED_LINE_WIDTH_RANGE: u32 = 0x846E;
    #[classattr]
    const ALIASED_POINT_SIZE_RANGE: u32 = 0x846D;
    #[classattr]
    const ALL_ATTRIB_BITS: u32 = 0xFFFFFFFF;
    #[classattr]
    const ALPHA: u32 = 0x1906;
    #[classattr]
    const ALPHA12: u32 = 0x803D;
    #[classattr]
    const ALPHA16: u32 = 0x803E;
    #[classattr]
    const ALPHA16F_EXT: u32 = 0x881C;
    #[classattr]
    const ALPHA32F_EXT: u32 = 0x8816;
    #[classattr]
    const ALPHA4: u32 = 0x803B;
    #[classattr]
    const ALPHA8: u32 = 0x803C;
    #[classattr]
    const ALPHA8_EXT: u32 = 0x803C;
    #[classattr]
    const ALPHA_BIAS: u32 = 0x0D1D;
    #[classattr]
    const ALPHA_BITS: u32 = 0x0D55;
    #[classattr]
    const ALPHA_INTEGER: u32 = 0x8D97;
    #[classattr]
    const ALPHA_SCALE: u32 = 0x0D1C;
    #[classattr]
    const ALPHA_TEST: u32 = 0x0BC0;
    #[classattr]
    const ALPHA_TEST_FUNC: u32 = 0x0BC1;
    #[classattr]
    const ALPHA_TEST_REF: u32 = 0x0BC2;
    #[classattr]
    const ALREADY_SIGNALED: u32 = 0x911A;
    #[classattr]
    const ALWAYS: u32 = 0x0207;
    #[classattr]
    const AMBIENT: u32 = 0x1200;
    #[classattr]
    const AMBIENT_AND_DIFFUSE: u32 = 0x1602;
    #[classattr]
    const AND: u32 = 0x1501;
    #[classattr]
    const AND_INVERTED: u32 = 0x1504;
    #[classattr]
    const AND_REVERSE: u32 = 0x1502;
    #[classattr]
    const ANY_SAMPLES_PASSED: u32 = 0x8C2F;
    #[classattr]
    const ANY_SAMPLES_PASSED_CONSERVATIVE: u32 = 0x8D6A;
    #[classattr]
    const ARRAY_BUFFER: u32 = 0x8892;
    #[classattr]
    const ARRAY_BUFFER_BINDING: u32 = 0x8894;
    #[classattr]
    const ATTACHED_SHADERS: u32 = 0x8B85;
    #[classattr]
    const ATTRIB_STACK_DEPTH: u32 = 0x0BB0;
    #[classattr]
    const AUTO_NORMAL: u32 = 0x0D80;
    #[classattr]
    const AUX0: u32 = 0x0409;
    #[classattr]
    const AUX1: u32 = 0x040A;
    #[classattr]
    const AUX2: u32 = 0x040B;
    #[classattr]
    const AUX3: u32 = 0x040C;
    #[classattr]
    const AUX_BUFFERS: u32 = 0x0C00;
    #[classattr]
    const BACK: u32 = 0x0405;
    #[classattr]
    const BACK_LEFT: u32 = 0x0402;
    #[classattr]
    const BACK_RIGHT: u32 = 0x0403;
    #[classattr]
    const BGR: u32 = 0x80E0;
    #[classattr]
    const BGRA: u32 = 0x80E1;
    #[classattr]
    const BGRA8_EXT: u32 = 0x93A1;
    #[classattr]
    const BGRA_EXT: u32 = 0x80E1;
    #[classattr]
    const BGRA_INTEGER: u32 = 0x8D9B;
    #[classattr]
    const BGR_INTEGER: u32 = 0x8D9A;
    #[classattr]
    const BITMAP: u32 = 0x1A00;
    #[classattr]
    const BITMAP_TOKEN: u32 = 0x0704;
    #[classattr]
    const BLEND: u32 = 0x0BE2;
    #[classattr]
    const BLEND_ADVANCED_COHERENT_KHR: u32 = 0x9285;
    #[classattr]
    const BLEND_COLOR: u32 = 0x8005;
    #[classattr]
    const BLEND_DST: u32 = 0x0BE0;
    #[classattr]
    const BLEND_DST_ALPHA: u32 = 0x80CA;
    #[classattr]
    const BLEND_DST_RGB: u32 = 0x80C8;
    #[classattr]
    const BLEND_EQUATION: u32 = 0x8009;
    #[classattr]
    const BLEND_EQUATION_ALPHA: u32 = 0x883D;
    #[classattr]
    const BLEND_EQUATION_RGB: u32 = 0x8009;
    #[classattr]
    const BLEND_SRC: u32 = 0x0BE1;
    #[classattr]
    const BLEND_SRC_ALPHA: u32 = 0x80CB;
    #[classattr]
    const BLEND_SRC_RGB: u32 = 0x80C9;
    #[classattr]
    const BLUE: u32 = 0x1905;
    #[classattr]
    const BLUE_BIAS: u32 = 0x0D1B;
    #[classattr]
    const BLUE_BITS: u32 = 0x0D54;
    #[classattr]
    const BLUE_INTEGER: u32 = 0x8D96;
    #[classattr]
    const BLUE_SCALE: u32 = 0x0D1A;
    #[classattr]
    const BOOL: u32 = 0x8B56;
    #[classattr]
    const BOOL_VEC2: u32 = 0x8B57;
    #[classattr]
    const BOOL_VEC3: u32 = 0x8B58;
    #[classattr]
    const BOOL_VEC4: u32 = 0x8B59;
    #[classattr]
    const BUFFER: u32 = 0x82E0;
    #[classattr]
    const BUFFER_ACCESS: u32 = 0x88BB;
    #[classattr]
    const BUFFER_ACCESS_FLAGS: u32 = 0x911F;
    #[classattr]
    const BUFFER_KHR: u32 = 0x82E0;
    #[classattr]
    const BUFFER_MAPPED: u32 = 0x88BC;
    #[classattr]
    const BUFFER_MAP_LENGTH: u32 = 0x9120;
    #[classattr]
    const BUFFER_MAP_OFFSET: u32 = 0x9121;
    #[classattr]
    const BUFFER_MAP_POINTER: u32 = 0x88BD;
    #[classattr]
    const BUFFER_SIZE: u32 = 0x8764;
    #[classattr]
    const BUFFER_USAGE: u32 = 0x8765;
    #[classattr]
    const BYTE: u32 = 0x1400;
    #[classattr]
    const C3F_V3F: u32 = 0x2A24;
    #[classattr]
    const C4F_N3F_V3F: u32 = 0x2A26;
    #[classattr]
    const C4UB_V2F: u32 = 0x2A22;
    #[classattr]
    const C4UB_V3F: u32 = 0x2A23;
    #[classattr]
    const CCW: u32 = 0x0901;
    #[classattr]
    const CLAMP: u32 = 0x2900;
    #[classattr]
    const CLAMP_FRAGMENT_COLOR: u32 = 0x891B;
    #[classattr]
    const CLAMP_READ_COLOR: u32 = 0x891C;
    #[classattr]
    const CLAMP_TO_BORDER: u32 = 0x812D;
    #[classattr]
    const CLAMP_TO_EDGE: u32 = 0x812F;
    #[classattr]
    const CLAMP_VERTEX_COLOR: u32 = 0x891A;
    #[classattr]
    const CLEAR: u32 = 0x1500;
    #[classattr]
    const CLIENT_ACTIVE_TEXTURE: u32 = 0x84E1;
    #[classattr]
    const CLIENT_ALL_ATTRIB_BITS: u32 = 0xFFFFFFFF;
    #[classattr]
    const CLIENT_ATTRIB_STACK_DEPTH: u32 = 0x0BB1;
    #[classattr]
    const CLIENT_PIXEL_STORE_BIT: u32 = 0x00000001;
    #[classattr]
    const CLIENT_VERTEX_ARRAY_BIT: u32 = 0x00000002;
    #[classattr]
    const CLIP_DISTANCE0: u32 = 0x3000;
    #[classattr]
    const CLIP_DISTANCE1: u32 = 0x3001;
    #[classattr]
    const CLIP_DISTANCE2: u32 = 0x3002;
    #[classattr]
    const CLIP_DISTANCE3: u32 = 0x3003;
    #[classattr]
    const CLIP_DISTANCE4: u32 = 0x3004;
    #[classattr]
    const CLIP_DISTANCE5: u32 = 0x3005;
    #[classattr]
    const CLIP_DISTANCE6: u32 = 0x3006;
    #[classattr]
    const CLIP_DISTANCE7: u32 = 0x3007;
    #[classattr]
    const CLIP_PLANE0: u32 = 0x3000;
    #[classattr]
    const CLIP_PLANE1: u32 = 0x3001;
    #[classattr]
    const CLIP_PLANE2: u32 = 0x3002;
    #[classattr]
    const CLIP_PLANE3: u32 = 0x3003;
    #[classattr]
    const CLIP_PLANE4: u32 = 0x3004;
    #[classattr]
    const CLIP_PLANE5: u32 = 0x3005;
    #[classattr]
    const COEFF: u32 = 0x0A00;
    #[classattr]
    const COLOR: u32 = 0x1800;
    #[classattr]
    const COLORBURN_KHR: u32 = 0x929A;
    #[classattr]
    const COLORDODGE_KHR: u32 = 0x9299;
    #[classattr]
    const COLOR_ARRAY: u32 = 0x8076;
    #[classattr]
    const COLOR_ARRAY_BUFFER_BINDING: u32 = 0x8898;
    #[classattr]
    const COLOR_ARRAY_POINTER: u32 = 0x8090;
    #[classattr]
    const COLOR_ARRAY_SIZE: u32 = 0x8081;
    #[classattr]
    const COLOR_ARRAY_STRIDE: u32 = 0x8083;
    #[classattr]
    const COLOR_ARRAY_TYPE: u32 = 0x8082;
    #[classattr]
    const COLOR_ATTACHMENT0: u32 = 0x8CE0;
    #[classattr]
    const COLOR_ATTACHMENT1: u32 = 0x8CE1;
    #[classattr]
    const COLOR_ATTACHMENT10: u32 = 0x8CEA;
    #[classattr]
    const COLOR_ATTACHMENT11: u32 = 0x8CEB;
    #[classattr]
    const COLOR_ATTACHMENT12: u32 = 0x8CEC;
    #[classattr]
    const COLOR_ATTACHMENT13: u32 = 0x8CED;
    #[classattr]
    const COLOR_ATTACHMENT14: u32 = 0x8CEE;
    #[classattr]
    const COLOR_ATTACHMENT15: u32 = 0x8CEF;
    #[classattr]
    const COLOR_ATTACHMENT16: u32 = 0x8CF0;
    #[classattr]
    const COLOR_ATTACHMENT17: u32 = 0x8CF1;
    #[classattr]
    const COLOR_ATTACHMENT18: u32 = 0x8CF2;
    #[classattr]
    const COLOR_ATTACHMENT19: u32 = 0x8CF3;
    #[classattr]
    const COLOR_ATTACHMENT2: u32 = 0x8CE2;
    #[classattr]
    const COLOR_ATTACHMENT20: u32 = 0x8CF4;
    #[classattr]
    const COLOR_ATTACHMENT21: u32 = 0x8CF5;
    #[classattr]
    const COLOR_ATTACHMENT22: u32 = 0x8CF6;
    #[classattr]
    const COLOR_ATTACHMENT23: u32 = 0x8CF7;
    #[classattr]
    const COLOR_ATTACHMENT24: u32 = 0x8CF8;
    #[classattr]
    const COLOR_ATTACHMENT25: u32 = 0x8CF9;
    #[classattr]
    const COLOR_ATTACHMENT26: u32 = 0x8CFA;
    #[classattr]
    const COLOR_ATTACHMENT27: u32 = 0x8CFB;
    #[classattr]
    const COLOR_ATTACHMENT28: u32 = 0x8CFC;
    #[classattr]
    const COLOR_ATTACHMENT29: u32 = 0x8CFD;
    #[classattr]
    const COLOR_ATTACHMENT3: u32 = 0x8CE3;
    #[classattr]
    const COLOR_ATTACHMENT30: u32 = 0x8CFE;
    #[classattr]
    const COLOR_ATTACHMENT31: u32 = 0x8CFF;
    #[classattr]
    const COLOR_ATTACHMENT4: u32 = 0x8CE4;
    #[classattr]
    const COLOR_ATTACHMENT5: u32 = 0x8CE5;
    #[classattr]
    const COLOR_ATTACHMENT6: u32 = 0x8CE6;
    #[classattr]
    const COLOR_ATTACHMENT7: u32 = 0x8CE7;
    #[classattr]
    const COLOR_ATTACHMENT8: u32 = 0x8CE8;
    #[classattr]
    const COLOR_ATTACHMENT9: u32 = 0x8CE9;
    #[classattr]
    const COLOR_BUFFER_BIT: u32 = 0x00004000;
    #[classattr]
    const COLOR_CLEAR_VALUE: u32 = 0x0C22;
    #[classattr]
    const COLOR_INDEX: u32 = 0x1900;
    #[classattr]
    const COLOR_INDEXES: u32 = 0x1603;
    #[classattr]
    const COLOR_LOGIC_OP: u32 = 0x0BF2;
    #[classattr]
    const COLOR_MATERIAL: u32 = 0x0B57;
    #[classattr]
    const COLOR_MATERIAL_FACE: u32 = 0x0B55;
    #[classattr]
    const COLOR_MATERIAL_PARAMETER: u32 = 0x0B56;
    #[classattr]
    const COLOR_SUM: u32 = 0x8458;
    #[classattr]
    const COLOR_WRITEMASK: u32 = 0x0C23;
    #[classattr]
    const COMBINE: u32 = 0x8570;
    #[classattr]
    const COMBINE_ALPHA: u32 = 0x8572;
    #[classattr]
    const COMBINE_RGB: u32 = 0x8571;
    #[classattr]
    const COMPARE_REF_TO_TEXTURE: u32 = 0x884E;
    #[classattr]
    const COMPARE_R_TO_TEXTURE: u32 = 0x884E;
    #[classattr]
    const COMPILE: u32 = 0x1300;
    #[classattr]
    const COMPILE_AND_EXECUTE: u32 = 0x1301;
    #[classattr]
    const COMPILE_STATUS: u32 = 0x8B81;
    #[classattr]
    const COMPRESSED_ALPHA: u32 = 0x84E9;
    #[classattr]
    const COMPRESSED_INTENSITY: u32 = 0x84EC;
    #[classattr]
    const COMPRESSED_LUMINANCE: u32 = 0x84EA;
    #[classattr]
    const COMPRESSED_LUMINANCE_ALPHA: u32 = 0x84EB;
    #[classattr]
    const COMPRESSED_R11_EAC: u32 = 0x9270;
    #[classattr]
    const COMPRESSED_RED: u32 = 0x8225;
    #[classattr]
    const COMPRESSED_RED_RGTC1: u32 = 0x8DBB;
    #[classattr]
    const COMPRESSED_RG: u32 = 0x8226;
    #[classattr]
    const COMPRESSED_RG11_EAC: u32 = 0x9272;
    #[classattr]
    const COMPRESSED_RGB: u32 = 0x84ED;
    #[classattr]
    const COMPRESSED_RGB8_ETC2: u32 = 0x9274;
    #[classattr]
    const COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9276;
    #[classattr]
    const COMPRESSED_RGBA: u32 = 0x84EE;
    #[classattr]
    const COMPRESSED_RGBA8_ETC2_EAC: u32 = 0x9278;
    #[classattr]
    const COMPRESSED_RG_RGTC2: u32 = 0x8DBD;
    #[classattr]
    const COMPRESSED_SIGNED_R11_EAC: u32 = 0x9271;
    #[classattr]
    const COMPRESSED_SIGNED_RED_RGTC1: u32 = 0x8DBC;
    #[classattr]
    const COMPRESSED_SIGNED_RG11_EAC: u32 = 0x9273;
    #[classattr]
    const COMPRESSED_SIGNED_RG_RGTC2: u32 = 0x8DBE;
    #[classattr]
    const COMPRESSED_SLUMINANCE: u32 = 0x8C4A;
    #[classattr]
    const COMPRESSED_SLUMINANCE_ALPHA: u32 = 0x8C4B;
    #[classattr]
    const COMPRESSED_SRGB: u32 = 0x8C48;
    #[classattr]
    const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: u32 = 0x9279;
    #[classattr]
    const COMPRESSED_SRGB8_ETC2: u32 = 0x9275;
    #[classattr]
    const COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9277;
    #[classattr]
    const COMPRESSED_SRGB_ALPHA: u32 = 0x8C49;
    #[classattr]
    const COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A3;
    #[classattr]
    const CONDITION_SATISFIED: u32 = 0x911C;
    #[classattr]
    const CONSTANT: u32 = 0x8576;
    #[classattr]
    const CONSTANT_ALPHA: u32 = 0x8003;
    #[classattr]
    const CONSTANT_ATTENUATION: u32 = 0x1207;
    #[classattr]
    const CONSTANT_COLOR: u32 = 0x8001;
    #[classattr]
    const CONTEXT_COMPATIBILITY_PROFILE_BIT: u32 = 0x00000002;
    #[classattr]
    const CONTEXT_CORE_PROFILE_BIT: u32 = 0x00000001;
    #[classattr]
    const CONTEXT_FLAGS: u32 = 0x821E;
    #[classattr]
    const CONTEXT_FLAG_DEBUG_BIT: u32 = 0x00000002;
    #[classattr]
    const CONTEXT_FLAG_DEBUG_BIT_KHR: u32 = 0x00000002;
    #[classattr]
    const CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: u32 = 0x00000001;
    #[classattr]
    const CONTEXT_PROFILE_MASK: u32 = 0x9126;
    #[classattr]
    const COORD_REPLACE: u32 = 0x8862;
    #[classattr]
    const COPY: u32 = 0x1503;
    #[classattr]
    const COPY_INVERTED: u32 = 0x150C;
    #[classattr]
    const COPY_PIXEL_TOKEN: u32 = 0x0706;
    #[classattr]
    const COPY_READ_BUFFER: u32 = 0x8F36;
    #[classattr]
    const COPY_READ_BUFFER_BINDING: u32 = 0x8F36;
    #[classattr]
    const COPY_WRITE_BUFFER: u32 = 0x8F37;
    #[classattr]
    const COPY_WRITE_BUFFER_BINDING: u32 = 0x8F37;
    #[classattr]
    const CULL_FACE: u32 = 0x0B44;
    #[classattr]
    const CULL_FACE_MODE: u32 = 0x0B45;
    #[classattr]
    const CURRENT_BIT: u32 = 0x00000001;
    #[classattr]
    const CURRENT_COLOR: u32 = 0x0B00;
    #[classattr]
    const CURRENT_FOG_COORD: u32 = 0x8453;
    #[classattr]
    const CURRENT_FOG_COORDINATE: u32 = 0x8453;
    #[classattr]
    const CURRENT_INDEX: u32 = 0x0B01;
    #[classattr]
    const CURRENT_NORMAL: u32 = 0x0B02;
    #[classattr]
    const CURRENT_PROGRAM: u32 = 0x8B8D;
    #[classattr]
    const CURRENT_QUERY: u32 = 0x8865;
    #[classattr]
    const CURRENT_QUERY_EXT: u32 = 0x8865;
    #[classattr]
    const CURRENT_RASTER_COLOR: u32 = 0x0B04;
    #[classattr]
    const CURRENT_RASTER_DISTANCE: u32 = 0x0B09;
    #[classattr]
    const CURRENT_RASTER_INDEX: u32 = 0x0B05;
    #[classattr]
    const CURRENT_RASTER_POSITION: u32 = 0x0B07;
    #[classattr]
    const CURRENT_RASTER_POSITION_VALID: u32 = 0x0B08;
    #[classattr]
    const CURRENT_RASTER_SECONDARY_COLOR: u32 = 0x845F;
    #[classattr]
    const CURRENT_RASTER_TEXTURE_COORDS: u32 = 0x0B06;
    #[classattr]
    const CURRENT_SECONDARY_COLOR: u32 = 0x8459;
    #[classattr]
    const CURRENT_TEXTURE_COORDS: u32 = 0x0B03;
    #[classattr]
    const CURRENT_VERTEX_ATTRIB: u32 = 0x8626;
    #[classattr]
    const CW: u32 = 0x0900;
    #[classattr]
    const DARKEN_KHR: u32 = 0x9297;
    #[classattr]
    const DEBUG_CALLBACK_FUNCTION: u32 = 0x8244;
    #[classattr]
    const DEBUG_CALLBACK_FUNCTION_KHR: u32 = 0x8244;
    #[classattr]
    const DEBUG_CALLBACK_USER_PARAM: u32 = 0x8245;
    #[classattr]
    const DEBUG_CALLBACK_USER_PARAM_KHR: u32 = 0x8245;
    #[classattr]
    const DEBUG_GROUP_STACK_DEPTH: u32 = 0x826D;
    #[classattr]
    const DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826D;
    #[classattr]
    const DEBUG_LOGGED_MESSAGES: u32 = 0x9145;
    #[classattr]
    const DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9145;
    #[classattr]
    const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: u32 = 0x8243;
    #[classattr]
    const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR: u32 = 0x8243;
    #[classattr]
    const DEBUG_OUTPUT: u32 = 0x92E0;
    #[classattr]
    const DEBUG_OUTPUT_KHR: u32 = 0x92E0;
    #[classattr]
    const DEBUG_OUTPUT_SYNCHRONOUS: u32 = 0x8242;
    #[classattr]
    const DEBUG_OUTPUT_SYNCHRONOUS_KHR: u32 = 0x8242;
    #[classattr]
    const DEBUG_SEVERITY_HIGH: u32 = 0x9146;
    #[classattr]
    const DEBUG_SEVERITY_HIGH_KHR: u32 = 0x9146;
    #[classattr]
    const DEBUG_SEVERITY_LOW: u32 = 0x9148;
    #[classattr]
    const DEBUG_SEVERITY_LOW_KHR: u32 = 0x9148;
    #[classattr]
    const DEBUG_SEVERITY_MEDIUM: u32 = 0x9147;
    #[classattr]
    const DEBUG_SEVERITY_MEDIUM_KHR: u32 = 0x9147;
    #[classattr]
    const DEBUG_SEVERITY_NOTIFICATION: u32 = 0x826B;
    #[classattr]
    const DEBUG_SEVERITY_NOTIFICATION_KHR: u32 = 0x826B;
    #[classattr]
    const DEBUG_SOURCE_API: u32 = 0x8246;
    #[classattr]
    const DEBUG_SOURCE_API_KHR: u32 = 0x8246;
    #[classattr]
    const DEBUG_SOURCE_APPLICATION: u32 = 0x824A;
    #[classattr]
    const DEBUG_SOURCE_APPLICATION_KHR: u32 = 0x824A;
    #[classattr]
    const DEBUG_SOURCE_OTHER: u32 = 0x824B;
    #[classattr]
    const DEBUG_SOURCE_OTHER_KHR: u32 = 0x824B;
    #[classattr]
    const DEBUG_SOURCE_SHADER_COMPILER: u32 = 0x8248;
    #[classattr]
    const DEBUG_SOURCE_SHADER_COMPILER_KHR: u32 = 0x8248;
    #[classattr]
    const DEBUG_SOURCE_THIRD_PARTY: u32 = 0x8249;
    #[classattr]
    const DEBUG_SOURCE_THIRD_PARTY_KHR: u32 = 0x8249;
    #[classattr]
    const DEBUG_SOURCE_WINDOW_SYSTEM: u32 = 0x8247;
    #[classattr]
    const DEBUG_SOURCE_WINDOW_SYSTEM_KHR: u32 = 0x8247;
    #[classattr]
    const DEBUG_TYPE_DEPRECATED_BEHAVIOR: u32 = 0x824D;
    #[classattr]
    const DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR: u32 = 0x824D;
    #[classattr]
    const DEBUG_TYPE_ERROR: u32 = 0x824C;
    #[classattr]
    const DEBUG_TYPE_ERROR_KHR: u32 = 0x824C;
    #[classattr]
    const DEBUG_TYPE_MARKER: u32 = 0x8268;
    #[classattr]
    const DEBUG_TYPE_MARKER_KHR: u32 = 0x8268;
    #[classattr]
    const DEBUG_TYPE_OTHER: u32 = 0x8251;
    #[classattr]
    const DEBUG_TYPE_OTHER_KHR: u32 = 0x8251;
    #[classattr]
    const DEBUG_TYPE_PERFORMANCE: u32 = 0x8250;
    #[classattr]
    const DEBUG_TYPE_PERFORMANCE_KHR: u32 = 0x8250;
    #[classattr]
    const DEBUG_TYPE_POP_GROUP: u32 = 0x826A;
    #[classattr]
    const DEBUG_TYPE_POP_GROUP_KHR: u32 = 0x826A;
    #[classattr]
    const DEBUG_TYPE_PORTABILITY: u32 = 0x824F;
    #[classattr]
    const DEBUG_TYPE_PORTABILITY_KHR: u32 = 0x824F;
    #[classattr]
    const DEBUG_TYPE_PUSH_GROUP: u32 = 0x8269;
    #[classattr]
    const DEBUG_TYPE_PUSH_GROUP_KHR: u32 = 0x8269;
    #[classattr]
    const DEBUG_TYPE_UNDEFINED_BEHAVIOR: u32 = 0x824E;
    #[classattr]
    const DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR: u32 = 0x824E;
    #[classattr]
    const DECAL: u32 = 0x2101;
    #[classattr]
    const DECR: u32 = 0x1E03;
    #[classattr]
    const DECR_WRAP: u32 = 0x8508;
    #[classattr]
    const DELETE_STATUS: u32 = 0x8B80;
    #[classattr]
    const DEPTH: u32 = 0x1801;
    #[classattr]
    const DEPTH24_STENCIL8: u32 = 0x88F0;
    #[classattr]
    const DEPTH32F_STENCIL8: u32 = 0x8CAD;
    #[classattr]
    const DEPTH_ATTACHMENT: u32 = 0x8D00;
    #[classattr]
    const DEPTH_BIAS: u32 = 0x0D1F;
    #[classattr]
    const DEPTH_BITS: u32 = 0x0D56;
    #[classattr]
    const DEPTH_BUFFER_BIT: u32 = 0x00000100;
    #[classattr]
    const DEPTH_CLAMP: u32 = 0x864F;
    #[classattr]
    const DEPTH_CLEAR_VALUE: u32 = 0x0B73;
    #[classattr]
    const DEPTH_COMPONENT: u32 = 0x1902;
    #[classattr]
    const DEPTH_COMPONENT16: u32 = 0x81A5;
    #[classattr]
    const DEPTH_COMPONENT24: u32 = 0x81A6;
    #[classattr]
    const DEPTH_COMPONENT32: u32 = 0x81A7;
    #[classattr]
    const DEPTH_COMPONENT32F: u32 = 0x8CAC;
    #[classattr]
    const DEPTH_FUNC: u32 = 0x0B74;
    #[classattr]
    const DEPTH_RANGE: u32 = 0x0B70;
    #[classattr]
    const DEPTH_SCALE: u32 = 0x0D1E;
    #[classattr]
    const DEPTH_STENCIL: u32 = 0x84F9;
    #[classattr]
    const DEPTH_STENCIL_ATTACHMENT: u32 = 0x821A;
    #[classattr]
    const DEPTH_TEST: u32 = 0x0B71;
    #[classattr]
    const DEPTH_TEXTURE_MODE: u32 = 0x884B;
    #[classattr]
    const DEPTH_WRITEMASK: u32 = 0x0B72;
    #[classattr]
    const DIFFERENCE_KHR: u32 = 0x929E;
    #[classattr]
    const DIFFUSE: u32 = 0x1201;
    #[classattr]
    const DISPLAY_LIST: u32 = 0x82E7;
    #[classattr]
    const DITHER: u32 = 0x0BD0;
    #[classattr]
    const DOMAIN: u32 = 0x0A02;
    #[classattr]
    const DONT_CARE: u32 = 0x1100;
    #[classattr]
    const DOT3_RGB: u32 = 0x86AE;
    #[classattr]
    const DOT3_RGBA: u32 = 0x86AF;
    #[classattr]
    const DOUBLE: u32 = 0x140A;
    #[classattr]
    const DOUBLEBUFFER: u32 = 0x0C32;
    #[classattr]
    const DRAW_BUFFER: u32 = 0x0C01;
    #[classattr]
    const DRAW_BUFFER0: u32 = 0x8825;
    #[classattr]
    const DRAW_BUFFER1: u32 = 0x8826;
    #[classattr]
    const DRAW_BUFFER10: u32 = 0x882F;
    #[classattr]
    const DRAW_BUFFER11: u32 = 0x8830;
    #[classattr]
    const DRAW_BUFFER12: u32 = 0x8831;
    #[classattr]
    const DRAW_BUFFER13: u32 = 0x8832;
    #[classattr]
    const DRAW_BUFFER14: u32 = 0x8833;
    #[classattr]
    const DRAW_BUFFER15: u32 = 0x8834;
    #[classattr]
    const DRAW_BUFFER2: u32 = 0x8827;
    #[classattr]
    const DRAW_BUFFER3: u32 = 0x8828;
    #[classattr]
    const DRAW_BUFFER4: u32 = 0x8829;
    #[classattr]
    const DRAW_BUFFER5: u32 = 0x882A;
    #[classattr]
    const DRAW_BUFFER6: u32 = 0x882B;
    #[classattr]
    const DRAW_BUFFER7: u32 = 0x882C;
    #[classattr]
    const DRAW_BUFFER8: u32 = 0x882D;
    #[classattr]
    const DRAW_BUFFER9: u32 = 0x882E;
    #[classattr]
    const DRAW_FRAMEBUFFER: u32 = 0x8CA9;
    #[classattr]
    const DRAW_FRAMEBUFFER_BINDING: u32 = 0x8CA6;
    #[classattr]
    const DRAW_PIXELS_APPLE: u32 = 0x8A0A;
    #[classattr]
    const DRAW_PIXEL_TOKEN: u32 = 0x0705;
    #[classattr]
    const DST_ALPHA: u32 = 0x0304;
    #[classattr]
    const DST_COLOR: u32 = 0x0306;
    #[classattr]
    const DYNAMIC_COPY: u32 = 0x88EA;
    #[classattr]
    const DYNAMIC_DRAW: u32 = 0x88E8;
    #[classattr]
    const DYNAMIC_READ: u32 = 0x88E9;
    #[classattr]
    const EDGE_FLAG: u32 = 0x0B43;
    #[classattr]
    const EDGE_FLAG_ARRAY: u32 = 0x8079;
    #[classattr]
    const EDGE_FLAG_ARRAY_BUFFER_BINDING: u32 = 0x889B;
    #[classattr]
    const EDGE_FLAG_ARRAY_POINTER: u32 = 0x8093;
    #[classattr]
    const EDGE_FLAG_ARRAY_STRIDE: u32 = 0x808C;
    #[classattr]
    const ELEMENT_ARRAY_BUFFER: u32 = 0x8893;
    #[classattr]
    const ELEMENT_ARRAY_BUFFER_BINDING: u32 = 0x8895;
    #[classattr]
    const EMISSION: u32 = 0x1600;
    #[classattr]
    const ENABLE_BIT: u32 = 0x00002000;
    #[classattr]
    const EQUAL: u32 = 0x0202;
    #[classattr]
    const EQUIV: u32 = 0x1509;
    #[classattr]
    const EVAL_BIT: u32 = 0x00010000;
    #[classattr]
    const EXCLUSION_KHR: u32 = 0x92A0;
    #[classattr]
    const EXP: u32 = 0x0800;
    #[classattr]
    const EXP2: u32 = 0x0801;
    #[classattr]
    const EXTENSIONS: u32 = 0x1F03;
    #[classattr]
    const EYE_LINEAR: u32 = 0x2400;
    #[classattr]
    const EYE_PLANE: u32 = 0x2502;
    #[classattr]
    const FALSE: u8 = 0;
    #[classattr]
    const FASTEST: u32 = 0x1101;
    #[classattr]
    const FEEDBACK: u32 = 0x1C01;
    #[classattr]
    const FEEDBACK_BUFFER_POINTER: u32 = 0x0DF0;
    #[classattr]
    const FEEDBACK_BUFFER_SIZE: u32 = 0x0DF1;
    #[classattr]
    const FEEDBACK_BUFFER_TYPE: u32 = 0x0DF2;
    #[classattr]
    const FENCE_APPLE: u32 = 0x8A0B;
    #[classattr]
    const FILL: u32 = 0x1B02;
    #[classattr]
    const FIRST_VERTEX_CONVENTION: u32 = 0x8E4D;
    #[classattr]
    const FIXED: u32 = 0x140C;
    #[classattr]
    const FIXED_ONLY: u32 = 0x891D;
    #[classattr]
    const FLAT: u32 = 0x1D00;
    #[classattr]
    const FLOAT: u32 = 0x1406;
    #[classattr]
    const FLOAT_32_UNSIGNED_INT_24_8_REV: u32 = 0x8DAD;
    #[classattr]
    const FLOAT_MAT2: u32 = 0x8B5A;
    #[classattr]
    const FLOAT_MAT2x3: u32 = 0x8B65;
    #[classattr]
    const FLOAT_MAT2x4: u32 = 0x8B66;
    #[classattr]
    const FLOAT_MAT3: u32 = 0x8B5B;
    #[classattr]
    const FLOAT_MAT3x2: u32 = 0x8B67;
    #[classattr]
    const FLOAT_MAT3x4: u32 = 0x8B68;
    #[classattr]
    const FLOAT_MAT4: u32 = 0x8B5C;
    #[classattr]
    const FLOAT_MAT4x2: u32 = 0x8B69;
    #[classattr]
    const FLOAT_MAT4x3: u32 = 0x8B6A;
    #[classattr]
    const FLOAT_VEC2: u32 = 0x8B50;
    #[classattr]
    const FLOAT_VEC3: u32 = 0x8B51;
    #[classattr]
    const FLOAT_VEC4: u32 = 0x8B52;
    #[classattr]
    const FOG: u32 = 0x0B60;
    #[classattr]
    const FOG_BIT: u32 = 0x00000080;
    #[classattr]
    const FOG_COLOR: u32 = 0x0B66;
    #[classattr]
    const FOG_COORD: u32 = 0x8451;
    #[classattr]
    const FOG_COORDINATE: u32 = 0x8451;
    #[classattr]
    const FOG_COORDINATE_ARRAY: u32 = 0x8457;
    #[classattr]
    const FOG_COORDINATE_ARRAY_BUFFER_BINDING: u32 = 0x889D;
    #[classattr]
    const FOG_COORDINATE_ARRAY_POINTER: u32 = 0x8456;
    #[classattr]
    const FOG_COORDINATE_ARRAY_STRIDE: u32 = 0x8455;
    #[classattr]
    const FOG_COORDINATE_ARRAY_TYPE: u32 = 0x8454;
    #[classattr]
    const FOG_COORDINATE_SOURCE: u32 = 0x8450;
    #[classattr]
    const FOG_COORD_ARRAY: u32 = 0x8457;
    #[classattr]
    const FOG_COORD_ARRAY_BUFFER_BINDING: u32 = 0x889D;
    #[classattr]
    const FOG_COORD_ARRAY_POINTER: u32 = 0x8456;
    #[classattr]
    const FOG_COORD_ARRAY_STRIDE: u32 = 0x8455;
    #[classattr]
    const FOG_COORD_ARRAY_TYPE: u32 = 0x8454;
    #[classattr]
    const FOG_COORD_SRC: u32 = 0x8450;
    #[classattr]
    const FOG_DENSITY: u32 = 0x0B62;
    #[classattr]
    const FOG_END: u32 = 0x0B64;
    #[classattr]
    const FOG_HINT: u32 = 0x0C54;
    #[classattr]
    const FOG_INDEX: u32 = 0x0B61;
    #[classattr]
    const FOG_MODE: u32 = 0x0B65;
    #[classattr]
    const FOG_START: u32 = 0x0B63;
    #[classattr]
    const FRAGMENT_DEPTH: u32 = 0x8452;
    #[classattr]
    const FRAGMENT_SHADER: u32 = 0x8B30;
    #[classattr]
    const FRAGMENT_SHADER_DERIVATIVE_HINT: u32 = 0x8B8B;
    #[classattr]
    const FRAMEBUFFER: u32 = 0x8D40;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: u32 = 0x8215;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_ANGLE: u32 = 0x93A3;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: u32 = 0x8214;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: u32 = 0x8210;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: u32 = 0x8211;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: u32 = 0x8216;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: u32 = 0x8213;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_LAYERED: u32 = 0x8DA7;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: u32 = 0x8CD1;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: u32 = 0x8CD0;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_RED_SIZE: u32 = 0x8212;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: u32 = 0x8217;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: u32 = 0x8CD3;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: u32 = 0x8CD4;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: u32 = 0x8CD2;
    #[classattr]
    const FRAMEBUFFER_BINDING: u32 = 0x8CA6;
    #[classattr]
    const FRAMEBUFFER_COMPLETE: u32 = 0x8CD5;
    #[classattr]
    const FRAMEBUFFER_DEFAULT: u32 = 0x8218;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_ATTACHMENT: u32 = 0x8CD6;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_DIMENSIONS: u32 = 0x8CD9;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: u32 = 0x8CDB;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS: u32 = 0x8DA8;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: u32 = 0x8CD7;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: u32 = 0x8D56;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_READ_BUFFER: u32 = 0x8CDC;
    #[classattr]
    const FRAMEBUFFER_SRGB: u32 = 0x8DB9;
    #[classattr]
    const FRAMEBUFFER_UNDEFINED: u32 = 0x8219;
    #[classattr]
    const FRAMEBUFFER_UNSUPPORTED: u32 = 0x8CDD;
    #[classattr]
    const FRONT: u32 = 0x0404;
    #[classattr]
    const FRONT_AND_BACK: u32 = 0x0408;
    #[classattr]
    const FRONT_FACE: u32 = 0x0B46;
    #[classattr]
    const FRONT_LEFT: u32 = 0x0400;
    #[classattr]
    const FRONT_RIGHT: u32 = 0x0401;
    #[classattr]
    const FUNC_ADD: u32 = 0x8006;
    #[classattr]
    const FUNC_REVERSE_SUBTRACT: u32 = 0x800B;
    #[classattr]
    const FUNC_SUBTRACT: u32 = 0x800A;
    #[classattr]
    const GENERATE_MIPMAP: u32 = 0x8191;
    #[classattr]
    const GENERATE_MIPMAP_HINT: u32 = 0x8192;
    #[classattr]
    const GEOMETRY_INPUT_TYPE: u32 = 0x8917;
    #[classattr]
    const GEOMETRY_OUTPUT_TYPE: u32 = 0x8918;
    #[classattr]
    const GEOMETRY_SHADER: u32 = 0x8DD9;
    #[classattr]
    const GEOMETRY_VERTICES_OUT: u32 = 0x8916;
    #[classattr]
    const GEQUAL: u32 = 0x0206;
    #[classattr]
    const GPU_DISJOINT_EXT: u32 = 0x8FBB;
    #[classattr]
    const GREATER: u32 = 0x0204;
    #[classattr]
    const GREEN: u32 = 0x1904;
    #[classattr]
    const GREEN_BIAS: u32 = 0x0D19;
    #[classattr]
    const GREEN_BITS: u32 = 0x0D53;
    #[classattr]
    const GREEN_INTEGER: u32 = 0x8D95;
    #[classattr]
    const GREEN_SCALE: u32 = 0x0D18;
    #[classattr]
    const HALF_FLOAT: u32 = 0x140B;
    #[classattr]
    const HALF_FLOAT_OES: u32 = 0x8D61;
    #[classattr]
    const HARDLIGHT_KHR: u32 = 0x929B;
    #[classattr]
    const HIGH_FLOAT: u32 = 0x8DF2;
    #[classattr]
    const HIGH_INT: u32 = 0x8DF5;
    #[classattr]
    const HINT_BIT: u32 = 0x00008000;
    #[classattr]
    const HSL_COLOR_KHR: u32 = 0x92AF;
    #[classattr]
    const HSL_HUE_KHR: u32 = 0x92AD;
    #[classattr]
    const HSL_LUMINOSITY_KHR: u32 = 0x92B0;
    #[classattr]
    const HSL_SATURATION_KHR: u32 = 0x92AE;
    #[classattr]
    const IMPLEMENTATION_COLOR_READ_FORMAT: u32 = 0x8B9B;
    #[classattr]
    const IMPLEMENTATION_COLOR_READ_TYPE: u32 = 0x8B9A;
    #[classattr]
    const INCR: u32 = 0x1E02;
    #[classattr]
    const INCR_WRAP: u32 = 0x8507;
    #[classattr]
    const INDEX: u32 = 0x8222;
    #[classattr]
    const INDEX_ARRAY: u32 = 0x8077;
    #[classattr]
    const INDEX_ARRAY_BUFFER_BINDING: u32 = 0x8899;
    #[classattr]
    const INDEX_ARRAY_POINTER: u32 = 0x8091;
    #[classattr]
    const INDEX_ARRAY_STRIDE: u32 = 0x8086;
    #[classattr]
    const INDEX_ARRAY_TYPE: u32 = 0x8085;
    #[classattr]
    const INDEX_BITS: u32 = 0x0D51;
    #[classattr]
    const INDEX_CLEAR_VALUE: u32 = 0x0C20;
    #[classattr]
    const INDEX_LOGIC_OP: u32 = 0x0BF1;
    #[classattr]
    const INDEX_MODE: u32 = 0x0C30;
    #[classattr]
    const INDEX_OFFSET: u32 = 0x0D13;
    #[classattr]
    const INDEX_SHIFT: u32 = 0x0D12;
    #[classattr]
    const INDEX_WRITEMASK: u32 = 0x0C21;
    #[classattr]
    const INFO_LOG_LENGTH: u32 = 0x8B84;
    #[classattr]
    const INT: u32 = 0x1404;
    #[classattr]
    const INTENSITY: u32 = 0x8049;
    #[classattr]
    const INTENSITY12: u32 = 0x804C;
    #[classattr]
    const INTENSITY16: u32 = 0x804D;
    #[classattr]
    const INTENSITY4: u32 = 0x804A;
    #[classattr]
    const INTENSITY8: u32 = 0x804B;
    #[classattr]
    const INTERLEAVED_ATTRIBS: u32 = 0x8C8C;
    #[classattr]
    const INTERPOLATE: u32 = 0x8575;
    #[classattr]
    const INT_2_10_10_10_REV: u32 = 0x8D9F;
    #[classattr]
    const INT_SAMPLER_1D: u32 = 0x8DC9;
    #[classattr]
    const INT_SAMPLER_1D_ARRAY: u32 = 0x8DCE;
    #[classattr]
    const INT_SAMPLER_2D: u32 = 0x8DCA;
    #[classattr]
    const INT_SAMPLER_2D_ARRAY: u32 = 0x8DCF;
    #[classattr]
    const INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x9109;
    #[classattr]
    const INT_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910C;
    #[classattr]
    const INT_SAMPLER_2D_RECT: u32 = 0x8DCD;
    #[classattr]
    const INT_SAMPLER_3D: u32 = 0x8DCB;
    #[classattr]
    const INT_SAMPLER_BUFFER: u32 = 0x8DD0;
    #[classattr]
    const INT_SAMPLER_CUBE: u32 = 0x8DCC;
    #[classattr]
    const INT_VEC2: u32 = 0x8B53;
    #[classattr]
    const INT_VEC3: u32 = 0x8B54;
    #[classattr]
    const INT_VEC4: u32 = 0x8B55;
    #[classattr]
    const INVALID_ENUM: u32 = 0x0500;
    #[classattr]
    const INVALID_FRAMEBUFFER_OPERATION: u32 = 0x0506;
    #[classattr]
    const INVALID_INDEX: u32 = 0xFFFFFFFF;
    #[classattr]
    const INVALID_OPERATION: u32 = 0x0502;
    #[classattr]
    const INVALID_VALUE: u32 = 0x0501;
    #[classattr]
    const INVERT: u32 = 0x150A;
    #[classattr]
    const KEEP: u32 = 0x1E00;
    #[classattr]
    const LAST_VERTEX_CONVENTION: u32 = 0x8E4E;
    #[classattr]
    const LEFT: u32 = 0x0406;
    #[classattr]
    const LEQUAL: u32 = 0x0203;
    #[classattr]
    const LESS: u32 = 0x0201;
    #[classattr]
    const LIGHT0: u32 = 0x4000;
    #[classattr]
    const LIGHT1: u32 = 0x4001;
    #[classattr]
    const LIGHT2: u32 = 0x4002;
    #[classattr]
    const LIGHT3: u32 = 0x4003;
    #[classattr]
    const LIGHT4: u32 = 0x4004;
    #[classattr]
    const LIGHT5: u32 = 0x4005;
    #[classattr]
    const LIGHT6: u32 = 0x4006;
    #[classattr]
    const LIGHT7: u32 = 0x4007;
    #[classattr]
    const LIGHTEN_KHR: u32 = 0x9298;
    #[classattr]
    const LIGHTING: u32 = 0x0B50;
    #[classattr]
    const LIGHTING_BIT: u32 = 0x00000040;
    #[classattr]
    const LIGHT_MODEL_AMBIENT: u32 = 0x0B53;
    #[classattr]
    const LIGHT_MODEL_COLOR_CONTROL: u32 = 0x81F8;
    #[classattr]
    const LIGHT_MODEL_LOCAL_VIEWER: u32 = 0x0B51;
    #[classattr]
    const LIGHT_MODEL_TWO_SIDE: u32 = 0x0B52;
    #[classattr]
    const LINE: u32 = 0x1B01;
    #[classattr]
    const LINEAR: u32 = 0x2601;
    #[classattr]
    const LINEAR_ATTENUATION: u32 = 0x1208;
    #[classattr]
    const LINEAR_MIPMAP_LINEAR: u32 = 0x2703;
    #[classattr]
    const LINEAR_MIPMAP_NEAREST: u32 = 0x2701;
    #[classattr]
    const LINES: u32 = 0x0001;
    #[classattr]
    const LINES_ADJACENCY: u32 = 0x000A;
    #[classattr]
    const LINE_BIT: u32 = 0x00000004;
    #[classattr]
    const LINE_LOOP: u32 = 0x0002;
    #[classattr]
    const LINE_RESET_TOKEN: u32 = 0x0707;
    #[classattr]
    const LINE_SMOOTH: u32 = 0x0B20;
    #[classattr]
    const LINE_SMOOTH_HINT: u32 = 0x0C52;
    #[classattr]
    const LINE_STIPPLE: u32 = 0x0B24;
    #[classattr]
    const LINE_STIPPLE_PATTERN: u32 = 0x0B25;
    #[classattr]
    const LINE_STIPPLE_REPEAT: u32 = 0x0B26;
    #[classattr]
    const LINE_STRIP: u32 = 0x0003;
    #[classattr]
    const LINE_STRIP_ADJACENCY: u32 = 0x000B;
    #[classattr]
    const LINE_TOKEN: u32 = 0x0702;
    #[classattr]
    const LINE_WIDTH: u32 = 0x0B21;
    #[classattr]
    const LINE_WIDTH_GRANULARITY: u32 = 0x0B23;
    #[classattr]
    const LINE_WIDTH_RANGE: u32 = 0x0B22;
    #[classattr]
    const LINK_STATUS: u32 = 0x8B82;
    #[classattr]
    const LIST_BASE: u32 = 0x0B32;
    #[classattr]
    const LIST_BIT: u32 = 0x00020000;
    #[classattr]
    const LIST_INDEX: u32 = 0x0B33;
    #[classattr]
    const LIST_MODE: u32 = 0x0B30;
    #[classattr]
    const LOAD: u32 = 0x0101;
    #[classattr]
    const LOGIC_OP: u32 = 0x0BF1;
    #[classattr]
    const LOGIC_OP_MODE: u32 = 0x0BF0;
    #[classattr]
    const LOWER_LEFT: u32 = 0x8CA1;
    #[classattr]
    const LOW_FLOAT: u32 = 0x8DF0;
    #[classattr]
    const LOW_INT: u32 = 0x8DF3;
    #[classattr]
    const LUMINANCE: u32 = 0x1909;
    #[classattr]
    const LUMINANCE12: u32 = 0x8041;
    #[classattr]
    const LUMINANCE12_ALPHA12: u32 = 0x8047;
    #[classattr]
    const LUMINANCE12_ALPHA4: u32 = 0x8046;
    #[classattr]
    const LUMINANCE16: u32 = 0x8042;
    #[classattr]
    const LUMINANCE16F_EXT: u32 = 0x881E;
    #[classattr]
    const LUMINANCE16_ALPHA16: u32 = 0x8048;
    #[classattr]
    const LUMINANCE32F_EXT: u32 = 0x8818;
    #[classattr]
    const LUMINANCE4: u32 = 0x803F;
    #[classattr]
    const LUMINANCE4_ALPHA4: u32 = 0x8043;
    #[classattr]
    const LUMINANCE6_ALPHA2: u32 = 0x8044;
    #[classattr]
    const LUMINANCE8: u32 = 0x8040;
    #[classattr]
    const LUMINANCE8_ALPHA8: u32 = 0x8045;
    #[classattr]
    const LUMINANCE8_ALPHA8_EXT: u32 = 0x8045;
    #[classattr]
    const LUMINANCE8_EXT: u32 = 0x8040;
    #[classattr]
    const LUMINANCE_ALPHA: u32 = 0x190A;
    #[classattr]
    const LUMINANCE_ALPHA16F_EXT: u32 = 0x881F;
    #[classattr]
    const LUMINANCE_ALPHA32F_EXT: u32 = 0x8819;
    #[classattr]
    const MAJOR_VERSION: u32 = 0x821B;
    #[classattr]
    const MAP1_COLOR_4: u32 = 0x0D90;
    #[classattr]
    const MAP1_GRID_DOMAIN: u32 = 0x0DD0;
    #[classattr]
    const MAP1_GRID_SEGMENTS: u32 = 0x0DD1;
    #[classattr]
    const MAP1_INDEX: u32 = 0x0D91;
    #[classattr]
    const MAP1_NORMAL: u32 = 0x0D92;
    #[classattr]
    const MAP1_TEXTURE_COORD_1: u32 = 0x0D93;
    #[classattr]
    const MAP1_TEXTURE_COORD_2: u32 = 0x0D94;
    #[classattr]
    const MAP1_TEXTURE_COORD_3: u32 = 0x0D95;
    #[classattr]
    const MAP1_TEXTURE_COORD_4: u32 = 0x0D96;
    #[classattr]
    const MAP1_VERTEX_3: u32 = 0x0D97;
    #[classattr]
    const MAP1_VERTEX_4: u32 = 0x0D98;
    #[classattr]
    const MAP2_COLOR_4: u32 = 0x0DB0;
    #[classattr]
    const MAP2_GRID_DOMAIN: u32 = 0x0DD2;
    #[classattr]
    const MAP2_GRID_SEGMENTS: u32 = 0x0DD3;
    #[classattr]
    const MAP2_INDEX: u32 = 0x0DB1;
    #[classattr]
    const MAP2_NORMAL: u32 = 0x0DB2;
    #[classattr]
    const MAP2_TEXTURE_COORD_1: u32 = 0x0DB3;
    #[classattr]
    const MAP2_TEXTURE_COORD_2: u32 = 0x0DB4;
    #[classattr]
    const MAP2_TEXTURE_COORD_3: u32 = 0x0DB5;
    #[classattr]
    const MAP2_TEXTURE_COORD_4: u32 = 0x0DB6;
    #[classattr]
    const MAP2_VERTEX_3: u32 = 0x0DB7;
    #[classattr]
    const MAP2_VERTEX_4: u32 = 0x0DB8;
    #[classattr]
    const MAP_COLOR: u32 = 0x0D10;
    #[classattr]
    const MAP_FLUSH_EXPLICIT_BIT: u32 = 0x0010;
    #[classattr]
    const MAP_INVALIDATE_BUFFER_BIT: u32 = 0x0008;
    #[classattr]
    const MAP_INVALIDATE_RANGE_BIT: u32 = 0x0004;
    #[classattr]
    const MAP_READ_BIT: u32 = 0x0001;
    #[classattr]
    const MAP_STENCIL: u32 = 0x0D11;
    #[classattr]
    const MAP_UNSYNCHRONIZED_BIT: u32 = 0x0020;
    #[classattr]
    const MAP_WRITE_BIT: u32 = 0x0002;
    #[classattr]
    const MATRIX_MODE: u32 = 0x0BA0;
    #[classattr]
    const MAX: u32 = 0x8008;
    #[classattr]
    const MAX_3D_TEXTURE_SIZE: u32 = 0x8073;
    #[classattr]
    const MAX_ARRAY_TEXTURE_LAYERS: u32 = 0x88FF;
    #[classattr]
    const MAX_ATTRIB_STACK_DEPTH: u32 = 0x0D35;
    #[classattr]
    const MAX_CLIENT_ATTRIB_STACK_DEPTH: u32 = 0x0D3B;
    #[classattr]
    const MAX_CLIP_DISTANCES: u32 = 0x0D32;
    #[classattr]
    const MAX_CLIP_PLANES: u32 = 0x0D32;
    #[classattr]
    const MAX_COLOR_ATTACHMENTS: u32 = 0x8CDF;
    #[classattr]
    const MAX_COLOR_TEXTURE_SAMPLES: u32 = 0x910E;
    #[classattr]
    const MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8A33;
    #[classattr]
    const MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS: u32 = 0x8A32;
    #[classattr]
    const MAX_COMBINED_TEXTURE_IMAGE_UNITS: u32 = 0x8B4D;
    #[classattr]
    const MAX_COMBINED_UNIFORM_BLOCKS: u32 = 0x8A2E;
    #[classattr]
    const MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8A31;
    #[classattr]
    const MAX_CUBE_MAP_TEXTURE_SIZE: u32 = 0x851C;
    #[classattr]
    const MAX_DEBUG_GROUP_STACK_DEPTH: u32 = 0x826C;
    #[classattr]
    const MAX_DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826C;
    #[classattr]
    const MAX_DEBUG_LOGGED_MESSAGES: u32 = 0x9144;
    #[classattr]
    const MAX_DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9144;
    #[classattr]
    const MAX_DEBUG_MESSAGE_LENGTH: u32 = 0x9143;
    #[classattr]
    const MAX_DEBUG_MESSAGE_LENGTH_KHR: u32 = 0x9143;
    #[classattr]
    const MAX_DEPTH_TEXTURE_SAMPLES: u32 = 0x910F;
    #[classattr]
    const MAX_DRAW_BUFFERS: u32 = 0x8824;
    #[classattr]
    const MAX_DUAL_SOURCE_DRAW_BUFFERS: u32 = 0x88FC;
    #[classattr]
    const MAX_ELEMENTS_INDICES: u32 = 0x80E9;
    #[classattr]
    const MAX_ELEMENTS_VERTICES: u32 = 0x80E8;
    #[classattr]
    const MAX_ELEMENT_INDEX: u32 = 0x8D6B;
    #[classattr]
    const MAX_EVAL_ORDER: u32 = 0x0D30;
    #[classattr]
    const MAX_FRAGMENT_INPUT_COMPONENTS: u32 = 0x9125;
    #[classattr]
    const MAX_FRAGMENT_UNIFORM_BLOCKS: u32 = 0x8A2D;
    #[classattr]
    const MAX_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8B49;
    #[classattr]
    const MAX_FRAGMENT_UNIFORM_VECTORS: u32 = 0x8DFD;
    #[classattr]
    const MAX_GEOMETRY_INPUT_COMPONENTS: u32 = 0x9123;
    #[classattr]
    const MAX_GEOMETRY_OUTPUT_COMPONENTS: u32 = 0x9124;
    #[classattr]
    const MAX_GEOMETRY_OUTPUT_VERTICES: u32 = 0x8DE0;
    #[classattr]
    const MAX_GEOMETRY_TEXTURE_IMAGE_UNITS: u32 = 0x8C29;
    #[classattr]
    const MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS: u32 = 0x8DE1;
    #[classattr]
    const MAX_GEOMETRY_UNIFORM_BLOCKS: u32 = 0x8A2C;
    #[classattr]
    const MAX_GEOMETRY_UNIFORM_COMPONENTS: u32 = 0x8DDF;
    #[classattr]
    const MAX_INTEGER_SAMPLES: u32 = 0x9110;
    #[classattr]
    const MAX_LABEL_LENGTH: u32 = 0x82E8;
    #[classattr]
    const MAX_LABEL_LENGTH_KHR: u32 = 0x82E8;
    #[classattr]
    const MAX_LIGHTS: u32 = 0x0D31;
    #[classattr]
    const MAX_LIST_NESTING: u32 = 0x0B31;
    #[classattr]
    const MAX_MODELVIEW_STACK_DEPTH: u32 = 0x0D36;
    #[classattr]
    const MAX_NAME_STACK_DEPTH: u32 = 0x0D37;
    #[classattr]
    const MAX_PIXEL_MAP_TABLE: u32 = 0x0D34;
    #[classattr]
    const MAX_PROGRAM_TEXEL_OFFSET: u32 = 0x8905;
    #[classattr]
    const MAX_PROJECTION_STACK_DEPTH: u32 = 0x0D38;
    #[classattr]
    const MAX_RECTANGLE_TEXTURE_SIZE: u32 = 0x84F8;
    #[classattr]
    const MAX_RECTANGLE_TEXTURE_SIZE_ARB: u32 = 0x84F8;
    #[classattr]
    const MAX_RENDERBUFFER_SIZE: u32 = 0x84E8;
    #[classattr]
    const MAX_SAMPLES: u32 = 0x8D57;
    #[classattr]
    const MAX_SAMPLE_MASK_WORDS: u32 = 0x8E59;
    #[classattr]
    const MAX_SERVER_WAIT_TIMEOUT: u32 = 0x9111;
    #[classattr]
    const MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT: u32 = 0x8F63;
    #[classattr]
    const MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT: u32 = 0x8F67;
    #[classattr]
    const MAX_TEXTURE_BUFFER_SIZE: u32 = 0x8C2B;
    #[classattr]
    const MAX_TEXTURE_COORDS: u32 = 0x8871;
    #[classattr]
    const MAX_TEXTURE_IMAGE_UNITS: u32 = 0x8872;
    #[classattr]
    const MAX_TEXTURE_LOD_BIAS: u32 = 0x84FD;
    #[classattr]
    const MAX_TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FF;
    #[classattr]
    const MAX_TEXTURE_SIZE: u32 = 0x0D33;
    #[classattr]
    const MAX_TEXTURE_STACK_DEPTH: u32 = 0x0D39;
    #[classattr]
    const MAX_TEXTURE_UNITS: u32 = 0x84E2;
    #[classattr]
    const MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: u32 = 0x8C8A;
    #[classattr]
    const MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: u32 = 0x8C8B;
    #[classattr]
    const MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: u32 = 0x8C80;
    #[classattr]
    const MAX_UNIFORM_BLOCK_SIZE: u32 = 0x8A30;
    #[classattr]
    const MAX_UNIFORM_BUFFER_BINDINGS: u32 = 0x8A2F;
    #[classattr]
    const MAX_VARYING_COMPONENTS: u32 = 0x8B4B;
    #[classattr]
    const MAX_VARYING_FLOATS: u32 = 0x8B4B;
    #[classattr]
    const MAX_VARYING_VECTORS: u32 = 0x8DFC;
    #[classattr]
    const MAX_VERTEX_ATTRIBS: u32 = 0x8869;
    #[classattr]
    const MAX_VERTEX_OUTPUT_COMPONENTS: u32 = 0x9122;
    #[classattr]
    const MAX_VERTEX_TEXTURE_IMAGE_UNITS: u32 = 0x8B4C;
    #[classattr]
    const MAX_VERTEX_UNIFORM_BLOCKS: u32 = 0x8A2B;
    #[classattr]
    const MAX_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8B4A;
    #[classattr]
    const MAX_VERTEX_UNIFORM_VECTORS: u32 = 0x8DFB;
    #[classattr]
    const MAX_VIEWPORT_DIMS: u32 = 0x0D3A;
    #[classattr]
    const MEDIUM_FLOAT: u32 = 0x8DF1;
    #[classattr]
    const MEDIUM_INT: u32 = 0x8DF4;
    #[classattr]
    const MIN: u32 = 0x8007;
    #[classattr]
    const MINOR_VERSION: u32 = 0x821C;
    #[classattr]
    const MIN_PROGRAM_TEXEL_OFFSET: u32 = 0x8904;
    #[classattr]
    const MIRRORED_REPEAT: u32 = 0x8370;
    #[classattr]
    const MODELVIEW: u32 = 0x1700;
    #[classattr]
    const MODELVIEW_MATRIX: u32 = 0x0BA6;
    #[classattr]
    const MODELVIEW_STACK_DEPTH: u32 = 0x0BA3;
    #[classattr]
    const MODULATE: u32 = 0x2100;
    #[classattr]
    const MULT: u32 = 0x0103;
    #[classattr]
    const MULTIPLY_KHR: u32 = 0x9294;
    #[classattr]
    const MULTISAMPLE: u32 = 0x809D;
    #[classattr]
    const MULTISAMPLE_BIT: u32 = 0x20000000;
    #[classattr]
    const N3F_V3F: u32 = 0x2A25;
    #[classattr]
    const NAME_STACK_DEPTH: u32 = 0x0D70;
    #[classattr]
    const NAND: u32 = 0x150E;
    #[classattr]
    const NEAREST: u32 = 0x2600;
    #[classattr]
    const NEAREST_MIPMAP_LINEAR: u32 = 0x2702;
    #[classattr]
    const NEAREST_MIPMAP_NEAREST: u32 = 0x2700;
    #[classattr]
    const NEVER: u32 = 0x0200;
    #[classattr]
    const NICEST: u32 = 0x1102;
    #[classattr]
    const NONE: u32 = 0;
    #[classattr]
    const NOOP: u32 = 0x1505;
    #[classattr]
    const NOR: u32 = 0x1508;
    #[classattr]
    const NORMALIZE: u32 = 0x0BA1;
    #[classattr]
    const NORMAL_ARRAY: u32 = 0x8075;
    #[classattr]
    const NORMAL_ARRAY_BUFFER_BINDING: u32 = 0x8897;
    #[classattr]
    const NORMAL_ARRAY_POINTER: u32 = 0x808F;
    #[classattr]
    const NORMAL_ARRAY_STRIDE: u32 = 0x807F;
    #[classattr]
    const NORMAL_ARRAY_TYPE: u32 = 0x807E;
    #[classattr]
    const NORMAL_MAP: u32 = 0x8511;
    #[classattr]
    const NOTEQUAL: u32 = 0x0205;
    #[classattr]
    const NO_ERROR: u32 = 0;
    #[classattr]
    const NUM_COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A2;
    #[classattr]
    const NUM_EXTENSIONS: u32 = 0x821D;
    #[classattr]
    const NUM_PROGRAM_BINARY_FORMATS: u32 = 0x87FE;
    #[classattr]
    const NUM_SAMPLE_COUNTS: u32 = 0x9380;
    #[classattr]
    const NUM_SHADER_BINARY_FORMATS: u32 = 0x8DF9;
    #[classattr]
    const OBJECT_LINEAR: u32 = 0x2401;
    #[classattr]
    const OBJECT_PLANE: u32 = 0x2501;
    #[classattr]
    const OBJECT_TYPE: u32 = 0x9112;
    #[classattr]
    const ONE: u32 = 1;
    #[classattr]
    const ONE_MINUS_CONSTANT_ALPHA: u32 = 0x8004;
    #[classattr]
    const ONE_MINUS_CONSTANT_COLOR: u32 = 0x8002;
    #[classattr]
    const ONE_MINUS_DST_ALPHA: u32 = 0x0305;
    #[classattr]
    const ONE_MINUS_DST_COLOR: u32 = 0x0307;
    #[classattr]
    const ONE_MINUS_SRC1_ALPHA: u32 = 0x88FB;
    #[classattr]
    const ONE_MINUS_SRC1_COLOR: u32 = 0x88FA;
    #[classattr]
    const ONE_MINUS_SRC_ALPHA: u32 = 0x0303;
    #[classattr]
    const ONE_MINUS_SRC_COLOR: u32 = 0x0301;
    #[classattr]
    const OPERAND0_ALPHA: u32 = 0x8598;
    #[classattr]
    const OPERAND0_RGB: u32 = 0x8590;
    #[classattr]
    const OPERAND1_ALPHA: u32 = 0x8599;
    #[classattr]
    const OPERAND1_RGB: u32 = 0x8591;
    #[classattr]
    const OPERAND2_ALPHA: u32 = 0x859A;
    #[classattr]
    const OPERAND2_RGB: u32 = 0x8592;
    #[classattr]
    const OR: u32 = 0x1507;
    #[classattr]
    const ORDER: u32 = 0x0A01;
    #[classattr]
    const OR_INVERTED: u32 = 0x150D;
    #[classattr]
    const OR_REVERSE: u32 = 0x150B;
    #[classattr]
    const OUT_OF_MEMORY: u32 = 0x0505;
    #[classattr]
    const OVERLAY_KHR: u32 = 0x9296;
    #[classattr]
    const PACK_ALIGNMENT: u32 = 0x0D05;
    #[classattr]
    const PACK_IMAGE_HEIGHT: u32 = 0x806C;
    #[classattr]
    const PACK_LSB_FIRST: u32 = 0x0D01;
    #[classattr]
    const PACK_ROW_LENGTH: u32 = 0x0D02;
    #[classattr]
    const PACK_SKIP_IMAGES: u32 = 0x806B;
    #[classattr]
    const PACK_SKIP_PIXELS: u32 = 0x0D04;
    #[classattr]
    const PACK_SKIP_ROWS: u32 = 0x0D03;
    #[classattr]
    const PACK_SWAP_BYTES: u32 = 0x0D00;
    #[classattr]
    const PASS_THROUGH_TOKEN: u32 = 0x0700;
    #[classattr]
    const PERSPECTIVE_CORRECTION_HINT: u32 = 0x0C50;
    #[classattr]
    const PIXEL_MAP_A_TO_A: u32 = 0x0C79;
    #[classattr]
    const PIXEL_MAP_A_TO_A_SIZE: u32 = 0x0CB9;
    #[classattr]
    const PIXEL_MAP_B_TO_B: u32 = 0x0C78;
    #[classattr]
    const PIXEL_MAP_B_TO_B_SIZE: u32 = 0x0CB8;
    #[classattr]
    const PIXEL_MAP_G_TO_G: u32 = 0x0C77;
    #[classattr]
    const PIXEL_MAP_G_TO_G_SIZE: u32 = 0x0CB7;
    #[classattr]
    const PIXEL_MAP_I_TO_A: u32 = 0x0C75;
    #[classattr]
    const PIXEL_MAP_I_TO_A_SIZE: u32 = 0x0CB5;
    #[classattr]
    const PIXEL_MAP_I_TO_B: u32 = 0x0C74;
    #[classattr]
    const PIXEL_MAP_I_TO_B_SIZE: u32 = 0x0CB4;
    #[classattr]
    const PIXEL_MAP_I_TO_G: u32 = 0x0C73;
    #[classattr]
    const PIXEL_MAP_I_TO_G_SIZE: u32 = 0x0CB3;
    #[classattr]
    const PIXEL_MAP_I_TO_I: u32 = 0x0C70;
    #[classattr]
    const PIXEL_MAP_I_TO_I_SIZE: u32 = 0x0CB0;
    #[classattr]
    const PIXEL_MAP_I_TO_R: u32 = 0x0C72;
    #[classattr]
    const PIXEL_MAP_I_TO_R_SIZE: u32 = 0x0CB2;
    #[classattr]
    const PIXEL_MAP_R_TO_R: u32 = 0x0C76;
    #[classattr]
    const PIXEL_MAP_R_TO_R_SIZE: u32 = 0x0CB6;
    #[classattr]
    const PIXEL_MAP_S_TO_S: u32 = 0x0C71;
    #[classattr]
    const PIXEL_MAP_S_TO_S_SIZE: u32 = 0x0CB1;
    #[classattr]
    const PIXEL_MODE_BIT: u32 = 0x00000020;
    #[classattr]
    const PIXEL_PACK_BUFFER: u32 = 0x88EB;
    #[classattr]
    const PIXEL_PACK_BUFFER_BINDING: u32 = 0x88ED;
    #[classattr]
    const PIXEL_UNPACK_BUFFER: u32 = 0x88EC;
    #[classattr]
    const PIXEL_UNPACK_BUFFER_BINDING: u32 = 0x88EF;
    #[classattr]
    const POINT: u32 = 0x1B00;
    #[classattr]
    const POINTS: u32 = 0x0000;
    #[classattr]
    const POINT_BIT: u32 = 0x00000002;
    #[classattr]
    const POINT_DISTANCE_ATTENUATION: u32 = 0x8129;
    #[classattr]
    const POINT_FADE_THRESHOLD_SIZE: u32 = 0x8128;
    #[classattr]
    const POINT_SIZE: u32 = 0x0B11;
    #[classattr]
    const POINT_SIZE_GRANULARITY: u32 = 0x0B13;
    #[classattr]
    const POINT_SIZE_MAX: u32 = 0x8127;
    #[classattr]
    const POINT_SIZE_MIN: u32 = 0x8126;
    #[classattr]
    const POINT_SIZE_RANGE: u32 = 0x0B12;
    #[classattr]
    const POINT_SMOOTH: u32 = 0x0B10;
    #[classattr]
    const POINT_SMOOTH_HINT: u32 = 0x0C51;
    #[classattr]
    const POINT_SPRITE: u32 = 0x8861;
    #[classattr]
    const POINT_SPRITE_COORD_ORIGIN: u32 = 0x8CA0;
    #[classattr]
    const POINT_TOKEN: u32 = 0x0701;
    #[classattr]
    const POLYGON: u32 = 0x0009;
    #[classattr]
    const POLYGON_BIT: u32 = 0x00000008;
    #[classattr]
    const POLYGON_MODE: u32 = 0x0B40;
    #[classattr]
    const POLYGON_OFFSET_FACTOR: u32 = 0x8038;
    #[classattr]
    const POLYGON_OFFSET_FILL: u32 = 0x8037;
    #[classattr]
    const POLYGON_OFFSET_LINE: u32 = 0x2A02;
    #[classattr]
    const POLYGON_OFFSET_POINT: u32 = 0x2A01;
    #[classattr]
    const POLYGON_OFFSET_UNITS: u32 = 0x2A00;
    #[classattr]
    const POLYGON_SMOOTH: u32 = 0x0B41;
    #[classattr]
    const POLYGON_SMOOTH_HINT: u32 = 0x0C53;
    #[classattr]
    const POLYGON_STIPPLE: u32 = 0x0B42;
    #[classattr]
    const POLYGON_STIPPLE_BIT: u32 = 0x00000010;
    #[classattr]
    const POLYGON_TOKEN: u32 = 0x0703;
    #[classattr]
    const POSITION: u32 = 0x1203;
    #[classattr]
    const PREVIOUS: u32 = 0x8578;
    #[classattr]
    const PRIMARY_COLOR: u32 = 0x8577;
    #[classattr]
    const PRIMITIVES_GENERATED: u32 = 0x8C87;
    #[classattr]
    const PRIMITIVE_RESTART: u32 = 0x8F9D;
    #[classattr]
    const PRIMITIVE_RESTART_FIXED_INDEX: u32 = 0x8D69;
    #[classattr]
    const PRIMITIVE_RESTART_INDEX: u32 = 0x8F9E;
    #[classattr]
    const PROGRAM: u32 = 0x82E2;
    #[classattr]
    const PROGRAM_BINARY_FORMATS: u32 = 0x87FF;
    #[classattr]
    const PROGRAM_BINARY_LENGTH: u32 = 0x8741;
    #[classattr]
    const PROGRAM_BINARY_RETRIEVABLE_HINT: u32 = 0x8257;
    #[classattr]
    const PROGRAM_KHR: u32 = 0x82E2;
    #[classattr]
    const PROGRAM_PIPELINE: u32 = 0x82E4;
    #[classattr]
    const PROGRAM_PIPELINE_KHR: u32 = 0x82E4;
    #[classattr]
    const PROGRAM_POINT_SIZE: u32 = 0x8642;
    #[classattr]
    const PROJECTION: u32 = 0x1701;
    #[classattr]
    const PROJECTION_MATRIX: u32 = 0x0BA7;
    #[classattr]
    const PROJECTION_STACK_DEPTH: u32 = 0x0BA4;
    #[classattr]
    const PROVOKING_VERTEX: u32 = 0x8E4F;
    #[classattr]
    const PROXY_TEXTURE_1D: u32 = 0x8063;
    #[classattr]
    const PROXY_TEXTURE_1D_ARRAY: u32 = 0x8C19;
    #[classattr]
    const PROXY_TEXTURE_2D: u32 = 0x8064;
    #[classattr]
    const PROXY_TEXTURE_2D_ARRAY: u32 = 0x8C1B;
    #[classattr]
    const PROXY_TEXTURE_2D_MULTISAMPLE: u32 = 0x9101;
    #[classattr]
    const PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: u32 = 0x9103;
    #[classattr]
    const PROXY_TEXTURE_3D: u32 = 0x8070;
    #[classattr]
    const PROXY_TEXTURE_CUBE_MAP: u32 = 0x851B;
    #[classattr]
    const PROXY_TEXTURE_RECTANGLE: u32 = 0x84F7;
    #[classattr]
    const PROXY_TEXTURE_RECTANGLE_ARB: u32 = 0x84F7;
    #[classattr]
    const Q: u32 = 0x2003;
    #[classattr]
    const QUADRATIC_ATTENUATION: u32 = 0x1209;
    #[classattr]
    const QUADS: u32 = 0x0007;
    #[classattr]
    const QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION: u32 = 0x8E4C;
    #[classattr]
    const QUAD_STRIP: u32 = 0x0008;
    #[classattr]
    const QUERY: u32 = 0x82E3;
    #[classattr]
    const QUERY_BY_REGION_NO_WAIT: u32 = 0x8E16;
    #[classattr]
    const QUERY_BY_REGION_WAIT: u32 = 0x8E15;
    #[classattr]
    const QUERY_COUNTER_BITS: u32 = 0x8864;
    #[classattr]
    const QUERY_COUNTER_BITS_EXT: u32 = 0x8864;
    #[classattr]
    const QUERY_KHR: u32 = 0x82E3;
    #[classattr]
    const QUERY_NO_WAIT: u32 = 0x8E14;
    #[classattr]
    const QUERY_RESULT: u32 = 0x8866;
    #[classattr]
    const QUERY_RESULT_AVAILABLE: u32 = 0x8867;
    #[classattr]
    const QUERY_RESULT_AVAILABLE_EXT: u32 = 0x8867;
    #[classattr]
    const QUERY_RESULT_EXT: u32 = 0x8866;
    #[classattr]
    const QUERY_WAIT: u32 = 0x8E13;
    #[classattr]
    const R: u32 = 0x2002;
    #[classattr]
    const R11F_G11F_B10F: u32 = 0x8C3A;
    #[classattr]
    const R16: u32 = 0x822A;
    #[classattr]
    const R16F: u32 = 0x822D;
    #[classattr]
    const R16F_EXT: u32 = 0x822D;
    #[classattr]
    const R16I: u32 = 0x8233;
    #[classattr]
    const R16UI: u32 = 0x8234;
    #[classattr]
    const R16_SNORM: u32 = 0x8F98;
    #[classattr]
    const R32F: u32 = 0x822E;
    #[classattr]
    const R32F_EXT: u32 = 0x822E;
    #[classattr]
    const R32I: u32 = 0x8235;
    #[classattr]
    const R32UI: u32 = 0x8236;
    #[classattr]
    const R3_G3_B2: u32 = 0x2A10;
    #[classattr]
    const R8: u32 = 0x8229;
    #[classattr]
    const R8I: u32 = 0x8231;
    #[classattr]
    const R8UI: u32 = 0x8232;
    #[classattr]
    const R8_EXT: u32 = 0x8229;
    #[classattr]
    const R8_SNORM: u32 = 0x8F94;
    #[classattr]
    const RASTERIZER_DISCARD: u32 = 0x8C89;
    #[classattr]
    const READ_BUFFER: u32 = 0x0C02;
    #[classattr]
    const READ_FRAMEBUFFER: u32 = 0x8CA8;
    #[classattr]
    const READ_FRAMEBUFFER_BINDING: u32 = 0x8CAA;
    #[classattr]
    const READ_ONLY: u32 = 0x88B8;
    #[classattr]
    const READ_WRITE: u32 = 0x88BA;
    #[classattr]
    const RED: u32 = 0x1903;
    #[classattr]
    const RED_BIAS: u32 = 0x0D15;
    #[classattr]
    const RED_BITS: u32 = 0x0D52;
    #[classattr]
    const RED_INTEGER: u32 = 0x8D94;
    #[classattr]
    const RED_SCALE: u32 = 0x0D14;
    #[classattr]
    const REFLECTION_MAP: u32 = 0x8512;
    #[classattr]
    const RENDER: u32 = 0x1C00;
    #[classattr]
    const RENDERBUFFER: u32 = 0x8D41;
    #[classattr]
    const RENDERBUFFER_ALPHA_SIZE: u32 = 0x8D53;
    #[classattr]
    const RENDERBUFFER_BINDING: u32 = 0x8CA7;
    #[classattr]
    const RENDERBUFFER_BLUE_SIZE: u32 = 0x8D52;
    #[classattr]
    const RENDERBUFFER_DEPTH_SIZE: u32 = 0x8D54;
    #[classattr]
    const RENDERBUFFER_GREEN_SIZE: u32 = 0x8D51;
    #[classattr]
    const RENDERBUFFER_HEIGHT: u32 = 0x8D43;
    #[classattr]
    const RENDERBUFFER_INTERNAL_FORMAT: u32 = 0x8D44;
    #[classattr]
    const RENDERBUFFER_RED_SIZE: u32 = 0x8D50;
    #[classattr]
    const RENDERBUFFER_SAMPLES: u32 = 0x8CAB;
    #[classattr]
    const RENDERBUFFER_STENCIL_SIZE: u32 = 0x8D55;
    #[classattr]
    const RENDERBUFFER_WIDTH: u32 = 0x8D42;
    #[classattr]
    const RENDERER: u32 = 0x1F01;
    #[classattr]
    const RENDER_MODE: u32 = 0x0C40;
    #[classattr]
    const REPEAT: u32 = 0x2901;
    #[classattr]
    const REPLACE: u32 = 0x1E01;
    #[classattr]
    const REQUIRED_TEXTURE_IMAGE_UNITS_OES: u32 = 0x8D68;
    #[classattr]
    const RESCALE_NORMAL: u32 = 0x803A;
    #[classattr]
    const RETURN: u32 = 0x0102;
    #[classattr]
    const RG: u32 = 0x8227;
    #[classattr]
    const RG16: u32 = 0x822C;
    #[classattr]
    const RG16F: u32 = 0x822F;
    #[classattr]
    const RG16F_EXT: u32 = 0x822F;
    #[classattr]
    const RG16I: u32 = 0x8239;
    #[classattr]
    const RG16UI: u32 = 0x823A;
    #[classattr]
    const RG16_SNORM: u32 = 0x8F99;
    #[classattr]
    const RG32F: u32 = 0x8230;
    #[classattr]
    const RG32F_EXT: u32 = 0x8230;
    #[classattr]
    const RG32I: u32 = 0x823B;
    #[classattr]
    const RG32UI: u32 = 0x823C;
    #[classattr]
    const RG8: u32 = 0x822B;
    #[classattr]
    const RG8I: u32 = 0x8237;
    #[classattr]
    const RG8UI: u32 = 0x8238;
    #[classattr]
    const RG8_EXT: u32 = 0x822B;
    #[classattr]
    const RG8_SNORM: u32 = 0x8F95;
    #[classattr]
    const RGB: u32 = 0x1907;
    #[classattr]
    const RGB10: u32 = 0x8052;
    #[classattr]
    const RGB10_A2: u32 = 0x8059;
    #[classattr]
    const RGB10_A2UI: u32 = 0x906F;
    #[classattr]
    const RGB10_A2_EXT: u32 = 0x8059;
    #[classattr]
    const RGB10_EXT: u32 = 0x8052;
    #[classattr]
    const RGB12: u32 = 0x8053;
    #[classattr]
    const RGB16: u32 = 0x8054;
    #[classattr]
    const RGB16F: u32 = 0x881B;
    #[classattr]
    const RGB16F_EXT: u32 = 0x881B;
    #[classattr]
    const RGB16I: u32 = 0x8D89;
    #[classattr]
    const RGB16UI: u32 = 0x8D77;
    #[classattr]
    const RGB16_SNORM: u32 = 0x8F9A;
    #[classattr]
    const RGB32F: u32 = 0x8815;
    #[classattr]
    const RGB32F_EXT: u32 = 0x8815;
    #[classattr]
    const RGB32I: u32 = 0x8D83;
    #[classattr]
    const RGB32UI: u32 = 0x8D71;
    #[classattr]
    const RGB4: u32 = 0x804F;
    #[classattr]
    const RGB5: u32 = 0x8050;
    #[classattr]
    const RGB565: u32 = 0x8D62;
    #[classattr]
    const RGB5_A1: u32 = 0x8057;
    #[classattr]
    const RGB8: u32 = 0x8051;
    #[classattr]
    const RGB8I: u32 = 0x8D8F;
    #[classattr]
    const RGB8UI: u32 = 0x8D7D;
    #[classattr]
    const RGB8_SNORM: u32 = 0x8F96;
    #[classattr]
    const RGB9_E5: u32 = 0x8C3D;
    #[classattr]
    const RGBA: u32 = 0x1908;
    #[classattr]
    const RGBA12: u32 = 0x805A;
    #[classattr]
    const RGBA16: u32 = 0x805B;
    #[classattr]
    const RGBA16F: u32 = 0x881A;
    #[classattr]
    const RGBA16F_EXT: u32 = 0x881A;
    #[classattr]
    const RGBA16I: u32 = 0x8D88;
    #[classattr]
    const RGBA16UI: u32 = 0x8D76;
    #[classattr]
    const RGBA16_SNORM: u32 = 0x8F9B;
    #[classattr]
    const RGBA2: u32 = 0x8055;
    #[classattr]
    const RGBA32F: u32 = 0x8814;
    #[classattr]
    const RGBA32F_EXT: u32 = 0x8814;
    #[classattr]
    const RGBA32I: u32 = 0x8D82;
    #[classattr]
    const RGBA32UI: u32 = 0x8D70;
    #[classattr]
    const RGBA4: u32 = 0x8056;
    #[classattr]
    const RGBA8: u32 = 0x8058;
    #[classattr]
    const RGBA8I: u32 = 0x8D8E;
    #[classattr]
    const RGBA8UI: u32 = 0x8D7C;
    #[classattr]
    const RGBA8_SNORM: u32 = 0x8F97;
    #[classattr]
    const RGBA_INTEGER: u32 = 0x8D99;
    #[classattr]
    const RGBA_MODE: u32 = 0x0C31;
    #[classattr]
    const RGB_INTEGER: u32 = 0x8D98;
    #[classattr]
    const RGB_SCALE: u32 = 0x8573;
    #[classattr]
    const RG_INTEGER: u32 = 0x8228;
    #[classattr]
    const RIGHT: u32 = 0x0407;
    #[classattr]
    const S: u32 = 0x2000;
    #[classattr]
    const SAMPLER: u32 = 0x82E6;
    #[classattr]
    const SAMPLER_1D: u32 = 0x8B5D;
    #[classattr]
    const SAMPLER_1D_ARRAY: u32 = 0x8DC0;
    #[classattr]
    const SAMPLER_1D_ARRAY_SHADOW: u32 = 0x8DC3;
    #[classattr]
    const SAMPLER_1D_SHADOW: u32 = 0x8B61;
    #[classattr]
    const SAMPLER_2D: u32 = 0x8B5E;
    #[classattr]
    const SAMPLER_2D_ARRAY: u32 = 0x8DC1;
    #[classattr]
    const SAMPLER_2D_ARRAY_SHADOW: u32 = 0x8DC4;
    #[classattr]
    const SAMPLER_2D_MULTISAMPLE: u32 = 0x9108;
    #[classattr]
    const SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910B;
    #[classattr]
    const SAMPLER_2D_RECT: u32 = 0x8B63;
    #[classattr]
    const SAMPLER_2D_RECT_SHADOW: u32 = 0x8B64;
    #[classattr]
    const SAMPLER_2D_SHADOW: u32 = 0x8B62;
    #[classattr]
    const SAMPLER_3D: u32 = 0x8B5F;
    #[classattr]
    const SAMPLER_BINDING: u32 = 0x8919;
    #[classattr]
    const SAMPLER_BUFFER: u32 = 0x8DC2;
    #[classattr]
    const SAMPLER_CUBE: u32 = 0x8B60;
    #[classattr]
    const SAMPLER_CUBE_SHADOW: u32 = 0x8DC5;
    #[classattr]
    const SAMPLER_EXTERNAL_OES: u32 = 0x8D66;
    #[classattr]
    const SAMPLER_KHR: u32 = 0x82E6;
    #[classattr]
    const SAMPLES: u32 = 0x80A9;
    #[classattr]
    const SAMPLES_PASSED: u32 = 0x8914;
    #[classattr]
    const SAMPLE_ALPHA_TO_COVERAGE: u32 = 0x809E;
    #[classattr]
    const SAMPLE_ALPHA_TO_ONE: u32 = 0x809F;
    #[classattr]
    const SAMPLE_BUFFERS: u32 = 0x80A8;
    #[classattr]
    const SAMPLE_COVERAGE: u32 = 0x80A0;
    #[classattr]
    const SAMPLE_COVERAGE_INVERT: u32 = 0x80AB;
    #[classattr]
    const SAMPLE_COVERAGE_VALUE: u32 = 0x80AA;
    #[classattr]
    const SAMPLE_MASK: u32 = 0x8E51;
    #[classattr]
    const SAMPLE_MASK_VALUE: u32 = 0x8E52;
    #[classattr]
    const SAMPLE_POSITION: u32 = 0x8E50;
    #[classattr]
    const SCISSOR_BIT: u32 = 0x00080000;
    #[classattr]
    const SCISSOR_BOX: u32 = 0x0C10;
    #[classattr]
    const SCISSOR_TEST: u32 = 0x0C11;
    #[classattr]
    const SCREEN_KHR: u32 = 0x9295;
    #[classattr]
    const SECONDARY_COLOR_ARRAY: u32 = 0x845E;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_BUFFER_BINDING: u32 = 0x889C;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_POINTER: u32 = 0x845D;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_SIZE: u32 = 0x845A;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_STRIDE: u32 = 0x845C;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_TYPE: u32 = 0x845B;
    #[classattr]
    const SELECT: u32 = 0x1C02;
    #[classattr]
    const SELECTION_BUFFER_POINTER: u32 = 0x0DF3;
    #[classattr]
    const SELECTION_BUFFER_SIZE: u32 = 0x0DF4;
    #[classattr]
    const SEPARATE_ATTRIBS: u32 = 0x8C8D;
    #[classattr]
    const SEPARATE_SPECULAR_COLOR: u32 = 0x81FA;
    #[classattr]
    const SET: u32 = 0x150F;
    #[classattr]
    const SHADER: u32 = 0x82E1;
    #[classattr]
    const SHADER_BINARY_FORMATS: u32 = 0x8DF8;
    #[classattr]
    const SHADER_COMPILER: u32 = 0x8DFA;
    #[classattr]
    const SHADER_KHR: u32 = 0x82E1;
    #[classattr]
    const SHADER_PIXEL_LOCAL_STORAGE_EXT: u32 = 0x8F64;
    #[classattr]
    const SHADER_SOURCE_LENGTH: u32 = 0x8B88;
    #[classattr]
    const SHADER_TYPE: u32 = 0x8B4F;
    #[classattr]
    const SHADE_MODEL: u32 = 0x0B54;
    #[classattr]
    const SHADING_LANGUAGE_VERSION: u32 = 0x8B8C;
    #[classattr]
    const SHININESS: u32 = 0x1601;
    #[classattr]
    const SHORT: u32 = 0x1402;
    #[classattr]
    const SIGNALED: u32 = 0x9119;
    #[classattr]
    const SIGNED_NORMALIZED: u32 = 0x8F9C;
    #[classattr]
    const SINGLE_COLOR: u32 = 0x81F9;
    #[classattr]
    const SLUMINANCE: u32 = 0x8C46;
    #[classattr]
    const SLUMINANCE8: u32 = 0x8C47;
    #[classattr]
    const SLUMINANCE8_ALPHA8: u32 = 0x8C45;
    #[classattr]
    const SLUMINANCE_ALPHA: u32 = 0x8C44;
    #[classattr]
    const SMOOTH: u32 = 0x1D01;
    #[classattr]
    const SMOOTH_LINE_WIDTH_GRANULARITY: u32 = 0x0B23;
    #[classattr]
    const SMOOTH_LINE_WIDTH_RANGE: u32 = 0x0B22;
    #[classattr]
    const SMOOTH_POINT_SIZE_GRANULARITY: u32 = 0x0B13;
    #[classattr]
    const SMOOTH_POINT_SIZE_RANGE: u32 = 0x0B12;
    #[classattr]
    const SOFTLIGHT_KHR: u32 = 0x929C;
    #[classattr]
    const SOURCE0_ALPHA: u32 = 0x8588;
    #[classattr]
    const SOURCE0_RGB: u32 = 0x8580;
    #[classattr]
    const SOURCE1_ALPHA: u32 = 0x8589;
    #[classattr]
    const SOURCE1_RGB: u32 = 0x8581;
    #[classattr]
    const SOURCE2_ALPHA: u32 = 0x858A;
    #[classattr]
    const SOURCE2_RGB: u32 = 0x8582;
    #[classattr]
    const SPECULAR: u32 = 0x1202;
    #[classattr]
    const SPHERE_MAP: u32 = 0x2402;
    #[classattr]
    const SPOT_CUTOFF: u32 = 0x1206;
    #[classattr]
    const SPOT_DIRECTION: u32 = 0x1204;
    #[classattr]
    const SPOT_EXPONENT: u32 = 0x1205;
    #[classattr]
    const SRC0_ALPHA: u32 = 0x8588;
    #[classattr]
    const SRC0_RGB: u32 = 0x8580;
    #[classattr]
    const SRC1_ALPHA: u32 = 0x8589;
    #[classattr]
    const SRC1_COLOR: u32 = 0x88F9;
    #[classattr]
    const SRC1_RGB: u32 = 0x8581;
    #[classattr]
    const SRC2_ALPHA: u32 = 0x858A;
    #[classattr]
    const SRC2_RGB: u32 = 0x8582;
    #[classattr]
    const SRC_ALPHA: u32 = 0x0302;
    #[classattr]
    const SRC_ALPHA_SATURATE: u32 = 0x0308;
    #[classattr]
    const SRC_COLOR: u32 = 0x0300;
    #[classattr]
    const SRGB: u32 = 0x8C40;
    #[classattr]
    const SRGB8: u32 = 0x8C41;
    #[classattr]
    const SRGB8_ALPHA8: u32 = 0x8C43;
    #[classattr]
    const SRGB_ALPHA: u32 = 0x8C42;
    #[classattr]
    const STACK_OVERFLOW: u32 = 0x0503;
    #[classattr]
    const STACK_OVERFLOW_KHR: u32 = 0x0503;
    #[classattr]
    const STACK_UNDERFLOW: u32 = 0x0504;
    #[classattr]
    const STACK_UNDERFLOW_KHR: u32 = 0x0504;
    #[classattr]
    const STATIC_COPY: u32 = 0x88E6;
    #[classattr]
    const STATIC_DRAW: u32 = 0x88E4;
    #[classattr]
    const STATIC_READ: u32 = 0x88E5;
    #[classattr]
    const STENCIL: u32 = 0x1802;
    #[classattr]
    const STENCIL_ATTACHMENT: u32 = 0x8D20;
    #[classattr]
    const STENCIL_BACK_FAIL: u32 = 0x8801;
    #[classattr]
    const STENCIL_BACK_FUNC: u32 = 0x8800;
    #[classattr]
    const STENCIL_BACK_PASS_DEPTH_FAIL: u32 = 0x8802;
    #[classattr]
    const STENCIL_BACK_PASS_DEPTH_PASS: u32 = 0x8803;
    #[classattr]
    const STENCIL_BACK_REF: u32 = 0x8CA3;
    #[classattr]
    const STENCIL_BACK_VALUE_MASK: u32 = 0x8CA4;
    #[classattr]
    const STENCIL_BACK_WRITEMASK: u32 = 0x8CA5;
    #[classattr]
    const STENCIL_BITS: u32 = 0x0D57;
    #[classattr]
    const STENCIL_BUFFER_BIT: u32 = 0x00000400;
    #[classattr]
    const STENCIL_CLEAR_VALUE: u32 = 0x0B91;
    #[classattr]
    const STENCIL_FAIL: u32 = 0x0B94;
    #[classattr]
    const STENCIL_FUNC: u32 = 0x0B92;
    #[classattr]
    const STENCIL_INDEX: u32 = 0x1901;
    #[classattr]
    const STENCIL_INDEX1: u32 = 0x8D46;
    #[classattr]
    const STENCIL_INDEX16: u32 = 0x8D49;
    #[classattr]
    const STENCIL_INDEX4: u32 = 0x8D47;
    #[classattr]
    const STENCIL_INDEX8: u32 = 0x8D48;
    #[classattr]
    const STENCIL_PASS_DEPTH_FAIL: u32 = 0x0B95;
    #[classattr]
    const STENCIL_PASS_DEPTH_PASS: u32 = 0x0B96;
    #[classattr]
    const STENCIL_REF: u32 = 0x0B97;
    #[classattr]
    const STENCIL_TEST: u32 = 0x0B90;
    #[classattr]
    const STENCIL_VALUE_MASK: u32 = 0x0B93;
    #[classattr]
    const STENCIL_WRITEMASK: u32 = 0x0B98;
    #[classattr]
    const STEREO: u32 = 0x0C33;
    #[classattr]
    const STORAGE_CACHED_APPLE: u32 = 0x85BE;
    #[classattr]
    const STORAGE_PRIVATE_APPLE: u32 = 0x85BD;
    #[classattr]
    const STORAGE_SHARED_APPLE: u32 = 0x85BF;
    #[classattr]
    const STREAM_COPY: u32 = 0x88E2;
    #[classattr]
    const STREAM_DRAW: u32 = 0x88E0;
    #[classattr]
    const STREAM_READ: u32 = 0x88E1;
    #[classattr]
    const SUBPIXEL_BITS: u32 = 0x0D50;
    #[classattr]
    const SUBTRACT: u32 = 0x84E7;
    #[classattr]
    const SYNC_CONDITION: u32 = 0x9113;
    #[classattr]
    const SYNC_FENCE: u32 = 0x9116;
    #[classattr]
    const SYNC_FLAGS: u32 = 0x9115;
    #[classattr]
    const SYNC_FLUSH_COMMANDS_BIT: u32 = 0x00000001;
    #[classattr]
    const SYNC_GPU_COMMANDS_COMPLETE: u32 = 0x9117;
    #[classattr]
    const SYNC_STATUS: u32 = 0x9114;
    #[classattr]
    const T: u32 = 0x2001;
    #[classattr]
    const T2F_C3F_V3F: u32 = 0x2A2A;
    #[classattr]
    const T2F_C4F_N3F_V3F: u32 = 0x2A2C;
    #[classattr]
    const T2F_C4UB_V3F: u32 = 0x2A29;
    #[classattr]
    const T2F_N3F_V3F: u32 = 0x2A2B;
    #[classattr]
    const T2F_V3F: u32 = 0x2A27;
    #[classattr]
    const T4F_C4F_N3F_V4F: u32 = 0x2A2D;
    #[classattr]
    const T4F_V4F: u32 = 0x2A28;
    #[classattr]
    const TEXTURE: u32 = 0x1702;
    #[classattr]
    const TEXTURE0: u32 = 0x84C0;
    #[classattr]
    const TEXTURE1: u32 = 0x84C1;
    #[classattr]
    const TEXTURE10: u32 = 0x84CA;
    #[classattr]
    const TEXTURE11: u32 = 0x84CB;
    #[classattr]
    const TEXTURE12: u32 = 0x84CC;
    #[classattr]
    const TEXTURE13: u32 = 0x84CD;
    #[classattr]
    const TEXTURE14: u32 = 0x84CE;
    #[classattr]
    const TEXTURE15: u32 = 0x84CF;
    #[classattr]
    const TEXTURE16: u32 = 0x84D0;
    #[classattr]
    const TEXTURE17: u32 = 0x84D1;
    #[classattr]
    const TEXTURE18: u32 = 0x84D2;
    #[classattr]
    const TEXTURE19: u32 = 0x84D3;
    #[classattr]
    const TEXTURE2: u32 = 0x84C2;
    #[classattr]
    const TEXTURE20: u32 = 0x84D4;
    #[classattr]
    const TEXTURE21: u32 = 0x84D5;
    #[classattr]
    const TEXTURE22: u32 = 0x84D6;
    #[classattr]
    const TEXTURE23: u32 = 0x84D7;
    #[classattr]
    const TEXTURE24: u32 = 0x84D8;
    #[classattr]
    const TEXTURE25: u32 = 0x84D9;
    #[classattr]
    const TEXTURE26: u32 = 0x84DA;
    #[classattr]
    const TEXTURE27: u32 = 0x84DB;
    #[classattr]
    const TEXTURE28: u32 = 0x84DC;
    #[classattr]
    const TEXTURE29: u32 = 0x84DD;
    #[classattr]
    const TEXTURE3: u32 = 0x84C3;
    #[classattr]
    const TEXTURE30: u32 = 0x84DE;
    #[classattr]
    const TEXTURE31: u32 = 0x84DF;
    #[classattr]
    const TEXTURE4: u32 = 0x84C4;
    #[classattr]
    const TEXTURE5: u32 = 0x84C5;
    #[classattr]
    const TEXTURE6: u32 = 0x84C6;
    #[classattr]
    const TEXTURE7: u32 = 0x84C7;
    #[classattr]
    const TEXTURE8: u32 = 0x84C8;
    #[classattr]
    const TEXTURE9: u32 = 0x84C9;
    #[classattr]
    const TEXTURE_1D: u32 = 0x0DE0;
    #[classattr]
    const TEXTURE_1D_ARRAY: u32 = 0x8C18;
    #[classattr]
    const TEXTURE_2D: u32 = 0x0DE1;
    #[classattr]
    const TEXTURE_2D_ARRAY: u32 = 0x8C1A;
    #[classattr]
    const TEXTURE_2D_MULTISAMPLE: u32 = 0x9100;
    #[classattr]
    const TEXTURE_2D_MULTISAMPLE_ARRAY: u32 = 0x9102;
    #[classattr]
    const TEXTURE_3D: u32 = 0x806F;
    #[classattr]
    const TEXTURE_ALPHA_SIZE: u32 = 0x805F;
    #[classattr]
    const TEXTURE_ALPHA_TYPE: u32 = 0x8C13;
    #[classattr]
    const TEXTURE_BASE_LEVEL: u32 = 0x813C;
    #[classattr]
    const TEXTURE_BINDING_1D: u32 = 0x8068;
    #[classattr]
    const TEXTURE_BINDING_1D_ARRAY: u32 = 0x8C1C;
    #[classattr]
    const TEXTURE_BINDING_2D: u32 = 0x8069;
    #[classattr]
    const TEXTURE_BINDING_2D_ARRAY: u32 = 0x8C1D;
    #[classattr]
    const TEXTURE_BINDING_2D_MULTISAMPLE: u32 = 0x9104;
    #[classattr]
    const TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY: u32 = 0x9105;
    #[classattr]
    const TEXTURE_BINDING_3D: u32 = 0x806A;
    #[classattr]
    const TEXTURE_BINDING_BUFFER: u32 = 0x8C2C;
    #[classattr]
    const TEXTURE_BINDING_CUBE_MAP: u32 = 0x8514;
    #[classattr]
    const TEXTURE_BINDING_EXTERNAL_OES: u32 = 0x8D67;
    #[classattr]
    const TEXTURE_BINDING_RECTANGLE: u32 = 0x84F6;
    #[classattr]
    const TEXTURE_BINDING_RECTANGLE_ARB: u32 = 0x84F6;
    #[classattr]
    const TEXTURE_BIT: u32 = 0x00040000;
    #[classattr]
    const TEXTURE_BLUE_SIZE: u32 = 0x805E;
    #[classattr]
    const TEXTURE_BLUE_TYPE: u32 = 0x8C12;
    #[classattr]
    const TEXTURE_BORDER: u32 = 0x1005;
    #[classattr]
    const TEXTURE_BORDER_COLOR: u32 = 0x1004;
    #[classattr]
    const TEXTURE_BUFFER: u32 = 0x8C2A;
    #[classattr]
    const TEXTURE_BUFFER_DATA_STORE_BINDING: u32 = 0x8C2D;
    #[classattr]
    const TEXTURE_COMPARE_FUNC: u32 = 0x884D;
    #[classattr]
    const TEXTURE_COMPARE_MODE: u32 = 0x884C;
    #[classattr]
    const TEXTURE_COMPONENTS: u32 = 0x1003;
    #[classattr]
    const TEXTURE_COMPRESSED: u32 = 0x86A1;
    #[classattr]
    const TEXTURE_COMPRESSED_IMAGE_SIZE: u32 = 0x86A0;
    #[classattr]
    const TEXTURE_COMPRESSION_HINT: u32 = 0x84EF;
    #[classattr]
    const TEXTURE_COORD_ARRAY: u32 = 0x8078;
    #[classattr]
    const TEXTURE_COORD_ARRAY_BUFFER_BINDING: u32 = 0x889A;
    #[classattr]
    const TEXTURE_COORD_ARRAY_POINTER: u32 = 0x8092;
    #[classattr]
    const TEXTURE_COORD_ARRAY_SIZE: u32 = 0x8088;
    #[classattr]
    const TEXTURE_COORD_ARRAY_STRIDE: u32 = 0x808A;
    #[classattr]
    const TEXTURE_COORD_ARRAY_TYPE: u32 = 0x8089;
    #[classattr]
    const TEXTURE_CUBE_MAP: u32 = 0x8513;
    #[classattr]
    const TEXTURE_CUBE_MAP_NEGATIVE_X: u32 = 0x8516;
    #[classattr]
    const TEXTURE_CUBE_MAP_NEGATIVE_Y: u32 = 0x8518;
    #[classattr]
    const TEXTURE_CUBE_MAP_NEGATIVE_Z: u32 = 0x851A;
    #[classattr]
    const TEXTURE_CUBE_MAP_POSITIVE_X: u32 = 0x8515;
    #[classattr]
    const TEXTURE_CUBE_MAP_POSITIVE_Y: u32 = 0x8517;
    #[classattr]
    const TEXTURE_CUBE_MAP_POSITIVE_Z: u32 = 0x8519;
    #[classattr]
    const TEXTURE_CUBE_MAP_SEAMLESS: u32 = 0x884F;
    #[classattr]
    const TEXTURE_DEPTH: u32 = 0x8071;
    #[classattr]
    const TEXTURE_DEPTH_SIZE: u32 = 0x884A;
    #[classattr]
    const TEXTURE_DEPTH_TYPE: u32 = 0x8C16;
    #[classattr]
    const TEXTURE_ENV: u32 = 0x2300;
    #[classattr]
    const TEXTURE_ENV_COLOR: u32 = 0x2201;
    #[classattr]
    const TEXTURE_ENV_MODE: u32 = 0x2200;
    #[classattr]
    const TEXTURE_EXTERNAL_OES: u32 = 0x8D65;
    #[classattr]
    const TEXTURE_FILTER_CONTROL: u32 = 0x8500;
    #[classattr]
    const TEXTURE_FIXED_SAMPLE_LOCATIONS: u32 = 0x9107;
    #[classattr]
    const TEXTURE_GEN_MODE: u32 = 0x2500;
    #[classattr]
    const TEXTURE_GEN_Q: u32 = 0x0C63;
    #[classattr]
    const TEXTURE_GEN_R: u32 = 0x0C62;
    #[classattr]
    const TEXTURE_GEN_S: u32 = 0x0C60;
    #[classattr]
    const TEXTURE_GEN_T: u32 = 0x0C61;
    #[classattr]
    const TEXTURE_GREEN_SIZE: u32 = 0x805D;
    #[classattr]
    const TEXTURE_GREEN_TYPE: u32 = 0x8C11;
    #[classattr]
    const TEXTURE_HEIGHT: u32 = 0x1001;
    #[classattr]
    const TEXTURE_IMMUTABLE_FORMAT: u32 = 0x912F;
    #[classattr]
    const TEXTURE_IMMUTABLE_FORMAT_EXT: u32 = 0x912F;
    #[classattr]
    const TEXTURE_IMMUTABLE_LEVELS: u32 = 0x82DF;
    #[classattr]
    const TEXTURE_INTENSITY_SIZE: u32 = 0x8061;
    #[classattr]
    const TEXTURE_INTENSITY_TYPE: u32 = 0x8C15;
    #[classattr]
    const TEXTURE_INTERNAL_FORMAT: u32 = 0x1003;
    #[classattr]
    const TEXTURE_LOD_BIAS: u32 = 0x8501;
    #[classattr]
    const TEXTURE_LUMINANCE_SIZE: u32 = 0x8060;
    #[classattr]
    const TEXTURE_LUMINANCE_TYPE: u32 = 0x8C14;
    #[classattr]
    const TEXTURE_MAG_FILTER: u32 = 0x2800;
    #[classattr]
    const TEXTURE_MATRIX: u32 = 0x0BA8;
    #[classattr]
    const TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FE;
    #[classattr]
    const TEXTURE_MAX_LEVEL: u32 = 0x813D;
    #[classattr]
    const TEXTURE_MAX_LOD: u32 = 0x813B;
    #[classattr]
    const TEXTURE_MIN_FILTER: u32 = 0x2801;
    #[classattr]
    const TEXTURE_MIN_LOD: u32 = 0x813A;
    #[classattr]
    const TEXTURE_PRIORITY: u32 = 0x8066;
    #[classattr]
    const TEXTURE_RANGE_LENGTH_APPLE: u32 = 0x85B7;
    #[classattr]
    const TEXTURE_RANGE_POINTER_APPLE: u32 = 0x85B8;
    #[classattr]
    const TEXTURE_RECTANGLE: u32 = 0x84F5;
    #[classattr]
    const TEXTURE_RECTANGLE_ARB: u32 = 0x84F5;
    #[classattr]
    const TEXTURE_RED_SIZE: u32 = 0x805C;
    #[classattr]
    const TEXTURE_RED_TYPE: u32 = 0x8C10;
    #[classattr]
    const TEXTURE_RESIDENT: u32 = 0x8067;
    #[classattr]
    const TEXTURE_SAMPLES: u32 = 0x9106;
    #[classattr]
    const TEXTURE_SHARED_SIZE: u32 = 0x8C3F;
    #[classattr]
    const TEXTURE_STACK_DEPTH: u32 = 0x0BA5;
    #[classattr]
    const TEXTURE_STENCIL_SIZE: u32 = 0x88F1;
    #[classattr]
    const TEXTURE_STORAGE_HINT_APPLE: u32 = 0x85BC;
    #[classattr]
    const TEXTURE_SWIZZLE_A: u32 = 0x8E45;
    #[classattr]
    const TEXTURE_SWIZZLE_B: u32 = 0x8E44;
    #[classattr]
    const TEXTURE_SWIZZLE_G: u32 = 0x8E43;
    #[classattr]
    const TEXTURE_SWIZZLE_R: u32 = 0x8E42;
    #[classattr]
    const TEXTURE_SWIZZLE_RGBA: u32 = 0x8E46;
    #[classattr]
    const TEXTURE_USAGE_ANGLE: u32 = 0x93A2;
    #[classattr]
    const TEXTURE_WIDTH: u32 = 0x1000;
    #[classattr]
    const TEXTURE_WRAP_R: u32 = 0x8072;
    #[classattr]
    const TEXTURE_WRAP_S: u32 = 0x2802;
    #[classattr]
    const TEXTURE_WRAP_T: u32 = 0x2803;
    #[classattr]
    const TIMEOUT_EXPIRED: u32 = 0x911B;
    #[classattr]
    const TIMEOUT_IGNORED: u64 = 0xFFFFFFFFFFFFFFFF;
    #[classattr]
    const TIMESTAMP: u32 = 0x8E28;
    #[classattr]
    const TIMESTAMP_EXT: u32 = 0x8E28;
    #[classattr]
    const TIME_ELAPSED: u32 = 0x88BF;
    #[classattr]
    const TIME_ELAPSED_EXT: u32 = 0x88BF;
    #[classattr]
    const TRANSFORM_BIT: u32 = 0x00001000;
    #[classattr]
    const TRANSFORM_FEEDBACK: u32 = 0x8E22;
    #[classattr]
    const TRANSFORM_FEEDBACK_ACTIVE: u32 = 0x8E24;
    #[classattr]
    const TRANSFORM_FEEDBACK_BINDING: u32 = 0x8E25;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER: u32 = 0x8C8E;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER_BINDING: u32 = 0x8C8F;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER_MODE: u32 = 0x8C7F;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER_SIZE: u32 = 0x8C85;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER_START: u32 = 0x8C84;
    #[classattr]
    const TRANSFORM_FEEDBACK_PAUSED: u32 = 0x8E23;
    #[classattr]
    const TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: u32 = 0x8C88;
    #[classattr]
    const TRANSFORM_FEEDBACK_VARYINGS: u32 = 0x8C83;
    #[classattr]
    const TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: u32 = 0x8C76;
    #[classattr]
    const TRANSPOSE_COLOR_MATRIX: u32 = 0x84E6;
    #[classattr]
    const TRANSPOSE_MODELVIEW_MATRIX: u32 = 0x84E3;
    #[classattr]
    const TRANSPOSE_PROJECTION_MATRIX: u32 = 0x84E4;
    #[classattr]
    const TRANSPOSE_TEXTURE_MATRIX: u32 = 0x84E5;
    #[classattr]
    const TRIANGLES: u32 = 0x0004;
    #[classattr]
    const TRIANGLES_ADJACENCY: u32 = 0x000C;
    #[classattr]
    const TRIANGLE_FAN: u32 = 0x0006;
    #[classattr]
    const TRIANGLE_STRIP: u32 = 0x0005;
    #[classattr]
    const TRIANGLE_STRIP_ADJACENCY: u32 = 0x000D;
    #[classattr]
    const TRUE: u8 = 1;
    #[classattr]
    const UNIFORM_ARRAY_STRIDE: u32 = 0x8A3C;
    #[classattr]
    const UNIFORM_BLOCK_ACTIVE_UNIFORMS: u32 = 0x8A42;
    #[classattr]
    const UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: u32 = 0x8A43;
    #[classattr]
    const UNIFORM_BLOCK_BINDING: u32 = 0x8A3F;
    #[classattr]
    const UNIFORM_BLOCK_DATA_SIZE: u32 = 0x8A40;
    #[classattr]
    const UNIFORM_BLOCK_INDEX: u32 = 0x8A3A;
    #[classattr]
    const UNIFORM_BLOCK_NAME_LENGTH: u32 = 0x8A41;
    #[classattr]
    const UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: u32 = 0x8A46;
    #[classattr]
    const UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER: u32 = 0x8A45;
    #[classattr]
    const UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: u32 = 0x8A44;
    #[classattr]
    const UNIFORM_BUFFER: u32 = 0x8A11;
    #[classattr]
    const UNIFORM_BUFFER_BINDING: u32 = 0x8A28;
    #[classattr]
    const UNIFORM_BUFFER_OFFSET_ALIGNMENT: u32 = 0x8A34;
    #[classattr]
    const UNIFORM_BUFFER_SIZE: u32 = 0x8A2A;
    #[classattr]
    const UNIFORM_BUFFER_START: u32 = 0x8A29;
    #[classattr]
    const UNIFORM_IS_ROW_MAJOR: u32 = 0x8A3E;
    #[classattr]
    const UNIFORM_MATRIX_STRIDE: u32 = 0x8A3D;
    #[classattr]
    const UNIFORM_NAME_LENGTH: u32 = 0x8A39;
    #[classattr]
    const UNIFORM_OFFSET: u32 = 0x8A3B;
    #[classattr]
    const UNIFORM_SIZE: u32 = 0x8A38;
    #[classattr]
    const UNIFORM_TYPE: u32 = 0x8A37;
    #[classattr]
    const UNPACK_ALIGNMENT: u32 = 0x0CF5;
    #[classattr]
    const UNPACK_CLIENT_STORAGE_APPLE: u32 = 0x85B2;
    #[classattr]
    const UNPACK_IMAGE_HEIGHT: u32 = 0x806E;
    #[classattr]
    const UNPACK_LSB_FIRST: u32 = 0x0CF1;
    #[classattr]
    const UNPACK_ROW_LENGTH: u32 = 0x0CF2;
    #[classattr]
    const UNPACK_SKIP_IMAGES: u32 = 0x806D;
    #[classattr]
    const UNPACK_SKIP_PIXELS: u32 = 0x0CF4;
    #[classattr]
    const UNPACK_SKIP_ROWS: u32 = 0x0CF3;
    #[classattr]
    const UNPACK_SWAP_BYTES: u32 = 0x0CF0;
    #[classattr]
    const UNSIGNALED: u32 = 0x9118;
    #[classattr]
    const UNSIGNED_BYTE: u32 = 0x1401;
    #[classattr]
    const UNSIGNED_BYTE_2_3_3_REV: u32 = 0x8362;
    #[classattr]
    const UNSIGNED_BYTE_3_3_2: u32 = 0x8032;
    #[classattr]
    const UNSIGNED_INT: u32 = 0x1405;
    #[classattr]
    const UNSIGNED_INT_10F_11F_11F_REV: u32 = 0x8C3B;
    #[classattr]
    const UNSIGNED_INT_10_10_10_2: u32 = 0x8036;
    #[classattr]
    const UNSIGNED_INT_24_8: u32 = 0x84FA;
    #[classattr]
    const UNSIGNED_INT_2_10_10_10_REV: u32 = 0x8368;
    #[classattr]
    const UNSIGNED_INT_5_9_9_9_REV: u32 = 0x8C3E;
    #[classattr]
    const UNSIGNED_INT_8_8_8_8: u32 = 0x8035;
    #[classattr]
    const UNSIGNED_INT_8_8_8_8_REV: u32 = 0x8367;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_1D: u32 = 0x8DD1;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_1D_ARRAY: u32 = 0x8DD6;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D: u32 = 0x8DD2;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D_ARRAY: u32 = 0x8DD7;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x910A;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910D;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D_RECT: u32 = 0x8DD5;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_3D: u32 = 0x8DD3;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_BUFFER: u32 = 0x8DD8;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_CUBE: u32 = 0x8DD4;
    #[classattr]
    const UNSIGNED_INT_VEC2: u32 = 0x8DC6;
    #[classattr]
    const UNSIGNED_INT_VEC3: u32 = 0x8DC7;
    #[classattr]
    const UNSIGNED_INT_VEC4: u32 = 0x8DC8;
    #[classattr]
    const UNSIGNED_NORMALIZED: u32 = 0x8C17;
    #[classattr]
    const UNSIGNED_SHORT: u32 = 0x1403;
    #[classattr]
    const UNSIGNED_SHORT_1_5_5_5_REV: u32 = 0x8366;
    #[classattr]
    const UNSIGNED_SHORT_4_4_4_4: u32 = 0x8033;
    #[classattr]
    const UNSIGNED_SHORT_4_4_4_4_REV: u32 = 0x8365;
    #[classattr]
    const UNSIGNED_SHORT_5_5_5_1: u32 = 0x8034;
    #[classattr]
    const UNSIGNED_SHORT_5_6_5: u32 = 0x8363;
    #[classattr]
    const UNSIGNED_SHORT_5_6_5_REV: u32 = 0x8364;
    #[classattr]
    const UPPER_LEFT: u32 = 0x8CA2;
    #[classattr]
    const V2F: u32 = 0x2A20;
    #[classattr]
    const V3F: u32 = 0x2A21;
    #[classattr]
    const VALIDATE_STATUS: u32 = 0x8B83;
    #[classattr]
    const VENDOR: u32 = 0x1F00;
    #[classattr]
    const VERSION: u32 = 0x1F02;
    #[classattr]
    const VERTEX_ARRAY: u32 = 0x8074;
    #[classattr]
    const VERTEX_ARRAY_BINDING: u32 = 0x85B5;
    #[classattr]
    const VERTEX_ARRAY_BINDING_APPLE: u32 = 0x85B5;
    #[classattr]
    const VERTEX_ARRAY_BUFFER_BINDING: u32 = 0x8896;
    #[classattr]
    const VERTEX_ARRAY_KHR: u32 = 0x8074;
    #[classattr]
    const VERTEX_ARRAY_POINTER: u32 = 0x808E;
    #[classattr]
    const VERTEX_ARRAY_SIZE: u32 = 0x807A;
    #[classattr]
    const VERTEX_ARRAY_STRIDE: u32 = 0x807C;
    #[classattr]
    const VERTEX_ARRAY_TYPE: u32 = 0x807B;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: u32 = 0x889F;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_DIVISOR: u32 = 0x88FE;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_ENABLED: u32 = 0x8622;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_INTEGER: u32 = 0x88FD;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_NORMALIZED: u32 = 0x886A;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_POINTER: u32 = 0x8645;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_SIZE: u32 = 0x8623;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_STRIDE: u32 = 0x8624;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_TYPE: u32 = 0x8625;
    #[classattr]
    const VERTEX_PROGRAM_POINT_SIZE: u32 = 0x8642;
    #[classattr]
    const VERTEX_PROGRAM_TWO_SIDE: u32 = 0x8643;
    #[classattr]
    const VERTEX_SHADER: u32 = 0x8B31;
    #[classattr]
    const VIEWPORT: u32 = 0x0BA2;
    #[classattr]
    const VIEWPORT_BIT: u32 = 0x00000800;
    #[classattr]
    const WAIT_FAILED: u32 = 0x911D;
    #[classattr]
    const WEIGHT_ARRAY_BUFFER_BINDING: u32 = 0x889E;
    #[classattr]
    const WRITE_ONLY: u32 = 0x88B9;
    #[classattr]
    const XOR: u32 = 0x1506;
    #[classattr]
    const ZERO: u32 = 0;
    #[classattr]
    const ZOOM_X: u32 = 0x0D16;
    #[classattr]
    const ZOOM_Y: u32 = 0x0D17;

    fn get_type(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn buffer_data_untyped(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn buffer_sub_data_untyped(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn map_buffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn map_buffer_range(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn unmap_buffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_buffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn shader_source(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn read_buffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn read_pixels_into_buffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn read_pixels(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn read_pixels_into_pbo(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn sample_coverage(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn polygon_offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn pixel_store_i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn gen_buffers(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn gen_renderbuffers(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn gen_framebuffers(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn gen_textures(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn gen_vertex_arrays(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn gen_queries(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn begin_query(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn end_query(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn query_counter(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_query_object_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_query_object_uiv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_query_object_i64v(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_query_object_ui64v(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_queries(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_vertex_arrays(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_buffers(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_renderbuffers(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_framebuffers(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_textures(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn framebuffer_renderbuffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn renderbuffer_storage(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn depth_func(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn active_texture(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn attach_shader(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_attrib_location(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_uniform_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_uniform_fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_uniform_block_index(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_uniform_indices(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_buffer_base(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_buffer_range(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_block_binding(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_buffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_vertex_array(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_renderbuffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_framebuffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_texture(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn draw_buffers(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_image_2d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn compressed_tex_image_2d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn compressed_tex_sub_image_2d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_image_3d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn copy_tex_image_2d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn copy_tex_sub_image_2d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn copy_tex_sub_image_3d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_sub_image_2d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_sub_image_2d_pbo(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_sub_image_3d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_sub_image_3d_pbo(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_storage_2d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_storage_3d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_tex_image_into_buffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn copy_image_sub_data(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn invalidate_framebuffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn invalidate_sub_framebuffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_integer_v(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_integer_64v(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_integer_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_integer_64iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_boolean_v(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_float_v(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_framebuffer_attachment_parameter_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_renderbuffer_parameter_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_tex_parameter_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_tex_parameter_fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_parameter_i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tex_parameter_f(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn framebuffer_texture_2d(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn framebuffer_texture_layer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn blit_framebuffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn vertex_attrib_4f(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn vertex_attrib_pointer_f32(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn vertex_attrib_pointer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn vertex_attrib_i_pointer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn vertex_attrib_divisor(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn viewport(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn scissor(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn line_width(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn use_program(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn validate_program(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn draw_arrays(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn draw_arrays_instanced(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn draw_elements(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn draw_elements_instanced(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn blend_color(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn blend_func(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn blend_func_separate(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn blend_equation(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn blend_equation_separate(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn color_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn cull_face(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn front_face(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn enable(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn disable(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn hint(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_enabled(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_shader(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_texture(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_framebuffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_renderbuffer(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn check_frame_buffer_status(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn enable_vertex_attrib_array(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn disable_vertex_attrib_array(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_1f(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_1fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_1i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_1iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_1ui(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_2f(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_2fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_2i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_2iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_2ui(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_3f(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_3fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_3i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_3iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_3ui(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_4f(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_4i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_4iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_4ui(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_4fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_matrix_2fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_matrix_3fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn uniform_matrix_4fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn depth_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn depth_range(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_active_attrib(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_active_uniform(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_active_uniforms_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_active_uniform_block_i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_active_uniform_block_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_active_uniform_block_name(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_attrib_location(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_frag_data_location(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_uniform_location(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_program_info_log(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_program_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_program_binary(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn program_binary(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn program_parameter_i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_vertex_attrib_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_vertex_attrib_fv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_vertex_attrib_pointer_v(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_buffer_parameter_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_shader_info_log(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_string(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_string_i(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_shader_iv(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_shader_precision_format(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn compile_shader(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn create_program(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_program(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn create_shader(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_shader(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn detach_shader(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn link_program(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn clear_color(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn clear(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn clear_depth(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn clear_stencil(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn flush(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn finish(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_error(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn stencil_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn stencil_mask_separate(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn stencil_func(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn stencil_func_separate(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn stencil_op(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn stencil_op_separate(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn egl_image_target_texture2d_oes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn generate_mipmap(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn insert_event_marker_ext(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn push_group_marker_ext(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn pop_group_marker_ext(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn debug_message_insert_khr(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn push_debug_group_khr(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn pop_debug_group_khr(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn fence_sync(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn client_wait_sync(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn wait_sync(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_sync(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn texture_range_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn gen_fences_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_fences_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn set_fence_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn finish_fence_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn test_fence_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn test_object_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn finish_object_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_frag_data_index(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn blend_barrier_khr(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_frag_data_location_indexed(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_debug_messages(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn provoking_vertex_angle(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn gen_vertex_arrays_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bind_vertex_array_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn delete_vertex_arrays_apple(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn copy_texture_chromium(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn copy_sub_texture_chromium(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn egl_image_target_renderbuffer_storage_oes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn copy_texture_3d_angle(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn copy_sub_texture_3d_angle(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn buffer_storage(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn flush_mapped_buffer_range(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzGlContextPtr {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlContextPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlContextPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGetProgramBinaryReturn {
}

#[pyproto]
impl PyObjectProtocol for AzGetProgramBinaryReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GetProgramBinaryReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GetProgramBinaryReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGetActiveAttribReturn {
}

#[pyproto]
impl PyObjectProtocol for AzGetActiveAttribReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GetActiveAttribReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GetActiveAttribReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLsyncPtr {
}

#[pyproto]
impl PyObjectProtocol for AzGLsyncPtr {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLsyncPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLsyncPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGetActiveUniformReturn {
}

#[pyproto]
impl PyObjectProtocol for AzGetActiveUniformReturn {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GetActiveUniformReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GetActiveUniformReturn = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgVertex {
}

#[pyproto]
impl PyObjectProtocol for AzSvgVertex {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgVertex = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgVertex = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexArrayObject {
}

#[pyproto]
impl PyObjectProtocol for AzVertexArrayObject {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexArrayObject = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexArrayObject = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIndexBufferFormatEnumWrapper {
    #[classattr]
    const Points: AzIndexBufferFormat = AzIndexBufferFormat::Points;
    #[classattr]
    const Lines: AzIndexBufferFormat = AzIndexBufferFormat::Lines;
    #[classattr]
    const LineStrip: AzIndexBufferFormat = AzIndexBufferFormat::LineStrip;
    #[classattr]
    const Triangles: AzIndexBufferFormat = AzIndexBufferFormat::Triangles;
    #[classattr]
    const TriangleStrip: AzIndexBufferFormat = AzIndexBufferFormat::TriangleStrip;
    #[classattr]
    const TriangleFan: AzIndexBufferFormat = AzIndexBufferFormat::TriangleFan;
}

#[pyproto]
impl PyObjectProtocol for AzIndexBufferFormatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::IndexBufferFormat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::IndexBufferFormat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzIndexBufferFormatEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzVertexBuffer {
}

#[pyproto]
impl PyObjectProtocol for AzVertexBuffer {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexBuffer = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexBuffer = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlTypeEnumWrapper {
    #[classattr]
    const Gl: AzGlType = AzGlType::Gl;
    #[classattr]
    const Gles: AzGlType = AzGlType::Gles;
}

#[pyproto]
impl PyObjectProtocol for AzGlTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GlType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzGlTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzImageRef {
    #[staticmethod]
    fn null_image(/* args */) -> AzImageRef {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn raw_image(/* args */) -> AzImageRef {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn gl_texture(/* args */) -> AzImageRef {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn clone_bytes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_invalid(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_gl_texture(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_raw_image(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_callback(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_raw_image(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_hash(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzImageRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::ImageRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::ImageRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRawImage {
    #[staticmethod]
    fn empty(/* args */) -> AzRawImage {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn allocate_clip_mask(/* args */) -> AzRawImage {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn decode_image_bytes_any(/* args */) -> AzRawImage {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn draw_clip_mask(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn encode_bmp(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn encode_png(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn encode_jpeg(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn encode_tga(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn encode_pnm(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn encode_gif(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn encode_tiff(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzRawImage {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::RawImage = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::RawImage = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzImageMask {
}

#[pyproto]
impl PyObjectProtocol for AzImageMask {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::ImageMask = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::ImageMask = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRawImageFormatEnumWrapper {
    #[classattr]
    const R8: AzRawImageFormat = AzRawImageFormat::R8;
    #[classattr]
    const RG8: AzRawImageFormat = AzRawImageFormat::RG8;
    #[classattr]
    const RGB8: AzRawImageFormat = AzRawImageFormat::RGB8;
    #[classattr]
    const RGBA8: AzRawImageFormat = AzRawImageFormat::RGBA8;
    #[classattr]
    const R16: AzRawImageFormat = AzRawImageFormat::R16;
    #[classattr]
    const RG16: AzRawImageFormat = AzRawImageFormat::RG16;
    #[classattr]
    const RGB16: AzRawImageFormat = AzRawImageFormat::RGB16;
    #[classattr]
    const RGBA16: AzRawImageFormat = AzRawImageFormat::RGBA16;
    #[classattr]
    const BGR8: AzRawImageFormat = AzRawImageFormat::BGR8;
    #[classattr]
    const BGRA8: AzRawImageFormat = AzRawImageFormat::BGRA8;
    #[classattr]
    const RGBF32: AzRawImageFormat = AzRawImageFormat::RGBF32;
    #[classattr]
    const RGBAF32: AzRawImageFormat = AzRawImageFormat::RGBAF32;
}

#[pyproto]
impl PyObjectProtocol for AzRawImageFormatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::RawImageFormat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::RawImageFormat = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzRawImageFormatEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzRawImageDataEnumWrapper {
    #[staticmethod]
    fn U8(v: U8Vec) -> AzRawImageDataEnumWrapper {
        AzRawImageDataEnumWrapper { inner: AzRawImageData::U8(v) }}
    }
    #[staticmethod]
    fn U16(v: U16Vec) -> AzRawImageDataEnumWrapper {
        AzRawImageDataEnumWrapper { inner: AzRawImageData::U16(v) }}
    }
    #[staticmethod]
    fn F32(v: F32Vec) -> AzRawImageDataEnumWrapper {
        AzRawImageDataEnumWrapper { inner: AzRawImageData::F32(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzRawImageData;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzRawImageData::U8(v) => Ok(vec!["U8".into_py(py), v.into_py(py)]),
            AzRawImageData::U16(v) => Ok(vec!["U16".into_py(py), v.into_py(py)]),
            AzRawImageData::F32(v) => Ok(vec!["F32".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRawImageDataEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::RawImageData = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::RawImageData = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzImageRenderingEnumWrapper {
    #[classattr]
    const OptimizeQuality: AzImageRendering = AzImageRendering::OptimizeQuality;
    #[classattr]
    const OptimizeSpeed: AzImageRendering = AzImageRendering::OptimizeSpeed;
}

#[pyproto]
impl PyObjectProtocol for AzImageRenderingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::ImageRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::ImageRendering = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzImageRenderingEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzFontMetrics {
    #[staticmethod]
    fn zero(/* args */) -> AzFontMetrics {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn use_typo_metrics(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_ascender(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_descender(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_line_gap(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_x_min(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_min(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_x_max(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_max(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_advance_width_max(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_min_left_side_bearing(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_min_right_side_bearing(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_x_max_extent(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_x_avg_char_width(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_subscript_x_size(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_subscript_y_size(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_subscript_x_offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_subscript_y_offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_superscript_x_size(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_superscript_y_size(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_superscript_x_offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_superscript_y_offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_strikeout_size(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_strikeout_position(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzFontMetrics {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::FontMetrics = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::FontMetrics = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFontRef {
    #[staticmethod]
    fn parse(/* args */) -> AzFontRef {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn get_bytes(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_font_metrics(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_hash(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzFontRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::FontRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::FontRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLoadedFontSource {
}

#[pyproto]
impl PyObjectProtocol for AzLoadedFontSource {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::LoadedFontSource = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::LoadedFontSource = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvg {
    #[staticmethod]
    fn from_string(/* args */) -> AzSvg {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn from_bytes(/* args */) -> AzSvg {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn get_root(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn render(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn to_string(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvg {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::Svg = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::Svg = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgMultiPolygon {
    fn get_bounds(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn contains_point(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn union(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn intersection(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn difference(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn xor(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_fill(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_stroke(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgMultiPolygon {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgMultiPolygon = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgMultiPolygon = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgNodeEnumWrapper {
    #[staticmethod]
    fn MultiPolygonCollection(v: SvgMultiPolygonVec) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper { inner: AzSvgNode::MultiPolygonCollection(v) }}
    }
    #[staticmethod]
    fn MultiPolygon(v: SvgMultiPolygon) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper { inner: AzSvgNode::MultiPolygon(v) }}
    }
    #[staticmethod]
    fn MultiShape(v: SvgSimpleNodeVec) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper { inner: AzSvgNode::MultiShape(v) }}
    }
    #[staticmethod]
    fn Path(v: SvgPath) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper { inner: AzSvgNode::Path(v) }}
    }
    #[staticmethod]
    fn Circle(v: SvgCircle) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper { inner: AzSvgNode::Circle(v) }}
    }
    #[staticmethod]
    fn Rect(v: SvgRect) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper { inner: AzSvgNode::Rect(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgNode;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgNode::MultiPolygonCollection(v) => Ok(vec!["MultiPolygonCollection".into_py(py), v.into_py(py)]),
            AzSvgNode::MultiPolygon(v) => Ok(vec!["MultiPolygon".into_py(py), v.into_py(py)]),
            AzSvgNode::MultiShape(v) => Ok(vec!["MultiShape".into_py(py), v.into_py(py)]),
            AzSvgNode::Path(v) => Ok(vec!["Path".into_py(py), v.into_py(py)]),
            AzSvgNode::Circle(v) => Ok(vec!["Circle".into_py(py), v.into_py(py)]),
            AzSvgNode::Rect(v) => Ok(vec!["Rect".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgNodeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgNode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgNode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgCircle {
    fn tessellate_fill(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_stroke(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgCircle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgCircle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgCircle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPath {
    fn is_closed(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn reverse(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_start(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_end(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_bounds(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn join_with(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn bevel(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_fill(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_stroke(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgPath {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathElementEnumWrapper {
    #[staticmethod]
    fn Line(v: SvgLine) -> AzSvgPathElementEnumWrapper {
        AzSvgPathElementEnumWrapper { inner: AzSvgPathElement::Line(v) }}
    }
    #[staticmethod]
    fn QuadraticCurve(v: SvgQuadraticCurve) -> AzSvgPathElementEnumWrapper {
        AzSvgPathElementEnumWrapper { inner: AzSvgPathElement::QuadraticCurve(v) }}
    }
    #[staticmethod]
    fn CubicCurve(v: SvgCubicCurve) -> AzSvgPathElementEnumWrapper {
        AzSvgPathElementEnumWrapper { inner: AzSvgPathElement::CubicCurve(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgPathElement;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgPathElement::Line(v) => Ok(vec!["Line".into_py(py), v.into_py(py)]),
            AzSvgPathElement::QuadraticCurve(v) => Ok(vec!["QuadraticCurve".into_py(py), v.into_py(py)]),
            AzSvgPathElement::CubicCurve(v) => Ok(vec!["CubicCurve".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathElementEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathElement = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathElement = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPoint {
    fn distance(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgPoint {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgPoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgPoint = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgVector {
    fn angle_degrees(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn normalize(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn rotate_90deg_ccw(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgVector {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgVector = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgVector = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgLine {
    fn reverse(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_start(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_end(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_bounds(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_length(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_t_at_offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_x_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_tangent_vector_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn intersect(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_stroke(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgLine {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgLine = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgLine = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgQuadraticCurve {
    fn reverse(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_start(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_end(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_bounds(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_length(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_t_at_offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_x_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_tangent_vector_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_stroke(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgQuadraticCurve {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgQuadraticCurve = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgQuadraticCurve = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgCubicCurve {
    fn reverse(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_start(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_end(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_bounds(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_length(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_t_at_offset(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_x_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_y_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_tangent_vector_at_t(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_stroke(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgCubicCurve {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgCubicCurve = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgCubicCurve = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgRect {
    fn get_center(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn contains_point(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn expand(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_fill(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn tessellate_stroke(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgRect {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::SvgRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedSvgNode {
    #[staticmethod]
    fn empty(/* args */) -> AzTessellatedSvgNode {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    #[staticmethod]
    fn from_nodes(/* args */) -> AzTessellatedSvgNode {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzTessellatedSvgNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgDashPattern {
}

#[pyproto]
impl PyObjectProtocol for AzSvgDashPattern {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgDashPattern = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgDashPattern = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgFitToEnumWrapper {
    #[classattr]
    fn Original() -> AzSvgFitToEnumWrapper {
        AzSvgFitToEnumWrapper { inner: AzSvgFitTo::Original }
    }
    #[staticmethod]
    fn Width(v: u32) -> AzSvgFitToEnumWrapper {
        AzSvgFitToEnumWrapper { inner: AzSvgFitTo::Width(v) }}
    }
    #[staticmethod]
    fn Height(v: u32) -> AzSvgFitToEnumWrapper {
        AzSvgFitToEnumWrapper { inner: AzSvgFitTo::Height(v) }}
    }
    #[staticmethod]
    fn Zoom(v: f32) -> AzSvgFitToEnumWrapper {
        AzSvgFitToEnumWrapper { inner: AzSvgFitTo::Zoom(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgFitTo;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgFitTo::Original => Ok(vec!["Original".into_py(py), ().into_py(py)]),
            AzSvgFitTo::Width(v) => Ok(vec!["Width".into_py(py), v.into_py(py)]),
            AzSvgFitTo::Height(v) => Ok(vec!["Height".into_py(py), v.into_py(py)]),
            AzSvgFitTo::Zoom(v) => Ok(vec!["Zoom".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgFitToEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgFitTo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgFitTo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgFillRuleEnumWrapper {
    #[classattr]
    const Winding: AzSvgFillRule = AzSvgFillRule::Winding;
    #[classattr]
    const EvenOdd: AzSvgFillRule = AzSvgFillRule::EvenOdd;
}

#[pyproto]
impl PyObjectProtocol for AzSvgFillRuleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgFillRule = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgFillRule = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzSvgFillRuleEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSvgStrokeStyle {
    #[staticmethod]
    fn default(/* args */) -> AzSvgStrokeStyle {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzSvgStrokeStyle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgStrokeStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgStrokeStyle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgLineJoinEnumWrapper {
    #[classattr]
    const Miter: AzSvgLineJoin = AzSvgLineJoin::Miter;
    #[classattr]
    const MiterClip: AzSvgLineJoin = AzSvgLineJoin::MiterClip;
    #[classattr]
    const Round: AzSvgLineJoin = AzSvgLineJoin::Round;
    #[classattr]
    const Bevel: AzSvgLineJoin = AzSvgLineJoin::Bevel;
}

#[pyproto]
impl PyObjectProtocol for AzSvgLineJoinEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgLineJoin = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgLineJoin = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzSvgLineJoinEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzSvgLineCapEnumWrapper {
    #[classattr]
    const Butt: AzSvgLineCap = AzSvgLineCap::Butt;
    #[classattr]
    const Square: AzSvgLineCap = AzSvgLineCap::Square;
    #[classattr]
    const Round: AzSvgLineCap = AzSvgLineCap::Round;
}

#[pyproto]
impl PyObjectProtocol for AzSvgLineCapEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgLineCap = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgLineCap = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzSvgLineCapEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzCssPathPseudoSelectorEnumWrapper {
    #[classattr]
    fn First() -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::First }
    }
    #[classattr]
    fn Last() -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::Last }
    }
    #[staticmethod]
    fn NthChild(v: CssNthChildSelector) -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::NthChild(v) }}
    }
    #[classattr]
    fn Hover() -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::Hover }
    }
    #[classattr]
    fn Active() -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::Active }
    }
    #[classattr]
    fn Focus() -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper { inner: AzCssPathPseudoSelector::Focus }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssPathPseudoSelector;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPathPseudoSelector::First => Ok(vec!["First".into_py(py), ().into_py(py)]),
            AzCssPathPseudoSelector::Last => Ok(vec!["Last".into_py(py), ().into_py(py)]),
            AzCssPathPseudoSelector::NthChild(v) => Ok(vec!["NthChild".into_py(py), v.into_py(py)]),
            AzCssPathPseudoSelector::Hover => Ok(vec!["Hover".into_py(py), ().into_py(py)]),
            AzCssPathPseudoSelector::Active => Ok(vec!["Active".into_py(py), ().into_py(py)]),
            AzCssPathPseudoSelector::Focus => Ok(vec!["Focus".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPathPseudoSelectorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPathPseudoSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPathPseudoSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalRect {
}

#[pyproto]
impl PyObjectProtocol for AzLogicalRect {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::LogicalRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::LogicalRect = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPathSelectorEnumWrapper {
    #[classattr]
    fn Global() -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::Global }
    }
    #[staticmethod]
    fn Type(v: NodeTypeTag) -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::Type(v) }}
    }
    #[staticmethod]
    fn Class(v: String) -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::Class(v) }}
    }
    #[staticmethod]
    fn Id(v: String) -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::Id(v) }}
    }
    #[staticmethod]
    fn PseudoSelector(v: CssPathPseudoSelector) -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::PseudoSelector(v) }}
    }
    #[classattr]
    fn DirectChildren() -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::DirectChildren }
    }
    #[classattr]
    fn Children() -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::Children }
    }
    #[classattr]
    fn AdjacentSibling() -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::AdjacentSibling }
    }
    #[classattr]
    fn GeneralSibling() -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper { inner: AzCssPathSelector::GeneralSibling }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssPathSelector;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPathSelector::Global => Ok(vec!["Global".into_py(py), ().into_py(py)]),
            AzCssPathSelector::Type(v) => Ok(vec!["Type".into_py(py), v.into_py(py)]),
            AzCssPathSelector::Class(v) => Ok(vec!["Class".into_py(py), v.into_py(py)]),
            AzCssPathSelector::Id(v) => Ok(vec!["Id".into_py(py), v.into_py(py)]),
            AzCssPathSelector::PseudoSelector(v) => Ok(vec!["PseudoSelector".into_py(py), v.into_py(py)]),
            AzCssPathSelector::DirectChildren => Ok(vec!["DirectChildren".into_py(py), ().into_py(py)]),
            AzCssPathSelector::Children => Ok(vec!["Children".into_py(py), ().into_py(py)]),
            AzCssPathSelector::AdjacentSibling => Ok(vec!["AdjacentSibling".into_py(py), ().into_py(py)]),
            AzCssPathSelector::GeneralSibling => Ok(vec!["GeneralSibling".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPathSelectorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPathSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPathSelector = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPath {
}

#[pyproto]
impl PyObjectProtocol for AzCssPath {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPath = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedGPUSvgNode {
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedGPUSvgNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedGPUSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedGPUSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedColoredGPUSvgNode {
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedColoredGPUSvgNode {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedColoredGPUSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedColoredGPUSvgNode = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapeCircle {
}

#[pyproto]
impl PyObjectProtocol for AzShapeCircle {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::ShapeCircle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::ShapeCircle = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapePolygon {
}

#[pyproto]
impl PyObjectProtocol for AzShapePolygon {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::ShapePolygon = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::ShapePolygon = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXml {
    #[staticmethod]
    fn from_str(/* args */) -> AzXml {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzXml {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::Xml = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::Xml = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInstantEnumWrapper {
    #[staticmethod]
    fn System(v: InstantPtr) -> AzInstantEnumWrapper {
        AzInstantEnumWrapper { inner: AzInstant::System(v) }}
    }
    #[staticmethod]
    fn Tick(v: SystemTick) -> AzInstantEnumWrapper {
        AzInstantEnumWrapper { inner: AzInstant::Tick(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzInstant;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInstant::System(v) => Ok(vec!["System".into_py(py), v.into_py(py)]),
            AzInstant::Tick(v) => Ok(vec!["Tick".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInstantEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::Instant = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::Instant = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemTickDiff {
}

#[pyproto]
impl PyObjectProtocol for AzSystemTickDiff {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::SystemTickDiff = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::SystemTickDiff = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemTick {
}

#[pyproto]
impl PyObjectProtocol for AzSystemTick {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::SystemTick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::SystemTick = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDurationEnumWrapper {
    #[staticmethod]
    fn System(v: SystemTimeDiff) -> AzDurationEnumWrapper {
        AzDurationEnumWrapper { inner: AzDuration::System(v) }}
    }
    #[staticmethod]
    fn Tick(v: SystemTickDiff) -> AzDurationEnumWrapper {
        AzDurationEnumWrapper { inner: AzDuration::Tick(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzDuration;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzDuration::System(v) => Ok(vec!["System".into_py(py), v.into_py(py)]),
            AzDuration::Tick(v) => Ok(vec!["Tick".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDurationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::Duration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::Duration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemTimeDiff {
}

#[pyproto]
impl PyObjectProtocol for AzSystemTimeDiff {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::SystemTimeDiff = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::SystemTimeDiff = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTimerId {
}

#[pyproto]
impl PyObjectProtocol for AzTimerId {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::TimerId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::TimerId = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInstantPtr {
}

#[pyproto]
impl PyObjectProtocol for AzInstantPtr {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::InstantPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::InstantPtr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssDuration {
}

#[pyproto]
impl PyObjectProtocol for AzCssDuration {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::time::CssDuration = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::time::CssDuration = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzString {
}

#[pyproto]
impl PyObjectProtocol for AzString {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::AzString = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::AzString = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRefstr {
}

#[pyproto]
impl PyObjectProtocol for AzRefstr {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::Refstr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::Refstr = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringPair {
}

#[pyproto]
impl PyObjectProtocol for AzStringPair {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::AzStringPair = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::AzStringPair = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringSet {
}

#[pyproto]
impl PyObjectProtocol for AzStringSet {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::content::StringSet = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::content::StringSet = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewRowVec {
}

#[pyproto]
impl PyObjectProtocol for AzListViewRowVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewRowVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewRowVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFilterVec {
}

#[pyproto]
impl PyObjectProtocol for AzStyleFilterVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleFilterVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleFilterVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAccessibilityStateVec {
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityStateVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityStateVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityStateVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuItemVec {
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItemVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItemVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontFamilyVec {
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontFamilyVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontFamilyVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontFamilyVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomVec {
}

#[pyproto]
impl PyObjectProtocol for AzDomVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::DomVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::DomVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIdOrClassVec {
}

#[pyproto]
impl PyObjectProtocol for AzIdOrClassVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::IdOrClassVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::IdOrClassVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataInlineCssPropertyVec {
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataInlineCssPropertyVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataInlineCssPropertyVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataInlineCssPropertyVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundContentVec {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundContentVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundContentVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundContentVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundPositionVec {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundPositionVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundPositionVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundPositionVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundRepeatVec {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundRepeatVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundRepeatVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundRepeatVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundSizeVec {
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundSizeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundSizeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundSizeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformVec {
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgMultiPolygonVec {
}

#[pyproto]
impl PyObjectProtocol for AzSvgMultiPolygonVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgMultiPolygonVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgMultiPolygonVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgSimpleNodeVec {
}

#[pyproto]
impl PyObjectProtocol for AzSvgSimpleNodeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgSimpleNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgSimpleNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathVec {
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathElementVec {
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathElementVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathElementVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathElementVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgVertexVec {
}

#[pyproto]
impl PyObjectProtocol for AzSvgVertexVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgVertexVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgVertexVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU32Vec {
}

#[pyproto]
impl PyObjectProtocol for AzU32Vec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U32Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U32Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVirtualKeyCodeVec {
}

#[pyproto]
impl PyObjectProtocol for AzVirtualKeyCodeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCascadeInfoVec {
}

#[pyproto]
impl PyObjectProtocol for AzCascadeInfoVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::style::CascadeInfoVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::style::CascadeInfoVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssDeclarationVec {
}

#[pyproto]
impl PyObjectProtocol for AzCssDeclarationVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssDeclarationVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssDeclarationVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPathSelectorVec {
}

#[pyproto]
impl PyObjectProtocol for AzCssPathSelectorVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPathSelectorVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPathSelectorVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylesheetVec {
}

#[pyproto]
impl PyObjectProtocol for AzStylesheetVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::StylesheetVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::StylesheetVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssRuleBlockVec {
}

#[pyproto]
impl PyObjectProtocol for AzCssRuleBlockVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssRuleBlockVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssRuleBlockVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU16Vec {
}

#[pyproto]
impl PyObjectProtocol for AzU16Vec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U16Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U16Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzF32Vec {
}

#[pyproto]
impl PyObjectProtocol for AzF32Vec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::F32Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::F32Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU8Vec {
    fn as_ref_vec(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzU8Vec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U8Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U8Vec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLuintVec {
}

#[pyproto]
impl PyObjectProtocol for AzGLuintVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLuintVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLuintVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLintVec {
}

#[pyproto]
impl PyObjectProtocol for AzGLintVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLintVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLintVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringVec {
}

#[pyproto]
impl PyObjectProtocol for AzStringVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::StringVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::StringVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringPairVec {
}

#[pyproto]
impl PyObjectProtocol for AzStringPairVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::StringPairVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::StringPairVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedLinearColorStopVec {
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedLinearColorStopVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedLinearColorStopVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedLinearColorStopVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedRadialColorStopVec {
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedRadialColorStopVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedRadialColorStopVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedRadialColorStopVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdVec {
}

#[pyproto]
impl PyObjectProtocol for AzNodeIdVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeIdVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeIdVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeHierarchyItemVec {
}

#[pyproto]
impl PyObjectProtocol for AzNodeHierarchyItemVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeHierarchyItemVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeHierarchyItemVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledNodeVec {
}

#[pyproto]
impl PyObjectProtocol for AzStyledNodeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledNodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTagIdToNodeIdMappingVec {
}

#[pyproto]
impl PyObjectProtocol for AzTagIdToNodeIdMappingVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::TagIdToNodeIdMappingVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::TagIdToNodeIdMappingVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzParentWithNodeDepthVec {
}

#[pyproto]
impl PyObjectProtocol for AzParentWithNodeDepthVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::ParentWithNodeDepthVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::ParentWithNodeDepthVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataVec {
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAttributeVec {
}

#[pyproto]
impl PyObjectProtocol for AzAttributeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AttributeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AttributeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCoreCallbackDataVec {
}

#[pyproto]
impl PyObjectProtocol for AzCoreCallbackDataVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::CoreCallbackDataVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::CoreCallbackDataVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAccessibilityActionVec {
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityActionVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityActionVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityActionVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlNodeChildVec {
}

#[pyproto]
impl PyObjectProtocol for AzXmlNodeChildVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlNodeChildVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlNodeChildVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGridTrackSizingVec {
}

#[pyproto]
impl PyObjectProtocol for AzGridTrackSizingVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridTrackSizingVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridTrackSizingVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLbooleanVecRefMut {
}

#[pyproto]
impl PyObjectProtocol for AzGLbooleanVecRefMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLbooleanVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLbooleanVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRefstrVecRef {
}

#[pyproto]
impl PyObjectProtocol for AzRefstrVecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::RefstrVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::RefstrVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLfloatVecRefMut {
}

#[pyproto]
impl PyObjectProtocol for AzGLfloatVecRefMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLfloatVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLfloatVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU8VecRefMut {
}

#[pyproto]
impl PyObjectProtocol for AzU8VecRefMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::U8VecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::U8VecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedSvgNodeVecRef {
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedSvgNodeVecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedSvgNodeVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::TessellatedSvgNodeVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzF32VecRef {
}

#[pyproto]
impl PyObjectProtocol for AzF32VecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::F32VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::F32VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLuintVecRef {
}

#[pyproto]
impl PyObjectProtocol for AzGLuintVecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLuintVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLuintVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzI32VecRef {
}

#[pyproto]
impl PyObjectProtocol for AzI32VecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::I32VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::I32VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU8VecRef {
}

#[pyproto]
impl PyObjectProtocol for AzU8VecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::U8VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::U8VecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLintVecRefMut {
}

#[pyproto]
impl PyObjectProtocol for AzGLintVecRefMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLintVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLintVecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLenumVecRef {
}

#[pyproto]
impl PyObjectProtocol for AzGLenumVecRef {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLenumVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLenumVecRef = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLint64VecRefMut {
}

#[pyproto]
impl PyObjectProtocol for AzGLint64VecRefMut {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLint64VecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLint64VecRefMut = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionU8VecRefEnumWrapper {
    #[classattr]
    fn None() -> AzOptionU8VecRefEnumWrapper {
        AzOptionU8VecRefEnumWrapper { inner: AzOptionU8VecRef::None }
    }
    #[staticmethod]
    fn Some(v: U8VecRef) -> AzOptionU8VecRefEnumWrapper {
        AzOptionU8VecRefEnumWrapper { inner: AzOptionU8VecRef::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionU8VecRef;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionU8VecRef::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionU8VecRef::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionU8VecRefEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::OptionU8VecRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::OptionU8VecRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgPathVecDestructorEnumWrapper {
        AzSvgPathVecDestructorEnumWrapper { inner: AzSvgPathVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgPathVecDestructorEnumWrapper {
        AzSvgPathVecDestructorEnumWrapper { inner: AzSvgPathVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: SvgPathVecDestructorType) -> AzSvgPathVecDestructorEnumWrapper {
        AzSvgPathVecDestructorEnumWrapper { inner: AzSvgPathVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgPathVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgPathVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzSvgPathVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzSvgPathVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFilterVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleFilterVecDestructorEnumWrapper {
        AzStyleFilterVecDestructorEnumWrapper { inner: AzStyleFilterVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleFilterVecDestructorEnumWrapper {
        AzStyleFilterVecDestructorEnumWrapper { inner: AzStyleFilterVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StyleFilterVecDestructorType) -> AzStyleFilterVecDestructorEnumWrapper {
        AzStyleFilterVecDestructorEnumWrapper { inner: AzStyleFilterVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleFilterVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFilterVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleFilterVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleFilterVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFilterVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleFilterVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::filter::StyleFilterVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleTransformVecDestructorEnumWrapper {
        AzStyleTransformVecDestructorEnumWrapper { inner: AzStyleTransformVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleTransformVecDestructorEnumWrapper {
        AzStyleTransformVecDestructorEnumWrapper { inner: AzStyleTransformVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StyleTransformVecDestructorType) -> AzStyleTransformVecDestructorEnumWrapper {
        AzStyleTransformVecDestructorEnumWrapper { inner: AzStyleTransformVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleTransformVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTransformVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleTransformVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleTransformVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::transform::StyleTransformVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLuintVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzGLuintVecDestructorEnumWrapper {
        AzGLuintVecDestructorEnumWrapper { inner: AzGLuintVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzGLuintVecDestructorEnumWrapper {
        AzGLuintVecDestructorEnumWrapper { inner: AzGLuintVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: GLuintVecDestructorType) -> AzGLuintVecDestructorEnumWrapper {
        AzGLuintVecDestructorEnumWrapper { inner: AzGLuintVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzGLuintVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzGLuintVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzGLuintVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzGLuintVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGLuintVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLuintVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLuintVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlNodeChildVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzXmlNodeChildVecDestructorEnumWrapper {
        AzXmlNodeChildVecDestructorEnumWrapper { inner: AzXmlNodeChildVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzXmlNodeChildVecDestructorEnumWrapper {
        AzXmlNodeChildVecDestructorEnumWrapper { inner: AzXmlNodeChildVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: XmlNodeChildVecDestructorType) -> AzXmlNodeChildVecDestructorEnumWrapper {
        AzXmlNodeChildVecDestructorEnumWrapper { inner: AzXmlNodeChildVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzXmlNodeChildVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlNodeChildVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzXmlNodeChildVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzXmlNodeChildVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlNodeChildVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlNodeChildVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlNodeChildVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundContentVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleBackgroundContentVecDestructorEnumWrapper {
        AzStyleBackgroundContentVecDestructorEnumWrapper { inner: AzStyleBackgroundContentVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleBackgroundContentVecDestructorEnumWrapper {
        AzStyleBackgroundContentVecDestructorEnumWrapper { inner: AzStyleBackgroundContentVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StyleBackgroundContentVecDestructorType) -> AzStyleBackgroundContentVecDestructorEnumWrapper {
        AzStyleBackgroundContentVecDestructorEnumWrapper { inner: AzStyleBackgroundContentVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundContentVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundContentVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleBackgroundContentVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleBackgroundContentVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundContentVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundContentVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundContentVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCascadeInfoVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCascadeInfoVecDestructorEnumWrapper {
        AzCascadeInfoVecDestructorEnumWrapper { inner: AzCascadeInfoVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzCascadeInfoVecDestructorEnumWrapper {
        AzCascadeInfoVecDestructorEnumWrapper { inner: AzCascadeInfoVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: CascadeInfoVecDestructorType) -> AzCascadeInfoVecDestructorEnumWrapper {
        AzCascadeInfoVecDestructorEnumWrapper { inner: AzCascadeInfoVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCascadeInfoVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCascadeInfoVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCascadeInfoVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCascadeInfoVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCascadeInfoVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::style::CascadeInfoVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::style::CascadeInfoVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAccessibilityStateVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzAccessibilityStateVecDestructorEnumWrapper {
        AzAccessibilityStateVecDestructorEnumWrapper { inner: AzAccessibilityStateVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzAccessibilityStateVecDestructorEnumWrapper {
        AzAccessibilityStateVecDestructorEnumWrapper { inner: AzAccessibilityStateVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: AccessibilityStateVecDestructorType) -> AzAccessibilityStateVecDestructorEnumWrapper {
        AzAccessibilityStateVecDestructorEnumWrapper { inner: AzAccessibilityStateVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzAccessibilityStateVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAccessibilityStateVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzAccessibilityStateVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzAccessibilityStateVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityStateVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityStateVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityStateVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzDomVecDestructorEnumWrapper {
        AzDomVecDestructorEnumWrapper { inner: AzDomVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzDomVecDestructorEnumWrapper {
        AzDomVecDestructorEnumWrapper { inner: AzDomVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: DomVecDestructorType) -> AzDomVecDestructorEnumWrapper {
        AzDomVecDestructorEnumWrapper { inner: AzDomVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzDomVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzDomVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzDomVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzDomVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDomVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::DomVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::DomVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStringVecDestructorEnumWrapper {
        AzStringVecDestructorEnumWrapper { inner: AzStringVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStringVecDestructorEnumWrapper {
        AzStringVecDestructorEnumWrapper { inner: AzStringVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StringVecDestructorType) -> AzStringVecDestructorEnumWrapper {
        AzStringVecDestructorEnumWrapper { inner: AzStringVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStringVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStringVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStringVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStringVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStringVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::StringVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::StringVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeDataVecDestructorEnumWrapper {
        AzNodeDataVecDestructorEnumWrapper { inner: AzNodeDataVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeDataVecDestructorEnumWrapper {
        AzNodeDataVecDestructorEnumWrapper { inner: AzNodeDataVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: NodeDataVecDestructorType) -> AzNodeDataVecDestructorEnumWrapper {
        AzNodeDataVecDestructorEnumWrapper { inner: AzNodeDataVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeDataVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeDataVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeDataVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeDataVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuItemVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzMenuItemVecDestructorEnumWrapper {
        AzMenuItemVecDestructorEnumWrapper { inner: AzMenuItemVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzMenuItemVecDestructorEnumWrapper {
        AzMenuItemVecDestructorEnumWrapper { inner: AzMenuItemVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: MenuItemVecDestructorType) -> AzMenuItemVecDestructorEnumWrapper {
        AzMenuItemVecDestructorEnumWrapper { inner: AzMenuItemVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzMenuItemVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzMenuItemVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzMenuItemVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzMenuItemVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItemVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::MenuItemVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgMultiPolygonVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgMultiPolygonVecDestructorEnumWrapper {
        AzSvgMultiPolygonVecDestructorEnumWrapper { inner: AzSvgMultiPolygonVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgMultiPolygonVecDestructorEnumWrapper {
        AzSvgMultiPolygonVecDestructorEnumWrapper { inner: AzSvgMultiPolygonVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: SvgMultiPolygonVecDestructorType) -> AzSvgMultiPolygonVecDestructorEnumWrapper {
        AzSvgMultiPolygonVecDestructorEnumWrapper { inner: AzSvgMultiPolygonVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgMultiPolygonVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgMultiPolygonVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzSvgMultiPolygonVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzSvgMultiPolygonVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgMultiPolygonVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgMultiPolygonVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgMultiPolygonVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewRowVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzListViewRowVecDestructorEnumWrapper {
        AzListViewRowVecDestructorEnumWrapper { inner: AzListViewRowVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzListViewRowVecDestructorEnumWrapper {
        AzListViewRowVecDestructorEnumWrapper { inner: AzListViewRowVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: ListViewRowVecDestructorType) -> AzListViewRowVecDestructorEnumWrapper {
        AzListViewRowVecDestructorEnumWrapper { inner: AzListViewRowVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzListViewRowVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzListViewRowVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzListViewRowVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzListViewRowVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzListViewRowVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewRowVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::ListViewRowVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgVertexVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgVertexVecDestructorEnumWrapper {
        AzSvgVertexVecDestructorEnumWrapper { inner: AzSvgVertexVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgVertexVecDestructorEnumWrapper {
        AzSvgVertexVecDestructorEnumWrapper { inner: AzSvgVertexVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: SvgVertexVecDestructorType) -> AzSvgVertexVecDestructorEnumWrapper {
        AzSvgVertexVecDestructorEnumWrapper { inner: AzSvgVertexVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgVertexVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgVertexVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzSvgVertexVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzSvgVertexVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgVertexVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgVertexVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgVertexVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylesheetVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStylesheetVecDestructorEnumWrapper {
        AzStylesheetVecDestructorEnumWrapper { inner: AzStylesheetVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStylesheetVecDestructorEnumWrapper {
        AzStylesheetVecDestructorEnumWrapper { inner: AzStylesheetVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StylesheetVecDestructorType) -> AzStylesheetVecDestructorEnumWrapper {
        AzStylesheetVecDestructorEnumWrapper { inner: AzStylesheetVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStylesheetVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStylesheetVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStylesheetVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStylesheetVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStylesheetVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::StylesheetVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::StylesheetVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU32VecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzU32VecDestructorEnumWrapper {
        AzU32VecDestructorEnumWrapper { inner: AzU32VecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzU32VecDestructorEnumWrapper {
        AzU32VecDestructorEnumWrapper { inner: AzU32VecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: U32VecDestructorType) -> AzU32VecDestructorEnumWrapper {
        AzU32VecDestructorEnumWrapper { inner: AzU32VecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzU32VecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzU32VecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzU32VecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzU32VecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzU32VecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U32VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U32VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssRuleBlockVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCssRuleBlockVecDestructorEnumWrapper {
        AzCssRuleBlockVecDestructorEnumWrapper { inner: AzCssRuleBlockVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzCssRuleBlockVecDestructorEnumWrapper {
        AzCssRuleBlockVecDestructorEnumWrapper { inner: AzCssRuleBlockVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: CssRuleBlockVecDestructorType) -> AzCssRuleBlockVecDestructorEnumWrapper {
        AzCssRuleBlockVecDestructorEnumWrapper { inner: AzCssRuleBlockVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssRuleBlockVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssRuleBlockVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCssRuleBlockVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCssRuleBlockVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssRuleBlockVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssRuleBlockVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssRuleBlockVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedLinearColorStopVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNormalizedLinearColorStopVecDestructorEnumWrapper {
        AzNormalizedLinearColorStopVecDestructorEnumWrapper { inner: AzNormalizedLinearColorStopVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzNormalizedLinearColorStopVecDestructorEnumWrapper {
        AzNormalizedLinearColorStopVecDestructorEnumWrapper { inner: AzNormalizedLinearColorStopVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: NormalizedLinearColorStopVecDestructorType) -> AzNormalizedLinearColorStopVecDestructorEnumWrapper {
        AzNormalizedLinearColorStopVecDestructorEnumWrapper { inner: AzNormalizedLinearColorStopVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNormalizedLinearColorStopVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNormalizedLinearColorStopVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNormalizedLinearColorStopVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNormalizedLinearColorStopVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedLinearColorStopVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedLinearColorStopVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedLinearColorStopVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontFamilyVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleFontFamilyVecDestructorEnumWrapper {
        AzStyleFontFamilyVecDestructorEnumWrapper { inner: AzStyleFontFamilyVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleFontFamilyVecDestructorEnumWrapper {
        AzStyleFontFamilyVecDestructorEnumWrapper { inner: AzStyleFontFamilyVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StyleFontFamilyVecDestructorType) -> AzStyleFontFamilyVecDestructorEnumWrapper {
        AzStyleFontFamilyVecDestructorEnumWrapper { inner: AzStyleFontFamilyVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleFontFamilyVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFontFamilyVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontFamilyVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontFamilyVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::StyleFontFamilyVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPathSelectorVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCssPathSelectorVecDestructorEnumWrapper {
        AzCssPathSelectorVecDestructorEnumWrapper { inner: AzCssPathSelectorVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzCssPathSelectorVecDestructorEnumWrapper {
        AzCssPathSelectorVecDestructorEnumWrapper { inner: AzCssPathSelectorVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: CssPathSelectorVecDestructorType) -> AzCssPathSelectorVecDestructorEnumWrapper {
        AzCssPathSelectorVecDestructorEnumWrapper { inner: AzCssPathSelectorVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssPathSelectorVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPathSelectorVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCssPathSelectorVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCssPathSelectorVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPathSelectorVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPathSelectorVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssPathSelectorVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeHierarchyItemVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeHierarchyItemVecDestructorEnumWrapper {
        AzNodeHierarchyItemVecDestructorEnumWrapper { inner: AzNodeHierarchyItemVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeHierarchyItemVecDestructorEnumWrapper {
        AzNodeHierarchyItemVecDestructorEnumWrapper { inner: AzNodeHierarchyItemVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: NodeHierarchyItemVecDestructorType) -> AzNodeHierarchyItemVecDestructorEnumWrapper {
        AzNodeHierarchyItemVecDestructorEnumWrapper { inner: AzNodeHierarchyItemVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeHierarchyItemVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeHierarchyItemVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeHierarchyItemVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeHierarchyItemVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeHierarchyItemVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeHierarchyItemVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeHierarchyItemVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVirtualKeyCodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzVirtualKeyCodeVecDestructorEnumWrapper {
        AzVirtualKeyCodeVecDestructorEnumWrapper { inner: AzVirtualKeyCodeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzVirtualKeyCodeVecDestructorEnumWrapper {
        AzVirtualKeyCodeVecDestructorEnumWrapper { inner: AzVirtualKeyCodeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: VirtualKeyCodeVecDestructorType) -> AzVirtualKeyCodeVecDestructorEnumWrapper {
        AzVirtualKeyCodeVecDestructorEnumWrapper { inner: AzVirtualKeyCodeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzVirtualKeyCodeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzVirtualKeyCodeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzVirtualKeyCodeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzVirtualKeyCodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVirtualKeyCodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzF32VecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzF32VecDestructorEnumWrapper {
        AzF32VecDestructorEnumWrapper { inner: AzF32VecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzF32VecDestructorEnumWrapper {
        AzF32VecDestructorEnumWrapper { inner: AzF32VecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: F32VecDestructorType) -> AzF32VecDestructorEnumWrapper {
        AzF32VecDestructorEnumWrapper { inner: AzF32VecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzF32VecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzF32VecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzF32VecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzF32VecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzF32VecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::F32VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::F32VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundRepeatVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleBackgroundRepeatVecDestructorEnumWrapper {
        AzStyleBackgroundRepeatVecDestructorEnumWrapper { inner: AzStyleBackgroundRepeatVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleBackgroundRepeatVecDestructorEnumWrapper {
        AzStyleBackgroundRepeatVecDestructorEnumWrapper { inner: AzStyleBackgroundRepeatVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StyleBackgroundRepeatVecDestructorType) -> AzStyleBackgroundRepeatVecDestructorEnumWrapper {
        AzStyleBackgroundRepeatVecDestructorEnumWrapper { inner: AzStyleBackgroundRepeatVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundRepeatVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundRepeatVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleBackgroundRepeatVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleBackgroundRepeatVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundRepeatVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundRepeatVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundRepeatVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAccessibilityActionVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzAccessibilityActionVecDestructorEnumWrapper {
        AzAccessibilityActionVecDestructorEnumWrapper { inner: AzAccessibilityActionVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzAccessibilityActionVecDestructorEnumWrapper {
        AzAccessibilityActionVecDestructorEnumWrapper { inner: AzAccessibilityActionVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: AccessibilityActionVecDestructorType) -> AzAccessibilityActionVecDestructorEnumWrapper {
        AzAccessibilityActionVecDestructorEnumWrapper { inner: AzAccessibilityActionVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzAccessibilityActionVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAccessibilityActionVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzAccessibilityActionVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzAccessibilityActionVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityActionVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityActionVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AccessibilityActionVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU16VecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzU16VecDestructorEnumWrapper {
        AzU16VecDestructorEnumWrapper { inner: AzU16VecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzU16VecDestructorEnumWrapper {
        AzU16VecDestructorEnumWrapper { inner: AzU16VecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: U16VecDestructorType) -> AzU16VecDestructorEnumWrapper {
        AzU16VecDestructorEnumWrapper { inner: AzU16VecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzU16VecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzU16VecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzU16VecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzU16VecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzU16VecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U16VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U16VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
        AzTagIdToNodeIdMappingVecDestructorEnumWrapper { inner: AzTagIdToNodeIdMappingVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
        AzTagIdToNodeIdMappingVecDestructorEnumWrapper { inner: AzTagIdToNodeIdMappingVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: TagIdToNodeIdMappingVecDestructorType) -> AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
        AzTagIdToNodeIdMappingVecDestructorEnumWrapper { inner: AzTagIdToNodeIdMappingVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzTagIdToNodeIdMappingVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTagIdToNodeIdMappingVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzTagIdToNodeIdMappingVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzTagIdToNodeIdMappingVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::TagIdToNodeIdMappingVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::TagIdToNodeIdMappingVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeIdVecDestructorEnumWrapper {
        AzNodeIdVecDestructorEnumWrapper { inner: AzNodeIdVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeIdVecDestructorEnumWrapper {
        AzNodeIdVecDestructorEnumWrapper { inner: AzNodeIdVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: NodeIdVecDestructorType) -> AzNodeIdVecDestructorEnumWrapper {
        AzNodeIdVecDestructorEnumWrapper { inner: AzNodeIdVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeIdVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeIdVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeIdVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeIdVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeIdVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeIdVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::NodeIdVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzParentWithNodeDepthVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzParentWithNodeDepthVecDestructorEnumWrapper {
        AzParentWithNodeDepthVecDestructorEnumWrapper { inner: AzParentWithNodeDepthVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzParentWithNodeDepthVecDestructorEnumWrapper {
        AzParentWithNodeDepthVecDestructorEnumWrapper { inner: AzParentWithNodeDepthVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: ParentWithNodeDepthVecDestructorType) -> AzParentWithNodeDepthVecDestructorEnumWrapper {
        AzParentWithNodeDepthVecDestructorEnumWrapper { inner: AzParentWithNodeDepthVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzParentWithNodeDepthVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzParentWithNodeDepthVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzParentWithNodeDepthVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzParentWithNodeDepthVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzParentWithNodeDepthVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::ParentWithNodeDepthVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::ParentWithNodeDepthVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLintVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzGLintVecDestructorEnumWrapper {
        AzGLintVecDestructorEnumWrapper { inner: AzGLintVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzGLintVecDestructorEnumWrapper {
        AzGLintVecDestructorEnumWrapper { inner: AzGLintVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: GLintVecDestructorType) -> AzGLintVecDestructorEnumWrapper {
        AzGLintVecDestructorEnumWrapper { inner: AzGLintVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzGLintVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzGLintVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzGLintVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzGLintVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGLintVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLintVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::GLintVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
        AzNodeDataInlineCssPropertyVecDestructorEnumWrapper { inner: AzNodeDataInlineCssPropertyVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
        AzNodeDataInlineCssPropertyVecDestructorEnumWrapper { inner: AzNodeDataInlineCssPropertyVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: NodeDataInlineCssPropertyVecDestructorType) -> AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
        AzNodeDataInlineCssPropertyVecDestructorEnumWrapper { inner: AzNodeDataInlineCssPropertyVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNodeDataInlineCssPropertyVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeDataInlineCssPropertyVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNodeDataInlineCssPropertyVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNodeDataInlineCssPropertyVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataInlineCssPropertyVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::NodeDataInlineCssPropertyVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedRadialColorStopVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNormalizedRadialColorStopVecDestructorEnumWrapper {
        AzNormalizedRadialColorStopVecDestructorEnumWrapper { inner: AzNormalizedRadialColorStopVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzNormalizedRadialColorStopVecDestructorEnumWrapper {
        AzNormalizedRadialColorStopVecDestructorEnumWrapper { inner: AzNormalizedRadialColorStopVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: NormalizedRadialColorStopVecDestructorType) -> AzNormalizedRadialColorStopVecDestructorEnumWrapper {
        AzNormalizedRadialColorStopVecDestructorEnumWrapper { inner: AzNormalizedRadialColorStopVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzNormalizedRadialColorStopVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNormalizedRadialColorStopVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzNormalizedRadialColorStopVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzNormalizedRadialColorStopVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedRadialColorStopVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedRadialColorStopVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::NormalizedRadialColorStopVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledNodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyledNodeVecDestructorEnumWrapper {
        AzStyledNodeVecDestructorEnumWrapper { inner: AzStyledNodeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStyledNodeVecDestructorEnumWrapper {
        AzStyledNodeVecDestructorEnumWrapper { inner: AzStyledNodeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StyledNodeVecDestructorType) -> AzStyledNodeVecDestructorEnumWrapper {
        AzStyledNodeVecDestructorEnumWrapper { inner: AzStyledNodeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyledNodeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyledNodeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyledNodeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyledNodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyledNodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::StyledNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundPositionVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleBackgroundPositionVecDestructorEnumWrapper {
        AzStyleBackgroundPositionVecDestructorEnumWrapper { inner: AzStyleBackgroundPositionVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleBackgroundPositionVecDestructorEnumWrapper {
        AzStyleBackgroundPositionVecDestructorEnumWrapper { inner: AzStyleBackgroundPositionVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StyleBackgroundPositionVecDestructorType) -> AzStyleBackgroundPositionVecDestructorEnumWrapper {
        AzStyleBackgroundPositionVecDestructorEnumWrapper { inner: AzStyleBackgroundPositionVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundPositionVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundPositionVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleBackgroundPositionVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleBackgroundPositionVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundPositionVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundPositionVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundPositionVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgSimpleNodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgSimpleNodeVecDestructorEnumWrapper {
        AzSvgSimpleNodeVecDestructorEnumWrapper { inner: AzSvgSimpleNodeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgSimpleNodeVecDestructorEnumWrapper {
        AzSvgSimpleNodeVecDestructorEnumWrapper { inner: AzSvgSimpleNodeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: SvgSimpleNodeVecDestructorType) -> AzSvgSimpleNodeVecDestructorEnumWrapper {
        AzSvgSimpleNodeVecDestructorEnumWrapper { inner: AzSvgSimpleNodeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgSimpleNodeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgSimpleNodeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzSvgSimpleNodeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzSvgSimpleNodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgSimpleNodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgSimpleNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgSimpleNodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAttributeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzAttributeVecDestructorEnumWrapper {
        AzAttributeVecDestructorEnumWrapper { inner: AzAttributeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzAttributeVecDestructorEnumWrapper {
        AzAttributeVecDestructorEnumWrapper { inner: AzAttributeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: AttributeVecDestructorType) -> AzAttributeVecDestructorEnumWrapper {
        AzAttributeVecDestructorEnumWrapper { inner: AzAttributeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzAttributeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAttributeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzAttributeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzAttributeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAttributeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AttributeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::AttributeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssDeclarationVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCssDeclarationVecDestructorEnumWrapper {
        AzCssDeclarationVecDestructorEnumWrapper { inner: AzCssDeclarationVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzCssDeclarationVecDestructorEnumWrapper {
        AzCssDeclarationVecDestructorEnumWrapper { inner: AzCssDeclarationVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: CssDeclarationVecDestructorType) -> AzCssDeclarationVecDestructorEnumWrapper {
        AzCssDeclarationVecDestructorEnumWrapper { inner: AzCssDeclarationVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCssDeclarationVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssDeclarationVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCssDeclarationVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCssDeclarationVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssDeclarationVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssDeclarationVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::css::CssDeclarationVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIdOrClassVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzIdOrClassVecDestructorEnumWrapper {
        AzIdOrClassVecDestructorEnumWrapper { inner: AzIdOrClassVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzIdOrClassVecDestructorEnumWrapper {
        AzIdOrClassVecDestructorEnumWrapper { inner: AzIdOrClassVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: IdOrClassVecDestructorType) -> AzIdOrClassVecDestructorEnumWrapper {
        AzIdOrClassVecDestructorEnumWrapper { inner: AzIdOrClassVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzIdOrClassVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzIdOrClassVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzIdOrClassVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzIdOrClassVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIdOrClassVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::IdOrClassVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::IdOrClassVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundSizeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleBackgroundSizeVecDestructorEnumWrapper {
        AzStyleBackgroundSizeVecDestructorEnumWrapper { inner: AzStyleBackgroundSizeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleBackgroundSizeVecDestructorEnumWrapper {
        AzStyleBackgroundSizeVecDestructorEnumWrapper { inner: AzStyleBackgroundSizeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StyleBackgroundSizeVecDestructorType) -> AzStyleBackgroundSizeVecDestructorEnumWrapper {
        AzStyleBackgroundSizeVecDestructorEnumWrapper { inner: AzStyleBackgroundSizeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStyleBackgroundSizeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundSizeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSizeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSizeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundSizeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundSizeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::StyleBackgroundSizeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringPairVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStringPairVecDestructorEnumWrapper {
        AzStringPairVecDestructorEnumWrapper { inner: AzStringPairVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzStringPairVecDestructorEnumWrapper {
        AzStringPairVecDestructorEnumWrapper { inner: AzStringPairVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: StringPairVecDestructorType) -> AzStringPairVecDestructorEnumWrapper {
        AzStringPairVecDestructorEnumWrapper { inner: AzStringPairVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzStringPairVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStringPairVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzStringPairVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzStringPairVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStringPairVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::StringPairVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::StringPairVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCoreCallbackDataVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCoreCallbackDataVecDestructorEnumWrapper {
        AzCoreCallbackDataVecDestructorEnumWrapper { inner: AzCoreCallbackDataVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzCoreCallbackDataVecDestructorEnumWrapper {
        AzCoreCallbackDataVecDestructorEnumWrapper { inner: AzCoreCallbackDataVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: CoreCallbackDataVecDestructorType) -> AzCoreCallbackDataVecDestructorEnumWrapper {
        AzCoreCallbackDataVecDestructorEnumWrapper { inner: AzCoreCallbackDataVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzCoreCallbackDataVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCoreCallbackDataVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzCoreCallbackDataVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzCoreCallbackDataVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCoreCallbackDataVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::CoreCallbackDataVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::CoreCallbackDataVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathElementVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgPathElementVecDestructorEnumWrapper {
        AzSvgPathElementVecDestructorEnumWrapper { inner: AzSvgPathElementVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgPathElementVecDestructorEnumWrapper {
        AzSvgPathElementVecDestructorEnumWrapper { inner: AzSvgPathElementVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: SvgPathElementVecDestructorType) -> AzSvgPathElementVecDestructorEnumWrapper {
        AzSvgPathElementVecDestructorEnumWrapper { inner: AzSvgPathElementVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgPathElementVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgPathElementVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzSvgPathElementVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzSvgPathElementVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathElementVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathElementVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgPathElementVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU8VecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzU8VecDestructorEnumWrapper {
        AzU8VecDestructorEnumWrapper { inner: AzU8VecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzU8VecDestructorEnumWrapper {
        AzU8VecDestructorEnumWrapper { inner: AzU8VecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: U8VecDestructorType) -> AzU8VecDestructorEnumWrapper {
        AzU8VecDestructorEnumWrapper { inner: AzU8VecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzU8VecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzU8VecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzU8VecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzU8VecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzU8VecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U8VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::U8VecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGridTrackSizingVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzGridTrackSizingVecDestructorEnumWrapper {
        AzGridTrackSizingVecDestructorEnumWrapper { inner: AzGridTrackSizingVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzGridTrackSizingVecDestructorEnumWrapper {
        AzGridTrackSizingVecDestructorEnumWrapper { inner: AzGridTrackSizingVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: GridTrackSizingVecDestructorType) -> AzGridTrackSizingVecDestructorEnumWrapper {
        AzGridTrackSizingVecDestructorEnumWrapper { inner: AzGridTrackSizingVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzGridTrackSizingVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzGridTrackSizingVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzGridTrackSizingVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzGridTrackSizingVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGridTrackSizingVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridTrackSizingVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::grid::GridTrackSizingVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexAttributeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzVertexAttributeVecDestructorEnumWrapper {
        AzVertexAttributeVecDestructorEnumWrapper { inner: AzVertexAttributeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzVertexAttributeVecDestructorEnumWrapper {
        AzVertexAttributeVecDestructorEnumWrapper { inner: AzVertexAttributeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: VertexAttributeVecDestructorType) -> AzVertexAttributeVecDestructorEnumWrapper {
        AzVertexAttributeVecDestructorEnumWrapper { inner: AzVertexAttributeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzVertexAttributeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzVertexAttributeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzVertexAttributeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzVertexAttributeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVertexAttributeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexAttributeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexAttributeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexAttributeVec {
}

#[pyproto]
impl PyObjectProtocol for AzVertexAttributeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexAttributeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::VertexAttributeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDebugMessageVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzDebugMessageVecDestructorEnumWrapper {
        AzDebugMessageVecDestructorEnumWrapper { inner: AzDebugMessageVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzDebugMessageVecDestructorEnumWrapper {
        AzDebugMessageVecDestructorEnumWrapper { inner: AzDebugMessageVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: DebugMessageVecDestructorType) -> AzDebugMessageVecDestructorEnumWrapper {
        AzDebugMessageVecDestructorEnumWrapper { inner: AzDebugMessageVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzDebugMessageVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzDebugMessageVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzDebugMessageVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzDebugMessageVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDebugMessageVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::DebugMessageVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::DebugMessageVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDebugMessageVec {
}

#[pyproto]
impl PyObjectProtocol for AzDebugMessageVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::DebugMessageVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::DebugMessageVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapePointVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzShapePointVecDestructorEnumWrapper {
        AzShapePointVecDestructorEnumWrapper { inner: AzShapePointVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzShapePointVecDestructorEnumWrapper {
        AzShapePointVecDestructorEnumWrapper { inner: AzShapePointVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: ShapePointVecDestructorType) -> AzShapePointVecDestructorEnumWrapper {
        AzShapePointVecDestructorEnumWrapper { inner: AzShapePointVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzShapePointVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzShapePointVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzShapePointVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzShapePointVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzShapePointVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::ShapePointVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::ShapePointVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapePointVec {
}

#[pyproto]
impl PyObjectProtocol for AzShapePointVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::ShapePointVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::shape::ShapePointVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMonitorVec {
}

#[pyproto]
impl PyObjectProtocol for AzMonitorVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MonitorVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MonitorVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVideoModeVec {
}

#[pyproto]
impl PyObjectProtocol for AzVideoModeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoModeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoModeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXWindowTypeVec {
}

#[pyproto]
impl PyObjectProtocol for AzXWindowTypeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowTypeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowTypeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXWindowTypeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzXWindowTypeVecDestructorEnumWrapper {
        AzXWindowTypeVecDestructorEnumWrapper { inner: AzXWindowTypeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzXWindowTypeVecDestructorEnumWrapper {
        AzXWindowTypeVecDestructorEnumWrapper { inner: AzXWindowTypeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: XWindowTypeVecDestructorType) -> AzXWindowTypeVecDestructorEnumWrapper {
        AzXWindowTypeVecDestructorEnumWrapper { inner: AzXWindowTypeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzXWindowTypeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXWindowTypeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzXWindowTypeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzXWindowTypeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXWindowTypeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowTypeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::XWindowTypeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMonitorVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzMonitorVecDestructorEnumWrapper {
        AzMonitorVecDestructorEnumWrapper { inner: AzMonitorVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzMonitorVecDestructorEnumWrapper {
        AzMonitorVecDestructorEnumWrapper { inner: AzMonitorVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: MonitorVecDestructorType) -> AzMonitorVecDestructorEnumWrapper {
        AzMonitorVecDestructorEnumWrapper { inner: AzMonitorVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzMonitorVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzMonitorVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzMonitorVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzMonitorVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMonitorVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MonitorVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::MonitorVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVideoModeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzVideoModeVecDestructorEnumWrapper {
        AzVideoModeVecDestructorEnumWrapper { inner: AzVideoModeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzVideoModeVecDestructorEnumWrapper {
        AzVideoModeVecDestructorEnumWrapper { inner: AzVideoModeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: VideoModeVecDestructorType) -> AzVideoModeVecDestructorEnumWrapper {
        AzVideoModeVecDestructorEnumWrapper { inner: AzVideoModeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzVideoModeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzVideoModeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzVideoModeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzVideoModeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVideoModeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoModeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VideoModeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScanCodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzScanCodeVecDestructorEnumWrapper {
        AzScanCodeVecDestructorEnumWrapper { inner: AzScanCodeVecDestructor::DefaultRust }
    }
    #[classattr]
    fn NoDestructor() -> AzScanCodeVecDestructorEnumWrapper {
        AzScanCodeVecDestructorEnumWrapper { inner: AzScanCodeVecDestructor::NoDestructor }
    }
    #[staticmethod]
    fn External(v: ScanCodeVecDestructorType) -> AzScanCodeVecDestructorEnumWrapper {
        AzScanCodeVecDestructorEnumWrapper { inner: AzScanCodeVecDestructor::External(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzScanCodeVecDestructor;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzScanCodeVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzScanCodeVecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzScanCodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzScanCodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ScanCodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ScanCodeVecDestructor = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScanCodeVec {
}

#[pyproto]
impl PyObjectProtocol for AzScanCodeVec {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ScanCodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::ScanCodeVec = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionSvgPointEnumWrapper {
    #[classattr]
    fn None() -> AzOptionSvgPointEnumWrapper {
        AzOptionSvgPointEnumWrapper { inner: AzOptionSvgPoint::None }
    }
    #[staticmethod]
    fn Some(v: SvgPoint) -> AzOptionSvgPointEnumWrapper {
        AzOptionSvgPointEnumWrapper { inner: AzOptionSvgPoint::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionSvgPoint;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionSvgPoint::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionSvgPoint::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionSvgPointEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::OptionSvgPoint = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::OptionSvgPoint = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionListViewOnRowClickEnumWrapper {
    #[classattr]
    fn None() -> AzOptionListViewOnRowClickEnumWrapper {
        AzOptionListViewOnRowClickEnumWrapper { inner: AzOptionListViewOnRowClick::None }
    }
    #[staticmethod]
    fn Some(v: ListViewOnRowClick) -> AzOptionListViewOnRowClickEnumWrapper {
        AzOptionListViewOnRowClickEnumWrapper { inner: AzOptionListViewOnRowClick::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionListViewOnRowClick;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionListViewOnRowClick::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionListViewOnRowClick::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionListViewOnRowClickEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::OptionListViewOnRowClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::OptionListViewOnRowClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionListViewOnColumnClickEnumWrapper {
    #[classattr]
    fn None() -> AzOptionListViewOnColumnClickEnumWrapper {
        AzOptionListViewOnColumnClickEnumWrapper { inner: AzOptionListViewOnColumnClick::None }
    }
    #[staticmethod]
    fn Some(v: ListViewOnColumnClick) -> AzOptionListViewOnColumnClickEnumWrapper {
        AzOptionListViewOnColumnClickEnumWrapper { inner: AzOptionListViewOnColumnClick::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionListViewOnColumnClick;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionListViewOnColumnClick::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionListViewOnColumnClick::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionListViewOnColumnClickEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::OptionListViewOnColumnClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::OptionListViewOnColumnClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionListViewOnLazyLoadScrollEnumWrapper {
    #[classattr]
    fn None() -> AzOptionListViewOnLazyLoadScrollEnumWrapper {
        AzOptionListViewOnLazyLoadScrollEnumWrapper { inner: AzOptionListViewOnLazyLoadScroll::None }
    }
    #[staticmethod]
    fn Some(v: ListViewOnLazyLoadScroll) -> AzOptionListViewOnLazyLoadScrollEnumWrapper {
        AzOptionListViewOnLazyLoadScrollEnumWrapper { inner: AzOptionListViewOnLazyLoadScroll::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionListViewOnLazyLoadScroll;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionListViewOnLazyLoadScroll::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionListViewOnLazyLoadScroll::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionListViewOnLazyLoadScrollEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::OptionListViewOnLazyLoadScroll = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::list_view::OptionListViewOnLazyLoadScroll = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMenuEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMenuEnumWrapper {
        AzOptionMenuEnumWrapper { inner: AzOptionMenu::None }
    }
    #[staticmethod]
    fn Some(v: Menu) -> AzOptionMenuEnumWrapper {
        AzOptionMenuEnumWrapper { inner: AzOptionMenu::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionMenu;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMenu::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMenu::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMenuEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::OptionMenu = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::OptionMenu = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionPixelValueNoPercentEnumWrapper {
    #[classattr]
    fn None() -> AzOptionPixelValueNoPercentEnumWrapper {
        AzOptionPixelValueNoPercentEnumWrapper { inner: AzOptionPixelValueNoPercent::None }
    }
    #[staticmethod]
    fn Some(v: PixelValueNoPercent) -> AzOptionPixelValueNoPercentEnumWrapper {
        AzOptionPixelValueNoPercentEnumWrapper { inner: AzOptionPixelValueNoPercent::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionPixelValueNoPercent;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionPixelValueNoPercent::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionPixelValueNoPercent::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionPixelValueNoPercentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::pixel::OptionPixelValueNoPercent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::pixel::OptionPixelValueNoPercent = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionColorInputOnValueChangeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionColorInputOnValueChangeEnumWrapper {
        AzOptionColorInputOnValueChangeEnumWrapper { inner: AzOptionColorInputOnValueChange::None }
    }
    #[staticmethod]
    fn Some(v: ColorInputOnValueChange) -> AzOptionColorInputOnValueChangeEnumWrapper {
        AzOptionColorInputOnValueChangeEnumWrapper { inner: AzOptionColorInputOnValueChange::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionColorInputOnValueChange;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionColorInputOnValueChange::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionColorInputOnValueChange::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionColorInputOnValueChangeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::color_input::OptionColorInputOnValueChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::color_input::OptionColorInputOnValueChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionButtonOnClickEnumWrapper {
    #[classattr]
    fn None() -> AzOptionButtonOnClickEnumWrapper {
        AzOptionButtonOnClickEnumWrapper { inner: AzOptionButtonOnClick::None }
    }
    #[staticmethod]
    fn Some(v: ButtonOnClick) -> AzOptionButtonOnClickEnumWrapper {
        AzOptionButtonOnClickEnumWrapper { inner: AzOptionButtonOnClick::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionButtonOnClick;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionButtonOnClick::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionButtonOnClick::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionButtonOnClickEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::button::OptionButtonOnClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::button::OptionButtonOnClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTabOnClickEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTabOnClickEnumWrapper {
        AzOptionTabOnClickEnumWrapper { inner: AzOptionTabOnClick::None }
    }
    #[staticmethod]
    fn Some(v: TabOnClick) -> AzOptionTabOnClickEnumWrapper {
        AzOptionTabOnClickEnumWrapper { inner: AzOptionTabOnClick::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTabOnClick;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTabOnClick::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTabOnClick::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTabOnClickEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::tabs::OptionTabOnClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::tabs::OptionTabOnClick = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionFileInputOnPathChangeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionFileInputOnPathChangeEnumWrapper {
        AzOptionFileInputOnPathChangeEnumWrapper { inner: AzOptionFileInputOnPathChange::None }
    }
    #[staticmethod]
    fn Some(v: FileInputOnPathChange) -> AzOptionFileInputOnPathChangeEnumWrapper {
        AzOptionFileInputOnPathChangeEnumWrapper { inner: AzOptionFileInputOnPathChange::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionFileInputOnPathChange;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionFileInputOnPathChange::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionFileInputOnPathChange::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionFileInputOnPathChangeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::file_input::OptionFileInputOnPathChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::file_input::OptionFileInputOnPathChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionCheckBoxOnToggleEnumWrapper {
    #[classattr]
    fn None() -> AzOptionCheckBoxOnToggleEnumWrapper {
        AzOptionCheckBoxOnToggleEnumWrapper { inner: AzOptionCheckBoxOnToggle::None }
    }
    #[staticmethod]
    fn Some(v: CheckBoxOnToggle) -> AzOptionCheckBoxOnToggleEnumWrapper {
        AzOptionCheckBoxOnToggleEnumWrapper { inner: AzOptionCheckBoxOnToggle::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionCheckBoxOnToggle;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionCheckBoxOnToggle::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionCheckBoxOnToggle::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionCheckBoxOnToggleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::check_box::OptionCheckBoxOnToggle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::check_box::OptionCheckBoxOnToggle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextInputOnTextInputEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextInputOnTextInputEnumWrapper {
        AzOptionTextInputOnTextInputEnumWrapper { inner: AzOptionTextInputOnTextInput::None }
    }
    #[staticmethod]
    fn Some(v: TextInputOnTextInput) -> AzOptionTextInputOnTextInputEnumWrapper {
        AzOptionTextInputOnTextInputEnumWrapper { inner: AzOptionTextInputOnTextInput::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTextInputOnTextInput;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTextInputOnTextInput::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTextInputOnTextInput::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextInputOnTextInputEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::OptionTextInputOnTextInput = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::OptionTextInputOnTextInput = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextInputOnVirtualKeyDownEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextInputOnVirtualKeyDownEnumWrapper {
        AzOptionTextInputOnVirtualKeyDownEnumWrapper { inner: AzOptionTextInputOnVirtualKeyDown::None }
    }
    #[staticmethod]
    fn Some(v: TextInputOnVirtualKeyDown) -> AzOptionTextInputOnVirtualKeyDownEnumWrapper {
        AzOptionTextInputOnVirtualKeyDownEnumWrapper { inner: AzOptionTextInputOnVirtualKeyDown::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTextInputOnVirtualKeyDown;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTextInputOnVirtualKeyDown::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTextInputOnVirtualKeyDown::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextInputOnVirtualKeyDownEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::OptionTextInputOnVirtualKeyDown = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::OptionTextInputOnVirtualKeyDown = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextInputOnFocusLostEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextInputOnFocusLostEnumWrapper {
        AzOptionTextInputOnFocusLostEnumWrapper { inner: AzOptionTextInputOnFocusLost::None }
    }
    #[staticmethod]
    fn Some(v: TextInputOnFocusLost) -> AzOptionTextInputOnFocusLostEnumWrapper {
        AzOptionTextInputOnFocusLostEnumWrapper { inner: AzOptionTextInputOnFocusLost::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTextInputOnFocusLost;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTextInputOnFocusLost::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTextInputOnFocusLost::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextInputOnFocusLostEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::OptionTextInputOnFocusLost = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::OptionTextInputOnFocusLost = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextInputSelectionEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextInputSelectionEnumWrapper {
        AzOptionTextInputSelectionEnumWrapper { inner: AzOptionTextInputSelection::None }
    }
    #[staticmethod]
    fn Some(v: TextInputSelection) -> AzOptionTextInputSelectionEnumWrapper {
        AzOptionTextInputSelectionEnumWrapper { inner: AzOptionTextInputSelection::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTextInputSelection;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTextInputSelection::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTextInputSelection::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextInputSelectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::OptionTextInputSelection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::text_input::OptionTextInputSelection = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNumberInputOnFocusLostEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNumberInputOnFocusLostEnumWrapper {
        AzOptionNumberInputOnFocusLostEnumWrapper { inner: AzOptionNumberInputOnFocusLost::None }
    }
    #[staticmethod]
    fn Some(v: NumberInputOnFocusLost) -> AzOptionNumberInputOnFocusLostEnumWrapper {
        AzOptionNumberInputOnFocusLostEnumWrapper { inner: AzOptionNumberInputOnFocusLost::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionNumberInputOnFocusLost;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNumberInputOnFocusLost::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNumberInputOnFocusLost::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNumberInputOnFocusLostEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::OptionNumberInputOnFocusLost = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::OptionNumberInputOnFocusLost = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNumberInputOnValueChangeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNumberInputOnValueChangeEnumWrapper {
        AzOptionNumberInputOnValueChangeEnumWrapper { inner: AzOptionNumberInputOnValueChange::None }
    }
    #[staticmethod]
    fn Some(v: NumberInputOnValueChange) -> AzOptionNumberInputOnValueChangeEnumWrapper {
        AzOptionNumberInputOnValueChangeEnumWrapper { inner: AzOptionNumberInputOnValueChange::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionNumberInputOnValueChange;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNumberInputOnValueChange::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNumberInputOnValueChange::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNumberInputOnValueChangeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::OptionNumberInputOnValueChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::widgets::number_input::OptionNumberInputOnValueChange = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMenuItemIconEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMenuItemIconEnumWrapper {
        AzOptionMenuItemIconEnumWrapper { inner: AzOptionMenuItemIcon::None }
    }
    #[staticmethod]
    fn Some(v: MenuItemIcon) -> AzOptionMenuItemIconEnumWrapper {
        AzOptionMenuItemIconEnumWrapper { inner: AzOptionMenuItemIcon::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionMenuItemIcon;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMenuItemIcon::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMenuItemIcon::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMenuItemIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::OptionMenuItemIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::OptionMenuItemIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionVirtualKeyCodeComboEnumWrapper {
    #[classattr]
    fn None() -> AzOptionVirtualKeyCodeComboEnumWrapper {
        AzOptionVirtualKeyCodeComboEnumWrapper { inner: AzOptionVirtualKeyCodeCombo::None }
    }
    #[staticmethod]
    fn Some(v: VirtualKeyCodeCombo) -> AzOptionVirtualKeyCodeComboEnumWrapper {
        AzOptionVirtualKeyCodeComboEnumWrapper { inner: AzOptionVirtualKeyCodeCombo::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionVirtualKeyCodeCombo;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionVirtualKeyCodeCombo::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionVirtualKeyCodeCombo::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionVirtualKeyCodeComboEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionVirtualKeyCodeCombo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionVirtualKeyCodeCombo = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTimerIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTimerIdEnumWrapper {
        AzOptionTimerIdEnumWrapper { inner: AzOptionTimerId::None }
    }
    #[staticmethod]
    fn Some(v: TimerId) -> AzOptionTimerIdEnumWrapper {
        AzOptionTimerIdEnumWrapper { inner: AzOptionTimerId::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTimerId;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTimerId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTimerId::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTimerIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::OptionTimerId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::OptionTimerId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionI16EnumWrapper {
    #[classattr]
    fn None() -> AzOptionI16EnumWrapper {
        AzOptionI16EnumWrapper { inner: AzOptionI16::None }
    }
    #[staticmethod]
    fn Some(v: i16) -> AzOptionI16EnumWrapper {
        AzOptionI16EnumWrapper { inner: AzOptionI16::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionI16;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionI16::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionI16::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionI16EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionI16 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionI16 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionU16EnumWrapper {
    #[classattr]
    fn None() -> AzOptionU16EnumWrapper {
        AzOptionU16EnumWrapper { inner: AzOptionU16::None }
    }
    #[staticmethod]
    fn Some(v: u16) -> AzOptionU16EnumWrapper {
        AzOptionU16EnumWrapper { inner: AzOptionU16::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionU16;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionU16::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionU16::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionU16EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionU16 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionU16 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionU32EnumWrapper {
    #[classattr]
    fn None() -> AzOptionU32EnumWrapper {
        AzOptionU32EnumWrapper { inner: AzOptionU32::None }
    }
    #[staticmethod]
    fn Some(v: u32) -> AzOptionU32EnumWrapper {
        AzOptionU32EnumWrapper { inner: AzOptionU32::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionU32;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionU32::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionU32::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionU32EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionU32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionU32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionImageRefEnumWrapper {
    #[classattr]
    fn None() -> AzOptionImageRefEnumWrapper {
        AzOptionImageRefEnumWrapper { inner: AzOptionImageRef::None }
    }
    #[staticmethod]
    fn Some(v: ImageRef) -> AzOptionImageRefEnumWrapper {
        AzOptionImageRefEnumWrapper { inner: AzOptionImageRef::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionImageRef;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionImageRef::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionImageRef::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionImageRefEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::OptionImageRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::OptionImageRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionFontRefEnumWrapper {
    #[classattr]
    fn None() -> AzOptionFontRefEnumWrapper {
        AzOptionFontRefEnumWrapper { inner: AzOptionFontRef::None }
    }
    #[staticmethod]
    fn Some(v: FontRef) -> AzOptionFontRefEnumWrapper {
        AzOptionFontRefEnumWrapper { inner: AzOptionFontRef::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionFontRef;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionFontRef::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionFontRef::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionFontRefEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::OptionFontRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::font::OptionFontRef = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionRefAnyEnumWrapper {
    #[classattr]
    fn None() -> AzOptionRefAnyEnumWrapper {
        AzOptionRefAnyEnumWrapper { inner: AzOptionRefAny::None }
    }
    #[staticmethod]
    fn Some(v: RefAny) -> AzOptionRefAnyEnumWrapper {
        AzOptionRefAnyEnumWrapper { inner: AzOptionRefAny::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionRefAny;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionRefAny::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionRefAny::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionRefAnyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::refany::OptionRefAny = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::refany::OptionRefAny = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLayoutSizeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLayoutSizeEnumWrapper {
        AzOptionLayoutSizeEnumWrapper { inner: AzOptionLayoutSize::None }
    }
    #[staticmethod]
    fn Some(v: LayoutSize) -> AzOptionLayoutSizeEnumWrapper {
        AzOptionLayoutSizeEnumWrapper { inner: AzOptionLayoutSize::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionLayoutSize;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLayoutSize::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLayoutSize::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLayoutSizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::OptionLayoutSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::geometry::OptionLayoutSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionDomNodeIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionDomNodeIdEnumWrapper {
        AzOptionDomNodeIdEnumWrapper { inner: AzOptionDomNodeId::None }
    }
    #[staticmethod]
    fn Some(v: DomNodeId) -> AzOptionDomNodeIdEnumWrapper {
        AzOptionDomNodeIdEnumWrapper { inner: AzOptionDomNodeId::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionDomNodeId;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionDomNodeId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionDomNodeId::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionDomNodeIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::OptionDomNodeId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::OptionDomNodeId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionColorUEnumWrapper {
    #[classattr]
    fn None() -> AzOptionColorUEnumWrapper {
        AzOptionColorUEnumWrapper { inner: AzOptionColorU::None }
    }
    #[staticmethod]
    fn Some(v: ColorU) -> AzOptionColorUEnumWrapper {
        AzOptionColorUEnumWrapper { inner: AzOptionColorU::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionColorU;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionColorU::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionColorU::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionColorUEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::color::OptionColorU = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::color::OptionColorU = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionRawImageEnumWrapper {
    #[classattr]
    fn None() -> AzOptionRawImageEnumWrapper {
        AzOptionRawImageEnumWrapper { inner: AzOptionRawImage::None }
    }
    #[staticmethod]
    fn Some(v: RawImage) -> AzOptionRawImageEnumWrapper {
        AzOptionRawImageEnumWrapper { inner: AzOptionRawImage::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionRawImage;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionRawImage::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionRawImage::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionRawImageEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::OptionRawImage = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::OptionRawImage = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionSvgDashPatternEnumWrapper {
    #[classattr]
    fn None() -> AzOptionSvgDashPatternEnumWrapper {
        AzOptionSvgDashPatternEnumWrapper { inner: AzOptionSvgDashPattern::None }
    }
    #[staticmethod]
    fn Some(v: SvgDashPattern) -> AzOptionSvgDashPatternEnumWrapper {
        AzOptionSvgDashPatternEnumWrapper { inner: AzOptionSvgDashPattern::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionSvgDashPattern;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionSvgDashPattern::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionSvgDashPattern::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionSvgDashPatternEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::OptionSvgDashPattern = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::OptionSvgDashPattern = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTabIndexEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTabIndexEnumWrapper {
        AzOptionTabIndexEnumWrapper { inner: AzOptionTabIndex::None }
    }
    #[staticmethod]
    fn Some(v: TabIndex) -> AzOptionTabIndexEnumWrapper {
        AzOptionTabIndexEnumWrapper { inner: AzOptionTabIndex::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTabIndex;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTabIndex::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTabIndex::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTabIndexEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::OptionTabIndex = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::OptionTabIndex = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTagIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTagIdEnumWrapper {
        AzOptionTagIdEnumWrapper { inner: AzOptionTagId::None }
    }
    #[staticmethod]
    fn Some(v: TagId) -> AzOptionTagIdEnumWrapper {
        AzOptionTagIdEnumWrapper { inner: AzOptionTagId::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTagId;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTagId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTagId::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTagIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::OptionTagId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::OptionTagId = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionDurationEnumWrapper {
    #[classattr]
    fn None() -> AzOptionDurationEnumWrapper {
        AzOptionDurationEnumWrapper { inner: AzOptionDuration::None }
    }
    #[staticmethod]
    fn Some(v: Duration) -> AzOptionDurationEnumWrapper {
        AzOptionDurationEnumWrapper { inner: AzOptionDuration::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionDuration;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionDuration::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionDuration::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionDurationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::OptionDuration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::task::OptionDuration = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionUsizeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionUsizeEnumWrapper {
        AzOptionUsizeEnumWrapper { inner: AzOptionUsize::None }
    }
    #[staticmethod]
    fn Some(v: usize) -> AzOptionUsizeEnumWrapper {
        AzOptionUsizeEnumWrapper { inner: AzOptionUsize::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionUsize;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionUsize::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionUsize::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionUsizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::OptionUsize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::OptionUsize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionCoreMenuCallbackEnumWrapper {
    #[classattr]
    fn None() -> AzOptionCoreMenuCallbackEnumWrapper {
        AzOptionCoreMenuCallbackEnumWrapper { inner: AzOptionCoreMenuCallback::None }
    }
    #[staticmethod]
    fn Some(v: CoreMenuCallback) -> AzOptionCoreMenuCallbackEnumWrapper {
        AzOptionCoreMenuCallbackEnumWrapper { inner: AzOptionCoreMenuCallback::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionCoreMenuCallback;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionCoreMenuCallback::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionCoreMenuCallback::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionCoreMenuCallbackEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::OptionCoreMenuCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::menu::OptionCoreMenuCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionStyledDomEnumWrapper {
    #[classattr]
    fn None() -> AzOptionStyledDomEnumWrapper {
        AzOptionStyledDomEnumWrapper { inner: AzOptionStyledDom::None }
    }
    #[staticmethod]
    fn Some(v: StyledDom) -> AzOptionStyledDomEnumWrapper {
        AzOptionStyledDomEnumWrapper { inner: AzOptionStyledDom::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionStyledDom;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionStyledDom::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionStyledDom::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionStyledDomEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::OptionStyledDom = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::styled_dom::OptionStyledDom = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgParseOptions {
}

#[pyproto]
impl PyObjectProtocol for AzSvgParseOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgParseOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgParseOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgXmlOptions {
}

#[pyproto]
impl PyObjectProtocol for AzSvgXmlOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgXmlOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgXmlOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgRenderOptions {
}

#[pyproto]
impl PyObjectProtocol for AzSvgRenderOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgRenderOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgRenderOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLogicalPositionEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLogicalPositionEnumWrapper {
        AzOptionLogicalPositionEnumWrapper { inner: AzOptionLogicalPosition::None }
    }
    #[staticmethod]
    fn Some(v: LogicalPosition) -> AzOptionLogicalPositionEnumWrapper {
        AzOptionLogicalPositionEnumWrapper { inner: AzOptionLogicalPosition::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionLogicalPosition;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLogicalPosition::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLogicalPosition::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLogicalPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::OptionLogicalPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::OptionLogicalPosition = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionStringEnumWrapper {
    #[classattr]
    fn None() -> AzOptionStringEnumWrapper {
        AzOptionStringEnumWrapper { inner: AzOptionString::None }
    }
    #[staticmethod]
    fn Some(v: String) -> AzOptionStringEnumWrapper {
        AzOptionStringEnumWrapper { inner: AzOptionString::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionString;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionString::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionString::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionStringEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionString = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionString = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionF32EnumWrapper {
    #[classattr]
    fn None() -> AzOptionF32EnumWrapper {
        AzOptionF32EnumWrapper { inner: AzOptionF32::None }
    }
    #[staticmethod]
    fn Some(v: f32) -> AzOptionF32EnumWrapper {
        AzOptionF32EnumWrapper { inner: AzOptionF32::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionF32;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionF32::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionF32::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionF32EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionF32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionF32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionWaylandThemeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionWaylandThemeEnumWrapper {
        AzOptionWaylandThemeEnumWrapper { inner: AzOptionWaylandTheme::None }
    }
    #[staticmethod]
    fn Some(v: WaylandTheme) -> AzOptionWaylandThemeEnumWrapper {
        AzOptionWaylandThemeEnumWrapper { inner: AzOptionWaylandTheme::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionWaylandTheme;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionWaylandTheme::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionWaylandTheme::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionWaylandThemeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWaylandTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWaylandTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMouseCursorTypeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMouseCursorTypeEnumWrapper {
        AzOptionMouseCursorTypeEnumWrapper { inner: AzOptionMouseCursorType::None }
    }
    #[staticmethod]
    fn Some(v: MouseCursorType) -> AzOptionMouseCursorTypeEnumWrapper {
        AzOptionMouseCursorTypeEnumWrapper { inner: AzOptionMouseCursorType::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionMouseCursorType;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMouseCursorType::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMouseCursorType::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMouseCursorTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionMouseCursorType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionMouseCursorType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionWindowIconEnumWrapper {
    #[classattr]
    fn None() -> AzOptionWindowIconEnumWrapper {
        AzOptionWindowIconEnumWrapper { inner: AzOptionWindowIcon::None }
    }
    #[staticmethod]
    fn Some(v: WindowIcon) -> AzOptionWindowIconEnumWrapper {
        AzOptionWindowIconEnumWrapper { inner: AzOptionWindowIcon::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionWindowIcon;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionWindowIcon::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionWindowIcon::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionWindowIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWindowIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWindowIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionCallbackEnumWrapper {
    #[classattr]
    fn None() -> AzOptionCallbackEnumWrapper {
        AzOptionCallbackEnumWrapper { inner: AzOptionCallback::None }
    }
    #[staticmethod]
    fn Some(v: Callback) -> AzOptionCallbackEnumWrapper {
        AzOptionCallbackEnumWrapper { inner: AzOptionCallback::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionCallback;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionCallback::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionCallback::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionCallbackEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::OptionCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::callbacks::OptionCallback = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTaskBarIconEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTaskBarIconEnumWrapper {
        AzOptionTaskBarIconEnumWrapper { inner: AzOptionTaskBarIcon::None }
    }
    #[staticmethod]
    fn Some(v: TaskBarIcon) -> AzOptionTaskBarIconEnumWrapper {
        AzOptionTaskBarIconEnumWrapper { inner: AzOptionTaskBarIcon::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionTaskBarIcon;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTaskBarIcon::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTaskBarIcon::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTaskBarIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionTaskBarIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionTaskBarIcon = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionHwndHandleEnumWrapper {
    #[classattr]
    fn None() -> AzOptionHwndHandleEnumWrapper {
        AzOptionHwndHandleEnumWrapper { inner: AzOptionHwndHandle::None }
    }
    #[staticmethod]
    fn Some(v: HwndHandle) -> AzOptionHwndHandleEnumWrapper {
        AzOptionHwndHandleEnumWrapper { inner: AzOptionHwndHandle::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionHwndHandle;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionHwndHandle::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionHwndHandle::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionHwndHandleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionHwndHandle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionHwndHandle = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLinuxDecorationsStateEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLinuxDecorationsStateEnumWrapper {
        AzOptionLinuxDecorationsStateEnumWrapper { inner: AzOptionLinuxDecorationsState::None }
    }
    #[staticmethod]
    fn Some(v: LinuxDecorationsState) -> AzOptionLinuxDecorationsStateEnumWrapper {
        AzOptionLinuxDecorationsStateEnumWrapper { inner: AzOptionLinuxDecorationsState::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionLinuxDecorationsState;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLinuxDecorationsState::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLinuxDecorationsState::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLinuxDecorationsStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionLinuxDecorationsState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionLinuxDecorationsState = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionI32EnumWrapper {
    #[classattr]
    fn None() -> AzOptionI32EnumWrapper {
        AzOptionI32EnumWrapper { inner: AzOptionI32::None }
    }
    #[staticmethod]
    fn Some(v: i32) -> AzOptionI32EnumWrapper {
        AzOptionI32EnumWrapper { inner: AzOptionI32::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionI32;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionI32::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionI32::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionI32EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionI32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::corety::OptionI32 = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLogicalSizeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLogicalSizeEnumWrapper {
        AzOptionLogicalSizeEnumWrapper { inner: AzOptionLogicalSize::None }
    }
    #[staticmethod]
    fn Some(v: LogicalSize) -> AzOptionLogicalSizeEnumWrapper {
        AzOptionLogicalSizeEnumWrapper { inner: AzOptionLogicalSize::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionLogicalSize;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLogicalSize::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLogicalSize::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLogicalSizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::OptionLogicalSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::geom::OptionLogicalSize = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionVirtualKeyCodeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionVirtualKeyCodeEnumWrapper {
        AzOptionVirtualKeyCodeEnumWrapper { inner: AzOptionVirtualKeyCode::None }
    }
    #[staticmethod]
    fn Some(v: VirtualKeyCode) -> AzOptionVirtualKeyCodeEnumWrapper {
        AzOptionVirtualKeyCodeEnumWrapper { inner: AzOptionVirtualKeyCode::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionVirtualKeyCode;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionVirtualKeyCode::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionVirtualKeyCode::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionVirtualKeyCodeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionVirtualKeyCode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionVirtualKeyCode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionX11VisualEnumWrapper {
    #[classattr]
    fn None() -> AzOptionX11VisualEnumWrapper {
        AzOptionX11VisualEnumWrapper { inner: AzOptionX11Visual::None }
    }
    #[staticmethod]
    fn Some(v: X11Visual) -> AzOptionX11VisualEnumWrapper {
        AzOptionX11VisualEnumWrapper { inner: AzOptionX11Visual::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionX11Visual;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionX11Visual::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionX11Visual::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionX11VisualEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionX11Visual = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionX11Visual = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRendererOptions {
}

#[pyproto]
impl PyObjectProtocol for AzRendererOptions {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::RendererOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::RendererOptions = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionRendererOptionsEnumWrapper {
    #[classattr]
    fn None() -> AzOptionRendererOptionsEnumWrapper {
        AzOptionRendererOptionsEnumWrapper { inner: AzOptionRendererOptions::None }
    }
    #[staticmethod]
    fn Some(v: RendererOptions) -> AzOptionRendererOptionsEnumWrapper {
        AzOptionRendererOptionsEnumWrapper { inner: AzOptionRendererOptions::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionRendererOptions;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionRendererOptions::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionRendererOptions::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionRendererOptionsEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionRendererOptions = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionRendererOptions = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionWindowThemeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionWindowThemeEnumWrapper {
        AzOptionWindowThemeEnumWrapper { inner: AzOptionWindowTheme::None }
    }
    #[staticmethod]
    fn Some(v: WindowTheme) -> AzOptionWindowThemeEnumWrapper {
        AzOptionWindowThemeEnumWrapper { inner: AzOptionWindowTheme::Some(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzOptionWindowTheme;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionWindowTheme::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionWindowTheme::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionWindowThemeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWindowTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::OptionWindowTheme = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultXmlXmlErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: Xml) -> AzResultXmlXmlErrorEnumWrapper {
        AzResultXmlXmlErrorEnumWrapper { inner: AzResultXmlXmlError::Ok(v) }}
    }
    #[staticmethod]
    fn Err(v: XmlError) -> AzResultXmlXmlErrorEnumWrapper {
        AzResultXmlXmlErrorEnumWrapper { inner: AzResultXmlXmlError::Err(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzResultXmlXmlError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultXmlXmlError::Ok(v) => Ok(vec!["Ok".into_py(py), v.into_py(py)]),
            AzResultXmlXmlError::Err(v) => Ok(vec!["Err".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultXmlXmlErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::ResultXmlXmlError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::ResultXmlXmlError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultSvgSvgParseErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: Svg) -> AzResultSvgSvgParseErrorEnumWrapper {
        AzResultSvgSvgParseErrorEnumWrapper { inner: AzResultSvgSvgParseError::Ok(v) }}
    }
    #[staticmethod]
    fn Err(v: SvgParseError) -> AzResultSvgSvgParseErrorEnumWrapper {
        AzResultSvgSvgParseErrorEnumWrapper { inner: AzResultSvgSvgParseError::Err(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzResultSvgSvgParseError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultSvgSvgParseError::Ok(v) => Ok(vec!["Ok".into_py(py), v.into_py(py)]),
            AzResultSvgSvgParseError::Err(v) => Ok(vec!["Err".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultSvgSvgParseErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::ResultSvgSvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::ResultSvgSvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgParseErrorEnumWrapper {
    #[classattr]
    fn NoParserAvailable() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::NoParserAvailable }
    }
    #[classattr]
    fn ElementsLimitReached() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::ElementsLimitReached }
    }
    #[classattr]
    fn NotAnUtf8Str() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::NotAnUtf8Str }
    }
    #[classattr]
    fn MalformedGZip() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::MalformedGZip }
    }
    #[classattr]
    fn InvalidSize() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::InvalidSize }
    }
    #[staticmethod]
    fn ParsingFailed(v: XmlError) -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper { inner: AzSvgParseError::ParsingFailed(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzSvgParseError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgParseError::NoParserAvailable => Ok(vec!["NoParserAvailable".into_py(py), ().into_py(py)]),
            AzSvgParseError::ElementsLimitReached => Ok(vec!["ElementsLimitReached".into_py(py), ().into_py(py)]),
            AzSvgParseError::NotAnUtf8Str => Ok(vec!["NotAnUtf8Str".into_py(py), ().into_py(py)]),
            AzSvgParseError::MalformedGZip => Ok(vec!["MalformedGZip".into_py(py), ().into_py(py)]),
            AzSvgParseError::InvalidSize => Ok(vec!["InvalidSize".into_py(py), ().into_py(py)]),
            AzSvgParseError::ParsingFailed(v) => Ok(vec!["ParsingFailed".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgParseErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::svg::SvgParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlErrorEnumWrapper {
    #[classattr]
    fn NoParserAvailable() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::NoParserAvailable }
    }
    #[staticmethod]
    fn InvalidXmlPrefixUri(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidXmlPrefixUri(v) }}
    }
    #[staticmethod]
    fn UnexpectedXmlUri(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnexpectedXmlUri(v) }}
    }
    #[staticmethod]
    fn UnexpectedXmlnsUri(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnexpectedXmlnsUri(v) }}
    }
    #[staticmethod]
    fn InvalidElementNamePrefix(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidElementNamePrefix(v) }}
    }
    #[staticmethod]
    fn DuplicatedNamespace(v: DuplicatedNamespaceError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::DuplicatedNamespace(v) }}
    }
    #[staticmethod]
    fn UnknownNamespace(v: UnknownNamespaceError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnknownNamespace(v) }}
    }
    #[staticmethod]
    fn UnexpectedCloseTag(v: UnexpectedCloseTagError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnexpectedCloseTag(v) }}
    }
    #[staticmethod]
    fn UnexpectedEntityCloseTag(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnexpectedEntityCloseTag(v) }}
    }
    #[staticmethod]
    fn UnknownEntityReference(v: UnknownEntityReferenceError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnknownEntityReference(v) }}
    }
    #[staticmethod]
    fn MalformedEntityReference(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::MalformedEntityReference(v) }}
    }
    #[staticmethod]
    fn EntityReferenceLoop(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::EntityReferenceLoop(v) }}
    }
    #[staticmethod]
    fn InvalidAttributeValue(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidAttributeValue(v) }}
    }
    #[staticmethod]
    fn DuplicatedAttribute(v: DuplicatedAttributeError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::DuplicatedAttribute(v) }}
    }
    #[classattr]
    fn NoRootNode() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::NoRootNode }
    }
    #[classattr]
    fn SizeLimit() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::SizeLimit }
    }
    #[classattr]
    fn DtdDetected() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::DtdDetected }
    }
    #[staticmethod]
    fn MalformedHierarchy(v: MalformedHierarchyError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::MalformedHierarchy(v) }}
    }
    #[staticmethod]
    fn ParserError(v: XmlParseError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::ParserError(v) }}
    }
    #[classattr]
    fn UnclosedRootNode() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnclosedRootNode }
    }
    #[staticmethod]
    fn UnexpectedDeclaration(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnexpectedDeclaration(v) }}
    }
    #[classattr]
    fn NodesLimitReached() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::NodesLimitReached }
    }
    #[classattr]
    fn AttributesLimitReached() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::AttributesLimitReached }
    }
    #[classattr]
    fn NamespacesLimitReached() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::NamespacesLimitReached }
    }
    #[staticmethod]
    fn InvalidName(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidName(v) }}
    }
    #[staticmethod]
    fn NonXmlChar(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::NonXmlChar(v) }}
    }
    #[staticmethod]
    fn InvalidChar(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidChar(v) }}
    }
    #[staticmethod]
    fn InvalidChar2(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidChar2(v) }}
    }
    #[staticmethod]
    fn InvalidString(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidString(v) }}
    }
    #[staticmethod]
    fn InvalidExternalID(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidExternalID(v) }}
    }
    #[staticmethod]
    fn InvalidComment(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidComment(v) }}
    }
    #[staticmethod]
    fn InvalidCharacterData(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::InvalidCharacterData(v) }}
    }
    #[staticmethod]
    fn UnknownToken(v: XmlTextPos) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnknownToken(v) }}
    }
    #[classattr]
    fn UnexpectedEndOfStream() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper { inner: AzXmlError::UnexpectedEndOfStream }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzXmlError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlError::NoParserAvailable => Ok(vec!["NoParserAvailable".into_py(py), ().into_py(py)]),
            AzXmlError::InvalidXmlPrefixUri(v) => Ok(vec!["InvalidXmlPrefixUri".into_py(py), v.into_py(py)]),
            AzXmlError::UnexpectedXmlUri(v) => Ok(vec!["UnexpectedXmlUri".into_py(py), v.into_py(py)]),
            AzXmlError::UnexpectedXmlnsUri(v) => Ok(vec!["UnexpectedXmlnsUri".into_py(py), v.into_py(py)]),
            AzXmlError::InvalidElementNamePrefix(v) => Ok(vec!["InvalidElementNamePrefix".into_py(py), v.into_py(py)]),
            AzXmlError::DuplicatedNamespace(v) => Ok(vec!["DuplicatedNamespace".into_py(py), v.into_py(py)]),
            AzXmlError::UnknownNamespace(v) => Ok(vec!["UnknownNamespace".into_py(py), v.into_py(py)]),
            AzXmlError::UnexpectedCloseTag(v) => Ok(vec!["UnexpectedCloseTag".into_py(py), v.into_py(py)]),
            AzXmlError::UnexpectedEntityCloseTag(v) => Ok(vec!["UnexpectedEntityCloseTag".into_py(py), v.into_py(py)]),
            AzXmlError::UnknownEntityReference(v) => Ok(vec!["UnknownEntityReference".into_py(py), v.into_py(py)]),
            AzXmlError::MalformedEntityReference(v) => Ok(vec!["MalformedEntityReference".into_py(py), v.into_py(py)]),
            AzXmlError::EntityReferenceLoop(v) => Ok(vec!["EntityReferenceLoop".into_py(py), v.into_py(py)]),
            AzXmlError::InvalidAttributeValue(v) => Ok(vec!["InvalidAttributeValue".into_py(py), v.into_py(py)]),
            AzXmlError::DuplicatedAttribute(v) => Ok(vec!["DuplicatedAttribute".into_py(py), v.into_py(py)]),
            AzXmlError::NoRootNode => Ok(vec!["NoRootNode".into_py(py), ().into_py(py)]),
            AzXmlError::SizeLimit => Ok(vec!["SizeLimit".into_py(py), ().into_py(py)]),
            AzXmlError::DtdDetected => Ok(vec!["DtdDetected".into_py(py), ().into_py(py)]),
            AzXmlError::MalformedHierarchy(v) => Ok(vec!["MalformedHierarchy".into_py(py), v.into_py(py)]),
            AzXmlError::ParserError(v) => Ok(vec!["ParserError".into_py(py), v.into_py(py)]),
            AzXmlError::UnclosedRootNode => Ok(vec!["UnclosedRootNode".into_py(py), ().into_py(py)]),
            AzXmlError::UnexpectedDeclaration(v) => Ok(vec!["UnexpectedDeclaration".into_py(py), v.into_py(py)]),
            AzXmlError::NodesLimitReached => Ok(vec!["NodesLimitReached".into_py(py), ().into_py(py)]),
            AzXmlError::AttributesLimitReached => Ok(vec!["AttributesLimitReached".into_py(py), ().into_py(py)]),
            AzXmlError::NamespacesLimitReached => Ok(vec!["NamespacesLimitReached".into_py(py), ().into_py(py)]),
            AzXmlError::InvalidName(v) => Ok(vec!["InvalidName".into_py(py), v.into_py(py)]),
            AzXmlError::NonXmlChar(v) => Ok(vec!["NonXmlChar".into_py(py), v.into_py(py)]),
            AzXmlError::InvalidChar(v) => Ok(vec!["InvalidChar".into_py(py), v.into_py(py)]),
            AzXmlError::InvalidChar2(v) => Ok(vec!["InvalidChar2".into_py(py), v.into_py(py)]),
            AzXmlError::InvalidString(v) => Ok(vec!["InvalidString".into_py(py), v.into_py(py)]),
            AzXmlError::InvalidExternalID(v) => Ok(vec!["InvalidExternalID".into_py(py), v.into_py(py)]),
            AzXmlError::InvalidComment(v) => Ok(vec!["InvalidComment".into_py(py), v.into_py(py)]),
            AzXmlError::InvalidCharacterData(v) => Ok(vec!["InvalidCharacterData".into_py(py), v.into_py(py)]),
            AzXmlError::UnknownToken(v) => Ok(vec!["UnknownToken".into_py(py), v.into_py(py)]),
            AzXmlError::UnexpectedEndOfStream => Ok(vec!["UnexpectedEndOfStream".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDuplicatedNamespaceError {
}

#[pyproto]
impl PyObjectProtocol for AzDuplicatedNamespaceError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::DuplicatedNamespaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::DuplicatedNamespaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUnknownNamespaceError {
}

#[pyproto]
impl PyObjectProtocol for AzUnknownNamespaceError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::UnknownNamespaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::UnknownNamespaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUnexpectedCloseTagError {
}

#[pyproto]
impl PyObjectProtocol for AzUnexpectedCloseTagError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::UnexpectedCloseTagError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::UnexpectedCloseTagError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUnknownEntityReferenceError {
}

#[pyproto]
impl PyObjectProtocol for AzUnknownEntityReferenceError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::UnknownEntityReferenceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::UnknownEntityReferenceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDuplicatedAttributeError {
}

#[pyproto]
impl PyObjectProtocol for AzDuplicatedAttributeError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::DuplicatedAttributeError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::DuplicatedAttributeError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlParseErrorEnumWrapper {
    #[staticmethod]
    fn InvalidDeclaration(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidDeclaration(v) }}
    }
    #[staticmethod]
    fn InvalidComment(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidComment(v) }}
    }
    #[staticmethod]
    fn InvalidPI(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidPI(v) }}
    }
    #[staticmethod]
    fn InvalidDoctype(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidDoctype(v) }}
    }
    #[staticmethod]
    fn InvalidEntity(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidEntity(v) }}
    }
    #[staticmethod]
    fn InvalidElement(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidElement(v) }}
    }
    #[staticmethod]
    fn InvalidAttribute(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidAttribute(v) }}
    }
    #[staticmethod]
    fn InvalidCdata(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidCdata(v) }}
    }
    #[staticmethod]
    fn InvalidCharData(v: XmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::InvalidCharData(v) }}
    }
    #[staticmethod]
    fn UnknownToken(v: XmlTextPos) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper { inner: AzXmlParseError::UnknownToken(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzXmlParseError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlParseError::InvalidDeclaration(v) => Ok(vec!["InvalidDeclaration".into_py(py), v.into_py(py)]),
            AzXmlParseError::InvalidComment(v) => Ok(vec!["InvalidComment".into_py(py), v.into_py(py)]),
            AzXmlParseError::InvalidPI(v) => Ok(vec!["InvalidPI".into_py(py), v.into_py(py)]),
            AzXmlParseError::InvalidDoctype(v) => Ok(vec!["InvalidDoctype".into_py(py), v.into_py(py)]),
            AzXmlParseError::InvalidEntity(v) => Ok(vec!["InvalidEntity".into_py(py), v.into_py(py)]),
            AzXmlParseError::InvalidElement(v) => Ok(vec!["InvalidElement".into_py(py), v.into_py(py)]),
            AzXmlParseError::InvalidAttribute(v) => Ok(vec!["InvalidAttribute".into_py(py), v.into_py(py)]),
            AzXmlParseError::InvalidCdata(v) => Ok(vec!["InvalidCdata".into_py(py), v.into_py(py)]),
            AzXmlParseError::InvalidCharData(v) => Ok(vec!["InvalidCharData".into_py(py), v.into_py(py)]),
            AzXmlParseError::UnknownToken(v) => Ok(vec!["UnknownToken".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlParseErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlParseError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlTextError {
}

#[pyproto]
impl PyObjectProtocol for AzXmlTextError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlTextError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlTextError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlStreamErrorEnumWrapper {
    #[classattr]
    fn UnexpectedEndOfStream() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::UnexpectedEndOfStream }
    }
    #[classattr]
    fn InvalidName() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidName }
    }
    #[staticmethod]
    fn NonXmlChar(v: NonXmlCharError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::NonXmlChar(v) }}
    }
    #[staticmethod]
    fn InvalidChar(v: InvalidCharError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidChar(v) }}
    }
    #[staticmethod]
    fn InvalidCharMultiple(v: InvalidCharMultipleError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidCharMultiple(v) }}
    }
    #[staticmethod]
    fn InvalidQuote(v: InvalidQuoteError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidQuote(v) }}
    }
    #[staticmethod]
    fn InvalidSpace(v: InvalidSpaceError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidSpace(v) }}
    }
    #[staticmethod]
    fn InvalidString(v: InvalidStringError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidString(v) }}
    }
    #[classattr]
    fn InvalidReference() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidReference }
    }
    #[classattr]
    fn InvalidExternalID() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidExternalID }
    }
    #[classattr]
    fn InvalidCommentData() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidCommentData }
    }
    #[classattr]
    fn InvalidCommentEnd() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidCommentEnd }
    }
    #[classattr]
    fn InvalidCharacterData() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper { inner: AzXmlStreamError::InvalidCharacterData }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzXmlStreamError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlStreamError::UnexpectedEndOfStream => Ok(vec!["UnexpectedEndOfStream".into_py(py), ().into_py(py)]),
            AzXmlStreamError::InvalidName => Ok(vec!["InvalidName".into_py(py), ().into_py(py)]),
            AzXmlStreamError::NonXmlChar(v) => Ok(vec!["NonXmlChar".into_py(py), v.into_py(py)]),
            AzXmlStreamError::InvalidChar(v) => Ok(vec!["InvalidChar".into_py(py), v.into_py(py)]),
            AzXmlStreamError::InvalidCharMultiple(v) => Ok(vec!["InvalidCharMultiple".into_py(py), v.into_py(py)]),
            AzXmlStreamError::InvalidQuote(v) => Ok(vec!["InvalidQuote".into_py(py), v.into_py(py)]),
            AzXmlStreamError::InvalidSpace(v) => Ok(vec!["InvalidSpace".into_py(py), v.into_py(py)]),
            AzXmlStreamError::InvalidString(v) => Ok(vec!["InvalidString".into_py(py), v.into_py(py)]),
            AzXmlStreamError::InvalidReference => Ok(vec!["InvalidReference".into_py(py), ().into_py(py)]),
            AzXmlStreamError::InvalidExternalID => Ok(vec!["InvalidExternalID".into_py(py), ().into_py(py)]),
            AzXmlStreamError::InvalidCommentData => Ok(vec!["InvalidCommentData".into_py(py), ().into_py(py)]),
            AzXmlStreamError::InvalidCommentEnd => Ok(vec!["InvalidCommentEnd".into_py(py), ().into_py(py)]),
            AzXmlStreamError::InvalidCharacterData => Ok(vec!["InvalidCharacterData".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlStreamErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlStreamError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::XmlStreamError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNonXmlCharError {
}

#[pyproto]
impl PyObjectProtocol for AzNonXmlCharError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::NonXmlCharError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::NonXmlCharError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidCharError {
}

#[pyproto]
impl PyObjectProtocol for AzInvalidCharError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidCharError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidCharError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidCharMultipleError {
}

#[pyproto]
impl PyObjectProtocol for AzInvalidCharMultipleError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidCharMultipleError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidCharMultipleError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidQuoteError {
}

#[pyproto]
impl PyObjectProtocol for AzInvalidQuoteError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidQuoteError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidQuoteError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidSpaceError {
}

#[pyproto]
impl PyObjectProtocol for AzInvalidSpaceError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidSpaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidSpaceError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidStringError {
}

#[pyproto]
impl PyObjectProtocol for AzInvalidStringError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidStringError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::InvalidStringError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMalformedHierarchyError {
}

#[pyproto]
impl PyObjectProtocol for AzMalformedHierarchyError {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::MalformedHierarchyError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::xml::MalformedHierarchyError = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzEncodeImageErrorEnumWrapper {
    #[classattr]
    const EncoderNotAvailable: AzEncodeImageError = AzEncodeImageError::EncoderNotAvailable;
    #[classattr]
    const InsufficientMemory: AzEncodeImageError = AzEncodeImageError::InsufficientMemory;
    #[classattr]
    const DimensionError: AzEncodeImageError = AzEncodeImageError::DimensionError;
    #[classattr]
    const InvalidData: AzEncodeImageError = AzEncodeImageError::InvalidData;
    #[classattr]
    const Unknown: AzEncodeImageError = AzEncodeImageError::Unknown;
}

#[pyproto]
impl PyObjectProtocol for AzEncodeImageErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::image::encode::EncodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::image::encode::EncodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzEncodeImageErrorEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzResultRawImageDecodeImageErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: RawImage) -> AzResultRawImageDecodeImageErrorEnumWrapper {
        AzResultRawImageDecodeImageErrorEnumWrapper { inner: AzResultRawImageDecodeImageError::Ok(v) }}
    }
    #[staticmethod]
    fn Err(v: DecodeImageError) -> AzResultRawImageDecodeImageErrorEnumWrapper {
        AzResultRawImageDecodeImageErrorEnumWrapper { inner: AzResultRawImageDecodeImageError::Err(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzResultRawImageDecodeImageError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultRawImageDecodeImageError::Ok(v) => Ok(vec!["Ok".into_py(py), v.into_py(py)]),
            AzResultRawImageDecodeImageError::Err(v) => Ok(vec!["Err".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultRawImageDecodeImageErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::image::decode::ResultRawImageDecodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::image::decode::ResultRawImageDecodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDecodeImageErrorEnumWrapper {
    #[classattr]
    const InsufficientMemory: AzDecodeImageError = AzDecodeImageError::InsufficientMemory;
    #[classattr]
    const DimensionError: AzDecodeImageError = AzDecodeImageError::DimensionError;
    #[classattr]
    const UnsupportedImageFormat: AzDecodeImageError = AzDecodeImageError::UnsupportedImageFormat;
    #[classattr]
    const Unknown: AzDecodeImageError = AzDecodeImageError::Unknown;
}

#[pyproto]
impl PyObjectProtocol for AzDecodeImageErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::image::decode::DecodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::image::decode::DecodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzDecodeImageErrorEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzResultU8VecEncodeImageErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: U8Vec) -> AzResultU8VecEncodeImageErrorEnumWrapper {
        AzResultU8VecEncodeImageErrorEnumWrapper { inner: AzResultU8VecEncodeImageError::Ok(v) }}
    }
    #[staticmethod]
    fn Err(v: EncodeImageError) -> AzResultU8VecEncodeImageErrorEnumWrapper {
        AzResultU8VecEncodeImageErrorEnumWrapper { inner: AzResultU8VecEncodeImageError::Err(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzResultU8VecEncodeImageError;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultU8VecEncodeImageError::Ok(v) => Ok(vec!["Ok".into_py(py), v.into_py(py)]),
            AzResultU8VecEncodeImageError::Err(v) => Ok(vec!["Err".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultU8VecEncodeImageErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::image::encode::ResultU8VecEncodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_layout::image::encode::ResultU8VecEncodeImageError = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCascadeInfo {
}

#[pyproto]
impl PyObjectProtocol for AzCascadeInfo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::style::CascadeInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::style::CascadeInfo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRendererTypeEnumWrapper {
    #[classattr]
    const Hardware: AzRendererType = AzRendererType::Hardware;
    #[classattr]
    const Software: AzRendererType = AzRendererType::Software;
}

#[pyproto]
impl PyObjectProtocol for AzRendererTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::RendererType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::RendererType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzRendererTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzExtendModeEnumWrapper {
    #[classattr]
    const Clamp: AzExtendMode = AzExtendMode::Clamp;
    #[classattr]
    const Repeat: AzExtendMode = AzExtendMode::Repeat;
}

#[pyproto]
impl PyObjectProtocol for AzExtendModeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::ExtendMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::style::background::ExtendMode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzExtendModeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzFlowIntoEnumWrapper {
    #[classattr]
    fn None() -> AzFlowIntoEnumWrapper {
        AzFlowIntoEnumWrapper { inner: AzFlowInto::None }
    }
    #[staticmethod]
    fn Named(v: String) -> AzFlowIntoEnumWrapper {
        AzFlowIntoEnumWrapper { inner: AzFlowInto::Named(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzFlowInto;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzFlowInto::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzFlowInto::Named(v) => Ok(vec!["Named".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFlowIntoEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flow::FlowInto = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flow::FlowInto = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVirtualKeyCodeEnumWrapper {
    #[classattr]
    const Key1: AzVirtualKeyCode = AzVirtualKeyCode::Key1;
    #[classattr]
    const Key2: AzVirtualKeyCode = AzVirtualKeyCode::Key2;
    #[classattr]
    const Key3: AzVirtualKeyCode = AzVirtualKeyCode::Key3;
    #[classattr]
    const Key4: AzVirtualKeyCode = AzVirtualKeyCode::Key4;
    #[classattr]
    const Key5: AzVirtualKeyCode = AzVirtualKeyCode::Key5;
    #[classattr]
    const Key6: AzVirtualKeyCode = AzVirtualKeyCode::Key6;
    #[classattr]
    const Key7: AzVirtualKeyCode = AzVirtualKeyCode::Key7;
    #[classattr]
    const Key8: AzVirtualKeyCode = AzVirtualKeyCode::Key8;
    #[classattr]
    const Key9: AzVirtualKeyCode = AzVirtualKeyCode::Key9;
    #[classattr]
    const Key0: AzVirtualKeyCode = AzVirtualKeyCode::Key0;
    #[classattr]
    const A: AzVirtualKeyCode = AzVirtualKeyCode::A;
    #[classattr]
    const B: AzVirtualKeyCode = AzVirtualKeyCode::B;
    #[classattr]
    const C: AzVirtualKeyCode = AzVirtualKeyCode::C;
    #[classattr]
    const D: AzVirtualKeyCode = AzVirtualKeyCode::D;
    #[classattr]
    const E: AzVirtualKeyCode = AzVirtualKeyCode::E;
    #[classattr]
    const F: AzVirtualKeyCode = AzVirtualKeyCode::F;
    #[classattr]
    const G: AzVirtualKeyCode = AzVirtualKeyCode::G;
    #[classattr]
    const H: AzVirtualKeyCode = AzVirtualKeyCode::H;
    #[classattr]
    const I: AzVirtualKeyCode = AzVirtualKeyCode::I;
    #[classattr]
    const J: AzVirtualKeyCode = AzVirtualKeyCode::J;
    #[classattr]
    const K: AzVirtualKeyCode = AzVirtualKeyCode::K;
    #[classattr]
    const L: AzVirtualKeyCode = AzVirtualKeyCode::L;
    #[classattr]
    const M: AzVirtualKeyCode = AzVirtualKeyCode::M;
    #[classattr]
    const N: AzVirtualKeyCode = AzVirtualKeyCode::N;
    #[classattr]
    const O: AzVirtualKeyCode = AzVirtualKeyCode::O;
    #[classattr]
    const P: AzVirtualKeyCode = AzVirtualKeyCode::P;
    #[classattr]
    const Q: AzVirtualKeyCode = AzVirtualKeyCode::Q;
    #[classattr]
    const R: AzVirtualKeyCode = AzVirtualKeyCode::R;
    #[classattr]
    const S: AzVirtualKeyCode = AzVirtualKeyCode::S;
    #[classattr]
    const T: AzVirtualKeyCode = AzVirtualKeyCode::T;
    #[classattr]
    const U: AzVirtualKeyCode = AzVirtualKeyCode::U;
    #[classattr]
    const V: AzVirtualKeyCode = AzVirtualKeyCode::V;
    #[classattr]
    const W: AzVirtualKeyCode = AzVirtualKeyCode::W;
    #[classattr]
    const X: AzVirtualKeyCode = AzVirtualKeyCode::X;
    #[classattr]
    const Y: AzVirtualKeyCode = AzVirtualKeyCode::Y;
    #[classattr]
    const Z: AzVirtualKeyCode = AzVirtualKeyCode::Z;
    #[classattr]
    const Escape: AzVirtualKeyCode = AzVirtualKeyCode::Escape;
    #[classattr]
    const F1: AzVirtualKeyCode = AzVirtualKeyCode::F1;
    #[classattr]
    const F2: AzVirtualKeyCode = AzVirtualKeyCode::F2;
    #[classattr]
    const F3: AzVirtualKeyCode = AzVirtualKeyCode::F3;
    #[classattr]
    const F4: AzVirtualKeyCode = AzVirtualKeyCode::F4;
    #[classattr]
    const F5: AzVirtualKeyCode = AzVirtualKeyCode::F5;
    #[classattr]
    const F6: AzVirtualKeyCode = AzVirtualKeyCode::F6;
    #[classattr]
    const F7: AzVirtualKeyCode = AzVirtualKeyCode::F7;
    #[classattr]
    const F8: AzVirtualKeyCode = AzVirtualKeyCode::F8;
    #[classattr]
    const F9: AzVirtualKeyCode = AzVirtualKeyCode::F9;
    #[classattr]
    const F10: AzVirtualKeyCode = AzVirtualKeyCode::F10;
    #[classattr]
    const F11: AzVirtualKeyCode = AzVirtualKeyCode::F11;
    #[classattr]
    const F12: AzVirtualKeyCode = AzVirtualKeyCode::F12;
    #[classattr]
    const F13: AzVirtualKeyCode = AzVirtualKeyCode::F13;
    #[classattr]
    const F14: AzVirtualKeyCode = AzVirtualKeyCode::F14;
    #[classattr]
    const F15: AzVirtualKeyCode = AzVirtualKeyCode::F15;
    #[classattr]
    const F16: AzVirtualKeyCode = AzVirtualKeyCode::F16;
    #[classattr]
    const F17: AzVirtualKeyCode = AzVirtualKeyCode::F17;
    #[classattr]
    const F18: AzVirtualKeyCode = AzVirtualKeyCode::F18;
    #[classattr]
    const F19: AzVirtualKeyCode = AzVirtualKeyCode::F19;
    #[classattr]
    const F20: AzVirtualKeyCode = AzVirtualKeyCode::F20;
    #[classattr]
    const F21: AzVirtualKeyCode = AzVirtualKeyCode::F21;
    #[classattr]
    const F22: AzVirtualKeyCode = AzVirtualKeyCode::F22;
    #[classattr]
    const F23: AzVirtualKeyCode = AzVirtualKeyCode::F23;
    #[classattr]
    const F24: AzVirtualKeyCode = AzVirtualKeyCode::F24;
    #[classattr]
    const Snapshot: AzVirtualKeyCode = AzVirtualKeyCode::Snapshot;
    #[classattr]
    const Scroll: AzVirtualKeyCode = AzVirtualKeyCode::Scroll;
    #[classattr]
    const Pause: AzVirtualKeyCode = AzVirtualKeyCode::Pause;
    #[classattr]
    const Insert: AzVirtualKeyCode = AzVirtualKeyCode::Insert;
    #[classattr]
    const Home: AzVirtualKeyCode = AzVirtualKeyCode::Home;
    #[classattr]
    const Delete: AzVirtualKeyCode = AzVirtualKeyCode::Delete;
    #[classattr]
    const End: AzVirtualKeyCode = AzVirtualKeyCode::End;
    #[classattr]
    const PageDown: AzVirtualKeyCode = AzVirtualKeyCode::PageDown;
    #[classattr]
    const PageUp: AzVirtualKeyCode = AzVirtualKeyCode::PageUp;
    #[classattr]
    const Left: AzVirtualKeyCode = AzVirtualKeyCode::Left;
    #[classattr]
    const Up: AzVirtualKeyCode = AzVirtualKeyCode::Up;
    #[classattr]
    const Right: AzVirtualKeyCode = AzVirtualKeyCode::Right;
    #[classattr]
    const Down: AzVirtualKeyCode = AzVirtualKeyCode::Down;
    #[classattr]
    const Back: AzVirtualKeyCode = AzVirtualKeyCode::Back;
    #[classattr]
    const Return: AzVirtualKeyCode = AzVirtualKeyCode::Return;
    #[classattr]
    const Space: AzVirtualKeyCode = AzVirtualKeyCode::Space;
    #[classattr]
    const Compose: AzVirtualKeyCode = AzVirtualKeyCode::Compose;
    #[classattr]
    const Caret: AzVirtualKeyCode = AzVirtualKeyCode::Caret;
    #[classattr]
    const Numlock: AzVirtualKeyCode = AzVirtualKeyCode::Numlock;
    #[classattr]
    const Numpad0: AzVirtualKeyCode = AzVirtualKeyCode::Numpad0;
    #[classattr]
    const Numpad1: AzVirtualKeyCode = AzVirtualKeyCode::Numpad1;
    #[classattr]
    const Numpad2: AzVirtualKeyCode = AzVirtualKeyCode::Numpad2;
    #[classattr]
    const Numpad3: AzVirtualKeyCode = AzVirtualKeyCode::Numpad3;
    #[classattr]
    const Numpad4: AzVirtualKeyCode = AzVirtualKeyCode::Numpad4;
    #[classattr]
    const Numpad5: AzVirtualKeyCode = AzVirtualKeyCode::Numpad5;
    #[classattr]
    const Numpad6: AzVirtualKeyCode = AzVirtualKeyCode::Numpad6;
    #[classattr]
    const Numpad7: AzVirtualKeyCode = AzVirtualKeyCode::Numpad7;
    #[classattr]
    const Numpad8: AzVirtualKeyCode = AzVirtualKeyCode::Numpad8;
    #[classattr]
    const Numpad9: AzVirtualKeyCode = AzVirtualKeyCode::Numpad9;
    #[classattr]
    const NumpadAdd: AzVirtualKeyCode = AzVirtualKeyCode::NumpadAdd;
    #[classattr]
    const NumpadDivide: AzVirtualKeyCode = AzVirtualKeyCode::NumpadDivide;
    #[classattr]
    const NumpadDecimal: AzVirtualKeyCode = AzVirtualKeyCode::NumpadDecimal;
    #[classattr]
    const NumpadComma: AzVirtualKeyCode = AzVirtualKeyCode::NumpadComma;
    #[classattr]
    const NumpadEnter: AzVirtualKeyCode = AzVirtualKeyCode::NumpadEnter;
    #[classattr]
    const NumpadEquals: AzVirtualKeyCode = AzVirtualKeyCode::NumpadEquals;
    #[classattr]
    const NumpadMultiply: AzVirtualKeyCode = AzVirtualKeyCode::NumpadMultiply;
    #[classattr]
    const NumpadSubtract: AzVirtualKeyCode = AzVirtualKeyCode::NumpadSubtract;
    #[classattr]
    const AbntC1: AzVirtualKeyCode = AzVirtualKeyCode::AbntC1;
    #[classattr]
    const AbntC2: AzVirtualKeyCode = AzVirtualKeyCode::AbntC2;
    #[classattr]
    const Apostrophe: AzVirtualKeyCode = AzVirtualKeyCode::Apostrophe;
    #[classattr]
    const Apps: AzVirtualKeyCode = AzVirtualKeyCode::Apps;
    #[classattr]
    const Asterisk: AzVirtualKeyCode = AzVirtualKeyCode::Asterisk;
    #[classattr]
    const At: AzVirtualKeyCode = AzVirtualKeyCode::At;
    #[classattr]
    const Ax: AzVirtualKeyCode = AzVirtualKeyCode::Ax;
    #[classattr]
    const Backslash: AzVirtualKeyCode = AzVirtualKeyCode::Backslash;
    #[classattr]
    const Calculator: AzVirtualKeyCode = AzVirtualKeyCode::Calculator;
    #[classattr]
    const Capital: AzVirtualKeyCode = AzVirtualKeyCode::Capital;
    #[classattr]
    const Colon: AzVirtualKeyCode = AzVirtualKeyCode::Colon;
    #[classattr]
    const Comma: AzVirtualKeyCode = AzVirtualKeyCode::Comma;
    #[classattr]
    const Convert: AzVirtualKeyCode = AzVirtualKeyCode::Convert;
    #[classattr]
    const Equals: AzVirtualKeyCode = AzVirtualKeyCode::Equals;
    #[classattr]
    const Grave: AzVirtualKeyCode = AzVirtualKeyCode::Grave;
    #[classattr]
    const Kana: AzVirtualKeyCode = AzVirtualKeyCode::Kana;
    #[classattr]
    const Kanji: AzVirtualKeyCode = AzVirtualKeyCode::Kanji;
    #[classattr]
    const LAlt: AzVirtualKeyCode = AzVirtualKeyCode::LAlt;
    #[classattr]
    const LBracket: AzVirtualKeyCode = AzVirtualKeyCode::LBracket;
    #[classattr]
    const LControl: AzVirtualKeyCode = AzVirtualKeyCode::LControl;
    #[classattr]
    const LShift: AzVirtualKeyCode = AzVirtualKeyCode::LShift;
    #[classattr]
    const LWin: AzVirtualKeyCode = AzVirtualKeyCode::LWin;
    #[classattr]
    const Mail: AzVirtualKeyCode = AzVirtualKeyCode::Mail;
    #[classattr]
    const MediaSelect: AzVirtualKeyCode = AzVirtualKeyCode::MediaSelect;
    #[classattr]
    const MediaStop: AzVirtualKeyCode = AzVirtualKeyCode::MediaStop;
    #[classattr]
    const Minus: AzVirtualKeyCode = AzVirtualKeyCode::Minus;
    #[classattr]
    const Mute: AzVirtualKeyCode = AzVirtualKeyCode::Mute;
    #[classattr]
    const MyComputer: AzVirtualKeyCode = AzVirtualKeyCode::MyComputer;
    #[classattr]
    const NavigateForward: AzVirtualKeyCode = AzVirtualKeyCode::NavigateForward;
    #[classattr]
    const NavigateBackward: AzVirtualKeyCode = AzVirtualKeyCode::NavigateBackward;
    #[classattr]
    const NextTrack: AzVirtualKeyCode = AzVirtualKeyCode::NextTrack;
    #[classattr]
    const NoConvert: AzVirtualKeyCode = AzVirtualKeyCode::NoConvert;
    #[classattr]
    const OEM102: AzVirtualKeyCode = AzVirtualKeyCode::OEM102;
    #[classattr]
    const Period: AzVirtualKeyCode = AzVirtualKeyCode::Period;
    #[classattr]
    const PlayPause: AzVirtualKeyCode = AzVirtualKeyCode::PlayPause;
    #[classattr]
    const Plus: AzVirtualKeyCode = AzVirtualKeyCode::Plus;
    #[classattr]
    const Power: AzVirtualKeyCode = AzVirtualKeyCode::Power;
    #[classattr]
    const PrevTrack: AzVirtualKeyCode = AzVirtualKeyCode::PrevTrack;
    #[classattr]
    const RAlt: AzVirtualKeyCode = AzVirtualKeyCode::RAlt;
    #[classattr]
    const RBracket: AzVirtualKeyCode = AzVirtualKeyCode::RBracket;
    #[classattr]
    const RControl: AzVirtualKeyCode = AzVirtualKeyCode::RControl;
    #[classattr]
    const RShift: AzVirtualKeyCode = AzVirtualKeyCode::RShift;
    #[classattr]
    const RWin: AzVirtualKeyCode = AzVirtualKeyCode::RWin;
    #[classattr]
    const Semicolon: AzVirtualKeyCode = AzVirtualKeyCode::Semicolon;
    #[classattr]
    const Slash: AzVirtualKeyCode = AzVirtualKeyCode::Slash;
    #[classattr]
    const Sleep: AzVirtualKeyCode = AzVirtualKeyCode::Sleep;
    #[classattr]
    const Stop: AzVirtualKeyCode = AzVirtualKeyCode::Stop;
    #[classattr]
    const Sysrq: AzVirtualKeyCode = AzVirtualKeyCode::Sysrq;
    #[classattr]
    const Tab: AzVirtualKeyCode = AzVirtualKeyCode::Tab;
    #[classattr]
    const Underline: AzVirtualKeyCode = AzVirtualKeyCode::Underline;
    #[classattr]
    const Unlabeled: AzVirtualKeyCode = AzVirtualKeyCode::Unlabeled;
    #[classattr]
    const VolumeDown: AzVirtualKeyCode = AzVirtualKeyCode::VolumeDown;
    #[classattr]
    const VolumeUp: AzVirtualKeyCode = AzVirtualKeyCode::VolumeUp;
    #[classattr]
    const Wake: AzVirtualKeyCode = AzVirtualKeyCode::Wake;
    #[classattr]
    const WebBack: AzVirtualKeyCode = AzVirtualKeyCode::WebBack;
    #[classattr]
    const WebFavorites: AzVirtualKeyCode = AzVirtualKeyCode::WebFavorites;
    #[classattr]
    const WebForward: AzVirtualKeyCode = AzVirtualKeyCode::WebForward;
    #[classattr]
    const WebHome: AzVirtualKeyCode = AzVirtualKeyCode::WebHome;
    #[classattr]
    const WebRefresh: AzVirtualKeyCode = AzVirtualKeyCode::WebRefresh;
    #[classattr]
    const WebSearch: AzVirtualKeyCode = AzVirtualKeyCode::WebSearch;
    #[classattr]
    const WebStop: AzVirtualKeyCode = AzVirtualKeyCode::WebStop;
    #[classattr]
    const Yen: AzVirtualKeyCode = AzVirtualKeyCode::Yen;
    #[classattr]
    const Copy: AzVirtualKeyCode = AzVirtualKeyCode::Copy;
    #[classattr]
    const Paste: AzVirtualKeyCode = AzVirtualKeyCode::Paste;
    #[classattr]
    const Cut: AzVirtualKeyCode = AzVirtualKeyCode::Cut;
}

#[pyproto]
impl PyObjectProtocol for AzVirtualKeyCodeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCode = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzVirtualKeyCodeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzVirtualKeyCodeCombo {
}

#[pyproto]
impl PyObjectProtocol for AzVirtualKeyCodeCombo {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeCombo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::window::VirtualKeyCodeCombo = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIdOrClassEnumWrapper {
    #[staticmethod]
    fn Id(v: String) -> AzIdOrClassEnumWrapper {
        AzIdOrClassEnumWrapper { inner: AzIdOrClass::Id(v) }}
    }
    #[staticmethod]
    fn Class(v: String) -> AzIdOrClassEnumWrapper {
        AzIdOrClassEnumWrapper { inner: AzIdOrClass::Class(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzIdOrClass;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzIdOrClass::Id(v) => Ok(vec!["Id".into_py(py), v.into_py(py)]),
            AzIdOrClass::Class(v) => Ok(vec!["Class".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIdOrClassEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::IdOrClass = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::dom::IdOrClass = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInterpolateResolver {
}

#[pyproto]
impl PyObjectProtocol for AzInterpolateResolver {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::InterpolateResolver = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::basic::animation::InterpolateResolver = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFlowFromEnumWrapper {
    #[classattr]
    fn None() -> AzFlowFromEnumWrapper {
        AzFlowFromEnumWrapper { inner: AzFlowFrom::None }
    }
    #[staticmethod]
    fn Named(v: String) -> AzFlowFromEnumWrapper {
        AzFlowFromEnumWrapper { inner: AzFlowFrom::Named(v) }}
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use crate::python::AzFlowFrom;
        use pyo3::conversion::IntoPy;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzFlowFrom::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzFlowFrom::Named(v) => Ok(vec!["Named".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFlowFromEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flow::FlowFrom = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_css::props::layout::flow::FlowFrom = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRefCount {
    fn can_be_shared(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn can_be_shared_mut(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn increase_ref(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn decrease_ref(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn increase_refmut(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn decrease_refmut(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzRefCount {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::refany::RefCount = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::refany::RefCount = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUpdateEnumWrapper {
    #[classattr]
    const DoNothing: AzUpdate = AzUpdate::DoNothing;
    #[classattr]
    const RefreshDom: AzUpdate = AzUpdate::RefreshDom;
    #[classattr]
    const RefreshDomAllWindows: AzUpdate = AzUpdate::RefreshDomAllWindows;
}

#[pyproto]
impl PyObjectProtocol for AzUpdateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::Update = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::Update = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzUpdateEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzRefAny {
    #[staticmethod]
    fn new_c(/* args */) -> AzRefAny {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

    fn get_type_id(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn is_type(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzRefAny {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::refany::RefAny = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::refany::RefAny = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzEdgeTypeEnumWrapper {
    #[classattr]
    const Top: AzEdgeType = AzEdgeType::Top;
    #[classattr]
    const Bottom: AzEdgeType = AzEdgeType::Bottom;
    #[classattr]
    const Left: AzEdgeType = AzEdgeType::Left;
    #[classattr]
    const Right: AzEdgeType = AzEdgeType::Right;
}

#[pyproto]
impl PyObjectProtocol for AzEdgeTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::EdgeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::callbacks::EdgeType = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzEdgeTypeEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzDebugMessage {
}

#[pyproto]
impl PyObjectProtocol for AzDebugMessage {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::DebugMessage = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::gl::DebugMessage = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAppConfig {
    #[new]
    fn new(/* args */) -> AzAppConfig {
        // Implementation would convert Python args to Rust types
        // and call the appropriate C function
        unimplemented!()
    }

}

#[pyproto]
impl PyObjectProtocol for AzAppConfig {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::AppConfig = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::AppConfig = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzApp {
    fn add_window(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn get_monitors(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

    fn run(&self/* , args */) -> PyResult<()> {
        // Implementation would convert Python args to Rust types,
        // call the appropriate C function, and convert results back
        Ok(())
    }

}

#[pyproto]
impl PyObjectProtocol for AzApp {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::desktop::app::App = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_dll::desktop::app::App = unsafe { mem::transmute(self) }; Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAppTerminationBehaviorEnumWrapper {
    #[classattr]
    const ReturnToMain: AzAppTerminationBehavior = AzAppTerminationBehavior::ReturnToMain;
    #[classattr]
    const RunForever: AzAppTerminationBehavior = AzAppTerminationBehavior::RunForever;
    #[classattr]
    const EndProcess: AzAppTerminationBehavior = AzAppTerminationBehavior::EndProcess;
}

#[pyproto]
impl PyObjectProtocol for AzAppTerminationBehaviorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::AppTerminationBehavior = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::AppTerminationBehavior = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAppTerminationBehaviorEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

#[pymethods]
impl AzAppLogLevelEnumWrapper {
    #[classattr]
    const Off: AzAppLogLevel = AzAppLogLevel::Off;
    #[classattr]
    const Error: AzAppLogLevel = AzAppLogLevel::Error;
    #[classattr]
    const Warn: AzAppLogLevel = AzAppLogLevel::Warn;
    #[classattr]
    const Info: AzAppLogLevel = AzAppLogLevel::Info;
    #[classattr]
    const Debug: AzAppLogLevel = AzAppLogLevel::Debug;
    #[classattr]
    const Trace: AzAppLogLevel = AzAppLogLevel::Trace;
}

#[pyproto]
impl PyObjectProtocol for AzAppLogLevelEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::AppLogLevel = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> { 
        let m: &azul_core::resources::AppLogLevel = unsafe { mem::transmute(&self.inner) }; Ok(format!("{:#?}", m))
    }
    fn __richcmp__(&self, other: AzAppLogLevelEnumWrapper, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => { Ok((self.clone().inner as usize) <  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Le => { Ok((self.clone().inner as usize) <= (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Eq => { Ok((self.clone().inner as usize) == (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ne => { Ok((self.clone().inner as usize) != (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Gt => { Ok((self.clone().inner as usize) >  (other.clone().inner as usize)) }
            pyo3::class::basic::CompareOp::Ge => { Ok((self.clone().inner as usize) >= (other.clone().inner as usize)) }
        }
    }
}

// Error type conversions
// Error type implementations would go here

#[pymodule]
fn azul(py: Python, m: &PyModule) -> PyResult<()> {

    #[cfg(all(feature = "use_pyo3_logger", not(feature = "use_fern_logger")))] {
        let mut filter = log::LevelFilter::Warn;

        if std::env::var("AZUL_PY_LOGLEVEL_ERROR").is_ok() { filter = log::LevelFilter::Error; }
        if std::env::var("AZUL_PY_LOGLEVEL_WARN").is_ok() { filter = log::LevelFilter::Warn; }
        if std::env::var("AZUL_PY_LOGLEVEL_INFO").is_ok() { filter = log::LevelFilter::Info; }
        if std::env::var("AZUL_PY_LOGLEVEL_DEBUG").is_ok() { filter = log::LevelFilter::Debug; }
        if std::env::var("AZUL_PY_LOGLEVEL_TRACE").is_ok() { filter = log::LevelFilter::Trace; }
        if std::env::var("AZUL_PY_LOGLEVEL_OFF").is_ok() { filter = log::LevelFilter::Off; }
    }

    m.add_class::<AzStyleCursorEnumWrapper>()?;
    m.add_class::<AzWindowEventFilterEnumWrapper>()?;
    m.add_class::<AzHidpiAdjustedBounds>()?;
    m.add_class::<AzWindowThemeEnumWrapper>()?;
    m.add_class::<AzDpiScaleFactor>()?;
    m.add_class::<AzMouseCursorTypeEnumWrapper>()?;
    m.add_class::<AzWindowFrameEnumWrapper>()?;
    m.add_class::<AzLinuxWindowOptions>()?;
    m.add_class::<AzWaylandTheme>()?;
    m.add_class::<AzUserAttentionTypeEnumWrapper>()?;
    m.add_class::<AzMonitorId>()?;
    m.add_class::<AzWindowFlags>()?;
    m.add_class::<AzTaskBarIcon>()?;
    m.add_class::<AzWasmWindowOptions>()?;
    m.add_class::<AzSmallWindowIconBytes>()?;
    m.add_class::<AzMonitor>()?;
    m.add_class::<AzIconKey>()?;
    m.add_class::<AzHwAccelerationEnumWrapper>()?;
    m.add_class::<AzMacWindowOptions>()?;
    m.add_class::<AzVsyncEnumWrapper>()?;
    m.add_class::<AzVideoMode>()?;
    m.add_class::<AzLargeWindowIconBytes>()?;
    m.add_class::<AzXWindowTypeEnumWrapper>()?;
    m.add_class::<AzPlatformSpecificOptions>()?;
    m.add_class::<AzWindowIconEnumWrapper>()?;
    m.add_class::<AzWindowSize>()?;
    m.add_class::<AzWindowsWindowOptions>()?;
    m.add_class::<AzWindowTypeEnumWrapper>()?;
    m.add_class::<AzWindowCreateOptions>()?;
    m.add_class::<AzFullWindowState>()?;

    m.add_class::<AzIFrameCallback>()?;
    m.add_class::<AzIFrameCallbackReturn>()?;
    m.add_class::<AzIFrameCallbackInfo>()?;
    m.add_class::<AzCallbackInfo>()?;
    m.add_class::<AzRenderImageCallbackInfo>()?;
    m.add_class::<AzIFrameCallbackReasonEnumWrapper>()?;
    m.add_class::<AzMarshaledLayoutCallbackInner>()?;
    m.add_class::<AzLayoutCallbackInner>()?;
    m.add_class::<AzLayoutCallbackEnumWrapper>()?;
    m.add_class::<AzLayoutCallbackInfo>()?;
    m.add_class::<AzMarshaledLayoutCallback>()?;

    m.add_class::<AzDom>()?;
    m.add_class::<AzNodeData>()?;
    m.add_class::<AzNodeTypeEnumWrapper>()?;
    m.add_class::<AzAccessibilityInfo>()?;
    m.add_class::<AzAccessibilityRoleEnumWrapper>()?;
    m.add_class::<AzAccessibilityStateEnumWrapper>()?;
    m.add_class::<AzTabIndexEnumWrapper>()?;
    m.add_class::<AzNodeDataInlineCssPropertyEnumWrapper>()?;
    m.add_class::<AzDomId>()?;
    m.add_class::<AzDomNodeId>()?;
    m.add_class::<AzAccessibilityActionEnumWrapper>()?;
    m.add_class::<AzListViewOnColumnClickCallback>()?;
    m.add_class::<AzTagIdToNodeIdMapping>()?;
    m.add_class::<AzCoreCallback>()?;
    m.add_class::<AzNodeHierarchyItemId>()?;
    m.add_class::<AzSvgXmlNode>()?;
    m.add_class::<AzCoreCallbackData>()?;
    m.add_class::<AzListViewOnRowClickCallback>()?;
    m.add_class::<AzSvgSimpleNodeEnumWrapper>()?;
    m.add_class::<AzCoreMenuCallback>()?;
    m.add_class::<AzAttributeNameValue>()?;
    m.add_class::<AzCheckBoxOnToggleCallback>()?;
    m.add_class::<AzTabOnClickCallback>()?;
    m.add_class::<AzParentWithNodeDepth>()?;
    m.add_class::<AzListViewOnLazyLoadScrollCallback>()?;
    m.add_class::<AzAttributeTypeEnumWrapper>()?;
    m.add_class::<AzXmlNodeChildEnumWrapper>()?;
    m.add_class::<AzNodeHierarchyItem>()?;
    m.add_class::<AzButtonOnClickCallback>()?;
    m.add_class::<AzXmlNode>()?;
    m.add_class::<AzTagId>()?;
    m.add_class::<AzNodeTypeTagEnumWrapper>()?;
    m.add_class::<AzVertexAttributeTypeEnumWrapper>()?;
    m.add_class::<AzVertexAttribute>()?;
    m.add_class::<AzInstantPtrCloneCallback>()?;
    m.add_class::<AzInstantPtrDestructorCallback>()?;
    m.add_class::<AzCallback>()?;
    m.add_class::<AzDebugState>()?;
    m.add_class::<AzKeyboardState>()?;
    m.add_class::<AzTouchState>()?;
    m.add_class::<AzMouseState>()?;

    m.add_class::<AzMenu>()?;
    m.add_class::<AzContextMenuMouseButtonEnumWrapper>()?;
    m.add_class::<AzMenuPopupPositionEnumWrapper>()?;
    m.add_class::<AzMenuItemEnumWrapper>()?;
    m.add_class::<AzStringMenuItem>()?;
    m.add_class::<AzMenuItemIconEnumWrapper>()?;
    m.add_class::<AzMenuItemStateEnumWrapper>()?;

    m.add_class::<AzCssRuleBlock>()?;
    m.add_class::<AzCssPropertyEnumWrapper>()?;
    m.add_class::<AzCssNthChildSelectorEnumWrapper>()?;
    m.add_class::<AzCssNthChildPattern>()?;
    m.add_class::<AzStylesheet>()?;
    m.add_class::<AzCss>()?;
    m.add_class::<AzCssDeclarationEnumWrapper>()?;
    m.add_class::<AzDynamicCssProperty>()?;
    m.add_class::<AzAnimationInterpolationFunctionEnumWrapper>()?;
    m.add_class::<AzColorU>()?;
    m.add_class::<AzSizeMetricEnumWrapper>()?;
    m.add_class::<AzPixelValue>()?;
    m.add_class::<AzPixelValueNoPercent>()?;
    m.add_class::<AzBoxShadowClipModeEnumWrapper>()?;
    m.add_class::<AzStyleBoxShadow>()?;
    m.add_class::<AzStyleMixBlendModeEnumWrapper>()?;
    m.add_class::<AzStyleFilterEnumWrapper>()?;
    m.add_class::<AzStyleBlur>()?;
    m.add_class::<AzStyleColorMatrix>()?;
    m.add_class::<AzStyleFilterOffset>()?;
    m.add_class::<AzStyleCompositeFilterEnumWrapper>()?;
    m.add_class::<AzLayoutAlignContentEnumWrapper>()?;
    m.add_class::<AzLayoutAlignItemsEnumWrapper>()?;
    m.add_class::<AzLayoutBottom>()?;
    m.add_class::<AzLayoutBoxSizingEnumWrapper>()?;
    m.add_class::<AzLayoutFlexDirectionEnumWrapper>()?;
    m.add_class::<AzLayoutDisplayEnumWrapper>()?;
    m.add_class::<AzLayoutFlexGrow>()?;
    m.add_class::<AzLayoutFlexShrink>()?;
    m.add_class::<AzLayoutFloatEnumWrapper>()?;
    m.add_class::<AzLayoutHeightEnumWrapper>()?;
    m.add_class::<AzLayoutJustifyContentEnumWrapper>()?;
    m.add_class::<AzLayoutLeft>()?;
    m.add_class::<AzLayoutMarginBottom>()?;
    m.add_class::<AzLayoutMarginLeft>()?;
    m.add_class::<AzLayoutMarginRight>()?;
    m.add_class::<AzLayoutMarginTop>()?;
    m.add_class::<AzLayoutMaxHeight>()?;
    m.add_class::<AzLayoutMaxWidth>()?;
    m.add_class::<AzLayoutMinHeight>()?;
    m.add_class::<AzLayoutMinWidth>()?;
    m.add_class::<AzLayoutPaddingBottom>()?;
    m.add_class::<AzLayoutPaddingLeft>()?;
    m.add_class::<AzLayoutPaddingRight>()?;
    m.add_class::<AzLayoutPaddingTop>()?;
    m.add_class::<AzLayoutPositionEnumWrapper>()?;
    m.add_class::<AzLayoutRight>()?;
    m.add_class::<AzLayoutTop>()?;
    m.add_class::<AzLayoutWidthEnumWrapper>()?;
    m.add_class::<AzLayoutFlexWrapEnumWrapper>()?;
    m.add_class::<AzLayoutOverflowEnumWrapper>()?;
    m.add_class::<AzFloatValue>()?;
    m.add_class::<AzPercentageValue>()?;
    m.add_class::<AzAngleMetricEnumWrapper>()?;
    m.add_class::<AzAngleValue>()?;
    m.add_class::<AzNormalizedLinearColorStop>()?;
    m.add_class::<AzNormalizedRadialColorStop>()?;
    m.add_class::<AzDirectionCornerEnumWrapper>()?;
    m.add_class::<AzDirectionCorners>()?;
    m.add_class::<AzDirectionEnumWrapper>()?;
    m.add_class::<AzLinearGradient>()?;
    m.add_class::<AzShapeEnumWrapper>()?;
    m.add_class::<AzRadialGradientSizeEnumWrapper>()?;
    m.add_class::<AzRadialGradient>()?;
    m.add_class::<AzConicGradient>()?;
    m.add_class::<AzStyleBackgroundContentEnumWrapper>()?;
    m.add_class::<AzBackgroundPositionHorizontalEnumWrapper>()?;
    m.add_class::<AzBackgroundPositionVerticalEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundPosition>()?;
    m.add_class::<AzStyleBackgroundRepeatEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundSizeEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomColor>()?;
    m.add_class::<AzStyleBorderBottomLeftRadius>()?;
    m.add_class::<AzStyleBorderBottomRightRadius>()?;
    m.add_class::<AzBorderStyleEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomStyle>()?;
    m.add_class::<AzLayoutBorderBottomWidth>()?;
    m.add_class::<AzStyleBorderLeftColor>()?;
    m.add_class::<AzStyleBorderLeftStyle>()?;
    m.add_class::<AzLayoutBorderLeftWidth>()?;
    m.add_class::<AzStyleBorderRightColor>()?;
    m.add_class::<AzStyleBorderRightStyle>()?;
    m.add_class::<AzLayoutBorderRightWidth>()?;
    m.add_class::<AzStyleBorderTopColor>()?;
    m.add_class::<AzStyleBorderTopLeftRadius>()?;
    m.add_class::<AzStyleBorderTopRightRadius>()?;
    m.add_class::<AzStyleBorderTopStyle>()?;
    m.add_class::<AzLayoutBorderTopWidth>()?;
    m.add_class::<AzScrollbarInfo>()?;
    m.add_class::<AzScrollbarStyle>()?;
    m.add_class::<AzStyleFontFamilyEnumWrapper>()?;
    m.add_class::<AzStyleFontSize>()?;
    m.add_class::<AzStyleLetterSpacing>()?;
    m.add_class::<AzStyleLineHeight>()?;
    m.add_class::<AzStyleTabWidth>()?;
    m.add_class::<AzStyleOpacity>()?;
    m.add_class::<AzStyleTransformOrigin>()?;
    m.add_class::<AzStyleBackfaceVisibilityEnumWrapper>()?;
    m.add_class::<AzStyleTransformEnumWrapper>()?;
    m.add_class::<AzStyleTransformMatrix2D>()?;
    m.add_class::<AzStyleTransformMatrix3D>()?;
    m.add_class::<AzStyleTransformTranslate2D>()?;
    m.add_class::<AzStyleTransformTranslate3D>()?;
    m.add_class::<AzStyleTransformRotate3D>()?;
    m.add_class::<AzStyleTransformScale2D>()?;
    m.add_class::<AzStyleTransformScale3D>()?;
    m.add_class::<AzStyleTransformSkew2D>()?;
    m.add_class::<AzStyleTextAlignEnumWrapper>()?;
    m.add_class::<AzStyleTextColor>()?;
    m.add_class::<AzStyleWordSpacing>()?;
    m.add_class::<AzCssPropertyValueEnumWrapper>()?;
    m.add_class::<AzCounterReset>()?;
    m.add_class::<AzGridLineEnumWrapper>()?;
    m.add_class::<AzStylePerspectiveOrigin>()?;
    m.add_class::<AzLayoutZIndexEnumWrapper>()?;
    m.add_class::<AzLayoutJustifyItemsEnumWrapper>()?;
    m.add_class::<AzSelectionBackgroundColor>()?;
    m.add_class::<AzColumnRuleColor>()?;
    m.add_class::<AzColumnSpanEnumWrapper>()?;
    m.add_class::<AzLayoutClearEnumWrapper>()?;
    m.add_class::<AzStyleWhiteSpaceEnumWrapper>()?;
    m.add_class::<AzBreakInsideEnumWrapper>()?;
    m.add_class::<AzLayoutAlignSelfEnumWrapper>()?;
    m.add_class::<AzCaretAnimationDuration>()?;
    m.add_class::<AzColumnRuleStyle>()?;
    m.add_class::<AzGridPlacement>()?;
    m.add_class::<AzShapeOutsideEnumWrapper>()?;
    m.add_class::<AzColumnCountEnumWrapper>()?;
    m.add_class::<AzLayoutWritingModeEnumWrapper>()?;
    m.add_class::<AzStyleUserSelectEnumWrapper>()?;
    m.add_class::<AzGridTemplate>()?;
    m.add_class::<AzLayoutJustifySelfEnumWrapper>()?;
    m.add_class::<AzContent>()?;
    m.add_class::<AzStyleHyphensEnumWrapper>()?;
    m.add_class::<AzLayoutGap>()?;
    m.add_class::<AzStyleDirectionEnumWrapper>()?;
    m.add_class::<AzLayoutFlexBasisEnumWrapper>()?;
    m.add_class::<AzShapeMargin>()?;
    m.add_class::<AzLayoutTextJustifyEnumWrapper>()?;
    m.add_class::<AzColumnWidthEnumWrapper>()?;
    m.add_class::<AzCounterIncrement>()?;
    m.add_class::<AzBoxDecorationBreakEnumWrapper>()?;
    m.add_class::<AzSelectionColor>()?;
    m.add_class::<AzStyleVisibilityEnumWrapper>()?;
    m.add_class::<AzShapeImageThreshold>()?;
    m.add_class::<AzLayoutGridAutoFlowEnumWrapper>()?;
    m.add_class::<AzColumnRuleWidth>()?;
    m.add_class::<AzStyleTextDecorationEnumWrapper>()?;
    m.add_class::<AzCaretColor>()?;
    m.add_class::<AzLayoutSize>()?;
    m.add_class::<AzColumnFillEnumWrapper>()?;
    m.add_class::<AzPageBreakEnumWrapper>()?;
    m.add_class::<AzLayoutScrollbarWidthEnumWrapper>()?;
    m.add_class::<AzStyleScrollbarColorEnumWrapper>()?;
    m.add_class::<AzStyleVerticalAlignEnumWrapper>()?;
    m.add_class::<AzStyleLineClamp>()?;
    m.add_class::<AzShapeInsideEnumWrapper>()?;
    m.add_class::<AzSelectionRadius>()?;
    m.add_class::<AzOrphans>()?;
    m.add_class::<AzStyleTextIndent>()?;
    m.add_class::<AzLayoutBorderSpacing>()?;
    m.add_class::<AzLayoutPaddingInlineStart>()?;
    m.add_class::<AzStyleFontWeightEnumWrapper>()?;
    m.add_class::<AzStyleExclusionMargin>()?;
    m.add_class::<AzWidows>()?;
    m.add_class::<AzLayoutColumnGap>()?;
    m.add_class::<AzLayoutPaddingInlineEnd>()?;
    m.add_class::<AzStyleListStyleTypeEnumWrapper>()?;
    m.add_class::<AzClipPathEnumWrapper>()?;
    m.add_class::<AzStyleHyphenationLanguage>()?;
    m.add_class::<AzStyleListStylePositionEnumWrapper>()?;
    m.add_class::<AzStyleBorderCollapseEnumWrapper>()?;
    m.add_class::<AzStyleCaptionSideEnumWrapper>()?;
    m.add_class::<AzLayoutRowGap>()?;
    m.add_class::<AzStyleHangingPunctuation>()?;
    m.add_class::<AzLayoutTableLayoutEnumWrapper>()?;
    m.add_class::<AzStyleInitialLetter>()?;
    m.add_class::<AzStyleEmptyCellsEnumWrapper>()?;
    m.add_class::<AzStyleFontStyleEnumWrapper>()?;
    m.add_class::<AzStyleTextCombineUprightEnumWrapper>()?;
    m.add_class::<AzGridTrackSizingEnumWrapper>()?;
    m.add_class::<AzPhysicalSizeU32>()?;
    m.add_class::<AzHoverEventFilterEnumWrapper>()?;
    m.add_class::<AzTextSelectionStartEnd>()?;
    m.add_class::<AzShapeRenderingEnumWrapper>()?;
    m.add_class::<AzApplicationEventFilterEnumWrapper>()?;
    m.add_class::<AzSvgFillStyle>()?;
    m.add_class::<AzXmlTextPos>()?;
    m.add_class::<AzLogicalSize>()?;
    m.add_class::<AzStyledNodeState>()?;
    m.add_class::<AzCssPropertyCachePtr>()?;
    m.add_class::<AzSvgRenderTransform>()?;
    m.add_class::<AzTextRenderingEnumWrapper>()?;
    m.add_class::<AzFocusEventFilterEnumWrapper>()?;
    m.add_class::<AzLogicalPosition>()?;
    m.add_class::<AzEventFilterEnumWrapper>()?;
    m.add_class::<AzPhysicalSize>()?;
    m.add_class::<AzSvgStyleEnumWrapper>()?;
    m.add_class::<AzIndentEnumWrapper>()?;
    m.add_class::<AzFontDatabaseEnumWrapper>()?;
    m.add_class::<AzStyledDom>()?;
    m.add_class::<AzStyledNode>()?;
    m.add_class::<AzNotEventFilterEnumWrapper>()?;
    m.add_class::<AzComponentEventFilterEnumWrapper>()?;
    m.add_class::<AzSvgTransform>()?;
    m.add_class::<AzVertexLayout>()?;
    m.add_class::<AzGridMinMax>()?;
    m.add_class::<AzNamedGridLine>()?;
    m.add_class::<AzScrollbarColorCustom>()?;
    m.add_class::<AzShapeInset>()?;
    m.add_class::<AzCssShapeEnumWrapper>()?;
    m.add_class::<AzShapePath>()?;
    m.add_class::<AzShapeEllipse>()?;
    m.add_class::<AzShapePoint>()?;
    m.add_class::<AzWindowBackgroundMaterialEnumWrapper>()?;
    m.add_class::<AzLayoutRect>()?;
    m.add_class::<AzWindowPositionEnumWrapper>()?;
    m.add_class::<AzLayoutPoint>()?;
    m.add_class::<AzCursorPositionEnumWrapper>()?;
    m.add_class::<AzImePositionEnumWrapper>()?;
    m.add_class::<AzWindowDecorationsEnumWrapper>()?;
    m.add_class::<AzPhysicalPosition>()?;
    m.add_class::<AzLinuxDecorationsState>()?;
    m.add_class::<AzSrgbEnumWrapper>()?;

    m.add_class::<AzButton>()?;
    m.add_class::<AzButtonOnClick>()?;
    m.add_class::<AzFileInput>()?;
    m.add_class::<AzFileInputStateWrapper>()?;
    m.add_class::<AzFileInputState>()?;
    m.add_class::<AzFileInputOnPathChange>()?;
    m.add_class::<AzFileInputOnPathChangeCallback>()?;
    m.add_class::<AzCheckBox>()?;
    m.add_class::<AzCheckBoxStateWrapper>()?;
    m.add_class::<AzCheckBoxOnToggle>()?;
    m.add_class::<AzCheckBoxState>()?;
    m.add_class::<AzColorInput>()?;
    m.add_class::<AzColorInputStateWrapper>()?;
    m.add_class::<AzColorInputState>()?;
    m.add_class::<AzColorInputOnValueChange>()?;
    m.add_class::<AzColorInputOnValueChangeCallback>()?;
    m.add_class::<AzTextInput>()?;
    m.add_class::<AzTextInputStateWrapper>()?;
    m.add_class::<AzTextInputState>()?;
    m.add_class::<AzTextInputSelectionEnumWrapper>()?;
    m.add_class::<AzTextInputSelectionRange>()?;
    m.add_class::<AzTextInputOnTextInput>()?;
    m.add_class::<AzTextInputOnTextInputCallback>()?;
    m.add_class::<AzTextInputOnVirtualKeyDown>()?;
    m.add_class::<AzTextInputOnVirtualKeyDownCallback>()?;
    m.add_class::<AzTextInputOnFocusLost>()?;
    m.add_class::<AzTextInputOnFocusLostCallback>()?;
    m.add_class::<AzOnTextInputReturn>()?;
    m.add_class::<AzTextInputValidEnumWrapper>()?;
    m.add_class::<AzNumberInput>()?;
    m.add_class::<AzNumberInputStateWrapper>()?;
    m.add_class::<AzNumberInputState>()?;
    m.add_class::<AzNumberInputOnValueChange>()?;
    m.add_class::<AzNumberInputOnValueChangeCallback>()?;
    m.add_class::<AzNumberInputOnFocusLost>()?;
    m.add_class::<AzNumberInputOnFocusLostCallback>()?;
    m.add_class::<AzProgressBar>()?;
    m.add_class::<AzProgressBarState>()?;
    m.add_class::<AzTabHeader>()?;
    m.add_class::<AzTabOnClick>()?;
    m.add_class::<AzFrame>()?;
    m.add_class::<AzListView>()?;
    m.add_class::<AzListViewRow>()?;
    m.add_class::<AzListViewOnLazyLoadScroll>()?;
    m.add_class::<AzListViewOnColumnClick>()?;
    m.add_class::<AzListViewOnRowClick>()?;
    m.add_class::<AzIFrameNode>()?;
    m.add_class::<AzListViewState>()?;
    m.add_class::<AzTabHeaderState>()?;

    m.add_class::<AzTexture>()?;
    m.add_class::<AzGlVoidPtrConst>()?;
    m.add_class::<AzGlVoidPtrMut>()?;
    m.add_class::<AzTextureFlags>()?;
    m.add_class::<AzGlShaderPrecisionFormatReturn>()?;
    m.add_class::<AzGlContextPtr>()?;
    m.add_class::<AzGetProgramBinaryReturn>()?;
    m.add_class::<AzGetActiveAttribReturn>()?;
    m.add_class::<AzGLsyncPtr>()?;
    m.add_class::<AzGetActiveUniformReturn>()?;
    m.add_class::<AzSvgVertex>()?;
    m.add_class::<AzVertexArrayObject>()?;
    m.add_class::<AzIndexBufferFormatEnumWrapper>()?;
    m.add_class::<AzVertexBuffer>()?;
    m.add_class::<AzGlTypeEnumWrapper>()?;

    m.add_class::<AzImageRef>()?;
    m.add_class::<AzRawImage>()?;
    m.add_class::<AzImageMask>()?;
    m.add_class::<AzRawImageFormatEnumWrapper>()?;
    m.add_class::<AzRawImageDataEnumWrapper>()?;
    m.add_class::<AzImageRenderingEnumWrapper>()?;

    m.add_class::<AzFontMetrics>()?;
    m.add_class::<AzFontRef>()?;
    m.add_class::<AzLoadedFontSource>()?;

    m.add_class::<AzSvg>()?;
    m.add_class::<AzSvgMultiPolygon>()?;
    m.add_class::<AzSvgNodeEnumWrapper>()?;
    m.add_class::<AzSvgCircle>()?;
    m.add_class::<AzSvgPath>()?;
    m.add_class::<AzSvgPathElementEnumWrapper>()?;
    m.add_class::<AzSvgPoint>()?;
    m.add_class::<AzSvgVector>()?;
    m.add_class::<AzSvgLine>()?;
    m.add_class::<AzSvgQuadraticCurve>()?;
    m.add_class::<AzSvgCubicCurve>()?;
    m.add_class::<AzSvgRect>()?;
    m.add_class::<AzTessellatedSvgNode>()?;
    m.add_class::<AzSvgDashPattern>()?;
    m.add_class::<AzSvgFitToEnumWrapper>()?;
    m.add_class::<AzSvgFillRuleEnumWrapper>()?;
    m.add_class::<AzSvgStrokeStyle>()?;
    m.add_class::<AzSvgLineJoinEnumWrapper>()?;
    m.add_class::<AzSvgLineCapEnumWrapper>()?;
    m.add_class::<AzCssPathPseudoSelectorEnumWrapper>()?;
    m.add_class::<AzLogicalRect>()?;
    m.add_class::<AzCssPathSelectorEnumWrapper>()?;
    m.add_class::<AzCssPath>()?;
    m.add_class::<AzTessellatedGPUSvgNode>()?;
    m.add_class::<AzTessellatedColoredGPUSvgNode>()?;
    m.add_class::<AzShapeCircle>()?;
    m.add_class::<AzShapePolygon>()?;

    m.add_class::<AzXml>()?;

    m.add_class::<AzInstantEnumWrapper>()?;
    m.add_class::<AzSystemTickDiff>()?;
    m.add_class::<AzSystemTick>()?;
    m.add_class::<AzDurationEnumWrapper>()?;
    m.add_class::<AzSystemTimeDiff>()?;
    m.add_class::<AzTimerId>()?;
    m.add_class::<AzInstantPtr>()?;
    m.add_class::<AzCssDuration>()?;

    m.add_class::<AzString>()?;
    m.add_class::<AzRefstr>()?;
    m.add_class::<AzStringPair>()?;
    m.add_class::<AzStringSet>()?;

    m.add_class::<AzListViewRowVec>()?;
    m.add_class::<AzStyleFilterVec>()?;
    m.add_class::<AzAccessibilityStateVec>()?;
    m.add_class::<AzMenuItemVec>()?;
    m.add_class::<AzStyleFontFamilyVec>()?;
    m.add_class::<AzDomVec>()?;
    m.add_class::<AzIdOrClassVec>()?;
    m.add_class::<AzNodeDataInlineCssPropertyVec>()?;
    m.add_class::<AzStyleBackgroundContentVec>()?;
    m.add_class::<AzStyleBackgroundPositionVec>()?;
    m.add_class::<AzStyleBackgroundRepeatVec>()?;
    m.add_class::<AzStyleBackgroundSizeVec>()?;
    m.add_class::<AzStyleTransformVec>()?;
    m.add_class::<AzSvgMultiPolygonVec>()?;
    m.add_class::<AzSvgSimpleNodeVec>()?;
    m.add_class::<AzSvgPathVec>()?;
    m.add_class::<AzSvgPathElementVec>()?;
    m.add_class::<AzSvgVertexVec>()?;
    m.add_class::<AzU32Vec>()?;
    m.add_class::<AzVirtualKeyCodeVec>()?;
    m.add_class::<AzCascadeInfoVec>()?;
    m.add_class::<AzCssDeclarationVec>()?;
    m.add_class::<AzCssPathSelectorVec>()?;
    m.add_class::<AzStylesheetVec>()?;
    m.add_class::<AzCssRuleBlockVec>()?;
    m.add_class::<AzU16Vec>()?;
    m.add_class::<AzF32Vec>()?;
    m.add_class::<AzU8Vec>()?;
    m.add_class::<AzGLuintVec>()?;
    m.add_class::<AzGLintVec>()?;
    m.add_class::<AzStringVec>()?;
    m.add_class::<AzStringPairVec>()?;
    m.add_class::<AzNormalizedLinearColorStopVec>()?;
    m.add_class::<AzNormalizedRadialColorStopVec>()?;
    m.add_class::<AzNodeIdVec>()?;
    m.add_class::<AzNodeHierarchyItemVec>()?;
    m.add_class::<AzStyledNodeVec>()?;
    m.add_class::<AzTagIdToNodeIdMappingVec>()?;
    m.add_class::<AzParentWithNodeDepthVec>()?;
    m.add_class::<AzNodeDataVec>()?;
    m.add_class::<AzAttributeVec>()?;
    m.add_class::<AzCoreCallbackDataVec>()?;
    m.add_class::<AzAccessibilityActionVec>()?;
    m.add_class::<AzXmlNodeChildVec>()?;
    m.add_class::<AzGridTrackSizingVec>()?;
    m.add_class::<AzGLbooleanVecRefMut>()?;
    m.add_class::<AzRefstrVecRef>()?;
    m.add_class::<AzGLfloatVecRefMut>()?;
    m.add_class::<AzU8VecRefMut>()?;
    m.add_class::<AzTessellatedSvgNodeVecRef>()?;
    m.add_class::<AzF32VecRef>()?;
    m.add_class::<AzGLuintVecRef>()?;
    m.add_class::<AzI32VecRef>()?;
    m.add_class::<AzU8VecRef>()?;
    m.add_class::<AzGLintVecRefMut>()?;
    m.add_class::<AzGLenumVecRef>()?;
    m.add_class::<AzGLint64VecRefMut>()?;
    m.add_class::<AzOptionU8VecRefEnumWrapper>()?;
    m.add_class::<AzSvgPathVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleFilterVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleTransformVecDestructorEnumWrapper>()?;
    m.add_class::<AzGLuintVecDestructorEnumWrapper>()?;
    m.add_class::<AzXmlNodeChildVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundContentVecDestructorEnumWrapper>()?;
    m.add_class::<AzCascadeInfoVecDestructorEnumWrapper>()?;
    m.add_class::<AzAccessibilityStateVecDestructorEnumWrapper>()?;
    m.add_class::<AzDomVecDestructorEnumWrapper>()?;
    m.add_class::<AzStringVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeDataVecDestructorEnumWrapper>()?;
    m.add_class::<AzMenuItemVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgMultiPolygonVecDestructorEnumWrapper>()?;
    m.add_class::<AzListViewRowVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgVertexVecDestructorEnumWrapper>()?;
    m.add_class::<AzStylesheetVecDestructorEnumWrapper>()?;
    m.add_class::<AzU32VecDestructorEnumWrapper>()?;
    m.add_class::<AzCssRuleBlockVecDestructorEnumWrapper>()?;
    m.add_class::<AzNormalizedLinearColorStopVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleFontFamilyVecDestructorEnumWrapper>()?;
    m.add_class::<AzCssPathSelectorVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeHierarchyItemVecDestructorEnumWrapper>()?;
    m.add_class::<AzVirtualKeyCodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzF32VecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundRepeatVecDestructorEnumWrapper>()?;
    m.add_class::<AzAccessibilityActionVecDestructorEnumWrapper>()?;
    m.add_class::<AzU16VecDestructorEnumWrapper>()?;
    m.add_class::<AzTagIdToNodeIdMappingVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeIdVecDestructorEnumWrapper>()?;
    m.add_class::<AzParentWithNodeDepthVecDestructorEnumWrapper>()?;
    m.add_class::<AzGLintVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeDataInlineCssPropertyVecDestructorEnumWrapper>()?;
    m.add_class::<AzNormalizedRadialColorStopVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyledNodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundPositionVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgSimpleNodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzAttributeVecDestructorEnumWrapper>()?;
    m.add_class::<AzCssDeclarationVecDestructorEnumWrapper>()?;
    m.add_class::<AzIdOrClassVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundSizeVecDestructorEnumWrapper>()?;
    m.add_class::<AzStringPairVecDestructorEnumWrapper>()?;
    m.add_class::<AzCoreCallbackDataVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgPathElementVecDestructorEnumWrapper>()?;
    m.add_class::<AzU8VecDestructorEnumWrapper>()?;
    m.add_class::<AzGridTrackSizingVecDestructorEnumWrapper>()?;
    m.add_class::<AzVertexAttributeVecDestructorEnumWrapper>()?;
    m.add_class::<AzVertexAttributeVec>()?;
    m.add_class::<AzDebugMessageVecDestructorEnumWrapper>()?;
    m.add_class::<AzDebugMessageVec>()?;
    m.add_class::<AzShapePointVecDestructorEnumWrapper>()?;
    m.add_class::<AzShapePointVec>()?;
    m.add_class::<AzMonitorVec>()?;
    m.add_class::<AzVideoModeVec>()?;
    m.add_class::<AzXWindowTypeVec>()?;
    m.add_class::<AzXWindowTypeVecDestructorEnumWrapper>()?;
    m.add_class::<AzMonitorVecDestructorEnumWrapper>()?;
    m.add_class::<AzVideoModeVecDestructorEnumWrapper>()?;
    m.add_class::<AzScanCodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzScanCodeVec>()?;

    m.add_class::<AzOptionSvgPointEnumWrapper>()?;
    m.add_class::<AzOptionListViewOnRowClickEnumWrapper>()?;
    m.add_class::<AzOptionListViewOnColumnClickEnumWrapper>()?;
    m.add_class::<AzOptionListViewOnLazyLoadScrollEnumWrapper>()?;
    m.add_class::<AzOptionMenuEnumWrapper>()?;
    m.add_class::<AzOptionPixelValueNoPercentEnumWrapper>()?;
    m.add_class::<AzOptionColorInputOnValueChangeEnumWrapper>()?;
    m.add_class::<AzOptionButtonOnClickEnumWrapper>()?;
    m.add_class::<AzOptionTabOnClickEnumWrapper>()?;
    m.add_class::<AzOptionFileInputOnPathChangeEnumWrapper>()?;
    m.add_class::<AzOptionCheckBoxOnToggleEnumWrapper>()?;
    m.add_class::<AzOptionTextInputOnTextInputEnumWrapper>()?;
    m.add_class::<AzOptionTextInputOnVirtualKeyDownEnumWrapper>()?;
    m.add_class::<AzOptionTextInputOnFocusLostEnumWrapper>()?;
    m.add_class::<AzOptionTextInputSelectionEnumWrapper>()?;
    m.add_class::<AzOptionNumberInputOnFocusLostEnumWrapper>()?;
    m.add_class::<AzOptionNumberInputOnValueChangeEnumWrapper>()?;
    m.add_class::<AzOptionMenuItemIconEnumWrapper>()?;
    m.add_class::<AzOptionVirtualKeyCodeComboEnumWrapper>()?;
    m.add_class::<AzOptionTimerIdEnumWrapper>()?;
    m.add_class::<AzOptionI16EnumWrapper>()?;
    m.add_class::<AzOptionU16EnumWrapper>()?;
    m.add_class::<AzOptionU32EnumWrapper>()?;
    m.add_class::<AzOptionImageRefEnumWrapper>()?;
    m.add_class::<AzOptionFontRefEnumWrapper>()?;
    m.add_class::<AzOptionRefAnyEnumWrapper>()?;
    m.add_class::<AzOptionLayoutSizeEnumWrapper>()?;
    m.add_class::<AzOptionDomNodeIdEnumWrapper>()?;
    m.add_class::<AzOptionColorUEnumWrapper>()?;
    m.add_class::<AzOptionRawImageEnumWrapper>()?;
    m.add_class::<AzOptionSvgDashPatternEnumWrapper>()?;
    m.add_class::<AzOptionTabIndexEnumWrapper>()?;
    m.add_class::<AzOptionTagIdEnumWrapper>()?;
    m.add_class::<AzOptionDurationEnumWrapper>()?;
    m.add_class::<AzOptionUsizeEnumWrapper>()?;
    m.add_class::<AzOptionCoreMenuCallbackEnumWrapper>()?;
    m.add_class::<AzOptionStyledDomEnumWrapper>()?;
    m.add_class::<AzSvgParseOptions>()?;
    m.add_class::<AzSvgXmlOptions>()?;
    m.add_class::<AzSvgRenderOptions>()?;
    m.add_class::<AzOptionLogicalPositionEnumWrapper>()?;
    m.add_class::<AzOptionStringEnumWrapper>()?;
    m.add_class::<AzOptionF32EnumWrapper>()?;
    m.add_class::<AzOptionWaylandThemeEnumWrapper>()?;
    m.add_class::<AzOptionMouseCursorTypeEnumWrapper>()?;
    m.add_class::<AzOptionWindowIconEnumWrapper>()?;
    m.add_class::<AzOptionCallbackEnumWrapper>()?;
    m.add_class::<AzOptionTaskBarIconEnumWrapper>()?;
    m.add_class::<AzOptionHwndHandleEnumWrapper>()?;
    m.add_class::<AzOptionLinuxDecorationsStateEnumWrapper>()?;
    m.add_class::<AzOptionI32EnumWrapper>()?;
    m.add_class::<AzOptionLogicalSizeEnumWrapper>()?;
    m.add_class::<AzOptionVirtualKeyCodeEnumWrapper>()?;
    m.add_class::<AzOptionX11VisualEnumWrapper>()?;
    m.add_class::<AzRendererOptions>()?;
    m.add_class::<AzOptionRendererOptionsEnumWrapper>()?;
    m.add_class::<AzOptionWindowThemeEnumWrapper>()?;

    m.add_class::<AzResultXmlXmlErrorEnumWrapper>()?;
    m.add_class::<AzResultSvgSvgParseErrorEnumWrapper>()?;
    m.add_class::<AzSvgParseErrorEnumWrapper>()?;
    m.add_class::<AzXmlErrorEnumWrapper>()?;
    m.add_class::<AzDuplicatedNamespaceError>()?;
    m.add_class::<AzUnknownNamespaceError>()?;
    m.add_class::<AzUnexpectedCloseTagError>()?;
    m.add_class::<AzUnknownEntityReferenceError>()?;
    m.add_class::<AzDuplicatedAttributeError>()?;
    m.add_class::<AzXmlParseErrorEnumWrapper>()?;
    m.add_class::<AzXmlTextError>()?;
    m.add_class::<AzXmlStreamErrorEnumWrapper>()?;
    m.add_class::<AzNonXmlCharError>()?;
    m.add_class::<AzInvalidCharError>()?;
    m.add_class::<AzInvalidCharMultipleError>()?;
    m.add_class::<AzInvalidQuoteError>()?;
    m.add_class::<AzInvalidSpaceError>()?;
    m.add_class::<AzInvalidStringError>()?;
    m.add_class::<AzMalformedHierarchyError>()?;
    m.add_class::<AzEncodeImageErrorEnumWrapper>()?;
    m.add_class::<AzResultRawImageDecodeImageErrorEnumWrapper>()?;
    m.add_class::<AzDecodeImageErrorEnumWrapper>()?;
    m.add_class::<AzResultU8VecEncodeImageErrorEnumWrapper>()?;

    m.add_class::<AzCascadeInfo>()?;
    m.add_class::<AzRendererTypeEnumWrapper>()?;
    m.add_class::<AzExtendModeEnumWrapper>()?;
    m.add_class::<AzFlowIntoEnumWrapper>()?;
    m.add_class::<AzVirtualKeyCodeEnumWrapper>()?;
    m.add_class::<AzVirtualKeyCodeCombo>()?;
    m.add_class::<AzIdOrClassEnumWrapper>()?;
    m.add_class::<AzInterpolateResolver>()?;
    m.add_class::<AzFlowFromEnumWrapper>()?;
    m.add_class::<AzRefCount>()?;
    m.add_class::<AzUpdateEnumWrapper>()?;
    m.add_class::<AzRefAny>()?;
    m.add_class::<AzEdgeTypeEnumWrapper>()?;
    m.add_class::<AzDebugMessage>()?;

    m.add_class::<AzAppConfig>()?;
    m.add_class::<AzApp>()?;
    m.add_class::<AzAppTerminationBehaviorEnumWrapper>()?;
    m.add_class::<AzAppLogLevelEnumWrapper>()?;

    Ok(())
}
