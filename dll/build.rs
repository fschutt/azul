use std::{env, fs, path::Path, process::Command};

fn main() {
    // Check for required generated files before compilation
    check_generated_files();

    // Configure dynamic linking when link-dynamic feature is enabled
    // Uses AZUL_LINK_PATH environment variable to find libazul
    // Note: In build.rs, we check features via CARGO_FEATURE_* env vars
    if env::var("CARGO_FEATURE_LINK_DYNAMIC").is_ok() {
        if let Ok(link_path) = env::var("AZUL_LINK_PATH") {
            println!("cargo:rustc-link-search=native={}", link_path);
            println!("cargo:rerun-if-env-changed=AZUL_LINK_PATH");
        } else {
            // Try some default paths
            let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
            let target_release = Path::new(&manifest_dir).join("../target/release");
            let target_debug = Path::new(&manifest_dir).join("../target/debug");

            if target_release.exists() {
                println!(
                    "cargo:rustc-link-search=native={}",
                    target_release.display()
                );
            } else if target_debug.exists() {
                println!("cargo:rustc-link-search=native={}", target_debug.display());
            } else {
                println!(
                    "cargo:warning=AZUL_LINK_PATH not set and no default libazul location found."
                );
                println!("cargo:warning=Set AZUL_LINK_PATH to the directory containing libazul.dylib/so/dll");
            }
        }
        println!("cargo:rustc-link-lib=dylib=azul");
    }

    // Configure Python extension linking on macOS
    // With extension-module, PyO3 expects Python symbols to be provided by the interpreter
    // On macOS, we need to tell the linker that undefined symbols are OK
    #[cfg(target_os = "macos")]
    {
        if env::var("CARGO_FEATURE_PYO3").is_ok() {
            println!("cargo:rustc-cdylib-link-arg=-undefined");
            println!("cargo:rustc-cdylib-link-arg=dynamic_lookup");
        }
    }

    // This build script only runs its logic when targeting iOS.
    let target = env::var("TARGET").unwrap_or_default();
    if !target.contains("ios") {
        return;
    }

    // Allow users to opt-out of the automatic configuration.
    if env::var("AZUL_IOS_SETUP").unwrap_or_default() == "disable" {
        println!(
            "cargo:warning=AZUL_IOS_SETUP is disabled. Skipping automatic iOS project \
             configuration."
        );
        return;
    }

    // --- Prerequisite Checks ---
    check_xcode_cli_tools();
    check_ios_deploy();

    // --- Automatic Project Configuration ---
    // This part modifies the user's project to set up the Cargo runner.
    // We assume the CWD for the build script is the user's project root.
    let project_root = env::var("CARGO_MANIFEST_DIR").unwrap();
    println!(
        "cargo:warning=Azul is automatically configuring '{}' for iOS builds.",
        project_root
    );

    // Create .cargo/config.toml
    let cargo_dir = Path::new(&project_root).join(".cargo");
    fs::create_dir_all(&cargo_dir).unwrap();
    let config_path = cargo_dir.join("config.toml");
    let config_content = format!(
        r#"[target.aarch64-apple-ios]
runner = "scripts/ios-runner.sh"
"#
    );
    // Only write the file if it doesn't exist or doesn't have our runner.
    if !fs::read_to_string(&config_path)
        .unwrap_or_default()
        .contains("ios-runner.sh")
    {
        fs::write(config_path, config_content).unwrap();
        println!("cargo:warning=Created/updated .cargo/config.toml with iOS runner.");
    }

    // Create the runner script
    let scripts_dir = Path::new(&project_root).join("scripts");
    fs::create_dir_all(&scripts_dir).unwrap();
    let runner_path = scripts_dir.join("ios-runner.sh");
    let runner_content = r#"#!/bin/bash
# This script is auto-generated by Azul's build system.
set -e

# Cargo passes the path to the executable as the first argument.
EXECUTABLE_PATH="$1"
# We derive the .app bundle path from it (it's created by the user's build script).
APP_NAME=$(basename "$EXECUTABLE_PATH")
APP_BUNDLE_PATH="$(dirname "$EXECUTABLE_PATH")/${APP_NAME}.app"

echo "Deploying and launching ${APP_BUNDLE_PATH} on attached iOS device..."

# Use ios-deploy to install and launch the app.
# The --justlaunch flag tells it not to attach a debugger.
ios-deploy --bundle "${APP_BUNDLE_PATH}" --justlaunch
"#;
    fs::write(&runner_path, runner_content).unwrap();
    // Make the script executable.
    Command::new("chmod")
        .arg("+x")
        .arg(&runner_path)
        .status()
        .unwrap();

    println!("cargo:warning=Created scripts/ios-runner.sh for deploying to device.");
}

/// Checks if Xcode Command Line Tools are installed.
fn check_xcode_cli_tools() {
    let status = Command::new("xcode-select").arg("-p").status();
    match status {
        Ok(s) if s.success() => { /* All good */ }
        _ => {
            panic!(
                "Xcode Command Line Tools not found. Please run 'xcode-select --install' in your \
                 terminal."
            );
        }
    }
}

/// Checks if ios-deploy is installed.
fn check_ios_deploy() {
    let status = Command::new("ios-deploy").arg("--version").status();
    match status {
        Ok(s) if s.success() => { /* All good */ }
        _ => {
            panic!(
                "'ios-deploy' not found. Please install it by running 'brew install ios-deploy'."
            );
        }
    }
}

/// Checks for required generated files based on enabled features.
/// Provides helpful error messages directing users to run the correct codegen command.
fn check_generated_files() {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let workspace_root = Path::new(&manifest_dir).parent().unwrap();
    let codegen_v2_dir = workspace_root.join("target/codegen/v2");

    // Check for build-dll feature (needs dll_api_build.rs)
    if env::var("CARGO_FEATURE_BUILD_DLL").is_ok() {
        let dll_api_build_path = codegen_v2_dir.join("dll_api_build.rs");
        if !dll_api_build_path.exists() {
            panic!(
                "\n\
                ╔══════════════════════════════════════════════════════════════════════════════╗\n\
                ║                 MISSING GENERATED FILE: dll_api_build.rs                     ║\n\
                ╠══════════════════════════════════════════════════════════════════════════════╣\n\
                ║ The build-dll feature requires generated bindings that don't exist yet.     ║\n\
                ║                                                                              ║\n\
                ║ To generate all bindings, run:                                               ║\n\
                ║                                                                              ║\n\
                ║   cd doc && cargo run --release -- codegen all                               ║\n\
                ║                                                                              ║\n\
                ║ Expected file: target/codegen/v2/dll_api_build.rs                            ║\n\
                ╚══════════════════════════════════════════════════════════════════════════════╝\n"
            );
        }
        println!("cargo:rerun-if-changed={}", dll_api_build_path.display());
    }

    // Check for link-static feature (needs dll_api_static.rs)
    if env::var("CARGO_FEATURE_LINK_STATIC").is_ok() {
        let dll_api_static_path = codegen_v2_dir.join("dll_api_static.rs");
        if !dll_api_static_path.exists() {
            panic!(
                "\n\
                ╔══════════════════════════════════════════════════════════════════════════════╗\n\
                ║                 MISSING GENERATED FILE: dll_api_static.rs                    ║\n\
                ╠══════════════════════════════════════════════════════════════════════════════╣\n\
                ║ The link-static feature requires generated bindings that don't exist yet.   ║\n\
                ║                                                                              ║\n\
                ║ To generate all bindings, run:                                               ║\n\
                ║                                                                              ║\n\
                ║   cd doc && cargo run --release -- codegen all                               ║\n\
                ║                                                                              ║\n\
                ║ Expected file: target/codegen/v2/dll_api_static.rs                           ║\n\
                ╚══════════════════════════════════════════════════════════════════════════════╝\n"
            );
        }
        println!("cargo:rerun-if-changed={}", dll_api_static_path.display());
    }

    // Check for link-dynamic feature (needs dll_api_dynamic.rs)
    if env::var("CARGO_FEATURE_LINK_DYNAMIC").is_ok() {
        let dll_api_dynamic_path = codegen_v2_dir.join("dll_api_dynamic.rs");
        if !dll_api_dynamic_path.exists() {
            panic!(
                "\n\
                ╔══════════════════════════════════════════════════════════════════════════════╗\n\
                ║                MISSING GENERATED FILE: dll_api_dynamic.rs                    ║\n\
                ╠══════════════════════════════════════════════════════════════════════════════╣\n\
                ║ The link-dynamic feature requires generated bindings that don't exist yet.  ║\n\
                ║                                                                              ║\n\
                ║ To generate all bindings, run:                                               ║\n\
                ║                                                                              ║\n\
                ║   cd doc && cargo run --release -- codegen all                               ║\n\
                ║                                                                              ║\n\
                ║ Expected file: target/codegen/v2/dll_api_dynamic.rs                          ║\n\
                ╚══════════════════════════════════════════════════════════════════════════════╝\n"
            );
        }
        println!("cargo:rerun-if-changed={}", dll_api_dynamic_path.display());
    }

    // Check for reexports.rs (needed by any link mode)
    if env::var("CARGO_FEATURE_LINK_STATIC").is_ok()
        || env::var("CARGO_FEATURE_LINK_DYNAMIC").is_ok()
        || env::var("CARGO_FEATURE_BUILD_DLL").is_ok()
    {
        let reexports_path = codegen_v2_dir.join("reexports.rs");
        if !reexports_path.exists() {
            panic!(
                "\n\
                ╔══════════════════════════════════════════════════════════════════════════════╗\n\
                ║                   MISSING GENERATED FILE: reexports.rs                       ║\n\
                ╠══════════════════════════════════════════════════════════════════════════════╣\n\
                ║ The public Rust API requires generated re-exports that don't exist yet.     ║\n\
                ║                                                                              ║\n\
                ║ To generate all bindings, run:                                               ║\n\
                ║                                                                              ║\n\
                ║   cd doc && cargo run --release -- codegen all                               ║\n\
                ║                                                                              ║\n\
                ║ Expected file: target/codegen/v2/reexports.rs                                ║\n\
                ╚══════════════════════════════════════════════════════════════════════════════╝\n"
            );
        }
        println!("cargo:rerun-if-changed={}", reexports_path.display());
    }

    // Check for python-extension feature
    if env::var("CARGO_FEATURE_PYTHON_EXTENSION").is_ok() {
        let python_api_path = codegen_v2_dir.join("python_api.rs");
        if !python_api_path.exists() {
            panic!(
                "\n\
                ╔══════════════════════════════════════════════════════════════════════════════╗\n\
                ║                   MISSING GENERATED FILE: python_api.rs                      ║\n\
                ╠══════════════════════════════════════════════════════════════════════════════╣\n\
                ║ The Python extension requires generated bindings that don't exist yet.      ║\n\
                ║                                                                              ║\n\
                ║ To generate all bindings, run:                                               ║\n\
                ║                                                                              ║\n\
                ║   cd doc && cargo run --release -- codegen all                               ║\n\
                ║                                                                              ║\n\
                ║ Expected file: target/codegen/v2/python_api.rs                               ║\n\
                ╚══════════════════════════════════════════════════════════════════════════════╝\n"
            );
        }
        println!("cargo:rerun-if-changed={}", python_api_path.display());
    }

    // Always rerun if api.json changes (the source of truth)
    let api_json_path = workspace_root.join("api.json");
    if api_json_path.exists() {
        println!("cargo:rerun-if-changed={}", api_json_path.display());
    }
}
