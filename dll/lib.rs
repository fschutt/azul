//! WARNING: autogenerated code for azul api version 1.0.0-alpha1

#![deny(improper_ctypes_definitions)]

// Header would be included here from _patches/dll/header.rs

pub mod widgets;
#[cfg(all(feature = "python-extension", feature = "link-dynamic", not(feature = "link-static")))]
pub mod python;


/// Version of the layout solver to use - future binary versions of azul may have more fields here, necessary so that old compiled applications don't break with newer releases of azul. Newer layout versions are opt-in only.
#[repr(C)] pub struct AzLayoutSolverVersion { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Configuration for optional features, such as whether to enable logging or panic hooks
#[repr(C)] pub struct AzAppConfig { pub ptr: *mut c_void }
/// Constructs a default `AppConfig`, uses the layout solver currently available
#[no_mangle] pub extern "C" fn AzAppConfig_new (layout_solver: AzLayoutSolverVersion) -> AzAppConfig { let object: AppConfig = AzAppConfig::new(layout_solver); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzAppConfig { ptr } }
/* Error: Type is not stack allocated! */

/// Configuration to set which messages should be logged.
#[repr(C)] pub struct AzAppLogLevel { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Main application class
pub use azul_dll::desktop::app::AzAppPtr as AzAzAppPtrTT;
pub use AzAzAppPtrTT as AzAzAppPtr;
/// Creates a new App instance from the given `AppConfig`
#[no_mangle] pub extern "C" fn AzAzAppPtr_new (data: AzRefAny, config: AzAppConfig) -> AzAzAppPtr { let object: AzAppPtr = crate::azul_impl::app::AzAppPtr::new(data, config); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzAzAppPtr { ptr } }
/// Spawn a new window on the screen when the app is run.
#[no_mangle] pub extern "C" fn AzAzAppPtr_addWindow (azappptr: &mut AzAzAppPtr, window: AzWindowCreateOptions){ app.add_window(window) }
/// Adds a new image identified by an ID to the image cache
#[no_mangle] pub extern "C" fn AzAzAppPtr_addImage (azappptr: &mut AzAzAppPtr, id: AzAzString, image: AzImageRef){ app.add_image(id, image) }
/// Returns a list of monitors - useful for setting the monitor that a window should spawn on.
#[no_mangle] pub extern "C" fn AzAzAppPtr_getMonitors (azappptr: &AzAzAppPtr) -> AzMonitorVec{ app.get_monitors() }
/// Runs the application. Due to platform restrictions (specifically `WinMain` on Windows), this function never returns.
#[no_mangle] pub extern "C" fn AzAzAppPtr_run (azappptr: &AzAzAppPtr, window: AzWindowCreateOptions){ app.run(window) }
/* Error: Type is not stack allocated! */

/// External system callbacks to get the system time or create / manage threads
#[repr(C)] pub struct AzExternalSystemCallbacks { pub ptr: *mut c_void }
/// Use the default, library-internal callbacks instead of providing your own
#[no_mangle] pub extern "C" fn AzExternalSystemCallbacks_libraryInternal () -> AzExternalSystemCallbacks { let object: ExternalSystemCallbacks = AzSystemCallbacks::rust_internal(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzExternalSystemCallbacks { ptr } }
/* Error: Type is not stack allocated! */

/// Options on how to initially create the window
#[repr(C)] pub struct AzWindowCreateOptions { pub ptr: *mut c_void }
/// Creates a new window configuration with a custom layout callback
#[no_mangle] pub extern "C" fn AzWindowCreateOptions_new (layout_callback: AzLayoutCallbackType) -> AzWindowCreateOptions { let object: WindowCreateOptions = AzWindowCreateOptions::new(layout_callback); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzWindowCreateOptions { ptr } }
/* Error: Type is not stack allocated! */

/// Force a specific renderer: note that azul will **crash** on startup if the `RendererOptions` are not satisfied.
#[repr(C)] pub struct AzRendererOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Whether the renderer has VSync enabled
#[repr(C)] pub struct AzVsync { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Does the renderer render in SRGB color space? By default, azul tries to set it to `Enabled` and falls back to `Disabled` if the OpenGL context can't be initialized properly
#[repr(C)] pub struct AzSrgb { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Does the renderer render using hardware acceleration? By default, azul tries to set it to `Enabled` and falls back to `Disabled` if the OpenGL context can't be initialized properly
#[repr(C)] pub struct AzHwAcceleration { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Offset in physical pixels (integer units)
#[repr(C)] pub struct AzLayoutPoint { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Size in physical pixels (integer units)
#[repr(C)] pub struct AzLayoutSize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a rectangle in physical pixels (integer units)
#[repr(C)] pub struct AzLayoutRect { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Raw platform handle, for integration in / with other toolkits and custom non-azul window extensions
#[repr(C)] pub struct AzRawWindowHandle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<IOSHandle>` struct
#[repr(C)] pub struct AzIOSHandle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<MacOSHandle>` struct
#[repr(C)] pub struct AzMacOSHandle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<XlibHandle>` struct
#[repr(C)] pub struct AzXlibHandle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<XcbHandle>` struct
#[repr(C)] pub struct AzXcbHandle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WaylandHandle>` struct
#[repr(C)] pub struct AzWaylandHandle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WindowsHandle>` struct
#[repr(C)] pub struct AzWindowsHandle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WebHandle>` struct
#[repr(C)] pub struct AzWebHandle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AndroidHandle>` struct
#[repr(C)] pub struct AzAndroidHandle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// X window type. Maps directly to [`_NET_WM_WINDOW_TYPE`](https://specifications.freedesktop.org/wm-spec/wm-spec-1.5.html).
#[repr(C)] pub struct AzXWindowType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Same as `LayoutPoint`, but uses `i32` instead of `isize`
#[repr(C)] pub struct AzPhysicalPositionI32 { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Same as `LayoutPoint`, but uses `u32` instead of `isize`
#[repr(C)] pub struct AzPhysicalSizeU32 { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Logical rectangle area (can differ based on HiDPI settings). Usually this is what you'd want for hit-testing and positioning elements.
#[repr(C)] pub struct AzLogicalRect { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Logical position (can differ based on HiDPI settings). Usually this is what you'd want for hit-testing and positioning elements.
#[repr(C)] pub struct AzLogicalPosition { pub ptr: *mut c_void }
/// Creates a new `LogicalPosition` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `LogicalPosition::new()` constructor.
#[no_mangle] pub extern "C" fn AzLogicalPosition_new (x: f32, y: f32) -> AzLogicalPosition { let object: LogicalPosition = AzLogicalPosition::new(x, y); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzLogicalPosition { ptr } }
/// Creates a new `LogicalPosition` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `LogicalPosition::zero()` constructor.
#[no_mangle] pub extern "C" fn AzLogicalPosition_zero () -> AzLogicalPosition { let object: LogicalPosition = AzLogicalPosition::zero(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzLogicalPosition { ptr } }
/* Error: Type is not stack allocated! */

/// A size in "logical" (non-HiDPI-adjusted) pixels in floating-point units
#[repr(C)] pub struct AzLogicalSize { pub ptr: *mut c_void }
/// Equivalent to the Rust `LogicalSize::to_physical()` function.
#[no_mangle] pub extern "C" fn AzLogicalSize_toPhysical (logicalsize: &AzLogicalSize, hidpi_factor: f32) -> AzPhysicalSizeU32{ logicalsize.to_physical(hidpi_factor) }
/* Error: Type is not stack allocated! */

/// Unique hash of a window icon, so that azul does not have to compare the actual bytes to see wether the window icon has changed.
#[repr(C)] pub struct AzIconKey { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// 16x16x4 bytes icon
#[repr(C)] pub struct AzSmallWindowIconBytes { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// 16x16x4 bytes icon
#[repr(C)] pub struct AzLargeWindowIconBytes { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Window "favicon", usually shown in the top left of the window on Windows
#[repr(C)] pub struct AzWindowIcon { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// 256x256x4 bytes window icon
#[repr(C)] pub struct AzTaskBarIcon { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Symbolic name for a keyboard key, does NOT take the keyboard locale into account
#[repr(C)] pub struct AzVirtualKeyCode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Utility function for easier creation of a keymap - i.e. `[vec![Ctrl, S], my_function]`
#[repr(C)] pub struct AzAcceleratorKey { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Minimum / maximum / current size of the window in logical dimensions
#[repr(C)] pub struct AzWindowSize { pub ptr: *mut c_void }
/// Returns the hidpi factor of the bounds
#[no_mangle] pub extern "C" fn AzWindowSize_getHidpiFactor (windowsize: &AzWindowSize) -> f32{ windowsize.get_hidpi_factor() }
/* Error: Type is not stack allocated! */

/// Boolean flags relating to the current window state
#[repr(C)] pub struct AzWindowFlags { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// State of the window frame (minimized, maximized, fullscreen or normal window)
#[repr(C)] pub struct AzWindowFrame { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Toggles webrender debug flags (will make stuff appear on the screen that you might not want to - used for debugging purposes)
#[repr(C)] pub struct AzDebugState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Determines which keys are pressed currently (modifiers, etc.)
#[repr(C)] pub struct AzKeyboardState { pub ptr: *mut c_void }
/// Returns if the `SHIFT` key is held down (left OR right shift)
#[no_mangle] pub extern "C" fn AzKeyboardState_shiftDown (keyboardstate: &AzKeyboardState) -> bool{ keyboardstate.shift_down() }
/// Returns if the `CTRL` key is held down
#[no_mangle] pub extern "C" fn AzKeyboardState_ctrlDown (keyboardstate: &AzKeyboardState) -> bool{ keyboardstate.ctrl_down() }
/// Returns if the `ALT` key is held down
#[no_mangle] pub extern "C" fn AzKeyboardState_altDown (keyboardstate: &AzKeyboardState) -> bool{ keyboardstate.alt_down() }
/// Returns if the `SUPER` ("Windows") key is held down
#[no_mangle] pub extern "C" fn AzKeyboardState_superDown (keyboardstate: &AzKeyboardState) -> bool{ keyboardstate.super_down() }
/// Returns if a key is held down
#[no_mangle] pub extern "C" fn AzKeyboardState_isKeyDown (keyboardstate: &AzKeyboardState, key: AzVirtualKeyCode) -> bool{ keyboardstate.is_key_down(key) }
/* Error: Type is not stack allocated! */

/// Current icon of the mouse cursor
#[repr(C)] pub struct AzMouseCursorType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Current position of the mouse cursor, relative to the window. Set to `Uninitialized` on startup (gets initialized on the first frame).
#[repr(C)] pub struct AzCursorPosition { pub ptr: *mut c_void }
/// Equivalent to the Rust `CursorPosition::get_position()` function.
#[no_mangle] pub extern "C" fn AzCursorPosition_getPosition (cursorposition: &AzCursorPosition) -> AzOptionLogicalPosition{ cursorposition.get_position().into() }
/* Error: Type is not stack allocated! */

/// Mouse position, cursor type, user scroll input, etc.
#[repr(C)] pub struct AzMouseState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Platform-specific window configuration, i.e. WM options that are not cross-platform
#[repr(C)] pub struct AzPlatformSpecificOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Window configuration specific to Win32
#[repr(C)] pub struct AzWindowsWindowOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// CSD theme of the window title / button controls
#[repr(C)] pub struct AzWaylandTheme { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Renderer type of the current windows OpenGL context
#[repr(C)] pub struct AzRendererType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WindowState>` struct
#[repr(C)] pub struct AzWindowState { pub ptr: *mut c_void }
/// Creates a new WindowState with default settings and a custom layout callback
#[no_mangle] pub extern "C" fn AzWindowState_new (layout_callback: AzLayoutCallbackType) -> AzWindowState { let object: WindowState = AzWindowState::new(layout_callback); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzWindowState { ptr } }
/// Creates a default WindowState with an empty layout callback - useful only if you use the Rust `WindowState { .. WindowState::default() }` intialization syntax.
#[no_mangle] pub extern "C" fn AzWindowState_default () -> AzWindowState { let object: WindowState = AzWindowState::default(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzWindowState { ptr } }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LinuxWindowOptions>` struct
#[repr(C)] pub struct AzLinuxWindowOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<MacWindowOptions>` struct
#[repr(C)] pub struct AzMacWindowOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WasmWindowOptions>` struct
#[repr(C)] pub struct AzWasmWindowOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FullScreenMode>` struct
#[repr(C)] pub struct AzFullScreenMode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// State, size, etc of the window, for comparing to the last frame
#[repr(C)] pub struct AzWindowTheme { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Position of the top left corner of the window relative to the top left of the monitor
#[repr(C)] pub struct AzWindowPosition { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// IME composition window rectangle (cursor position + height)
#[repr(C)] pub struct AzImePosition { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Current state of touch devices / touch inputs
#[repr(C)] pub struct AzTouchState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Complete information about a monitor/display
#[repr(C)] pub struct AzMonitor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Describes a rendering configuration for a monitor
#[repr(C)] pub struct AzVideoMode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AzStringPair>` struct
#[repr(C)] pub struct AzAzStringPair { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SystemCallbacks>` struct
#[repr(C)] pub struct AzSystemCallbacks { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<UserAttentionType>` struct
#[repr(C)] pub struct AzUserAttentionType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Window decoration style
#[repr(C)] pub struct AzWindowDecorations { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Compositor blur/transparency effects for window background
#[repr(C)] pub struct AzWindowBackgroundMaterial { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Identifies a specific monitor/display Contains both an index (for fast current-session lookup) and a stable hash (for persistence across app restarts and monitor reconfigurations). - `index`: Runtime index (0-based), may change if monitors are added/removed - `hash`: Stable identifier based on monitor properties (name, size, position) Applications can serialize `hash` to remember which monitor a window was on, then search for matching hash on next launch, falling back to index or PRIMARY.
#[repr(C)] pub struct AzMonitorId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Window type classification for behavior control
#[repr(C)] pub struct AzWindowType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutCallback>` struct
#[repr(C)] pub struct AzLayoutCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable wrapper over a `MarshaledLayoutCallback`
#[repr(C)] pub struct AzMarshaledLayoutCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable wrapper over a `MarshaledLayoutCallbackInner`
#[repr(C)] pub struct AzMarshaledLayoutCallbackInner { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// In order to interact with external VMs (Java, Python, etc.) the callback is often stored as a "function object" In order to callback into external languages, the layout callback has to be able to carry some extra data (the first argument), which usually contains the function object i.e. in the Python VM a PyCallable / PyAny
pub type AzMarshaledLayoutCallbackType = Azextern "C" fn (&mut RefAny , &mut RefAny , &mut LayoutCallbackInfo ,) -> StyledDom<>;

/// C-ABI stable wrapper over a `LayoutCallbackType`
#[repr(C)] pub struct AzLayoutCallbackInner { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Callback function pointer (has to be a function pointer in order to be compatible with C APIs later on). IMPORTANT: The callback needs to deallocate the `RefAnyPtr` and `LayoutCallbackInfoPtr`, otherwise that memory is leaked. If you use the official auto-generated bindings, this is already done for you. NOTE: The original callback was `fn(&self, LayoutCallbackInfo) -> Dom` which then evolved to `fn(&RefAny, LayoutCallbackInfo) -> Dom`. The indirection is necessary because of the memory management around the C API See azul-core/ui_state.rs:298 for how the memory is managed across the callback boundary.
pub type AzLayoutCallbackType = Azextern "C" fn (&mut RefAny , &mut LayoutCallbackInfo) -> StyledDom<>;

/// Stores a function pointer that is executed when the given UI element is hit Must return an `Update` that denotes if the screen should be redrawn.
#[repr(C)] pub struct AzCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Main callback type for UI event handling
pub type AzCallbackType = Azextern "C" fn (&mut RefAny , &mut CallbackInfo) -> Update<>;

/// Information about the callback that is passed to the callback whenever a callback is invoked
#[repr(C)] pub struct AzCallbackInfo { pub ptr: *mut c_void }
/// Returns the `DomNodeId` of the element that the callback was attached to.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getHitNode (callbackinfo: &AzCallbackInfo) -> AzDomNodeId{ callbackinfo.get_hit_node() }
/// Returns the function pointer necessary to query the current time.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getSystemTimeFn (callbackinfo: &AzCallbackInfo) -> AzGetSystemTimeCallback{ callbackinfo.get_system_time_fn() }
/// Returns the `LayoutPoint` of the cursor in the viewport (relative to the origin of the `Dom`). Set to `None` if the cursor is not in the current window.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getCursorRelativeToViewport (callbackinfo: &AzCallbackInfo) -> AzOptionLogicalPosition{ callbackinfo.get_cursor_relative_to_viewport() }
/// Returns the `LayoutPoint` of the cursor in the viewport (relative to the origin of the `Dom`). Set to `None` if the cursor is not hovering over the current node.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getCursorRelativeToNode (callbackinfo: &AzCallbackInfo) -> AzOptionLogicalPosition{ callbackinfo.get_cursor_relative_to_node() }
/// Returns a copy of the current windows `WindowState`.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getCurrentWindowState (callbackinfo: &AzCallbackInfo) -> AzWindowState{ callbackinfo.get_current_window_state() }
/// Returns a copy of the internal `KeyboardState`. Same as `self.get_window_state().keyboard_state`
#[no_mangle] pub extern "C" fn AzCallbackInfo_getCurrentKeyboardState (callbackinfo: &AzCallbackInfo) -> AzKeyboardState{ callbackinfo.get_current_keyboard_state() }
/// Returns a copy of the internal `MouseState`. Same as `self.get_window_state().mouse_state`
#[no_mangle] pub extern "C" fn AzCallbackInfo_getCurrentMouseState (callbackinfo: &AzCallbackInfo) -> AzMouseState{ callbackinfo.get_current_mouse_state() }
/// Returns a copy of the current windows `WindowState`.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getPreviousWindowState (callbackinfo: &AzCallbackInfo) -> AzOptionWindowState{ callbackinfo.get_previous_window_state().into() }
/// Returns a copy of the internal `KeyboardState`. Same as `self.get_window_state().keyboard_state`
#[no_mangle] pub extern "C" fn AzCallbackInfo_getPreviousKeyboardState (callbackinfo: &AzCallbackInfo) -> AzOptionKeyboardState{ callbackinfo.get_previous_keyboard_state().into() }
/// Returns a copy of the internal `MouseState`. Same as `self.get_window_state().mouse_state`
#[no_mangle] pub extern "C" fn AzCallbackInfo_getPreviousMouseState (callbackinfo: &AzCallbackInfo) -> AzOptionMouseState{ callbackinfo.get_previous_mouse_state().into() }
/// Returns a copy of the current windows `RawWindowHandle`.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getCurrentWindowHandle (callbackinfo: &AzCallbackInfo) -> AzRawWindowHandle{ callbackinfo.get_current_window_handle() }
/// Returns a **reference-counted copy** of the current windows' `Gl` (context). You can use this to render OpenGL textures.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getGlContext (callbackinfo: &AzCallbackInfo) -> AzOptionGlContextPtr{ callbackinfo.get_gl_context() }
/// Returns the x / y offset that this node has been scrolled to by the user or `None` if the node has not been scrolled.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getScrollPosition (callbackinfo: &AzCallbackInfo, node_id: AzDomNodeId) -> AzOptionLogicalPosition{ callbackinfo.get_scroll_position(node_id).into() }
/// Returns the `dataset` property of the given Node or `None` if the node doesn't have a `dataset` property.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getDataset (callbackinfo: &mut AzCallbackInfo, node_id: AzDomNodeId) -> AzOptionRefAny{ callbackinfo.get_dataset(node_id).into() }
/// Given a dataset, returns the node ID of the "root" `RefAny`, i.e. the `RefAny` with the lowest `instance` count that is set as a `dataset` on any node.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getNodeIdOfRootDataset (callbackinfo: &mut AzCallbackInfo, dataset: AzRefAny) -> AzOptionDomNodeId{ callbackinfo.get_node_id_of_root_dataset(dataset).into() }
/// If the node is a `Text` node, returns a copy of the internal string contents.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getStringContents (callbackinfo: &AzCallbackInfo, node_id: AzDomNodeId) -> AzOptionAzString{ callbackinfo.get_string_contents(node_id).into() }
/// If the node is a `Text` node, returns the layouted inline glyphs of the text currently rendered on the screen
#[no_mangle] pub extern "C" fn AzCallbackInfo_getInlineText (callbackinfo: &AzCallbackInfo, node_id: AzDomNodeId) -> AzOptionInlineText{ callbackinfo.get_inline_text(node_id).into() }
/// If the node is a `Text` node, returns the `FontRef` that was used to render this node. Useful for getting font metrics for a text string
#[no_mangle] pub extern "C" fn AzCallbackInfo_getFontRef (callbackinfo: &AzCallbackInfo, node_id: AzDomNodeId) -> AzOptionFontRef{ callbackinfo.get_font_ref(node_id).into() }
/// Equivalent to the Rust `CallbackInfo::get_text_layout_options()` function.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getTextLayoutOptions (callbackinfo: &AzCallbackInfo, node_id: AzDomNodeId) -> AzOptionResolvedTextLayoutOptions{ callbackinfo.get_text_layout_options(node_id).into() }
/// Similar to `get_inline_text()`: If the node is a `Text` node, shape the `text` string with the same parameters as the current text and return the calculated InlineTextLayout. Necessary to calculate text cursor offsets and to detect when a line overflows content.
#[no_mangle] pub extern "C" fn AzCallbackInfo_shapeText (callbackinfo: &AzCallbackInfo, node_id: AzDomNodeId, text: AzAzString) -> AzOptionInlineText{ azul_layout::callback_info_shape_text(callbackinfo, node_id, text).into() }
/// Returns the index of the node relative to the parent node.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getIndexInParent (callbackinfo: &mut AzCallbackInfo, node_id: AzDomNodeId) -> usize{ let mut t = 0; let mut n = node_id; while let Some(prev) = callbackinfo.get_previous_sibling(n) { n = prev; t += 1; } t }
/// Returns the parent `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getParent (callbackinfo: &mut AzCallbackInfo, node_id: AzDomNodeId) -> AzOptionDomNodeId{ callbackinfo.get_parent(node_id).into() }
/// Returns the previous siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getPreviousSibling (callbackinfo: &mut AzCallbackInfo, node_id: AzDomNodeId) -> AzOptionDomNodeId{ callbackinfo.get_previous_sibling(node_id).into() }
/// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getNextSibling (callbackinfo: &mut AzCallbackInfo, node_id: AzDomNodeId) -> AzOptionDomNodeId{ callbackinfo.get_next_sibling(node_id).into() }
/// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getFirstChild (callbackinfo: &mut AzCallbackInfo, node_id: AzDomNodeId) -> AzOptionDomNodeId{ callbackinfo.get_first_child(node_id).into() }
/// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
#[no_mangle] pub extern "C" fn AzCallbackInfo_getLastChild (callbackinfo: &mut AzCallbackInfo, node_id: AzDomNodeId) -> AzOptionDomNodeId{ callbackinfo.get_last_child(node_id).into() }
/// Returns the position of a given DOM node in the UI
#[no_mangle] pub extern "C" fn AzCallbackInfo_getNodePosition (callbackinfo: &mut AzCallbackInfo, node_id: AzDomNodeId) -> AzOptionPositionInfo{ callbackinfo.get_node_position(node_id).into() }
/// Returns the size of a given DOM node in the UI
#[no_mangle] pub extern "C" fn AzCallbackInfo_getNodeSize (callbackinfo: &mut AzCallbackInfo, node_id: AzDomNodeId) -> AzOptionLogicalSize{ callbackinfo.get_node_size(node_id).into() }
/// Returns the current computed CSS property of a given DOM node in the UI
#[no_mangle] pub extern "C" fn AzCallbackInfo_getComputedCssProperty (callbackinfo: &mut AzCallbackInfo, node_id: AzDomNodeId, property_type: AzCssPropertyType) -> AzOptionCssProperty{ callbackinfo.get_computed_css_property(node_id, property_type).into() }
/// Sets the new `WindowState` for the next frame. The window is updated after all callbacks are run.
#[no_mangle] pub extern "C" fn AzCallbackInfo_setWindowState (callbackinfo: &mut AzCallbackInfo, new_state: AzWindowState){ callbackinfo.set_window_state(new_state); }
/// Sets the new `FocusTarget` for the next frame. Note that this will emit a `On::FocusLost` and `On::FocusReceived` event, if the focused node has changed.
#[no_mangle] pub extern "C" fn AzCallbackInfo_setFocus (callbackinfo: &mut AzCallbackInfo, target: AzFocusTarget){ callbackinfo.set_focus(target); }
/// Sets a `CssProperty` on a given node to its new value. If this property change affects the layout, this will automatically trigger a relayout and redraw of the screen.
#[no_mangle] pub extern "C" fn AzCallbackInfo_setCssProperty (callbackinfo: &mut AzCallbackInfo, node_id: AzDomNodeId, new_property: AzCssProperty){ callbackinfo.set_css_property(node_id, new_property);  }
/// Sets the scroll position of the node
#[no_mangle] pub extern "C" fn AzCallbackInfo_setScrollPosition (callbackinfo: &mut AzCallbackInfo, node_id: AzDomNodeId, scroll_position: AzLogicalPosition){ callbackinfo.set_scroll_position(node_id, scroll_position) }
/// If the node is a `Text` node, overwrites the `Text` content with the new string, without requiring the entire UI to be rebuilt.
#[no_mangle] pub extern "C" fn AzCallbackInfo_setStringContents (callbackinfo: &mut AzCallbackInfo, node_id: AzDomNodeId, string: AzAzString){ callbackinfo.set_string_contents(node_id, string) }
/// Adds a new image identified by an ID to the image cache
#[no_mangle] pub extern "C" fn AzCallbackInfo_addImage (callbackinfo: &mut AzCallbackInfo, id: AzAzString, image: AzImageRef){ callbackinfo.add_image(id, image) }
/// Returns whether an image with a given CSS ID already exists
#[no_mangle] pub extern "C" fn AzCallbackInfo_hasImage (callbackinfo: &AzCallbackInfo, id: AzAzString) -> bool{ callbackinfo.has_image(&id) }
/// Returns the image with a given CSS ID
#[no_mangle] pub extern "C" fn AzCallbackInfo_getImage (callbackinfo: &AzCallbackInfo, id: AzAzString) -> AzOptionImageRef{ callbackinfo.get_image(&id).into() }
/// If the node is an `Image`, exchanges the current image with a new source
#[no_mangle] pub extern "C" fn AzCallbackInfo_updateImage (callbackinfo: &mut AzCallbackInfo, node_id: AzDomNodeId, new_image: AzImageRef, image_type: AzUpdateImageType){ callbackinfo.update_image(node_id, new_image, image_type) }
/// Deletes an image identified by a CSS ID from the image cache
#[no_mangle] pub extern "C" fn AzCallbackInfo_deleteImage (callbackinfo: &mut AzCallbackInfo, id: AzAzString){ callbackinfo.delete_image(&id) }
/// If the node has an `ImageMask`, exchanges the current mask for the new mask
#[no_mangle] pub extern "C" fn AzCallbackInfo_updateImageMask (callbackinfo: &mut AzCallbackInfo, node_id: AzDomNodeId, new_mask: AzImageMask){ callbackinfo.update_image_mask(node_id, new_mask) }
/// Stops the propagation of the current callback event type to the parent. Events are bubbled from the inside out (children first, then parents), this event stops the propagation of the event to the parent.
#[no_mangle] pub extern "C" fn AzCallbackInfo_stopPropagation (callbackinfo: &mut AzCallbackInfo){ callbackinfo.stop_propagation(); }
/// Spawns a new window with the given `WindowCreateOptions`.
#[no_mangle] pub extern "C" fn AzCallbackInfo_createWindow (callbackinfo: &mut AzCallbackInfo, new_window: AzWindowCreateOptions){ callbackinfo.create_window(new_window); }
/// Adds a new `Timer` to the runtime. See the documentation for `Timer` for more information.
#[no_mangle] pub extern "C" fn AzCallbackInfo_startTimer (callbackinfo: &mut AzCallbackInfo, timer: AzTimer) -> AzTimerId{ callbackinfo.start_timer(timer) }
/// Starts an animation timer on a give NodeId - same as a `Timer`, but uses a pre-configured interpolation function to drive the animation timer
#[no_mangle] pub extern "C" fn AzCallbackInfo_startAnimation (callbackinfo: &mut AzCallbackInfo, node: AzDomNodeId, animation: AzAnimation) -> AzOptionTimerId{ callbackinfo.start_animation(node, animation).into() }
/// Stops / cancels a `Timer`. See the documentation for `Timer` for more information.
#[no_mangle] pub extern "C" fn AzCallbackInfo_stopTimer (callbackinfo: &mut AzCallbackInfo, timer_id: AzTimerId) -> bool{ callbackinfo.stop_timer(timer_id) }
/// Starts a new `Thread` to the runtime. See the documentation for `Thread` for more information.
#[no_mangle] pub extern "C" fn AzCallbackInfo_startThread (callbackinfo: &mut AzCallbackInfo, thread_initialize_data: AzRefAny, writeback_data: AzRefAny, callback: AzThreadCallbackType) -> AzOptionThreadId{ callbackinfo.start_thread(thread_initialize_data, writeback_data, callback).into() }
/// Sends a message to a background thread
#[no_mangle] pub extern "C" fn AzCallbackInfo_sendThreadMsg (callbackinfo: &mut AzCallbackInfo, thread_id: AzThreadId, msg: AzThreadSendMsg) -> bool{ callbackinfo.send_thread_msg(thread_id, msg) }
/// Stops a thread at the nearest possible opportunity. Sends a `ThreadSendMsg::TerminateThread` message to the thread and joins the thread.
#[no_mangle] pub extern "C" fn AzCallbackInfo_stopThread (callbackinfo: &mut AzCallbackInfo, thread_id: AzThreadId) -> bool{ callbackinfo.stop_thread(thread_id) }
/* Error: Type is not stack allocated! */

/// Which type of image should be updated: background image (the CSS background) or content image (the <img src=""> content)
#[repr(C)] pub struct AzUpdateImageType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Specifies if the screen should be updated after the callback function has returned
#[repr(C)] pub struct AzUpdate { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Gives the `layout()` function access to the `RendererResources` and the `Window` (for querying images and fonts, as well as width / height)
#[repr(C)] pub struct AzLayoutCallbackInfo { pub ptr: *mut c_void }
/// Returns a copy of the OpenGL context
#[no_mangle] pub extern "C" fn AzLayoutCallbackInfo_getGlContext (layoutcallbackinfo: &AzLayoutCallbackInfo) -> AzOptionGlContextPtr{ layoutcallbackinfo.get_gl_context() }
/// Returns all system-native fonts with their respective file paths as values
#[no_mangle] pub extern "C" fn AzLayoutCallbackInfo_getSystemFonts (layoutcallbackinfo: &AzLayoutCallbackInfo) -> AzStringPairVec{ layoutcallbackinfo.get_system_fonts().into() }
/// Returns an `ImageRef` referenced by a CSS ID
#[no_mangle] pub extern "C" fn AzLayoutCallbackInfo_getImage (layoutcallbackinfo: &AzLayoutCallbackInfo, id: AzAzString) -> AzOptionImageRef{ layoutcallbackinfo.get_image(&id).into() }
/* Error: Type is not stack allocated! */

/// ID of a DOM - one window can contain multiple, nested DOMs (such as iframes)
#[repr(C)] pub struct AzDomId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Combination of node ID + DOM ID, both together can identify a node
#[repr(C)] pub struct AzDomNodeId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<PositionInfo>` struct
#[repr(C)] pub struct AzPositionInfo { pub ptr: *mut c_void }
/// Equivalent to the Rust `PositionInfo::is_positioned()` function.
#[no_mangle] pub extern "C" fn AzPositionInfo_isPositioned (positioninfo: &AzPositionInfo) -> bool{ positioninfo.is_positioned() }
/// Equivalent to the Rust `PositionInfo::get_static_offset()` function.
#[no_mangle] pub extern "C" fn AzPositionInfo_getStaticOffset (positioninfo: &AzPositionInfo) -> AzLogicalPosition{ positioninfo.get_static_offset() }
/// Equivalent to the Rust `PositionInfo::get_relative_offset()` function.
#[no_mangle] pub extern "C" fn AzPositionInfo_getRelativeOffset (positioninfo: &AzPositionInfo) -> AzLogicalPosition{ positioninfo.get_relative_offset() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<PositionInfoInner>` struct
#[repr(C)] pub struct AzPositionInfoInner { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Information about the bounds of a laid-out div rectangle. Necessary when invoking `IFrameCallbacks` and `RenderImageCallbacks`, so that they can change what their content is based on their size.
#[repr(C)] pub struct AzHidpiAdjustedBounds { pub ptr: *mut c_void }
/// Returns the size of the bounds in logical units
#[no_mangle] pub extern "C" fn AzHidpiAdjustedBounds_getLogicalSize (hidpiadjustedbounds: &AzHidpiAdjustedBounds) -> AzLogicalSize{ hidpiadjustedbounds.get_logical_size() }
/// Returns the size of the bounds in physical units
#[no_mangle] pub extern "C" fn AzHidpiAdjustedBounds_getPhysicalSize (hidpiadjustedbounds: &AzHidpiAdjustedBounds) -> AzPhysicalSizeU32{ hidpiadjustedbounds.get_physical_size() }
/// Returns the hidpi factor of the bounds
#[no_mangle] pub extern "C" fn AzHidpiAdjustedBounds_getHidpiFactor (hidpiadjustedbounds: &AzHidpiAdjustedBounds) -> f32{ hidpiadjustedbounds.get_hidpi_factor() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InlineText>` struct
#[repr(C)] pub struct AzInlineText { pub ptr: *mut c_void }
/// Hit-tests the inline text, returns detailed information about which glyph / word / line, etc. the position (usually the mouse cursor) is currently over. Result may be empty (no hits) or contain more than one result (cursor is hovering over multiple overlapping glyphs at once).
#[no_mangle] pub extern "C" fn AzInlineText_hitTest (inlinetext: &AzInlineText, position: AzLogicalPosition) -> AzInlineTextHitVec{ inlinetext.hit_test(position).into() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InlineLine>` struct
#[repr(C)] pub struct AzInlineLine { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InlineWord>` struct
#[repr(C)] pub struct AzInlineWord { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InlineTextContents>` struct
#[repr(C)] pub struct AzInlineTextContents { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InlineGlyph>` struct
#[repr(C)] pub struct AzInlineGlyph { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InlineTextHit>` struct
#[repr(C)] pub struct AzInlineTextHit { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Defines the focus_targeted node ID for the next frame
#[repr(C)] pub struct AzFocusTarget { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// CSS path to set the keyboard input focus
#[repr(C)] pub struct AzFocusTargetPath { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ScriptType>` struct
#[repr(C)] pub struct AzScriptType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ResolvedTextLayoutOptions>` struct
#[repr(C)] pub struct AzResolvedTextLayoutOptions { pub ptr: *mut c_void }
/// Creates a new `ResolvedTextLayoutOptions` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `ResolvedTextLayoutOptions::default()` constructor.
#[no_mangle] pub extern "C" fn AzResolvedTextLayoutOptions_default () -> AzResolvedTextLayoutOptions { let object: ResolvedTextLayoutOptions = AzResolvedTextLayoutOptions::default(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzResolvedTextLayoutOptions { ptr } }
/* Error: Type is not stack allocated! */

/// Animation struct to start a new animation
#[repr(C)] pub struct AzAnimation { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// How should an animation repeat (loop, ping-pong, etc.)
#[repr(C)] pub struct AzAnimationRepeat { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// How many times should an animation repeat
#[repr(C)] pub struct AzAnimationRepeatCount { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Index of a Node in the internal `NodeDataContainer`
#[repr(C)] pub struct AzNodeHierarchyItemId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI wrapper over an `IFrameCallbackType`
#[repr(C)] pub struct AzIFrameCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (&mut RefAny , &mut IFrameCallbackInfo) -> IFrameCallbackReturn
pub type AzIFrameCallbackType = Azextern "C" fn (&mut RefAny , &mut IFrameCallbackInfo) -> IFrameCallbackReturn<>;

/// Pointer to rust-allocated `Box<IFrameCallbackInfo>` struct
#[repr(C)] pub struct AzIFrameCallbackInfo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Return value for an IFrame rendering callback. # Dual Size Model IFrame callbacks return two size/offset pairs that enable lazy loading and virtualization: ## Actual Content (`scroll_size` + `scroll_offset`) The size and position of content that has **actually been rendered**. This is the content currently present in the returned DOM. **Example**: A table view might render only 20 visible rows out of 1000 total rows. ## Virtual Content (`virtual_scroll_size` + `virtual_scroll_offset`) The size and position of content that the IFrame **pretends to have**. This is used for scrollbar sizing and positioning, allowing the scrollbar to represent the full dataset even when only a subset is rendered. **Example**: The same table might pretend to have all 1000 rows for scrollbar sizing. # Conditional Re-invocation The IFrame callback will be re-invoked **only when necessary** to avoid performance overhead: 1. **Initial render** - First time the IFrame appears in the layout 2. **Parent DOM recreated** - The parent DOM was rebuilt from scratch (not just re-laid-out) 3. **Window resize (expansion only)** - Window grows and IFrame bounds exceed `scroll_size` - ✅ Only triggers **ONCE** per expansion (when bounds become uncovered) - ❌ Does **NOT** trigger when window shrinks (content is clipped, not re-rendered) - ❌ Does **NOT** trigger if expanded area is still within existing `scroll_size` 4. **Scroll near edge** - User scrolls within threshold (default 200px) of content edge - ✅ Only triggers **ONCE** per edge approach (prevents repeated calls) - Flag resets when: scroll moves away from edge, or callback returns expanded content 5. **Programmatic scroll** - `set_scroll_position()` scrolls beyond rendered `scroll_size` - Same constraints as rule #4 (threshold and once-per-edge) ## Window Resize Example ```text Frame 0: IFrame bounds = 800×600, scroll_size = 800×600 (perfectly covered) Frame 1: Window resizes to 1000×700 (larger) -> IFrame bounds = 1000×700 -> Bounds no longer fully covered by scroll_size (800×600) -> ✅ RE-INVOKE callback once Frame 2: Window resizes to 1100×800 (even larger) -> If callback returned scroll_size = 1100×800, fully covered again -> ❌ Do NOT re-invoke (content covers new bounds) -> If callback returned scroll_size = 1000×700, not fully covered -> ✅ RE-INVOKE again (new uncovered area) Frame 3: Window resizes to 900×650 (smaller) -> Bounds now smaller than scroll_size -> ❌ Do NOT re-invoke (content is just clipped by scrollbars) ``` ## Scroll Near Edge Example ```text scroll_size = 1000×2000 (width × height) Container = 800×600 Threshold = 200px Current scroll_offset = 0×0 User scrolls to scroll_offset = 0×1500: -> Bottom edge at 1500 + 600 = 2100 -> Within 200px of scroll_size.height (2000) -> Distance from edge: 2100 - 2000 = 100px < 200px -> ✅ RE-INVOKE callback to load more content Callback returns: -> New scroll_size = 1000×4000 (doubled) -> Flag reset (edge no longer near) -> User continues scrolling without re-invoke until near new edge ``` # Optimization: Returning None If the callback determines that no new content is needed (e.g., sufficient content has already been rendered ahead of the scroll position), it can return `OptionStyledDom::None` for the `dom` field. This signals the layout engine to keep using the current DOM and only update the scroll bounds. ```rust,ignore fn my_iframe_callback(data: &mut MyData, info: &mut IFrameCallbackInfo) -> IFrameCallbackReturn { let current_scroll = info.scroll_offset; // Check if we've already rendered content that covers this scroll position if data.already_rendered_area_covers(current_scroll, info.bounds.size) { return IFrameCallbackReturn { dom: OptionStyledDom::None, // Keep current DOM scroll_size: data.current_scroll_size, scroll_offset: data.current_scroll_offset, virtual_scroll_size: data.virtual_size, virtual_scroll_offset: LogicalPosition::zero(), }; } // Otherwise, render new content let new_dom = data.render_more_content(...); IFrameCallbackReturn { dom: OptionStyledDom::Some(new_dom), ... } } ``` # Example: Basic IFrame ```rust,ignore fn my_iframe_callback(data: &mut MyData, info: &mut IFrameCallbackInfo) -> IFrameCallbackReturn { let dom = Dom::body() .with_child(Dom::text("Hello from IFrame!")); let styled_dom = dom.style(Css::empty()); IFrameCallbackReturn { // The rendered content dom: OptionStyledDom::Some(styled_dom), // Size of actual rendered content (matches container) scroll_size: info.bounds.size, // Content starts at top-left scroll_offset: LogicalPosition::zero(), // Virtual size same as actual (no virtualization needed) virtual_scroll_size: info.bounds.size, virtual_scroll_offset: LogicalPosition::zero(), } } ``` # Example: Virtualized Table (Lazy Loading) ```rust,ignore struct TableData { total_rows: usize, // 1000 rows in full dataset row_height: f32, // 30px per row visible_rows: Vec<Row>, // Currently rendered rows (e.g., rows 0-29) first_visible_row: usize, // Index of first rendered row } fn table_iframe_callback(data: &mut TableData, info: &mut IFrameCallbackInfo) -> IFrameCallbackReturn { let container_height = info.bounds.size.height; let scroll_y = info.scroll_offset.y; // Calculate which rows should be visible based on scroll position let first_row = (scroll_y / data.row_height) as usize; let visible_count = (container_height / data.row_height).ceil() as usize + 2; // +2 for buffer // Fetch and render only the visible rows data.visible_rows = data.fetch_rows(first_row, visible_count); data.first_visible_row = first_row; let dom = Dom::body() .with_children( data.visible_rows.iter().map(|row| { Dom::div() .with_child(Dom::text(row.text.clone())) .with_inline_css_props(css_property_vec![ ("height", format!("{}px", data.row_height)), ]) }).collect() ); IFrameCallbackReturn { dom: OptionStyledDom::Some(dom.style(Css::empty())), // ACTUAL: Size of the ~30 rendered rows (e.g., 900px tall) scroll_size: LogicalSize::new( info.bounds.size.width, data.visible_rows.len() as f32 * data.row_height, ), // ACTUAL: Where these rows start in virtual space (e.g., y=300 if showing rows 10-30) scroll_offset: LogicalPosition::new( 0.0, first_row as f32 * data.row_height, ), // VIRTUAL: Size if all 1000 rows were rendered (30,000px tall) virtual_scroll_size: LogicalSize::new( info.bounds.size.width, data.total_rows as f32 * data.row_height, ), // VIRTUAL: Usually starts at origin virtual_scroll_offset: LogicalPosition::zero(), } } ``` In this example: - Only 20-30 rows are rendered at a time (~600-900px of DOM nodes) - The scrollbar represents all 1000 rows (30,000px virtual height) - When user scrolls near the bottom of rendered content, callback is re-invoked - New rows are rendered, and `scroll_size`/`scroll_offset` are updated - User experiences seamless scrolling through the full dataset # How the Layout Engine Uses These Values ## For Rendering - Uses `scroll_size` to determine the actual size of the IFrame's content box - Uses `scroll_offset` to position the content within the virtual space - Clips rendering to the visible viewport ## For Scrollbars - Uses `virtual_scroll_size` to calculate scrollbar thumb size and track length - Uses `virtual_scroll_offset` as the base for scroll position calculations - User sees scrollbar representing full virtual size, not just rendered content ## For Re-invocation Checks - Compares viewport bounds against `scroll_size` to detect edge proximity - Compares current scroll position against `scroll_offset + scroll_size` bounds - Triggers callback when user scrolls beyond the rendered content threshold
#[repr(C)] pub struct AzIFrameCallbackReturn { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Callback that returns a rendered OpenGL texture **IMPORTANT**: In azul-core, this is stored as `CoreRenderImageCallback` with a `cb: usize` field. When creating callbacks in the data model, function pointers are cast to usize. This type is used in azul-layout where we can safely work with the actual function pointer type.
#[repr(C)] pub struct AzRenderImageCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Callback type that renders an OpenGL texture **IMPORTANT**: In azul-core, this is stored as `CoreRenderImageCallbackType = usize` to avoid circular dependencies. The actual function pointer is cast to usize for storage in the data model, then unsafely cast back to this type when invoked.
pub type AzRenderImageCallbackType = Azextern "C" fn (&mut RefAny , &mut RenderImageCallbackInfo) -> ImageRef<>;

/// Information passed to image rendering callbacks
#[repr(C)] pub struct AzRenderImageCallbackInfo { pub ptr: *mut c_void }
/// Returns a copy of the internal `Gl`
#[no_mangle] pub extern "C" fn AzRenderImageCallbackInfo_getGlContext (renderimagecallbackinfo: &AzRenderImageCallbackInfo) -> AzOptionGlContextPtr{ renderimagecallbackinfo.get_gl_context().into() }
/// Returns a copy of the internal `HidpiAdjustedBounds`
#[no_mangle] pub extern "C" fn AzRenderImageCallbackInfo_getBounds (renderimagecallbackinfo: &AzRenderImageCallbackInfo) -> AzHidpiAdjustedBounds{ renderimagecallbackinfo.get_bounds() }
/// Returns the `DomNodeId` that this callback was called on
#[no_mangle] pub extern "C" fn AzRenderImageCallbackInfo_getCallbackNodeId (renderimagecallbackinfo: &AzRenderImageCallbackInfo) -> AzDomNodeId{ renderimagecallbackinfo.get_callback_node_id() }
/// If the node is a `Text` node, returns the layouted inline glyphs
#[no_mangle] pub extern "C" fn AzRenderImageCallbackInfo_getInlineText (renderimagecallbackinfo: &AzRenderImageCallbackInfo, node_id: AzDomNodeId) -> AzOptionInlineText{ renderimagecallbackinfo.get_inline_text(node_id).into() }
/// Returns the index of the node relative to the parent node.
#[no_mangle] pub extern "C" fn AzRenderImageCallbackInfo_getIndexInParent (renderimagecallbackinfo: &mut AzRenderImageCallbackInfo, node_id: AzDomNodeId) -> usize{ let mut t = 0; let mut n = node_id; while let Some(prev) = renderimagecallbackinfo.get_previous_sibling(n) { n = prev; t += 1; } t }
/// Returns the parent `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
#[no_mangle] pub extern "C" fn AzRenderImageCallbackInfo_getParent (renderimagecallbackinfo: &mut AzRenderImageCallbackInfo, node_id: AzDomNodeId) -> AzOptionDomNodeId{ renderimagecallbackinfo.get_parent(node_id).into() }
/// Returns the previous siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
#[no_mangle] pub extern "C" fn AzRenderImageCallbackInfo_getPreviousSibling (renderimagecallbackinfo: &mut AzRenderImageCallbackInfo, node_id: AzDomNodeId) -> AzOptionDomNodeId{ renderimagecallbackinfo.get_previous_sibling(node_id).into() }
/// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
#[no_mangle] pub extern "C" fn AzRenderImageCallbackInfo_getNextSibling (renderimagecallbackinfo: &mut AzRenderImageCallbackInfo, node_id: AzDomNodeId) -> AzOptionDomNodeId{ renderimagecallbackinfo.get_next_sibling(node_id).into() }
/// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
#[no_mangle] pub extern "C" fn AzRenderImageCallbackInfo_getFirstChild (renderimagecallbackinfo: &mut AzRenderImageCallbackInfo, node_id: AzDomNodeId) -> AzOptionDomNodeId{ renderimagecallbackinfo.get_first_child(node_id).into() }
/// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
#[no_mangle] pub extern "C" fn AzRenderImageCallbackInfo_getLastChild (renderimagecallbackinfo: &mut AzRenderImageCallbackInfo, node_id: AzDomNodeId) -> AzOptionDomNodeId{ renderimagecallbackinfo.get_last_child(node_id).into() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TimerCallback>` struct
#[repr(C)] pub struct AzTimerCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `TimerCallbackType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<TimerCallbackInfo>` struct
#[repr(C)] pub struct AzTimerCallbackInfo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TimerCallbackReturn>` struct
#[repr(C)] pub struct AzTimerCallbackReturn { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `WriteBackCallbackType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<WriteBackCallback>` struct
#[repr(C)] pub struct AzWriteBackCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ThreadCallback>` struct
#[repr(C)] pub struct AzThreadCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `ThreadCallbackType` struct
/* Error: 'external' key is required for this class */

/// Re-export of rust-allocated (stack based) `RefAnyDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<RefCount>` struct
pub use azul_core::callbacks::RefCount as AzRefCountTT;
pub use AzRefCountTT as AzRefCount;
/// Equivalent to the Rust `RefCount::can_be_shared()` function.
#[no_mangle] pub extern "C" fn AzRefCount_canBeShared (refcount: &AzRefCount) -> bool{ refcount.can_be_shared() }
/// Equivalent to the Rust `RefCount::can_be_shared_mut()` function.
#[no_mangle] pub extern "C" fn AzRefCount_canBeSharedMut (refcount: &AzRefCount) -> bool{ refcount.can_be_shared_mut() }
/// Equivalent to the Rust `RefCount::increase_ref()` function.
#[no_mangle] pub extern "C" fn AzRefCount_increaseRef (refcount: &mut AzRefCount){ refcount.increase_ref() }
/// Equivalent to the Rust `RefCount::decrease_ref()` function.
#[no_mangle] pub extern "C" fn AzRefCount_decreaseRef (refcount: &mut AzRefCount){ refcount.decrease_ref() }
/// Equivalent to the Rust `RefCount::increase_refmut()` function.
#[no_mangle] pub extern "C" fn AzRefCount_increaseRefmut (refcount: &mut AzRefCount){ refcount.increase_refmut() }
/// Equivalent to the Rust `RefCount::decrease_refmut()` function.
#[no_mangle] pub extern "C" fn AzRefCount_decreaseRefmut (refcount: &mut AzRefCount){ refcount.decrease_refmut() }
/* Error: Type is not stack allocated! */

/// RefAny is a reference-counted, opaque pointer, which stores a reference to a struct. `RefAny` can be up- and downcasted (this usually done via generics and can't be expressed in the Rust API)
pub use azul_core::callbacks::RefAny as AzRefAnyTT;
pub use AzRefAnyTT as AzRefAny;
/// Creates a new `RefAny` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `RefAny::new_c()` constructor.
#[no_mangle] pub extern "C" fn AzRefAny_newC (ptr: *const c_void, len: usize, align: usize, type_id: u64, type_name: AzAzString, destructor: AzRefAnyDestructorType) -> AzRefAny { let object: RefAny = AzRefAny::new_c(ptr, len, align, type_id, type_name, destructor); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzRefAny { ptr } }
/// Equivalent to the Rust `RefAny::get_type_id()` function.
#[no_mangle] pub extern "C" fn AzRefAny_getTypeId (refany: &AzRefAny) -> u64{ refany.get_type_id() }
/// Equivalent to the Rust `RefAny::get_type_name()` function.
#[no_mangle] pub extern "C" fn AzRefAny_getTypeName (refany: &AzRefAny) -> AzAzString{ refany.get_type_name() }
/* Error: Type is not stack allocated! */

/// Which edge triggered a scroll-based re-invocation
#[repr(C)] pub struct AzEdgeType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Config necessary for threading + animations to work in no_std environments
#[repr(C)] pub struct AzExternalSystemCallbacks { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Menu callback: What data / function pointer should be called when the menu item is clicked?
#[repr(C)] pub struct AzMenuCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Reason why an IFrame callback is being invoked. This helps the callback optimize its behavior based on why it's being called.
#[repr(C)] pub struct AzIFrameCallbackReason { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// The document model, similar to HTML. This is a create-only structure, you don't actually read anything back from it. It's designed for ease of construction.
#[repr(C)] pub struct AzDom { pub ptr: *mut c_void }
/// Creates a new `Dom` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Dom::new()` constructor.
#[no_mangle] pub extern "C" fn AzDom_new (node_type: AzNodeType) -> AzDom { let object: Dom = AzDom::new(node_type); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzDom { ptr } }
/// Creates a new `Dom` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Dom::body()` constructor.
#[no_mangle] pub extern "C" fn AzDom_body () -> AzDom { let object: Dom = AzDom::body(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzDom { ptr } }
/// Creates a new `Dom` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Dom::div()` constructor.
#[no_mangle] pub extern "C" fn AzDom_div () -> AzDom { let object: Dom = AzDom::div(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzDom { ptr } }
/// Creates a new `Dom` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Dom::br()` constructor.
#[no_mangle] pub extern "C" fn AzDom_br () -> AzDom { let object: Dom = AzDom::br(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzDom { ptr } }
/// Creates a new `Dom` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Dom::text()` constructor.
#[no_mangle] pub extern "C" fn AzDom_text (string: AzAzString) -> AzDom { let object: Dom = AzDom::text(string); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzDom { ptr } }
/// Creates a new `Dom` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Dom::image()` constructor.
#[no_mangle] pub extern "C" fn AzDom_image (image: AzImageRef) -> AzDom { let object: Dom = AzDom::image(image); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzDom { ptr } }
/// Creates a new `Dom` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Dom::iframe()` constructor.
#[no_mangle] pub extern "C" fn AzDom_iframe (data: AzRefAny, callback: AzIFrameCallbackType) -> AzDom { let object: Dom = AzDom::iframe(data, callback); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzDom { ptr } }
/// Equivalent to the Rust `Dom::set_node_type()` function.
#[no_mangle] pub extern "C" fn AzDom_setNodeType (dom: &mut AzDom, node_type: AzNodeType){ dom.root.set_node_type(node_type) }
/// Equivalent to the Rust `Dom::with_node_type()` function.
#[no_mangle] pub extern "C" fn AzDom_withNodeType (dom: &mut AzDom, node_type: AzNodeType) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.set_node_type(node_type); dom }
/// Equivalent to the Rust `Dom::set_dataset()` function.
#[no_mangle] pub extern "C" fn AzDom_setDataset (dom: &mut AzDom, dataset: AzRefAny){ dom.root.set_dataset(Some(dataset).into()) }
/// Equivalent to the Rust `Dom::with_dataset()` function.
#[no_mangle] pub extern "C" fn AzDom_withDataset (dom: &mut AzDom, dataset: AzRefAny) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.set_dataset(Some(dataset).into()); dom }
/// Equivalent to the Rust `Dom::set_ids_and_classes()` function.
#[no_mangle] pub extern "C" fn AzDom_setIdsAndClasses (dom: &mut AzDom, ids_and_classes: AzIdOrClassVec){ dom.root.set_ids_and_classes(ids_and_classes) }
/// Equivalent to the Rust `Dom::with_ids_and_classes()` function.
#[no_mangle] pub extern "C" fn AzDom_withIdsAndClasses (dom: &mut AzDom, ids_and_classes: AzIdOrClassVec) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.set_ids_and_classes(ids_and_classes); dom }
/// Equivalent to the Rust `Dom::set_callbacks()` function.
#[no_mangle] pub extern "C" fn AzDom_setCallbacks (dom: &mut AzDom, callbacks: AzCallbackDataVec){ dom.root.set_callbacks(callbacks) }
/// Equivalent to the Rust `Dom::with_callbacks()` function.
#[no_mangle] pub extern "C" fn AzDom_withCallbacks (dom: &mut AzDom, callbacks: AzCallbackDataVec) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.set_callbacks(callbacks); dom }
/// Equivalent to the Rust `Dom::set_inline_css_props()` function.
#[no_mangle] pub extern "C" fn AzDom_setInlineCssProps (dom: &mut AzDom, css_properties: AzNodeDataInlineCssPropertyVec){ dom.root.set_inline_css_props(css_properties) }
/// Equivalent to the Rust `Dom::with_inline_css_props()` function.
#[no_mangle] pub extern "C" fn AzDom_withInlineCssProps (dom: &mut AzDom, css_properties: AzNodeDataInlineCssPropertyVec) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.set_inline_css_props(css_properties); dom }
/// Adds a child node to this DOM (potentially heap-allocates in Rust code). Swaps `self` with a default `Dom` in order to prevent accidental copies.
#[no_mangle] pub extern "C" fn AzDom_addCallback (dom: &mut AzDom, event: AzEventFilter, data: AzRefAny, callback: AzCallbackType){ dom.root.add_callback(event, data, callback) }
/// Same as add_child, but as a builder method.
#[no_mangle] pub extern "C" fn AzDom_withCallback (dom: &mut AzDom, event: AzEventFilter, data: AzRefAny, callback: AzCallbackType) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.add_callback(event, data, callback); dom }
/// Adds a child node to this DOM (potentially heap-allocates in Rust code). Swaps `self` with a default `Dom` in order to prevent accidental copies.
#[no_mangle] pub extern "C" fn AzDom_addChild (dom: &mut AzDom, child: AzDom){ dom.add_child(child) }
/// Same as add_child, but as a builder method.
#[no_mangle] pub extern "C" fn AzDom_withChild (dom: &mut AzDom, child: AzDom) -> AzDom{ dom.with_child(child) }
/// Adds a child node to this DOM (potentially heap-allocates in Rust code). Swaps `self` with a default `Dom` in order to prevent accidental copies.
#[no_mangle] pub extern "C" fn AzDom_setChildren (dom: &mut AzDom, children: AzDomVec){ dom.set_children(children) }
/// Same as set_children, but as a builder method.
#[no_mangle] pub extern "C" fn AzDom_withChildren (dom: &mut AzDom, children: AzDomVec) -> AzDom{ let mut dom = dom.swap_with_default(); dom.set_children(children); dom }
/// Adds an CSS ID to the DOM root node.
#[no_mangle] pub extern "C" fn AzDom_addId (dom: &mut AzDom, id: AzAzString){ dom.root.add_id(id) }
/// Same as add_id, but as a builder method
#[no_mangle] pub extern "C" fn AzDom_withId (dom: &mut AzDom, id: AzAzString) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.add_id(id); dom }
/// Adds a CSS class to the DOM root node.
#[no_mangle] pub extern "C" fn AzDom_addClass (dom: &mut AzDom, class: AzAzString){ dom.root.add_class(class) }
/// Same as add_class, but as a builder method
#[no_mangle] pub extern "C" fn AzDom_withClass (dom: &mut AzDom, class: AzAzString) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.add_class(class); dom }
/// Adds an inline (normal) CSS property to the DOM root node.
#[no_mangle] pub extern "C" fn AzDom_addCssProperty (dom: &mut AzDom, prop: AzCssProperty){ dom.root.add_normal_css_property(prop) }
/// Same as add_class, but as a builder method
#[no_mangle] pub extern "C" fn AzDom_withCssProperty (dom: &mut AzDom, prop: AzCssProperty) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.add_normal_css_property(prop); dom }
/// Adds an inline (hover) CSS property to the DOM root node.
#[no_mangle] pub extern "C" fn AzDom_addHoverCssProperty (dom: &mut AzDom, prop: AzCssProperty){ dom.root.add_hover_css_property(prop) }
/// Same as add_class, but as a builder method
#[no_mangle] pub extern "C" fn AzDom_withHoverCssProperty (dom: &mut AzDom, prop: AzCssProperty) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.add_hover_css_property(prop); dom }
/// Adds an inline (hover) CSS property to the DOM root node.
#[no_mangle] pub extern "C" fn AzDom_addActiveCssProperty (dom: &mut AzDom, prop: AzCssProperty){ dom.root.add_active_css_property(prop) }
/// Same as add_class, but as a builder method
#[no_mangle] pub extern "C" fn AzDom_withActiveCssProperty (dom: &mut AzDom, prop: AzCssProperty) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.add_active_css_property(prop); dom }
/// Adds an inline (hover) CSS property to the DOM root node.
#[no_mangle] pub extern "C" fn AzDom_addFocusCssProperty (dom: &mut AzDom, prop: AzCssProperty){ dom.root.add_focus_css_property(prop) }
/// Same as add_class, but as a builder method
#[no_mangle] pub extern "C" fn AzDom_withFocusCssProperty (dom: &mut AzDom, prop: AzCssProperty) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.add_focus_css_property(prop); dom }
/// Equivalent to the Rust `Dom::set_inline_style()` function.
#[no_mangle] pub extern "C" fn AzDom_setInlineStyle (dom: &mut AzDom, style: AzAzString){ AzNodeData_setInlineStyle(&mut dom.root, style); }
/// Equivalent to the Rust `Dom::with_inline_style()` function.
#[no_mangle] pub extern "C" fn AzDom_withInlineStyle (dom: &mut AzDom, style: AzAzString) -> AzDom{ let mut dom = dom.swap_with_default(); AzNodeData_setInlineStyle(&mut dom.root, style); dom }
/// Equivalent to the Rust `Dom::set_inline_hover_style()` function.
#[no_mangle] pub extern "C" fn AzDom_setInlineHoverStyle (dom: &mut AzDom, style: AzAzString){ AzNodeData_setInlineHoverStyle(&mut dom.root, style); }
/// Equivalent to the Rust `Dom::with_inline_hover_style()` function.
#[no_mangle] pub extern "C" fn AzDom_withInlineHoverStyle (dom: &mut AzDom, style: AzAzString) -> AzDom{ let mut dom = dom.swap_with_default(); AzNodeData_setInlineHoverStyle(&mut dom.root, style); dom }
/// Equivalent to the Rust `Dom::set_inline_active_style()` function.
#[no_mangle] pub extern "C" fn AzDom_setInlineActiveStyle (dom: &mut AzDom, style: AzAzString){ AzNodeData_setInlineActiveStyle(&mut dom.root, style); }
/// Equivalent to the Rust `Dom::with_inline_active_style()` function.
#[no_mangle] pub extern "C" fn AzDom_withInlineActiveStyle (dom: &mut AzDom, style: AzAzString) -> AzDom{ let mut dom = dom.swap_with_default(); AzNodeData_setInlineActiveStyle(&mut dom.root, style); dom }
/// Equivalent to the Rust `Dom::set_inline_focus_style()` function.
#[no_mangle] pub extern "C" fn AzDom_setInlineFocusStyle (dom: &mut AzDom, style: AzAzString){ AzNodeData_setInlineFocusStyle(&mut dom.root, style); }
/// Equivalent to the Rust `Dom::with_inline_focus_style()` function.
#[no_mangle] pub extern "C" fn AzDom_withInlineFocusStyle (dom: &mut AzDom, style: AzAzString) -> AzDom{ let mut dom = dom.swap_with_default(); AzNodeData_setInlineFocusStyle(&mut dom.root, style); dom }
/// Sets the clip mask for the DOM root node.
#[no_mangle] pub extern "C" fn AzDom_setClipMask (dom: &mut AzDom, clip_mask: AzImageMask){ dom.root.set_clip_mask(clip_mask) }
/// Same as set_clip_mask, but as a builder method
#[no_mangle] pub extern "C" fn AzDom_withClipMask (dom: &mut AzDom, clip_mask: AzImageMask) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.set_clip_mask(clip_mask); dom }
/// Sets the tab index for the DOM root node.
#[no_mangle] pub extern "C" fn AzDom_setTabIndex (dom: &mut AzDom, tab_index: AzTabIndex){ dom.root.set_tab_index(tab_index) }
/// Same as set_tab_index, but as a builder method
#[no_mangle] pub extern "C" fn AzDom_withTabIndex (dom: &mut AzDom, tab_index: AzTabIndex) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.set_tab_index(tab_index); dom }
/// Sets accessibility attributes for the DOM root node.
#[no_mangle] pub extern "C" fn AzDom_setAccessibilityInfo (dom: &mut AzDom, accessibility_info: AzAccessibilityInfo){ dom.root.set_accessibility_info(accessibility_info) }
/// Same as set_accessibility_info, but as a builder method
#[no_mangle] pub extern "C" fn AzDom_withAccessibilityInfo (dom: &mut AzDom, accessibility_info: AzAccessibilityInfo) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.set_accessibility_info(accessibility_info); dom }
/// Sets the menu bar for the DOM root node. See `NodeData::set_menu_bar` for more information.
#[no_mangle] pub extern "C" fn AzDom_setMenuBar (dom: &mut AzDom, menu_bar: AzMenu){ dom.root.set_menu_bar(menu_bar) }
/// Same as set_accessibility_info, but as a builder method
#[no_mangle] pub extern "C" fn AzDom_withMenuBar (dom: &mut AzDom, menu_bar: AzMenu) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.set_menu_bar(menu_bar); dom }
/// Sets the context menu for the DOM root node. See `NodeData::set_context_menu` for more information.
#[no_mangle] pub extern "C" fn AzDom_setContextMenu (dom: &mut AzDom, context_menu: AzMenu){ dom.root.set_context_menu(context_menu) }
/// Same as set_context_menu, but as a builder method
#[no_mangle] pub extern "C" fn AzDom_withContextMenu (dom: &mut AzDom, context_menu: AzMenu) -> AzDom{ let mut dom = dom.swap_with_default(); dom.root.set_context_menu(context_menu); dom }
/// Calculates the hash of this node (note: in order to be truly unique, you also have to hash the DOM and Node ID).
#[no_mangle] pub extern "C" fn AzDom_hash (dom: &AzDom) -> u64{ dom.root.calculate_node_data_hash().0 }
/// Returns the number of nodes in the DOM, including all child DOM trees. Result is equal to `self.total_children + 1` (count of all child trees + the root node)
#[no_mangle] pub extern "C" fn AzDom_nodeCount (dom: &AzDom) -> usize{ dom.node_count() }
/// Returns a HTML string that you can write to a file in order to debug the UI structure and debug potential cascading issues
#[no_mangle] pub extern "C" fn AzDom_getHtmlString (dom: &mut AzDom) -> AzAzString{ dom.style(AzCss::empty().into()).get_html_string("", "", false).into() }
/// Returns a HTML for unit testing
#[no_mangle] pub extern "C" fn AzDom_getHtmlStringTest (dom: &mut AzDom) -> AzAzString{ dom.style(AzCss::empty().into()).get_html_string("", "", true).into() }
/// Same as `StyledDom::new(dom, css)`: NOTE - replaces self with an empty DOM, in order to prevent cloning the DOM entirely
#[no_mangle] pub extern "C" fn AzDom_style (dom: &mut AzDom, css: AzCss) -> AzStyledDom{ dom.style(css.into()) }
/* Error: Type is not stack allocated! */

/// Contains the necessary information to render an embedded `IFrame` node.
#[repr(C)] pub struct AzIFrameNode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CallbackData>` struct
#[repr(C)] pub struct AzCallbackData { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents all data associated with a single DOM node, such as its type, classes, IDs, callbacks, and inline styles.
#[repr(C)] pub struct AzNodeData { pub ptr: *mut c_void }
/// Creates an new, empty `NodeData` struct
#[no_mangle] pub extern "C" fn AzNodeData_new (node_type: AzNodeType) -> AzNodeData { let object: NodeData = AzNodeData::new(node_type); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzNodeData { ptr } }
/// Creates a new `NodeData` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `NodeData::body()` constructor.
#[no_mangle] pub extern "C" fn AzNodeData_body () -> AzNodeData { let object: NodeData = AzNodeData::body(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzNodeData { ptr } }
/// Creates a new `NodeData` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `NodeData::div()` constructor.
#[no_mangle] pub extern "C" fn AzNodeData_div () -> AzNodeData { let object: NodeData = AzNodeData::div(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzNodeData { ptr } }
/// Creates a new `NodeData` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `NodeData::br()` constructor.
#[no_mangle] pub extern "C" fn AzNodeData_br () -> AzNodeData { let object: NodeData = AzNodeData::br(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzNodeData { ptr } }
/// Creates a new `NodeData` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `NodeData::text()` constructor.
#[no_mangle] pub extern "C" fn AzNodeData_text (string: AzAzString) -> AzNodeData { let object: NodeData = AzNodeData::text(string); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzNodeData { ptr } }
/// Creates a new `NodeData` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `NodeData::image()` constructor.
#[no_mangle] pub extern "C" fn AzNodeData_image (image: AzImageRef) -> AzNodeData { let object: NodeData = AzNodeData::image(image); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzNodeData { ptr } }
/// Creates a new `NodeData` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `NodeData::iframe()` constructor.
#[no_mangle] pub extern "C" fn AzNodeData_iframe (data: AzRefAny, callback: AzIFrameCallbackType) -> AzNodeData { let object: NodeData = AzNodeData::iframe(data, callback); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzNodeData { ptr } }
/// Equivalent to the Rust `NodeData::set_node_type()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setNodeType (nodedata: &mut AzNodeData, node_type: AzNodeType){ nodedata.set_node_type(node_type) }
/// Equivalent to the Rust `NodeData::with_node_type()` function.
#[no_mangle] pub extern "C" fn AzNodeData_withNodeType (nodedata: &mut AzNodeData, node_type: AzNodeType) -> AzNodeData{ let mut nodedata = nodedata.swap_with_default(); nodedata.set_node_type(node_type); nodedata }
/// Equivalent to the Rust `NodeData::set_dataset()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setDataset (nodedata: &mut AzNodeData, dataset: AzRefAny){ nodedata.set_dataset(Some(dataset).into()) }
/// Equivalent to the Rust `NodeData::with_dataset()` function.
#[no_mangle] pub extern "C" fn AzNodeData_withDataset (nodedata: &mut AzNodeData, dataset: AzRefAny) -> AzNodeData{ let mut nodedata = nodedata.swap_with_default(); nodedata.set_dataset(Some(dataset).into()); nodedata }
/// Equivalent to the Rust `NodeData::set_ids_and_classes()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setIdsAndClasses (nodedata: &mut AzNodeData, ids_and_classes: AzIdOrClassVec){ nodedata.set_ids_and_classes(ids_and_classes) }
/// Equivalent to the Rust `NodeData::with_ids_and_classes()` function.
#[no_mangle] pub extern "C" fn AzNodeData_withIdsAndClasses (nodedata: &mut AzNodeData, ids_and_classes: AzIdOrClassVec) -> AzNodeData{ let mut nodedata = nodedata.swap_with_default(); nodedata.set_ids_and_classes(ids_and_classes); nodedata }
/// Adds a callback this DOM (potentially heap-allocates in Rust code)
#[no_mangle] pub extern "C" fn AzNodeData_addCallback (nodedata: &mut AzNodeData, event: AzEventFilter, data: AzRefAny, callback: AzCallbackType){ nodedata.add_callback(event, data, callback) }
/// Same as add_child, but as a builder method.
#[no_mangle] pub extern "C" fn AzNodeData_withCallback (nodedata: &mut AzNodeData, event: AzEventFilter, data: AzRefAny, callback: AzCallbackType) -> AzNodeData{ let mut nodedata = nodedata.swap_with_default(); nodedata.add_callback(event, data, callback); nodedata }
/// Equivalent to the Rust `NodeData::set_callbacks()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setCallbacks (nodedata: &mut AzNodeData, callbacks: AzCallbackDataVec){ nodedata.set_callbacks(callbacks) }
/// Equivalent to the Rust `NodeData::with_callbacks()` function.
#[no_mangle] pub extern "C" fn AzNodeData_withCallbacks (nodedata: &mut AzNodeData, callbacks: AzCallbackDataVec) -> AzNodeData{ let mut nodedata = nodedata.swap_with_default(); nodedata.set_callbacks(callbacks); nodedata }
/// Equivalent to the Rust `NodeData::set_inline_css_props()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setInlineCssProps (nodedata: &mut AzNodeData, css_properties: AzNodeDataInlineCssPropertyVec){ nodedata.set_inline_css_props(css_properties) }
/// Equivalent to the Rust `NodeData::with_inline_css_props()` function.
#[no_mangle] pub extern "C" fn AzNodeData_withInlineCssProps (nodedata: &mut AzNodeData, css_properties: AzNodeDataInlineCssPropertyVec) -> AzNodeData{ let mut nodedata = nodedata.swap_with_default(); nodedata.set_inline_css_props(css_properties); nodedata }
/// Equivalent to the Rust `NodeData::set_inline_style()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setInlineStyle (nodedata: &mut AzNodeData, style: AzAzString){ nodedata.set_inline_css_props(nodedata.get_inline_css_props().with_append(AzNodeDataInlineCssPropertyVec::parse_normal(style.as_str()))) }
/// Equivalent to the Rust `NodeData::with_inline_style()` function.
#[no_mangle] pub extern "C" fn AzNodeData_withInlineStyle (nodedata: &mut AzNodeData, style: AzAzString) -> AzNodeData{ let mut nodedata = nodedata.swap_with_default(); AzNodeData_setInlineStyle(&mut nodedata, style); nodedata }
/// Equivalent to the Rust `NodeData::set_inline_hover_style()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setInlineHoverStyle (nodedata: &mut AzNodeData, style: AzAzString){ nodedata.set_inline_css_props(nodedata.get_inline_css_props().with_append(AzNodeDataInlineCssPropertyVec::parse_hover(style.as_str()))) }
/// Equivalent to the Rust `NodeData::with_inline_hover_style()` function.
#[no_mangle] pub extern "C" fn AzNodeData_withInlineHoverStyle (nodedata: &mut AzNodeData, style: AzAzString) -> AzNodeData{ let mut nodedata = nodedata.swap_with_default(); AzNodeData_setInlineHoverStyle(&mut nodedata, style); nodedata }
/// Equivalent to the Rust `NodeData::set_inline_active_style()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setInlineActiveStyle (nodedata: &mut AzNodeData, style: AzAzString){ nodedata.set_inline_css_props(nodedata.get_inline_css_props().with_append(AzNodeDataInlineCssPropertyVec::parse_active(style.as_str()))) }
/// Equivalent to the Rust `NodeData::with_inline_active_style()` function.
#[no_mangle] pub extern "C" fn AzNodeData_withInlineActiveStyle (nodedata: &mut AzNodeData, style: AzAzString) -> AzNodeData{ let mut nodedata = nodedata.swap_with_default(); AzNodeData_setInlineActiveStyle(&mut nodedata, style); nodedata }
/// Equivalent to the Rust `NodeData::set_inline_focus_style()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setInlineFocusStyle (nodedata: &mut AzNodeData, style: AzAzString){ nodedata.set_inline_css_props(nodedata.get_inline_css_props().with_append(AzNodeDataInlineCssPropertyVec::parse_focus(style.as_str()))) }
/// Equivalent to the Rust `NodeData::with_inline_focus_style()` function.
#[no_mangle] pub extern "C" fn AzNodeData_withInlineFocusStyle (nodedata: &mut AzNodeData, style: AzAzString) -> AzNodeData{ let mut nodedata = nodedata.swap_with_default(); AzNodeData_setInlineFocusStyle(&mut nodedata, style); nodedata }
/// Sets the `extra.clip_mask` field for this node
#[no_mangle] pub extern "C" fn AzNodeData_setClipMask (nodedata: &mut AzNodeData, image_mask: AzImageMask){ nodedata.set_clip_mask(image_mask) }
/// Sets the tab index for this node
#[no_mangle] pub extern "C" fn AzNodeData_setTabIndex (nodedata: &mut AzNodeData, tab_index: AzTabIndex){ nodedata.set_tab_index(tab_index) }
/// Sets accessibility attributes for this node
#[no_mangle] pub extern "C" fn AzNodeData_setAccessibilityInfo (nodedata: &mut AzNodeData, accessibility_info: AzAccessibilityInfo){ nodedata.set_accessibility_info(accessibility_info) }
/// Adds a (native) menu bar: If this node is the root node the menu bar will be added to the window, else it will be displayed using the width and position of the bounding rectangle
#[no_mangle] pub extern "C" fn AzNodeData_setMenuBar (nodedata: &mut AzNodeData, menu_bar: AzMenu){ nodedata.set_menu_bar(menu_bar) }
/// Signalizes that this node has a (native) context-aware menu. If set, the user can left-click the node to open the menu
#[no_mangle] pub extern "C" fn AzNodeData_setContextMenu (nodedata: &mut AzNodeData, context_menu: AzMenu){ nodedata.set_context_menu(context_menu) }
/// Calculates the hash of this node (note: in order to be truly unique, you also have to hash the DOM and Node ID).
#[no_mangle] pub extern "C" fn AzNodeData_hash (nodedata: &AzNodeData) -> u64{ nodedata.calculate_node_data_hash().0 }
/* Error: Type is not stack allocated! */

/// List of core DOM node types built into `azul`. This enum defines the building blocks of the UI, similar to HTML tags.
#[repr(C)] pub struct AzNodeType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Defines the type of event that can trigger a callback action.
#[repr(C)] pub struct AzOn { pub ptr: *mut c_void }
/// Converts the `On` shorthand into a `EventFilter`
#[no_mangle] pub extern "C" fn AzOn_intoEventFilter (on: AzOn) -> AzEventFilter{ on.into() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<EventFilter>` struct
#[repr(C)] pub struct AzEventFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<HoverEventFilter>` struct
#[repr(C)] pub struct AzHoverEventFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FocusEventFilter>` struct
#[repr(C)] pub struct AzFocusEventFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NotEventFilter>` struct
#[repr(C)] pub struct AzNotEventFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WindowEventFilter>` struct
#[repr(C)] pub struct AzWindowEventFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ComponentEventFilter>` struct
#[repr(C)] pub struct AzComponentEventFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ApplicationEventFilter>` struct
#[repr(C)] pub struct AzApplicationEventFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Holds information about a UI element for accessibility purposes (e.g., screen readers). This is a wrapper for platform-specific accessibility APIs like MSAA.
#[repr(C)] pub struct AzAccessibilityInfo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Defines the element's purpose for accessibility APIs, informing assistive technologies like screen readers about the function of a UI element. Each variant corresponds to a standard control type or UI structure. For more details, see the [MSDN Role Constants page](https://docs.microsoft.com/en-us/windows/winauto/object-roles).
#[repr(C)] pub struct AzAccessibilityRole { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Defines the current state of an element for accessibility APIs (e.g., focused, checked). These states provide dynamic information to assistive technologies about the element's condition. See the [MSDN State Constants page](https://docs.microsoft.com/en-us/windows/win32/winauto/object-state-constants) for more details.
#[repr(C)] pub struct AzAccessibilityState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Determines the behavior of an element in sequential focus navigation
#[repr(C)] pub struct AzTabIndex { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// An enum that holds either a CSS ID or a class name as a string.
#[repr(C)] pub struct AzIdOrClass { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents an inline CSS property attached to a node for a specific interaction state. This allows defining styles for `:hover`, `:focus`, etc., directly on a DOM node.
#[repr(C)] pub struct AzNodeDataInlineCssProperty { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// A unique, runtime-generated identifier for a single `Dom` instance.
#[repr(C)] pub struct AzDomId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// A UUID for a DOM node within a `LayoutWindow`.
#[repr(C)] pub struct AzDomNodeId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a menu (context menu, dropdown menu, or application menu). A menu consists of a list of items that can be displayed as a popup or attached to a window's menu bar. Modeled after the Windows API for cross-platform consistency. # Fields * `items` - The menu items to display * `position` - Where the menu should appear (for popups) * `context_mouse_btn` - Which mouse button triggers the context menu
#[repr(C)] pub struct AzMenu { pub ptr: *mut c_void }
/// Creates an new, empty Menu
#[no_mangle] pub extern "C" fn AzMenu_new (items: AzMenuItemVec) -> AzMenu { let object: Menu = AzMenu::new(items); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzMenu { ptr } }
/// Sets the popup position of the menu, ignored on menu bars
#[no_mangle] pub extern "C" fn AzMenu_setPopupPosition (menu: &mut AzMenu, position: AzMenuPopupPosition){ menu.position = position; }
/// Sets the popup position of the menu, ignored on menu bars (builder method)
#[no_mangle] pub extern "C" fn AzMenu_withPopupPosition (menu: &mut AzMenu, position: AzMenuPopupPosition) -> AzMenu{ let mut menu = menu.swap_with_default(); menu.position = position; menu }
/* Error: Type is not stack allocated! */

/// Determines whether this context menu should pop up on a left, right or middle click
#[repr(C)] pub struct AzContextMenuMouseButton { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Specifies where a popup menu should appear relative to the cursor or clicked element. This positioning information is ignored for application-level menus (menu bars) and only applies to context menus and dropdowns.
#[repr(C)] pub struct AzMenuPopupPosition { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a single item in a menu. Menu items can be regular text items with labels and callbacks, visual separators, or line breaks for horizontal menu layouts.
#[repr(C)] pub struct AzMenuItem { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// A menu item with a text label and optional features. `StringMenuItem` represents a clickable menu entry that can have: - A text label - An optional keyboard accelerator (e.g., Ctrl+C) - An optional callback function - An optional icon (checkbox or image) - A state (normal, greyed, or disabled) - Child menu items (for sub-menus) # Examples ```rust,no_run use azul_core::menu::StringMenuItem; use azul_css::AzString; let item = StringMenuItem::new(AzString::from_const_str("Copy")); ```
#[repr(C)] pub struct AzStringMenuItem { pub ptr: *mut c_void }
/// Creates a new menu item
#[no_mangle] pub extern "C" fn AzStringMenuItem_new (label: AzAzString) -> AzStringMenuItem { let object: StringMenuItem = AzStringMenuItem::new(label); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzStringMenuItem { ptr } }
/// Adds a callback to the menu item
#[no_mangle] pub extern "C" fn AzStringMenuItem_setCallback (stringmenuitem: &mut AzStringMenuItem, data: AzRefAny, callback: AzCallbackType){ stringmenuitem.callback = AzOptionMenuCallback::Some(AzMenuCallback { data, callback: AzCallback { cb: callback } }); }
/// Adds a callback to the menu item
#[no_mangle] pub extern "C" fn AzStringMenuItem_withCallback (stringmenuitem: &mut AzStringMenuItem, data: AzRefAny, callback: AzCallbackType) -> AzStringMenuItem{ let mut stringmenuitem = stringmenuitem.swap_with_default(); stringmenuitem.callback = AzOptionMenuCallback::Some(AzMenuCallback { data, callback: AzCallback { cb: callback } }); stringmenuitem }
/// Adds a single child submenu to the current menu
#[no_mangle] pub extern "C" fn AzStringMenuItem_addChild (stringmenuitem: &mut AzStringMenuItem, child: AzMenuItem){ let mut m = stringmenuitem.children.clone().into_library_owned_vec(); m.push(child); stringmenuitem.children = m.into(); }
/// Adds a single child submenu to the current menu
#[no_mangle] pub extern "C" fn AzStringMenuItem_withChild (stringmenuitem: &mut AzStringMenuItem, child: AzMenuItem) -> AzStringMenuItem{ let mut stringmenuitem = stringmenuitem.swap_with_default(); let mut m = stringmenuitem.children.clone().into_library_owned_vec(); m.push(child); stringmenuitem.children = m.into(); stringmenuitem }
/// Sets the children of this menu
#[no_mangle] pub extern "C" fn AzStringMenuItem_setChildren (stringmenuitem: &mut AzStringMenuItem, children: AzMenuItemVec){ stringmenuitem.children = children; }
/// Adds a child submenu to the current menu
#[no_mangle] pub extern "C" fn AzStringMenuItem_withChildren (stringmenuitem: &mut AzStringMenuItem, children: AzMenuItemVec) -> AzStringMenuItem{ let mut stringmenuitem = stringmenuitem.swap_with_default(); stringmenuitem.children = children; stringmenuitem }
/* Error: Type is not stack allocated! */

/// Combination of virtual key codes that have to be pressed together
#[repr(C)] pub struct AzVirtualKeyCodeCombo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Similar to `dom.CallbackData`, stores some data + a callback to call when the menu is activated
#[repr(C)] pub struct AzMenuCallback { pub ptr: *mut c_void }
/// Creates a new `MenuCallback` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `MenuCallback::new()` constructor.
#[no_mangle] pub extern "C" fn AzMenuCallback_new (data: AzRefAny, callback: AzCallbackType) -> AzMenuCallback { let object: MenuCallback = AzMenuCallback { callback: AzCallback { cb: callback }, data }; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzMenuCallback { ptr } }
/* Error: Type is not stack allocated! */

/// Optional icon displayed next to a menu item. Icons can be either: - A checkbox (checked or unchecked) - A custom image (typically 16x16 pixels)
#[repr(C)] pub struct AzMenuItemIcon { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Describes the interactive state of a menu item. Menu items can be in different states that affect their appearance and behavior: - Normal items are clickable and render normally - Greyed items are visually disabled (greyed out) and non-clickable - Disabled items are non-clickable but retain normal appearance
#[repr(C)] pub struct AzMenuItemState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// One block of rules that applies a bunch of rules to a "path" in the style, i.e. `div#myid.myclass -> { ("justify-content", "center") }`
#[repr(C)] pub struct AzCssRuleBlock { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a full CSS path (i.e. the "div#id.class" selector belonging to a CSS "content group" (the following key-value block)). ```no_run,ignore "#div > .my_class:focus" == [ CssPathSelector::Type(NodeTypeTag::Div), CssPathSelector::PseudoSelector(CssPathPseudoSelector::LimitChildren), CssPathSelector::Class("my_class"), CssPathSelector::PseudoSelector(CssPathPseudoSelector::Focus), ]
#[repr(C)] pub struct AzCssPath { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssPathSelector>` struct
#[repr(C)] pub struct AzCssPathSelector { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents one parsed CSS key-value pair, such as `"width: 20px"` => `CssProperty::Width(LayoutWidth::px(20.0))`
#[repr(C)] pub struct AzCssProperty { pub ptr: *mut c_void }
/// Returns the key of the CSS property as a string, i.e. `background`
#[no_mangle] pub extern "C" fn AzCssProperty_getKeyString (cssproperty: &AzCssProperty) -> AzAzString{ cssproperty.key().into() }
/// Returns the value of the CSS property as a string, i.e. `linear-gradient(red, blue)`
#[no_mangle] pub extern "C" fn AzCssProperty_getValueString (cssproperty: &AzCssProperty) -> AzAzString{ cssproperty.value().into() }
/// Returns the CSS key-value pair as a string, i.e. `background: linear-gradient(red, blue)`
#[no_mangle] pub extern "C" fn AzCssProperty_getKeyValueString (cssproperty: &AzCssProperty) -> AzAzString{ cssproperty.format_css().into() }
/// Interpolates two CSS properties given a value `t` ranging from 0.0 to 1.0. The interpolation function can be set on the `context` (`Ease`, `Linear`, etc.).
#[no_mangle] pub extern "C" fn AzCssProperty_interpolate (cssproperty: &AzCssProperty, other: AzCssProperty, t: f32, context: AzInterpolateResolver) -> AzCssProperty{ cssproperty.interpolate(&other, t, &context) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssPathPseudoSelector>` struct
#[repr(C)] pub struct AzCssPathPseudoSelector { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssNthChildSelector>` struct
#[repr(C)] pub struct AzCssNthChildSelector { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssNthChildPattern>` struct
#[repr(C)] pub struct AzCssNthChildPattern { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Stylesheet>` struct
#[repr(C)] pub struct AzStylesheet { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Css stylesheet - contains a parsed CSS stylesheet in "rule blocks", i.e. blocks of key-value pairs associated with a selector path.
#[repr(C)] pub struct AzCss { pub ptr: *mut c_void }
/// Returns an empty CSS style
#[no_mangle] pub extern "C" fn AzCss_empty () -> AzCss { let object: Css = AzCss::empty(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzCss { ptr } }
/// Returns a CSS style parsed from a `String`
#[no_mangle] pub extern "C" fn AzCss_fromString (s: AzAzString) -> AzCss { let object: Css = AzCss::from_string(s); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzCss { ptr } }
/* Error: Type is not stack allocated! */

/// Contains one parsed `key: value` pair, static or dynamic
#[repr(C)] pub struct AzCssDeclaration { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// A `DynamicCssProperty` is a type of css property that can be changed on possibly every frame by the Rust code - for example to implement an `On::Hover` behaviour. The syntax for such a property looks like this: ```no_run,ignore #my_div { padding: var(--my_dynamic_property_id, 400px); } ``` Azul will register a dynamic property with the key "my_dynamic_property_id" and the default value of 400px. If the property gets overridden during one frame, the overridden property takes precedence. At runtime the style is immutable (which is a performance optimization - if we can assume that the property never changes at runtime), we can do some optimizations on it. Dynamic style properties can also be used for animations and conditional styles (i.e. `hover`, `focus`, etc.), thereby leading to cleaner code, since all of these special cases now use one single API.
#[repr(C)] pub struct AzDynamicCssProperty { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a CSS key (for example `"border-radius"` => `BorderRadius`). You can also derive this key from a `CssProperty` by calling `CssProperty::get_type()`.
#[repr(C)] pub struct AzCssPropertyType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents an animation timing function.
#[repr(C)] pub struct AzAnimationInterpolationFunction { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Signifies the type of a DOM node without carrying any associated data
#[repr(C)] pub struct AzNodeTypeTag { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// u8-based color, range 0 to 255 (similar to webrenders ColorU)
#[repr(C)] pub struct AzColorU { pub ptr: *mut c_void }
/// Creates a new `ColorU` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `ColorU::from_str()` constructor.
#[no_mangle] pub extern "C" fn AzColorU_fromStr (string: AzAzString) -> AzColorU { let object: ColorU = azul_css::parser::parse_css_color(string.as_str()).ok().unwrap_or(AzColorU::BLACK); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzColorU { ptr } }
/// Creates a new `ColorU` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `ColorU::transparent()` constructor.
#[no_mangle] pub extern "C" fn AzColorU_transparent () -> AzColorU { let object: ColorU = AzColorU::TRANSPARENT; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzColorU { ptr } }
/// Creates a new `ColorU` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `ColorU::white()` constructor.
#[no_mangle] pub extern "C" fn AzColorU_white () -> AzColorU { let object: ColorU = AzColorU::WHITE; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzColorU { ptr } }
/// Creates a new `ColorU` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `ColorU::black()` constructor.
#[no_mangle] pub extern "C" fn AzColorU_black () -> AzColorU { let object: ColorU = AzColorU::BLACK; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzColorU { ptr } }
/// Equivalent to the Rust `ColorU::to_hash()` function.
#[no_mangle] pub extern "C" fn AzColorU_toHash (coloru: &AzColorU) -> AzAzString{ coloru.to_hash().into() }
/* Error: Type is not stack allocated! */

/// Enum representing the metric associated with a number (px, pt, em, etc.)
#[repr(C)] pub struct AzSizeMetric { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<PixelValue>` struct
#[repr(C)] pub struct AzPixelValue { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Same as PixelValue, but doesn't allow a "%" sign
#[repr(C)] pub struct AzPixelValueNoPercent { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// What direction should a `box-shadow` be clipped in (inset or outset).
#[repr(C)] pub struct AzBoxShadowClipMode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `box-shadow` or `text-shadow` property.
#[repr(C)] pub struct AzStyleBoxShadow { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `mix-blend-mode` attribute, which determines how an element's content should blend with the content of the element's parent.
#[repr(C)] pub struct AzStyleMixBlendMode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleFilter>` struct
#[repr(C)] pub struct AzStyleFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBlur>` struct
#[repr(C)] pub struct AzStyleBlur { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleColorMatrix>` struct
#[repr(C)] pub struct AzStyleColorMatrix { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleFilterOffset>` struct
#[repr(C)] pub struct AzStyleFilterOffset { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleCompositeFilter>` struct
#[repr(C)] pub struct AzStyleCompositeFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents an `align-content` attribute, which aligns a flex container's lines within it when there is extra space in the cross-axis. Default: `Stretch`
#[repr(C)] pub struct AzLayoutAlignContent { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents an `align-items` attribute, which defines the default behavior for how flex items are laid out along the cross axis on the current line. Default: `Stretch`
#[repr(C)] pub struct AzLayoutAlignItems { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutBottom>` struct
#[repr(C)] pub struct AzLayoutBottom { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `box-sizing` attribute
#[repr(C)] pub struct AzLayoutBoxSizing { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `flex-direction` attribute, which establishes the main-axis, thus defining the direction flex items are placed in the flex container. Default: `Row`
#[repr(C)] pub struct AzLayoutFlexDirection { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `display` CSS property value
#[repr(C)] pub struct AzLayoutDisplay { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `flex-grow` attribute, which dictates what proportion of the remaining space in the flex container should be assigned to the item. Default: 0
#[repr(C)] pub struct AzLayoutFlexGrow { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `flex-shrink` attribute, which dictates what proportion of the negative space in the flex container should be removed from the item. Default: 1
#[repr(C)] pub struct AzLayoutFlexShrink { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `float` attribute
#[repr(C)] pub struct AzLayoutFloat { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutHeight>` struct
#[repr(C)] pub struct AzLayoutHeight { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `justify-content` attribute, which defines the alignment along the main axis. Default: `Start` (flex-start)
#[repr(C)] pub struct AzLayoutJustifyContent { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutLeft>` struct
#[repr(C)] pub struct AzLayoutLeft { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutMarginBottom>` struct
#[repr(C)] pub struct AzLayoutMarginBottom { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutMarginLeft>` struct
#[repr(C)] pub struct AzLayoutMarginLeft { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutMarginRight>` struct
#[repr(C)] pub struct AzLayoutMarginRight { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutMarginTop>` struct
#[repr(C)] pub struct AzLayoutMarginTop { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutMaxHeight>` struct
#[repr(C)] pub struct AzLayoutMaxHeight { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutMaxWidth>` struct
#[repr(C)] pub struct AzLayoutMaxWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutMinHeight>` struct
#[repr(C)] pub struct AzLayoutMinHeight { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutMinWidth>` struct
#[repr(C)] pub struct AzLayoutMinWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutPaddingBottom>` struct
#[repr(C)] pub struct AzLayoutPaddingBottom { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutPaddingLeft>` struct
#[repr(C)] pub struct AzLayoutPaddingLeft { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutPaddingRight>` struct
#[repr(C)] pub struct AzLayoutPaddingRight { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutPaddingTop>` struct
#[repr(C)] pub struct AzLayoutPaddingTop { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `position` attribute - default: `Static`
#[repr(C)] pub struct AzLayoutPosition { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutRight>` struct
#[repr(C)] pub struct AzLayoutRight { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutTop>` struct
#[repr(C)] pub struct AzLayoutTop { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutWidth>` struct
#[repr(C)] pub struct AzLayoutWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `flex-wrap` attribute, which determines whether flex items are forced onto one line or can wrap onto multiple lines. Default: `NoWrap`
#[repr(C)] pub struct AzLayoutFlexWrap { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents an `overflow-x` or `overflow-y` property. Determines what to do when content overflows an element's box.
#[repr(C)] pub struct AzLayoutOverflow { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper around an f32 value that is internally casted to an isize, in order to provide hash-ability (to avoid numerical instability).
#[repr(C)] pub struct AzFloatValue { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper around FloatValue, represents a percentage instead of just being a regular floating-point value, i.e `5` = `5%`
#[repr(C)] pub struct AzPercentageValue { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Enum representing the metric associated with an angle (deg, rad, etc.)
#[repr(C)] pub struct AzAngleMetric { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// FloatValue, but associated with a certain metric (i.e. deg, rad, etc.)
#[repr(C)] pub struct AzAngleValue { pub ptr: *mut c_void }
/// Equivalent to the Rust `AngleValue::get_degrees()` function.
#[no_mangle] pub extern "C" fn AzAngleValue_getDegrees (anglevalue: &AzAngleValue) -> f32{ anglevalue.to_degrees() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NormalizedLinearColorStop>` struct
#[repr(C)] pub struct AzNormalizedLinearColorStop { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NormalizedRadialColorStop>` struct
#[repr(C)] pub struct AzNormalizedRadialColorStop { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DirectionCorner>` struct
#[repr(C)] pub struct AzDirectionCorner { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DirectionCorners>` struct
#[repr(C)] pub struct AzDirectionCorners { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// CSS direction (necessary for gradients). Can either be a fixed angle or a direction ("to right" / "to left", etc.).
#[repr(C)] pub struct AzDirection { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Whether a `gradient` should be repeated or clamped to the edges.
#[repr(C)] pub struct AzExtendMode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LinearGradient>` struct
#[repr(C)] pub struct AzLinearGradient { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Shape>` struct
#[repr(C)] pub struct AzShape { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RadialGradientSize>` struct
#[repr(C)] pub struct AzRadialGradientSize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RadialGradient>` struct
#[repr(C)] pub struct AzRadialGradient { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ConicGradient>` struct
#[repr(C)] pub struct AzConicGradient { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBackgroundContent>` struct
#[repr(C)] pub struct AzStyleBackgroundContent { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<BackgroundPositionHorizontal>` struct
#[repr(C)] pub struct AzBackgroundPositionHorizontal { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<BackgroundPositionVertical>` struct
#[repr(C)] pub struct AzBackgroundPositionVertical { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBackgroundPosition>` struct
#[repr(C)] pub struct AzStyleBackgroundPosition { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBackgroundRepeat>` struct
#[repr(C)] pub struct AzStyleBackgroundRepeat { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBackgroundSize>` struct
#[repr(C)] pub struct AzStyleBackgroundSize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderBottomColor>` struct
#[repr(C)] pub struct AzStyleBorderBottomColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderBottomLeftRadius>` struct
#[repr(C)] pub struct AzStyleBorderBottomLeftRadius { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderBottomRightRadius>` struct
#[repr(C)] pub struct AzStyleBorderBottomRightRadius { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Style of a `border`: solid, double, dash, ridge, etc.
#[repr(C)] pub struct AzBorderStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderBottomStyle>` struct
#[repr(C)] pub struct AzStyleBorderBottomStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutBorderBottomWidth>` struct
#[repr(C)] pub struct AzLayoutBorderBottomWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderLeftColor>` struct
#[repr(C)] pub struct AzStyleBorderLeftColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderLeftStyle>` struct
#[repr(C)] pub struct AzStyleBorderLeftStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutBorderLeftWidth>` struct
#[repr(C)] pub struct AzLayoutBorderLeftWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderRightColor>` struct
#[repr(C)] pub struct AzStyleBorderRightColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderRightStyle>` struct
#[repr(C)] pub struct AzStyleBorderRightStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutBorderRightWidth>` struct
#[repr(C)] pub struct AzLayoutBorderRightWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderTopColor>` struct
#[repr(C)] pub struct AzStyleBorderTopColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderTopLeftRadius>` struct
#[repr(C)] pub struct AzStyleBorderTopLeftRadius { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderTopRightRadius>` struct
#[repr(C)] pub struct AzStyleBorderTopRightRadius { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderTopStyle>` struct
#[repr(C)] pub struct AzStyleBorderTopStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutBorderTopWidth>` struct
#[repr(C)] pub struct AzLayoutBorderTopWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Holds info necessary for layouting / styling -webkit-scrollbar properties.
#[repr(C)] pub struct AzScrollbarInfo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Scrollbar style for both horizontal and vertical scrollbars.
#[repr(C)] pub struct AzScrollbarStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `cursor` attribute, defining the mouse cursor to be displayed when pointing over an element.
#[repr(C)] pub struct AzStyleCursor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `font-family` attribute
#[repr(C)] pub struct AzStyleFontFamily { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `font-size` attribute
#[repr(C)] pub struct AzStyleFontSize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `letter-spacing` attribute
#[repr(C)] pub struct AzStyleLetterSpacing { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `line-height` attribute
#[repr(C)] pub struct AzStyleLineHeight { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `tab-width` attribute
#[repr(C)] pub struct AzStyleTabWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents an `opacity` attribute, a value from 0.0 to 1.0.
#[repr(C)] pub struct AzStyleOpacity { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `transform-origin` attribute
#[repr(C)] pub struct AzStyleTransformOrigin { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InterpolateResolver>` struct
#[repr(C)] pub struct AzInterpolateResolver { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `backface-visibility` attribute
#[repr(C)] pub struct AzStyleBackfaceVisibility { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents one component of a `transform` attribute
#[repr(C)] pub struct AzStyleTransform { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformMatrix2D>` struct
#[repr(C)] pub struct AzStyleTransformMatrix2D { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformMatrix3D>` struct
#[repr(C)] pub struct AzStyleTransformMatrix3D { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformTranslate2D>` struct
#[repr(C)] pub struct AzStyleTransformTranslate2D { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformTranslate3D>` struct
#[repr(C)] pub struct AzStyleTransformTranslate3D { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformRotate3D>` struct
#[repr(C)] pub struct AzStyleTransformRotate3D { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformScale2D>` struct
#[repr(C)] pub struct AzStyleTransformScale2D { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformScale3D>` struct
#[repr(C)] pub struct AzStyleTransformScale3D { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformSkew2D>` struct
#[repr(C)] pub struct AzStyleTransformSkew2D { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Horizontal text alignment enum (left, center, right) - default: `Left`
#[repr(C)] pub struct AzStyleTextAlign { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `color` attribute.
#[repr(C)] pub struct AzStyleTextColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `word-spacing` attribute
#[repr(C)] pub struct AzStyleWordSpacing { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for CssPropertyValue < StyleBoxShadow >
pub type AzStyleBoxShadowValue = AzCssPropertyValue<AzStyleBoxShadow>;

/// Type alias for CssPropertyValue < LayoutAlignContent >
pub type AzLayoutAlignContentValue = AzCssPropertyValue<AzLayoutAlignContent>;

/// Type alias for CssPropertyValue < LayoutAlignItems >
pub type AzLayoutAlignItemsValue = AzCssPropertyValue<AzLayoutAlignItems>;

/// Type alias for CssPropertyValue < LayoutBottom >
pub type AzLayoutBottomValue = AzCssPropertyValue<AzLayoutBottom>;

/// Type alias for CssPropertyValue < LayoutBoxSizing >
pub type AzLayoutBoxSizingValue = AzCssPropertyValue<AzLayoutBoxSizing>;

/// Type alias for CssPropertyValue < LayoutFlexDirection >
pub type AzLayoutFlexDirectionValue = AzCssPropertyValue<AzLayoutFlexDirection>;

/// Type alias for CssPropertyValue < LayoutDisplay >
pub type AzLayoutDisplayValue = AzCssPropertyValue<AzLayoutDisplay>;

/// Type alias for CssPropertyValue < LayoutFlexGrow >
pub type AzLayoutFlexGrowValue = AzCssPropertyValue<AzLayoutFlexGrow>;

/// Type alias for CssPropertyValue < LayoutFlexShrink >
pub type AzLayoutFlexShrinkValue = AzCssPropertyValue<AzLayoutFlexShrink>;

/// Type alias for CssPropertyValue < LayoutFloat >
pub type AzLayoutFloatValue = AzCssPropertyValue<AzLayoutFloat>;

/// Type alias for CssPropertyValue < LayoutHeight >
pub type AzLayoutHeightValue = AzCssPropertyValue<AzLayoutHeight>;

/// Type alias for CssPropertyValue < LayoutJustifyContent >
pub type AzLayoutJustifyContentValue = AzCssPropertyValue<AzLayoutJustifyContent>;

/// Type alias for CssPropertyValue < LayoutLeft >
pub type AzLayoutLeftValue = AzCssPropertyValue<AzLayoutLeft>;

/// Type alias for CssPropertyValue < LayoutMarginBottom >
pub type AzLayoutMarginBottomValue = AzCssPropertyValue<AzLayoutMarginBottom>;

/// Type alias for CssPropertyValue < LayoutMarginLeft >
pub type AzLayoutMarginLeftValue = AzCssPropertyValue<AzLayoutMarginLeft>;

/// Type alias for CssPropertyValue < LayoutMarginRight >
pub type AzLayoutMarginRightValue = AzCssPropertyValue<AzLayoutMarginRight>;

/// Type alias for CssPropertyValue < LayoutMarginTop >
pub type AzLayoutMarginTopValue = AzCssPropertyValue<AzLayoutMarginTop>;

/// Type alias for CssPropertyValue < LayoutMaxHeight >
pub type AzLayoutMaxHeightValue = AzCssPropertyValue<AzLayoutMaxHeight>;

/// Type alias for CssPropertyValue < LayoutMaxWidth >
pub type AzLayoutMaxWidthValue = AzCssPropertyValue<AzLayoutMaxWidth>;

/// Type alias for CssPropertyValue < LayoutMinHeight >
pub type AzLayoutMinHeightValue = AzCssPropertyValue<AzLayoutMinHeight>;

/// Type alias for CssPropertyValue < LayoutMinWidth >
pub type AzLayoutMinWidthValue = AzCssPropertyValue<AzLayoutMinWidth>;

/// Type alias for CssPropertyValue < LayoutPaddingBottom >
pub type AzLayoutPaddingBottomValue = AzCssPropertyValue<AzLayoutPaddingBottom>;

/// Type alias for CssPropertyValue < LayoutPaddingLeft >
pub type AzLayoutPaddingLeftValue = AzCssPropertyValue<AzLayoutPaddingLeft>;

/// Type alias for CssPropertyValue < LayoutPaddingRight >
pub type AzLayoutPaddingRightValue = AzCssPropertyValue<AzLayoutPaddingRight>;

/// Type alias for CssPropertyValue < LayoutPaddingTop >
pub type AzLayoutPaddingTopValue = AzCssPropertyValue<AzLayoutPaddingTop>;

/// Type alias for CssPropertyValue < LayoutPosition >
pub type AzLayoutPositionValue = AzCssPropertyValue<AzLayoutPosition>;

/// Type alias for CssPropertyValue < LayoutRight >
pub type AzLayoutRightValue = AzCssPropertyValue<AzLayoutRight>;

/// Type alias for CssPropertyValue < LayoutTop >
pub type AzLayoutTopValue = AzCssPropertyValue<AzLayoutTop>;

/// Type alias for CssPropertyValue < LayoutWidth >
pub type AzLayoutWidthValue = AzCssPropertyValue<AzLayoutWidth>;

/// Type alias for CssPropertyValue < LayoutFlexWrap >
pub type AzLayoutFlexWrapValue = AzCssPropertyValue<AzLayoutFlexWrap>;

/// Type alias for CssPropertyValue < LayoutOverflow >
pub type AzLayoutOverflowValue = AzCssPropertyValue<AzLayoutOverflow>;

/// Type alias for CssPropertyValue < ScrollbarStyle >
pub type AzScrollbarStyleValue = AzCssPropertyValue<AzScrollbarStyle>;

/// Type alias for CssPropertyValue < StyleBackgroundContentVec >
pub type AzStyleBackgroundContentVecValue = AzCssPropertyValue<AzStyleBackgroundContentVec>;

/// Type alias for CssPropertyValue < StyleBackgroundPositionVec >
pub type AzStyleBackgroundPositionVecValue = AzCssPropertyValue<AzStyleBackgroundPositionVec>;

/// Type alias for CssPropertyValue < StyleBackgroundRepeatVec >
pub type AzStyleBackgroundRepeatVecValue = AzCssPropertyValue<AzStyleBackgroundRepeatVec>;

/// Type alias for CssPropertyValue < StyleBackgroundSizeVec >
pub type AzStyleBackgroundSizeVecValue = AzCssPropertyValue<AzStyleBackgroundSizeVec>;

/// Type alias for CssPropertyValue < StyleBorderBottomColor >
pub type AzStyleBorderBottomColorValue = AzCssPropertyValue<AzStyleBorderBottomColor>;

/// Type alias for CssPropertyValue < StyleBorderBottomLeftRadius >
pub type AzStyleBorderBottomLeftRadiusValue = AzCssPropertyValue<AzStyleBorderBottomLeftRadius>;

/// Type alias for CssPropertyValue < StyleBorderBottomRightRadius >
pub type AzStyleBorderBottomRightRadiusValue = AzCssPropertyValue<AzStyleBorderBottomRightRadius>;

/// Type alias for CssPropertyValue < StyleBorderBottomStyle >
pub type AzStyleBorderBottomStyleValue = AzCssPropertyValue<AzStyleBorderBottomStyle>;

/// Type alias for CssPropertyValue < LayoutBorderBottomWidth >
pub type AzLayoutBorderBottomWidthValue = AzCssPropertyValue<AzLayoutBorderBottomWidth>;

/// Type alias for CssPropertyValue < StyleBorderLeftColor >
pub type AzStyleBorderLeftColorValue = AzCssPropertyValue<AzStyleBorderLeftColor>;

/// Type alias for CssPropertyValue < StyleBorderLeftStyle >
pub type AzStyleBorderLeftStyleValue = AzCssPropertyValue<AzStyleBorderLeftStyle>;

/// Type alias for CssPropertyValue < LayoutBorderLeftWidth >
pub type AzLayoutBorderLeftWidthValue = AzCssPropertyValue<AzLayoutBorderLeftWidth>;

/// Type alias for CssPropertyValue < StyleBorderRightColor >
pub type AzStyleBorderRightColorValue = AzCssPropertyValue<AzStyleBorderRightColor>;

/// Type alias for CssPropertyValue < StyleBorderRightStyle >
pub type AzStyleBorderRightStyleValue = AzCssPropertyValue<AzStyleBorderRightStyle>;

/// Type alias for CssPropertyValue < LayoutBorderRightWidth >
pub type AzLayoutBorderRightWidthValue = AzCssPropertyValue<AzLayoutBorderRightWidth>;

/// Type alias for CssPropertyValue < StyleBorderTopColor >
pub type AzStyleBorderTopColorValue = AzCssPropertyValue<AzStyleBorderTopColor>;

/// Type alias for CssPropertyValue < StyleBorderTopLeftRadius >
pub type AzStyleBorderTopLeftRadiusValue = AzCssPropertyValue<AzStyleBorderTopLeftRadius>;

/// Type alias for CssPropertyValue < StyleBorderTopRightRadius >
pub type AzStyleBorderTopRightRadiusValue = AzCssPropertyValue<AzStyleBorderTopRightRadius>;

/// Type alias for CssPropertyValue < StyleBorderTopStyle >
pub type AzStyleBorderTopStyleValue = AzCssPropertyValue<AzStyleBorderTopStyle>;

/// Type alias for CssPropertyValue < LayoutBorderTopWidth >
pub type AzLayoutBorderTopWidthValue = AzCssPropertyValue<AzLayoutBorderTopWidth>;

/// Type alias for CssPropertyValue < StyleCursor >
pub type AzStyleCursorValue = AzCssPropertyValue<AzStyleCursor>;

/// Type alias for CssPropertyValue < StyleFontFamilyVec >
pub type AzStyleFontFamilyVecValue = AzCssPropertyValue<AzStyleFontFamilyVec>;

/// Type alias for CssPropertyValue < StyleFontSize >
pub type AzStyleFontSizeValue = AzCssPropertyValue<AzStyleFontSize>;

/// Type alias for CssPropertyValue < StyleLetterSpacing >
pub type AzStyleLetterSpacingValue = AzCssPropertyValue<AzStyleLetterSpacing>;

/// Type alias for CssPropertyValue < StyleLineHeight >
pub type AzStyleLineHeightValue = AzCssPropertyValue<AzStyleLineHeight>;

/// Type alias for CssPropertyValue < StyleTabWidth >
pub type AzStyleTabWidthValue = AzCssPropertyValue<AzStyleTabWidth>;

/// Type alias for CssPropertyValue < StyleTextAlign >
pub type AzStyleTextAlignValue = AzCssPropertyValue<AzStyleTextAlign>;

/// Type alias for CssPropertyValue < StyleTextColor >
pub type AzStyleTextColorValue = AzCssPropertyValue<AzStyleTextColor>;

/// Type alias for CssPropertyValue < StyleWordSpacing >
pub type AzStyleWordSpacingValue = AzCssPropertyValue<AzStyleWordSpacing>;

/// Type alias for CssPropertyValue < StyleOpacity >
pub type AzStyleOpacityValue = AzCssPropertyValue<AzStyleOpacity>;

/// Type alias for CssPropertyValue < StyleTransformVec >
pub type AzStyleTransformVecValue = AzCssPropertyValue<AzStyleTransformVec>;

/// Type alias for CssPropertyValue < StyleTransformOrigin >
pub type AzStyleTransformOriginValue = AzCssPropertyValue<AzStyleTransformOrigin>;

/// Type alias for CssPropertyValue < StylePerspectiveOrigin >
pub type AzStylePerspectiveOriginValue = AzCssPropertyValue<AzStylePerspectiveOrigin>;

/// Type alias for CssPropertyValue < StyleBackfaceVisibility >
pub type AzStyleBackfaceVisibilityValue = AzCssPropertyValue<AzStyleBackfaceVisibility>;

/// Type alias for CssPropertyValue < StyleMixBlendMode >
pub type AzStyleMixBlendModeValue = AzCssPropertyValue<AzStyleMixBlendMode>;

/// Type alias for CssPropertyValue < StyleFilterVec >
pub type AzStyleFilterVecValue = AzCssPropertyValue<AzStyleFilterVec>;

/// Type alias for CssPropertyValue < StyleVisibility >
pub type AzStyleVisibilityValue = AzCssPropertyValue<AzStyleVisibility>;

/// Type alias for CssPropertyValue < ColumnRuleStyle >
pub type AzColumnRuleStyleValue = AzCssPropertyValue<AzColumnRuleStyle>;

/// Type alias for CssPropertyValue < GridAutoTracks >
pub type AzLayoutGridAutoColumnsValue = AzCssPropertyValue<AzGridAutoTracks>;

/// Type alias for CssPropertyValue < LayoutGap >
pub type AzLayoutGapValue = AzCssPropertyValue<AzLayoutGap>;

/// Type alias for CssPropertyValue < ShapeOutside >
pub type AzShapeOutsideValue = AzCssPropertyValue<AzShapeOutside>;

/// Type alias for CssPropertyValue < BoxDecorationBreak >
pub type AzBoxDecorationBreakValue = AzCssPropertyValue<AzBoxDecorationBreak>;

/// Type alias for CssPropertyValue < BreakInside >
pub type AzBreakInsideValue = AzCssPropertyValue<AzBreakInside>;

/// Type alias for CssPropertyValue < StyleHyphens >
pub type AzStyleHyphensValue = AzCssPropertyValue<AzStyleHyphens>;

/// Type alias for CssPropertyValue < LayoutZIndex >
pub type AzLayoutZIndexValue = AzCssPropertyValue<AzLayoutZIndex>;

/// Type alias for CssPropertyValue < ColumnRuleColor >
pub type AzColumnRuleColorValue = AzCssPropertyValue<AzColumnRuleColor>;

/// Type alias for CssPropertyValue < CounterReset >
pub type AzCounterResetValue = AzCssPropertyValue<AzCounterReset>;

/// Type alias for CssPropertyValue < LayoutScrollbarWidth >
pub type AzLayoutScrollbarWidthValue = AzCssPropertyValue<AzLayoutScrollbarWidth>;

/// Type alias for CssPropertyValue < PageBreak >
pub type AzPageBreakValue = AzCssPropertyValue<AzPageBreak>;

/// Type alias for CssPropertyValue < LayoutFlexBasis >
pub type AzLayoutFlexBasisValue = AzCssPropertyValue<AzLayoutFlexBasis>;

/// Type alias for CssPropertyValue < CounterIncrement >
pub type AzCounterIncrementValue = AzCssPropertyValue<AzCounterIncrement>;

/// Type alias for CssPropertyValue < ColumnFill >
pub type AzColumnFillValue = AzCssPropertyValue<AzColumnFill>;

/// Type alias for CssPropertyValue < Orphans >
pub type AzOrphansValue = AzCssPropertyValue<AzOrphans>;

/// Type alias for CssPropertyValue < ColumnWidth >
pub type AzColumnWidthValue = AzCssPropertyValue<AzColumnWidth>;

/// Type alias for CssPropertyValue < LayoutJustifySelf >
pub type AzLayoutJustifySelfValue = AzCssPropertyValue<AzLayoutJustifySelf>;

/// Type alias for CssPropertyValue < ShapeMargin >
pub type AzShapeMarginValue = AzCssPropertyValue<AzShapeMargin>;

/// Type alias for CssPropertyValue < GridPlacement >
pub type AzLayoutGridColumnValue = AzCssPropertyValue<AzGridPlacement>;

/// Type alias for CssPropertyValue < ColumnSpan >
pub type AzColumnSpanValue = AzCssPropertyValue<AzColumnSpan>;

/// Type alias for CssPropertyValue < LayoutAlignSelf >
pub type AzLayoutAlignSelfValue = AzCssPropertyValue<AzLayoutAlignSelf>;

/// Type alias for CssPropertyValue < Widows >
pub type AzWidowsValue = AzCssPropertyValue<AzWidows>;

/// Type alias for CssPropertyValue < ColumnCount >
pub type AzColumnCountValue = AzCssPropertyValue<AzColumnCount>;

/// Type alias for CssPropertyValue < StyleScrollbarColor >
pub type AzStyleScrollbarColorValue = AzCssPropertyValue<AzStyleScrollbarColor>;

/// Type alias for CssPropertyValue < FlowInto >
pub type AzFlowIntoValue = AzCssPropertyValue<AzFlowInto>;

/// Type alias for CssPropertyValue < StyleFontFamilyVec >
pub type AzStyleFontValue = AzCssPropertyValue<AzStyleFontFamilyVec>;

/// Type alias for CssPropertyValue < GridTemplate >
pub type AzLayoutGridTemplateRowsValue = AzCssPropertyValue<AzGridTemplate>;

/// Type alias for CssPropertyValue < LayoutJustifyItems >
pub type AzLayoutJustifyItemsValue = AzCssPropertyValue<AzLayoutJustifyItems>;

/// Type alias for CssPropertyValue < LayoutTextJustify >
pub type AzLayoutTextJustifyValue = AzCssPropertyValue<AzLayoutTextJustify>;

/// Type alias for CssPropertyValue < SelectionColor >
pub type AzSelectionColorValue = AzCssPropertyValue<AzSelectionColor>;

/// Type alias for CssPropertyValue < LayoutWritingMode >
pub type AzLayoutWritingModeValue = AzCssPropertyValue<AzLayoutWritingMode>;

/// Type alias for CssPropertyValue < StyleDirection >
pub type AzStyleDirectionValue = AzCssPropertyValue<AzStyleDirection>;

/// Type alias for CssPropertyValue < LayoutColumnGap >
pub type AzLayoutColumnGapValue = AzCssPropertyValue<AzLayoutColumnGap>;

/// Type alias for CssPropertyValue < StringSet >
pub type AzStringSetValue = AzCssPropertyValue<AzStringSet>;

/// Type alias for CssPropertyValue < GridTemplate >
pub type AzLayoutGridTemplateColumnsValue = AzCssPropertyValue<AzGridTemplate>;

/// Type alias for CssPropertyValue < ShapeImageThreshold >
pub type AzShapeImageThresholdValue = AzCssPropertyValue<AzShapeImageThreshold>;

/// Type alias for CssPropertyValue < CaretAnimationDuration >
pub type AzCaretAnimationDurationValue = AzCssPropertyValue<AzCaretAnimationDuration>;

/// Type alias for CssPropertyValue < LayoutClear >
pub type AzLayoutClearValue = AzCssPropertyValue<AzLayoutClear>;

/// Type alias for CssPropertyValue < SelectionBackgroundColor >
pub type AzSelectionBackgroundColorValue = AzCssPropertyValue<AzSelectionBackgroundColor>;

/// Type alias for CssPropertyValue < GridAutoTracks >
pub type AzLayoutGridAutoRowsValue = AzCssPropertyValue<AzGridAutoTracks>;

/// Type alias for CssPropertyValue < StyleWhiteSpace >
pub type AzStyleWhiteSpaceValue = AzCssPropertyValue<AzStyleWhiteSpace>;

/// Type alias for CssPropertyValue < CaretColor >
pub type AzCaretColorValue = AzCssPropertyValue<AzCaretColor>;

/// Type alias for CssPropertyValue < LayoutGridAutoFlow >
pub type AzLayoutGridAutoFlowValue = AzCssPropertyValue<AzLayoutGridAutoFlow>;

/// Type alias for CssPropertyValue < StyleTextDecoration >
pub type AzStyleTextDecorationValue = AzCssPropertyValue<AzStyleTextDecoration>;

/// Type alias for CssPropertyValue < Content >
pub type AzContentValue = AzCssPropertyValue<AzContent>;

/// Type alias for CssPropertyValue < FlowFrom >
pub type AzFlowFromValue = AzCssPropertyValue<AzFlowFrom>;

/// Type alias for CssPropertyValue < ColumnRuleWidth >
pub type AzColumnRuleWidthValue = AzCssPropertyValue<AzColumnRuleWidth>;

/// Type alias for CssPropertyValue < StyleUserSelect >
pub type AzStyleUserSelectValue = AzCssPropertyValue<AzStyleUserSelect>;

/// Type alias for CssPropertyValue < LayoutRowGap >
pub type AzLayoutRowGapValue = AzCssPropertyValue<AzLayoutRowGap>;

/// Type alias for CssPropertyValue < GridPlacement >
pub type AzLayoutGridRowValue = AzCssPropertyValue<AzGridPlacement>;

/// Generic CSS property value that can be Auto, None, Initial, Inherit, or an exact value
#[repr(C)] pub struct AzCssPropertyValue { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CounterReset>` struct
#[repr(C)] pub struct AzCounterReset { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a grid line position (start or end)
#[repr(C)] pub struct AzGridLine { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `perspective-origin` attribute
#[repr(C)] pub struct AzStylePerspectiveOrigin { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `z-index` attribute - controls stacking order of positioned elements
#[repr(C)] pub struct AzLayoutZIndex { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents `justify-items` for grid containers
#[repr(C)] pub struct AzLayoutJustifyItems { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SelectionBackgroundColor>` struct
#[repr(C)] pub struct AzSelectionBackgroundColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColumnRuleColor>` struct
#[repr(C)] pub struct AzColumnRuleColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// FontRef is a reference-counted pointer to a parsed font. It holds a *const c_void that points to the actual parsed font data (typically a ParsedFont from the layout crate). The parsed data is managed via atomic reference counting, allowing safe sharing across threads without duplicating the font data.
#[repr(C)] pub struct AzFontRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents the detected platform.
#[repr(C)] pub struct AzPlatform { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColumnSpan>` struct
#[repr(C)] pub struct AzColumnSpan { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `clear` attribute
#[repr(C)] pub struct AzLayoutClear { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Only used for calculations: Point coordinate (x, y) in layout space.
#[repr(C)] pub struct AzLayoutPoint { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// How to handle white space inside an element.
#[repr(C)] pub struct AzStyleWhiteSpace { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Common system metrics for UI element sizing and spacing.
#[repr(C)] pub struct AzSystemMetrics { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// A unified collection of discovered system style properties.
#[repr(C)] pub struct AzSystemStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Font metrics structure containing all font-related measurements from the font file tables (head, hhea, and os/2 tables).
#[repr(C)] pub struct AzFontMetrics { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `break-inside` CSS property value.
#[repr(C)] pub struct AzBreakInside { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents an `align-self` attribute, which allows the default alignment (or the one specified by align-items) to be overridden for individual flex items. Default: `Auto`
#[repr(C)] pub struct AzLayoutAlignSelf { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CaretAnimationDuration>` struct
#[repr(C)] pub struct AzCaretAnimationDuration { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColumnRuleStyle>` struct
#[repr(C)] pub struct AzColumnRuleStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgPoint>` struct
#[repr(C)] pub struct AzSvgPoint { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents `grid-row` or `grid-column` (start / end)
#[repr(C)] pub struct AzGridPlacement { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StringSet>` struct
#[repr(C)] pub struct AzStringSet { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ShapeOutside>` struct
#[repr(C)] pub struct AzShapeOutside { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgVector>` struct
#[repr(C)] pub struct AzSvgVector { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents the detected Linux Desktop Environment.
#[repr(C)] pub struct AzDesktopEnvironment { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColumnCount>` struct
#[repr(C)] pub struct AzColumnCount { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `writing-mode` attribute
#[repr(C)] pub struct AzLayoutWritingMode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgRect>` struct
#[repr(C)] pub struct AzSvgRect { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Common system colors used for UI elements.
#[repr(C)] pub struct AzSystemColors { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Only used for calculations: Rectangle (x, y, width, height) in layout space.
#[repr(C)] pub struct AzLayoutRect { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Controls whether the user can select text. Used to prevent accidental text selection on UI controls like buttons.
#[repr(C)] pub struct AzStyleUserSelect { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FlowInto>` struct
#[repr(C)] pub struct AzFlowInto { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents `grid-template-columns` or `grid-template-rows`
#[repr(C)] pub struct AzGridTemplate { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents `justify-self` for grid items
#[repr(C)] pub struct AzLayoutJustifySelf { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Content>` struct
#[repr(C)] pub struct AzContent { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Hyphenation rules.
#[repr(C)] pub struct AzStyleHyphens { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutGap>` struct
#[repr(C)] pub struct AzLayoutGap { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Text direction.
#[repr(C)] pub struct AzStyleDirection { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `flex-basis` attribute
#[repr(C)] pub struct AzLayoutFlexBasis { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ShapeMargin>` struct
#[repr(C)] pub struct AzShapeMargin { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutTextJustify>` struct
#[repr(C)] pub struct AzLayoutTextJustify { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColumnWidth>` struct
#[repr(C)] pub struct AzColumnWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CounterIncrement>` struct
#[repr(C)] pub struct AzCounterIncrement { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `box-decoration-break` CSS property value.
#[repr(C)] pub struct AzBoxDecorationBreak { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgCubicCurve>` struct
#[repr(C)] pub struct AzSvgCubicCurve { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgQuadraticCurve>` struct
#[repr(C)] pub struct AzSvgQuadraticCurve { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SelectionColor>` struct
#[repr(C)] pub struct AzSelectionColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `visibility` attribute, controlling element visibility.
#[repr(C)] pub struct AzStyleVisibility { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// The overall theme type.
#[repr(C)] pub struct AzTheme { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ShapeImageThreshold>` struct
#[repr(C)] pub struct AzShapeImageThreshold { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents the `grid-auto-flow` property
#[repr(C)] pub struct AzLayoutGridAutoFlow { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColumnRuleWidth>` struct
#[repr(C)] pub struct AzColumnRuleWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AzString>` struct
#[repr(C)] pub struct AzAzString { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Text decoration (underline, overline, line-through).
#[repr(C)] pub struct AzStyleTextDecoration { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CaretColor>` struct
#[repr(C)] pub struct AzCaretColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Only used for calculations: Size (width, height) in layout space.
#[repr(C)] pub struct AzLayoutSize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColumnFill>` struct
#[repr(C)] pub struct AzColumnFill { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Common system font settings.
#[repr(C)] pub struct AzSystemFonts { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FlowFrom>` struct
#[repr(C)] pub struct AzFlowFrom { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for GridTemplate
pub type AzGridAutoTracks = AzGridTemplate<>;

/// Represents a `break-before` or `break-after` CSS property value.
#[repr(C)] pub struct AzPageBreak { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents the standard `scrollbar-width` property.
#[repr(C)] pub struct AzLayoutScrollbarWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents the standard `scrollbar-color` property.
#[repr(C)] pub struct AzStyleScrollbarColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Ribbon>` struct
#[repr(C)] pub struct AzRibbon { pub ptr: *mut c_void }
/// Equivalent to the Rust `Ribbon::dom()` function.
#[no_mangle] pub extern "C" fn AzRibbon_dom (ribbon: &mut AzRibbon, callback: AzRibbonOnTabClickedCallback, data: AzRefAny) -> AzDom{ ribbon.dom(callback, data) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RibbonOnTabClickedCallback>` struct
#[repr(C)] pub struct AzRibbonOnTabClickedCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (&mut RefAny , &mut CallbackInfo , i32) -> Update
pub type AzRibbonOnTabClickedCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Button>` struct
#[repr(C)] pub struct AzButton { pub ptr: *mut c_void }
/// Creates a new labeled button
#[no_mangle] pub extern "C" fn AzButton_new (label: AzAzString) -> AzButton { let object: Button = AzButton::new(label); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzButton { ptr } }
/// Equivalent to the Rust `Button::set_on_click()` function.
#[no_mangle] pub extern "C" fn AzButton_setOnClick (button: &mut AzButton, data: AzRefAny, callback: AzCallbackType){ button.set_on_click(data, callback); }
/// Equivalent to the Rust `Button::with_on_click()` function.
#[no_mangle] pub extern "C" fn AzButton_withOnClick (button: &mut AzButton, data: AzRefAny, callback: AzCallbackType) -> AzButton{ let mut button = button.swap_with_default(); button.set_on_click(data, callback); button }
/// Equivalent to the Rust `Button::dom()` function.
#[no_mangle] pub extern "C" fn AzButton_dom (button: &mut AzButton) -> AzDom{ button.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ButtonOnClick>` struct
#[repr(C)] pub struct AzButtonOnClick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FileInput>` struct
#[repr(C)] pub struct AzFileInput { pub ptr: *mut c_void }
/// Creates a new file input button
#[no_mangle] pub extern "C" fn AzFileInput_new (path: AzOptionAzString) -> AzFileInput { let object: FileInput = AzFileInput::new(path); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzFileInput { ptr } }
/// Equivalent to the Rust `FileInput::set_default_text()` function.
#[no_mangle] pub extern "C" fn AzFileInput_setDefaultText (fileinput: &mut AzFileInput, default_text: AzAzString){ fileinput.set_default_text(default_text); }
/// Equivalent to the Rust `FileInput::with_default_text()` function.
#[no_mangle] pub extern "C" fn AzFileInput_withDefaultText (fileinput: &mut AzFileInput, default_text: AzAzString) -> AzFileInput{ let mut fileinput = fileinput.swap_with_default(); fileinput.set_default_text(default_text); fileinput }
/// Equivalent to the Rust `FileInput::set_on_path_change()` function.
#[no_mangle] pub extern "C" fn AzFileInput_setOnPathChange (fileinput: &mut AzFileInput, data: AzRefAny, callback: AzFileInputOnPathChangeCallbackType){ fileinput.set_on_path_change(data, callback); }
/// Equivalent to the Rust `FileInput::with_on_path_change()` function.
#[no_mangle] pub extern "C" fn AzFileInput_withOnPathChange (fileinput: &mut AzFileInput, data: AzRefAny, callback: AzFileInputOnPathChangeCallbackType) -> AzFileInput{ let mut fileinput = fileinput.swap_with_default(); fileinput.set_on_path_change(data, callback); fileinput }
/// Equivalent to the Rust `FileInput::dom()` function.
#[no_mangle] pub extern "C" fn AzFileInput_dom (fileinput: &mut AzFileInput) -> AzDom{ fileinput.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FileInputStateWrapper>` struct
#[repr(C)] pub struct AzFileInputStateWrapper { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FileInputState>` struct
#[repr(C)] pub struct AzFileInputState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FileInputOnPathChange>` struct
#[repr(C)] pub struct AzFileInputOnPathChange { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FileInputOnPathChangeCallback>` struct
#[repr(C)] pub struct AzFileInputOnPathChangeCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (&mut RefAny , &mut CallbackInfo , &FileInputState) -> Update
pub type AzFileInputOnPathChangeCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CheckBox>` struct
#[repr(C)] pub struct AzCheckBox { pub ptr: *mut c_void }
/// Creates a new checkbox, disabled or enabled
#[no_mangle] pub extern "C" fn AzCheckBox_new (checked: bool) -> AzCheckBox { let object: CheckBox = AzCheckBox::new(checked); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzCheckBox { ptr } }
/// Equivalent to the Rust `CheckBox::set_on_toggle()` function.
#[no_mangle] pub extern "C" fn AzCheckBox_setOnToggle (checkbox: &mut AzCheckBox, data: AzRefAny, callback: AzCheckBoxOnToggleCallbackType){ checkbox.set_on_toggle(data, callback); }
/// Equivalent to the Rust `CheckBox::with_on_toggle()` function.
#[no_mangle] pub extern "C" fn AzCheckBox_withOnToggle (checkbox: &mut AzCheckBox, data: AzRefAny, callback: AzCheckBoxOnToggleCallbackType) -> AzCheckBox{ let mut checkbox = checkbox.swap_with_default(); checkbox.set_on_toggle(data, callback); checkbox }
/// Equivalent to the Rust `CheckBox::dom()` function.
#[no_mangle] pub extern "C" fn AzCheckBox_dom (checkbox: &mut AzCheckBox) -> AzDom{ checkbox.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CheckBoxStateWrapper>` struct
#[repr(C)] pub struct AzCheckBoxStateWrapper { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CheckBoxOnToggle>` struct
#[repr(C)] pub struct AzCheckBoxOnToggle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CheckBoxOnToggleCallback>` struct
#[repr(C)] pub struct AzCheckBoxOnToggleCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (&mut RefAny , &mut CallbackInfo , &CheckBoxState) -> Update
pub type AzCheckBoxOnToggleCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CheckBoxState>` struct
#[repr(C)] pub struct AzCheckBoxState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Label>` struct
#[repr(C)] pub struct AzLabel { pub ptr: *mut c_void }
/// Creates a new `Label` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Label::new()` constructor.
#[no_mangle] pub extern "C" fn AzLabel_new (text: AzAzString) -> AzLabel { let object: Label = AzLabel::new(text); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzLabel { ptr } }
/// Equivalent to the Rust `Label::dom()` function.
#[no_mangle] pub extern "C" fn AzLabel_dom (label: &mut AzLabel) -> AzDom{ label.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColorInput>` struct
#[repr(C)] pub struct AzColorInput { pub ptr: *mut c_void }
/// Creates a new `ColorInput` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `ColorInput::new()` constructor.
#[no_mangle] pub extern "C" fn AzColorInput_new (color: AzColorU) -> AzColorInput { let object: ColorInput = AzColorInput::new(color); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzColorInput { ptr } }
/// Equivalent to the Rust `ColorInput::set_on_value_change()` function.
#[no_mangle] pub extern "C" fn AzColorInput_setOnValueChange (colorinput: &mut AzColorInput, data: AzRefAny, callback: AzColorInputOnValueChangeCallbackType){ colorinput.set_on_value_change(data, callback) }
/// Equivalent to the Rust `ColorInput::with_on_value_change()` function.
#[no_mangle] pub extern "C" fn AzColorInput_withOnValueChange (colorinput: &mut AzColorInput, data: AzRefAny, callback: AzColorInputOnValueChangeCallbackType) -> AzColorInput{ let mut colorinput = colorinput.swap_with_default(); colorinput.set_on_value_change(data, callback); colorinput }
/// Equivalent to the Rust `ColorInput::dom()` function.
#[no_mangle] pub extern "C" fn AzColorInput_dom (colorinput: &mut AzColorInput) -> AzDom{ colorinput.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColorInputStateWrapper>` struct
#[repr(C)] pub struct AzColorInputStateWrapper { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColorInputState>` struct
#[repr(C)] pub struct AzColorInputState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColorInputOnValueChange>` struct
#[repr(C)] pub struct AzColorInputOnValueChange { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColorInputOnValueChangeCallback>` struct
#[repr(C)] pub struct AzColorInputOnValueChangeCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (&mut RefAny , &mut CallbackInfo , &ColorInputState) -> Update
pub type AzColorInputOnValueChangeCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInput>` struct
#[repr(C)] pub struct AzTextInput { pub ptr: *mut c_void }
/// Creates a new `TextInput` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `TextInput::new()` constructor.
#[no_mangle] pub extern "C" fn AzTextInput_new () -> AzTextInput { let object: TextInput = AzTextInput::new(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTextInput { ptr } }
/// Equivalent to the Rust `TextInput::set_text()` function.
#[no_mangle] pub extern "C" fn AzTextInput_setText (textinput: &mut AzTextInput, text: AzAzString){ textinput.set_text(text) }
/// Equivalent to the Rust `TextInput::with_text()` function.
#[no_mangle] pub extern "C" fn AzTextInput_withText (textinput: &mut AzTextInput, text: AzAzString) -> AzTextInput{ textinput.with_text(text) }
/// Equivalent to the Rust `TextInput::set_placeholder()` function.
#[no_mangle] pub extern "C" fn AzTextInput_setPlaceholder (textinput: &mut AzTextInput, text: AzAzString){ textinput.set_placeholder(text) }
/// Equivalent to the Rust `TextInput::with_placeholder()` function.
#[no_mangle] pub extern "C" fn AzTextInput_withPlaceholder (textinput: &mut AzTextInput, text: AzAzString) -> AzTextInput{ textinput.with_placeholder(text) }
/// Equivalent to the Rust `TextInput::set_on_text_input()` function.
#[no_mangle] pub extern "C" fn AzTextInput_setOnTextInput (textinput: &mut AzTextInput, data: AzRefAny, callback: AzTextInputOnTextInputCallbackType){ textinput.set_on_text_input(data, callback) }
/// Equivalent to the Rust `TextInput::with_on_text_input()` function.
#[no_mangle] pub extern "C" fn AzTextInput_withOnTextInput (textinput: &mut AzTextInput, data: AzRefAny, callback: AzTextInputOnTextInputCallbackType) -> AzTextInput{ let mut textinput = textinput.swap_with_default(); textinput.set_on_text_input(data, callback); textinput }
/// Equivalent to the Rust `TextInput::set_on_virtual_key_down()` function.
#[no_mangle] pub extern "C" fn AzTextInput_setOnVirtualKeyDown (textinput: &mut AzTextInput, data: AzRefAny, callback: AzTextInputOnVirtualKeyDownCallbackType){ textinput.set_on_virtual_key_down(data, callback) }
/// Equivalent to the Rust `TextInput::with_on_virtual_key_down()` function.
#[no_mangle] pub extern "C" fn AzTextInput_withOnVirtualKeyDown (textinput: &mut AzTextInput, data: AzRefAny, callback: AzTextInputOnVirtualKeyDownCallbackType) -> AzTextInput{ let mut textinput = textinput.swap_with_default(); textinput.set_on_virtual_key_down(data, callback); textinput }
/// Equivalent to the Rust `TextInput::set_on_focus_lost()` function.
#[no_mangle] pub extern "C" fn AzTextInput_setOnFocusLost (textinput: &mut AzTextInput, data: AzRefAny, callback: AzTextInputOnFocusLostCallbackType){ textinput.set_on_focus_lost(data, callback) }
/// Equivalent to the Rust `TextInput::with_on_focus_lost()` function.
#[no_mangle] pub extern "C" fn AzTextInput_withOnFocusLost (textinput: &mut AzTextInput, data: AzRefAny, callback: AzTextInputOnFocusLostCallbackType) -> AzTextInput{ let mut textinput = textinput.swap_with_default(); textinput.set_on_focus_lost(data, callback); textinput }
/// Equivalent to the Rust `TextInput::set_placeholder_style()` function.
#[no_mangle] pub extern "C" fn AzTextInput_setPlaceholderStyle (textinput: &mut AzTextInput, placeholder_style: AzNodeDataInlineCssPropertyVec){ textinput.set_placeholder_style(placeholder_style) }
/// Equivalent to the Rust `TextInput::with_placeholder_style()` function.
#[no_mangle] pub extern "C" fn AzTextInput_withPlaceholderStyle (textinput: &mut AzTextInput, placeholder_style: AzNodeDataInlineCssPropertyVec) -> AzTextInput{ let mut textinput = textinput.swap_with_default(); textinput.set_placeholder_style(placeholder_style); textinput }
/// Equivalent to the Rust `TextInput::set_container_style()` function.
#[no_mangle] pub extern "C" fn AzTextInput_setContainerStyle (textinput: &mut AzTextInput, container_style: AzNodeDataInlineCssPropertyVec){  textinput.set_container_style(container_style) }
/// Equivalent to the Rust `TextInput::with_container_style()` function.
#[no_mangle] pub extern "C" fn AzTextInput_withContainerStyle (textinput: &mut AzTextInput, container_style: AzNodeDataInlineCssPropertyVec) -> AzTextInput{ let mut textinput = textinput.swap_with_default(); textinput.set_container_style(container_style); textinput }
/// Equivalent to the Rust `TextInput::set_label_style()` function.
#[no_mangle] pub extern "C" fn AzTextInput_setLabelStyle (textinput: &mut AzTextInput, label_style: AzNodeDataInlineCssPropertyVec){ textinput.set_container_style(label_style) }
/// Equivalent to the Rust `TextInput::with_label_style()` function.
#[no_mangle] pub extern "C" fn AzTextInput_withLabelStyle (textinput: &mut AzTextInput, label_style: AzNodeDataInlineCssPropertyVec) -> AzTextInput{ let mut textinput = textinput.swap_with_default(); textinput.set_label_style(label_style); textinput }
/// Equivalent to the Rust `TextInput::dom()` function.
#[no_mangle] pub extern "C" fn AzTextInput_dom (textinput: &mut AzTextInput) -> AzDom{ textinput.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputStateWrapper>` struct
#[repr(C)] pub struct AzTextInputStateWrapper { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputState>` struct
#[repr(C)] pub struct AzTextInputState { pub ptr: *mut c_void }
/// Equivalent to the Rust `TextInputState::get_text()` function.
#[no_mangle] pub extern "C" fn AzTextInputState_getText (textinputstate: &AzTextInputState) -> AzAzString{ textinputstate.get_text().into() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputSelection>` struct
#[repr(C)] pub struct AzTextInputSelection { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputSelectionRange>` struct
#[repr(C)] pub struct AzTextInputSelectionRange { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputOnTextInput>` struct
#[repr(C)] pub struct AzTextInputOnTextInput { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputOnTextInputCallback>` struct
#[repr(C)] pub struct AzTextInputOnTextInputCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (&mut RefAny , &mut CallbackInfo , &TextInputState) -> OnTextInputReturn
pub type AzTextInputOnTextInputCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputOnVirtualKeyDown>` struct
#[repr(C)] pub struct AzTextInputOnVirtualKeyDown { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputOnVirtualKeyDownCallback>` struct
#[repr(C)] pub struct AzTextInputOnVirtualKeyDownCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (&mut RefAny , &mut CallbackInfo , &TextInputState) -> OnTextInputReturn
pub type AzTextInputOnVirtualKeyDownCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputOnFocusLost>` struct
#[repr(C)] pub struct AzTextInputOnFocusLost { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputOnFocusLostCallback>` struct
#[repr(C)] pub struct AzTextInputOnFocusLostCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (&mut RefAny , &mut CallbackInfo , &TextInputState) -> Update
pub type AzTextInputOnFocusLostCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OnTextInputReturn>` struct
#[repr(C)] pub struct AzOnTextInputReturn { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputValid>` struct
#[repr(C)] pub struct AzTextInputValid { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NumberInput>` struct
#[repr(C)] pub struct AzNumberInput { pub ptr: *mut c_void }
/// Creates a new `NumberInput` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `NumberInput::new()` constructor.
#[no_mangle] pub extern "C" fn AzNumberInput_new (number: f32) -> AzNumberInput { let object: NumberInput = AzNumberInput::new(number); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzNumberInput { ptr } }
/// Equivalent to the Rust `NumberInput::set_on_text_input()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_setOnTextInput (numberinput: &mut AzNumberInput, data: AzRefAny, callback: AzTextInputOnTextInputCallbackType){ numberinput.set_on_text_input(data, callback) }
/// Equivalent to the Rust `NumberInput::with_on_text_input()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_withOnTextInput (numberinput: &mut AzNumberInput, data: AzRefAny, callback: AzTextInputOnTextInputCallbackType) -> AzNumberInput{ let mut numberinput = numberinput.swap_with_default(); numberinput.set_on_text_input(data, callback); numberinput }
/// Equivalent to the Rust `NumberInput::set_on_virtual_key_down()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_setOnVirtualKeyDown (numberinput: &mut AzNumberInput, data: AzRefAny, callback: AzTextInputOnVirtualKeyDownCallbackType){ numberinput.set_on_virtual_key_down(data, callback) }
/// Equivalent to the Rust `NumberInput::with_on_virtual_key_down()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_withOnVirtualKeyDown (numberinput: &mut AzNumberInput, data: AzRefAny, callback: AzTextInputOnVirtualKeyDownCallbackType) -> AzNumberInput{ let mut numberinput = numberinput.swap_with_default(); numberinput.set_on_virtual_key_down(data, callback); numberinput }
/// Equivalent to the Rust `NumberInput::set_on_focus_lost()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_setOnFocusLost (numberinput: &mut AzNumberInput, data: AzRefAny, callback: AzNumberInputOnFocusLostCallbackType){ numberinput.set_on_focus_lost(data, callback) }
/// Equivalent to the Rust `NumberInput::with_on_focus_lost()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_withOnFocusLost (numberinput: &mut AzNumberInput, data: AzRefAny, callback: AzNumberInputOnFocusLostCallbackType) -> AzNumberInput{ let mut numberinput = numberinput.swap_with_default(); numberinput.set_on_focus_lost(data, callback); numberinput }
/// Equivalent to the Rust `NumberInput::set_placeholder_style()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_setPlaceholderStyle (numberinput: &mut AzNumberInput, style: AzNodeDataInlineCssPropertyVec){ numberinput.set_placeholder_style(style) }
/// Equivalent to the Rust `NumberInput::with_placeholder_style()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_withPlaceholderStyle (numberinput: &mut AzNumberInput, style: AzNodeDataInlineCssPropertyVec) -> AzNumberInput{ let mut numberinput = numberinput.swap_with_default(); numberinput.set_placeholder_style(style); numberinput }
/// Equivalent to the Rust `NumberInput::set_container_style()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_setContainerStyle (numberinput: &mut AzNumberInput, style: AzNodeDataInlineCssPropertyVec){ numberinput.set_container_style(style) }
/// Equivalent to the Rust `NumberInput::with_container_style()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_withContainerStyle (numberinput: &mut AzNumberInput, style: AzNodeDataInlineCssPropertyVec) -> AzNumberInput{ let mut numberinput = numberinput.swap_with_default(); numberinput.set_container_style(style); numberinput }
/// Equivalent to the Rust `NumberInput::set_label_style()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_setLabelStyle (numberinput: &mut AzNumberInput, style: AzNodeDataInlineCssPropertyVec){ numberinput.set_label_style(style) }
/// Equivalent to the Rust `NumberInput::with_label_style()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_withLabelStyle (numberinput: &mut AzNumberInput, style: AzNodeDataInlineCssPropertyVec) -> AzNumberInput{ let mut numberinput = numberinput.swap_with_default(); numberinput.set_label_style(style); numberinput }
/// Equivalent to the Rust `NumberInput::set_on_value_change()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_setOnValueChange (numberinput: &mut AzNumberInput, data: AzRefAny, callback: AzNumberInputOnValueChangeCallbackType){ numberinput.set_on_value_change(data, callback) }
/// Equivalent to the Rust `NumberInput::with_on_value_change()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_withOnValueChange (numberinput: &mut AzNumberInput, data: AzRefAny, callback: AzNumberInputOnValueChangeCallbackType) -> AzNumberInput{ let mut numberinput = numberinput.swap_with_default(); numberinput.set_on_value_change(data, callback); numberinput }
/// Equivalent to the Rust `NumberInput::dom()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_dom (numberinput: &mut AzNumberInput) -> AzDom{ numberinput.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NumberInputStateWrapper>` struct
#[repr(C)] pub struct AzNumberInputStateWrapper { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NumberInputState>` struct
#[repr(C)] pub struct AzNumberInputState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NumberInputOnValueChange>` struct
#[repr(C)] pub struct AzNumberInputOnValueChange { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NumberInputOnValueChangeCallback>` struct
#[repr(C)] pub struct AzNumberInputOnValueChangeCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (&mut RefAny , &mut CallbackInfo , &NumberInputState) -> Update
pub type AzNumberInputOnValueChangeCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NumberInputOnFocusLost>` struct
#[repr(C)] pub struct AzNumberInputOnFocusLost { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NumberInputOnFocusLostCallback>` struct
#[repr(C)] pub struct AzNumberInputOnFocusLostCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (&mut RefAny , &mut CallbackInfo , &NumberInputState) -> Update
pub type AzNumberInputOnFocusLostCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ProgressBar>` struct
#[repr(C)] pub struct AzProgressBar { pub ptr: *mut c_void }
/// Creates a new `ProgressBar` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `ProgressBar::new()` constructor.
#[no_mangle] pub extern "C" fn AzProgressBar_new (percent_done: f32) -> AzProgressBar { let object: ProgressBar = AzProgressBar::new(percent_done); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzProgressBar { ptr } }
/// Equivalent to the Rust `ProgressBar::set_height()` function.
#[no_mangle] pub extern "C" fn AzProgressBar_setHeight (progressbar: &mut AzProgressBar, height: AzPixelValue){ progressbar.set_height(height); }
/// Equivalent to the Rust `ProgressBar::with_height()` function.
#[no_mangle] pub extern "C" fn AzProgressBar_withHeight (progressbar: &mut AzProgressBar, height: AzPixelValue) -> AzProgressBar{ let mut progressbar = progressbar.swap_with_default(); progressbar.set_height(height); progressbar }
/// Equivalent to the Rust `ProgressBar::set_container_background()` function.
#[no_mangle] pub extern "C" fn AzProgressBar_setContainerBackground (progressbar: &mut AzProgressBar, background: AzStyleBackgroundContentVec){ progressbar.set_container_background(background); }
/// Equivalent to the Rust `ProgressBar::with_container_style()` function.
#[no_mangle] pub extern "C" fn AzProgressBar_withContainerStyle (progressbar: &mut AzProgressBar, background: AzStyleBackgroundContentVec) -> AzProgressBar{ let mut progressbar = progressbar.swap_with_default(); progressbar.set_container_background(background); progressbar }
/// Equivalent to the Rust `ProgressBar::set_bar_background()` function.
#[no_mangle] pub extern "C" fn AzProgressBar_setBarBackground (progressbar: &mut AzProgressBar, background: AzStyleBackgroundContentVec){ progressbar.set_bar_background(background); }
/// Equivalent to the Rust `ProgressBar::with_bar_background()` function.
#[no_mangle] pub extern "C" fn AzProgressBar_withBarBackground (progressbar: &mut AzProgressBar, background: AzStyleBackgroundContentVec) -> AzProgressBar{ let mut progressbar = progressbar.swap_with_default(); progressbar.set_bar_background(background); progressbar }
/// Equivalent to the Rust `ProgressBar::dom()` function.
#[no_mangle] pub extern "C" fn AzProgressBar_dom (progressbar: &mut AzProgressBar) -> AzDom{ progressbar.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ProgressBarState>` struct
#[repr(C)] pub struct AzProgressBarState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TabHeader>` struct
#[repr(C)] pub struct AzTabHeader { pub ptr: *mut c_void }
/// Creates a new `TabHeader` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `TabHeader::new()` constructor.
#[no_mangle] pub extern "C" fn AzTabHeader_new (tabs: AzStringVec) -> AzTabHeader { let object: TabHeader = AzTabHeader::new(tabs); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTabHeader { ptr } }
/// Equivalent to the Rust `TabHeader::set_active_tab()` function.
#[no_mangle] pub extern "C" fn AzTabHeader_setActiveTab (tabheader: &mut AzTabHeader, active_tab: usize){ tabheader.set_active_tab(active_tab) }
/// Equivalent to the Rust `TabHeader::with_active_tab()` function.
#[no_mangle] pub extern "C" fn AzTabHeader_withActiveTab (tabheader: &mut AzTabHeader, active_tab: usize) -> AzTabHeader{ tabheader.with_active_tab(active_tab) }
/// Equivalent to the Rust `TabHeader::set_on_click()` function.
#[no_mangle] pub extern "C" fn AzTabHeader_setOnClick (tabheader: &mut AzTabHeader, data: AzRefAny, callback: AzTabOnClickCallbackType){ tabheader.set_on_click(data, callback) }
/// Equivalent to the Rust `TabHeader::with_on_click()` function.
#[no_mangle] pub extern "C" fn AzTabHeader_withOnClick (tabheader: &mut AzTabHeader, data: AzRefAny, callback: AzTabOnClickCallbackType) -> AzTabHeader{ tabheader.with_on_click(data, callback) }
/// Equivalent to the Rust `TabHeader::dom()` function.
#[no_mangle] pub extern "C" fn AzTabHeader_dom (tabheader: &mut AzTabHeader) -> AzDom{ tabheader.dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TabHeaderState>` struct
#[repr(C)] pub struct AzTabHeaderState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TabContent>` struct
#[repr(C)] pub struct AzTabContent { pub ptr: *mut c_void }
/// Creates a new `TabContent` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `TabContent::new()` constructor.
#[no_mangle] pub extern "C" fn AzTabContent_new (content: AzDom) -> AzTabContent { let object: TabContent = AzTabContent::new(content); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTabContent { ptr } }
/// Equivalent to the Rust `TabContent::set_padding()` function.
#[no_mangle] pub extern "C" fn AzTabContent_setPadding (tabcontent: &mut AzTabContent, has_padding: bool){ tabcontent.set_padding(has_padding) }
/// Equivalent to the Rust `TabContent::with_padding()` function.
#[no_mangle] pub extern "C" fn AzTabContent_withPadding (tabcontent: &mut AzTabContent, has_padding: bool) -> AzTabContent{ tabcontent.with_padding(has_padding) }
/// Equivalent to the Rust `TabContent::dom()` function.
#[no_mangle] pub extern "C" fn AzTabContent_dom (tabcontent: &mut AzTabContent) -> AzDom{ tabcontent.dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TabOnClick>` struct
#[repr(C)] pub struct AzTabOnClick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TabOnClickCallback>` struct
#[repr(C)] pub struct AzTabOnClickCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (&mut RefAny , &mut CallbackInfo , &TabHeaderState) -> Update
pub type AzTabOnClickCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Frame>` struct
#[repr(C)] pub struct AzFrame { pub ptr: *mut c_void }
/// Creates a new `Frame` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Frame::new()` constructor.
#[no_mangle] pub extern "C" fn AzFrame_new (title: AzAzString, dom: AzDom) -> AzFrame { let object: Frame = AzFrame::new(title, dom); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzFrame { ptr } }
/// Equivalent to the Rust `Frame::set_flex_grow()` function.
#[no_mangle] pub extern "C" fn AzFrame_setFlexGrow (frame: &mut AzFrame, flex_grow: f32){ frame.set_flex_grow(flex_grow) }
/// Equivalent to the Rust `Frame::with_flex_grow()` function.
#[no_mangle] pub extern "C" fn AzFrame_withFlexGrow (frame: &mut AzFrame, flex_grow: f32) -> AzFrame{ let mut frame = frame.swap_with_default(); frame.set_flex_grow(flex_grow); frame }
/// Equivalent to the Rust `Frame::dom()` function.
#[no_mangle] pub extern "C" fn AzFrame_dom (frame: &mut AzFrame) -> AzDom{ frame.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Same as the NodeGraph but without generics and without the actual data
#[repr(C)] pub struct AzNodeGraph { pub ptr: *mut c_void }
/// Equivalent to the Rust `NodeGraph::dom()` function.
#[no_mangle] pub extern "C" fn AzNodeGraph_dom (nodegraph: &mut AzNodeGraph) -> AzDom{ nodegraph.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeTypeIdInfoMap>` struct
#[repr(C)] pub struct AzNodeTypeIdInfoMap { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InputOutputTypeIdInfoMap>` struct
#[repr(C)] pub struct AzInputOutputTypeIdInfoMap { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeIdNodeMap>` struct
#[repr(C)] pub struct AzNodeIdNodeMap { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeGraphStyle>` struct
#[repr(C)] pub struct AzNodeGraphStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeGraphCallbacks>` struct
#[repr(C)] pub struct AzNodeGraphCallbacks { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeAddedCallbackType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<DropDownOnChoiceChange>` struct
#[repr(C)] pub struct AzDropDownOnChoiceChange { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OnNodeAddedCallback>` struct
#[repr(C)] pub struct AzOnNodeAddedCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeRemovedCallbackType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<OnNodeAdded>` struct
#[repr(C)] pub struct AzOnNodeAdded { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OnNodeRemovedCallback>` struct
#[repr(C)] pub struct AzOnNodeRemovedCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeGraphDraggedCallbackType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<OnNodeRemoved>` struct
#[repr(C)] pub struct AzOnNodeRemoved { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OnNodeGraphDraggedCallback>` struct
#[repr(C)] pub struct AzOnNodeGraphDraggedCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeDraggedCallbackType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<OnNodeGraphDragged>` struct
#[repr(C)] pub struct AzOnNodeGraphDragged { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OnNodeDraggedCallback>` struct
#[repr(C)] pub struct AzOnNodeDraggedCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeConnectedCallbackType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<OnNodeDragged>` struct
#[repr(C)] pub struct AzOnNodeDragged { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OnNodeConnectedCallback>` struct
#[repr(C)] pub struct AzOnNodeConnectedCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeInputDisconnectedCallbackType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<OnNodeConnected>` struct
#[repr(C)] pub struct AzOnNodeConnected { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OnNodeInputDisconnectedCallback>` struct
#[repr(C)] pub struct AzOnNodeInputDisconnectedCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeOutputDisconnectedCallbackType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<OnNodeInputDisconnected>` struct
#[repr(C)] pub struct AzOnNodeInputDisconnected { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OnNodeOutputDisconnectedCallback>` struct
#[repr(C)] pub struct AzOnNodeOutputDisconnectedCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeFieldEditedCallbackType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<OnNodeOutputDisconnected>` struct
#[repr(C)] pub struct AzOnNodeOutputDisconnected { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OnNodeFieldEditedCallback>` struct
#[repr(C)] pub struct AzOnNodeFieldEditedCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InputOutputTypeId>` struct
#[repr(C)] pub struct AzInputOutputTypeId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeTypeId>` struct
#[repr(C)] pub struct AzNodeTypeId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeGraphNodeId>` struct
#[repr(C)] pub struct AzNodeGraphNodeId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Node>` struct
#[repr(C)] pub struct AzNode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeTypeField>` struct
#[repr(C)] pub struct AzNodeTypeField { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeTypeFieldValue>` struct
#[repr(C)] pub struct AzNodeTypeFieldValue { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InputConnection>` struct
#[repr(C)] pub struct AzInputConnection { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OutputNodeAndIndex>` struct
#[repr(C)] pub struct AzOutputNodeAndIndex { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OutputConnection>` struct
#[repr(C)] pub struct AzOutputConnection { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InputNodeAndIndex>` struct
#[repr(C)] pub struct AzInputNodeAndIndex { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeTypeInfo>` struct
#[repr(C)] pub struct AzNodeTypeInfo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InputOutputInfo>` struct
#[repr(C)] pub struct AzInputOutputInfo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Things only relevant to the display of the node in an interactive editor - such as x and y position in the node graph, name, etc.
#[repr(C)] pub struct AzNodePosition { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GraphDragAmount>` struct
#[repr(C)] pub struct AzGraphDragAmount { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeDragAmount>` struct
#[repr(C)] pub struct AzNodeDragAmount { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// List view, optionally able to lazy-load data
#[repr(C)] pub struct AzListView { pub ptr: *mut c_void }
/// Creates a new `ListView` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `ListView::new()` constructor.
#[no_mangle] pub extern "C" fn AzListView_new (columns: AzStringVec) -> AzListView { let object: ListView = AzListView::new(columns); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzListView { ptr } }
/// Equivalent to the Rust `ListView::with_rows()` function.
#[no_mangle] pub extern "C" fn AzListView_withRows (listview: &mut AzListView, rows: AzListViewRowVec) -> AzListView{ listview.with_rows(rows) }
/// Equivalent to the Rust `ListView::dom()` function.
#[no_mangle] pub extern "C" fn AzListView_dom (listview: &mut AzListView) -> AzDom{ listview.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Row of the ListView
#[repr(C)] pub struct AzListViewRow { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// State of the ListView, but without row data
#[repr(C)] pub struct AzListViewState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (&mut RefAny , &mut CallbackInfo , &ListViewState) -> Update
pub type AzListViewOnLazyLoadScrollCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewOnLazyLoadScrollCallback>` struct
#[repr(C)] pub struct AzListViewOnLazyLoadScrollCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewOnLazyLoadScroll>` struct
#[repr(C)] pub struct AzListViewOnLazyLoadScroll { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (&mut RefAny , &mut CallbackInfo , &ListViewState , column_clicked : usize) -> Update
pub type AzListViewOnColumnClickCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewOnColumnClickCallback>` struct
#[repr(C)] pub struct AzListViewOnColumnClickCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewOnColumnClick>` struct
#[repr(C)] pub struct AzListViewOnColumnClick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (&mut RefAny , &mut CallbackInfo , &ListViewState , row_clicked : usize) -> Update
pub type AzListViewOnRowClickCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewOnRowClickCallback>` struct
#[repr(C)] pub struct AzListViewOnRowClickCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewOnRowClick>` struct
#[repr(C)] pub struct AzListViewOnRowClick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TreeView>` struct
#[repr(C)] pub struct AzTreeView { pub ptr: *mut c_void }
/// Creates a new `TreeView` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `TreeView::new()` constructor.
#[no_mangle] pub extern "C" fn AzTreeView_new (root: AzAzString) -> AzTreeView { let object: TreeView = AzTreeView::new(root); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTreeView { ptr } }
/// Equivalent to the Rust `TreeView::dom()` function.
#[no_mangle] pub extern "C" fn AzTreeView_dom (treeview: &mut AzTreeView) -> AzDom{ treeview.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DropDown>` struct
#[repr(C)] pub struct AzDropDown { pub ptr: *mut c_void }
/// Creates a new `DropDown` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `DropDown::new()` constructor.
#[no_mangle] pub extern "C" fn AzDropDown_new (choices: AzStringVec) -> AzDropDown { let object: DropDown = AzDropDown::new(choices); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzDropDown { ptr } }
/// Equivalent to the Rust `DropDown::dom()` function.
#[no_mangle] pub extern "C" fn AzDropDown_dom (dropdown: &mut AzDropDown) -> AzDom{ dropdown.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (&mut RefAny , &mut CallbackInfo , usize) -> Update
pub type AzDropDownOnChoiceChangeCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DropDownOnChoiceChangeCallback>` struct
#[repr(C)] pub struct AzDropDownOnChoiceChangeCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OnNodeFieldEdited>` struct
#[repr(C)] pub struct AzOnNodeFieldEdited { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeHierarchyItem>` struct
#[repr(C)] pub struct AzNodeHierarchyItem { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Has all the necessary information about the style CSS path
#[repr(C)] pub struct AzCascadeInfo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssPropertySource>` struct
#[repr(C)] pub struct AzCssPropertySource { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyledNodeState>` struct
#[repr(C)] pub struct AzStyledNodeState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyledNode>` struct
#[repr(C)] pub struct AzStyledNode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyledDom>` struct
#[repr(C)] pub struct AzStyledDom { pub ptr: *mut c_void }
/// Styles a `Dom` with the given `Css`, returning the `StyledDom` - complexity `O(count(dom_nodes) * count(css_blocks))`: make sure that the `Dom` and the `Css` are as small as possible, use inline CSS if the performance isn't good enough
#[no_mangle] pub extern "C" fn AzStyledDom_new (dom: AzDom, css: AzCss) -> AzStyledDom { let object: StyledDom = let mut dom = dom; AzStyledDom::new(&mut dom, css.into()); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzStyledDom { ptr } }
/// Returns a default, empty `Dom`, usually returned if you don't want to crash in an error case.
#[no_mangle] pub extern "C" fn AzStyledDom_default () -> AzStyledDom { let object: StyledDom = AzStyledDom::default(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzStyledDom { ptr } }
/// Returns a DOM loaded from an XML file
#[no_mangle] pub extern "C" fn AzStyledDom_fromXml (xml_string: AzAzString) -> AzStyledDom { let object: StyledDom = crate::extra::styled_dom_from_str(xml_string.as_str()); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzStyledDom { ptr } }
/// Same as `from_xml`, but loads the file relative to the current directory
#[no_mangle] pub extern "C" fn AzStyledDom_fromFile (xml_file_path: AzAzString) -> AzStyledDom { let object: StyledDom = crate::extra::styled_dom_from_file(xml_file_path.as_str()); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzStyledDom { ptr } }
/// Appends an already styled list of DOM nodes to the current `dom.root` - complexity `O(count(dom.dom_nodes))`
#[no_mangle] pub extern "C" fn AzStyledDom_appendChild (styleddom: &mut AzStyledDom, dom: AzStyledDom){ styleddom.append_child(dom); }
/// Same as `append_child()`, but as a builder method
#[no_mangle] pub extern "C" fn AzStyledDom_withChild (styleddom: &mut AzStyledDom, dom: AzStyledDom) -> AzStyledDom{ styleddom.with_child(dom) }
/// Restyles an already styled DOM with a new CSS - overwrites old styles, but does not replace them, useful for implementing user styles that are applied on top of the existing application style
#[no_mangle] pub extern "C" fn AzStyledDom_restyle (styleddom: &mut AzStyledDom, css: AzCss){ styleddom.restyle(css.into()); }
/// Returns the number of nodes in the styled DOM
#[no_mangle] pub extern "C" fn AzStyledDom_nodeCount (styleddom: &AzStyledDom) -> usize{ styleddom.node_count() }
/// Returns a HTML string that you can write to a file in order to debug the UI structure and debug potential cascading issues
#[no_mangle] pub extern "C" fn AzStyledDom_getHtmlString (styleddom: &AzStyledDom) -> AzAzString{ styleddom.get_html_string("", "", false).into() }
/// Returns a HTML for unit testing
#[no_mangle] pub extern "C" fn AzStyledDom_getHtmlStringTest (styleddom: &AzStyledDom) -> AzAzString{ styleddom.get_html_string("", "", true).into() }
/// Adds a menu to the root node
#[no_mangle] pub extern "C" fn AzStyledDom_setMenuBar (styleddom: &mut AzStyledDom, menu: AzMenu){ styleddom.set_menu_bar(menu) }
/// Adds a menu to the root node (builder method)
#[no_mangle] pub extern "C" fn AzStyledDom_withMenuBar (styleddom: &mut AzStyledDom, menu: AzMenu) -> AzStyledDom{ let mut styleddom = styleddom.swap_with_default(); styleddom.set_menu_bar(menu); styleddom }
/// Adds a context menu to the root node
#[no_mangle] pub extern "C" fn AzStyledDom_setContextMenu (styleddom: &mut AzStyledDom, menu: AzMenu){ styleddom.set_context_menu(menu) }
/// Adds a context menu to the root node (builder method)
#[no_mangle] pub extern "C" fn AzStyledDom_withContextMenu (styleddom: &mut AzStyledDom, menu: AzMenu) -> AzStyledDom{ let mut styleddom = styleddom.swap_with_default(); styleddom.set_context_menu(menu); styleddom }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TagIdToNodeIdMapping>` struct
#[repr(C)] pub struct AzTagIdToNodeIdMapping { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ParentWithNodeDepth>` struct
#[repr(C)] pub struct AzParentWithNodeDepth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AzTagId>` struct
#[repr(C)] pub struct AzAzTagId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssPropertyCachePtr>` struct
pub use azul_core::styled_dom::CssPropertyCachePtr as AzCssPropertyCachePtrTT;
pub use AzCssPropertyCachePtrTT as AzCssPropertyCachePtr;
/* Error: Type is not stack allocated! */

/// OpenGL texture, use `ReadOnlyWindow::create_texture` to create a texture
pub use azul_core::gl::Texture as AzTextureTT;
pub use AzTextureTT as AzTexture;
/// Creates a new `Texture` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Texture::new()` constructor.
#[no_mangle] pub extern "C" fn AzTexture_new (texture_id: u32, flags: AzTextureFlags, size: AzPhysicalSizeU32, background_color: AzColorU, gl_context: AzGlContextPtr, format: AzRawImageFormat) -> AzTexture { let object: Texture = AzTexture::new(texture_id, flags, size, background_color, gl_context, format); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTexture { ptr } }
/// Allocates an OpenGL texture of a given size with a single red channel (used for image masks)
#[no_mangle] pub extern "C" fn AzTexture_allocateRgba8 (gl: AzGlContextPtr, size: AzPhysicalSizeU32, background: AzColorU) -> AzTexture { let object: Texture = AzTexture::allocate_rgba8(gl, size, background); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTexture { ptr } }
/// Allocates an OpenGL texture of a given size with a single red channel (used for image masks)
#[no_mangle] pub extern "C" fn AzTexture_allocateClipMask (gl: AzGlContextPtr, size: AzPhysicalSizeU32, background: AzColorU) -> AzTexture { let object: Texture = azul_layout::xml::svg::allocate_clipmask_texture(gl, size, background); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTexture { ptr } }
/// Clears the texture with the currently set background color
#[no_mangle] pub extern "C" fn AzTexture_clear (texture: &mut AzTexture){ texture.clear() }
/// Draws a vertex / index buffer (aka. `&TessellatedSvgNode`) to the texture
#[no_mangle] pub extern "C" fn AzTexture_drawClipMask (texture: &mut AzTexture, node: AzTessellatedSvgNode) -> bool{ azul_layout::xml::svg::render_tessellated_node_gpu(texture, &node).is_some() }
/// Draws a `&TessellatedGPUSvgNode` with the given color to the texture
#[no_mangle] pub extern "C" fn AzTexture_drawTesselatedSvgGpuNode (texture: &mut AzTexture, node: *const AzTessellatedGPUSvgNode, size: AzPhysicalSizeU32, color: AzColorU, transforms: AzStyleTransformVec) -> bool{ let node = unsafe { &*node }; node.draw(texture, size, color, transforms) }
/// Draws a `&TessellatedColoredGPUSvgNode` with the given color to the texture
#[no_mangle] pub extern "C" fn AzTexture_drawTesselatedColoredSvgGpuNode (texture: &mut AzTexture, node: *const AzTessellatedColoredGPUSvgNode, size: AzPhysicalSizeU32, transforms: AzStyleTransformVec) -> bool{ let node = unsafe { &*node }; node.draw(texture, size, transforms) }
/// Applies an FXAA filter to the texture
#[no_mangle] pub extern "C" fn AzTexture_applyFxaa (texture: &mut AzTexture) -> bool{ azul_layout::xml::svg::apply_fxaa(texture).is_some() }
/* Error: Type is not stack allocated! */

/// Passing *const c_void is not easily possible when generating APIs, so this wrapper struct is for easier API generation
pub use azul_core::gl::GlVoidPtrConst as AzGlVoidPtrConstTT;
pub use AzGlVoidPtrConstTT as AzGlVoidPtrConst;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GlVoidPtrMut>` struct
#[repr(C)] pub struct AzGlVoidPtrMut { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextureFlags>` struct
#[repr(C)] pub struct AzTextureFlags { pub ptr: *mut c_void }
/// Default texture flags (not opaque, not a video texture)
#[no_mangle] pub extern "C" fn AzTextureFlags_default () -> AzTextureFlags { let object: TextureFlags = AzTextureFlags::default(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTextureFlags { ptr } }
/* Error: Type is not stack allocated! */

/// For .get_gl_precision_format(), but ABI-safe - returning an array or a tuple is not ABI-safe
#[repr(C)] pub struct AzGlShaderPrecisionFormatReturn { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VertexAttributeType>` struct
#[repr(C)] pub struct AzVertexAttributeType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VertexAttribute>` struct
#[repr(C)] pub struct AzVertexAttribute { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VertexLayout>` struct
#[repr(C)] pub struct AzVertexLayout { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VertexArrayObject>` struct
pub use azul_core::gl::VertexArrayObject as AzVertexArrayObjectTT;
pub use AzVertexArrayObjectTT as AzVertexArrayObject;
/// Creates a new `VertexArrayObject` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `VertexArrayObject::new()` constructor.
#[no_mangle] pub extern "C" fn AzVertexArrayObject_new (vertex_layout: AzVertexLayout, vao_id: u32, gl_context: AzGlContextPtr) -> AzVertexArrayObject { let object: VertexArrayObject = AzVertexArrayObject::new(vertex_layout, vao_id, gl_context); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzVertexArrayObject { ptr } }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<IndexBufferFormat>` struct
#[repr(C)] pub struct AzIndexBufferFormat { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VertexBuffer>` struct
pub use azul_core::gl::VertexBuffer as AzVertexBufferTT;
pub use AzVertexBufferTT as AzVertexBuffer;
/// Creates a new `VertexBuffer` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `VertexBuffer::new()` constructor.
#[no_mangle] pub extern "C" fn AzVertexBuffer_new (vertex_buffer_id: u32, vertex_buffer_len: usize, vao: AzVertexArrayObject, index_buffer_id: u32, index_buffer_len: usize, index_buffer_format: AzIndexBufferFormat) -> AzVertexBuffer { let object: VertexBuffer = AzVertexBuffer::new_raw(vertex_buffer_id, vertex_buffer_len, vao, index_buffer_id, index_buffer_len, index_buffer_format); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzVertexBuffer { ptr } }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GlContextPtr>` struct
pub use azul_core::gl::GlContextPtr as AzGlContextPtrTT;
pub use AzGlContextPtrTT as AzGlContextPtr;
/// Equivalent to the Rust `GlContextPtr::get_type()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getType (glcontextptr: &AzGlContextPtr) -> AzAzGlType{ gl.get_type() }
/// Equivalent to the Rust `GlContextPtr::buffer_data_untyped()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bufferDataUntyped (glcontextptr: &AzGlContextPtr, target: u32, size: isize, data: AzGlVoidPtrConst, usage: u32){ gl.buffer_data_untyped(target, size, data, usage) }
/// Equivalent to the Rust `GlContextPtr::buffer_sub_data_untyped()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bufferSubDataUntyped (glcontextptr: &AzGlContextPtr, target: u32, offset: isize, size: isize, data: AzGlVoidPtrConst){ gl.buffer_sub_data_untyped(target, offset, size, data) }
/// Equivalent to the Rust `GlContextPtr::map_buffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_mapBuffer (glcontextptr: &AzGlContextPtr, target: u32, access: u32) -> AzGlVoidPtrMut{ gl.map_buffer(target, access) }
/// Equivalent to the Rust `GlContextPtr::map_buffer_range()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_mapBufferRange (glcontextptr: &AzGlContextPtr, target: u32, offset: isize, length: isize, access: u32) -> AzGlVoidPtrMut{ gl.map_buffer_range(target, offset, length, access) }
/// Equivalent to the Rust `GlContextPtr::unmap_buffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_unmapBuffer (glcontextptr: &AzGlContextPtr, target: u32) -> u8{ gl.unmap_buffer(target) }
/// Equivalent to the Rust `GlContextPtr::tex_buffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texBuffer (glcontextptr: &AzGlContextPtr, target: u32, internal_format: u32, buffer: u32){ gl.tex_buffer(target, internal_format, buffer) }
/// Equivalent to the Rust `GlContextPtr::shader_source()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_shaderSource (glcontextptr: &AzGlContextPtr, shader: u32, strings: AzStringVec){ gl.shader_source(shader, strings) }
/// Equivalent to the Rust `GlContextPtr::read_buffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_readBuffer (glcontextptr: &AzGlContextPtr, mode: u32){ gl.read_buffer(mode) }
/// Equivalent to the Rust `GlContextPtr::read_pixels_into_buffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_readPixelsIntoBuffer (glcontextptr: &AzGlContextPtr, x: i32, y: i32, width: i32, height: i32, format: u32, pixel_type: u32, dst_buffer: AzU8VecRefMut){ gl.read_pixels_into_buffer(x, y, width, height, format, pixel_type, dst_buffer) }
/// Equivalent to the Rust `GlContextPtr::read_pixels()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_readPixels (glcontextptr: &AzGlContextPtr, x: i32, y: i32, width: i32, height: i32, format: u32, pixel_type: u32) -> AzU8Vec{ gl.read_pixels(x, y, width, height, format, pixel_type) }
/// Equivalent to the Rust `GlContextPtr::read_pixels_into_pbo()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_readPixelsIntoPbo (glcontextptr: &AzGlContextPtr, x: i32, y: i32, width: i32, height: i32, format: u32, pixel_type: u32){ gl.read_pixels_into_pbo(x, y, width, height, format, pixel_type) }
/// Equivalent to the Rust `GlContextPtr::sample_coverage()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_sampleCoverage (glcontextptr: &AzGlContextPtr, value: f32, invert: bool){ gl.sample_coverage(value, invert) }
/// Equivalent to the Rust `GlContextPtr::polygon_offset()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_polygonOffset (glcontextptr: &AzGlContextPtr, factor: f32, units: f32){ gl.polygon_offset(factor, units) }
/// Equivalent to the Rust `GlContextPtr::pixel_store_i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_pixelStoreI (glcontextptr: &AzGlContextPtr, name: u32, param: i32){ gl.pixel_store_i(name, param) }
/// Equivalent to the Rust `GlContextPtr::gen_buffers()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_genBuffers (glcontextptr: &AzGlContextPtr, n: i32) -> AzGLuintVec{ gl.gen_buffers(n) }
/// Equivalent to the Rust `GlContextPtr::gen_renderbuffers()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_genRenderbuffers (glcontextptr: &AzGlContextPtr, n: i32) -> AzGLuintVec{ gl.gen_renderbuffers(n) }
/// Equivalent to the Rust `GlContextPtr::gen_framebuffers()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_genFramebuffers (glcontextptr: &AzGlContextPtr, n: i32) -> AzGLuintVec{ gl.gen_framebuffers(n) }
/// Equivalent to the Rust `GlContextPtr::gen_textures()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_genTextures (glcontextptr: &AzGlContextPtr, n: i32) -> AzGLuintVec{ gl.gen_textures(n) }
/// Equivalent to the Rust `GlContextPtr::gen_vertex_arrays()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_genVertexArrays (glcontextptr: &AzGlContextPtr, n: i32) -> AzGLuintVec{ gl.gen_vertex_arrays(n) }
/// Equivalent to the Rust `GlContextPtr::gen_queries()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_genQueries (glcontextptr: &AzGlContextPtr, n: i32) -> AzGLuintVec{ gl.gen_queries(n) }
/// Equivalent to the Rust `GlContextPtr::begin_query()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_beginQuery (glcontextptr: &AzGlContextPtr, target: u32, id: u32){ gl.begin_query(target, id) }
/// Equivalent to the Rust `GlContextPtr::end_query()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_endQuery (glcontextptr: &AzGlContextPtr, target: u32){ gl.end_query(target) }
/// Equivalent to the Rust `GlContextPtr::query_counter()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_queryCounter (glcontextptr: &AzGlContextPtr, id: u32, target: u32){ gl.query_counter(id, target) }
/// Equivalent to the Rust `GlContextPtr::get_query_object_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getQueryObjectIv (glcontextptr: &AzGlContextPtr, id: u32, pname: u32) -> i32{ gl.get_query_object_iv(id, pname) }
/// Equivalent to the Rust `GlContextPtr::get_query_object_uiv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getQueryObjectUiv (glcontextptr: &AzGlContextPtr, id: u32, pname: u32) -> u32{ gl.get_query_object_uiv(id, pname) }
/// Equivalent to the Rust `GlContextPtr::get_query_object_i64v()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getQueryObjectI64v (glcontextptr: &AzGlContextPtr, id: u32, pname: u32) -> i64{ gl.get_query_object_i64v(id, pname) }
/// Equivalent to the Rust `GlContextPtr::get_query_object_ui64v()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getQueryObjectUi64v (glcontextptr: &AzGlContextPtr, id: u32, pname: u32) -> u64{ gl.get_query_object_ui64v(id, pname) }
/// Equivalent to the Rust `GlContextPtr::delete_queries()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteQueries (glcontextptr: &AzGlContextPtr, queries: AzGLuintVecRef){ gl.delete_queries(queries) }
/// Equivalent to the Rust `GlContextPtr::delete_vertex_arrays()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteVertexArrays (glcontextptr: &AzGlContextPtr, vertex_arrays: AzGLuintVecRef){ gl.delete_vertex_arrays(vertex_arrays) }
/// Equivalent to the Rust `GlContextPtr::delete_buffers()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteBuffers (glcontextptr: &AzGlContextPtr, buffers: AzGLuintVecRef){ gl.delete_buffers(buffers) }
/// Equivalent to the Rust `GlContextPtr::delete_renderbuffers()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteRenderbuffers (glcontextptr: &AzGlContextPtr, renderbuffers: AzGLuintVecRef){ gl.delete_renderbuffers(renderbuffers) }
/// Equivalent to the Rust `GlContextPtr::delete_framebuffers()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteFramebuffers (glcontextptr: &AzGlContextPtr, framebuffers: AzGLuintVecRef){ gl.delete_framebuffers(framebuffers) }
/// Equivalent to the Rust `GlContextPtr::delete_textures()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteTextures (glcontextptr: &AzGlContextPtr, textures: AzGLuintVecRef){ gl.delete_textures(textures) }
/// Equivalent to the Rust `GlContextPtr::framebuffer_renderbuffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_framebufferRenderbuffer (glcontextptr: &AzGlContextPtr, target: u32, attachment: u32, renderbuffertarget: u32, renderbuffer: u32){ gl.framebuffer_renderbuffer(target, attachment, renderbuffertarget, renderbuffer) }
/// Equivalent to the Rust `GlContextPtr::renderbuffer_storage()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_renderbufferStorage (glcontextptr: &AzGlContextPtr, target: u32, internalformat: u32, width: i32, height: i32){ gl.renderbuffer_storage(target, internalformat, width, height) }
/// Equivalent to the Rust `GlContextPtr::depth_func()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_depthFunc (glcontextptr: &AzGlContextPtr, func: u32){ gl.depth_func(func) }
/// Equivalent to the Rust `GlContextPtr::active_texture()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_activeTexture (glcontextptr: &AzGlContextPtr, texture: u32){ gl.active_texture(texture) }
/// Equivalent to the Rust `GlContextPtr::attach_shader()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_attachShader (glcontextptr: &AzGlContextPtr, program: u32, shader: u32){ gl.attach_shader(program, shader) }
/// Equivalent to the Rust `GlContextPtr::bind_attrib_location()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindAttribLocation (glcontextptr: &AzGlContextPtr, program: u32, index: u32, name: AzRefstr){ gl.bind_attrib_location(program, index, name) }
/// Equivalent to the Rust `GlContextPtr::get_uniform_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getUniformIv (glcontextptr: &AzGlContextPtr, program: u32, location: i32, result: AzGLintVecRefMut){ gl.get_uniform_iv(program, location, result) }
/// Equivalent to the Rust `GlContextPtr::get_uniform_fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getUniformFv (glcontextptr: &AzGlContextPtr, program: u32, location: i32, result: AzGLfloatVecRefMut){ gl.get_uniform_fv(program, location, result) }
/// Equivalent to the Rust `GlContextPtr::get_uniform_block_index()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getUniformBlockIndex (glcontextptr: &AzGlContextPtr, program: u32, name: AzRefstr) -> u32{ gl.get_uniform_block_index(program, name) }
/// Equivalent to the Rust `GlContextPtr::get_uniform_indices()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getUniformIndices (glcontextptr: &AzGlContextPtr, program: u32, names: AzRefstrVecRef) -> AzGLuintVec{ gl.get_uniform_indices(program, names) }
/// Equivalent to the Rust `GlContextPtr::bind_buffer_base()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindBufferBase (glcontextptr: &AzGlContextPtr, target: u32, index: u32, buffer: u32){ gl.bind_buffer_base(target, index, buffer) }
/// Equivalent to the Rust `GlContextPtr::bind_buffer_range()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindBufferRange (glcontextptr: &AzGlContextPtr, target: u32, index: u32, buffer: u32, offset: isize, size: isize){ gl.bind_buffer_range(target, index, buffer, offset, size) }
/// Equivalent to the Rust `GlContextPtr::uniform_block_binding()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniformBlockBinding (glcontextptr: &AzGlContextPtr, program: u32, uniform_block_index: u32, uniform_block_binding: u32){ gl.uniform_block_binding(program, uniform_block_index, uniform_block_binding) }
/// Equivalent to the Rust `GlContextPtr::bind_buffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindBuffer (glcontextptr: &AzGlContextPtr, target: u32, buffer: u32){ gl.bind_buffer(target, buffer) }
/// Equivalent to the Rust `GlContextPtr::bind_vertex_array()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindVertexArray (glcontextptr: &AzGlContextPtr, vao: u32){ gl.bind_vertex_array(vao) }
/// Equivalent to the Rust `GlContextPtr::bind_renderbuffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindRenderbuffer (glcontextptr: &AzGlContextPtr, target: u32, renderbuffer: u32){ gl.bind_renderbuffer(target, renderbuffer) }
/// Equivalent to the Rust `GlContextPtr::bind_framebuffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindFramebuffer (glcontextptr: &AzGlContextPtr, target: u32, framebuffer: u32){ gl.bind_framebuffer(target, framebuffer) }
/// Equivalent to the Rust `GlContextPtr::bind_texture()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindTexture (glcontextptr: &AzGlContextPtr, target: u32, texture: u32){ gl.bind_texture(target, texture) }
/// Equivalent to the Rust `GlContextPtr::draw_buffers()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_drawBuffers (glcontextptr: &AzGlContextPtr, bufs: AzGLenumVecRef){ gl.draw_buffers(bufs) }
/// Equivalent to the Rust `GlContextPtr::tex_image_2d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texImage2d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, internal_format: i32, width: i32, height: i32, border: i32, format: u32, ty: u32, opt_data: AzOptionU8VecRef){ gl.tex_image_2d(target, level, internal_format, width, height, border, format, ty, opt_data) }
/// Equivalent to the Rust `GlContextPtr::compressed_tex_image_2d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_compressedTexImage2d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, internal_format: u32, width: i32, height: i32, border: i32, data: AzU8VecRef){ gl.compressed_tex_image_2d(target, level, internal_format, width, height, border, data) }
/// Equivalent to the Rust `GlContextPtr::compressed_tex_sub_image_2d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_compressedTexSubImage2d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, data: AzU8VecRef){ gl.compressed_tex_sub_image_2d(target, level, xoffset, yoffset, width, height, format, data) }
/// Equivalent to the Rust `GlContextPtr::tex_image_3d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texImage3d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, internal_format: i32, width: i32, height: i32, depth: i32, border: i32, format: u32, ty: u32, opt_data: AzOptionU8VecRef){ gl.tex_image_3d(target, level, internal_format, width, height, depth, border, format, ty, opt_data) }
/// Equivalent to the Rust `GlContextPtr::copy_tex_image_2d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_copyTexImage2d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, internal_format: u32, x: i32, y: i32, width: i32, height: i32, border: i32){ gl.copy_tex_image_2d(target, level, internal_format, x, y, width, height, border) }
/// Equivalent to the Rust `GlContextPtr::copy_tex_sub_image_2d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_copyTexSubImage2d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, xoffset: i32, yoffset: i32, x: i32, y: i32, width: i32, height: i32){ gl.copy_tex_sub_image_2d(target, level, xoffset, yoffset, x, y, width, height) }
/// Equivalent to the Rust `GlContextPtr::copy_tex_sub_image_3d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_copyTexSubImage3d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, x: i32, y: i32, width: i32, height: i32){ gl.copy_tex_sub_image_3d(target, level, xoffset, yoffset, zoffset, x, y, width, height) }
/// Equivalent to the Rust `GlContextPtr::tex_sub_image_2d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texSubImage2d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, ty: u32, data: AzU8VecRef){ gl.tex_sub_image_2d(target, level, xoffset, yoffset, width, height, format, ty, data) }
/// Equivalent to the Rust `GlContextPtr::tex_sub_image_2d_pbo()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texSubImage2dPbo (glcontextptr: &AzGlContextPtr, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, ty: u32, offset: usize){ gl.tex_sub_image_2d_pbo(target, level, xoffset, yoffset, width, height, format, ty, offset) }
/// Equivalent to the Rust `GlContextPtr::tex_sub_image_3d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texSubImage3d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, width: i32, height: i32, depth: i32, format: u32, ty: u32, data: AzU8VecRef){ gl.tex_sub_image_3d(target, level, xoffset, yoffset, zoffset, width, height, depth, format, ty, data) }
/// Equivalent to the Rust `GlContextPtr::tex_sub_image_3d_pbo()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texSubImage3dPbo (glcontextptr: &AzGlContextPtr, target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, width: i32, height: i32, depth: i32, format: u32, ty: u32, offset: usize){ gl.tex_sub_image_3d_pbo(target, level, xoffset, yoffset, zoffset, width, height, depth, format, ty, offset) }
/// Equivalent to the Rust `GlContextPtr::tex_storage_2d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texStorage2d (glcontextptr: &AzGlContextPtr, target: u32, levels: i32, internal_format: u32, width: i32, height: i32){ gl.tex_storage_2d(target, levels, internal_format, width, height) }
/// Equivalent to the Rust `GlContextPtr::tex_storage_3d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texStorage3d (glcontextptr: &AzGlContextPtr, target: u32, levels: i32, internal_format: u32, width: i32, height: i32, depth: i32){ gl.tex_storage_3d(target, levels, internal_format, width, height, depth) }
/// Equivalent to the Rust `GlContextPtr::get_tex_image_into_buffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getTexImageIntoBuffer (glcontextptr: &AzGlContextPtr, target: u32, level: i32, format: u32, ty: u32, output: AzU8VecRefMut){ gl.get_tex_image_into_buffer(target, level, format, ty, output) }
/// Equivalent to the Rust `GlContextPtr::copy_image_sub_data()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_copyImageSubData (glcontextptr: &AzGlContextPtr, src_name: u32, src_target: u32, src_level: i32, src_x: i32, src_y: i32, src_z: i32, dst_name: u32, dst_target: u32, dst_level: i32, dst_x: i32, dst_y: i32, dst_z: i32, src_width: i32, src_height: i32, src_depth: i32){ gl.copy_image_sub_data(src_name, src_target, src_level, src_x, src_y, src_z, dst_name, dst_target, dst_level, dst_x, dst_y, dst_z, src_width, src_height, src_depth) }
/// Equivalent to the Rust `GlContextPtr::invalidate_framebuffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_invalidateFramebuffer (glcontextptr: &AzGlContextPtr, target: u32, attachments: AzGLenumVecRef){ gl.invalidate_framebuffer(target, attachments) }
/// Equivalent to the Rust `GlContextPtr::invalidate_sub_framebuffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_invalidateSubFramebuffer (glcontextptr: &AzGlContextPtr, target: u32, attachments: AzGLenumVecRef, xoffset: i32, yoffset: i32, width: i32, height: i32){ gl.invalidate_sub_framebuffer(target, attachments, xoffset, yoffset, width, height) }
/// Equivalent to the Rust `GlContextPtr::get_integer_v()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getIntegerV (glcontextptr: &AzGlContextPtr, name: u32, result: AzGLintVecRefMut){ gl.get_integer_v(name, result) }
/// Equivalent to the Rust `GlContextPtr::get_integer_64v()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getInteger64v (glcontextptr: &AzGlContextPtr, name: u32, result: AzGLint64VecRefMut){ gl.get_integer_64v(name, result) }
/// Equivalent to the Rust `GlContextPtr::get_integer_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getIntegerIv (glcontextptr: &AzGlContextPtr, name: u32, index: u32, result: AzGLintVecRefMut){ gl.get_integer_iv(name, index, result) }
/// Equivalent to the Rust `GlContextPtr::get_integer_64iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getInteger64iv (glcontextptr: &AzGlContextPtr, name: u32, index: u32, result: AzGLint64VecRefMut){ gl.get_integer_64iv(name, index, result) }
/// Equivalent to the Rust `GlContextPtr::get_boolean_v()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getBooleanV (glcontextptr: &AzGlContextPtr, name: u32, result: AzGLbooleanVecRefMut){ gl.get_boolean_v(name, result) }
/// Equivalent to the Rust `GlContextPtr::get_float_v()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getFloatV (glcontextptr: &AzGlContextPtr, name: u32, result: AzGLfloatVecRefMut){ gl.get_float_v(name, result) }
/// Equivalent to the Rust `GlContextPtr::get_framebuffer_attachment_parameter_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getFramebufferAttachmentParameterIv (glcontextptr: &AzGlContextPtr, target: u32, attachment: u32, pname: u32) -> i32{ gl.get_framebuffer_attachment_parameter_iv(target, attachment, pname) }
/// Equivalent to the Rust `GlContextPtr::get_renderbuffer_parameter_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getRenderbufferParameterIv (glcontextptr: &AzGlContextPtr, target: u32, pname: u32) -> i32{ gl.get_renderbuffer_parameter_iv(target, pname) }
/// Equivalent to the Rust `GlContextPtr::get_tex_parameter_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getTexParameterIv (glcontextptr: &AzGlContextPtr, target: u32, name: u32) -> i32{ gl.get_tex_parameter_iv(target, name) }
/// Equivalent to the Rust `GlContextPtr::get_tex_parameter_fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getTexParameterFv (glcontextptr: &AzGlContextPtr, target: u32, name: u32) -> f32{ gl.get_tex_parameter_fv(target, name) }
/// Equivalent to the Rust `GlContextPtr::tex_parameter_i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texParameterI (glcontextptr: &AzGlContextPtr, target: u32, pname: u32, param: i32){ gl.tex_parameter_i(target, pname, param) }
/// Equivalent to the Rust `GlContextPtr::tex_parameter_f()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texParameterF (glcontextptr: &AzGlContextPtr, target: u32, pname: u32, param: f32){ gl.tex_parameter_f(target, pname, param) }
/// Equivalent to the Rust `GlContextPtr::framebuffer_texture_2d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_framebufferTexture2d (glcontextptr: &AzGlContextPtr, target: u32, attachment: u32, textarget: u32, texture: u32, level: i32){ gl.framebuffer_texture_2d(target, attachment, textarget, texture, level) }
/// Equivalent to the Rust `GlContextPtr::framebuffer_texture_layer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_framebufferTextureLayer (glcontextptr: &AzGlContextPtr, target: u32, attachment: u32, texture: u32, level: i32, layer: i32){ gl.framebuffer_texture_layer(target, attachment, texture, level, layer) }
/// Equivalent to the Rust `GlContextPtr::blit_framebuffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_blitFramebuffer (glcontextptr: &AzGlContextPtr, src_x0: i32, src_y0: i32, src_x1: i32, src_y1: i32, dst_x0: i32, dst_y0: i32, dst_x1: i32, dst_y1: i32, mask: u32, filter: u32){ gl.blit_framebuffer(src_x0, src_y0, src_x1, src_y1, dst_x0, dst_y0, dst_x1, dst_y1, mask, filter) }
/// Equivalent to the Rust `GlContextPtr::vertex_attrib_4f()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_vertexAttrib4f (glcontextptr: &AzGlContextPtr, index: u32, x: f32, y: f32, z: f32, w: f32){ gl.vertex_attrib_4f(index, x, y, z, w) }
/// Equivalent to the Rust `GlContextPtr::vertex_attrib_pointer_f32()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_vertexAttribPointerF32 (glcontextptr: &AzGlContextPtr, index: u32, size: i32, normalized: bool, stride: i32, offset: u32){ gl.vertex_attrib_pointer_f32(index, size, normalized, stride, offset) }
/// Equivalent to the Rust `GlContextPtr::vertex_attrib_pointer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_vertexAttribPointer (glcontextptr: &AzGlContextPtr, index: u32, size: i32, type_: u32, normalized: bool, stride: i32, offset: u32){ gl.vertex_attrib_pointer(index, size, type_, normalized, stride, offset) }
/// Equivalent to the Rust `GlContextPtr::vertex_attrib_i_pointer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_vertexAttribIPointer (glcontextptr: &AzGlContextPtr, index: u32, size: i32, type_: u32, stride: i32, offset: u32){ gl.vertex_attrib_i_pointer(index, size, type_, stride, offset) }
/// Equivalent to the Rust `GlContextPtr::vertex_attrib_divisor()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_vertexAttribDivisor (glcontextptr: &AzGlContextPtr, index: u32, divisor: u32){ gl.vertex_attrib_divisor(index, divisor) }
/// Equivalent to the Rust `GlContextPtr::viewport()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_viewport (glcontextptr: &AzGlContextPtr, x: i32, y: i32, width: i32, height: i32){ gl.viewport(x, y, width, height) }
/// Equivalent to the Rust `GlContextPtr::scissor()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_scissor (glcontextptr: &AzGlContextPtr, x: i32, y: i32, width: i32, height: i32){ gl.scissor(x, y, width, height) }
/// Equivalent to the Rust `GlContextPtr::line_width()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_lineWidth (glcontextptr: &AzGlContextPtr, width: f32){ gl.line_width(width) }
/// Equivalent to the Rust `GlContextPtr::use_program()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_useProgram (glcontextptr: &AzGlContextPtr, program: u32){ gl.use_program(program) }
/// Equivalent to the Rust `GlContextPtr::validate_program()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_validateProgram (glcontextptr: &AzGlContextPtr, program: u32){ gl.validate_program(program) }
/// Equivalent to the Rust `GlContextPtr::draw_arrays()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_drawArrays (glcontextptr: &AzGlContextPtr, mode: u32, first: i32, count: i32){ gl.draw_arrays(mode, first, count) }
/// Equivalent to the Rust `GlContextPtr::draw_arrays_instanced()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_drawArraysInstanced (glcontextptr: &AzGlContextPtr, mode: u32, first: i32, count: i32, primcount: i32){ gl.draw_arrays_instanced(mode, first, count, primcount) }
/// Equivalent to the Rust `GlContextPtr::draw_elements()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_drawElements (glcontextptr: &AzGlContextPtr, mode: u32, count: i32, element_type: u32, indices_offset: u32){ gl.draw_elements(mode, count, element_type, indices_offset) }
/// Equivalent to the Rust `GlContextPtr::draw_elements_instanced()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_drawElementsInstanced (glcontextptr: &AzGlContextPtr, mode: u32, count: i32, element_type: u32, indices_offset: u32, primcount: i32){ gl.draw_elements_instanced(mode, count, element_type, indices_offset, primcount) }
/// Equivalent to the Rust `GlContextPtr::blend_color()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_blendColor (glcontextptr: &AzGlContextPtr, r: f32, g: f32, b: f32, a: f32){ gl.blend_color(r, g, b, a) }
/// Equivalent to the Rust `GlContextPtr::blend_func()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_blendFunc (glcontextptr: &AzGlContextPtr, sfactor: u32, dfactor: u32){ gl.blend_func(sfactor, dfactor) }
/// Equivalent to the Rust `GlContextPtr::blend_func_separate()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_blendFuncSeparate (glcontextptr: &AzGlContextPtr, src_rgb: u32, dest_rgb: u32, src_alpha: u32, dest_alpha: u32){ gl.blend_func_separate(src_rgb, dest_rgb, src_alpha, dest_alpha) }
/// Equivalent to the Rust `GlContextPtr::blend_equation()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_blendEquation (glcontextptr: &AzGlContextPtr, mode: u32){ gl.blend_equation(mode) }
/// Equivalent to the Rust `GlContextPtr::blend_equation_separate()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_blendEquationSeparate (glcontextptr: &AzGlContextPtr, mode_rgb: u32, mode_alpha: u32){ gl.blend_equation_separate(mode_rgb, mode_alpha) }
/// Equivalent to the Rust `GlContextPtr::color_mask()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_colorMask (glcontextptr: &AzGlContextPtr, r: bool, g: bool, b: bool, a: bool){ gl.color_mask(r, g, b, a) }
/// Equivalent to the Rust `GlContextPtr::cull_face()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_cullFace (glcontextptr: &AzGlContextPtr, mode: u32){ gl.cull_face(mode) }
/// Equivalent to the Rust `GlContextPtr::front_face()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_frontFace (glcontextptr: &AzGlContextPtr, mode: u32){ gl.front_face(mode) }
/// Equivalent to the Rust `GlContextPtr::enable()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_enable (glcontextptr: &AzGlContextPtr, cap: u32){ gl.enable(cap) }
/// Equivalent to the Rust `GlContextPtr::disable()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_disable (glcontextptr: &AzGlContextPtr, cap: u32){ gl.disable(cap) }
/// Equivalent to the Rust `GlContextPtr::hint()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_hint (glcontextptr: &AzGlContextPtr, param_name: u32, param_val: u32){ gl.hint(param_name, param_val) }
/// Equivalent to the Rust `GlContextPtr::is_enabled()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_isEnabled (glcontextptr: &AzGlContextPtr, cap: u32) -> u8{ gl.is_enabled(cap) }
/// Equivalent to the Rust `GlContextPtr::is_shader()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_isShader (glcontextptr: &AzGlContextPtr, shader: u32) -> u8{ gl.is_shader(shader) }
/// Equivalent to the Rust `GlContextPtr::is_texture()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_isTexture (glcontextptr: &AzGlContextPtr, texture: u32) -> u8{ gl.is_texture(texture) }
/// Equivalent to the Rust `GlContextPtr::is_framebuffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_isFramebuffer (glcontextptr: &AzGlContextPtr, framebuffer: u32) -> u8{ gl.is_framebuffer(framebuffer) }
/// Equivalent to the Rust `GlContextPtr::is_renderbuffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_isRenderbuffer (glcontextptr: &AzGlContextPtr, renderbuffer: u32) -> u8{ gl.is_renderbuffer(renderbuffer) }
/// Equivalent to the Rust `GlContextPtr::check_frame_buffer_status()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_checkFrameBufferStatus (glcontextptr: &AzGlContextPtr, target: u32) -> u32{ gl.check_frame_buffer_status(target) }
/// Equivalent to the Rust `GlContextPtr::enable_vertex_attrib_array()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_enableVertexAttribArray (glcontextptr: &AzGlContextPtr, index: u32){ gl.enable_vertex_attrib_array(index) }
/// Equivalent to the Rust `GlContextPtr::disable_vertex_attrib_array()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_disableVertexAttribArray (glcontextptr: &AzGlContextPtr, index: u32){ gl.disable_vertex_attrib_array(index) }
/// Equivalent to the Rust `GlContextPtr::uniform_1f()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform1f (glcontextptr: &AzGlContextPtr, location: i32, v0: f32){ gl.uniform_1f(location, v0) }
/// Equivalent to the Rust `GlContextPtr::uniform_1fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform1fv (glcontextptr: &AzGlContextPtr, location: i32, values: AzF32VecRef){ gl.uniform_1fv(location, values) }
/// Equivalent to the Rust `GlContextPtr::uniform_1i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform1i (glcontextptr: &AzGlContextPtr, location: i32, v0: i32){ gl.uniform_1i(location, v0) }
/// Equivalent to the Rust `GlContextPtr::uniform_1iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform1iv (glcontextptr: &AzGlContextPtr, location: i32, values: AzI32VecRef){ gl.uniform_1iv(location, values) }
/// Equivalent to the Rust `GlContextPtr::uniform_1ui()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform1ui (glcontextptr: &AzGlContextPtr, location: i32, v0: u32){ gl.uniform_1ui(location, v0) }
/// Equivalent to the Rust `GlContextPtr::uniform_2f()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform2f (glcontextptr: &AzGlContextPtr, location: i32, v0: f32, v1: f32){ gl.uniform_2f(location, v0, v1) }
/// Equivalent to the Rust `GlContextPtr::uniform_2fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform2fv (glcontextptr: &AzGlContextPtr, location: i32, values: AzF32VecRef){ gl.uniform_2fv(location, values) }
/// Equivalent to the Rust `GlContextPtr::uniform_2i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform2i (glcontextptr: &AzGlContextPtr, location: i32, v0: i32, v1: i32){ gl.uniform_2i(location, v0, v1) }
/// Equivalent to the Rust `GlContextPtr::uniform_2iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform2iv (glcontextptr: &AzGlContextPtr, location: i32, values: AzI32VecRef){ gl.uniform_2iv(location, values) }
/// Equivalent to the Rust `GlContextPtr::uniform_2ui()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform2ui (glcontextptr: &AzGlContextPtr, location: i32, v0: u32, v1: u32){ gl.uniform_2ui(location, v0, v1) }
/// Equivalent to the Rust `GlContextPtr::uniform_3f()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform3f (glcontextptr: &AzGlContextPtr, location: i32, v0: f32, v1: f32, v2: f32){ gl.uniform_3f(location, v0, v1, v2) }
/// Equivalent to the Rust `GlContextPtr::uniform_3fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform3fv (glcontextptr: &AzGlContextPtr, location: i32, values: AzF32VecRef){ gl.uniform_3fv(location, values) }
/// Equivalent to the Rust `GlContextPtr::uniform_3i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform3i (glcontextptr: &AzGlContextPtr, location: i32, v0: i32, v1: i32, v2: i32){ gl.uniform_3i(location, v0, v1, v2) }
/// Equivalent to the Rust `GlContextPtr::uniform_3iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform3iv (glcontextptr: &AzGlContextPtr, location: i32, values: AzI32VecRef){ gl.uniform_3iv(location, values) }
/// Equivalent to the Rust `GlContextPtr::uniform_3ui()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform3ui (glcontextptr: &AzGlContextPtr, location: i32, v0: u32, v1: u32, v2: u32){ gl.uniform_3ui(location, v0, v1, v2) }
/// Equivalent to the Rust `GlContextPtr::uniform_4f()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform4f (glcontextptr: &AzGlContextPtr, location: i32, x: f32, y: f32, z: f32, w: f32){ gl.uniform_4f(location, x, y, z, w) }
/// Equivalent to the Rust `GlContextPtr::uniform_4i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform4i (glcontextptr: &AzGlContextPtr, location: i32, x: i32, y: i32, z: i32, w: i32){ gl.uniform_4i(location, x, y, z, w) }
/// Equivalent to the Rust `GlContextPtr::uniform_4iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform4iv (glcontextptr: &AzGlContextPtr, location: i32, values: AzI32VecRef){ gl.uniform_4iv(location, values) }
/// Equivalent to the Rust `GlContextPtr::uniform_4ui()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform4ui (glcontextptr: &AzGlContextPtr, location: i32, x: u32, y: u32, z: u32, w: u32){ gl.uniform_4ui(location, x, y, z, w) }
/// Equivalent to the Rust `GlContextPtr::uniform_4fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform4fv (glcontextptr: &AzGlContextPtr, location: i32, values: AzF32VecRef){ gl.uniform_4fv(location, values) }
/// Equivalent to the Rust `GlContextPtr::uniform_matrix_2fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniformMatrix2fv (glcontextptr: &AzGlContextPtr, location: i32, transpose: bool, value: AzF32VecRef){ gl.uniform_matrix_2fv(location, transpose, value) }
/// Equivalent to the Rust `GlContextPtr::uniform_matrix_3fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniformMatrix3fv (glcontextptr: &AzGlContextPtr, location: i32, transpose: bool, value: AzF32VecRef){ gl.uniform_matrix_3fv(location, transpose, value) }
/// Equivalent to the Rust `GlContextPtr::uniform_matrix_4fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniformMatrix4fv (glcontextptr: &AzGlContextPtr, location: i32, transpose: bool, value: AzF32VecRef){ gl.uniform_matrix_4fv(location, transpose, value) }
/// Equivalent to the Rust `GlContextPtr::depth_mask()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_depthMask (glcontextptr: &AzGlContextPtr, flag: bool){ gl.depth_mask(flag) }
/// Equivalent to the Rust `GlContextPtr::depth_range()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_depthRange (glcontextptr: &AzGlContextPtr, near: f64, far: f64){ gl.depth_range(near, far) }
/// Equivalent to the Rust `GlContextPtr::get_active_attrib()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getActiveAttrib (glcontextptr: &AzGlContextPtr, program: u32, index: u32) -> AzGetActiveAttribReturn{ gl.get_active_attrib(program, index) }
/// Equivalent to the Rust `GlContextPtr::get_active_uniform()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getActiveUniform (glcontextptr: &AzGlContextPtr, program: u32, index: u32) -> AzGetActiveUniformReturn{ gl.get_active_uniform(program, index) }
/// Equivalent to the Rust `GlContextPtr::get_active_uniforms_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getActiveUniformsIv (glcontextptr: &AzGlContextPtr, program: u32, indices: AzGLuintVec, pname: u32) -> AzGLintVec{ gl.get_active_uniforms_iv(program, indices, pname) }
/// Equivalent to the Rust `GlContextPtr::get_active_uniform_block_i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getActiveUniformBlockI (glcontextptr: &AzGlContextPtr, program: u32, index: u32, pname: u32) -> i32{ gl.get_active_uniform_block_i(program, index, pname) }
/// Equivalent to the Rust `GlContextPtr::get_active_uniform_block_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getActiveUniformBlockIv (glcontextptr: &AzGlContextPtr, program: u32, index: u32, pname: u32) -> AzGLintVec{ gl.get_active_uniform_block_iv(program, index, pname) }
/// Equivalent to the Rust `GlContextPtr::get_active_uniform_block_name()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getActiveUniformBlockName (glcontextptr: &AzGlContextPtr, program: u32, index: u32) -> AzAzString{ gl.get_active_uniform_block_name(program, index) }
/// Equivalent to the Rust `GlContextPtr::get_attrib_location()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getAttribLocation (glcontextptr: &AzGlContextPtr, program: u32, name: AzRefstr) -> i32{ gl.get_attrib_location(program, name) }
/// Equivalent to the Rust `GlContextPtr::get_frag_data_location()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getFragDataLocation (glcontextptr: &AzGlContextPtr, program: u32, name: AzRefstr) -> i32{ gl.get_frag_data_location(program, name) }
/// Equivalent to the Rust `GlContextPtr::get_uniform_location()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getUniformLocation (glcontextptr: &AzGlContextPtr, program: u32, name: AzRefstr) -> i32{ gl.get_uniform_location(program, name) }
/// Equivalent to the Rust `GlContextPtr::get_program_info_log()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getProgramInfoLog (glcontextptr: &AzGlContextPtr, program: u32) -> AzAzString{ gl.get_program_info_log(program) }
/// Equivalent to the Rust `GlContextPtr::get_program_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getProgramIv (glcontextptr: &AzGlContextPtr, program: u32, pname: u32, result: AzGLintVecRefMut){ gl.get_program_iv(program, pname, result) }
/// Equivalent to the Rust `GlContextPtr::get_program_binary()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getProgramBinary (glcontextptr: &AzGlContextPtr, program: u32) -> AzGetProgramBinaryReturn{ gl.get_program_binary(program) }
/// Equivalent to the Rust `GlContextPtr::program_binary()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_programBinary (glcontextptr: &AzGlContextPtr, program: u32, format: u32, binary: AzU8VecRef){ gl.program_binary(program, format, binary) }
/// Equivalent to the Rust `GlContextPtr::program_parameter_i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_programParameterI (glcontextptr: &AzGlContextPtr, program: u32, pname: u32, value: i32){ gl.program_parameter_i(program, pname, value) }
/// Equivalent to the Rust `GlContextPtr::get_vertex_attrib_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getVertexAttribIv (glcontextptr: &AzGlContextPtr, index: u32, pname: u32, result: AzGLintVecRefMut){ gl.get_vertex_attrib_iv(index, pname, result) }
/// Equivalent to the Rust `GlContextPtr::get_vertex_attrib_fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getVertexAttribFv (glcontextptr: &AzGlContextPtr, index: u32, pname: u32, result: AzGLfloatVecRefMut){ gl.get_vertex_attrib_fv(index, pname, result) }
/// Equivalent to the Rust `GlContextPtr::get_vertex_attrib_pointer_v()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getVertexAttribPointerV (glcontextptr: &AzGlContextPtr, index: u32, pname: u32) -> isize{ gl.get_vertex_attrib_pointer_v(index, pname) }
/// Equivalent to the Rust `GlContextPtr::get_buffer_parameter_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getBufferParameterIv (glcontextptr: &AzGlContextPtr, target: u32, pname: u32) -> i32{ gl.get_buffer_parameter_iv(target, pname) }
/// Equivalent to the Rust `GlContextPtr::get_shader_info_log()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getShaderInfoLog (glcontextptr: &AzGlContextPtr, shader: u32) -> AzAzString{ gl.get_shader_info_log(shader) }
/// Equivalent to the Rust `GlContextPtr::get_string()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getString (glcontextptr: &AzGlContextPtr, which: u32) -> AzAzString{ gl.get_string(which) }
/// Equivalent to the Rust `GlContextPtr::get_string_i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getStringI (glcontextptr: &AzGlContextPtr, which: u32, index: u32) -> AzAzString{ gl.get_string_i(which, index) }
/// Equivalent to the Rust `GlContextPtr::get_shader_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getShaderIv (glcontextptr: &AzGlContextPtr, shader: u32, pname: u32, result: AzGLintVecRefMut){ gl.get_shader_iv(shader, pname, result) }
/// Equivalent to the Rust `GlContextPtr::get_shader_precision_format()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getShaderPrecisionFormat (glcontextptr: &AzGlContextPtr, shader_type: u32, precision_type: u32) -> AzGlShaderPrecisionFormatReturn{ gl.get_shader_precision_format(shader_type, precision_type) }
/// Equivalent to the Rust `GlContextPtr::compile_shader()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_compileShader (glcontextptr: &AzGlContextPtr, shader: u32){ gl.compile_shader(shader) }
/// Equivalent to the Rust `GlContextPtr::create_program()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_createProgram (glcontextptr: &AzGlContextPtr) -> u32{ gl.create_program() }
/// Equivalent to the Rust `GlContextPtr::delete_program()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteProgram (glcontextptr: &AzGlContextPtr, program: u32){ gl.delete_program(program) }
/// Equivalent to the Rust `GlContextPtr::create_shader()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_createShader (glcontextptr: &AzGlContextPtr, shader_type: u32) -> u32{ gl.create_shader(shader_type) }
/// Equivalent to the Rust `GlContextPtr::delete_shader()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteShader (glcontextptr: &AzGlContextPtr, shader: u32){ gl.delete_shader(shader) }
/// Equivalent to the Rust `GlContextPtr::detach_shader()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_detachShader (glcontextptr: &AzGlContextPtr, program: u32, shader: u32){ gl.detach_shader(program, shader) }
/// Equivalent to the Rust `GlContextPtr::link_program()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_linkProgram (glcontextptr: &AzGlContextPtr, program: u32){ gl.link_program(program) }
/// Equivalent to the Rust `GlContextPtr::clear_color()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_clearColor (glcontextptr: &AzGlContextPtr, r: f32, g: f32, b: f32, a: f32){ gl.clear_color(r, g, b, a) }
/// Equivalent to the Rust `GlContextPtr::clear()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_clear (glcontextptr: &AzGlContextPtr, buffer_mask: u32){ gl.clear(buffer_mask) }
/// Equivalent to the Rust `GlContextPtr::clear_depth()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_clearDepth (glcontextptr: &AzGlContextPtr, depth: f64){ gl.clear_depth(depth) }
/// Equivalent to the Rust `GlContextPtr::clear_stencil()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_clearStencil (glcontextptr: &AzGlContextPtr, s: i32){ gl.clear_stencil(s) }
/// Equivalent to the Rust `GlContextPtr::flush()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_flush (glcontextptr: &AzGlContextPtr){ gl.flush() }
/// Equivalent to the Rust `GlContextPtr::finish()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_finish (glcontextptr: &AzGlContextPtr){ gl.finish() }
/// Equivalent to the Rust `GlContextPtr::get_error()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getError (glcontextptr: &AzGlContextPtr) -> u32{ gl.get_error() }
/// Equivalent to the Rust `GlContextPtr::stencil_mask()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_stencilMask (glcontextptr: &AzGlContextPtr, mask: u32){ gl.stencil_mask(mask) }
/// Equivalent to the Rust `GlContextPtr::stencil_mask_separate()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_stencilMaskSeparate (glcontextptr: &AzGlContextPtr, face: u32, mask: u32){ gl.stencil_mask_separate(face, mask) }
/// Equivalent to the Rust `GlContextPtr::stencil_func()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_stencilFunc (glcontextptr: &AzGlContextPtr, func: u32, ref_: i32, mask: u32){ gl.stencil_func(func, ref_, mask) }
/// Equivalent to the Rust `GlContextPtr::stencil_func_separate()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_stencilFuncSeparate (glcontextptr: &AzGlContextPtr, face: u32, func: u32, ref_: i32, mask: u32){ gl.stencil_func_separate(face, func, ref_, mask) }
/// Equivalent to the Rust `GlContextPtr::stencil_op()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_stencilOp (glcontextptr: &AzGlContextPtr, sfail: u32, dpfail: u32, dppass: u32){ gl.stencil_op(sfail, dpfail, dppass) }
/// Equivalent to the Rust `GlContextPtr::stencil_op_separate()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_stencilOpSeparate (glcontextptr: &AzGlContextPtr, face: u32, sfail: u32, dpfail: u32, dppass: u32){ gl.stencil_op_separate(face, sfail, dpfail, dppass) }
/// Equivalent to the Rust `GlContextPtr::egl_image_target_texture2d_oes()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_eglImageTargetTexture2dOes (glcontextptr: &AzGlContextPtr, target: u32, image: AzGlVoidPtrConst){ gl.egl_image_target_texture2d_oes(target, image) }
/// Equivalent to the Rust `GlContextPtr::generate_mipmap()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_generateMipmap (glcontextptr: &AzGlContextPtr, target: u32){ gl.generate_mipmap(target) }
/// Equivalent to the Rust `GlContextPtr::insert_event_marker_ext()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_insertEventMarkerExt (glcontextptr: &AzGlContextPtr, message: AzRefstr){ gl.insert_event_marker_ext(message) }
/// Equivalent to the Rust `GlContextPtr::push_group_marker_ext()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_pushGroupMarkerExt (glcontextptr: &AzGlContextPtr, message: AzRefstr){ gl.push_group_marker_ext(message) }
/// Equivalent to the Rust `GlContextPtr::pop_group_marker_ext()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_popGroupMarkerExt (glcontextptr: &AzGlContextPtr){ gl.pop_group_marker_ext() }
/// Equivalent to the Rust `GlContextPtr::debug_message_insert_khr()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_debugMessageInsertKhr (glcontextptr: &AzGlContextPtr, source: u32, type_: u32, id: u32, severity: u32, message: AzRefstr){ gl.debug_message_insert_khr(source, type_, id, severity, message) }
/// Equivalent to the Rust `GlContextPtr::push_debug_group_khr()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_pushDebugGroupKhr (glcontextptr: &AzGlContextPtr, source: u32, id: u32, message: AzRefstr){ gl.push_debug_group_khr(source, id, message) }
/// Equivalent to the Rust `GlContextPtr::pop_debug_group_khr()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_popDebugGroupKhr (glcontextptr: &AzGlContextPtr){ gl.pop_debug_group_khr() }
/// Equivalent to the Rust `GlContextPtr::fence_sync()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_fenceSync (glcontextptr: &AzGlContextPtr, condition: u32, flags: u32) -> AzGLsyncPtr{ gl.fence_sync(condition, flags) }
/// Equivalent to the Rust `GlContextPtr::client_wait_sync()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_clientWaitSync (glcontextptr: &AzGlContextPtr, sync: AzGLsyncPtr, flags: u32, timeout: u64) -> u32{ gl.client_wait_sync(sync, flags, timeout) }
/// Equivalent to the Rust `GlContextPtr::wait_sync()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_waitSync (glcontextptr: &AzGlContextPtr, sync: AzGLsyncPtr, flags: u32, timeout: u64){ gl.wait_sync(sync, flags, timeout) }
/// Equivalent to the Rust `GlContextPtr::delete_sync()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteSync (glcontextptr: &AzGlContextPtr, sync: AzGLsyncPtr){ gl.delete_sync(sync) }
/// Equivalent to the Rust `GlContextPtr::texture_range_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_textureRangeApple (glcontextptr: &AzGlContextPtr, target: u32, data: AzU8VecRef){ gl.texture_range_apple(target, data) }
/// Equivalent to the Rust `GlContextPtr::gen_fences_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_genFencesApple (glcontextptr: &AzGlContextPtr, n: i32) -> AzGLuintVec{ gl.gen_fences_apple(n) }
/// Equivalent to the Rust `GlContextPtr::delete_fences_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteFencesApple (glcontextptr: &AzGlContextPtr, fences: AzGLuintVecRef){ gl.delete_fences_apple(fences) }
/// Equivalent to the Rust `GlContextPtr::set_fence_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_setFenceApple (glcontextptr: &AzGlContextPtr, fence: u32){ gl.set_fence_apple(fence) }
/// Equivalent to the Rust `GlContextPtr::finish_fence_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_finishFenceApple (glcontextptr: &AzGlContextPtr, fence: u32){ gl.finish_fence_apple(fence) }
/// Equivalent to the Rust `GlContextPtr::test_fence_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_testFenceApple (glcontextptr: &AzGlContextPtr, fence: u32){ gl.test_fence_apple(fence) }
/// Equivalent to the Rust `GlContextPtr::test_object_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_testObjectApple (glcontextptr: &AzGlContextPtr, object: u32, name: u32) -> u8{ gl.test_object_apple(object, name) }
/// Equivalent to the Rust `GlContextPtr::finish_object_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_finishObjectApple (glcontextptr: &AzGlContextPtr, object: u32, name: u32){ gl.finish_object_apple(object, name) }
/// Equivalent to the Rust `GlContextPtr::get_frag_data_index()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getFragDataIndex (glcontextptr: &AzGlContextPtr, program: u32, name: AzRefstr) -> i32{ gl.get_frag_data_index(program, name) }
/// Equivalent to the Rust `GlContextPtr::blend_barrier_khr()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_blendBarrierKhr (glcontextptr: &AzGlContextPtr){ gl.blend_barrier_khr() }
/// Equivalent to the Rust `GlContextPtr::bind_frag_data_location_indexed()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindFragDataLocationIndexed (glcontextptr: &AzGlContextPtr, program: u32, color_number: u32, index: u32, name: AzRefstr){ gl.bind_frag_data_location_indexed(program, color_number, index, name) }
/// Equivalent to the Rust `GlContextPtr::get_debug_messages()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getDebugMessages (glcontextptr: &AzGlContextPtr) -> AzAzDebugMessageVec{ gl.get_debug_messages() }
/// Equivalent to the Rust `GlContextPtr::provoking_vertex_angle()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_provokingVertexAngle (glcontextptr: &AzGlContextPtr, mode: u32){ gl.provoking_vertex_angle(mode) }
/// Equivalent to the Rust `GlContextPtr::gen_vertex_arrays_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_genVertexArraysApple (glcontextptr: &AzGlContextPtr, n: i32) -> AzGLuintVec{ gl.gen_vertex_arrays_apple(n) }
/// Equivalent to the Rust `GlContextPtr::bind_vertex_array_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindVertexArrayApple (glcontextptr: &AzGlContextPtr, vao: u32){ gl.bind_vertex_array_apple(vao) }
/// Equivalent to the Rust `GlContextPtr::delete_vertex_arrays_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteVertexArraysApple (glcontextptr: &AzGlContextPtr, vertex_arrays: AzGLuintVecRef){ gl.delete_vertex_arrays_apple(vertex_arrays) }
/// Equivalent to the Rust `GlContextPtr::copy_texture_chromium()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_copyTextureChromium (glcontextptr: &AzGlContextPtr, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, internal_format: i32, dest_type: u32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8){ gl.copy_texture_chromium(source_id, source_level, dest_target, dest_id, dest_level, internal_format, dest_type, unpack_flip_y, unpack_premultiply_alpha, unpack_unmultiply_alpha) }
/// Equivalent to the Rust `GlContextPtr::copy_sub_texture_chromium()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_copySubTextureChromium (glcontextptr: &AzGlContextPtr, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, x_offset: i32, y_offset: i32, x: i32, y: i32, width: i32, height: i32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8){ gl.copy_sub_texture_chromium(source_id, source_level, dest_target, dest_id, dest_level, x_offset, y_offset, x, y, width, height, unpack_flip_y, unpack_premultiply_alpha, unpack_unmultiply_alpha) }
/// Equivalent to the Rust `GlContextPtr::egl_image_target_renderbuffer_storage_oes()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_eglImageTargetRenderbufferStorageOes (glcontextptr: &AzGlContextPtr, target: u32, image: AzGlVoidPtrConst){ gl.egl_image_target_renderbuffer_storage_oes(target, image) }
/// Equivalent to the Rust `GlContextPtr::copy_texture_3d_angle()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_copyTexture3dAngle (glcontextptr: &AzGlContextPtr, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, internal_format: i32, dest_type: u32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8){ gl.copy_texture_3d_angle(source_id, source_level, dest_target, dest_id, dest_level, internal_format, dest_type, unpack_flip_y, unpack_premultiply_alpha, unpack_unmultiply_alpha) }
/// Equivalent to the Rust `GlContextPtr::copy_sub_texture_3d_angle()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_copySubTexture3dAngle (glcontextptr: &AzGlContextPtr, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, x_offset: i32, y_offset: i32, z_offset: i32, x: i32, y: i32, z: i32, width: i32, height: i32, depth: i32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8){ gl.copy_sub_texture_3d_angle(source_id, source_level, dest_target, dest_id, dest_level, x_offset, y_offset, z_offset, x, y, z, width, height, depth, unpack_flip_y, unpack_premultiply_alpha, unpack_unmultiply_alpha) }
/// Equivalent to the Rust `GlContextPtr::buffer_storage()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bufferStorage (glcontextptr: &AzGlContextPtr, target: u32, size: isize, data: AzGlVoidPtrConst, flags: u32){ gl.buffer_storage(target, size, data, flags) }
/// Equivalent to the Rust `GlContextPtr::flush_mapped_buffer_range()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_flushMappedBufferRange (glcontextptr: &AzGlContextPtr, target: u32, offset: isize, length: isize){ gl.flush_mapped_buffer_range(target, offset, length) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AzGlType>` struct
#[repr(C)] pub struct AzAzGlType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `&[u8]`
#[repr(C)] pub struct AzU8VecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `&mut [u8]`
#[repr(C)] pub struct AzU8VecRefMut { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `&[f32]`
#[repr(C)] pub struct AzF32VecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `&[i32]`
#[repr(C)] pub struct AzI32VecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `&[GLuint]` aka `&[u32]`
#[repr(C)] pub struct AzGLuintVecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `&[GLenum]` aka `&[u32]`
#[repr(C)] pub struct AzGLenumVecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `&mut [GLint]` aka `&mut [i32]`
#[repr(C)] pub struct AzGLintVecRefMut { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `&mut [GLint64]` aka `&mut [i64]`
#[repr(C)] pub struct AzGLint64VecRefMut { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `&mut [GLboolean]` aka `&mut [u8]`
#[repr(C)] pub struct AzGLbooleanVecRefMut { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `&mut [GLfloat]` aka `&mut [f32]`
#[repr(C)] pub struct AzGLfloatVecRefMut { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `&[Refstr]` aka `&mut [&str]`
#[repr(C)] pub struct AzRefstrVecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `&str`
#[repr(C)] pub struct AzRefstr { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `(U8Vec, u32)`
#[repr(C)] pub struct AzGetProgramBinaryReturn { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `(i32, u32, AzString)`
#[repr(C)] pub struct AzGetActiveAttribReturn { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `*const gleam::gl::GLsync`
pub use azul_core::gl::GLsyncPtr as AzGLsyncPtrTT;
pub use AzGLsyncPtrTT as AzGLsyncPtr;
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `(i32, u32, AzString)`
#[repr(C)] pub struct AzGetActiveUniformReturn { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AzDebugMessage>` struct
#[repr(C)] pub struct AzAzDebugMessage { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for u32
pub type AzGLuint = Azu32<>;

/// Type alias for u32
pub type AzGLenum = Azu32<>;

/// Type alias for c_void
pub type AzGLvoid = Azc_void<>;

/// Type alias for i32
pub type AzGLint = Azi32<>;

/// Type alias for i32
pub type AzGLsizei = Azi32<>;

/// Type alias for u8
pub type AzGLboolean = Azu8<>;

/// Pointer to rust-allocated `Box<ImageRef>` struct
pub use azul_core::app_resources::ImageRef as AzImageRefTT;
pub use AzImageRefTT as AzImageRef;
/// Creates an "invalid" image with a width and height that reserves an image key, but does not render anything
#[no_mangle] pub extern "C" fn AzImageRef_nullImage (width: usize, height: usize, format: AzRawImageFormat, tag: AzU8Vec) -> AzImageRef { let object: ImageRef = AzImageRef::null_image(width, height, format, tag.as_ref().to_vec()); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzImageRef { ptr } }
/// Creates an image reference from a CPU-backed buffer
#[no_mangle] pub extern "C" fn AzImageRef_rawImage (data: AzRawImage) -> AzOptionImageRef { let object: ImageRef = AzImageRef::new_rawimage(data).into(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzImageRef { ptr } }
/// Creates an image reference from an OpenGL texture
#[no_mangle] pub extern "C" fn AzImageRef_glTexture (texture: AzTexture) -> AzImageRef { let object: ImageRef = AzImageRef::new_gltexture(texture); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzImageRef { ptr } }
/// Creates an image reference from a callback that is going to be rendered with the given nodes computed size
#[no_mangle] pub extern "C" fn AzImageRef_callback (data: AzRefAny, callback: AzRenderImageCallbackType) -> AzImageRef { let object: ImageRef = AzImageRef::callback(callback, data); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzImageRef { ptr } }
/// Creates a new copy of the image bytes instead of shallow-copying the reference
#[no_mangle] pub extern "C" fn AzImageRef_cloneBytes (imageref: &AzImageRef) -> AzImageRef{ imageref.deep_copy() }
/// Returns whether the image is a null (invalid) image
#[no_mangle] pub extern "C" fn AzImageRef_isInvalid (imageref: &AzImageRef) -> bool{ imageref.is_null_image() }
/// Returns whether the image is a GL texture
#[no_mangle] pub extern "C" fn AzImageRef_isGlTexture (imageref: &AzImageRef) -> bool{ imageref.is_gl_texture() }
/// Returns whether the image is a raw (CPU-decoded) image
#[no_mangle] pub extern "C" fn AzImageRef_isRawImage (imageref: &AzImageRef) -> bool{ imageref.is_raw_image() }
/// Returns whether the image is a `RenderImageCallback`
#[no_mangle] pub extern "C" fn AzImageRef_isCallback (imageref: &AzImageRef) -> bool{ imageref.is_callback() }
/// If the image is a RawImage, returns a COPY of the internal image bytes (useful for encoding the RawImage / exporting the ImageRef to a file)
#[no_mangle] pub extern "C" fn AzImageRef_getRawImage (imageref: &AzImageRef) -> AzOptionRawImage{ imageref.get_rawimage().into() }
/// Returns the hash of the ImageRef (fast)
#[no_mangle] pub extern "C" fn AzImageRef_getHash (imageref: &AzImageRef) -> u64{ imageref.get_hash().0 as u64 }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RawImage>` struct
#[repr(C)] pub struct AzRawImage { pub ptr: *mut c_void }
/// Returns a zero-sized image
#[no_mangle] pub extern "C" fn AzRawImage_empty () -> AzRawImage { let object: RawImage = AzRawImage::null_image(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzRawImage { ptr } }
/// Allocates a width * height, single-channel image with zeroed bytes
#[no_mangle] pub extern "C" fn AzRawImage_allocateClipMask (size: AzLayoutSize) -> AzRawImage { let object: RawImage = AzRawImage::allocate_mask(size); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzRawImage { ptr } }
/// Decodes a RawImage from any supported image format - automatically guesses the format based on magic header
#[no_mangle] pub extern "C" fn AzRawImage_decodeImageBytesAny (bytes: AzU8VecRef) -> AzResultRawImageDecodeImageError { let object: RawImage = azul_layout::image::decode::decode_raw_image_from_any_bytes(bytes.as_slice()); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzRawImage { ptr } }
/// Equivalent to the Rust `RawImage::draw_clip_mask()` function.
#[no_mangle] pub extern "C" fn AzRawImage_drawClipMask (rawimage: &mut AzRawImage, node: AzSvgNode, style: AzSvgStyle) -> bool{ azul_layout::xml::svg::render_node_clipmask_cpu(rawimage, &node, style).is_some() }
/// Encodes the RawImage in the BMP image format
#[no_mangle] pub extern "C" fn AzRawImage_encodeBmp (rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError{ azul_layout::image::encode::encode_bmp(rawimage) }
/// Encodes the RawImage in the PNG image format
#[no_mangle] pub extern "C" fn AzRawImage_encodePng (rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError{ azul_layout::image::encode::encode_png(rawimage) }
/// Encodes the RawImage in the JPG image format
#[no_mangle] pub extern "C" fn AzRawImage_encodeJpeg (rawimage: &AzRawImage, quality: u8) -> AzResultU8VecEncodeImageError{ azul_layout::image::encode::encode_jpeg(rawimage, quality) }
/// Encodes the RawImage in the TGA image format
#[no_mangle] pub extern "C" fn AzRawImage_encodeTga (rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError{ azul_layout::image::encode::encode_tga(rawimage) }
/// Encodes the RawImage in the PNM image format
#[no_mangle] pub extern "C" fn AzRawImage_encodePnm (rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError{ azul_layout::image::encode::encode_pnm(rawimage) }
/// Encodes the RawImage in the GIF image format
#[no_mangle] pub extern "C" fn AzRawImage_encodeGif (rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError{ azul_layout::image::encode::encode_gif(rawimage) }
/// Encodes the RawImage in the TIFF image format
#[no_mangle] pub extern "C" fn AzRawImage_encodeTiff (rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError{ azul_layout::image::encode::encode_tiff(rawimage) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ImageMask>` struct
#[repr(C)] pub struct AzImageMask { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RawImageFormat>` struct
#[repr(C)] pub struct AzRawImageFormat { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<EncodeImageError>` struct
#[repr(C)] pub struct AzEncodeImageError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DecodeImageError>` struct
#[repr(C)] pub struct AzDecodeImageError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RawImageData>` struct
#[repr(C)] pub struct AzRawImageData { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `ParsedFontDestructorFnType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<FontMetrics>` struct
#[repr(C)] pub struct AzFontMetrics { pub ptr: *mut c_void }
/// Returns a FontMetrics struct with all fields set to 0
#[no_mangle] pub extern "C" fn AzFontMetrics_zero () -> AzFontMetrics { let object: FontMetrics = AzFontMetrics::zero(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzFontMetrics { ptr } }
/// If set, use `OS/2.sTypoAscender - OS/2.sTypoDescender + OS/2.sTypoLineGap` to calculate the height.
#[no_mangle] pub extern "C" fn AzFontMetrics_useTypoMetrics (fontmetrics: &AzFontMetrics) -> bool{ fontmetrics.use_typo_metrics() }
/// Equivalent to the Rust `FontMetrics::get_ascender()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getAscender (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_ascender(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_descender()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getDescender (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_descender(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_line_gap()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getLineGap (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_line_gap(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_x_min()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getXMin (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_x_min(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_y_min()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getYMin (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_y_min(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_x_max()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getXMax (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_x_max(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_y_max()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getYMax (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_y_max(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_advance_width_max()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getAdvanceWidthMax (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_advance_width_max(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_min_left_side_bearing()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getMinLeftSideBearing (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_min_left_side_bearing(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_min_right_side_bearing()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getMinRightSideBearing (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_min_right_side_bearing(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_x_max_extent()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getXMaxExtent (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_x_max_extent(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_x_avg_char_width()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getXAvgCharWidth (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_x_avg_char_width(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_y_subscript_x_size()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getYSubscriptXSize (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_y_subscript_x_size(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_y_subscript_y_size()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getYSubscriptYSize (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_y_subscript_y_size(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_y_subscript_x_offset()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getYSubscriptXOffset (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_y_subscript_x_offset(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_y_subscript_y_offset()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getYSubscriptYOffset (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_y_subscript_y_offset(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_y_superscript_x_size()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getYSuperscriptXSize (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_y_superscript_x_size(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_y_superscript_y_size()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getYSuperscriptYSize (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_y_superscript_y_size(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_y_superscript_x_offset()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getYSuperscriptXOffset (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_y_superscript_x_offset(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_y_superscript_y_offset()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getYSuperscriptYOffset (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_y_superscript_y_offset(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_y_strikeout_size()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getYStrikeoutSize (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_y_strikeout_size(target_font_size) }
/// Equivalent to the Rust `FontMetrics::get_y_strikeout_position()` function.
#[no_mangle] pub extern "C" fn AzFontMetrics_getYStrikeoutPosition (fontmetrics: &AzFontMetrics, target_font_size: f32) -> f32{ fontmetrics.get_y_strikeout_position(target_font_size) }
/* Error: Type is not stack allocated! */

/// Atomically reference-counted parsed font data
pub use azul_css::FontRef as AzFontRefTT;
pub use AzFontRefTT as AzFontRef;
/// Parses a new font from bytes. Returns `None` if the font could not be parsed correctly.
#[no_mangle] pub extern "C" fn AzFontRef_parse (source: AzLoadedFontSource) -> AzOptionFontRef { let object: FontRef = azul_layout::parse_font_fn(source).into(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzFontRef { ptr } }
/// Returns the font bytes of the underlying font source
#[no_mangle] pub extern "C" fn AzFontRef_getBytes (fontref: &AzFontRef) -> AzU8Vec{ fontref.get_bytes() }
/// Returns the font metrics of the parsed font
#[no_mangle] pub extern "C" fn AzFontRef_getFontMetrics (fontref: &AzFontRef) -> AzFontMetrics{ azul_layout::text2::get_font_metrics_fontref(fontref) }
/// Returns the text layout of the shaped text
#[no_mangle] pub extern "C" fn AzFontRef_shapeText (fontref: &AzFontRef, text: AzRefstr, options: AzResolvedTextLayoutOptions) -> AzInlineText{ azul_layout::text2::layout::shape_text(fontref, text.as_str(), &options) }
/// Returns the hash of the FontRef (fast)
#[no_mangle] pub extern "C" fn AzFontRef_getHash (fontref: &AzFontRef) -> u64{ azul_core::app_resources::font_ref_get_hash(fontref) }
/* Error: Type is not stack allocated! */

/// Source data of a font file (bytes)
#[repr(C)] pub struct AzLoadedFontSource { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Svg>` struct
pub use azul_layout::xml::svg::Svg as AzSvgTT;
pub use AzSvgTT as AzSvg;
/// Creates a new `Svg` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Svg::from_string()` constructor.
#[no_mangle] pub extern "C" fn AzSvg_fromString (svg_string: AzAzString, parse_options: AzSvgParseOptions) -> AzResultSvgSvgParseError { let object: Svg = match azul_layout::xml::svg::svg_parse(svg_string.as_ref().as_bytes(), parse_options) { Ok(o) => azul_core::svg::ResultSvgSvgParseError::Ok(unsafe { core::mem::transmute(o) }), Err(e) => azul_core::svg::ResultSvgSvgParseError::Err(e) }; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzSvg { ptr } }
/// Creates a new `Svg` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Svg::from_bytes()` constructor.
#[no_mangle] pub extern "C" fn AzSvg_fromBytes (svg_bytes: AzU8VecRef, parse_options: AzSvgParseOptions) -> AzResultSvgSvgParseError { let object: Svg = match azul_layout::xml::svg::svg_parse(svg_bytes.as_slice(), parse_options) { Ok(o) => azul_core::svg::ResultSvgSvgParseError::Ok(unsafe { core::mem::transmute(o) }), Err(e) => azul_core::svg::ResultSvgSvgParseError::Err(e) }; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzSvg { ptr } }
/// Equivalent to the Rust `Svg::get_root()` function.
#[no_mangle] pub extern "C" fn AzSvg_getRoot (svg: &AzSvg) -> AzSvgXmlNode{ azul_layout::xml::svg::svg_root(svg) }
/// Equivalent to the Rust `Svg::render()` function.
#[no_mangle] pub extern "C" fn AzSvg_render (svg: &AzSvg, options: AzSvgRenderOptions) -> AzOptionRawImage{ azul_layout::xml::svg::svg_render(svg, options).into() }
/// Equivalent to the Rust `Svg::to_string()` function.
#[no_mangle] pub extern "C" fn AzSvg_toString (svg: &AzSvg, options: AzSvgXmlOptions) -> AzAzString{ azul_layout::xml::svg::svg_to_string(svg, options).into() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgXmlNode>` struct
pub use azul_layout::xml::svg::SvgXmlNode as AzSvgXmlNodeTT;
pub use AzSvgXmlNodeTT as AzSvgXmlNode;
/// Creates a new `SvgXmlNode` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `SvgXmlNode::parse_from()` constructor.
#[no_mangle] pub extern "C" fn AzSvgXmlNode_parseFrom (svg_bytes: AzU8VecRef, parse_options: AzSvgParseOptions) -> AzResultSvgXmlNodeSvgParseError { let object: SvgXmlNode = match azul_layout::xml::svg::svgxmlnode_parse(svg_bytes.as_slice(), parse_options) { Ok(o) => azul_core::svg::ResultSvgXmlNodeSvgParseError::Ok(unsafe { core::mem::transmute(o) }), Err(e) => azul_core::svg::ResultSvgXmlNodeSvgParseError::Err(e) }; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzSvgXmlNode { ptr } }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgMultiPolygon>` struct
#[repr(C)] pub struct AzSvgMultiPolygon { pub ptr: *mut c_void }
/// Returns the bounds of the polygon
#[no_mangle] pub extern "C" fn AzSvgMultiPolygon_getBounds (svgmultipolygon: &AzSvgMultiPolygon) -> AzSvgRect{ svgmultipolygon.get_bounds() }
/// Returns whether the polygon contains a point
#[no_mangle] pub extern "C" fn AzSvgMultiPolygon_containsPoint (svgmultipolygon: &AzSvgMultiPolygon, point: AzSvgPoint, fill_rule: AzSvgFillRule, tolerance: f32) -> bool{ azul_layout::xml::svg::polygon_contains_point(svgmultipolygon, point, fill_rule, tolerance) }
/// Unions two MultiPolygons, returns the unioned MultiPolygon
#[no_mangle] pub extern "C" fn AzSvgMultiPolygon_union (svgmultipolygon: &AzSvgMultiPolygon, other: AzSvgMultiPolygon) -> AzSvgMultiPolygon{ azul_layout::xml::svg::svg_multi_polygon_union(svgmultipolygon, &other) }
/// Intersects two MultiPolygons, returns the intersected MultiPolygon
#[no_mangle] pub extern "C" fn AzSvgMultiPolygon_intersection (svgmultipolygon: &AzSvgMultiPolygon, other: AzSvgMultiPolygon) -> AzSvgMultiPolygon{ azul_layout::xml::svg::svg_multi_polygon_intersection(svgmultipolygon, &other) }
/// Calculates the difference two MultiPolygons, returns a MultiPolygon
#[no_mangle] pub extern "C" fn AzSvgMultiPolygon_difference (svgmultipolygon: &AzSvgMultiPolygon, other: AzSvgMultiPolygon) -> AzSvgMultiPolygon{ azul_layout::xml::svg::svg_multi_polygon_difference(svgmultipolygon, &other) }
/// Xors two MultiPolygons, returns a MultiPolygon
#[no_mangle] pub extern "C" fn AzSvgMultiPolygon_xor (svgmultipolygon: &AzSvgMultiPolygon, other: AzSvgMultiPolygon) -> AzSvgMultiPolygon{ azul_layout::xml::svg::svg_multi_polygon_xor(svgmultipolygon, &other) }
/// Equivalent to the Rust `SvgMultiPolygon::tessellate_fill()` function.
#[no_mangle] pub extern "C" fn AzSvgMultiPolygon_tessellateFill (svgmultipolygon: &AzSvgMultiPolygon, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_multi_polygon_fill(svgmultipolygon, fill_style) }
/// Equivalent to the Rust `SvgMultiPolygon::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgMultiPolygon_tessellateStroke (svgmultipolygon: &AzSvgMultiPolygon, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_multi_polygon_stroke(svgmultipolygon, stroke_style) }
/* Error: Type is not stack allocated! */

/// One `SvgNode` corresponds to one SVG `<path></path>` element
#[repr(C)] pub struct AzSvgNode { pub ptr: *mut c_void }
/// Equivalent to the Rust `SvgNode::tessellate_fill()` function.
#[no_mangle] pub extern "C" fn AzSvgNode_tessellateFill (svgnode: &AzSvgNode, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_node_fill(svgnode, fill_style) }
/// Equivalent to the Rust `SvgNode::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgNode_tessellateStroke (svgnode: &AzSvgNode, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_node_stroke(svgnode, stroke_style) }
/// Returns whether the shape is closed
#[no_mangle] pub extern "C" fn AzSvgNode_isClosed (svgnode: &AzSvgNode) -> bool{ svgnode.is_closed() }
/// Returns the bounds of the polygon
#[no_mangle] pub extern "C" fn AzSvgNode_containsPoint (svgnode: &AzSvgNode, point: AzSvgPoint, fill_rule: AzSvgFillRule, tolerance: f32) -> bool{ azul_layout::xml::svg::svg_node_contains_point(svgnode, point, fill_rule, tolerance) }
/// Equivalent to the Rust `SvgNode::get_bounds()` function.
#[no_mangle] pub extern "C" fn AzSvgNode_getBounds (svgnode: &AzSvgNode) -> AzSvgRect{ svgnode.get_bounds() }
/* Error: Type is not stack allocated! */

/// One `SvgSimpleNode` is either a path, a rect or a circle
#[repr(C)] pub struct AzSvgSimpleNode { pub ptr: *mut c_void }
/// Equivalent to the Rust `SvgSimpleNode::get_bounds()` function.
#[no_mangle] pub extern "C" fn AzSvgSimpleNode_getBounds (svgsimplenode: &AzSvgSimpleNode) -> AzSvgRect{ svgsimplenode.get_bounds() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgStyledNode>` struct
#[repr(C)] pub struct AzSvgStyledNode { pub ptr: *mut c_void }
/// Equivalent to the Rust `SvgStyledNode::tessellate()` function.
#[no_mangle] pub extern "C" fn AzSvgStyledNode_tessellate (svgstylednode: &AzSvgStyledNode) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_styled_node(svgstylednode) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgCircle>` struct
#[repr(C)] pub struct AzSvgCircle { pub ptr: *mut c_void }
/// Equivalent to the Rust `SvgCircle::tessellate_fill()` function.
#[no_mangle] pub extern "C" fn AzSvgCircle_tessellateFill (svgcircle: &AzSvgCircle, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_circle_fill(svgcircle, fill_style) }
/// Equivalent to the Rust `SvgCircle::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgCircle_tessellateStroke (svgcircle: &AzSvgCircle, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_circle_stroke(svgcircle, stroke_style) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgPath>` struct
#[repr(C)] pub struct AzSvgPath { pub ptr: *mut c_void }
/// Returns whether the path is closed
#[no_mangle] pub extern "C" fn AzSvgPath_isClosed (svgpath: &AzSvgPath) -> bool{ svgpath.is_closed() }
/// Reverses the order of points in the path so that the path runs in the opposite direction afterwards
#[no_mangle] pub extern "C" fn AzSvgPath_reverse (svgpath: &mut AzSvgPath){ svgpath.reverse() }
/// Returns the first point of the path (or None if path has no items)
#[no_mangle] pub extern "C" fn AzSvgPath_getStart (svgpath: &AzSvgPath) -> AzOptionSvgPoint{ svgpath.get_start().into() }
/// Returns the first point of the path (or None if path has no items)
#[no_mangle] pub extern "C" fn AzSvgPath_getEnd (svgpath: &AzSvgPath) -> AzOptionSvgPoint{ svgpath.get_end().into() }
/// Returns the axis-aligned bounding rect of this path
#[no_mangle] pub extern "C" fn AzSvgPath_getBounds (svgpath: &mut AzSvgPath) -> AzSvgRect{ svgpath.get_bounds() }
/// Adds a path to the end of the current path
#[no_mangle] pub extern "C" fn AzSvgPath_joinWith (svgpath: &mut AzSvgPath, path: AzSvgPath){ svgpath.join_with(path); }
/// Offset the path by a certain distance. Will create bezier curves around the edges when the path is closed
#[no_mangle] pub extern "C" fn AzSvgPath_offset (svgpath: &mut AzSvgPath, distance: f32, join: AzSvgLineJoin, cap: AzSvgLineCap) -> AzSvgPath{ azul_layout::xml::svg::svg_path_offset(svgpath, distance, join, cap) }
/// Round the edges with a cubic curve
#[no_mangle] pub extern "C" fn AzSvgPath_bevel (svgpath: &mut AzSvgPath, distance: f32) -> AzSvgPath{ azul_layout::xml::svg::svg_path_bevel(svgpath, distance) }
/// Equivalent to the Rust `SvgPath::tessellate_fill()` function.
#[no_mangle] pub extern "C" fn AzSvgPath_tessellateFill (svgpath: &AzSvgPath, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_path_fill(svgpath, fill_style) }
/// Equivalent to the Rust `SvgPath::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgPath_tessellateStroke (svgpath: &AzSvgPath, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_path_stroke(svgpath, stroke_style) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgPathElement>` struct
#[repr(C)] pub struct AzSvgPathElement { pub ptr: *mut c_void }
/// Reverses the order of points in the path so that the path runs in the opposite direction afterwards
#[no_mangle] pub extern "C" fn AzSvgPathElement_reverse (svgpathelement: &mut AzSvgPathElement){ svgpathelement.reverse() }
/// Returns the starting point of this item
#[no_mangle] pub extern "C" fn AzSvgPathElement_getStart (svgpathelement: &AzSvgPathElement) -> AzSvgPoint{ svgpathelement.get_start() }
/// Returns the ending point of this item
#[no_mangle] pub extern "C" fn AzSvgPathElement_getEnd (svgpathelement: &AzSvgPathElement) -> AzSvgPoint{ svgpathelement.get_end() }
/// Returns the bounding box of this item
#[no_mangle] pub extern "C" fn AzSvgPathElement_getBounds (svgpathelement: &AzSvgPathElement) -> AzSvgRect{ svgpathelement.get_bounds() }
/// Returns the length of the line or curve
#[no_mangle] pub extern "C" fn AzSvgPathElement_getLength (svgpathelement: &AzSvgPathElement) -> f64{ svgpathelement.get_length() }
/// Returns the interpolation value t (between 0 and 1) at the given offset from the line or curve start
#[no_mangle] pub extern "C" fn AzSvgPathElement_getTAtOffset (svgpathelement: &AzSvgPathElement, offset: f64) -> f64{ svgpathelement.get_t_at_offset(offset) }
/// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
#[no_mangle] pub extern "C" fn AzSvgPathElement_getXAtT (svgpathelement: &AzSvgPathElement, t: f64) -> f64{ svgpathelement.get_x_at_t(t) }
/// Returns the y position of the line or curve at t
#[no_mangle] pub extern "C" fn AzSvgPathElement_getYAtT (svgpathelement: &AzSvgPathElement, t: f64) -> f64{ svgpathelement.get_y_at_t(t) }
/// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between 0 and 1)
#[no_mangle] pub extern "C" fn AzSvgPathElement_getTangentVectorAtT (svgpathelement: &AzSvgPathElement, t: f64) -> AzSvgVector{ svgpathelement.get_tangent_vector_at_t(t) }
/// Equivalent to the Rust `SvgPathElement::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgPathElement_tessellateStroke (svgpathelement: &AzSvgPathElement, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_svgpathelement_stroke(svgpathelement, stroke_style) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgPoint>` struct
#[repr(C)] pub struct AzSvgPoint { pub ptr: *mut c_void }
/// Returns the euclidean distance to some other point
#[no_mangle] pub extern "C" fn AzSvgPoint_distance (svgpoint: &AzSvgPoint, other: AzSvgPoint) -> f64{ svgpoint.distance(other) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgVector>` struct
#[repr(C)] pub struct AzSvgVector { pub ptr: *mut c_void }
/// Returns the angle of this vector in degrees
#[no_mangle] pub extern "C" fn AzSvgVector_angleDegrees (svgvector: &AzSvgVector) -> f64{ svgvector.angle_degrees() }
/// Normalizes the vector, returning the normalized vector
#[no_mangle] pub extern "C" fn AzSvgVector_normalize (svgvector: &AzSvgVector) -> AzSvgVector{ svgvector.normalize() }
/// Rotates the vector 90 degrees counter clockwise, returning the rotated vector
#[no_mangle] pub extern "C" fn AzSvgVector_rotate90degCcw (svgvector: &AzSvgVector) -> AzSvgVector{ svgvector.rotate_90deg_ccw() }
/* Error: Type is not stack allocated! */

/// A line segment in 2D space.
#[repr(C)] pub struct AzSvgLine { pub ptr: *mut c_void }
/// Reverses the order of points in the path so that the path runs in the opposite direction afterwards
#[no_mangle] pub extern "C" fn AzSvgLine_reverse (svgline: &mut AzSvgLine){ svgline.reverse() }
/// Returns the starting point of this item
#[no_mangle] pub extern "C" fn AzSvgLine_getStart (svgline: &AzSvgLine) -> AzSvgPoint{ svgline.get_start() }
/// Returns the ending point of this item
#[no_mangle] pub extern "C" fn AzSvgLine_getEnd (svgline: &AzSvgLine) -> AzSvgPoint{ svgline.get_end() }
/// Returns the bounding box of this item
#[no_mangle] pub extern "C" fn AzSvgLine_getBounds (svgline: &AzSvgLine) -> AzSvgRect{ svgline.get_bounds() }
/// Returns the length of the line or curve
#[no_mangle] pub extern "C" fn AzSvgLine_getLength (svgline: &AzSvgLine) -> f64{ svgline.get_length() }
/// Returns the interpolation value t (between 0 and 1) at the given offset from the line or curve start
#[no_mangle] pub extern "C" fn AzSvgLine_getTAtOffset (svgline: &AzSvgLine, offset: f64) -> f64{ svgline.get_t_at_offset(offset) }
/// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
#[no_mangle] pub extern "C" fn AzSvgLine_getXAtT (svgline: &AzSvgLine, t: f64) -> f64{ svgline.get_x_at_t(t) }
/// Returns the y position of the line or curve at t
#[no_mangle] pub extern "C" fn AzSvgLine_getYAtT (svgline: &AzSvgLine, t: f64) -> f64{ svgline.get_y_at_t(t) }
/// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between 0 and 1)
#[no_mangle] pub extern "C" fn AzSvgLine_getTangentVectorAtT (svgline: &AzSvgLine, t: f64) -> AzSvgVector{ svgline.get_tangent_vector_at_t(t) }
/// Intersect two lines EVEN IF THEY ARE DISTINCT. Only returns None on parallel lines (never intersect)
#[no_mangle] pub extern "C" fn AzSvgLine_intersect (svgline: &AzSvgLine, other: AzSvgLine) -> AzOptionSvgPoint{ azul_layout::xml::svg::raw_line_intersection(svgline, &other).into() }
/// Equivalent to the Rust `SvgLine::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgLine_tessellateStroke (svgline: &AzSvgLine, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_line_stroke(svgline, stroke_style) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgQuadraticCurve>` struct
#[repr(C)] pub struct AzSvgQuadraticCurve { pub ptr: *mut c_void }
/// Reverses the order of points in the curve so that the curve runs in the opposite direction afterwards
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_reverse (svgquadraticcurve: &mut AzSvgQuadraticCurve){ svgquadraticcurve.reverse() }
/// Returns the starting point of this item
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_getStart (svgquadraticcurve: &AzSvgQuadraticCurve) -> AzSvgPoint{ svgquadraticcurve.get_start() }
/// Returns the ending point of this item
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_getEnd (svgquadraticcurve: &AzSvgQuadraticCurve) -> AzSvgPoint{ svgquadraticcurve.get_end() }
/// Returns the bounding box of this item
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_getBounds (svgquadraticcurve: &AzSvgQuadraticCurve) -> AzSvgRect{ svgquadraticcurve.get_bounds() }
/// Returns the length of the line or curve
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_getLength (svgquadraticcurve: &AzSvgQuadraticCurve) -> f64{ svgquadraticcurve.get_length() }
/// Returns the interpolation value t (between 0 and 1) at the given offset from the line or curve start
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_getTAtOffset (svgquadraticcurve: &AzSvgQuadraticCurve, offset: f64) -> f64{ svgquadraticcurve.get_t_at_offset(offset) }
/// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_getXAtT (svgquadraticcurve: &AzSvgQuadraticCurve, t: f64) -> f64{ svgquadraticcurve.get_x_at_t(t) }
/// Returns the y position of the line or curve at t
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_getYAtT (svgquadraticcurve: &AzSvgQuadraticCurve, t: f64) -> f64{ svgquadraticcurve.get_y_at_t(t) }
/// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between 0 and 1)
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_getTangentVectorAtT (svgquadraticcurve: &AzSvgQuadraticCurve, t: f64) -> AzSvgVector{ svgquadraticcurve.get_tangent_vector_at_t(t) }
/// Equivalent to the Rust `SvgQuadraticCurve::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_tessellateStroke (svgquadraticcurve: &AzSvgQuadraticCurve, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_quadraticcurve_stroke(svgquadraticcurve, stroke_style) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgCubicCurve>` struct
#[repr(C)] pub struct AzSvgCubicCurve { pub ptr: *mut c_void }
/// Reverses the order of points in the curve so that the curve runs in the opposite direction afterwards
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_reverse (svgcubiccurve: &mut AzSvgCubicCurve){ svgcubiccurve.reverse() }
/// Returns the starting point of this item
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_getStart (svgcubiccurve: &AzSvgCubicCurve) -> AzSvgPoint{ svgcubiccurve.get_start() }
/// Returns the ending point of this item
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_getEnd (svgcubiccurve: &AzSvgCubicCurve) -> AzSvgPoint{ svgcubiccurve.get_end() }
/// Returns the bounding box of this item
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_getBounds (svgcubiccurve: &AzSvgCubicCurve) -> AzSvgRect{ svgcubiccurve.get_bounds() }
/// Returns the length of the line or curve
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_getLength (svgcubiccurve: &AzSvgCubicCurve) -> f64{ svgcubiccurve.get_length() }
/// Returns the interpolation value t (between 0 and 1) at the given offset from the line or curve start
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_getTAtOffset (svgcubiccurve: &AzSvgCubicCurve, offset: f64) -> f64{ svgcubiccurve.get_t_at_offset(offset) }
/// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_getXAtT (svgcubiccurve: &AzSvgCubicCurve, t: f64) -> f64{ svgcubiccurve.get_x_at_t(t) }
/// Returns the y position of the line or curve at t
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_getYAtT (svgcubiccurve: &AzSvgCubicCurve, t: f64) -> f64{ svgcubiccurve.get_y_at_t(t) }
/// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between 0 and 1)
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_getTangentVectorAtT (svgcubiccurve: &AzSvgCubicCurve, t: f64) -> AzSvgVector{ svgcubiccurve.get_tangent_vector_at_t(t) }
/// Equivalent to the Rust `SvgCubicCurve::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_tessellateStroke (svgcubiccurve: &AzSvgCubicCurve, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_cubiccurve_stroke(svgcubiccurve, stroke_style) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgRect>` struct
#[repr(C)] pub struct AzSvgRect { pub ptr: *mut c_void }
/// Equivalent to the Rust `SvgRect::get_center()` function.
#[no_mangle] pub extern "C" fn AzSvgRect_getCenter (svgrect: &AzSvgRect) -> AzSvgPoint{ svgrect.get_center() }
/// Equivalent to the Rust `SvgRect::contains_point()` function.
#[no_mangle] pub extern "C" fn AzSvgRect_containsPoint (svgrect: &AzSvgRect, point: AzSvgPoint) -> bool{ svgrect.contains_point(point.x, point.y) }
/// Equivalent to the Rust `SvgRect::expand()` function.
#[no_mangle] pub extern "C" fn AzSvgRect_expand (svgrect: &AzSvgRect, padding_top: f32, padding_bottom: f32, padding_left: f32, padding_right: f32) -> AzSvgRect{ svgrect.expand(padding_top, padding_bottom, padding_left, padding_right) }
/// Equivalent to the Rust `SvgRect::tessellate_fill()` function.
#[no_mangle] pub extern "C" fn AzSvgRect_tessellateFill (svgrect: &AzSvgRect, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_rect_fill(svgrect, fill_style) }
/// Equivalent to the Rust `SvgRect::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgRect_tessellateStroke (svgrect: &AzSvgRect, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_rect_stroke(svgrect, stroke_style) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgColoredVertex>` struct
#[repr(C)] pub struct AzSvgColoredVertex { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TessellatedColoredSvgNode>` struct
#[repr(C)] pub struct AzTessellatedColoredSvgNode { pub ptr: *mut c_void }
/// Returns an empty buffer vertices / indices
#[no_mangle] pub extern "C" fn AzTessellatedColoredSvgNode_empty () -> AzTessellatedColoredSvgNode { let object: TessellatedColoredSvgNode = AzTessellatedColoredSvgNode::empty(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTessellatedColoredSvgNode { ptr } }
/// Creates a new TessellatedColoredSvgNode by joining all the given nodes together into one array and inserting a `GL_RESTART_INDEX` (`u32::MAX`) into the indices (so that the resulting buffer can be drawn in one draw call).
#[no_mangle] pub extern "C" fn AzTessellatedColoredSvgNode_fromNodes (nodes: AzTessellatedColoredSvgNodeVecRef) -> AzTessellatedColoredSvgNode { let object: TessellatedColoredSvgNode = azul_layout::xml::svg::join_tessellated_colored_nodes(nodes.as_slice()); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTessellatedColoredSvgNode { ptr } }
/* Error: Type is not stack allocated! */

/// Rust wrapper over a `&[TessellatedColoredSvgNode]` or `&Vec<TessellatedColoredSvgNode>`
#[repr(C)] pub struct AzTessellatedColoredSvgNodeVecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TessellatedColoredGPUSvgNode>` struct
#[repr(C)] pub struct AzTessellatedColoredGPUSvgNode { pub ptr: *mut c_void }
/// Creates a new `TessellatedColoredGPUSvgNode` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `TessellatedColoredGPUSvgNode::new()` constructor.
#[no_mangle] pub extern "C" fn AzTessellatedColoredGPUSvgNode_new (tessellated_node: *const AzTessellatedColoredSvgNode, gl: AzGlContextPtr) -> AzTessellatedColoredGPUSvgNode { let object: TessellatedColoredGPUSvgNode = AzTessellatedColoredGPUSvgNode::new(unsafe { &*tessellated_node }, gl); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTessellatedColoredGPUSvgNode { ptr } }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgVertex>` struct
#[repr(C)] pub struct AzSvgVertex { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TessellatedSvgNode>` struct
#[repr(C)] pub struct AzTessellatedSvgNode { pub ptr: *mut c_void }
/// Returns an empty buffer vertices / indices
#[no_mangle] pub extern "C" fn AzTessellatedSvgNode_empty () -> AzTessellatedSvgNode { let object: TessellatedSvgNode = AzTessellatedSvgNode::empty(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTessellatedSvgNode { ptr } }
/// Creates a new TessellatedSvgNode by joining all the given nodes together into one array and inserting a `GL_RESTART_INDEX` (`u32::MAX`) into the indices (so that the resulting buffer can be drawn in one draw call).
#[no_mangle] pub extern "C" fn AzTessellatedSvgNode_fromNodes (nodes: AzTessellatedSvgNodeVecRef) -> AzTessellatedSvgNode { let object: TessellatedSvgNode = azul_layout::xml::svg::join_tessellated_nodes(nodes.as_slice()); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTessellatedSvgNode { ptr } }
/* Error: Type is not stack allocated! */

/// Rust wrapper over a `&[TessellatedSvgNode]` or `&Vec<TessellatedSvgNode>`
#[repr(C)] pub struct AzTessellatedSvgNodeVecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TessellatedGPUSvgNode>` struct
#[repr(C)] pub struct AzTessellatedGPUSvgNode { pub ptr: *mut c_void }
/// Creates a new `TessellatedGPUSvgNode` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `TessellatedGPUSvgNode::new()` constructor.
#[no_mangle] pub extern "C" fn AzTessellatedGPUSvgNode_new (tessellated_node: *const AzTessellatedSvgNode, gl: AzGlContextPtr) -> AzTessellatedGPUSvgNode { let object: TessellatedGPUSvgNode = AzTessellatedGPUSvgNode::new(unsafe { &*tessellated_node }, gl); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTessellatedGPUSvgNode { ptr } }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgParseOptions>` struct
#[repr(C)] pub struct AzSvgParseOptions { pub ptr: *mut c_void }
/// Creates a new `SvgParseOptions` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `SvgParseOptions::default()` constructor.
#[no_mangle] pub extern "C" fn AzSvgParseOptions_default () -> AzSvgParseOptions { let object: SvgParseOptions = AzSvgParseOptions::default(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzSvgParseOptions { ptr } }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ShapeRendering>` struct
#[repr(C)] pub struct AzShapeRendering { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextRendering>` struct
#[repr(C)] pub struct AzTextRendering { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ImageRendering>` struct
#[repr(C)] pub struct AzImageRendering { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FontDatabase>` struct
#[repr(C)] pub struct AzFontDatabase { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgRenderOptions>` struct
#[repr(C)] pub struct AzSvgRenderOptions { pub ptr: *mut c_void }
/// Creates a new `SvgRenderOptions` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `SvgRenderOptions::default()` constructor.
#[no_mangle] pub extern "C" fn AzSvgRenderOptions_default () -> AzSvgRenderOptions { let object: SvgRenderOptions = AzSvgRenderOptions::default(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzSvgRenderOptions { ptr } }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgRenderTransform>` struct
#[repr(C)] pub struct AzSvgRenderTransform { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgDashPattern>` struct
#[repr(C)] pub struct AzSvgDashPattern { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Indent>` struct
#[repr(C)] pub struct AzIndent { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgFitTo>` struct
#[repr(C)] pub struct AzSvgFitTo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgStyle>` struct
#[repr(C)] pub struct AzSvgStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgFillRule>` struct
#[repr(C)] pub struct AzSvgFillRule { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgTransform>` struct
#[repr(C)] pub struct AzSvgTransform { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgFillStyle>` struct
#[repr(C)] pub struct AzSvgFillStyle { pub ptr: *mut c_void }
/// Creates a new `SvgFillStyle` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `SvgFillStyle::default()` constructor.
#[no_mangle] pub extern "C" fn AzSvgFillStyle_default () -> AzSvgFillStyle { let object: SvgFillStyle = AzSvgFillStyle::default(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzSvgFillStyle { ptr } }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgStrokeStyle>` struct
#[repr(C)] pub struct AzSvgStrokeStyle { pub ptr: *mut c_void }
/// Creates a new `SvgStrokeStyle` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `SvgStrokeStyle::default()` constructor.
#[no_mangle] pub extern "C" fn AzSvgStrokeStyle_default () -> AzSvgStrokeStyle { let object: SvgStrokeStyle = AzSvgStrokeStyle::default(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzSvgStrokeStyle { ptr } }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgLineJoin>` struct
#[repr(C)] pub struct AzSvgLineJoin { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgLineCap>` struct
#[repr(C)] pub struct AzSvgLineCap { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgXmlOptions>` struct
#[repr(C)] pub struct AzSvgXmlOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgParseError>` struct
#[repr(C)] pub struct AzSvgParseError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Xml>` struct
#[repr(C)] pub struct AzXml { pub ptr: *mut c_void }
/// Parses an XML document with one or more root nodes
#[no_mangle] pub extern "C" fn AzXml_fromStr (xml_string: AzRefstr) -> AzResultXmlXmlError { let object: Xml = azul_layout::xml::parse_xml(xml_string.as_str()).into(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzXml { ptr } }
/* Error: Type is not stack allocated! */

/// Represents one XML node tag
#[repr(C)] pub struct AzXmlNode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Tag of an XML node, such as the "button" in `<button>Hello</button>`.
pub type AzXmlTagName = AzAzString<>;

/// Attributes of an XML node, such as `["color" => "blue"]` in `<button color="blue" />`.
pub type AzXmlAttributeMap = AzStringPairVec<>;

/// (Unparsed) text content of an XML node, such as the "Hello" in `<button>Hello</button>`.
pub type AzXmlTextContent = AzOptionAzString<>;

/// **Reference-counted** file handle
pub use crate::azul_impl::file::File as AzFileTT;
pub use AzFileTT as AzFile;
/// Opens a file at the given path. If the file exists, replaces it with a new file
#[no_mangle] pub extern "C" fn AzFile_open (path: AzAzString) -> AzOptionFile { let object: File = AzFile::open(path.as_str()).into(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzFile { ptr } }
/// Creates a file at the given path. If the file exists, replaces it with a new file
#[no_mangle] pub extern "C" fn AzFile_create (path: AzAzString) -> AzOptionFile { let object: File = AzFile::create(path.as_str()).into(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzFile { ptr } }
/// Reads the file to a UTF8-encoded String, returns None if the file can't be decoded correctly
#[no_mangle] pub extern "C" fn AzFile_readToString (file: &mut AzFile) -> AzOptionAzString{ file.read_to_string().into() }
/// Reads the file as bytes, returns None if the file can't be decoded correctly
#[no_mangle] pub extern "C" fn AzFile_readToBytes (file: &mut AzFile) -> AzOptionU8Vec{ file.read_to_bytes().into() }
/// Writes a string to the file, synchronizes the results before returning
#[no_mangle] pub extern "C" fn AzFile_writeString (file: &mut AzFile, bytes: AzRefstr) -> bool{ file.write_string(bytes.as_str()).is_some() }
/// Writes some bytes to the file, synchronizes the results before returning
#[no_mangle] pub extern "C" fn AzFile_writeBytes (file: &mut AzFile, bytes: AzU8VecRef) -> bool{ file.write_bytes(bytes.as_slice()).is_some() }
/// Destructor, closes the file handle
#[no_mangle] pub extern "C" fn AzFile_close (file: &mut AzFile){ file.clone().close() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<MsgBox>` struct
#[repr(C)] pub struct AzMsgBox { pub ptr: *mut c_void }
/// Opens an informational message box with only an "OK" button
#[no_mangle] pub extern "C" fn AzMsgBox_ok (icon: AzMsgBoxIcon, title: AzAzString, message: AzAzString) -> bool { let object: MsgBox = crate::azul_impl::dialogs::msg_box_ok(title.as_str(), message.as_str(), icon.into()); true; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzMsgBox { ptr } }
/// Shorthand for `MsgBox::ok("Info", $message, Icon::Info)`
#[no_mangle] pub extern "C" fn AzMsgBox_info (message: AzAzString) -> bool { let object: MsgBox = crate::azul_impl::dialogs::msg_box_ok("Info", message.as_str(), AzMsgBoxIcon::Info.into()); true; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzMsgBox { ptr } }
/// Shorthand for `MsgBox::ok("Warning", $message, Icon::Warning)`
#[no_mangle] pub extern "C" fn AzMsgBox_warning (message: AzAzString) -> bool { let object: MsgBox = crate::azul_impl::dialogs::msg_box_ok("Warning", message.as_str(), AzMsgBoxIcon::Warning.into()); true; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzMsgBox { ptr } }
/// Shorthand for `MsgBox::ok("Error", $message, Icon::Error)`
#[no_mangle] pub extern "C" fn AzMsgBox_error (message: AzAzString) -> bool { let object: MsgBox = crate::azul_impl::dialogs::msg_box_ok("Error", message.as_str(), AzMsgBoxIcon::Error.into()); true; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzMsgBox { ptr } }
/// Shorthand for `MsgBox::ok("Question", $message, Icon::Question)`
#[no_mangle] pub extern "C" fn AzMsgBox_question (message: AzAzString) -> bool { let object: MsgBox = crate::azul_impl::dialogs::msg_box_ok("Question", message.as_str(), AzMsgBoxIcon::Question.into()); true; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzMsgBox { ptr } }
/// Opens a ok / cancel message box. Blocks the current thread.
#[no_mangle] pub extern "C" fn AzMsgBox_okCancel (icon: AzMsgBoxIcon, title: AzAzString, message: AzAzString, default_value: AzOkCancel) -> AzOkCancel { let object: MsgBox = crate::azul_impl::dialogs::msg_box_ok_cancel(title.as_str(), message.as_str(), icon.into(), default_value); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzMsgBox { ptr } }
/// Opens a yes / no message box. Blocks the current thread.
#[no_mangle] pub extern "C" fn AzMsgBox_yesNo (icon: AzMsgBoxIcon, title: AzAzString, message: AzAzString, default_value: AzYesNo) -> AzYesNo { let object: MsgBox = crate::azul_impl::dialogs::msg_box_yes_no(title.as_str(), message.as_str(), icon.into(), default_value); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzMsgBox { ptr } }
/* Error: Type is not stack allocated! */

/// Type of message box icon
#[repr(C)] pub struct AzMsgBoxIcon { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColorPickerDialog>` struct
#[repr(C)] pub struct AzColorPickerDialog { pub ptr: *mut c_void }
/// Opens a system-native color picker dialog
#[no_mangle] pub extern "C" fn AzColorPickerDialog_open (title: AzAzString, default_color: AzOptionColorU) -> AzOptionColorU { let object: ColorPickerDialog = crate::azul_impl::dialogs::color_picker_dialog(title.as_str(), default_color.into_option().map(|s| s.into())).into(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzColorPickerDialog { ptr } }
/* Error: Type is not stack allocated! */

/// Value returned from a yes / no message box
#[repr(C)] pub struct AzYesNo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// File picker dialog
#[repr(C)] pub struct AzFileDialog { pub ptr: *mut c_void }
/// Select a single file using the system-native file picker. Blocks the current thread.
#[no_mangle] pub extern "C" fn AzFileDialog_selectFile (title: AzAzString, default_path: AzOptionAzString, filter_list: AzOptionFileTypeList) -> AzOptionAzString { let object: FileDialog = crate::azul_impl::dialogs::open_file_dialog(title.as_str(), default_path.as_ref().map(|s| s.as_str()), filter_list.into_option().map(|s| s.into())).into(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzFileDialog { ptr } }
/// Select multiple files using the system-native file picker. Blocks the current thread.
#[no_mangle] pub extern "C" fn AzFileDialog_selectMultipleFiles (title: AzAzString, default_path: AzOptionAzString, filter_list: AzOptionFileTypeList) -> AzOptionStringVec { let object: FileDialog = crate::azul_impl::dialogs::open_multiple_files_dialog(title.as_str(), default_path.as_ref().map(|s| s.as_str()), filter_list.into_option().map(|s| s.into())).into(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzFileDialog { ptr } }
/// Open a dialog prompting the user to select a directory to open. Blocks the current thread.
#[no_mangle] pub extern "C" fn AzFileDialog_selectFolder (title: AzAzString, default_path: AzOptionAzString) -> AzOptionAzString { let object: FileDialog = crate::azul_impl::dialogs::open_directory_dialog(title.as_str(), default_path.as_ref().map(|s| s.as_str())).into(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzFileDialog { ptr } }
/// Open a dialog prompting the user to save a file. Blocks the current thread.
#[no_mangle] pub extern "C" fn AzFileDialog_saveFile (title: AzAzString, default_path: AzOptionAzString) -> AzOptionAzString { let object: FileDialog = crate::azul_impl::dialogs::save_file_dialog(title.as_str(), default_path.as_ref().map(|s| s.as_str())).into(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzFileDialog { ptr } }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FileTypeList>` struct
#[repr(C)] pub struct AzFileTypeList { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Value returned from an ok / cancel message box
#[repr(C)] pub struct AzOkCancel { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Instant>` struct
#[repr(C)] pub struct AzInstant { pub ptr: *mut c_void }
/// Returns the duration since and earlier instant or None if the earlier instant is later than self
#[no_mangle] pub extern "C" fn AzInstant_durationSince (instant: &AzInstant, earlier: AzInstant) -> AzOptionDuration{ if &earlier < instant { Some(instant.duration_since(&earlier)).into() } else { None.into() } }
/// Adds a duration to the current time instant, returning the new `Instant`
#[no_mangle] pub extern "C" fn AzInstant_addDuration (instant: &mut AzInstant, duration: AzDuration) -> AzInstant{ instant.add_optional_duration(Some(&duration)) }
/// Linearly interpolates between [start, end] if the `self` Instant lies between start and end. Returns values between 0.0 and 1.0
#[no_mangle] pub extern "C" fn AzInstant_linearInterpolate (instant: &AzInstant, start: AzInstant, end: AzInstant) -> f32{ instant.linear_interpolate(start, end) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SystemTickDiff>` struct
#[repr(C)] pub struct AzSystemTickDiff { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `InstantPtrCloneFnType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<AzInstantPtr>` struct
pub use azul_core::task::AzInstantPtr as AzAzInstantPtrTT;
pub use AzAzInstantPtrTT as AzAzInstantPtr;
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `InstantPtrDestructorFnType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<InstantPtrCloneCallback>` struct
#[repr(C)] pub struct AzInstantPtrCloneCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SystemTick>` struct
#[repr(C)] pub struct AzSystemTick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Duration>` struct
#[repr(C)] pub struct AzDuration { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SystemTimeDiff>` struct
#[repr(C)] pub struct AzSystemTimeDiff { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InstantPtrDestructorCallback>` struct
#[repr(C)] pub struct AzInstantPtrDestructorCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TimerId>` struct
#[repr(C)] pub struct AzTimerId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Timer>` struct
#[repr(C)] pub struct AzTimer { pub ptr: *mut c_void }
/// Creates a new `Timer` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Timer::new()` constructor.
#[no_mangle] pub extern "C" fn AzTimer_new (timer_data: AzRefAny, callback: AzTimerCallbackType, get_system_time_fn: AzGetSystemTimeCallback) -> AzTimer { let object: Timer = AzTimer::new(timer_data, callback, get_system_time_fn); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTimer { ptr } }
/// Equivalent to the Rust `Timer::with_delay()` function.
#[no_mangle] pub extern "C" fn AzTimer_withDelay (timer: &AzTimer, delay: AzDuration) -> AzTimer{ timer.clone().with_delay(delay) }
/// Equivalent to the Rust `Timer::with_interval()` function.
#[no_mangle] pub extern "C" fn AzTimer_withInterval (timer: &AzTimer, interval: AzDuration) -> AzTimer{ timer.clone().with_interval(interval) }
/// Equivalent to the Rust `Timer::with_timeout()` function.
#[no_mangle] pub extern "C" fn AzTimer_withTimeout (timer: &AzTimer, timeout: AzDuration) -> AzTimer{ timer.clone().with_timeout(timeout) }
/* Error: Type is not stack allocated! */

/// Should a timer terminate or not - used to remove active timers
#[repr(C)] pub struct AzTerminateTimer { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ThreadId>` struct
#[repr(C)] pub struct AzThreadId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Thread>` struct
pub use azul_core::task::Thread as AzThreadTT;
pub use AzThreadTT as AzThread;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ThreadSender>` struct
pub use azul_core::task::ThreadSender as AzThreadSenderTT;
pub use AzThreadSenderTT as AzThreadSender;
/// Equivalent to the Rust `ThreadSender::send()` function.
#[no_mangle] pub extern "C" fn AzThreadSender_send (threadsender: &mut AzThreadSender, msg: AzThreadReceiveMsg) -> bool{ threadsender.send(msg) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ThreadReceiver>` struct
pub use azul_core::task::ThreadReceiver as AzThreadReceiverTT;
pub use AzThreadReceiverTT as AzThreadReceiver;
/// Equivalent to the Rust `ThreadReceiver::receive()` function.
#[no_mangle] pub extern "C" fn AzThreadReceiver_receive (threadreceiver: &mut AzThreadReceiver) -> AzOptionThreadSendMsg{ threadreceiver.recv().into() }
/* Error: Type is not stack allocated! */

/// Message that can be sent from the main thread to the Thread using the ThreadId. The thread can ignore the event.
#[repr(C)] pub struct AzThreadSendMsg { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ThreadReceiveMsg>` struct
#[repr(C)] pub struct AzThreadReceiveMsg { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ThreadWriteBackMsg>` struct
#[repr(C)] pub struct AzThreadWriteBackMsg { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `CreateThreadFnType` struct
/* Error: 'external' key is required for this class */

/// Destructor of the `ThreadReceiver`
#[repr(C)] pub struct AzThreadReceiverDestructorCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `GetSystemTimeFnType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<CreateThreadCallback>` struct
#[repr(C)] pub struct AzCreateThreadCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Callback that checks whether the thread has finished - the input argument is the `dropcheck` field on the Thread.
/* Error: 'external' key is required for this class */

/// Get the current system time, equivalent to `std::time::Instant::now()`, except it also works on systems that work with "ticks" instead of timers
#[repr(C)] pub struct AzGetSystemTimeCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `LibrarySendThreadMsgFnType` struct
/* Error: 'external' key is required for this class */

/// Function called to check if the thread has finished
#[repr(C)] pub struct AzCheckThreadFinishedCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `LibraryReceiveThreadMsgFnType` struct
/* Error: 'external' key is required for this class */

/// Function to send a message to the thread
#[repr(C)] pub struct AzLibrarySendThreadMsgCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `ThreadRecvFnType` struct
/* Error: 'external' key is required for this class */

/// Function to receive a message from the thread
#[repr(C)] pub struct AzLibraryReceiveThreadMsgCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `ThreadSendFnType` struct
/* Error: 'external' key is required for this class */

/// Function that the running `Thread` can call to receive messages from the main UI thread
#[repr(C)] pub struct AzThreadRecvCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `ThreadDestructorFnType` struct
/* Error: 'external' key is required for this class */

/// Function that the running `Thread` can call to receive messages from the main UI thread
#[repr(C)] pub struct AzThreadSendCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `ThreadReceiverDestructorFnType` struct
/* Error: 'external' key is required for this class */

/// Destructor of the `Thread`
#[repr(C)] pub struct AzThreadDestructorCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `ThreadSenderDestructorFnType` struct
/* Error: 'external' key is required for this class */

/// Destructor of the `ThreadSender`
#[repr(C)] pub struct AzThreadSenderDestructorCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (*const c_void) -> bool
pub type AzCheckThreadFinishedCallbackType = Azextern "C" fn (*const c_void) -> bool<>;

/// Type alias for extern "C" fn (*mut AzInstantPtr)
pub type AzInstantPtrDestructorCallbackType = Azextern "C" fn (*mut AzInstantPtr)<>;

/// Type alias for extern "C" fn (*mut ThreadReceiverInner)
pub type AzThreadReceiverDestructorCallbackType = Azextern "C" fn (*mut ThreadReceiverInner)<>;

/// Type alias for extern "C" fn (*const c_void) -> OptionThreadSendMsg
pub type AzThreadRecvCallbackType = Azextern "C" fn (*const c_void) -> OptionThreadSendMsg<>;

/// Get the current system type, equivalent to `std::time::Instant::now()`, except it also works on systems that don't have a clock (such as embedded timers)
pub type AzGetSystemTimeCallbackType = Azextern "C" fn () -> Instant<>;

/// Type alias for extern "C" fn (*const AzInstantPtr) -> AzInstantPtr
pub type AzInstantPtrCloneCallbackType = Azextern "C" fn (*const AzInstantPtr) -> AzInstantPtr<>;

/// Type alias for extern "C" fn (*const c_void , ThreadSendMsg) -> bool
pub type AzLibrarySendThreadMsgCallbackType = Azextern "C" fn (*const c_void , ThreadSendMsg) -> bool<>;

/// Pointer to rust-allocated `Box<FmtValue>` struct
#[repr(C)] pub struct AzFmtValue { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FmtArg>` struct
#[repr(C)] pub struct AzFmtArg { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AzString>` struct
#[repr(C)] pub struct AzAzString { pub ptr: *mut c_void }
/// Creates a dynamically formatted String from a fomat string + named arguments
#[no_mangle] pub extern "C" fn AzAzString_format (format: AzAzString, args: AzFmtArgVec) -> AzAzString { let object: AzString = crate::str::fmt_string(format, args).into(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzAzString { ptr } }
/// Creates a new String from an arbitary pointer, a start offset (bytes from the start pointer, usually 0) and a length (in bytes). The bytes are expected to point to a UTF-8 encoded string, no error checking is performed.
#[no_mangle] pub extern "C" fn AzAzString_copyFromBytes (ptr: *const u8, start: usize, len: usize) -> AzAzString { let object: AzString = unsafe { let start_ptr = ptr.offset(start.max(core::isize::MAX as usize) as isize); let s = core::str::from_utf8_unchecked(core::slice::from_raw_parts(start_ptr, len)); s.to_string().into() }; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzAzString { ptr } }
/// Trims whitespace from the start / end of the string
#[no_mangle] pub extern "C" fn AzAzString_trim (azstring: &AzAzString) -> AzAzString{ string.as_str().trim().to_string().into() }
/// Returns a reference to the string - NOTE: the returned value is a reference to `self`, you MUST NOT drop the `String` object that the `Refstr` references
#[no_mangle] pub extern "C" fn AzAzString_asRefstr (azstring: &AzAzString) -> AzRefstr{ string.as_str().into() }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<ListViewRow>`
#[repr(C)] pub struct AzListViewRowVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<StyleFilter>`
#[repr(C)] pub struct AzStyleFilterVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<LogicalRect>`
#[repr(C)] pub struct AzLogicalRectVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<NodeTypeIdInfoMap>`
#[repr(C)] pub struct AzNodeTypeIdInfoMapVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<InputOutputTypeIdInfoMap>`
#[repr(C)] pub struct AzInputOutputTypeIdInfoMapVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<NodeIdNodeMap>`
#[repr(C)] pub struct AzNodeIdNodeMapVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<InputOutputTypeId>`
#[repr(C)] pub struct AzInputOutputTypeIdVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<NodeTypeField>`
#[repr(C)] pub struct AzNodeTypeFieldVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<InputConnection>`
#[repr(C)] pub struct AzInputConnectionVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<OutputNodeAndIndex>`
#[repr(C)] pub struct AzOutputNodeAndIndexVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<OutputConnection>`
#[repr(C)] pub struct AzOutputConnectionVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<InputNodeAndIndex>`
#[repr(C)] pub struct AzInputNodeAndIndexVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<AccessibilityState>`
#[repr(C)] pub struct AzAccessibilityStateVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<MenuItem>`
#[repr(C)] pub struct AzMenuItemVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<TessellatedSvgNode>`
#[repr(C)] pub struct AzTessellatedSvgNodeVec { pub ptr: *mut c_void }
/// Returns the `TessellatedSvgNodeVec` as a non-owning slice, NOTE: The `U8Vec` that this slice was borrowed from MUST NOT be deleted before the `U8VecRef`
#[no_mangle] pub extern "C" fn AzTessellatedSvgNodeVec_asRefVec (tessellatedsvgnodevec: &AzTessellatedSvgNodeVec) -> AzTessellatedSvgNodeVecRef{ tessellatedsvgnodevec.get_ref() }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<TessellatedColoredSvgNode>`
#[repr(C)] pub struct AzTessellatedColoredSvgNodeVec { pub ptr: *mut c_void }
/// Returns the `TessellatedColoredSvgNodeVec` as a non-owning slice, NOTE: The `TessellatedColoredSvgNodeVec` that this slice was borrowed from MUST NOT be deleted before the `U8VecRef`
#[no_mangle] pub extern "C" fn AzTessellatedColoredSvgNodeVec_asRefVec (tessellatedcoloredsvgnodevec: &AzTessellatedColoredSvgNodeVec) -> AzTessellatedColoredSvgNodeVecRef{ tessellatedcoloredsvgnodevec.get_ref() }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<StyleFontFamily>`
#[repr(C)] pub struct AzStyleFontFamilyVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<XmlNode>`
#[repr(C)] pub struct AzXmlNodeVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<FmtArg>`
#[repr(C)] pub struct AzFmtArgVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<InlineLine>`
#[repr(C)] pub struct AzInlineLineVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<InlineWord>`
#[repr(C)] pub struct AzInlineWordVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<InlineGlyph>`
#[repr(C)] pub struct AzInlineGlyphVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<InlineTextHit>`
#[repr(C)] pub struct AzInlineTextHitVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<Monitor>`
#[repr(C)] pub struct AzMonitorVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<VideoMode>`
#[repr(C)] pub struct AzVideoModeVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<Dom>`
#[repr(C)] pub struct AzDomVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<IdOrClass>`
#[repr(C)] pub struct AzIdOrClassVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<NodeDataInlineCssProperty>`
#[repr(C)] pub struct AzNodeDataInlineCssPropertyVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundContent>`
#[repr(C)] pub struct AzStyleBackgroundContentVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundPosition>`
#[repr(C)] pub struct AzStyleBackgroundPositionVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundRepeat>`
#[repr(C)] pub struct AzStyleBackgroundRepeatVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundSize>`
#[repr(C)] pub struct AzStyleBackgroundSizeVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<StyleTransform>`
#[repr(C)] pub struct AzStyleTransformVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<CssProperty>`
#[repr(C)] pub struct AzCssPropertyVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<SvgMultiPolygon>`
#[repr(C)] pub struct AzSvgMultiPolygonVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<SvgSimpleNode>`
#[repr(C)] pub struct AzSvgSimpleNodeVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<SvgPath>`
#[repr(C)] pub struct AzSvgPathVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<VertexAttribute>`
#[repr(C)] pub struct AzVertexAttributeVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `VertexAttribute`
#[repr(C)] pub struct AzSvgPathElementVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `SvgVertex`
#[repr(C)] pub struct AzSvgVertexVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `SvgColoredVertex`
#[repr(C)] pub struct AzSvgColoredVertexVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<u32>`
#[repr(C)] pub struct AzU32Vec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `XWindowType`
#[repr(C)] pub struct AzXWindowTypeVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `VirtualKeyCode`
#[repr(C)] pub struct AzVirtualKeyCodeVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `CascadeInfo`
#[repr(C)] pub struct AzCascadeInfoVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `ScanCode`
#[repr(C)] pub struct AzScanCodeVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `CssDeclaration`
#[repr(C)] pub struct AzCssDeclarationVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `CssPathSelector`
#[repr(C)] pub struct AzCssPathSelectorVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Stylesheet`
#[repr(C)] pub struct AzStylesheetVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `CssRuleBlock`
#[repr(C)] pub struct AzCssRuleBlockVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<u16>`
#[repr(C)] pub struct AzU16Vec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<f32>`
#[repr(C)] pub struct AzF32Vec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `U8Vec`
#[repr(C)] pub struct AzU8Vec { pub ptr: *mut c_void }
/// Creates a new, heap-allocated U8Vec by copying the memory into Rust (heap allocation)
#[no_mangle] pub extern "C" fn AzU8Vec_copyFromBytes (ptr: *const u8, start: usize, len: usize) -> AzU8Vec { let object: U8Vec =  unsafe { let start_ptr = ptr.offset(start.max(core::isize::MAX as usize) as isize); let s = core::slice::from_raw_parts(start_ptr, len); s.to_vec().into() }; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzU8Vec { ptr } }
/// Returns the `U8Vec` as a non-owning slice, NOTE: The `U8Vec` that this slice was borrowed from MUST NOT be deleted before the `U8VecRef`
#[no_mangle] pub extern "C" fn AzU8Vec_asRefVec (u8vec: &AzU8Vec) -> AzU8VecRef{ u8vec.as_ref().into() }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `CallbackData`
#[repr(C)] pub struct AzCallbackDataVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NodeDataVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Wrapper over a Rust-allocated `U32Vec`
#[repr(C)] pub struct AzGLuintVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `GLintVec`
#[repr(C)] pub struct AzGLintVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `StringVec`
#[repr(C)] pub struct AzStringVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `StringPairVec`
#[repr(C)] pub struct AzStringPairVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `NormalizedLinearColorStopVec`
#[repr(C)] pub struct AzNormalizedLinearColorStopVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `NormalizedRadialColorStopVec`
#[repr(C)] pub struct AzNormalizedRadialColorStopVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `NodeIdVec`
#[repr(C)] pub struct AzNodeIdVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<NodeHierarchyItem>`
#[repr(C)] pub struct AzNodeHierarchyItemVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `StyledNodeVec`
#[repr(C)] pub struct AzStyledNodeVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `TagIdToNodeIdMappingVec`
#[repr(C)] pub struct AzTagIdToNodeIdMappingVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `ParentWithNodeDepthVec`
#[repr(C)] pub struct AzParentWithNodeDepthVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `NodeDataVec`
#[repr(C)] pub struct AzNodeDataVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleFontFamilyVecDestructor>` struct
#[repr(C)] pub struct AzStyleFontFamilyVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `StyleFontFamilyVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<ListViewRowVecDestructor>` struct
#[repr(C)] pub struct AzListViewRowVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `ListViewRowVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<StyleFilterVecDestructor>` struct
#[repr(C)] pub struct AzStyleFilterVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `StyleFilterVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<LogicalRectVecDestructor>` struct
#[repr(C)] pub struct AzLogicalRectVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `LogicalRectVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<NodeTypeIdInfoMapVecDestructor>` struct
#[repr(C)] pub struct AzNodeTypeIdInfoMapVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NodeTypeIdInfoMapVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<InputOutputTypeIdInfoMapVecDestructor>` struct
#[repr(C)] pub struct AzInputOutputTypeIdInfoMapVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `InputOutputTypeIdInfoMapVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<NodeIdNodeMapVecDestructor>` struct
#[repr(C)] pub struct AzNodeIdNodeMapVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NodeIdNodeMapVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<InputOutputTypeIdVecDestructor>` struct
#[repr(C)] pub struct AzInputOutputTypeIdVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `InputOutputTypeIdVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<NodeTypeFieldVecDestructor>` struct
#[repr(C)] pub struct AzNodeTypeFieldVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NodeTypeFieldVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<InputConnectionVecDestructor>` struct
#[repr(C)] pub struct AzInputConnectionVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `InputConnectionVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<OutputNodeAndIndexVecDestructor>` struct
#[repr(C)] pub struct AzOutputNodeAndIndexVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `OutputNodeAndIndexVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<OutputConnectionVecDestructor>` struct
#[repr(C)] pub struct AzOutputConnectionVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `OutputConnectionVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<InputNodeAndIndexVecDestructor>` struct
#[repr(C)] pub struct AzInputNodeAndIndexVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `InputNodeAndIndexVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<AccessibilityStateVecDestructor>` struct
#[repr(C)] pub struct AzAccessibilityStateVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `AccessibilityStateVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<MenuItemVecDestructor>` struct
#[repr(C)] pub struct AzMenuItemVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `MenuItemVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<TessellatedSvgNodeVecDestructor>` struct
#[repr(C)] pub struct AzTessellatedSvgNodeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `TessellatedSvgNodeVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<TessellatedColoredSvgNodeVecDestructor>` struct
#[repr(C)] pub struct AzTessellatedColoredSvgNodeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `TessellatedColoredSvgNodeVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<XmlNodeVecDestructor>` struct
#[repr(C)] pub struct AzXmlNodeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `XmlNodeVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<FmtArgVecDestructor>` struct
#[repr(C)] pub struct AzFmtArgVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `FmtArgVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<InlineLineVecDestructor>` struct
#[repr(C)] pub struct AzInlineLineVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `InlineLineVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<InlineWordVecDestructor>` struct
#[repr(C)] pub struct AzInlineWordVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `InlineWordVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<InlineGlyphVecDestructor>` struct
#[repr(C)] pub struct AzInlineGlyphVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `InlineGlyphVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<InlineTextHitVecDestructor>` struct
#[repr(C)] pub struct AzInlineTextHitVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `InlineTextHitVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<MonitorVecDestructor>` struct
#[repr(C)] pub struct AzMonitorVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `MonitorVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<VideoModeVecDestructor>` struct
#[repr(C)] pub struct AzVideoModeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `VideoModeVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<DomVecDestructor>` struct
#[repr(C)] pub struct AzDomVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `DomVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<IdOrClassVecDestructor>` struct
#[repr(C)] pub struct AzIdOrClassVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `IdOrClassVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<NodeDataInlineCssPropertyVecDestructor>` struct
#[repr(C)] pub struct AzNodeDataInlineCssPropertyVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NodeDataInlineCssPropertyVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<StyleBackgroundContentVecDestructor>` struct
#[repr(C)] pub struct AzStyleBackgroundContentVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `StyleBackgroundContentVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<StyleBackgroundPositionVecDestructor>` struct
#[repr(C)] pub struct AzStyleBackgroundPositionVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `StyleBackgroundPositionVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<StyleBackgroundRepeatVecDestructor>` struct
#[repr(C)] pub struct AzStyleBackgroundRepeatVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `StyleBackgroundRepeatVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<StyleBackgroundSizeVecDestructor>` struct
#[repr(C)] pub struct AzStyleBackgroundSizeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `StyleBackgroundSizeVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<StyleTransformVecDestructor>` struct
#[repr(C)] pub struct AzStyleTransformVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `StyleTransformVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<CssPropertyVecDestructor>` struct
#[repr(C)] pub struct AzCssPropertyVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `CssPropertyVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<SvgMultiPolygonVecDestructor>` struct
#[repr(C)] pub struct AzSvgMultiPolygonVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `SvgMultiPolygonVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<SvgSimpleNodeVecDestructor>` struct
#[repr(C)] pub struct AzSvgSimpleNodeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `SvgSimpleNodeVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<SvgPathVecDestructor>` struct
#[repr(C)] pub struct AzSvgPathVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `SvgPathVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<VertexAttributeVecDestructor>` struct
#[repr(C)] pub struct AzVertexAttributeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `VertexAttributeVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<SvgPathElementVecDestructor>` struct
#[repr(C)] pub struct AzSvgPathElementVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `SvgPathElementVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<SvgVertexVecDestructor>` struct
#[repr(C)] pub struct AzSvgVertexVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `SvgVertexVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<SvgColoredVertexVecDestructor>` struct
#[repr(C)] pub struct AzSvgColoredVertexVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `SvgColoredVertexVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<U32VecDestructor>` struct
#[repr(C)] pub struct AzU32VecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `U32VecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<XWindowTypeVecDestructor>` struct
#[repr(C)] pub struct AzXWindowTypeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `XWindowTypeVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<VirtualKeyCodeVecDestructor>` struct
#[repr(C)] pub struct AzVirtualKeyCodeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `VirtualKeyCodeVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<CascadeInfoVecDestructor>` struct
#[repr(C)] pub struct AzCascadeInfoVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `CascadeInfoVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<ScanCodeVecDestructor>` struct
#[repr(C)] pub struct AzScanCodeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `ScanCodeVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<CssDeclarationVecDestructor>` struct
#[repr(C)] pub struct AzCssDeclarationVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `CssDeclarationVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<CssPathSelectorVecDestructor>` struct
#[repr(C)] pub struct AzCssPathSelectorVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `CssPathSelectorVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<StylesheetVecDestructor>` struct
#[repr(C)] pub struct AzStylesheetVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `StylesheetVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<CssRuleBlockVecDestructor>` struct
#[repr(C)] pub struct AzCssRuleBlockVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `CssRuleBlockVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<F32VecDestructor>` struct
#[repr(C)] pub struct AzF32VecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `F32VecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<U16VecDestructor>` struct
#[repr(C)] pub struct AzU16VecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `U16VecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<U8VecDestructor>` struct
#[repr(C)] pub struct AzU8VecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `U8VecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<CallbackDataVecDestructor>` struct
#[repr(C)] pub struct AzCallbackDataVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `CallbackDataVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Wrapper over a Rust-allocated `Vec<DebugMessage>`
#[repr(C)] pub struct AzAzDebugMessageVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `DebugMessageVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<GLuintVecDestructor>` struct
#[repr(C)] pub struct AzGLuintVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `GLuintVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<GLintVecDestructor>` struct
#[repr(C)] pub struct AzGLintVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `GLintVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<StringVecDestructor>` struct
#[repr(C)] pub struct AzStringVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `StringVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<StringPairVecDestructor>` struct
#[repr(C)] pub struct AzStringPairVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `StringPairVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<NormalizedLinearColorStopVecDestructor>` struct
#[repr(C)] pub struct AzNormalizedLinearColorStopVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NormalizedLinearColorStopVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<NormalizedRadialColorStopVecDestructor>` struct
#[repr(C)] pub struct AzNormalizedRadialColorStopVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NormalizedRadialColorStopVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<NodeIdVecDestructor>` struct
#[repr(C)] pub struct AzNodeIdVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NodeIdVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<NodeHierarchyItemVecDestructor>` struct
#[repr(C)] pub struct AzNodeHierarchyItemVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `NodeHierarchyItemVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<StyledNodeVecDestructor>` struct
#[repr(C)] pub struct AzStyledNodeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `StyledNodeVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<TagIdToNodeIdMappingVecDestructor>` struct
#[repr(C)] pub struct AzTagIdToNodeIdMappingVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `TagIdToNodeIdMappingVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<ParentWithNodeDepthVecDestructor>` struct
#[repr(C)] pub struct AzParentWithNodeDepthVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `ParentWithNodeDepthVecDestructorType` struct
/* Error: 'external' key is required for this class */

/// Pointer to rust-allocated `Box<NodeDataVecDestructor>` struct
#[repr(C)] pub struct AzNodeDataVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AzDebugMessageVecDestructor>` struct
#[repr(C)] pub struct AzAzDebugMessageVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionSvgPoint>` struct
#[repr(C)] pub struct AzOptionSvgPoint { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionStyleTextAlign>` struct
#[repr(C)] pub struct AzOptionStyleTextAlign { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionListViewOnRowClick>` struct
#[repr(C)] pub struct AzOptionListViewOnRowClick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionListViewOnColumnClick>` struct
#[repr(C)] pub struct AzOptionListViewOnColumnClick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionListViewOnLazyLoadScroll>` struct
#[repr(C)] pub struct AzOptionListViewOnLazyLoadScroll { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionMenu>` struct
#[repr(C)] pub struct AzOptionMenu { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionPixelValueNoPercent>` struct
#[repr(C)] pub struct AzOptionPixelValueNoPercent { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionDropDownOnChoiceChange>` struct
#[repr(C)] pub struct AzOptionDropDownOnChoiceChange { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionResolvedTextLayoutOptions>` struct
#[repr(C)] pub struct AzOptionResolvedTextLayoutOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionU8VecRef>` struct
#[repr(C)] pub struct AzOptionU8VecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionOnNodeAdded>` struct
#[repr(C)] pub struct AzOptionOnNodeAdded { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionOnNodeRemoved>` struct
#[repr(C)] pub struct AzOptionOnNodeRemoved { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionOnNodeGraphDragged>` struct
#[repr(C)] pub struct AzOptionOnNodeGraphDragged { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionOnNodeDragged>` struct
#[repr(C)] pub struct AzOptionOnNodeDragged { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionOnNodeConnected>` struct
#[repr(C)] pub struct AzOptionOnNodeConnected { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionOnNodeInputDisconnected>` struct
#[repr(C)] pub struct AzOptionOnNodeInputDisconnected { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionOnNodeOutputDisconnected>` struct
#[repr(C)] pub struct AzOptionOnNodeOutputDisconnected { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionColorInputOnValueChange>` struct
#[repr(C)] pub struct AzOptionColorInputOnValueChange { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionButtonOnClick>` struct
#[repr(C)] pub struct AzOptionButtonOnClick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTabOnClick>` struct
#[repr(C)] pub struct AzOptionTabOnClick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionFileInputOnPathChange>` struct
#[repr(C)] pub struct AzOptionFileInputOnPathChange { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionCheckBoxOnToggle>` struct
#[repr(C)] pub struct AzOptionCheckBoxOnToggle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTextInputOnTextInput>` struct
#[repr(C)] pub struct AzOptionTextInputOnTextInput { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTextInputOnVirtualKeyDown>` struct
#[repr(C)] pub struct AzOptionTextInputOnVirtualKeyDown { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTextInputOnFocusLost>` struct
#[repr(C)] pub struct AzOptionTextInputOnFocusLost { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTextInputSelection>` struct
#[repr(C)] pub struct AzOptionTextInputSelection { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionNumberInputOnFocusLost>` struct
#[repr(C)] pub struct AzOptionNumberInputOnFocusLost { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionNumberInputOnValueChange>` struct
#[repr(C)] pub struct AzOptionNumberInputOnValueChange { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionMenuItemIcon>` struct
#[repr(C)] pub struct AzOptionMenuItemIcon { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Optional MenuCallback
#[repr(C)] pub struct AzOptionMenuCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionVirtualKeyCodeCombo>` struct
#[repr(C)] pub struct AzOptionVirtualKeyCodeCombo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionCssProperty>` struct
#[repr(C)] pub struct AzOptionCssProperty { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionPositionInfo>` struct
#[repr(C)] pub struct AzOptionPositionInfo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTimerId>` struct
#[repr(C)] pub struct AzOptionTimerId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionThreadId>` struct
#[repr(C)] pub struct AzOptionThreadId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionI16>` struct
#[repr(C)] pub struct AzOptionI16 { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionU16>` struct
#[repr(C)] pub struct AzOptionU16 { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionU32>` struct
#[repr(C)] pub struct AzOptionU32 { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionImageRef>` struct
#[repr(C)] pub struct AzOptionImageRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionFontRef>` struct
#[repr(C)] pub struct AzOptionFontRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionOnNodeFieldEdited>` struct
#[repr(C)] pub struct AzOptionOnNodeFieldEdited { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionFileTypeList>` struct
#[repr(C)] pub struct AzOptionFileTypeList { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionWindowState>` struct
#[repr(C)] pub struct AzOptionWindowState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionMouseState>` struct
#[repr(C)] pub struct AzOptionMouseState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionKeyboardState>` struct
#[repr(C)] pub struct AzOptionKeyboardState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionStringVec>` struct
#[repr(C)] pub struct AzOptionStringVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionFile>` struct
#[repr(C)] pub struct AzOptionFile { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionClipboard>` struct
#[repr(C)] pub struct AzOptionClipboard { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionThreadReceiveMsg>` struct
#[repr(C)] pub struct AzOptionThreadReceiveMsg { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionPercentageValue>` struct
#[repr(C)] pub struct AzOptionPercentageValue { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionAngleValue>` struct
#[repr(C)] pub struct AzOptionAngleValue { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionRendererOptions>` struct
#[repr(C)] pub struct AzOptionRendererOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Optional Callback
#[repr(C)] pub struct AzOptionCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionThreadSendMsg>` struct
#[repr(C)] pub struct AzOptionThreadSendMsg { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionLayoutRect>` struct
#[repr(C)] pub struct AzOptionLayoutRect { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionRefAny>` struct
#[repr(C)] pub struct AzOptionRefAny { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionInlineText>` struct
#[repr(C)] pub struct AzOptionInlineText { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionLayoutPoint>` struct
#[repr(C)] pub struct AzOptionLayoutPoint { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionLayoutSize>` struct
#[repr(C)] pub struct AzOptionLayoutSize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionWindowTheme>` struct
#[repr(C)] pub struct AzOptionWindowTheme { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionNodeId>` struct
#[repr(C)] pub struct AzOptionNodeId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionDomNodeId>` struct
#[repr(C)] pub struct AzOptionDomNodeId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionColorU>` struct
#[repr(C)] pub struct AzOptionColorU { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionRawImage>` struct
#[repr(C)] pub struct AzOptionRawImage { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionSvgDashPattern>` struct
#[repr(C)] pub struct AzOptionSvgDashPattern { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionWaylandTheme>` struct
#[repr(C)] pub struct AzOptionWaylandTheme { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTaskBarIcon>` struct
#[repr(C)] pub struct AzOptionTaskBarIcon { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionHwndHandle>` struct
#[repr(C)] pub struct AzOptionHwndHandle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionLogicalPosition>` struct
#[repr(C)] pub struct AzOptionLogicalPosition { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionPhysicalPositionI32>` struct
#[repr(C)] pub struct AzOptionPhysicalPositionI32 { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionWindowIcon>` struct
#[repr(C)] pub struct AzOptionWindowIcon { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionGlContextPtr>` struct
#[repr(C)] pub struct AzOptionGlContextPtr { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionX11Visual>` struct
#[repr(C)] pub struct AzOptionX11Visual { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionI32>` struct
#[repr(C)] pub struct AzOptionI32 { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionF32>` struct
#[repr(C)] pub struct AzOptionF32 { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionMouseCursorType>` struct
#[repr(C)] pub struct AzOptionMouseCursorType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionLogicalSize>` struct
#[repr(C)] pub struct AzOptionLogicalSize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Option<char> but the char is a u32, for C FFI stability reasons
#[repr(C)] pub struct AzOptionChar { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionVirtualKeyCode>` struct
#[repr(C)] pub struct AzOptionVirtualKeyCode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionDom>` struct
#[repr(C)] pub struct AzOptionDom { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTexture>` struct
#[repr(C)] pub struct AzOptionTexture { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionImageMask>` struct
#[repr(C)] pub struct AzOptionImageMask { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTabIndex>` struct
#[repr(C)] pub struct AzOptionTabIndex { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTagId>` struct
#[repr(C)] pub struct AzOptionTagId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionDuration>` struct
#[repr(C)] pub struct AzOptionDuration { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionInstant>` struct
#[repr(C)] pub struct AzOptionInstant { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionUsize>` struct
#[repr(C)] pub struct AzOptionUsize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionU8Vec>` struct
#[repr(C)] pub struct AzOptionU8Vec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionAzString>` struct
#[repr(C)] pub struct AzOptionAzString { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ResultXmlXmlError>` struct
#[repr(C)] pub struct AzResultXmlXmlError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ResultRawImageDecodeImageError>` struct
#[repr(C)] pub struct AzResultRawImageDecodeImageError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ResultU8VecEncodeImageError>` struct
#[repr(C)] pub struct AzResultU8VecEncodeImageError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ResultSvgXmlNodeSvgParseError>` struct
#[repr(C)] pub struct AzResultSvgXmlNodeSvgParseError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ResultSvgSvgParseError>` struct
#[repr(C)] pub struct AzResultSvgSvgParseError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgParseError>` struct
#[repr(C)] pub struct AzSvgParseError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<XmlError>` struct
#[repr(C)] pub struct AzXmlError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DuplicatedNamespaceError>` struct
#[repr(C)] pub struct AzDuplicatedNamespaceError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<UnknownNamespaceError>` struct
#[repr(C)] pub struct AzUnknownNamespaceError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<UnexpectedCloseTagError>` struct
#[repr(C)] pub struct AzUnexpectedCloseTagError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<UnknownEntityReferenceError>` struct
#[repr(C)] pub struct AzUnknownEntityReferenceError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DuplicatedAttributeError>` struct
#[repr(C)] pub struct AzDuplicatedAttributeError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<XmlParseError>` struct
#[repr(C)] pub struct AzXmlParseError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<XmlTextError>` struct
#[repr(C)] pub struct AzXmlTextError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<XmlStreamError>` struct
#[repr(C)] pub struct AzXmlStreamError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NonXmlCharError>` struct
#[repr(C)] pub struct AzNonXmlCharError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InvalidCharError>` struct
#[repr(C)] pub struct AzInvalidCharError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InvalidCharMultipleError>` struct
#[repr(C)] pub struct AzInvalidCharMultipleError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InvalidQuoteError>` struct
#[repr(C)] pub struct AzInvalidQuoteError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InvalidSpaceError>` struct
#[repr(C)] pub struct AzInvalidSpaceError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InvalidStringError>` struct
#[repr(C)] pub struct AzInvalidStringError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<XmlTextPos>` struct
#[repr(C)] pub struct AzXmlTextPos { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Stores the resources for the application, souch as fonts, images and cached texts, also clipboard strings Images and fonts can be references across window contexts (not yet tested, but should work).
#[repr(C)] pub struct AzImageCache { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FontCache>` struct
#[repr(C)] pub struct AzFontCache { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RawImageFormat>` struct
#[repr(C)] pub struct AzRawImageFormat { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AppLogLevel>` struct
#[repr(C)] pub struct AzAppLogLevel { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RawImageData>` struct
#[repr(C)] pub struct AzRawImageData { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LoadedFontSource>` struct
#[repr(C)] pub struct AzLoadedFontSource { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Configuration for optional features, such as whether to enable logging or panic hooks
#[repr(C)] pub struct AzAppConfig { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ImageMask>` struct
#[repr(C)] pub struct AzImageMask { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ImageRef>` struct
#[repr(C)] pub struct AzImageRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RawImage>` struct
#[repr(C)] pub struct AzRawImage { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DpiScaleFactor>` struct
#[repr(C)] pub struct AzDpiScaleFactor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Determines what happens when all application windows are closed
#[repr(C)] pub struct AzAppTerminationBehavior { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */


#[cfg(all(test, not(feature = "rlib")))]
#[allow(dead_code)]
mod test_sizes {

    #[cfg(not(feature = "link-static"))]
    impl AzString {
        #[inline]
        pub fn as_str(&self) -> &str {
            unsafe { core::str::from_utf8_unchecked(self.as_bytes()) }
        }
        #[inline]
        pub fn as_bytes(&self) -> &[u8] {
            unsafe { core::slice::from_raw_parts(self.vec.ptr, self.vec.len) }
        }
    }

    #[cfg(not(feature = "link-static"))]
    pub use self::dummy::*;

    #[cfg(not(feature = "link-static"))]
    pub mod dummy {
        use super::*;
        impl ::core::fmt::Debug for AzCallback                          { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzLayoutCallbackInner               { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzMarshaledLayoutCallbackInner      { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzRenderImageCallback               { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzIFrameCallback                    { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzTimerCallback                     { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzWriteBackCallback                 { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzThreadDestructorFn                { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzLibraryReceiveThreadMsgFn         { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzLibrarySendThreadMsgFn            { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzCheckThreadFinishedFn             { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzGetSystemTimeFn                   { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzCreateThreadFn                    { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzThreadRecvFn                      { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzThreadReceiverDestructorFn        { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzThreadSenderDestructorFn          { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzInstantPtrDestructorFn            { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzInstantPtrCloneFn                 { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzThreadSendFn                      { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzCheckBoxOnToggleCallback          { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzColorInputOnValueChangeCallback   { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzTextInputOnTextInputCallback      { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzTextInputOnVirtualKeyDownCallback { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzTextInputOnFocusLostCallback      { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzNumberInputOnValueChangeCallback  { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzTabOnClickCallback                { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}

        impl ::core::fmt::Debug for AzDomVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzDomVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzIdOrClassVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzIdOrClassVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzNodeDataInlineCssPropertyVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzNodeDataInlineCssPropertyVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStyleBackgroundContentVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStyleBackgroundContentVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStyleBackgroundPositionVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStyleBackgroundPositionVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStyleBackgroundRepeatVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStyleBackgroundRepeatVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStyleBackgroundSizeVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStyleBackgroundSizeVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStyleTransformVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStyleTransformVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzCssPropertyVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzCssPropertyVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzSvgMultiPolygonVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzSvgMultiPolygonVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzSvgPathVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzSvgPathVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzVertexAttributeVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzVertexAttributeVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzSvgPathElementVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzSvgPathElementVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzSvgVertexVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzSvgVertexVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzSvgColoredVertexVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzSvgColoredVertexVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzU32VecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzU32VecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzXWindowTypeVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzXWindowTypeVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzVirtualKeyCodeVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzVirtualKeyCodeVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzCascadeInfoVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzCascadeInfoVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzScanCodeVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzScanCodeVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzCssDeclarationVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzCssDeclarationVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzCssPathSelectorVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzCssPathSelectorVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStylesheetVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStylesheetVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzCssRuleBlockVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzCssRuleBlockVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzU8VecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzU8VecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzCallbackDataVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzCallbackDataVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzDebugMessageVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzDebugMessageVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzGLuintVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzGLuintVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzGLintVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzGLintVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStringVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStringVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStringPairVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStringPairVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzNormalizedLinearColorStopVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzNormalizedLinearColorStopVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzNormalizedRadialColorStopVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzNormalizedRadialColorStopVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzNodeIdVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzNodeIdVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzNodeHierarchyItemVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzNodeHierarchyItemVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStyledNodeVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStyledNodeVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzTagIdToNodeIdMappingVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzTagIdToNodeIdMappingVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzParentWithNodeDepthVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzParentWithNodeDepthVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzNodeDataVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzNodeDataVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzSvgSimpleNodeVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzSvgSimpleNodeVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
    }


    // Generated structs would go here
    use core::ffi::c_void;
    use azul_impl::css::*;

    #[test]
    fn test_size() {
         use core::alloc::Layout;
        assert_eq!((Layout::new::<azul_core::app_resources::LayoutSolverVersion>(), "AzLayoutSolverVersion"), (Layout::new::<AzLayoutSolverVersion>(), "AzLayoutSolverVersion"));
        assert_eq!((Layout::new::<azul_core::resources::AppConfig>(), "AzAppConfig"), (Layout::new::<AzAppConfig>(), "AzAppConfig"));
        assert_eq!((Layout::new::<azul_core::resources::AppLogLevel>(), "AzAppLogLevel"), (Layout::new::<AzAppLogLevel>(), "AzAppLogLevel"));
        assert_eq!((Layout::new::<azul_dll::desktop::app::AzAppPtr>(), "AzAzAppPtr"), (Layout::new::<AzAzAppPtr>(), "AzAzAppPtr"));
        assert_eq!((Layout::new::<azul_layout::callbacks::ExternalSystemCallbacks>(), "AzExternalSystemCallbacks"), (Layout::new::<AzExternalSystemCallbacks>(), "AzExternalSystemCallbacks"));
        assert_eq!((Layout::new::<azul_core::window::WindowCreateOptions>(), "AzWindowCreateOptions"), (Layout::new::<AzWindowCreateOptions>(), "AzWindowCreateOptions"));
        assert_eq!((Layout::new::<azul_core::window::RendererOptions>(), "AzRendererOptions"), (Layout::new::<AzRendererOptions>(), "AzRendererOptions"));
        assert_eq!((Layout::new::<azul_core::window::Vsync>(), "AzVsync"), (Layout::new::<AzVsync>(), "AzVsync"));
        assert_eq!((Layout::new::<azul_core::window::Srgb>(), "AzSrgb"), (Layout::new::<AzSrgb>(), "AzSrgb"));
        assert_eq!((Layout::new::<azul_core::window::HwAcceleration>(), "AzHwAcceleration"), (Layout::new::<AzHwAcceleration>(), "AzHwAcceleration"));
        assert_eq!((Layout::new::<azul_css::props::basic::geometry::LayoutPoint>(), "AzLayoutPoint"), (Layout::new::<AzLayoutPoint>(), "AzLayoutPoint"));
        assert_eq!((Layout::new::<azul_css::props::basic::geometry::LayoutSize>(), "AzLayoutSize"), (Layout::new::<AzLayoutSize>(), "AzLayoutSize"));
        assert_eq!((Layout::new::<azul_css::props::basic::geometry::LayoutRect>(), "AzLayoutRect"), (Layout::new::<AzLayoutRect>(), "AzLayoutRect"));
        assert_eq!((Layout::new::<azul_core::window::RawWindowHandle>(), "AzRawWindowHandle"), (Layout::new::<AzRawWindowHandle>(), "AzRawWindowHandle"));
        assert_eq!((Layout::new::<azul_core::window::IOSHandle>(), "AzIOSHandle"), (Layout::new::<AzIOSHandle>(), "AzIOSHandle"));
        assert_eq!((Layout::new::<azul_core::window::MacOSHandle>(), "AzMacOSHandle"), (Layout::new::<AzMacOSHandle>(), "AzMacOSHandle"));
        assert_eq!((Layout::new::<azul_core::window::XlibHandle>(), "AzXlibHandle"), (Layout::new::<AzXlibHandle>(), "AzXlibHandle"));
        assert_eq!((Layout::new::<azul_core::window::XcbHandle>(), "AzXcbHandle"), (Layout::new::<AzXcbHandle>(), "AzXcbHandle"));
        assert_eq!((Layout::new::<azul_core::window::WaylandHandle>(), "AzWaylandHandle"), (Layout::new::<AzWaylandHandle>(), "AzWaylandHandle"));
        assert_eq!((Layout::new::<azul_core::window::WindowsHandle>(), "AzWindowsHandle"), (Layout::new::<AzWindowsHandle>(), "AzWindowsHandle"));
        assert_eq!((Layout::new::<azul_core::window::WebHandle>(), "AzWebHandle"), (Layout::new::<AzWebHandle>(), "AzWebHandle"));
        assert_eq!((Layout::new::<azul_core::window::AndroidHandle>(), "AzAndroidHandle"), (Layout::new::<AzAndroidHandle>(), "AzAndroidHandle"));
        assert_eq!((Layout::new::<azul_core::window::XWindowType>(), "AzXWindowType"), (Layout::new::<AzXWindowType>(), "AzXWindowType"));
        assert_eq!((Layout::new::<azul_core::window::PhysicalPositionI32>(), "AzPhysicalPositionI32"), (Layout::new::<AzPhysicalPositionI32>(), "AzPhysicalPositionI32"));
        assert_eq!((Layout::new::<azul_core::window::PhysicalSizeU32>(), "AzPhysicalSizeU32"), (Layout::new::<AzPhysicalSizeU32>(), "AzPhysicalSizeU32"));
        assert_eq!((Layout::new::<azul_core::window::LogicalRect>(), "AzLogicalRect"), (Layout::new::<AzLogicalRect>(), "AzLogicalRect"));
        assert_eq!((Layout::new::<azul_core::window::LogicalPosition>(), "AzLogicalPosition"), (Layout::new::<AzLogicalPosition>(), "AzLogicalPosition"));
        assert_eq!((Layout::new::<azul_core::window::LogicalSize>(), "AzLogicalSize"), (Layout::new::<AzLogicalSize>(), "AzLogicalSize"));
        assert_eq!((Layout::new::<azul_core::window::IconKey>(), "AzIconKey"), (Layout::new::<AzIconKey>(), "AzIconKey"));
        assert_eq!((Layout::new::<azul_core::window::SmallWindowIconBytes>(), "AzSmallWindowIconBytes"), (Layout::new::<AzSmallWindowIconBytes>(), "AzSmallWindowIconBytes"));
        assert_eq!((Layout::new::<azul_core::window::LargeWindowIconBytes>(), "AzLargeWindowIconBytes"), (Layout::new::<AzLargeWindowIconBytes>(), "AzLargeWindowIconBytes"));
        assert_eq!((Layout::new::<azul_core::window::WindowIcon>(), "AzWindowIcon"), (Layout::new::<AzWindowIcon>(), "AzWindowIcon"));
        assert_eq!((Layout::new::<azul_core::window::TaskBarIcon>(), "AzTaskBarIcon"), (Layout::new::<AzTaskBarIcon>(), "AzTaskBarIcon"));
        assert_eq!((Layout::new::<azul_core::window::VirtualKeyCode>(), "AzVirtualKeyCode"), (Layout::new::<AzVirtualKeyCode>(), "AzVirtualKeyCode"));
        assert_eq!((Layout::new::<azul_core::window::AcceleratorKey>(), "AzAcceleratorKey"), (Layout::new::<AzAcceleratorKey>(), "AzAcceleratorKey"));
        assert_eq!((Layout::new::<azul_core::window::WindowSize>(), "AzWindowSize"), (Layout::new::<AzWindowSize>(), "AzWindowSize"));
        assert_eq!((Layout::new::<azul_core::window::WindowFlags>(), "AzWindowFlags"), (Layout::new::<AzWindowFlags>(), "AzWindowFlags"));
        assert_eq!((Layout::new::<azul_core::window::WindowFrame>(), "AzWindowFrame"), (Layout::new::<AzWindowFrame>(), "AzWindowFrame"));
        assert_eq!((Layout::new::<azul_core::window::DebugState>(), "AzDebugState"), (Layout::new::<AzDebugState>(), "AzDebugState"));
        assert_eq!((Layout::new::<azul_core::window::KeyboardState>(), "AzKeyboardState"), (Layout::new::<AzKeyboardState>(), "AzKeyboardState"));
        assert_eq!((Layout::new::<azul_core::window::MouseCursorType>(), "AzMouseCursorType"), (Layout::new::<AzMouseCursorType>(), "AzMouseCursorType"));
        assert_eq!((Layout::new::<azul_core::window::CursorPosition>(), "AzCursorPosition"), (Layout::new::<AzCursorPosition>(), "AzCursorPosition"));
        assert_eq!((Layout::new::<azul_core::window::MouseState>(), "AzMouseState"), (Layout::new::<AzMouseState>(), "AzMouseState"));
        assert_eq!((Layout::new::<azul_core::window::PlatformSpecificOptions>(), "AzPlatformSpecificOptions"), (Layout::new::<AzPlatformSpecificOptions>(), "AzPlatformSpecificOptions"));
        assert_eq!((Layout::new::<azul_core::window::WindowsWindowOptions>(), "AzWindowsWindowOptions"), (Layout::new::<AzWindowsWindowOptions>(), "AzWindowsWindowOptions"));
        assert_eq!((Layout::new::<azul_core::window::WaylandTheme>(), "AzWaylandTheme"), (Layout::new::<AzWaylandTheme>(), "AzWaylandTheme"));
        assert_eq!((Layout::new::<azul_core::window::RendererType>(), "AzRendererType"), (Layout::new::<AzRendererType>(), "AzRendererType"));
        assert_eq!((Layout::new::<azul_core::window::WindowState>(), "AzWindowState"), (Layout::new::<AzWindowState>(), "AzWindowState"));
        assert_eq!((Layout::new::<azul_core::window::LinuxWindowOptions>(), "AzLinuxWindowOptions"), (Layout::new::<AzLinuxWindowOptions>(), "AzLinuxWindowOptions"));
        assert_eq!((Layout::new::<azul_core::window::MacWindowOptions>(), "AzMacWindowOptions"), (Layout::new::<AzMacWindowOptions>(), "AzMacWindowOptions"));
        assert_eq!((Layout::new::<azul_core::window::WasmWindowOptions>(), "AzWasmWindowOptions"), (Layout::new::<AzWasmWindowOptions>(), "AzWasmWindowOptions"));
        assert_eq!((Layout::new::<azul_core::window::FullScreenMode>(), "AzFullScreenMode"), (Layout::new::<AzFullScreenMode>(), "AzFullScreenMode"));
        assert_eq!((Layout::new::<azul_core::window::WindowTheme>(), "AzWindowTheme"), (Layout::new::<AzWindowTheme>(), "AzWindowTheme"));
        assert_eq!((Layout::new::<azul_core::window::WindowPosition>(), "AzWindowPosition"), (Layout::new::<AzWindowPosition>(), "AzWindowPosition"));
        assert_eq!((Layout::new::<azul_core::window::ImePosition>(), "AzImePosition"), (Layout::new::<AzImePosition>(), "AzImePosition"));
        assert_eq!((Layout::new::<azul_core::window::TouchState>(), "AzTouchState"), (Layout::new::<AzTouchState>(), "AzTouchState"));
        assert_eq!((Layout::new::<azul_core::window::Monitor>(), "AzMonitor"), (Layout::new::<AzMonitor>(), "AzMonitor"));
        assert_eq!((Layout::new::<azul_core::window::VideoMode>(), "AzVideoMode"), (Layout::new::<AzVideoMode>(), "AzVideoMode"));
        assert_eq!((Layout::new::<azul_core::window::AzStringPair>(), "AzAzStringPair"), (Layout::new::<AzAzStringPair>(), "AzAzStringPair"));
        assert_eq!((Layout::new::<azul_layout::window::SystemCallbacks>(), "AzSystemCallbacks"), (Layout::new::<AzSystemCallbacks>(), "AzSystemCallbacks"));
        assert_eq!((Layout::new::<azul_core::window::UserAttentionType>(), "AzUserAttentionType"), (Layout::new::<AzUserAttentionType>(), "AzUserAttentionType"));
        assert_eq!((Layout::new::<azul_core::window::WindowDecorations>(), "AzWindowDecorations"), (Layout::new::<AzWindowDecorations>(), "AzWindowDecorations"));
        assert_eq!((Layout::new::<azul_core::window::WindowBackgroundMaterial>(), "AzWindowBackgroundMaterial"), (Layout::new::<AzWindowBackgroundMaterial>(), "AzWindowBackgroundMaterial"));
        assert_eq!((Layout::new::<azul_core::window::MonitorId>(), "AzMonitorId"), (Layout::new::<AzMonitorId>(), "AzMonitorId"));
        assert_eq!((Layout::new::<azul_core::window::WindowType>(), "AzWindowType"), (Layout::new::<AzWindowType>(), "AzWindowType"));
        assert_eq!((Layout::new::<azul_core::callbacks::LayoutCallback>(), "AzLayoutCallback"), (Layout::new::<AzLayoutCallback>(), "AzLayoutCallback"));
        assert_eq!((Layout::new::<azul_core::callbacks::MarshaledLayoutCallback>(), "AzMarshaledLayoutCallback"), (Layout::new::<AzMarshaledLayoutCallback>(), "AzMarshaledLayoutCallback"));
        assert_eq!((Layout::new::<azul_core::callbacks::MarshaledLayoutCallbackInner>(), "AzMarshaledLayoutCallbackInner"), (Layout::new::<AzMarshaledLayoutCallbackInner>(), "AzMarshaledLayoutCallbackInner"));
        assert_eq!((Layout::new::<azul_core::callbacks::LayoutCallbackInner>(), "AzLayoutCallbackInner"), (Layout::new::<AzLayoutCallbackInner>(), "AzLayoutCallbackInner"));
        assert_eq!((Layout::new::<azul_layout::callbacks::Callback>(), "AzCallback"), (Layout::new::<AzCallback>(), "AzCallback"));
        assert_eq!((Layout::new::<azul_layout::callbacks::CallbackInfo>(), "AzCallbackInfo"), (Layout::new::<AzCallbackInfo>(), "AzCallbackInfo"));
        assert_eq!((Layout::new::<azul_core::callbacks::UpdateImageType>(), "AzUpdateImageType"), (Layout::new::<AzUpdateImageType>(), "AzUpdateImageType"));
        assert_eq!((Layout::new::<azul_core::callbacks::Update>(), "AzUpdate"), (Layout::new::<AzUpdate>(), "AzUpdate"));
        assert_eq!((Layout::new::<azul_core::callbacks::LayoutCallbackInfo>(), "AzLayoutCallbackInfo"), (Layout::new::<AzLayoutCallbackInfo>(), "AzLayoutCallbackInfo"));
        assert_eq!((Layout::new::<azul_core::dom::DomId>(), "AzDomId"), (Layout::new::<AzDomId>(), "AzDomId"));
        assert_eq!((Layout::new::<azul_core::dom::DomNodeId>(), "AzDomNodeId"), (Layout::new::<AzDomNodeId>(), "AzDomNodeId"));
        assert_eq!((Layout::new::<azul_core::ui_solver::PositionInfo>(), "AzPositionInfo"), (Layout::new::<AzPositionInfo>(), "AzPositionInfo"));
        assert_eq!((Layout::new::<azul_core::ui_solver::PositionInfoInner>(), "AzPositionInfoInner"), (Layout::new::<AzPositionInfoInner>(), "AzPositionInfoInner"));
        assert_eq!((Layout::new::<azul_core::callbacks::HidpiAdjustedBounds>(), "AzHidpiAdjustedBounds"), (Layout::new::<AzHidpiAdjustedBounds>(), "AzHidpiAdjustedBounds"));
        assert_eq!((Layout::new::<azul_core::callbacks::InlineText>(), "AzInlineText"), (Layout::new::<AzInlineText>(), "AzInlineText"));
        assert_eq!((Layout::new::<azul_core::callbacks::InlineLine>(), "AzInlineLine"), (Layout::new::<AzInlineLine>(), "AzInlineLine"));
        assert_eq!((Layout::new::<azul_core::callbacks::InlineWord>(), "AzInlineWord"), (Layout::new::<AzInlineWord>(), "AzInlineWord"));
        assert_eq!((Layout::new::<azul_core::callbacks::InlineTextContents>(), "AzInlineTextContents"), (Layout::new::<AzInlineTextContents>(), "AzInlineTextContents"));
        assert_eq!((Layout::new::<azul_core::callbacks::InlineGlyph>(), "AzInlineGlyph"), (Layout::new::<AzInlineGlyph>(), "AzInlineGlyph"));
        assert_eq!((Layout::new::<azul_core::callbacks::InlineTextHit>(), "AzInlineTextHit"), (Layout::new::<AzInlineTextHit>(), "AzInlineTextHit"));
        assert_eq!((Layout::new::<azul_core::callbacks::FocusTarget>(), "AzFocusTarget"), (Layout::new::<AzFocusTarget>(), "AzFocusTarget"));
        assert_eq!((Layout::new::<azul_core::callbacks::FocusTargetPath>(), "AzFocusTargetPath"), (Layout::new::<AzFocusTargetPath>(), "AzFocusTargetPath"));
        assert_eq!((Layout::new::<azul_core::ui_solver::ScriptType>(), "AzScriptType"), (Layout::new::<AzScriptType>(), "AzScriptType"));
        assert_eq!((Layout::new::<azul_core::ui_solver::ResolvedTextLayoutOptions>(), "AzResolvedTextLayoutOptions"), (Layout::new::<AzResolvedTextLayoutOptions>(), "AzResolvedTextLayoutOptions"));
        assert_eq!((Layout::new::<azul_core::callbacks::Animation>(), "AzAnimation"), (Layout::new::<AzAnimation>(), "AzAnimation"));
        assert_eq!((Layout::new::<azul_core::callbacks::AnimationRepeat>(), "AzAnimationRepeat"), (Layout::new::<AzAnimationRepeat>(), "AzAnimationRepeat"));
        assert_eq!((Layout::new::<azul_core::callbacks::AnimationRepeatCount>(), "AzAnimationRepeatCount"), (Layout::new::<AzAnimationRepeatCount>(), "AzAnimationRepeatCount"));
        assert_eq!((Layout::new::<azul_core::styled_dom::NodeHierarchyItemId>(), "AzNodeHierarchyItemId"), (Layout::new::<AzNodeHierarchyItemId>(), "AzNodeHierarchyItemId"));
        assert_eq!((Layout::new::<azul_core::callbacks::IFrameCallback>(), "AzIFrameCallback"), (Layout::new::<AzIFrameCallback>(), "AzIFrameCallback"));
        assert_eq!((Layout::new::<azul_core::callbacks::IFrameCallbackInfo>(), "AzIFrameCallbackInfo"), (Layout::new::<AzIFrameCallbackInfo>(), "AzIFrameCallbackInfo"));
        assert_eq!((Layout::new::<azul_core::callbacks::IFrameCallbackReturn>(), "AzIFrameCallbackReturn"), (Layout::new::<AzIFrameCallbackReturn>(), "AzIFrameCallbackReturn"));
        assert_eq!((Layout::new::<azul_layout::callbacks::RenderImageCallback>(), "AzRenderImageCallback"), (Layout::new::<AzRenderImageCallback>(), "AzRenderImageCallback"));
        assert_eq!((Layout::new::<azul_layout::callbacks::RenderImageCallbackInfo>(), "AzRenderImageCallbackInfo"), (Layout::new::<AzRenderImageCallbackInfo>(), "AzRenderImageCallbackInfo"));
        assert_eq!((Layout::new::<azul_core::callbacks::TimerCallback>(), "AzTimerCallback"), (Layout::new::<AzTimerCallback>(), "AzTimerCallback"));
        assert_eq!((Layout::new::<azul_core::callbacks::TimerCallbackInfo>(), "AzTimerCallbackInfo"), (Layout::new::<AzTimerCallbackInfo>(), "AzTimerCallbackInfo"));
        assert_eq!((Layout::new::<azul_core::callbacks::TimerCallbackReturn>(), "AzTimerCallbackReturn"), (Layout::new::<AzTimerCallbackReturn>(), "AzTimerCallbackReturn"));
        assert_eq!((Layout::new::<azul_core::callbacks::WriteBackCallback>(), "AzWriteBackCallback"), (Layout::new::<AzWriteBackCallback>(), "AzWriteBackCallback"));
        assert_eq!((Layout::new::<azul_core::callbacks::ThreadCallback>(), "AzThreadCallback"), (Layout::new::<AzThreadCallback>(), "AzThreadCallback"));
        assert_eq!((Layout::new::<azul_core::callbacks::RefCount>(), "AzRefCount"), (Layout::new::<AzRefCount>(), "AzRefCount"));
        assert_eq!((Layout::new::<azul_core::callbacks::RefAny>(), "AzRefAny"), (Layout::new::<AzRefAny>(), "AzRefAny"));
        assert_eq!((Layout::new::<azul_core::callbacks::EdgeType>(), "AzEdgeType"), (Layout::new::<AzEdgeType>(), "AzEdgeType"));
        assert_eq!((Layout::new::<azul_core::window::MenuCallback>(), "AzMenuCallback"), (Layout::new::<AzMenuCallback>(), "AzMenuCallback"));
        assert_eq!((Layout::new::<azul_core::callbacks::IFrameCallbackReason>(), "AzIFrameCallbackReason"), (Layout::new::<AzIFrameCallbackReason>(), "AzIFrameCallbackReason"));
        assert_eq!((Layout::new::<azul_core::dom::Dom>(), "AzDom"), (Layout::new::<AzDom>(), "AzDom"));
        assert_eq!((Layout::new::<azul_core::dom::IFrameNode>(), "AzIFrameNode"), (Layout::new::<AzIFrameNode>(), "AzIFrameNode"));
        assert_eq!((Layout::new::<azul_core::dom::CallbackData>(), "AzCallbackData"), (Layout::new::<AzCallbackData>(), "AzCallbackData"));
        assert_eq!((Layout::new::<azul_core::dom::NodeData>(), "AzNodeData"), (Layout::new::<AzNodeData>(), "AzNodeData"));
        assert_eq!((Layout::new::<azul_core::dom::NodeType>(), "AzNodeType"), (Layout::new::<AzNodeType>(), "AzNodeType"));
        assert_eq!((Layout::new::<azul_core::dom::On>(), "AzOn"), (Layout::new::<AzOn>(), "AzOn"));
        assert_eq!((Layout::new::<azul_core::dom::EventFilter>(), "AzEventFilter"), (Layout::new::<AzEventFilter>(), "AzEventFilter"));
        assert_eq!((Layout::new::<azul_core::dom::HoverEventFilter>(), "AzHoverEventFilter"), (Layout::new::<AzHoverEventFilter>(), "AzHoverEventFilter"));
        assert_eq!((Layout::new::<azul_core::dom::FocusEventFilter>(), "AzFocusEventFilter"), (Layout::new::<AzFocusEventFilter>(), "AzFocusEventFilter"));
        assert_eq!((Layout::new::<azul_core::dom::NotEventFilter>(), "AzNotEventFilter"), (Layout::new::<AzNotEventFilter>(), "AzNotEventFilter"));
        assert_eq!((Layout::new::<azul_core::dom::WindowEventFilter>(), "AzWindowEventFilter"), (Layout::new::<AzWindowEventFilter>(), "AzWindowEventFilter"));
        assert_eq!((Layout::new::<azul_core::dom::ComponentEventFilter>(), "AzComponentEventFilter"), (Layout::new::<AzComponentEventFilter>(), "AzComponentEventFilter"));
        assert_eq!((Layout::new::<azul_core::dom::ApplicationEventFilter>(), "AzApplicationEventFilter"), (Layout::new::<AzApplicationEventFilter>(), "AzApplicationEventFilter"));
        assert_eq!((Layout::new::<azul_core::dom::AccessibilityInfo>(), "AzAccessibilityInfo"), (Layout::new::<AzAccessibilityInfo>(), "AzAccessibilityInfo"));
        assert_eq!((Layout::new::<azul_core::dom::AccessibilityRole>(), "AzAccessibilityRole"), (Layout::new::<AzAccessibilityRole>(), "AzAccessibilityRole"));
        assert_eq!((Layout::new::<azul_core::dom::AccessibilityState>(), "AzAccessibilityState"), (Layout::new::<AzAccessibilityState>(), "AzAccessibilityState"));
        assert_eq!((Layout::new::<azul_core::dom::TabIndex>(), "AzTabIndex"), (Layout::new::<AzTabIndex>(), "AzTabIndex"));
        assert_eq!((Layout::new::<azul_core::dom::IdOrClass>(), "AzIdOrClass"), (Layout::new::<AzIdOrClass>(), "AzIdOrClass"));
        assert_eq!((Layout::new::<azul_core::dom::NodeDataInlineCssProperty>(), "AzNodeDataInlineCssProperty"), (Layout::new::<AzNodeDataInlineCssProperty>(), "AzNodeDataInlineCssProperty"));
        assert_eq!((Layout::new::<azul_core::menu::Menu>(), "AzMenu"), (Layout::new::<AzMenu>(), "AzMenu"));
        assert_eq!((Layout::new::<azul_core::window::ContextMenuMouseButton>(), "AzContextMenuMouseButton"), (Layout::new::<AzContextMenuMouseButton>(), "AzContextMenuMouseButton"));
        assert_eq!((Layout::new::<azul_core::menu::MenuPopupPosition>(), "AzMenuPopupPosition"), (Layout::new::<AzMenuPopupPosition>(), "AzMenuPopupPosition"));
        assert_eq!((Layout::new::<azul_core::menu::MenuItem>(), "AzMenuItem"), (Layout::new::<AzMenuItem>(), "AzMenuItem"));
        assert_eq!((Layout::new::<azul_core::menu::StringMenuItem>(), "AzStringMenuItem"), (Layout::new::<AzStringMenuItem>(), "AzStringMenuItem"));
        assert_eq!((Layout::new::<azul_core::window::VirtualKeyCodeCombo>(), "AzVirtualKeyCodeCombo"), (Layout::new::<AzVirtualKeyCodeCombo>(), "AzVirtualKeyCodeCombo"));
        assert_eq!((Layout::new::<azul_core::menu::MenuItemIcon>(), "AzMenuItemIcon"), (Layout::new::<AzMenuItemIcon>(), "AzMenuItemIcon"));
        assert_eq!((Layout::new::<azul_core::menu::MenuItemState>(), "AzMenuItemState"), (Layout::new::<AzMenuItemState>(), "AzMenuItemState"));
        assert_eq!((Layout::new::<azul_css::css::CssRuleBlock>(), "AzCssRuleBlock"), (Layout::new::<AzCssRuleBlock>(), "AzCssRuleBlock"));
        assert_eq!((Layout::new::<azul_css::css::CssPath>(), "AzCssPath"), (Layout::new::<AzCssPath>(), "AzCssPath"));
        assert_eq!((Layout::new::<azul_css::css::CssPathSelector>(), "AzCssPathSelector"), (Layout::new::<AzCssPathSelector>(), "AzCssPathSelector"));
        assert_eq!((Layout::new::<azul_css::props::property::CssProperty>(), "AzCssProperty"), (Layout::new::<AzCssProperty>(), "AzCssProperty"));
        assert_eq!((Layout::new::<azul_css::css::CssPathPseudoSelector>(), "AzCssPathPseudoSelector"), (Layout::new::<AzCssPathPseudoSelector>(), "AzCssPathPseudoSelector"));
        assert_eq!((Layout::new::<azul_css::css::CssNthChildSelector>(), "AzCssNthChildSelector"), (Layout::new::<AzCssNthChildSelector>(), "AzCssNthChildSelector"));
        assert_eq!((Layout::new::<azul_css::css::CssNthChildPattern>(), "AzCssNthChildPattern"), (Layout::new::<AzCssNthChildPattern>(), "AzCssNthChildPattern"));
        assert_eq!((Layout::new::<azul_css::css::Stylesheet>(), "AzStylesheet"), (Layout::new::<AzStylesheet>(), "AzStylesheet"));
        assert_eq!((Layout::new::<azul_css::css::Css>(), "AzCss"), (Layout::new::<AzCss>(), "AzCss"));
        assert_eq!((Layout::new::<azul_css::css::CssDeclaration>(), "AzCssDeclaration"), (Layout::new::<AzCssDeclaration>(), "AzCssDeclaration"));
        assert_eq!((Layout::new::<azul_css::css::DynamicCssProperty>(), "AzDynamicCssProperty"), (Layout::new::<AzDynamicCssProperty>(), "AzDynamicCssProperty"));
        assert_eq!((Layout::new::<azul_css::props::property::CssPropertyType>(), "AzCssPropertyType"), (Layout::new::<AzCssPropertyType>(), "AzCssPropertyType"));
        assert_eq!((Layout::new::<azul_css::props::basic::animation::AnimationInterpolationFunction>(), "AzAnimationInterpolationFunction"), (Layout::new::<AzAnimationInterpolationFunction>(), "AzAnimationInterpolationFunction"));
        assert_eq!((Layout::new::<azul_css::css::NodeTypeTag>(), "AzNodeTypeTag"), (Layout::new::<AzNodeTypeTag>(), "AzNodeTypeTag"));
        assert_eq!((Layout::new::<azul_css::props::basic::color::ColorU>(), "AzColorU"), (Layout::new::<AzColorU>(), "AzColorU"));
        assert_eq!((Layout::new::<azul_css::props::basic::length::SizeMetric>(), "AzSizeMetric"), (Layout::new::<AzSizeMetric>(), "AzSizeMetric"));
        assert_eq!((Layout::new::<azul_css::props::basic::pixel::PixelValue>(), "AzPixelValue"), (Layout::new::<AzPixelValue>(), "AzPixelValue"));
        assert_eq!((Layout::new::<azul_css::props::basic::pixel::PixelValueNoPercent>(), "AzPixelValueNoPercent"), (Layout::new::<AzPixelValueNoPercent>(), "AzPixelValueNoPercent"));
        assert_eq!((Layout::new::<azul_css::props::style::box_shadow::BoxShadowClipMode>(), "AzBoxShadowClipMode"), (Layout::new::<AzBoxShadowClipMode>(), "AzBoxShadowClipMode"));
        assert_eq!((Layout::new::<azul_css::props::style::box_shadow::StyleBoxShadow>(), "AzStyleBoxShadow"), (Layout::new::<AzStyleBoxShadow>(), "AzStyleBoxShadow"));
        assert_eq!((Layout::new::<azul_css::props::style::effects::StyleMixBlendMode>(), "AzStyleMixBlendMode"), (Layout::new::<AzStyleMixBlendMode>(), "AzStyleMixBlendMode"));
        assert_eq!((Layout::new::<azul_css::props::style::filter::StyleFilter>(), "AzStyleFilter"), (Layout::new::<AzStyleFilter>(), "AzStyleFilter"));
        assert_eq!((Layout::new::<azul_css::props::style::filter::StyleBlur>(), "AzStyleBlur"), (Layout::new::<AzStyleBlur>(), "AzStyleBlur"));
        assert_eq!((Layout::new::<azul_css::props::style::filter::StyleColorMatrix>(), "AzStyleColorMatrix"), (Layout::new::<AzStyleColorMatrix>(), "AzStyleColorMatrix"));
        assert_eq!((Layout::new::<azul_css::props::style::filter::StyleFilterOffset>(), "AzStyleFilterOffset"), (Layout::new::<AzStyleFilterOffset>(), "AzStyleFilterOffset"));
        assert_eq!((Layout::new::<azul_css::props::style::filter::StyleCompositeFilter>(), "AzStyleCompositeFilter"), (Layout::new::<AzStyleCompositeFilter>(), "AzStyleCompositeFilter"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutAlignContent>(), "AzLayoutAlignContent"), (Layout::new::<AzLayoutAlignContent>(), "AzLayoutAlignContent"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutAlignItems>(), "AzLayoutAlignItems"), (Layout::new::<AzLayoutAlignItems>(), "AzLayoutAlignItems"));
        assert_eq!((Layout::new::<azul_css::LayoutBottom>(), "AzLayoutBottom"), (Layout::new::<AzLayoutBottom>(), "AzLayoutBottom"));
        assert_eq!((Layout::new::<azul_css::props::layout::dimensions::LayoutBoxSizing>(), "AzLayoutBoxSizing"), (Layout::new::<AzLayoutBoxSizing>(), "AzLayoutBoxSizing"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutFlexDirection>(), "AzLayoutFlexDirection"), (Layout::new::<AzLayoutFlexDirection>(), "AzLayoutFlexDirection"));
        assert_eq!((Layout::new::<azul_css::props::layout::display::LayoutDisplay>(), "AzLayoutDisplay"), (Layout::new::<AzLayoutDisplay>(), "AzLayoutDisplay"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutFlexGrow>(), "AzLayoutFlexGrow"), (Layout::new::<AzLayoutFlexGrow>(), "AzLayoutFlexGrow"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutFlexShrink>(), "AzLayoutFlexShrink"), (Layout::new::<AzLayoutFlexShrink>(), "AzLayoutFlexShrink"));
        assert_eq!((Layout::new::<azul_css::props::layout::display::LayoutFloat>(), "AzLayoutFloat"), (Layout::new::<AzLayoutFloat>(), "AzLayoutFloat"));
        assert_eq!((Layout::new::<azul_css::props::layout::dimensions::LayoutHeight>(), "AzLayoutHeight"), (Layout::new::<AzLayoutHeight>(), "AzLayoutHeight"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutJustifyContent>(), "AzLayoutJustifyContent"), (Layout::new::<AzLayoutJustifyContent>(), "AzLayoutJustifyContent"));
        assert_eq!((Layout::new::<azul_css::LayoutLeft>(), "AzLayoutLeft"), (Layout::new::<AzLayoutLeft>(), "AzLayoutLeft"));
        assert_eq!((Layout::new::<azul_css::LayoutMarginBottom>(), "AzLayoutMarginBottom"), (Layout::new::<AzLayoutMarginBottom>(), "AzLayoutMarginBottom"));
        assert_eq!((Layout::new::<azul_css::LayoutMarginLeft>(), "AzLayoutMarginLeft"), (Layout::new::<AzLayoutMarginLeft>(), "AzLayoutMarginLeft"));
        assert_eq!((Layout::new::<azul_css::LayoutMarginRight>(), "AzLayoutMarginRight"), (Layout::new::<AzLayoutMarginRight>(), "AzLayoutMarginRight"));
        assert_eq!((Layout::new::<azul_css::LayoutMarginTop>(), "AzLayoutMarginTop"), (Layout::new::<AzLayoutMarginTop>(), "AzLayoutMarginTop"));
        assert_eq!((Layout::new::<azul_css::LayoutMaxHeight>(), "AzLayoutMaxHeight"), (Layout::new::<AzLayoutMaxHeight>(), "AzLayoutMaxHeight"));
        assert_eq!((Layout::new::<azul_css::LayoutMaxWidth>(), "AzLayoutMaxWidth"), (Layout::new::<AzLayoutMaxWidth>(), "AzLayoutMaxWidth"));
        assert_eq!((Layout::new::<azul_css::LayoutMinHeight>(), "AzLayoutMinHeight"), (Layout::new::<AzLayoutMinHeight>(), "AzLayoutMinHeight"));
        assert_eq!((Layout::new::<azul_css::LayoutMinWidth>(), "AzLayoutMinWidth"), (Layout::new::<AzLayoutMinWidth>(), "AzLayoutMinWidth"));
        assert_eq!((Layout::new::<azul_css::LayoutPaddingBottom>(), "AzLayoutPaddingBottom"), (Layout::new::<AzLayoutPaddingBottom>(), "AzLayoutPaddingBottom"));
        assert_eq!((Layout::new::<azul_css::LayoutPaddingLeft>(), "AzLayoutPaddingLeft"), (Layout::new::<AzLayoutPaddingLeft>(), "AzLayoutPaddingLeft"));
        assert_eq!((Layout::new::<azul_css::LayoutPaddingRight>(), "AzLayoutPaddingRight"), (Layout::new::<AzLayoutPaddingRight>(), "AzLayoutPaddingRight"));
        assert_eq!((Layout::new::<azul_css::LayoutPaddingTop>(), "AzLayoutPaddingTop"), (Layout::new::<AzLayoutPaddingTop>(), "AzLayoutPaddingTop"));
        assert_eq!((Layout::new::<azul_css::props::layout::position::LayoutPosition>(), "AzLayoutPosition"), (Layout::new::<AzLayoutPosition>(), "AzLayoutPosition"));
        assert_eq!((Layout::new::<azul_css::LayoutRight>(), "AzLayoutRight"), (Layout::new::<AzLayoutRight>(), "AzLayoutRight"));
        assert_eq!((Layout::new::<azul_css::LayoutTop>(), "AzLayoutTop"), (Layout::new::<AzLayoutTop>(), "AzLayoutTop"));
        assert_eq!((Layout::new::<azul_css::props::layout::dimensions::LayoutWidth>(), "AzLayoutWidth"), (Layout::new::<AzLayoutWidth>(), "AzLayoutWidth"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutFlexWrap>(), "AzLayoutFlexWrap"), (Layout::new::<AzLayoutFlexWrap>(), "AzLayoutFlexWrap"));
        assert_eq!((Layout::new::<azul_css::props::layout::overflow::LayoutOverflow>(), "AzLayoutOverflow"), (Layout::new::<AzLayoutOverflow>(), "AzLayoutOverflow"));
        assert_eq!((Layout::new::<azul_css::props::basic::length::FloatValue>(), "AzFloatValue"), (Layout::new::<AzFloatValue>(), "AzFloatValue"));
        assert_eq!((Layout::new::<azul_css::props::basic::length::PercentageValue>(), "AzPercentageValue"), (Layout::new::<AzPercentageValue>(), "AzPercentageValue"));
        assert_eq!((Layout::new::<azul_css::props::basic::angle::AngleMetric>(), "AzAngleMetric"), (Layout::new::<AzAngleMetric>(), "AzAngleMetric"));
        assert_eq!((Layout::new::<azul_css::props::basic::angle::AngleValue>(), "AzAngleValue"), (Layout::new::<AzAngleValue>(), "AzAngleValue"));
        assert_eq!((Layout::new::<azul_css::props::style::background::NormalizedLinearColorStop>(), "AzNormalizedLinearColorStop"), (Layout::new::<AzNormalizedLinearColorStop>(), "AzNormalizedLinearColorStop"));
        assert_eq!((Layout::new::<azul_css::props::style::background::NormalizedRadialColorStop>(), "AzNormalizedRadialColorStop"), (Layout::new::<AzNormalizedRadialColorStop>(), "AzNormalizedRadialColorStop"));
        assert_eq!((Layout::new::<azul_css::props::basic::direction::DirectionCorner>(), "AzDirectionCorner"), (Layout::new::<AzDirectionCorner>(), "AzDirectionCorner"));
        assert_eq!((Layout::new::<azul_css::props::basic::direction::DirectionCorners>(), "AzDirectionCorners"), (Layout::new::<AzDirectionCorners>(), "AzDirectionCorners"));
        assert_eq!((Layout::new::<azul_css::props::basic::direction::Direction>(), "AzDirection"), (Layout::new::<AzDirection>(), "AzDirection"));
        assert_eq!((Layout::new::<azul_css::props::style::background::ExtendMode>(), "AzExtendMode"), (Layout::new::<AzExtendMode>(), "AzExtendMode"));
        assert_eq!((Layout::new::<azul_css::props::style::background::LinearGradient>(), "AzLinearGradient"), (Layout::new::<AzLinearGradient>(), "AzLinearGradient"));
        assert_eq!((Layout::new::<azul_css::props::style::background::Shape>(), "AzShape"), (Layout::new::<AzShape>(), "AzShape"));
        assert_eq!((Layout::new::<azul_css::props::style::background::RadialGradientSize>(), "AzRadialGradientSize"), (Layout::new::<AzRadialGradientSize>(), "AzRadialGradientSize"));
        assert_eq!((Layout::new::<azul_css::props::style::background::RadialGradient>(), "AzRadialGradient"), (Layout::new::<AzRadialGradient>(), "AzRadialGradient"));
        assert_eq!((Layout::new::<azul_css::props::style::background::ConicGradient>(), "AzConicGradient"), (Layout::new::<AzConicGradient>(), "AzConicGradient"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundContent>(), "AzStyleBackgroundContent"), (Layout::new::<AzStyleBackgroundContent>(), "AzStyleBackgroundContent"));
        assert_eq!((Layout::new::<azul_css::props::style::background::BackgroundPositionHorizontal>(), "AzBackgroundPositionHorizontal"), (Layout::new::<AzBackgroundPositionHorizontal>(), "AzBackgroundPositionHorizontal"));
        assert_eq!((Layout::new::<azul_css::props::style::background::BackgroundPositionVertical>(), "AzBackgroundPositionVertical"), (Layout::new::<AzBackgroundPositionVertical>(), "AzBackgroundPositionVertical"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundPosition>(), "AzStyleBackgroundPosition"), (Layout::new::<AzStyleBackgroundPosition>(), "AzStyleBackgroundPosition"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundRepeat>(), "AzStyleBackgroundRepeat"), (Layout::new::<AzStyleBackgroundRepeat>(), "AzStyleBackgroundRepeat"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundSize>(), "AzStyleBackgroundSize"), (Layout::new::<AzStyleBackgroundSize>(), "AzStyleBackgroundSize"));
        assert_eq!((Layout::new::<azul_css::StyleBorderBottomColor>(), "AzStyleBorderBottomColor"), (Layout::new::<AzStyleBorderBottomColor>(), "AzStyleBorderBottomColor"));
        assert_eq!((Layout::new::<azul_css::StyleBorderBottomLeftRadius>(), "AzStyleBorderBottomLeftRadius"), (Layout::new::<AzStyleBorderBottomLeftRadius>(), "AzStyleBorderBottomLeftRadius"));
        assert_eq!((Layout::new::<azul_css::StyleBorderBottomRightRadius>(), "AzStyleBorderBottomRightRadius"), (Layout::new::<AzStyleBorderBottomRightRadius>(), "AzStyleBorderBottomRightRadius"));
        assert_eq!((Layout::new::<azul_css::props::style::border::BorderStyle>(), "AzBorderStyle"), (Layout::new::<AzBorderStyle>(), "AzBorderStyle"));
        assert_eq!((Layout::new::<azul_css::StyleBorderBottomStyle>(), "AzStyleBorderBottomStyle"), (Layout::new::<AzStyleBorderBottomStyle>(), "AzStyleBorderBottomStyle"));
        assert_eq!((Layout::new::<azul_css::LayoutBorderBottomWidth>(), "AzLayoutBorderBottomWidth"), (Layout::new::<AzLayoutBorderBottomWidth>(), "AzLayoutBorderBottomWidth"));
        assert_eq!((Layout::new::<azul_css::StyleBorderLeftColor>(), "AzStyleBorderLeftColor"), (Layout::new::<AzStyleBorderLeftColor>(), "AzStyleBorderLeftColor"));
        assert_eq!((Layout::new::<azul_css::StyleBorderLeftStyle>(), "AzStyleBorderLeftStyle"), (Layout::new::<AzStyleBorderLeftStyle>(), "AzStyleBorderLeftStyle"));
        assert_eq!((Layout::new::<azul_css::LayoutBorderLeftWidth>(), "AzLayoutBorderLeftWidth"), (Layout::new::<AzLayoutBorderLeftWidth>(), "AzLayoutBorderLeftWidth"));
        assert_eq!((Layout::new::<azul_css::StyleBorderRightColor>(), "AzStyleBorderRightColor"), (Layout::new::<AzStyleBorderRightColor>(), "AzStyleBorderRightColor"));
        assert_eq!((Layout::new::<azul_css::StyleBorderRightStyle>(), "AzStyleBorderRightStyle"), (Layout::new::<AzStyleBorderRightStyle>(), "AzStyleBorderRightStyle"));
        assert_eq!((Layout::new::<azul_css::LayoutBorderRightWidth>(), "AzLayoutBorderRightWidth"), (Layout::new::<AzLayoutBorderRightWidth>(), "AzLayoutBorderRightWidth"));
        assert_eq!((Layout::new::<azul_css::StyleBorderTopColor>(), "AzStyleBorderTopColor"), (Layout::new::<AzStyleBorderTopColor>(), "AzStyleBorderTopColor"));
        assert_eq!((Layout::new::<azul_css::StyleBorderTopLeftRadius>(), "AzStyleBorderTopLeftRadius"), (Layout::new::<AzStyleBorderTopLeftRadius>(), "AzStyleBorderTopLeftRadius"));
        assert_eq!((Layout::new::<azul_css::StyleBorderTopRightRadius>(), "AzStyleBorderTopRightRadius"), (Layout::new::<AzStyleBorderTopRightRadius>(), "AzStyleBorderTopRightRadius"));
        assert_eq!((Layout::new::<azul_css::StyleBorderTopStyle>(), "AzStyleBorderTopStyle"), (Layout::new::<AzStyleBorderTopStyle>(), "AzStyleBorderTopStyle"));
        assert_eq!((Layout::new::<azul_css::LayoutBorderTopWidth>(), "AzLayoutBorderTopWidth"), (Layout::new::<AzLayoutBorderTopWidth>(), "AzLayoutBorderTopWidth"));
        assert_eq!((Layout::new::<azul_css::props::style::scrollbar::ScrollbarInfo>(), "AzScrollbarInfo"), (Layout::new::<AzScrollbarInfo>(), "AzScrollbarInfo"));
        assert_eq!((Layout::new::<azul_css::props::style::scrollbar::ScrollbarStyle>(), "AzScrollbarStyle"), (Layout::new::<AzScrollbarStyle>(), "AzScrollbarStyle"));
        assert_eq!((Layout::new::<azul_css::props::style::effects::StyleCursor>(), "AzStyleCursor"), (Layout::new::<AzStyleCursor>(), "AzStyleCursor"));
        assert_eq!((Layout::new::<azul_css::props::basic::font::StyleFontFamily>(), "AzStyleFontFamily"), (Layout::new::<AzStyleFontFamily>(), "AzStyleFontFamily"));
        assert_eq!((Layout::new::<azul_css::props::basic::font::StyleFontSize>(), "AzStyleFontSize"), (Layout::new::<AzStyleFontSize>(), "AzStyleFontSize"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleLetterSpacing>(), "AzStyleLetterSpacing"), (Layout::new::<AzStyleLetterSpacing>(), "AzStyleLetterSpacing"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleLineHeight>(), "AzStyleLineHeight"), (Layout::new::<AzStyleLineHeight>(), "AzStyleLineHeight"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleTabWidth>(), "AzStyleTabWidth"), (Layout::new::<AzStyleTabWidth>(), "AzStyleTabWidth"));
        assert_eq!((Layout::new::<azul_css::props::style::effects::StyleOpacity>(), "AzStyleOpacity"), (Layout::new::<AzStyleOpacity>(), "AzStyleOpacity"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformOrigin>(), "AzStyleTransformOrigin"), (Layout::new::<AzStyleTransformOrigin>(), "AzStyleTransformOrigin"));
        assert_eq!((Layout::new::<azul_css::props::basic::animation::InterpolateResolver>(), "AzInterpolateResolver"), (Layout::new::<AzInterpolateResolver>(), "AzInterpolateResolver"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleBackfaceVisibility>(), "AzStyleBackfaceVisibility"), (Layout::new::<AzStyleBackfaceVisibility>(), "AzStyleBackfaceVisibility"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransform>(), "AzStyleTransform"), (Layout::new::<AzStyleTransform>(), "AzStyleTransform"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformMatrix2D>(), "AzStyleTransformMatrix2D"), (Layout::new::<AzStyleTransformMatrix2D>(), "AzStyleTransformMatrix2D"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformMatrix3D>(), "AzStyleTransformMatrix3D"), (Layout::new::<AzStyleTransformMatrix3D>(), "AzStyleTransformMatrix3D"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformTranslate2D>(), "AzStyleTransformTranslate2D"), (Layout::new::<AzStyleTransformTranslate2D>(), "AzStyleTransformTranslate2D"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformTranslate3D>(), "AzStyleTransformTranslate3D"), (Layout::new::<AzStyleTransformTranslate3D>(), "AzStyleTransformTranslate3D"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformRotate3D>(), "AzStyleTransformRotate3D"), (Layout::new::<AzStyleTransformRotate3D>(), "AzStyleTransformRotate3D"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformScale2D>(), "AzStyleTransformScale2D"), (Layout::new::<AzStyleTransformScale2D>(), "AzStyleTransformScale2D"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformScale3D>(), "AzStyleTransformScale3D"), (Layout::new::<AzStyleTransformScale3D>(), "AzStyleTransformScale3D"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformSkew2D>(), "AzStyleTransformSkew2D"), (Layout::new::<AzStyleTransformSkew2D>(), "AzStyleTransformSkew2D"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleTextAlign>(), "AzStyleTextAlign"), (Layout::new::<AzStyleTextAlign>(), "AzStyleTextAlign"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleTextColor>(), "AzStyleTextColor"), (Layout::new::<AzStyleTextColor>(), "AzStyleTextColor"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleWordSpacing>(), "AzStyleWordSpacing"), (Layout::new::<AzStyleWordSpacing>(), "AzStyleWordSpacing"));
        assert_eq!((Layout::new::<azul_css::css::CssPropertyValue>(), "AzCssPropertyValue"), (Layout::new::<AzCssPropertyValue>(), "AzCssPropertyValue"));
        assert_eq!((Layout::new::<azul_css::props::style::content::CounterReset>(), "AzCounterReset"), (Layout::new::<AzCounterReset>(), "AzCounterReset"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::GridLine>(), "AzGridLine"), (Layout::new::<AzGridLine>(), "AzGridLine"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StylePerspectiveOrigin>(), "AzStylePerspectiveOrigin"), (Layout::new::<AzStylePerspectiveOrigin>(), "AzStylePerspectiveOrigin"));
        assert_eq!((Layout::new::<azul_css::props::layout::position::LayoutZIndex>(), "AzLayoutZIndex"), (Layout::new::<AzLayoutZIndex>(), "AzLayoutZIndex"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::LayoutJustifyItems>(), "AzLayoutJustifyItems"), (Layout::new::<AzLayoutJustifyItems>(), "AzLayoutJustifyItems"));
        assert_eq!((Layout::new::<azul_css::props::style::selection::SelectionBackgroundColor>(), "AzSelectionBackgroundColor"), (Layout::new::<AzSelectionBackgroundColor>(), "AzSelectionBackgroundColor"));
        assert_eq!((Layout::new::<azul_css::props::layout::column::ColumnRuleColor>(), "AzColumnRuleColor"), (Layout::new::<AzColumnRuleColor>(), "AzColumnRuleColor"));
        assert_eq!((Layout::new::<azul_css::FontRef>(), "AzFontRef"), (Layout::new::<AzFontRef>(), "AzFontRef"));
        assert_eq!((Layout::new::<azul_css::system::Platform>(), "AzPlatform"), (Layout::new::<AzPlatform>(), "AzPlatform"));
        assert_eq!((Layout::new::<azul_css::props::layout::column::ColumnSpan>(), "AzColumnSpan"), (Layout::new::<AzColumnSpan>(), "AzColumnSpan"));
        assert_eq!((Layout::new::<azul_css::props::layout::wrapping::LayoutClear>(), "AzLayoutClear"), (Layout::new::<AzLayoutClear>(), "AzLayoutClear"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleWhiteSpace>(), "AzStyleWhiteSpace"), (Layout::new::<AzStyleWhiteSpace>(), "AzStyleWhiteSpace"));
        assert_eq!((Layout::new::<azul_css::system::SystemMetrics>(), "AzSystemMetrics"), (Layout::new::<AzSystemMetrics>(), "AzSystemMetrics"));
        assert_eq!((Layout::new::<azul_css::system::SystemStyle>(), "AzSystemStyle"), (Layout::new::<AzSystemStyle>(), "AzSystemStyle"));
        assert_eq!((Layout::new::<azul_css::FontMetrics>(), "AzFontMetrics"), (Layout::new::<AzFontMetrics>(), "AzFontMetrics"));
        assert_eq!((Layout::new::<azul_css::props::layout::fragmentation::BreakInside>(), "AzBreakInside"), (Layout::new::<AzBreakInside>(), "AzBreakInside"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutAlignSelf>(), "AzLayoutAlignSelf"), (Layout::new::<AzLayoutAlignSelf>(), "AzLayoutAlignSelf"));
        assert_eq!((Layout::new::<azul_css::props::style::text::CaretAnimationDuration>(), "AzCaretAnimationDuration"), (Layout::new::<AzCaretAnimationDuration>(), "AzCaretAnimationDuration"));
        assert_eq!((Layout::new::<azul_css::props::layout::column::ColumnRuleStyle>(), "AzColumnRuleStyle"), (Layout::new::<AzColumnRuleStyle>(), "AzColumnRuleStyle"));
        assert_eq!((Layout::new::<azul_layout::xml::svg::SvgPoint>(), "AzSvgPoint"), (Layout::new::<AzSvgPoint>(), "AzSvgPoint"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::GridPlacement>(), "AzGridPlacement"), (Layout::new::<AzGridPlacement>(), "AzGridPlacement"));
        assert_eq!((Layout::new::<azul_css::props::style::content::StringSet>(), "AzStringSet"), (Layout::new::<AzStringSet>(), "AzStringSet"));
        assert_eq!((Layout::new::<azul_css::props::layout::shape::ShapeOutside>(), "AzShapeOutside"), (Layout::new::<AzShapeOutside>(), "AzShapeOutside"));
        assert_eq!((Layout::new::<azul_layout::xml::svg::SvgVector>(), "AzSvgVector"), (Layout::new::<AzSvgVector>(), "AzSvgVector"));
        assert_eq!((Layout::new::<azul_css::system::DesktopEnvironment>(), "AzDesktopEnvironment"), (Layout::new::<AzDesktopEnvironment>(), "AzDesktopEnvironment"));
        assert_eq!((Layout::new::<azul_css::props::layout::column::ColumnCount>(), "AzColumnCount"), (Layout::new::<AzColumnCount>(), "AzColumnCount"));
        assert_eq!((Layout::new::<azul_css::props::layout::wrapping::LayoutWritingMode>(), "AzLayoutWritingMode"), (Layout::new::<AzLayoutWritingMode>(), "AzLayoutWritingMode"));
        assert_eq!((Layout::new::<azul_layout::xml::svg::SvgRect>(), "AzSvgRect"), (Layout::new::<AzSvgRect>(), "AzSvgRect"));
        assert_eq!((Layout::new::<azul_css::system::SystemColors>(), "AzSystemColors"), (Layout::new::<AzSystemColors>(), "AzSystemColors"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleUserSelect>(), "AzStyleUserSelect"), (Layout::new::<AzStyleUserSelect>(), "AzStyleUserSelect"));
        assert_eq!((Layout::new::<azul_css::props::layout::flow::FlowInto>(), "AzFlowInto"), (Layout::new::<AzFlowInto>(), "AzFlowInto"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::GridTemplate>(), "AzGridTemplate"), (Layout::new::<AzGridTemplate>(), "AzGridTemplate"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::LayoutJustifySelf>(), "AzLayoutJustifySelf"), (Layout::new::<AzLayoutJustifySelf>(), "AzLayoutJustifySelf"));
        assert_eq!((Layout::new::<azul_css::props::style::content::Content>(), "AzContent"), (Layout::new::<AzContent>(), "AzContent"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleHyphens>(), "AzStyleHyphens"), (Layout::new::<AzStyleHyphens>(), "AzStyleHyphens"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::LayoutGap>(), "AzLayoutGap"), (Layout::new::<AzLayoutGap>(), "AzLayoutGap"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleDirection>(), "AzStyleDirection"), (Layout::new::<AzStyleDirection>(), "AzStyleDirection"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutFlexBasis>(), "AzLayoutFlexBasis"), (Layout::new::<AzLayoutFlexBasis>(), "AzLayoutFlexBasis"));
        assert_eq!((Layout::new::<azul_css::props::layout::shape::ShapeMargin>(), "AzShapeMargin"), (Layout::new::<AzShapeMargin>(), "AzShapeMargin"));
        assert_eq!((Layout::new::<azul_css::props::layout::text::LayoutTextJustify>(), "AzLayoutTextJustify"), (Layout::new::<AzLayoutTextJustify>(), "AzLayoutTextJustify"));
        assert_eq!((Layout::new::<azul_css::props::layout::column::ColumnWidth>(), "AzColumnWidth"), (Layout::new::<AzColumnWidth>(), "AzColumnWidth"));
        assert_eq!((Layout::new::<azul_css::props::style::content::CounterIncrement>(), "AzCounterIncrement"), (Layout::new::<AzCounterIncrement>(), "AzCounterIncrement"));
        assert_eq!((Layout::new::<azul_css::props::layout::fragmentation::BoxDecorationBreak>(), "AzBoxDecorationBreak"), (Layout::new::<AzBoxDecorationBreak>(), "AzBoxDecorationBreak"));
        assert_eq!((Layout::new::<azul_layout::xml::svg::SvgCubicCurve>(), "AzSvgCubicCurve"), (Layout::new::<AzSvgCubicCurve>(), "AzSvgCubicCurve"));
        assert_eq!((Layout::new::<azul_layout::xml::svg::SvgQuadraticCurve>(), "AzSvgQuadraticCurve"), (Layout::new::<AzSvgQuadraticCurve>(), "AzSvgQuadraticCurve"));
        assert_eq!((Layout::new::<azul_css::props::style::selection::SelectionColor>(), "AzSelectionColor"), (Layout::new::<AzSelectionColor>(), "AzSelectionColor"));
        assert_eq!((Layout::new::<azul_css::props::style::effects::StyleVisibility>(), "AzStyleVisibility"), (Layout::new::<AzStyleVisibility>(), "AzStyleVisibility"));
        assert_eq!((Layout::new::<azul_css::system::Theme>(), "AzTheme"), (Layout::new::<AzTheme>(), "AzTheme"));
        assert_eq!((Layout::new::<azul_css::props::layout::shape::ShapeImageThreshold>(), "AzShapeImageThreshold"), (Layout::new::<AzShapeImageThreshold>(), "AzShapeImageThreshold"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::LayoutGridAutoFlow>(), "AzLayoutGridAutoFlow"), (Layout::new::<AzLayoutGridAutoFlow>(), "AzLayoutGridAutoFlow"));
        assert_eq!((Layout::new::<azul_css::props::layout::column::ColumnRuleWidth>(), "AzColumnRuleWidth"), (Layout::new::<AzColumnRuleWidth>(), "AzColumnRuleWidth"));
        assert_eq!((Layout::new::<azul_css::AzString>(), "AzAzString"), (Layout::new::<AzAzString>(), "AzAzString"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleTextDecoration>(), "AzStyleTextDecoration"), (Layout::new::<AzStyleTextDecoration>(), "AzStyleTextDecoration"));
        assert_eq!((Layout::new::<azul_css::props::style::text::CaretColor>(), "AzCaretColor"), (Layout::new::<AzCaretColor>(), "AzCaretColor"));
        assert_eq!((Layout::new::<azul_css::props::layout::column::ColumnFill>(), "AzColumnFill"), (Layout::new::<AzColumnFill>(), "AzColumnFill"));
        assert_eq!((Layout::new::<azul_css::system::SystemFonts>(), "AzSystemFonts"), (Layout::new::<AzSystemFonts>(), "AzSystemFonts"));
        assert_eq!((Layout::new::<azul_css::props::layout::flow::FlowFrom>(), "AzFlowFrom"), (Layout::new::<AzFlowFrom>(), "AzFlowFrom"));
        assert_eq!((Layout::new::<azul_css::props::layout::fragmentation::PageBreak>(), "AzPageBreak"), (Layout::new::<AzPageBreak>(), "AzPageBreak"));
        assert_eq!((Layout::new::<azul_css::props::style::scrollbar::LayoutScrollbarWidth>(), "AzLayoutScrollbarWidth"), (Layout::new::<AzLayoutScrollbarWidth>(), "AzLayoutScrollbarWidth"));
        assert_eq!((Layout::new::<azul_css::props::style::scrollbar::StyleScrollbarColor>(), "AzStyleScrollbarColor"), (Layout::new::<AzStyleScrollbarColor>(), "AzStyleScrollbarColor"));
        assert_eq!((Layout::new::<azul_dll::widgets::ribbon::Ribbon>(), "AzRibbon"), (Layout::new::<AzRibbon>(), "AzRibbon"));
        assert_eq!((Layout::new::<azul_dll::widgets::ribbon::RibbonOnTabClickedCallback>(), "AzRibbonOnTabClickedCallback"), (Layout::new::<AzRibbonOnTabClickedCallback>(), "AzRibbonOnTabClickedCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::ribbon::RibbonOnTabClickedCallbackType>(), "AzRibbonOnTabClickedCallbackType"), (Layout::new::<AzRibbonOnTabClickedCallbackType>(), "AzRibbonOnTabClickedCallbackType"));
        assert_eq!((Layout::new::<azul_dll::widgets::button::Button>(), "AzButton"), (Layout::new::<AzButton>(), "AzButton"));
        assert_eq!((Layout::new::<azul_dll::widgets::button::ButtonOnClick>(), "AzButtonOnClick"), (Layout::new::<AzButtonOnClick>(), "AzButtonOnClick"));
        assert_eq!((Layout::new::<azul_dll::widgets::file_input::FileInput>(), "AzFileInput"), (Layout::new::<AzFileInput>(), "AzFileInput"));
        assert_eq!((Layout::new::<azul_dll::widgets::file_input::FileInputStateWrapper>(), "AzFileInputStateWrapper"), (Layout::new::<AzFileInputStateWrapper>(), "AzFileInputStateWrapper"));
        assert_eq!((Layout::new::<azul_dll::widgets::file_input::FileInputState>(), "AzFileInputState"), (Layout::new::<AzFileInputState>(), "AzFileInputState"));
        assert_eq!((Layout::new::<azul_dll::widgets::file_input::FileInputOnPathChange>(), "AzFileInputOnPathChange"), (Layout::new::<AzFileInputOnPathChange>(), "AzFileInputOnPathChange"));
        assert_eq!((Layout::new::<azul_dll::widgets::file_input::FileInputOnPathChangeCallback>(), "AzFileInputOnPathChangeCallback"), (Layout::new::<AzFileInputOnPathChangeCallback>(), "AzFileInputOnPathChangeCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::file_input::FileInputOnPathChangeCallbackType>(), "AzFileInputOnPathChangeCallbackType"), (Layout::new::<AzFileInputOnPathChangeCallbackType>(), "AzFileInputOnPathChangeCallbackType"));
        assert_eq!((Layout::new::<azul_dll::widgets::check_box::CheckBox>(), "AzCheckBox"), (Layout::new::<AzCheckBox>(), "AzCheckBox"));
        assert_eq!((Layout::new::<azul_dll::widgets::check_box::CheckBoxStateWrapper>(), "AzCheckBoxStateWrapper"), (Layout::new::<AzCheckBoxStateWrapper>(), "AzCheckBoxStateWrapper"));
        assert_eq!((Layout::new::<azul_dll::widgets::check_box::CheckBoxOnToggle>(), "AzCheckBoxOnToggle"), (Layout::new::<AzCheckBoxOnToggle>(), "AzCheckBoxOnToggle"));
        assert_eq!((Layout::new::<azul_dll::widgets::check_box::CheckBoxOnToggleCallback>(), "AzCheckBoxOnToggleCallback"), (Layout::new::<AzCheckBoxOnToggleCallback>(), "AzCheckBoxOnToggleCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::check_box::CheckBoxOnToggleCallbackType>(), "AzCheckBoxOnToggleCallbackType"), (Layout::new::<AzCheckBoxOnToggleCallbackType>(), "AzCheckBoxOnToggleCallbackType"));
        assert_eq!((Layout::new::<azul_dll::widgets::check_box::CheckBoxState>(), "AzCheckBoxState"), (Layout::new::<AzCheckBoxState>(), "AzCheckBoxState"));
        assert_eq!((Layout::new::<azul_dll::widgets::label::Label>(), "AzLabel"), (Layout::new::<AzLabel>(), "AzLabel"));
        assert_eq!((Layout::new::<azul_dll::widgets::color_input::ColorInput>(), "AzColorInput"), (Layout::new::<AzColorInput>(), "AzColorInput"));
        assert_eq!((Layout::new::<azul_dll::widgets::color_input::ColorInputStateWrapper>(), "AzColorInputStateWrapper"), (Layout::new::<AzColorInputStateWrapper>(), "AzColorInputStateWrapper"));
        assert_eq!((Layout::new::<azul_dll::widgets::color_input::ColorInputState>(), "AzColorInputState"), (Layout::new::<AzColorInputState>(), "AzColorInputState"));
        assert_eq!((Layout::new::<azul_dll::widgets::color_input::ColorInputOnValueChange>(), "AzColorInputOnValueChange"), (Layout::new::<AzColorInputOnValueChange>(), "AzColorInputOnValueChange"));
        assert_eq!((Layout::new::<azul_dll::widgets::color_input::ColorInputOnValueChangeCallback>(), "AzColorInputOnValueChangeCallback"), (Layout::new::<AzColorInputOnValueChangeCallback>(), "AzColorInputOnValueChangeCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::color_input::ColorInputOnValueChangeCallbackType>(), "AzColorInputOnValueChangeCallbackType"), (Layout::new::<AzColorInputOnValueChangeCallbackType>(), "AzColorInputOnValueChangeCallbackType"));
        assert_eq!((Layout::new::<azul_dll::widgets::text_input::TextInput>(), "AzTextInput"), (Layout::new::<AzTextInput>(), "AzTextInput"));
        assert_eq!((Layout::new::<azul_dll::widgets::text_input::TextInputStateWrapper>(), "AzTextInputStateWrapper"), (Layout::new::<AzTextInputStateWrapper>(), "AzTextInputStateWrapper"));
        assert_eq!((Layout::new::<azul_dll::widgets::text_input::TextInputState>(), "AzTextInputState"), (Layout::new::<AzTextInputState>(), "AzTextInputState"));
        assert_eq!((Layout::new::<azul_dll::widgets::text_input::TextInputSelection>(), "AzTextInputSelection"), (Layout::new::<AzTextInputSelection>(), "AzTextInputSelection"));
        assert_eq!((Layout::new::<azul_dll::widgets::text_input::TextInputSelectionRange>(), "AzTextInputSelectionRange"), (Layout::new::<AzTextInputSelectionRange>(), "AzTextInputSelectionRange"));
        assert_eq!((Layout::new::<azul_dll::widgets::text_input::TextInputOnTextInput>(), "AzTextInputOnTextInput"), (Layout::new::<AzTextInputOnTextInput>(), "AzTextInputOnTextInput"));
        assert_eq!((Layout::new::<azul_dll::widgets::text_input::TextInputOnTextInputCallback>(), "AzTextInputOnTextInputCallback"), (Layout::new::<AzTextInputOnTextInputCallback>(), "AzTextInputOnTextInputCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::text_input::TextInputOnTextInputCallbackType>(), "AzTextInputOnTextInputCallbackType"), (Layout::new::<AzTextInputOnTextInputCallbackType>(), "AzTextInputOnTextInputCallbackType"));
        assert_eq!((Layout::new::<azul_dll::widgets::text_input::TextInputOnVirtualKeyDown>(), "AzTextInputOnVirtualKeyDown"), (Layout::new::<AzTextInputOnVirtualKeyDown>(), "AzTextInputOnVirtualKeyDown"));
        assert_eq!((Layout::new::<azul_dll::widgets::text_input::TextInputOnVirtualKeyDownCallback>(), "AzTextInputOnVirtualKeyDownCallback"), (Layout::new::<AzTextInputOnVirtualKeyDownCallback>(), "AzTextInputOnVirtualKeyDownCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::text_input::TextInputOnVirtualKeyDownCallbackType>(), "AzTextInputOnVirtualKeyDownCallbackType"), (Layout::new::<AzTextInputOnVirtualKeyDownCallbackType>(), "AzTextInputOnVirtualKeyDownCallbackType"));
        assert_eq!((Layout::new::<azul_dll::widgets::text_input::TextInputOnFocusLost>(), "AzTextInputOnFocusLost"), (Layout::new::<AzTextInputOnFocusLost>(), "AzTextInputOnFocusLost"));
        assert_eq!((Layout::new::<azul_dll::widgets::text_input::TextInputOnFocusLostCallback>(), "AzTextInputOnFocusLostCallback"), (Layout::new::<AzTextInputOnFocusLostCallback>(), "AzTextInputOnFocusLostCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::text_input::TextInputOnFocusLostCallbackType>(), "AzTextInputOnFocusLostCallbackType"), (Layout::new::<AzTextInputOnFocusLostCallbackType>(), "AzTextInputOnFocusLostCallbackType"));
        assert_eq!((Layout::new::<azul_dll::widgets::text_input::OnTextInputReturn>(), "AzOnTextInputReturn"), (Layout::new::<AzOnTextInputReturn>(), "AzOnTextInputReturn"));
        assert_eq!((Layout::new::<azul_dll::widgets::text_input::TextInputValid>(), "AzTextInputValid"), (Layout::new::<AzTextInputValid>(), "AzTextInputValid"));
        assert_eq!((Layout::new::<azul_dll::widgets::number_input::NumberInput>(), "AzNumberInput"), (Layout::new::<AzNumberInput>(), "AzNumberInput"));
        assert_eq!((Layout::new::<azul_dll::widgets::number_input::NumberInputStateWrapper>(), "AzNumberInputStateWrapper"), (Layout::new::<AzNumberInputStateWrapper>(), "AzNumberInputStateWrapper"));
        assert_eq!((Layout::new::<azul_dll::widgets::number_input::NumberInputState>(), "AzNumberInputState"), (Layout::new::<AzNumberInputState>(), "AzNumberInputState"));
        assert_eq!((Layout::new::<azul_dll::widgets::number_input::NumberInputOnValueChange>(), "AzNumberInputOnValueChange"), (Layout::new::<AzNumberInputOnValueChange>(), "AzNumberInputOnValueChange"));
        assert_eq!((Layout::new::<azul_dll::widgets::number_input::NumberInputOnValueChangeCallback>(), "AzNumberInputOnValueChangeCallback"), (Layout::new::<AzNumberInputOnValueChangeCallback>(), "AzNumberInputOnValueChangeCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::number_input::NumberInputOnValueChangeCallbackType>(), "AzNumberInputOnValueChangeCallbackType"), (Layout::new::<AzNumberInputOnValueChangeCallbackType>(), "AzNumberInputOnValueChangeCallbackType"));
        assert_eq!((Layout::new::<azul_dll::widgets::number_input::NumberInputOnFocusLost>(), "AzNumberInputOnFocusLost"), (Layout::new::<AzNumberInputOnFocusLost>(), "AzNumberInputOnFocusLost"));
        assert_eq!((Layout::new::<azul_dll::widgets::number_input::NumberInputOnFocusLostCallback>(), "AzNumberInputOnFocusLostCallback"), (Layout::new::<AzNumberInputOnFocusLostCallback>(), "AzNumberInputOnFocusLostCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::number_input::NumberInputOnFocusLostCallbackType>(), "AzNumberInputOnFocusLostCallbackType"), (Layout::new::<AzNumberInputOnFocusLostCallbackType>(), "AzNumberInputOnFocusLostCallbackType"));
        assert_eq!((Layout::new::<azul_dll::widgets::progressbar::ProgressBar>(), "AzProgressBar"), (Layout::new::<AzProgressBar>(), "AzProgressBar"));
        assert_eq!((Layout::new::<azul_dll::widgets::progressbar::ProgressBarState>(), "AzProgressBarState"), (Layout::new::<AzProgressBarState>(), "AzProgressBarState"));
        assert_eq!((Layout::new::<azul_dll::widgets::tabs::TabHeader>(), "AzTabHeader"), (Layout::new::<AzTabHeader>(), "AzTabHeader"));
        assert_eq!((Layout::new::<azul_dll::widgets::tabs::TabHeaderState>(), "AzTabHeaderState"), (Layout::new::<AzTabHeaderState>(), "AzTabHeaderState"));
        assert_eq!((Layout::new::<azul_dll::widgets::tabs::TabContent>(), "AzTabContent"), (Layout::new::<AzTabContent>(), "AzTabContent"));
        assert_eq!((Layout::new::<azul_dll::widgets::tabs::TabOnClick>(), "AzTabOnClick"), (Layout::new::<AzTabOnClick>(), "AzTabOnClick"));
        assert_eq!((Layout::new::<azul_dll::widgets::tabs::TabOnClickCallback>(), "AzTabOnClickCallback"), (Layout::new::<AzTabOnClickCallback>(), "AzTabOnClickCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::tabs::TabOnClickCallbackType>(), "AzTabOnClickCallbackType"), (Layout::new::<AzTabOnClickCallbackType>(), "AzTabOnClickCallbackType"));
        assert_eq!((Layout::new::<crate::widgets::frame::Frame>(), "AzFrame"), (Layout::new::<AzFrame>(), "AzFrame"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::NodeGraph>(), "AzNodeGraph"), (Layout::new::<AzNodeGraph>(), "AzNodeGraph"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::NodeTypeIdInfoMap>(), "AzNodeTypeIdInfoMap"), (Layout::new::<AzNodeTypeIdInfoMap>(), "AzNodeTypeIdInfoMap"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::InputOutputTypeIdInfoMap>(), "AzInputOutputTypeIdInfoMap"), (Layout::new::<AzInputOutputTypeIdInfoMap>(), "AzInputOutputTypeIdInfoMap"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::NodeIdNodeMap>(), "AzNodeIdNodeMap"), (Layout::new::<AzNodeIdNodeMap>(), "AzNodeIdNodeMap"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::NodeGraphStyle>(), "AzNodeGraphStyle"), (Layout::new::<AzNodeGraphStyle>(), "AzNodeGraphStyle"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::NodeGraphCallbacks>(), "AzNodeGraphCallbacks"), (Layout::new::<AzNodeGraphCallbacks>(), "AzNodeGraphCallbacks"));
        assert_eq!((Layout::new::<azul_dll::widgets::drop_down::DropDownOnChoiceChange>(), "AzDropDownOnChoiceChange"), (Layout::new::<AzDropDownOnChoiceChange>(), "AzDropDownOnChoiceChange"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OnNodeAddedCallback>(), "AzOnNodeAddedCallback"), (Layout::new::<AzOnNodeAddedCallback>(), "AzOnNodeAddedCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OnNodeAdded>(), "AzOnNodeAdded"), (Layout::new::<AzOnNodeAdded>(), "AzOnNodeAdded"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OnNodeRemovedCallback>(), "AzOnNodeRemovedCallback"), (Layout::new::<AzOnNodeRemovedCallback>(), "AzOnNodeRemovedCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OnNodeRemoved>(), "AzOnNodeRemoved"), (Layout::new::<AzOnNodeRemoved>(), "AzOnNodeRemoved"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OnNodeGraphDraggedCallback>(), "AzOnNodeGraphDraggedCallback"), (Layout::new::<AzOnNodeGraphDraggedCallback>(), "AzOnNodeGraphDraggedCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OnNodeGraphDragged>(), "AzOnNodeGraphDragged"), (Layout::new::<AzOnNodeGraphDragged>(), "AzOnNodeGraphDragged"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OnNodeDraggedCallback>(), "AzOnNodeDraggedCallback"), (Layout::new::<AzOnNodeDraggedCallback>(), "AzOnNodeDraggedCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OnNodeDragged>(), "AzOnNodeDragged"), (Layout::new::<AzOnNodeDragged>(), "AzOnNodeDragged"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OnNodeConnectedCallback>(), "AzOnNodeConnectedCallback"), (Layout::new::<AzOnNodeConnectedCallback>(), "AzOnNodeConnectedCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OnNodeConnected>(), "AzOnNodeConnected"), (Layout::new::<AzOnNodeConnected>(), "AzOnNodeConnected"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OnNodeInputDisconnectedCallback>(), "AzOnNodeInputDisconnectedCallback"), (Layout::new::<AzOnNodeInputDisconnectedCallback>(), "AzOnNodeInputDisconnectedCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OnNodeInputDisconnected>(), "AzOnNodeInputDisconnected"), (Layout::new::<AzOnNodeInputDisconnected>(), "AzOnNodeInputDisconnected"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OnNodeOutputDisconnectedCallback>(), "AzOnNodeOutputDisconnectedCallback"), (Layout::new::<AzOnNodeOutputDisconnectedCallback>(), "AzOnNodeOutputDisconnectedCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OnNodeOutputDisconnected>(), "AzOnNodeOutputDisconnected"), (Layout::new::<AzOnNodeOutputDisconnected>(), "AzOnNodeOutputDisconnected"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OnNodeFieldEditedCallback>(), "AzOnNodeFieldEditedCallback"), (Layout::new::<AzOnNodeFieldEditedCallback>(), "AzOnNodeFieldEditedCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::InputOutputTypeId>(), "AzInputOutputTypeId"), (Layout::new::<AzInputOutputTypeId>(), "AzInputOutputTypeId"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::NodeTypeId>(), "AzNodeTypeId"), (Layout::new::<AzNodeTypeId>(), "AzNodeTypeId"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::NodeGraphNodeId>(), "AzNodeGraphNodeId"), (Layout::new::<AzNodeGraphNodeId>(), "AzNodeGraphNodeId"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::Node>(), "AzNode"), (Layout::new::<AzNode>(), "AzNode"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::NodeTypeField>(), "AzNodeTypeField"), (Layout::new::<AzNodeTypeField>(), "AzNodeTypeField"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::NodeTypeFieldValue>(), "AzNodeTypeFieldValue"), (Layout::new::<AzNodeTypeFieldValue>(), "AzNodeTypeFieldValue"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::InputConnection>(), "AzInputConnection"), (Layout::new::<AzInputConnection>(), "AzInputConnection"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OutputNodeAndIndex>(), "AzOutputNodeAndIndex"), (Layout::new::<AzOutputNodeAndIndex>(), "AzOutputNodeAndIndex"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OutputConnection>(), "AzOutputConnection"), (Layout::new::<AzOutputConnection>(), "AzOutputConnection"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::InputNodeAndIndex>(), "AzInputNodeAndIndex"), (Layout::new::<AzInputNodeAndIndex>(), "AzInputNodeAndIndex"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::NodeTypeInfo>(), "AzNodeTypeInfo"), (Layout::new::<AzNodeTypeInfo>(), "AzNodeTypeInfo"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::InputOutputInfo>(), "AzInputOutputInfo"), (Layout::new::<AzInputOutputInfo>(), "AzInputOutputInfo"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::NodePosition>(), "AzNodePosition"), (Layout::new::<AzNodePosition>(), "AzNodePosition"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::GraphDragAmount>(), "AzGraphDragAmount"), (Layout::new::<AzGraphDragAmount>(), "AzGraphDragAmount"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::NodeDragAmount>(), "AzNodeDragAmount"), (Layout::new::<AzNodeDragAmount>(), "AzNodeDragAmount"));
        assert_eq!((Layout::new::<azul_dll::widgets::list_view::ListView>(), "AzListView"), (Layout::new::<AzListView>(), "AzListView"));
        assert_eq!((Layout::new::<azul_dll::widgets::list_view::ListViewRow>(), "AzListViewRow"), (Layout::new::<AzListViewRow>(), "AzListViewRow"));
        assert_eq!((Layout::new::<azul_dll::widgets::list_view::ListViewState>(), "AzListViewState"), (Layout::new::<AzListViewState>(), "AzListViewState"));
        assert_eq!((Layout::new::<azul_dll::widgets::list_view::ListViewOnLazyLoadScrollCallbackType>(), "AzListViewOnLazyLoadScrollCallbackType"), (Layout::new::<AzListViewOnLazyLoadScrollCallbackType>(), "AzListViewOnLazyLoadScrollCallbackType"));
        assert_eq!((Layout::new::<azul_dll::widgets::list_view::ListViewOnLazyLoadScrollCallback>(), "AzListViewOnLazyLoadScrollCallback"), (Layout::new::<AzListViewOnLazyLoadScrollCallback>(), "AzListViewOnLazyLoadScrollCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::list_view::ListViewOnLazyLoadScroll>(), "AzListViewOnLazyLoadScroll"), (Layout::new::<AzListViewOnLazyLoadScroll>(), "AzListViewOnLazyLoadScroll"));
        assert_eq!((Layout::new::<azul_dll::widgets::list_view::ListViewOnColumnClickCallbackType>(), "AzListViewOnColumnClickCallbackType"), (Layout::new::<AzListViewOnColumnClickCallbackType>(), "AzListViewOnColumnClickCallbackType"));
        assert_eq!((Layout::new::<azul_dll::widgets::list_view::ListViewOnColumnClickCallback>(), "AzListViewOnColumnClickCallback"), (Layout::new::<AzListViewOnColumnClickCallback>(), "AzListViewOnColumnClickCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::list_view::ListViewOnColumnClick>(), "AzListViewOnColumnClick"), (Layout::new::<AzListViewOnColumnClick>(), "AzListViewOnColumnClick"));
        assert_eq!((Layout::new::<azul_dll::widgets::list_view::ListViewOnRowClickCallbackType>(), "AzListViewOnRowClickCallbackType"), (Layout::new::<AzListViewOnRowClickCallbackType>(), "AzListViewOnRowClickCallbackType"));
        assert_eq!((Layout::new::<azul_dll::widgets::list_view::ListViewOnRowClickCallback>(), "AzListViewOnRowClickCallback"), (Layout::new::<AzListViewOnRowClickCallback>(), "AzListViewOnRowClickCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::list_view::ListViewOnRowClick>(), "AzListViewOnRowClick"), (Layout::new::<AzListViewOnRowClick>(), "AzListViewOnRowClick"));
        assert_eq!((Layout::new::<azul_dll::widgets::tree_view::TreeView>(), "AzTreeView"), (Layout::new::<AzTreeView>(), "AzTreeView"));
        assert_eq!((Layout::new::<azul_dll::widgets::drop_down::DropDown>(), "AzDropDown"), (Layout::new::<AzDropDown>(), "AzDropDown"));
        assert_eq!((Layout::new::<azul_dll::widgets::drop_down::DropDownOnChoiceChangeCallbackType>(), "AzDropDownOnChoiceChangeCallbackType"), (Layout::new::<AzDropDownOnChoiceChangeCallbackType>(), "AzDropDownOnChoiceChangeCallbackType"));
        assert_eq!((Layout::new::<azul_dll::widgets::drop_down::DropDownOnChoiceChangeCallback>(), "AzDropDownOnChoiceChangeCallback"), (Layout::new::<AzDropDownOnChoiceChangeCallback>(), "AzDropDownOnChoiceChangeCallback"));
        assert_eq!((Layout::new::<azul_dll::widgets::node_graph::OnNodeFieldEdited>(), "AzOnNodeFieldEdited"), (Layout::new::<AzOnNodeFieldEdited>(), "AzOnNodeFieldEdited"));
        assert_eq!((Layout::new::<azul_core::styled_dom::NodeHierarchyItem>(), "AzNodeHierarchyItem"), (Layout::new::<AzNodeHierarchyItem>(), "AzNodeHierarchyItem"));
        assert_eq!((Layout::new::<azul_core::style::CascadeInfo>(), "AzCascadeInfo"), (Layout::new::<AzCascadeInfo>(), "AzCascadeInfo"));
        assert_eq!((Layout::new::<azul_core::styled_dom::CssPropertySource>(), "AzCssPropertySource"), (Layout::new::<AzCssPropertySource>(), "AzCssPropertySource"));
        assert_eq!((Layout::new::<azul_core::styled_dom::StyledNodeState>(), "AzStyledNodeState"), (Layout::new::<AzStyledNodeState>(), "AzStyledNodeState"));
        assert_eq!((Layout::new::<azul_core::styled_dom::StyledNode>(), "AzStyledNode"), (Layout::new::<AzStyledNode>(), "AzStyledNode"));
        assert_eq!((Layout::new::<azul_core::styled_dom::StyledDom>(), "AzStyledDom"), (Layout::new::<AzStyledDom>(), "AzStyledDom"));
        assert_eq!((Layout::new::<azul_core::styled_dom::TagIdToNodeIdMapping>(), "AzTagIdToNodeIdMapping"), (Layout::new::<AzTagIdToNodeIdMapping>(), "AzTagIdToNodeIdMapping"));
        assert_eq!((Layout::new::<azul_core::styled_dom::ParentWithNodeDepth>(), "AzParentWithNodeDepth"), (Layout::new::<AzParentWithNodeDepth>(), "AzParentWithNodeDepth"));
        assert_eq!((Layout::new::<azul_core::styled_dom::AzTagId>(), "AzAzTagId"), (Layout::new::<AzAzTagId>(), "AzAzTagId"));
        assert_eq!((Layout::new::<azul_core::styled_dom::CssPropertyCachePtr>(), "AzCssPropertyCachePtr"), (Layout::new::<AzCssPropertyCachePtr>(), "AzCssPropertyCachePtr"));
        assert_eq!((Layout::new::<azul_core::gl::Texture>(), "AzTexture"), (Layout::new::<AzTexture>(), "AzTexture"));
        assert_eq!((Layout::new::<azul_core::gl::GlVoidPtrConst>(), "AzGlVoidPtrConst"), (Layout::new::<AzGlVoidPtrConst>(), "AzGlVoidPtrConst"));
        assert_eq!((Layout::new::<azul_core::gl::GlVoidPtrMut>(), "AzGlVoidPtrMut"), (Layout::new::<AzGlVoidPtrMut>(), "AzGlVoidPtrMut"));
        assert_eq!((Layout::new::<azul_core::gl::TextureFlags>(), "AzTextureFlags"), (Layout::new::<AzTextureFlags>(), "AzTextureFlags"));
        assert_eq!((Layout::new::<azul_core::gl::GlShaderPrecisionFormatReturn>(), "AzGlShaderPrecisionFormatReturn"), (Layout::new::<AzGlShaderPrecisionFormatReturn>(), "AzGlShaderPrecisionFormatReturn"));
        assert_eq!((Layout::new::<azul_core::gl::VertexAttributeType>(), "AzVertexAttributeType"), (Layout::new::<AzVertexAttributeType>(), "AzVertexAttributeType"));
        assert_eq!((Layout::new::<azul_core::gl::VertexAttribute>(), "AzVertexAttribute"), (Layout::new::<AzVertexAttribute>(), "AzVertexAttribute"));
        assert_eq!((Layout::new::<azul_core::gl::VertexLayout>(), "AzVertexLayout"), (Layout::new::<AzVertexLayout>(), "AzVertexLayout"));
        assert_eq!((Layout::new::<azul_core::gl::VertexArrayObject>(), "AzVertexArrayObject"), (Layout::new::<AzVertexArrayObject>(), "AzVertexArrayObject"));
        assert_eq!((Layout::new::<azul_core::gl::IndexBufferFormat>(), "AzIndexBufferFormat"), (Layout::new::<AzIndexBufferFormat>(), "AzIndexBufferFormat"));
        assert_eq!((Layout::new::<azul_core::gl::VertexBuffer>(), "AzVertexBuffer"), (Layout::new::<AzVertexBuffer>(), "AzVertexBuffer"));
        assert_eq!((Layout::new::<azul_core::gl::GlContextPtr>(), "AzGlContextPtr"), (Layout::new::<AzGlContextPtr>(), "AzGlContextPtr"));
        assert_eq!((Layout::new::<azul_core::gl::AzGlType>(), "AzAzGlType"), (Layout::new::<AzAzGlType>(), "AzAzGlType"));
        assert_eq!((Layout::new::<azul_core::gl::U8VecRef>(), "AzU8VecRef"), (Layout::new::<AzU8VecRef>(), "AzU8VecRef"));
        assert_eq!((Layout::new::<azul_core::gl::U8VecRefMut>(), "AzU8VecRefMut"), (Layout::new::<AzU8VecRefMut>(), "AzU8VecRefMut"));
        assert_eq!((Layout::new::<azul_core::gl::F32VecRef>(), "AzF32VecRef"), (Layout::new::<AzF32VecRef>(), "AzF32VecRef"));
        assert_eq!((Layout::new::<azul_core::gl::I32VecRef>(), "AzI32VecRef"), (Layout::new::<AzI32VecRef>(), "AzI32VecRef"));
        assert_eq!((Layout::new::<azul_core::gl::GLuintVecRef>(), "AzGLuintVecRef"), (Layout::new::<AzGLuintVecRef>(), "AzGLuintVecRef"));
        assert_eq!((Layout::new::<azul_core::gl::GLenumVecRef>(), "AzGLenumVecRef"), (Layout::new::<AzGLenumVecRef>(), "AzGLenumVecRef"));
        assert_eq!((Layout::new::<azul_core::gl::GLintVecRefMut>(), "AzGLintVecRefMut"), (Layout::new::<AzGLintVecRefMut>(), "AzGLintVecRefMut"));
        assert_eq!((Layout::new::<azul_core::gl::GLint64VecRefMut>(), "AzGLint64VecRefMut"), (Layout::new::<AzGLint64VecRefMut>(), "AzGLint64VecRefMut"));
        assert_eq!((Layout::new::<azul_core::gl::GLbooleanVecRefMut>(), "AzGLbooleanVecRefMut"), (Layout::new::<AzGLbooleanVecRefMut>(), "AzGLbooleanVecRefMut"));
        assert_eq!((Layout::new::<azul_core::gl::GLfloatVecRefMut>(), "AzGLfloatVecRefMut"), (Layout::new::<AzGLfloatVecRefMut>(), "AzGLfloatVecRefMut"));
        assert_eq!((Layout::new::<azul_core::gl::RefstrVecRef>(), "AzRefstrVecRef"), (Layout::new::<AzRefstrVecRef>(), "AzRefstrVecRef"));
        assert_eq!((Layout::new::<azul_core::gl::Refstr>(), "AzRefstr"), (Layout::new::<AzRefstr>(), "AzRefstr"));
        assert_eq!((Layout::new::<azul_core::gl::GetProgramBinaryReturn>(), "AzGetProgramBinaryReturn"), (Layout::new::<AzGetProgramBinaryReturn>(), "AzGetProgramBinaryReturn"));
        assert_eq!((Layout::new::<azul_core::gl::GetActiveAttribReturn>(), "AzGetActiveAttribReturn"), (Layout::new::<AzGetActiveAttribReturn>(), "AzGetActiveAttribReturn"));
        assert_eq!((Layout::new::<azul_core::gl::GLsyncPtr>(), "AzGLsyncPtr"), (Layout::new::<AzGLsyncPtr>(), "AzGLsyncPtr"));
        assert_eq!((Layout::new::<azul_core::gl::GetActiveUniformReturn>(), "AzGetActiveUniformReturn"), (Layout::new::<AzGetActiveUniformReturn>(), "AzGetActiveUniformReturn"));
        assert_eq!((Layout::new::<azul_core::gl::AzDebugMessage>(), "AzAzDebugMessage"), (Layout::new::<AzAzDebugMessage>(), "AzAzDebugMessage"));
        assert_eq!((Layout::new::<azul_core::resources::ImageRef>(), "AzImageRef"), (Layout::new::<AzImageRef>(), "AzImageRef"));
        assert_eq!((Layout::new::<azul_core::resources::RawImage>(), "AzRawImage"), (Layout::new::<AzRawImage>(), "AzRawImage"));
        assert_eq!((Layout::new::<azul_core::resources::ImageMask>(), "AzImageMask"), (Layout::new::<AzImageMask>(), "AzImageMask"));
        assert_eq!((Layout::new::<azul_core::resources::RawImageFormat>(), "AzRawImageFormat"), (Layout::new::<AzRawImageFormat>(), "AzRawImageFormat"));
        assert_eq!((Layout::new::<azul_layout::image::encode::EncodeImageError>(), "AzEncodeImageError"), (Layout::new::<AzEncodeImageError>(), "AzEncodeImageError"));
        assert_eq!((Layout::new::<azul_layout::image::decode::DecodeImageError>(), "AzDecodeImageError"), (Layout::new::<AzDecodeImageError>(), "AzDecodeImageError"));
        assert_eq!((Layout::new::<azul_core::resources::RawImageData>(), "AzRawImageData"), (Layout::new::<AzRawImageData>(), "AzRawImageData"));
        assert_eq!((Layout::new::<azul_core::resources::LoadedFontSource>(), "AzLoadedFontSource"), (Layout::new::<AzLoadedFontSource>(), "AzLoadedFontSource"));
        assert_eq!((Layout::new::<azul_layout::xml::svg::Svg>(), "AzSvg"), (Layout::new::<AzSvg>(), "AzSvg"));
        assert_eq!((Layout::new::<azul_layout::xml::svg::SvgXmlNode>(), "AzSvgXmlNode"), (Layout::new::<AzSvgXmlNode>(), "AzSvgXmlNode"));
        assert_eq!((Layout::new::<azul_core::svg::SvgMultiPolygon>(), "AzSvgMultiPolygon"), (Layout::new::<AzSvgMultiPolygon>(), "AzSvgMultiPolygon"));
        assert_eq!((Layout::new::<azul_core::svg::SvgNode>(), "AzSvgNode"), (Layout::new::<AzSvgNode>(), "AzSvgNode"));
        assert_eq!((Layout::new::<azul_core::svg::SvgSimpleNode>(), "AzSvgSimpleNode"), (Layout::new::<AzSvgSimpleNode>(), "AzSvgSimpleNode"));
        assert_eq!((Layout::new::<azul_core::svg::SvgStyledNode>(), "AzSvgStyledNode"), (Layout::new::<AzSvgStyledNode>(), "AzSvgStyledNode"));
        assert_eq!((Layout::new::<azul_core::svg::SvgCircle>(), "AzSvgCircle"), (Layout::new::<AzSvgCircle>(), "AzSvgCircle"));
        assert_eq!((Layout::new::<azul_core::svg::SvgPath>(), "AzSvgPath"), (Layout::new::<AzSvgPath>(), "AzSvgPath"));
        assert_eq!((Layout::new::<azul_core::svg::SvgPathElement>(), "AzSvgPathElement"), (Layout::new::<AzSvgPathElement>(), "AzSvgPathElement"));
        assert_eq!((Layout::new::<azul_core::svg::SvgLine>(), "AzSvgLine"), (Layout::new::<AzSvgLine>(), "AzSvgLine"));
        assert_eq!((Layout::new::<azul_core::svg::SvgColoredVertex>(), "AzSvgColoredVertex"), (Layout::new::<AzSvgColoredVertex>(), "AzSvgColoredVertex"));
        assert_eq!((Layout::new::<azul_core::svg::TessellatedColoredSvgNode>(), "AzTessellatedColoredSvgNode"), (Layout::new::<AzTessellatedColoredSvgNode>(), "AzTessellatedColoredSvgNode"));
        assert_eq!((Layout::new::<azul_core::svg::TessellatedColoredSvgNodeVecRef>(), "AzTessellatedColoredSvgNodeVecRef"), (Layout::new::<AzTessellatedColoredSvgNodeVecRef>(), "AzTessellatedColoredSvgNodeVecRef"));
        assert_eq!((Layout::new::<azul_core::svg::TessellatedColoredGPUSvgNode>(), "AzTessellatedColoredGPUSvgNode"), (Layout::new::<AzTessellatedColoredGPUSvgNode>(), "AzTessellatedColoredGPUSvgNode"));
        assert_eq!((Layout::new::<azul_core::svg::SvgVertex>(), "AzSvgVertex"), (Layout::new::<AzSvgVertex>(), "AzSvgVertex"));
        assert_eq!((Layout::new::<azul_core::svg::TessellatedSvgNode>(), "AzTessellatedSvgNode"), (Layout::new::<AzTessellatedSvgNode>(), "AzTessellatedSvgNode"));
        assert_eq!((Layout::new::<azul_core::svg::TessellatedSvgNodeVecRef>(), "AzTessellatedSvgNodeVecRef"), (Layout::new::<AzTessellatedSvgNodeVecRef>(), "AzTessellatedSvgNodeVecRef"));
        assert_eq!((Layout::new::<azul_core::svg::TessellatedGPUSvgNode>(), "AzTessellatedGPUSvgNode"), (Layout::new::<AzTessellatedGPUSvgNode>(), "AzTessellatedGPUSvgNode"));
        assert_eq!((Layout::new::<azul_core::svg::SvgParseOptions>(), "AzSvgParseOptions"), (Layout::new::<AzSvgParseOptions>(), "AzSvgParseOptions"));
        assert_eq!((Layout::new::<azul_core::svg::ShapeRendering>(), "AzShapeRendering"), (Layout::new::<AzShapeRendering>(), "AzShapeRendering"));
        assert_eq!((Layout::new::<azul_core::svg::TextRendering>(), "AzTextRendering"), (Layout::new::<AzTextRendering>(), "AzTextRendering"));
        assert_eq!((Layout::new::<azul_core::svg::ImageRendering>(), "AzImageRendering"), (Layout::new::<AzImageRendering>(), "AzImageRendering"));
        assert_eq!((Layout::new::<azul_core::svg::FontDatabase>(), "AzFontDatabase"), (Layout::new::<AzFontDatabase>(), "AzFontDatabase"));
        assert_eq!((Layout::new::<azul_core::svg::SvgRenderOptions>(), "AzSvgRenderOptions"), (Layout::new::<AzSvgRenderOptions>(), "AzSvgRenderOptions"));
        assert_eq!((Layout::new::<azul_core::svg::SvgRenderTransform>(), "AzSvgRenderTransform"), (Layout::new::<AzSvgRenderTransform>(), "AzSvgRenderTransform"));
        assert_eq!((Layout::new::<azul_core::svg::SvgDashPattern>(), "AzSvgDashPattern"), (Layout::new::<AzSvgDashPattern>(), "AzSvgDashPattern"));
        assert_eq!((Layout::new::<azul_core::svg::Indent>(), "AzIndent"), (Layout::new::<AzIndent>(), "AzIndent"));
        assert_eq!((Layout::new::<azul_core::svg::SvgFitTo>(), "AzSvgFitTo"), (Layout::new::<AzSvgFitTo>(), "AzSvgFitTo"));
        assert_eq!((Layout::new::<azul_core::svg::SvgStyle>(), "AzSvgStyle"), (Layout::new::<AzSvgStyle>(), "AzSvgStyle"));
        assert_eq!((Layout::new::<azul_core::svg::SvgFillRule>(), "AzSvgFillRule"), (Layout::new::<AzSvgFillRule>(), "AzSvgFillRule"));
        assert_eq!((Layout::new::<azul_core::svg::SvgTransform>(), "AzSvgTransform"), (Layout::new::<AzSvgTransform>(), "AzSvgTransform"));
        assert_eq!((Layout::new::<azul_core::svg::SvgFillStyle>(), "AzSvgFillStyle"), (Layout::new::<AzSvgFillStyle>(), "AzSvgFillStyle"));
        assert_eq!((Layout::new::<azul_core::svg::SvgStrokeStyle>(), "AzSvgStrokeStyle"), (Layout::new::<AzSvgStrokeStyle>(), "AzSvgStrokeStyle"));
        assert_eq!((Layout::new::<azul_core::svg::SvgLineJoin>(), "AzSvgLineJoin"), (Layout::new::<AzSvgLineJoin>(), "AzSvgLineJoin"));
        assert_eq!((Layout::new::<azul_core::svg::SvgLineCap>(), "AzSvgLineCap"), (Layout::new::<AzSvgLineCap>(), "AzSvgLineCap"));
        assert_eq!((Layout::new::<azul_core::svg::SvgXmlOptions>(), "AzSvgXmlOptions"), (Layout::new::<AzSvgXmlOptions>(), "AzSvgXmlOptions"));
        assert_eq!((Layout::new::<azul_layout::xml::svg::SvgParseError>(), "AzSvgParseError"), (Layout::new::<AzSvgParseError>(), "AzSvgParseError"));
        assert_eq!((Layout::new::<azul_core::xml::Xml>(), "AzXml"), (Layout::new::<AzXml>(), "AzXml"));
        assert_eq!((Layout::new::<azul_core::xml::XmlNode>(), "AzXmlNode"), (Layout::new::<AzXmlNode>(), "AzXmlNode"));
        assert_eq!((Layout::new::<crate::azul_impl::file::File>(), "AzFile"), (Layout::new::<AzFile>(), "AzFile"));
        assert_eq!((Layout::new::<crate::azul_impl::dialogs::MsgBox>(), "AzMsgBox"), (Layout::new::<AzMsgBox>(), "AzMsgBox"));
        assert_eq!((Layout::new::<crate::azul_impl::dialogs::MsgBoxIcon>(), "AzMsgBoxIcon"), (Layout::new::<AzMsgBoxIcon>(), "AzMsgBoxIcon"));
        assert_eq!((Layout::new::<crate::azul_impl::dialogs::ColorPickerDialog>(), "AzColorPickerDialog"), (Layout::new::<AzColorPickerDialog>(), "AzColorPickerDialog"));
        assert_eq!((Layout::new::<crate::azul_impl::dialogs::YesNo>(), "AzYesNo"), (Layout::new::<AzYesNo>(), "AzYesNo"));
        assert_eq!((Layout::new::<crate::azul_impl::dialogs::FileDialog>(), "AzFileDialog"), (Layout::new::<AzFileDialog>(), "AzFileDialog"));
        assert_eq!((Layout::new::<crate::azul_impl::dialogs::FileTypeList>(), "AzFileTypeList"), (Layout::new::<AzFileTypeList>(), "AzFileTypeList"));
        assert_eq!((Layout::new::<crate::azul_impl::dialogs::OkCancel>(), "AzOkCancel"), (Layout::new::<AzOkCancel>(), "AzOkCancel"));
        assert_eq!((Layout::new::<azul_core::task::Instant>(), "AzInstant"), (Layout::new::<AzInstant>(), "AzInstant"));
        assert_eq!((Layout::new::<azul_core::task::SystemTickDiff>(), "AzSystemTickDiff"), (Layout::new::<AzSystemTickDiff>(), "AzSystemTickDiff"));
        assert_eq!((Layout::new::<azul_core::task::AzInstantPtr>(), "AzAzInstantPtr"), (Layout::new::<AzAzInstantPtr>(), "AzAzInstantPtr"));
        assert_eq!((Layout::new::<azul_core::task::InstantPtrCloneCallback>(), "AzInstantPtrCloneCallback"), (Layout::new::<AzInstantPtrCloneCallback>(), "AzInstantPtrCloneCallback"));
        assert_eq!((Layout::new::<azul_core::task::SystemTick>(), "AzSystemTick"), (Layout::new::<AzSystemTick>(), "AzSystemTick"));
        assert_eq!((Layout::new::<azul_core::task::Duration>(), "AzDuration"), (Layout::new::<AzDuration>(), "AzDuration"));
        assert_eq!((Layout::new::<azul_core::task::SystemTimeDiff>(), "AzSystemTimeDiff"), (Layout::new::<AzSystemTimeDiff>(), "AzSystemTimeDiff"));
        assert_eq!((Layout::new::<azul_core::task::InstantPtrDestructorCallback>(), "AzInstantPtrDestructorCallback"), (Layout::new::<AzInstantPtrDestructorCallback>(), "AzInstantPtrDestructorCallback"));
        assert_eq!((Layout::new::<azul_core::task::TimerId>(), "AzTimerId"), (Layout::new::<AzTimerId>(), "AzTimerId"));
        assert_eq!((Layout::new::<azul_core::task::Timer>(), "AzTimer"), (Layout::new::<AzTimer>(), "AzTimer"));
        assert_eq!((Layout::new::<azul_core::task::TerminateTimer>(), "AzTerminateTimer"), (Layout::new::<AzTerminateTimer>(), "AzTerminateTimer"));
        assert_eq!((Layout::new::<azul_core::task::ThreadId>(), "AzThreadId"), (Layout::new::<AzThreadId>(), "AzThreadId"));
        assert_eq!((Layout::new::<azul_core::task::Thread>(), "AzThread"), (Layout::new::<AzThread>(), "AzThread"));
        assert_eq!((Layout::new::<azul_core::task::ThreadSender>(), "AzThreadSender"), (Layout::new::<AzThreadSender>(), "AzThreadSender"));
        assert_eq!((Layout::new::<azul_core::task::ThreadReceiver>(), "AzThreadReceiver"), (Layout::new::<AzThreadReceiver>(), "AzThreadReceiver"));
        assert_eq!((Layout::new::<azul_core::task::ThreadSendMsg>(), "AzThreadSendMsg"), (Layout::new::<AzThreadSendMsg>(), "AzThreadSendMsg"));
        assert_eq!((Layout::new::<azul_core::task::ThreadReceiveMsg>(), "AzThreadReceiveMsg"), (Layout::new::<AzThreadReceiveMsg>(), "AzThreadReceiveMsg"));
        assert_eq!((Layout::new::<azul_core::task::ThreadWriteBackMsg>(), "AzThreadWriteBackMsg"), (Layout::new::<AzThreadWriteBackMsg>(), "AzThreadWriteBackMsg"));
        assert_eq!((Layout::new::<azul_core::task::ThreadReceiverDestructorCallback>(), "AzThreadReceiverDestructorCallback"), (Layout::new::<AzThreadReceiverDestructorCallback>(), "AzThreadReceiverDestructorCallback"));
        assert_eq!((Layout::new::<azul_core::task::CreateThreadCallback>(), "AzCreateThreadCallback"), (Layout::new::<AzCreateThreadCallback>(), "AzCreateThreadCallback"));
        assert_eq!((Layout::new::<azul_core::task::GetSystemTimeCallback>(), "AzGetSystemTimeCallback"), (Layout::new::<AzGetSystemTimeCallback>(), "AzGetSystemTimeCallback"));
        assert_eq!((Layout::new::<azul_core::task::CheckThreadFinishedCallback>(), "AzCheckThreadFinishedCallback"), (Layout::new::<AzCheckThreadFinishedCallback>(), "AzCheckThreadFinishedCallback"));
        assert_eq!((Layout::new::<azul_core::task::LibrarySendThreadMsgCallback>(), "AzLibrarySendThreadMsgCallback"), (Layout::new::<AzLibrarySendThreadMsgCallback>(), "AzLibrarySendThreadMsgCallback"));
        assert_eq!((Layout::new::<azul_core::task::LibraryReceiveThreadMsgCallback>(), "AzLibraryReceiveThreadMsgCallback"), (Layout::new::<AzLibraryReceiveThreadMsgCallback>(), "AzLibraryReceiveThreadMsgCallback"));
        assert_eq!((Layout::new::<azul_core::task::ThreadRecvCallback>(), "AzThreadRecvCallback"), (Layout::new::<AzThreadRecvCallback>(), "AzThreadRecvCallback"));
        assert_eq!((Layout::new::<azul_core::task::ThreadSendCallback>(), "AzThreadSendCallback"), (Layout::new::<AzThreadSendCallback>(), "AzThreadSendCallback"));
        assert_eq!((Layout::new::<azul_core::task::ThreadDestructorCallback>(), "AzThreadDestructorCallback"), (Layout::new::<AzThreadDestructorCallback>(), "AzThreadDestructorCallback"));
        assert_eq!((Layout::new::<azul_core::task::ThreadSenderDestructorCallback>(), "AzThreadSenderDestructorCallback"), (Layout::new::<AzThreadSenderDestructorCallback>(), "AzThreadSenderDestructorCallback"));
        assert_eq!((Layout::new::<azul_dll::str::FmtValue>(), "AzFmtValue"), (Layout::new::<AzFmtValue>(), "AzFmtValue"));
        assert_eq!((Layout::new::<azul_dll::str::FmtArg>(), "AzFmtArg"), (Layout::new::<AzFmtArg>(), "AzFmtArg"));
        assert_eq!((Layout::new::<crate::widgets::list_view::ListViewRowVec>(), "AzListViewRowVec"), (Layout::new::<AzListViewRowVec>(), "AzListViewRowVec"));
        assert_eq!((Layout::new::<azul_css::props::style::filter::StyleFilterVec>(), "AzStyleFilterVec"), (Layout::new::<AzStyleFilterVec>(), "AzStyleFilterVec"));
        assert_eq!((Layout::new::<azul_core::geom::LogicalRectVec>(), "AzLogicalRectVec"), (Layout::new::<AzLogicalRectVec>(), "AzLogicalRectVec"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::NodeTypeIdInfoMapVec>(), "AzNodeTypeIdInfoMapVec"), (Layout::new::<AzNodeTypeIdInfoMapVec>(), "AzNodeTypeIdInfoMapVec"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::InputOutputTypeIdInfoMapVec>(), "AzInputOutputTypeIdInfoMapVec"), (Layout::new::<AzInputOutputTypeIdInfoMapVec>(), "AzInputOutputTypeIdInfoMapVec"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::NodeIdNodeMapVec>(), "AzNodeIdNodeMapVec"), (Layout::new::<AzNodeIdNodeMapVec>(), "AzNodeIdNodeMapVec"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::InputOutputTypeIdVec>(), "AzInputOutputTypeIdVec"), (Layout::new::<AzInputOutputTypeIdVec>(), "AzInputOutputTypeIdVec"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::NodeTypeFieldVec>(), "AzNodeTypeFieldVec"), (Layout::new::<AzNodeTypeFieldVec>(), "AzNodeTypeFieldVec"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::InputConnectionVec>(), "AzInputConnectionVec"), (Layout::new::<AzInputConnectionVec>(), "AzInputConnectionVec"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::OutputNodeAndIndexVec>(), "AzOutputNodeAndIndexVec"), (Layout::new::<AzOutputNodeAndIndexVec>(), "AzOutputNodeAndIndexVec"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::OutputConnectionVec>(), "AzOutputConnectionVec"), (Layout::new::<AzOutputConnectionVec>(), "AzOutputConnectionVec"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::InputNodeAndIndexVec>(), "AzInputNodeAndIndexVec"), (Layout::new::<AzInputNodeAndIndexVec>(), "AzInputNodeAndIndexVec"));
        assert_eq!((Layout::new::<azul_core::dom::AccessibilityStateVec>(), "AzAccessibilityStateVec"), (Layout::new::<AzAccessibilityStateVec>(), "AzAccessibilityStateVec"));
        assert_eq!((Layout::new::<azul_core::menu::MenuItemVec>(), "AzMenuItemVec"), (Layout::new::<AzMenuItemVec>(), "AzMenuItemVec"));
        assert_eq!((Layout::new::<azul_core::svg::TessellatedSvgNodeVec>(), "AzTessellatedSvgNodeVec"), (Layout::new::<AzTessellatedSvgNodeVec>(), "AzTessellatedSvgNodeVec"));
        assert_eq!((Layout::new::<azul_core::svg::TessellatedColoredSvgNodeVec>(), "AzTessellatedColoredSvgNodeVec"), (Layout::new::<AzTessellatedColoredSvgNodeVec>(), "AzTessellatedColoredSvgNodeVec"));
        assert_eq!((Layout::new::<azul_css::props::basic::font::StyleFontFamilyVec>(), "AzStyleFontFamilyVec"), (Layout::new::<AzStyleFontFamilyVec>(), "AzStyleFontFamilyVec"));
        assert_eq!((Layout::new::<azul_core::xml::XmlNodeVec>(), "AzXmlNodeVec"), (Layout::new::<AzXmlNodeVec>(), "AzXmlNodeVec"));
        assert_eq!((Layout::new::<crate::str::FmtArgVec>(), "AzFmtArgVec"), (Layout::new::<AzFmtArgVec>(), "AzFmtArgVec"));
        assert_eq!((Layout::new::<azul_core::callbacks::InlineLineVec>(), "AzInlineLineVec"), (Layout::new::<AzInlineLineVec>(), "AzInlineLineVec"));
        assert_eq!((Layout::new::<azul_core::callbacks::InlineWordVec>(), "AzInlineWordVec"), (Layout::new::<AzInlineWordVec>(), "AzInlineWordVec"));
        assert_eq!((Layout::new::<azul_core::callbacks::InlineGlyphVec>(), "AzInlineGlyphVec"), (Layout::new::<AzInlineGlyphVec>(), "AzInlineGlyphVec"));
        assert_eq!((Layout::new::<azul_core::callbacks::InlineTextHitVec>(), "AzInlineTextHitVec"), (Layout::new::<AzInlineTextHitVec>(), "AzInlineTextHitVec"));
        assert_eq!((Layout::new::<azul_core::window::MonitorVec>(), "AzMonitorVec"), (Layout::new::<AzMonitorVec>(), "AzMonitorVec"));
        assert_eq!((Layout::new::<azul_core::window::VideoModeVec>(), "AzVideoModeVec"), (Layout::new::<AzVideoModeVec>(), "AzVideoModeVec"));
        assert_eq!((Layout::new::<azul_core::dom::DomVec>(), "AzDomVec"), (Layout::new::<AzDomVec>(), "AzDomVec"));
        assert_eq!((Layout::new::<azul_core::dom::IdOrClassVec>(), "AzIdOrClassVec"), (Layout::new::<AzIdOrClassVec>(), "AzIdOrClassVec"));
        assert_eq!((Layout::new::<azul_core::dom::NodeDataInlineCssPropertyVec>(), "AzNodeDataInlineCssPropertyVec"), (Layout::new::<AzNodeDataInlineCssPropertyVec>(), "AzNodeDataInlineCssPropertyVec"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundContentVec>(), "AzStyleBackgroundContentVec"), (Layout::new::<AzStyleBackgroundContentVec>(), "AzStyleBackgroundContentVec"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundPositionVec>(), "AzStyleBackgroundPositionVec"), (Layout::new::<AzStyleBackgroundPositionVec>(), "AzStyleBackgroundPositionVec"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundRepeatVec>(), "AzStyleBackgroundRepeatVec"), (Layout::new::<AzStyleBackgroundRepeatVec>(), "AzStyleBackgroundRepeatVec"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundSizeVec>(), "AzStyleBackgroundSizeVec"), (Layout::new::<AzStyleBackgroundSizeVec>(), "AzStyleBackgroundSizeVec"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformVec>(), "AzStyleTransformVec"), (Layout::new::<AzStyleTransformVec>(), "AzStyleTransformVec"));
        assert_eq!((Layout::new::<azul_dll::widgets::number_input::CssPropertyVec>(), "AzCssPropertyVec"), (Layout::new::<AzCssPropertyVec>(), "AzCssPropertyVec"));
        assert_eq!((Layout::new::<azul_core::svg::SvgMultiPolygonVec>(), "AzSvgMultiPolygonVec"), (Layout::new::<AzSvgMultiPolygonVec>(), "AzSvgMultiPolygonVec"));
        assert_eq!((Layout::new::<azul_core::svg::SvgSimpleNodeVec>(), "AzSvgSimpleNodeVec"), (Layout::new::<AzSvgSimpleNodeVec>(), "AzSvgSimpleNodeVec"));
        assert_eq!((Layout::new::<azul_core::svg::SvgPathVec>(), "AzSvgPathVec"), (Layout::new::<AzSvgPathVec>(), "AzSvgPathVec"));
        assert_eq!((Layout::new::<azul_core::gl::VertexAttributeVec>(), "AzVertexAttributeVec"), (Layout::new::<AzVertexAttributeVec>(), "AzVertexAttributeVec"));
        assert_eq!((Layout::new::<azul_core::svg::SvgPathElementVec>(), "AzSvgPathElementVec"), (Layout::new::<AzSvgPathElementVec>(), "AzSvgPathElementVec"));
        assert_eq!((Layout::new::<azul_core::svg::SvgVertexVec>(), "AzSvgVertexVec"), (Layout::new::<AzSvgVertexVec>(), "AzSvgVertexVec"));
        assert_eq!((Layout::new::<azul_core::svg::SvgColoredVertexVec>(), "AzSvgColoredVertexVec"), (Layout::new::<AzSvgColoredVertexVec>(), "AzSvgColoredVertexVec"));
        assert_eq!((Layout::new::<azul_css::corety::U32Vec>(), "AzU32Vec"), (Layout::new::<AzU32Vec>(), "AzU32Vec"));
        assert_eq!((Layout::new::<azul_core::window::XWindowTypeVec>(), "AzXWindowTypeVec"), (Layout::new::<AzXWindowTypeVec>(), "AzXWindowTypeVec"));
        assert_eq!((Layout::new::<azul_core::window::VirtualKeyCodeVec>(), "AzVirtualKeyCodeVec"), (Layout::new::<AzVirtualKeyCodeVec>(), "AzVirtualKeyCodeVec"));
        assert_eq!((Layout::new::<azul_core::style::CascadeInfoVec>(), "AzCascadeInfoVec"), (Layout::new::<AzCascadeInfoVec>(), "AzCascadeInfoVec"));
        assert_eq!((Layout::new::<azul_core::window::ScanCodeVec>(), "AzScanCodeVec"), (Layout::new::<AzScanCodeVec>(), "AzScanCodeVec"));
        assert_eq!((Layout::new::<azul_css::css::CssDeclarationVec>(), "AzCssDeclarationVec"), (Layout::new::<AzCssDeclarationVec>(), "AzCssDeclarationVec"));
        assert_eq!((Layout::new::<azul_css::css::CssPathSelectorVec>(), "AzCssPathSelectorVec"), (Layout::new::<AzCssPathSelectorVec>(), "AzCssPathSelectorVec"));
        assert_eq!((Layout::new::<azul_css::css::StylesheetVec>(), "AzStylesheetVec"), (Layout::new::<AzStylesheetVec>(), "AzStylesheetVec"));
        assert_eq!((Layout::new::<azul_css::css::CssRuleBlockVec>(), "AzCssRuleBlockVec"), (Layout::new::<AzCssRuleBlockVec>(), "AzCssRuleBlockVec"));
        assert_eq!((Layout::new::<azul_css::corety::U16Vec>(), "AzU16Vec"), (Layout::new::<AzU16Vec>(), "AzU16Vec"));
        assert_eq!((Layout::new::<azul_css::corety::F32Vec>(), "AzF32Vec"), (Layout::new::<AzF32Vec>(), "AzF32Vec"));
        assert_eq!((Layout::new::<azul_css::corety::U8Vec>(), "AzU8Vec"), (Layout::new::<AzU8Vec>(), "AzU8Vec"));
        assert_eq!((Layout::new::<azul_core::dom::CallbackDataVec>(), "AzCallbackDataVec"), (Layout::new::<AzCallbackDataVec>(), "AzCallbackDataVec"));
        assert_eq!((Layout::new::<azul_core::gl::GLuintVec>(), "AzGLuintVec"), (Layout::new::<AzGLuintVec>(), "AzGLuintVec"));
        assert_eq!((Layout::new::<azul_core::gl::GLintVec>(), "AzGLintVec"), (Layout::new::<AzGLintVec>(), "AzGLintVec"));
        assert_eq!((Layout::new::<azul_css::corety::StringVec>(), "AzStringVec"), (Layout::new::<AzStringVec>(), "AzStringVec"));
        assert_eq!((Layout::new::<azul_core::window::StringPairVec>(), "AzStringPairVec"), (Layout::new::<AzStringPairVec>(), "AzStringPairVec"));
        assert_eq!((Layout::new::<azul_css::props::style::background::NormalizedLinearColorStopVec>(), "AzNormalizedLinearColorStopVec"), (Layout::new::<AzNormalizedLinearColorStopVec>(), "AzNormalizedLinearColorStopVec"));
        assert_eq!((Layout::new::<azul_css::props::style::background::NormalizedRadialColorStopVec>(), "AzNormalizedRadialColorStopVec"), (Layout::new::<AzNormalizedRadialColorStopVec>(), "AzNormalizedRadialColorStopVec"));
        assert_eq!((Layout::new::<azul_core::styled_dom::NodeIdVec>(), "AzNodeIdVec"), (Layout::new::<AzNodeIdVec>(), "AzNodeIdVec"));
        assert_eq!((Layout::new::<azul_core::styled_dom::NodeHierarchyItemVec>(), "AzNodeHierarchyItemVec"), (Layout::new::<AzNodeHierarchyItemVec>(), "AzNodeHierarchyItemVec"));
        assert_eq!((Layout::new::<azul_core::styled_dom::StyledNodeVec>(), "AzStyledNodeVec"), (Layout::new::<AzStyledNodeVec>(), "AzStyledNodeVec"));
        assert_eq!((Layout::new::<azul_core::styled_dom::TagIdToNodeIdMappingVec>(), "AzTagIdToNodeIdMappingVec"), (Layout::new::<AzTagIdToNodeIdMappingVec>(), "AzTagIdToNodeIdMappingVec"));
        assert_eq!((Layout::new::<azul_core::styled_dom::ParentWithNodeDepthVec>(), "AzParentWithNodeDepthVec"), (Layout::new::<AzParentWithNodeDepthVec>(), "AzParentWithNodeDepthVec"));
        assert_eq!((Layout::new::<azul_core::dom::NodeDataVec>(), "AzNodeDataVec"), (Layout::new::<AzNodeDataVec>(), "AzNodeDataVec"));
        assert_eq!((Layout::new::<azul_css::props::basic::font::StyleFontFamilyVecDestructor>(), "AzStyleFontFamilyVecDestructor"), (Layout::new::<AzStyleFontFamilyVecDestructor>(), "AzStyleFontFamilyVecDestructor"));
        assert_eq!((Layout::new::<crate::widgets::list_view::ListViewRowVecDestructor>(), "AzListViewRowVecDestructor"), (Layout::new::<AzListViewRowVecDestructor>(), "AzListViewRowVecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::style::filter::StyleFilterVecDestructor>(), "AzStyleFilterVecDestructor"), (Layout::new::<AzStyleFilterVecDestructor>(), "AzStyleFilterVecDestructor"));
        assert_eq!((Layout::new::<azul_core::geom::LogicalRectVecDestructor>(), "AzLogicalRectVecDestructor"), (Layout::new::<AzLogicalRectVecDestructor>(), "AzLogicalRectVecDestructor"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::NodeTypeIdInfoMapVecDestructor>(), "AzNodeTypeIdInfoMapVecDestructor"), (Layout::new::<AzNodeTypeIdInfoMapVecDestructor>(), "AzNodeTypeIdInfoMapVecDestructor"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::InputOutputTypeIdInfoMapVecDestructor>(), "AzInputOutputTypeIdInfoMapVecDestructor"), (Layout::new::<AzInputOutputTypeIdInfoMapVecDestructor>(), "AzInputOutputTypeIdInfoMapVecDestructor"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::NodeIdNodeMapVecDestructor>(), "AzNodeIdNodeMapVecDestructor"), (Layout::new::<AzNodeIdNodeMapVecDestructor>(), "AzNodeIdNodeMapVecDestructor"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::InputOutputTypeIdVecDestructor>(), "AzInputOutputTypeIdVecDestructor"), (Layout::new::<AzInputOutputTypeIdVecDestructor>(), "AzInputOutputTypeIdVecDestructor"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::NodeTypeFieldVecDestructor>(), "AzNodeTypeFieldVecDestructor"), (Layout::new::<AzNodeTypeFieldVecDestructor>(), "AzNodeTypeFieldVecDestructor"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::InputConnectionVecDestructor>(), "AzInputConnectionVecDestructor"), (Layout::new::<AzInputConnectionVecDestructor>(), "AzInputConnectionVecDestructor"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::OutputNodeAndIndexVecDestructor>(), "AzOutputNodeAndIndexVecDestructor"), (Layout::new::<AzOutputNodeAndIndexVecDestructor>(), "AzOutputNodeAndIndexVecDestructor"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::OutputConnectionVecDestructor>(), "AzOutputConnectionVecDestructor"), (Layout::new::<AzOutputConnectionVecDestructor>(), "AzOutputConnectionVecDestructor"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::InputNodeAndIndexVecDestructor>(), "AzInputNodeAndIndexVecDestructor"), (Layout::new::<AzInputNodeAndIndexVecDestructor>(), "AzInputNodeAndIndexVecDestructor"));
        assert_eq!((Layout::new::<azul_core::dom::AccessibilityStateVecDestructor>(), "AzAccessibilityStateVecDestructor"), (Layout::new::<AzAccessibilityStateVecDestructor>(), "AzAccessibilityStateVecDestructor"));
        assert_eq!((Layout::new::<azul_core::menu::MenuItemVecDestructor>(), "AzMenuItemVecDestructor"), (Layout::new::<AzMenuItemVecDestructor>(), "AzMenuItemVecDestructor"));
        assert_eq!((Layout::new::<azul_core::svg::TessellatedSvgNodeVecDestructor>(), "AzTessellatedSvgNodeVecDestructor"), (Layout::new::<AzTessellatedSvgNodeVecDestructor>(), "AzTessellatedSvgNodeVecDestructor"));
        assert_eq!((Layout::new::<azul_core::svg::TessellatedColoredSvgNodeVecDestructor>(), "AzTessellatedColoredSvgNodeVecDestructor"), (Layout::new::<AzTessellatedColoredSvgNodeVecDestructor>(), "AzTessellatedColoredSvgNodeVecDestructor"));
        assert_eq!((Layout::new::<azul_core::xml::XmlNodeVecDestructor>(), "AzXmlNodeVecDestructor"), (Layout::new::<AzXmlNodeVecDestructor>(), "AzXmlNodeVecDestructor"));
        assert_eq!((Layout::new::<crate::str::FmtArgVecDestructor>(), "AzFmtArgVecDestructor"), (Layout::new::<AzFmtArgVecDestructor>(), "AzFmtArgVecDestructor"));
        assert_eq!((Layout::new::<azul_core::callbacks::InlineLineVecDestructor>(), "AzInlineLineVecDestructor"), (Layout::new::<AzInlineLineVecDestructor>(), "AzInlineLineVecDestructor"));
        assert_eq!((Layout::new::<azul_core::callbacks::InlineWordVecDestructor>(), "AzInlineWordVecDestructor"), (Layout::new::<AzInlineWordVecDestructor>(), "AzInlineWordVecDestructor"));
        assert_eq!((Layout::new::<azul_core::callbacks::InlineGlyphVecDestructor>(), "AzInlineGlyphVecDestructor"), (Layout::new::<AzInlineGlyphVecDestructor>(), "AzInlineGlyphVecDestructor"));
        assert_eq!((Layout::new::<azul_core::callbacks::InlineTextHitVecDestructor>(), "AzInlineTextHitVecDestructor"), (Layout::new::<AzInlineTextHitVecDestructor>(), "AzInlineTextHitVecDestructor"));
        assert_eq!((Layout::new::<azul_core::window::MonitorVecDestructor>(), "AzMonitorVecDestructor"), (Layout::new::<AzMonitorVecDestructor>(), "AzMonitorVecDestructor"));
        assert_eq!((Layout::new::<azul_core::window::VideoModeVecDestructor>(), "AzVideoModeVecDestructor"), (Layout::new::<AzVideoModeVecDestructor>(), "AzVideoModeVecDestructor"));
        assert_eq!((Layout::new::<azul_core::dom::DomVecDestructor>(), "AzDomVecDestructor"), (Layout::new::<AzDomVecDestructor>(), "AzDomVecDestructor"));
        assert_eq!((Layout::new::<azul_core::dom::IdOrClassVecDestructor>(), "AzIdOrClassVecDestructor"), (Layout::new::<AzIdOrClassVecDestructor>(), "AzIdOrClassVecDestructor"));
        assert_eq!((Layout::new::<azul_core::dom::NodeDataInlineCssPropertyVecDestructor>(), "AzNodeDataInlineCssPropertyVecDestructor"), (Layout::new::<AzNodeDataInlineCssPropertyVecDestructor>(), "AzNodeDataInlineCssPropertyVecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundContentVecDestructor>(), "AzStyleBackgroundContentVecDestructor"), (Layout::new::<AzStyleBackgroundContentVecDestructor>(), "AzStyleBackgroundContentVecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundPositionVecDestructor>(), "AzStyleBackgroundPositionVecDestructor"), (Layout::new::<AzStyleBackgroundPositionVecDestructor>(), "AzStyleBackgroundPositionVecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundRepeatVecDestructor>(), "AzStyleBackgroundRepeatVecDestructor"), (Layout::new::<AzStyleBackgroundRepeatVecDestructor>(), "AzStyleBackgroundRepeatVecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundSizeVecDestructor>(), "AzStyleBackgroundSizeVecDestructor"), (Layout::new::<AzStyleBackgroundSizeVecDestructor>(), "AzStyleBackgroundSizeVecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformVecDestructor>(), "AzStyleTransformVecDestructor"), (Layout::new::<AzStyleTransformVecDestructor>(), "AzStyleTransformVecDestructor"));
        assert_eq!((Layout::new::<azul_core::dom::CssPropertyVecDestructor>(), "AzCssPropertyVecDestructor"), (Layout::new::<AzCssPropertyVecDestructor>(), "AzCssPropertyVecDestructor"));
        assert_eq!((Layout::new::<azul_core::svg::SvgMultiPolygonVecDestructor>(), "AzSvgMultiPolygonVecDestructor"), (Layout::new::<AzSvgMultiPolygonVecDestructor>(), "AzSvgMultiPolygonVecDestructor"));
        assert_eq!((Layout::new::<azul_core::svg::SvgSimpleNodeVecDestructor>(), "AzSvgSimpleNodeVecDestructor"), (Layout::new::<AzSvgSimpleNodeVecDestructor>(), "AzSvgSimpleNodeVecDestructor"));
        assert_eq!((Layout::new::<azul_core::svg::SvgPathVecDestructor>(), "AzSvgPathVecDestructor"), (Layout::new::<AzSvgPathVecDestructor>(), "AzSvgPathVecDestructor"));
        assert_eq!((Layout::new::<azul_core::gl::VertexAttributeVecDestructor>(), "AzVertexAttributeVecDestructor"), (Layout::new::<AzVertexAttributeVecDestructor>(), "AzVertexAttributeVecDestructor"));
        assert_eq!((Layout::new::<azul_core::svg::SvgPathElementVecDestructor>(), "AzSvgPathElementVecDestructor"), (Layout::new::<AzSvgPathElementVecDestructor>(), "AzSvgPathElementVecDestructor"));
        assert_eq!((Layout::new::<azul_core::svg::SvgVertexVecDestructor>(), "AzSvgVertexVecDestructor"), (Layout::new::<AzSvgVertexVecDestructor>(), "AzSvgVertexVecDestructor"));
        assert_eq!((Layout::new::<azul_core::svg::SvgColoredVertexVecDestructor>(), "AzSvgColoredVertexVecDestructor"), (Layout::new::<AzSvgColoredVertexVecDestructor>(), "AzSvgColoredVertexVecDestructor"));
        assert_eq!((Layout::new::<azul_css::corety::U32VecDestructor>(), "AzU32VecDestructor"), (Layout::new::<AzU32VecDestructor>(), "AzU32VecDestructor"));
        assert_eq!((Layout::new::<azul_core::window::XWindowTypeVecDestructor>(), "AzXWindowTypeVecDestructor"), (Layout::new::<AzXWindowTypeVecDestructor>(), "AzXWindowTypeVecDestructor"));
        assert_eq!((Layout::new::<azul_core::window::VirtualKeyCodeVecDestructor>(), "AzVirtualKeyCodeVecDestructor"), (Layout::new::<AzVirtualKeyCodeVecDestructor>(), "AzVirtualKeyCodeVecDestructor"));
        assert_eq!((Layout::new::<azul_core::style::CascadeInfoVecDestructor>(), "AzCascadeInfoVecDestructor"), (Layout::new::<AzCascadeInfoVecDestructor>(), "AzCascadeInfoVecDestructor"));
        assert_eq!((Layout::new::<azul_core::window::ScanCodeVecDestructor>(), "AzScanCodeVecDestructor"), (Layout::new::<AzScanCodeVecDestructor>(), "AzScanCodeVecDestructor"));
        assert_eq!((Layout::new::<azul_css::css::CssDeclarationVecDestructor>(), "AzCssDeclarationVecDestructor"), (Layout::new::<AzCssDeclarationVecDestructor>(), "AzCssDeclarationVecDestructor"));
        assert_eq!((Layout::new::<azul_css::css::CssPathSelectorVecDestructor>(), "AzCssPathSelectorVecDestructor"), (Layout::new::<AzCssPathSelectorVecDestructor>(), "AzCssPathSelectorVecDestructor"));
        assert_eq!((Layout::new::<azul_css::css::StylesheetVecDestructor>(), "AzStylesheetVecDestructor"), (Layout::new::<AzStylesheetVecDestructor>(), "AzStylesheetVecDestructor"));
        assert_eq!((Layout::new::<azul_css::css::CssRuleBlockVecDestructor>(), "AzCssRuleBlockVecDestructor"), (Layout::new::<AzCssRuleBlockVecDestructor>(), "AzCssRuleBlockVecDestructor"));
        assert_eq!((Layout::new::<azul_css::corety::F32VecDestructor>(), "AzF32VecDestructor"), (Layout::new::<AzF32VecDestructor>(), "AzF32VecDestructor"));
        assert_eq!((Layout::new::<azul_css::corety::U16VecDestructor>(), "AzU16VecDestructor"), (Layout::new::<AzU16VecDestructor>(), "AzU16VecDestructor"));
        assert_eq!((Layout::new::<azul_css::corety::U8VecDestructor>(), "AzU8VecDestructor"), (Layout::new::<AzU8VecDestructor>(), "AzU8VecDestructor"));
        assert_eq!((Layout::new::<azul_core::dom::CallbackDataVecDestructor>(), "AzCallbackDataVecDestructor"), (Layout::new::<AzCallbackDataVecDestructor>(), "AzCallbackDataVecDestructor"));
        assert_eq!((Layout::new::<azul_core::gl::AzDebugMessageVec>(), "AzAzDebugMessageVec"), (Layout::new::<AzAzDebugMessageVec>(), "AzAzDebugMessageVec"));
        assert_eq!((Layout::new::<azul_core::gl::GLuintVecDestructor>(), "AzGLuintVecDestructor"), (Layout::new::<AzGLuintVecDestructor>(), "AzGLuintVecDestructor"));
        assert_eq!((Layout::new::<azul_core::gl::GLintVecDestructor>(), "AzGLintVecDestructor"), (Layout::new::<AzGLintVecDestructor>(), "AzGLintVecDestructor"));
        assert_eq!((Layout::new::<azul_css::corety::StringVecDestructor>(), "AzStringVecDestructor"), (Layout::new::<AzStringVecDestructor>(), "AzStringVecDestructor"));
        assert_eq!((Layout::new::<azul_core::window::StringPairVecDestructor>(), "AzStringPairVecDestructor"), (Layout::new::<AzStringPairVecDestructor>(), "AzStringPairVecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::style::background::NormalizedLinearColorStopVecDestructor>(), "AzNormalizedLinearColorStopVecDestructor"), (Layout::new::<AzNormalizedLinearColorStopVecDestructor>(), "AzNormalizedLinearColorStopVecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::style::background::NormalizedRadialColorStopVecDestructor>(), "AzNormalizedRadialColorStopVecDestructor"), (Layout::new::<AzNormalizedRadialColorStopVecDestructor>(), "AzNormalizedRadialColorStopVecDestructor"));
        assert_eq!((Layout::new::<azul_core::styled_dom::NodeIdVecDestructor>(), "AzNodeIdVecDestructor"), (Layout::new::<AzNodeIdVecDestructor>(), "AzNodeIdVecDestructor"));
        assert_eq!((Layout::new::<azul_core::styled_dom::NodeHierarchyItemVecDestructor>(), "AzNodeHierarchyItemVecDestructor"), (Layout::new::<AzNodeHierarchyItemVecDestructor>(), "AzNodeHierarchyItemVecDestructor"));
        assert_eq!((Layout::new::<azul_core::styled_dom::StyledNodeVecDestructor>(), "AzStyledNodeVecDestructor"), (Layout::new::<AzStyledNodeVecDestructor>(), "AzStyledNodeVecDestructor"));
        assert_eq!((Layout::new::<azul_core::styled_dom::TagIdToNodeIdMappingVecDestructor>(), "AzTagIdToNodeIdMappingVecDestructor"), (Layout::new::<AzTagIdToNodeIdMappingVecDestructor>(), "AzTagIdToNodeIdMappingVecDestructor"));
        assert_eq!((Layout::new::<azul_core::styled_dom::ParentWithNodeDepthVecDestructor>(), "AzParentWithNodeDepthVecDestructor"), (Layout::new::<AzParentWithNodeDepthVecDestructor>(), "AzParentWithNodeDepthVecDestructor"));
        assert_eq!((Layout::new::<azul_core::dom::NodeDataVecDestructor>(), "AzNodeDataVecDestructor"), (Layout::new::<AzNodeDataVecDestructor>(), "AzNodeDataVecDestructor"));
        assert_eq!((Layout::new::<azul_core::gl::AzDebugMessageVecDestructor>(), "AzAzDebugMessageVecDestructor"), (Layout::new::<AzAzDebugMessageVecDestructor>(), "AzAzDebugMessageVecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::basic::animation::OptionSvgPoint>(), "AzOptionSvgPoint"), (Layout::new::<AzOptionSvgPoint>(), "AzOptionSvgPoint"));
        assert_eq!((Layout::new::<azul_css::props::style::text::OptionStyleTextAlign>(), "AzOptionStyleTextAlign"), (Layout::new::<AzOptionStyleTextAlign>(), "AzOptionStyleTextAlign"));
        assert_eq!((Layout::new::<crate::widgets::list_view::OptionListViewOnRowClick>(), "AzOptionListViewOnRowClick"), (Layout::new::<AzOptionListViewOnRowClick>(), "AzOptionListViewOnRowClick"));
        assert_eq!((Layout::new::<crate::widgets::list_view::OptionListViewOnColumnClick>(), "AzOptionListViewOnColumnClick"), (Layout::new::<AzOptionListViewOnColumnClick>(), "AzOptionListViewOnColumnClick"));
        assert_eq!((Layout::new::<crate::widgets::list_view::OptionListViewOnLazyLoadScroll>(), "AzOptionListViewOnLazyLoadScroll"), (Layout::new::<AzOptionListViewOnLazyLoadScroll>(), "AzOptionListViewOnLazyLoadScroll"));
        assert_eq!((Layout::new::<azul_core::menu::OptionMenu>(), "AzOptionMenu"), (Layout::new::<AzOptionMenu>(), "AzOptionMenu"));
        assert_eq!((Layout::new::<azul_css::props::basic::pixel::OptionPixelValueNoPercent>(), "AzOptionPixelValueNoPercent"), (Layout::new::<AzOptionPixelValueNoPercent>(), "AzOptionPixelValueNoPercent"));
        assert_eq!((Layout::new::<crate::widgets::drop_down::OptionDropDownOnChoiceChange>(), "AzOptionDropDownOnChoiceChange"), (Layout::new::<AzOptionDropDownOnChoiceChange>(), "AzOptionDropDownOnChoiceChange"));
        assert_eq!((Layout::new::<azul_core::ui_solver::OptionResolvedTextLayoutOptions>(), "AzOptionResolvedTextLayoutOptions"), (Layout::new::<AzOptionResolvedTextLayoutOptions>(), "AzOptionResolvedTextLayoutOptions"));
        assert_eq!((Layout::new::<azul_core::gl::OptionU8VecRef>(), "AzOptionU8VecRef"), (Layout::new::<AzOptionU8VecRef>(), "AzOptionU8VecRef"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::OptionOnNodeAdded>(), "AzOptionOnNodeAdded"), (Layout::new::<AzOptionOnNodeAdded>(), "AzOptionOnNodeAdded"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::OptionOnNodeRemoved>(), "AzOptionOnNodeRemoved"), (Layout::new::<AzOptionOnNodeRemoved>(), "AzOptionOnNodeRemoved"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::OptionOnNodeGraphDragged>(), "AzOptionOnNodeGraphDragged"), (Layout::new::<AzOptionOnNodeGraphDragged>(), "AzOptionOnNodeGraphDragged"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::OptionOnNodeDragged>(), "AzOptionOnNodeDragged"), (Layout::new::<AzOptionOnNodeDragged>(), "AzOptionOnNodeDragged"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::OptionOnNodeConnected>(), "AzOptionOnNodeConnected"), (Layout::new::<AzOptionOnNodeConnected>(), "AzOptionOnNodeConnected"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::OptionOnNodeInputDisconnected>(), "AzOptionOnNodeInputDisconnected"), (Layout::new::<AzOptionOnNodeInputDisconnected>(), "AzOptionOnNodeInputDisconnected"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::OptionOnNodeOutputDisconnected>(), "AzOptionOnNodeOutputDisconnected"), (Layout::new::<AzOptionOnNodeOutputDisconnected>(), "AzOptionOnNodeOutputDisconnected"));
        assert_eq!((Layout::new::<crate::widgets::color_input::OptionColorInputOnValueChange>(), "AzOptionColorInputOnValueChange"), (Layout::new::<AzOptionColorInputOnValueChange>(), "AzOptionColorInputOnValueChange"));
        assert_eq!((Layout::new::<crate::widgets::button::OptionButtonOnClick>(), "AzOptionButtonOnClick"), (Layout::new::<AzOptionButtonOnClick>(), "AzOptionButtonOnClick"));
        assert_eq!((Layout::new::<crate::widgets::tabs::OptionTabOnClick>(), "AzOptionTabOnClick"), (Layout::new::<AzOptionTabOnClick>(), "AzOptionTabOnClick"));
        assert_eq!((Layout::new::<crate::widgets::file_input::OptionFileInputOnPathChange>(), "AzOptionFileInputOnPathChange"), (Layout::new::<AzOptionFileInputOnPathChange>(), "AzOptionFileInputOnPathChange"));
        assert_eq!((Layout::new::<crate::widgets::check_box::OptionCheckBoxOnToggle>(), "AzOptionCheckBoxOnToggle"), (Layout::new::<AzOptionCheckBoxOnToggle>(), "AzOptionCheckBoxOnToggle"));
        assert_eq!((Layout::new::<crate::widgets::text_input::OptionTextInputOnTextInput>(), "AzOptionTextInputOnTextInput"), (Layout::new::<AzOptionTextInputOnTextInput>(), "AzOptionTextInputOnTextInput"));
        assert_eq!((Layout::new::<crate::widgets::text_input::OptionTextInputOnVirtualKeyDown>(), "AzOptionTextInputOnVirtualKeyDown"), (Layout::new::<AzOptionTextInputOnVirtualKeyDown>(), "AzOptionTextInputOnVirtualKeyDown"));
        assert_eq!((Layout::new::<crate::widgets::text_input::OptionTextInputOnFocusLost>(), "AzOptionTextInputOnFocusLost"), (Layout::new::<AzOptionTextInputOnFocusLost>(), "AzOptionTextInputOnFocusLost"));
        assert_eq!((Layout::new::<crate::widgets::text_input::OptionTextInputSelection>(), "AzOptionTextInputSelection"), (Layout::new::<AzOptionTextInputSelection>(), "AzOptionTextInputSelection"));
        assert_eq!((Layout::new::<crate::widgets::number_input::OptionNumberInputOnFocusLost>(), "AzOptionNumberInputOnFocusLost"), (Layout::new::<AzOptionNumberInputOnFocusLost>(), "AzOptionNumberInputOnFocusLost"));
        assert_eq!((Layout::new::<crate::widgets::number_input::OptionNumberInputOnValueChange>(), "AzOptionNumberInputOnValueChange"), (Layout::new::<AzOptionNumberInputOnValueChange>(), "AzOptionNumberInputOnValueChange"));
        assert_eq!((Layout::new::<azul_core::menu::OptionMenuItemIcon>(), "AzOptionMenuItemIcon"), (Layout::new::<AzOptionMenuItemIcon>(), "AzOptionMenuItemIcon"));
        assert_eq!((Layout::new::<azul_layout::callbacks::OptionMenuCallback>(), "AzOptionMenuCallback"), (Layout::new::<AzOptionMenuCallback>(), "AzOptionMenuCallback"));
        assert_eq!((Layout::new::<azul_core::window::OptionVirtualKeyCodeCombo>(), "AzOptionVirtualKeyCodeCombo"), (Layout::new::<AzOptionVirtualKeyCodeCombo>(), "AzOptionVirtualKeyCodeCombo"));
        assert_eq!((Layout::new::<azul_css::props::property::OptionCssProperty>(), "AzOptionCssProperty"), (Layout::new::<AzOptionCssProperty>(), "AzOptionCssProperty"));
        assert_eq!((Layout::new::<azul_core::ui_solver::OptionPositionInfo>(), "AzOptionPositionInfo"), (Layout::new::<AzOptionPositionInfo>(), "AzOptionPositionInfo"));
        assert_eq!((Layout::new::<azul_core::task::OptionTimerId>(), "AzOptionTimerId"), (Layout::new::<AzOptionTimerId>(), "AzOptionTimerId"));
        assert_eq!((Layout::new::<azul_core::task::OptionThreadId>(), "AzOptionThreadId"), (Layout::new::<AzOptionThreadId>(), "AzOptionThreadId"));
        assert_eq!((Layout::new::<azul_css::corety::OptionI16>(), "AzOptionI16"), (Layout::new::<AzOptionI16>(), "AzOptionI16"));
        assert_eq!((Layout::new::<azul_css::corety::OptionU16>(), "AzOptionU16"), (Layout::new::<AzOptionU16>(), "AzOptionU16"));
        assert_eq!((Layout::new::<azul_css::corety::OptionU32>(), "AzOptionU32"), (Layout::new::<AzOptionU32>(), "AzOptionU32"));
        assert_eq!((Layout::new::<azul_core::resources::OptionImageRef>(), "AzOptionImageRef"), (Layout::new::<AzOptionImageRef>(), "AzOptionImageRef"));
        assert_eq!((Layout::new::<azul_css::props::basic::font::OptionFontRef>(), "AzOptionFontRef"), (Layout::new::<AzOptionFontRef>(), "AzOptionFontRef"));
        assert_eq!((Layout::new::<crate::widgets::node_graph::OptionOnNodeFieldEdited>(), "AzOptionOnNodeFieldEdited"), (Layout::new::<AzOptionOnNodeFieldEdited>(), "AzOptionOnNodeFieldEdited"));
        assert_eq!((Layout::new::<azul_dll::desktop::dialogs::OptionFileTypeList>(), "AzOptionFileTypeList"), (Layout::new::<AzOptionFileTypeList>(), "AzOptionFileTypeList"));
        assert_eq!((Layout::new::<azul_layout::window_state::OptionWindowState>(), "AzOptionWindowState"), (Layout::new::<AzOptionWindowState>(), "AzOptionWindowState"));
        assert_eq!((Layout::new::<azul_core::window::OptionMouseState>(), "AzOptionMouseState"), (Layout::new::<AzOptionMouseState>(), "AzOptionMouseState"));
        assert_eq!((Layout::new::<azul_core::window::OptionKeyboardState>(), "AzOptionKeyboardState"), (Layout::new::<AzOptionKeyboardState>(), "AzOptionKeyboardState"));
        assert_eq!((Layout::new::<azul_css::OptionStringVec>(), "AzOptionStringVec"), (Layout::new::<AzOptionStringVec>(), "AzOptionStringVec"));
        assert_eq!((Layout::new::<azul_dll::desktop::file::OptionFile>(), "AzOptionFile"), (Layout::new::<AzOptionFile>(), "AzOptionFile"));
        assert_eq!((Layout::new::<azul_dll::desktop::app::OptionClipboard>(), "AzOptionClipboard"), (Layout::new::<AzOptionClipboard>(), "AzOptionClipboard"));
        assert_eq!((Layout::new::<azul_layout::thread::OptionThreadReceiveMsg>(), "AzOptionThreadReceiveMsg"), (Layout::new::<AzOptionThreadReceiveMsg>(), "AzOptionThreadReceiveMsg"));
        assert_eq!((Layout::new::<azul_css::props::basic::length::OptionPercentageValue>(), "AzOptionPercentageValue"), (Layout::new::<AzOptionPercentageValue>(), "AzOptionPercentageValue"));
        assert_eq!((Layout::new::<azul_css::props::basic::angle::OptionAngleValue>(), "AzOptionAngleValue"), (Layout::new::<AzOptionAngleValue>(), "AzOptionAngleValue"));
        assert_eq!((Layout::new::<azul_core::window::OptionRendererOptions>(), "AzOptionRendererOptions"), (Layout::new::<AzOptionRendererOptions>(), "AzOptionRendererOptions"));
        assert_eq!((Layout::new::<azul_layout::callbacks::OptionCallback>(), "AzOptionCallback"), (Layout::new::<AzOptionCallback>(), "AzOptionCallback"));
        assert_eq!((Layout::new::<azul_core::task::OptionThreadSendMsg>(), "AzOptionThreadSendMsg"), (Layout::new::<AzOptionThreadSendMsg>(), "AzOptionThreadSendMsg"));
        assert_eq!((Layout::new::<azul_css::props::basic::geometry::OptionLayoutRect>(), "AzOptionLayoutRect"), (Layout::new::<AzOptionLayoutRect>(), "AzOptionLayoutRect"));
        assert_eq!((Layout::new::<azul_core::refany::OptionRefAny>(), "AzOptionRefAny"), (Layout::new::<AzOptionRefAny>(), "AzOptionRefAny"));
        assert_eq!((Layout::new::<azul_core::callbacks::OptionInlineText>(), "AzOptionInlineText"), (Layout::new::<AzOptionInlineText>(), "AzOptionInlineText"));
        assert_eq!((Layout::new::<azul_css::props::basic::geometry::OptionLayoutPoint>(), "AzOptionLayoutPoint"), (Layout::new::<AzOptionLayoutPoint>(), "AzOptionLayoutPoint"));
        assert_eq!((Layout::new::<azul_css::props::basic::geometry::OptionLayoutSize>(), "AzOptionLayoutSize"), (Layout::new::<AzOptionLayoutSize>(), "AzOptionLayoutSize"));
        assert_eq!((Layout::new::<azul_core::window::OptionWindowTheme>(), "AzOptionWindowTheme"), (Layout::new::<AzOptionWindowTheme>(), "AzOptionWindowTheme"));
        assert_eq!((Layout::new::<azul_core::styled_dom::OptionNodeId>(), "AzOptionNodeId"), (Layout::new::<AzOptionNodeId>(), "AzOptionNodeId"));
        assert_eq!((Layout::new::<azul_core::dom::OptionDomNodeId>(), "AzOptionDomNodeId"), (Layout::new::<AzOptionDomNodeId>(), "AzOptionDomNodeId"));
        assert_eq!((Layout::new::<azul_css::props::basic::color::OptionColorU>(), "AzOptionColorU"), (Layout::new::<AzOptionColorU>(), "AzOptionColorU"));
        assert_eq!((Layout::new::<azul_core::resources::OptionRawImage>(), "AzOptionRawImage"), (Layout::new::<AzOptionRawImage>(), "AzOptionRawImage"));
        assert_eq!((Layout::new::<azul_core::svg::OptionSvgDashPattern>(), "AzOptionSvgDashPattern"), (Layout::new::<AzOptionSvgDashPattern>(), "AzOptionSvgDashPattern"));
        assert_eq!((Layout::new::<azul_core::window::OptionWaylandTheme>(), "AzOptionWaylandTheme"), (Layout::new::<AzOptionWaylandTheme>(), "AzOptionWaylandTheme"));
        assert_eq!((Layout::new::<azul_core::window::OptionTaskBarIcon>(), "AzOptionTaskBarIcon"), (Layout::new::<AzOptionTaskBarIcon>(), "AzOptionTaskBarIcon"));
        assert_eq!((Layout::new::<azul_core::window::OptionHwndHandle>(), "AzOptionHwndHandle"), (Layout::new::<AzOptionHwndHandle>(), "AzOptionHwndHandle"));
        assert_eq!((Layout::new::<azul_core::geom::OptionLogicalPosition>(), "AzOptionLogicalPosition"), (Layout::new::<AzOptionLogicalPosition>(), "AzOptionLogicalPosition"));
        assert_eq!((Layout::new::<azul_core::geom::OptionPhysicalPositionI32>(), "AzOptionPhysicalPositionI32"), (Layout::new::<AzOptionPhysicalPositionI32>(), "AzOptionPhysicalPositionI32"));
        assert_eq!((Layout::new::<azul_core::window::OptionWindowIcon>(), "AzOptionWindowIcon"), (Layout::new::<AzOptionWindowIcon>(), "AzOptionWindowIcon"));
        assert_eq!((Layout::new::<azul_core::gl::OptionGlContextPtr>(), "AzOptionGlContextPtr"), (Layout::new::<AzOptionGlContextPtr>(), "AzOptionGlContextPtr"));
        assert_eq!((Layout::new::<azul_core::window::OptionX11Visual>(), "AzOptionX11Visual"), (Layout::new::<AzOptionX11Visual>(), "AzOptionX11Visual"));
        assert_eq!((Layout::new::<azul_css::corety::OptionI32>(), "AzOptionI32"), (Layout::new::<AzOptionI32>(), "AzOptionI32"));
        assert_eq!((Layout::new::<azul_css::corety::OptionF32>(), "AzOptionF32"), (Layout::new::<AzOptionF32>(), "AzOptionF32"));
        assert_eq!((Layout::new::<azul_core::window::OptionMouseCursorType>(), "AzOptionMouseCursorType"), (Layout::new::<AzOptionMouseCursorType>(), "AzOptionMouseCursorType"));
        assert_eq!((Layout::new::<azul_core::geom::OptionLogicalSize>(), "AzOptionLogicalSize"), (Layout::new::<AzOptionLogicalSize>(), "AzOptionLogicalSize"));
        assert_eq!((Layout::new::<azul_core::window::OptionChar>(), "AzOptionChar"), (Layout::new::<AzOptionChar>(), "AzOptionChar"));
        assert_eq!((Layout::new::<azul_core::window::OptionVirtualKeyCode>(), "AzOptionVirtualKeyCode"), (Layout::new::<AzOptionVirtualKeyCode>(), "AzOptionVirtualKeyCode"));
        assert_eq!((Layout::new::<azul_core::dom::OptionDom>(), "AzOptionDom"), (Layout::new::<AzOptionDom>(), "AzOptionDom"));
        assert_eq!((Layout::new::<azul_core::gl::OptionTexture>(), "AzOptionTexture"), (Layout::new::<AzOptionTexture>(), "AzOptionTexture"));
        assert_eq!((Layout::new::<azul_core::resources::OptionImageMask>(), "AzOptionImageMask"), (Layout::new::<AzOptionImageMask>(), "AzOptionImageMask"));
        assert_eq!((Layout::new::<azul_core::dom::OptionTabIndex>(), "AzOptionTabIndex"), (Layout::new::<AzOptionTabIndex>(), "AzOptionTabIndex"));
        assert_eq!((Layout::new::<azul_core::styled_dom::OptionTagId>(), "AzOptionTagId"), (Layout::new::<AzOptionTagId>(), "AzOptionTagId"));
        assert_eq!((Layout::new::<azul_core::task::OptionDuration>(), "AzOptionDuration"), (Layout::new::<AzOptionDuration>(), "AzOptionDuration"));
        assert_eq!((Layout::new::<azul_core::task::OptionInstant>(), "AzOptionInstant"), (Layout::new::<AzOptionInstant>(), "AzOptionInstant"));
        assert_eq!((Layout::new::<azul_core::gl::OptionUsize>(), "AzOptionUsize"), (Layout::new::<AzOptionUsize>(), "AzOptionUsize"));
        assert_eq!((Layout::new::<azul_css::OptionU8Vec>(), "AzOptionU8Vec"), (Layout::new::<AzOptionU8Vec>(), "AzOptionU8Vec"));
        assert_eq!((Layout::new::<azul_css::corety::OptionAzString>(), "AzOptionAzString"), (Layout::new::<AzOptionAzString>(), "AzOptionAzString"));
        assert_eq!((Layout::new::<azul_core::xml::ResultXmlXmlError>(), "AzResultXmlXmlError"), (Layout::new::<AzResultXmlXmlError>(), "AzResultXmlXmlError"));
        assert_eq!((Layout::new::<azul_layout::image::decode::ResultRawImageDecodeImageError>(), "AzResultRawImageDecodeImageError"), (Layout::new::<AzResultRawImageDecodeImageError>(), "AzResultRawImageDecodeImageError"));
        assert_eq!((Layout::new::<azul_layout::image::encode::ResultU8VecEncodeImageError>(), "AzResultU8VecEncodeImageError"), (Layout::new::<AzResultU8VecEncodeImageError>(), "AzResultU8VecEncodeImageError"));
        assert_eq!((Layout::new::<azul_core::svg::ResultSvgXmlNodeSvgParseError>(), "AzResultSvgXmlNodeSvgParseError"), (Layout::new::<AzResultSvgXmlNodeSvgParseError>(), "AzResultSvgXmlNodeSvgParseError"));
        assert_eq!((Layout::new::<azul_core::svg::ResultSvgSvgParseError>(), "AzResultSvgSvgParseError"), (Layout::new::<AzResultSvgSvgParseError>(), "AzResultSvgSvgParseError"));
        assert_eq!((Layout::new::<azul_core::xml::XmlError>(), "AzXmlError"), (Layout::new::<AzXmlError>(), "AzXmlError"));
        assert_eq!((Layout::new::<azul_core::xml::DuplicatedNamespaceError>(), "AzDuplicatedNamespaceError"), (Layout::new::<AzDuplicatedNamespaceError>(), "AzDuplicatedNamespaceError"));
        assert_eq!((Layout::new::<azul_core::xml::UnknownNamespaceError>(), "AzUnknownNamespaceError"), (Layout::new::<AzUnknownNamespaceError>(), "AzUnknownNamespaceError"));
        assert_eq!((Layout::new::<azul_core::xml::UnexpectedCloseTagError>(), "AzUnexpectedCloseTagError"), (Layout::new::<AzUnexpectedCloseTagError>(), "AzUnexpectedCloseTagError"));
        assert_eq!((Layout::new::<azul_core::xml::UnknownEntityReferenceError>(), "AzUnknownEntityReferenceError"), (Layout::new::<AzUnknownEntityReferenceError>(), "AzUnknownEntityReferenceError"));
        assert_eq!((Layout::new::<azul_core::xml::DuplicatedAttributeError>(), "AzDuplicatedAttributeError"), (Layout::new::<AzDuplicatedAttributeError>(), "AzDuplicatedAttributeError"));
        assert_eq!((Layout::new::<azul_core::xml::XmlParseError>(), "AzXmlParseError"), (Layout::new::<AzXmlParseError>(), "AzXmlParseError"));
        assert_eq!((Layout::new::<azul_core::xml::XmlTextError>(), "AzXmlTextError"), (Layout::new::<AzXmlTextError>(), "AzXmlTextError"));
        assert_eq!((Layout::new::<azul_core::xml::XmlStreamError>(), "AzXmlStreamError"), (Layout::new::<AzXmlStreamError>(), "AzXmlStreamError"));
        assert_eq!((Layout::new::<azul_core::xml::NonXmlCharError>(), "AzNonXmlCharError"), (Layout::new::<AzNonXmlCharError>(), "AzNonXmlCharError"));
        assert_eq!((Layout::new::<azul_core::xml::InvalidCharError>(), "AzInvalidCharError"), (Layout::new::<AzInvalidCharError>(), "AzInvalidCharError"));
        assert_eq!((Layout::new::<azul_core::xml::InvalidCharMultipleError>(), "AzInvalidCharMultipleError"), (Layout::new::<AzInvalidCharMultipleError>(), "AzInvalidCharMultipleError"));
        assert_eq!((Layout::new::<azul_core::xml::InvalidQuoteError>(), "AzInvalidQuoteError"), (Layout::new::<AzInvalidQuoteError>(), "AzInvalidQuoteError"));
        assert_eq!((Layout::new::<azul_core::xml::InvalidSpaceError>(), "AzInvalidSpaceError"), (Layout::new::<AzInvalidSpaceError>(), "AzInvalidSpaceError"));
        assert_eq!((Layout::new::<azul_core::xml::InvalidStringError>(), "AzInvalidStringError"), (Layout::new::<AzInvalidStringError>(), "AzInvalidStringError"));
        assert_eq!((Layout::new::<azul_core::xml::XmlTextPos>(), "AzXmlTextPos"), (Layout::new::<AzXmlTextPos>(), "AzXmlTextPos"));
        assert_eq!((Layout::new::<azul_core::resources::ImageCache>(), "AzImageCache"), (Layout::new::<AzImageCache>(), "AzImageCache"));
        assert_eq!((Layout::new::<azul_core::resources::FontCache>(), "AzFontCache"), (Layout::new::<AzFontCache>(), "AzFontCache"));
        assert_eq!((Layout::new::<azul_core::resources::DpiScaleFactor>(), "AzDpiScaleFactor"), (Layout::new::<AzDpiScaleFactor>(), "AzDpiScaleFactor"));
        assert_eq!((Layout::new::<azul_core::resources::AppTerminationBehavior>(), "AzAppTerminationBehavior"), (Layout::new::<AzAppTerminationBehavior>(), "AzAppTerminationBehavior"));
    }
}
