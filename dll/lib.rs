//! WARNING: autogenerated code for azul api version 1.0.0-alpha1

#![deny(improper_ctypes_definitions)]

// Header would be included here from _patches/dll/header.rs

pub mod widgets;
#[cfg(all(feature = "python-extension", feature = "link-dynamic", not(feature = "link-static")))]
pub mod python;


/// Pointer to rust-allocated `Box<StyleCursor>` struct
#[repr(C)] pub struct AzStyleCursor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WindowEventFilter>` struct
#[repr(C)] pub struct AzWindowEventFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for CssPropertyValue < StyleCursor >
pub type AzStyleCursorValue = AzCssPropertyValue<AzStyleCursor>;

/// Pointer to rust-allocated `Box<HidpiAdjustedBounds>` struct
#[repr(C)] pub struct AzHidpiAdjustedBounds { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WindowTheme>` struct
#[repr(C)] pub struct AzWindowTheme { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DpiScaleFactor>` struct
#[repr(C)] pub struct AzDpiScaleFactor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WindowCreateOptions>` struct
#[repr(C)] pub struct AzWindowCreateOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WasmWindowOptions>` struct
#[repr(C)] pub struct AzWasmWindowOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WindowFrame>` struct
#[repr(C)] pub struct AzWindowFrame { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WindowSize>` struct
#[repr(C)] pub struct AzWindowSize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LinuxWindowOptions>` struct
#[repr(C)] pub struct AzLinuxWindowOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<PlatformSpecificOptions>` struct
#[repr(C)] pub struct AzPlatformSpecificOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WindowType>` struct
#[repr(C)] pub struct AzWindowType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FullWindowState>` struct
#[repr(C)] pub struct AzFullWindowState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<MacWindowOptions>` struct
#[repr(C)] pub struct AzMacWindowOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<HwAcceleration>` struct
#[repr(C)] pub struct AzHwAcceleration { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<UserAttentionType>` struct
#[repr(C)] pub struct AzUserAttentionType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WindowFlags>` struct
#[repr(C)] pub struct AzWindowFlags { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WindowsWindowOptions>` struct
#[repr(C)] pub struct AzWindowsWindowOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Vsync>` struct
#[repr(C)] pub struct AzVsync { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Destructor callback for RefAny - called when the last reference is dropped
pub type AzRefAnyDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Main callback type for UI event handling
pub type AzCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// C-ABI wrapper over an `IFrameCallbackType`
#[repr(C)] pub struct AzIFrameCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for extern "C" fn (&mut RefAny , &mut IFrameCallbackInfo) -> IFrameCallbackReturn
pub type AzIFrameCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Return value for an IFrame rendering callback. # Dual Size Model IFrame callbacks return two size/offset pairs that enable lazy loading and virtualization: ## Actual Content (`scroll_size` + `scroll_offset`) The size and position of content that has **actually been rendered**. This is the content currently present in the returned DOM. **Example**: A table view might render only 20 visible rows out of 1000 total rows. ## Virtual Content (`virtual_scroll_size` + `virtual_scroll_offset`) The size and position of content that the IFrame **pretends to have**. This is used for scrollbar sizing and positioning, allowing the scrollbar to represent the full dataset even when only a subset is rendered. **Example**: The same table might pretend to have all 1000 rows for scrollbar sizing. # Conditional Re-invocation The IFrame callback will be re-invoked **only when necessary** to avoid performance overhead: 1. **Initial render** - First time the IFrame appears in the layout 2. **Parent DOM recreated** - The parent DOM was rebuilt from scratch (not just re-laid-out) 3. **Window resize (expansion only)** - Window grows and IFrame bounds exceed `scroll_size` - ✅ Only triggers **ONCE** per expansion (when bounds become uncovered) - Does **NOT** trigger when window shrinks (content is clipped, not re-rendered) - Does **NOT** trigger if expanded area is still within existing `scroll_size` 4. **Scroll near edge** - User scrolls within threshold (default 200px) of content edge - ✅ Only triggers **ONCE** per edge approach (prevents repeated calls) - Flag resets when: scroll moves away from edge, or callback returns expanded content 5. **Programmatic scroll** - `set_scroll_position()` scrolls beyond rendered `scroll_size` - Same constraints as rule #4 (threshold and once-per-edge) ## Window Resize Example ```text Frame 0: IFrame bounds = 800×600, scroll_size = 800×600 (perfectly covered) Frame 1: Window resizes to 1000×700 (larger) -> IFrame bounds = 1000×700 -> Bounds no longer fully covered by scroll_size (800×600) -> ✅ RE-INVOKE callback once Frame 2: Window resizes to 1100×800 (even larger) -> If callback returned scroll_size = 1100×800, fully covered again -> Do NOT re-invoke (content covers new bounds) -> If callback returned scroll_size = 1000×700, not fully covered -> ✅ RE-INVOKE again (new uncovered area) Frame 3: Window resizes to 900×650 (smaller) -> Bounds now smaller than scroll_size -> Do NOT re-invoke (content is just clipped by scrollbars) ``` ## Scroll Near Edge Example ```text scroll_size = 1000×2000 (width × height) Container = 800×600 Threshold = 200px Current scroll_offset = 0×0 User scrolls to scroll_offset = 0×1500: -> Bottom edge at 1500 + 600 = 2100 -> Within 200px of scroll_size.height (2000) -> Distance from edge: 2100 - 2000 = 100px < 200px -> ✅ RE-INVOKE callback to load more content Callback returns: -> New scroll_size = 1000×4000 (doubled) -> Flag reset (edge no longer near) -> User continues scrolling without re-invoke until near new edge ``` # Optimization: Returning None If the callback determines that no new content is needed (e.g., sufficient content has already been rendered ahead of the scroll position), it can return `OptionStyledDom::None` for the `dom` field. This signals the layout engine to keep using the current DOM and only update the scroll bounds. ```rust,ignore fn my_iframe_callback(data: &mut MyData, info: &mut IFrameCallbackInfo) -> IFrameCallbackReturn { let current_scroll = info.scroll_offset; // Check if we've already rendered content that covers this scroll position if data.already_rendered_area_covers(current_scroll, info.bounds.size) { return IFrameCallbackReturn { dom: OptionStyledDom::None, // Keep current DOM scroll_size: data.current_scroll_size, scroll_offset: data.current_scroll_offset, virtual_scroll_size: data.virtual_size, virtual_scroll_offset: LogicalPosition::zero(), }; } // Otherwise, render new content let new_dom = data.render_more_content(...); IFrameCallbackReturn { dom: OptionStyledDom::Some(new_dom), ... } } ``` # Example: Basic IFrame ```rust,ignore fn my_iframe_callback(data: &mut MyData, info: &mut IFrameCallbackInfo) -> IFrameCallbackReturn { let dom = Dom::body() .with_child(Dom::text("Hello from IFrame!")); let styled_dom = dom.style(Css::empty()); IFrameCallbackReturn { // The rendered content dom: OptionStyledDom::Some(styled_dom), // Size of actual rendered content (matches container) scroll_size: info.bounds.size, // Content starts at top-left scroll_offset: LogicalPosition::zero(), // Virtual size same as actual (no virtualization needed) virtual_scroll_size: info.bounds.size, virtual_scroll_offset: LogicalPosition::zero(), } } ``` # Example: Virtualized Table (Lazy Loading) ```rust,ignore struct TableData { total_rows: usize, // 1000 rows in full dataset row_height: f32, // 30px per row visible_rows: Vec<Row>, // Currently rendered rows (e.g., rows 0-29) first_visible_row: usize, // Index of first rendered row } fn table_iframe_callback(data: &mut TableData, info: &mut IFrameCallbackInfo) -> IFrameCallbackReturn { let container_height = info.bounds.size.height; let scroll_y = info.scroll_offset.y; // Calculate which rows should be visible based on scroll position let first_row = (scroll_y / data.row_height) as usize; let visible_count = (container_height / data.row_height).ceil() as usize + 2; // +2 for buffer // Fetch and render only the visible rows data.visible_rows = data.fetch_rows(first_row, visible_count); data.first_visible_row = first_row; let dom = Dom::body() .with_children( data.visible_rows.iter().map(|row| { Dom::div() .with_child(Dom::text(row.text.clone())) .with_inline_css_props(css_property_vec![ ("height", format!("{}px", data.row_height)), ]) }).collect() ); IFrameCallbackReturn { dom: OptionStyledDom::Some(dom.style(Css::empty())), // ACTUAL: Size of the ~30 rendered rows (e.g., 900px tall) scroll_size: LogicalSize::new( info.bounds.size.width, data.visible_rows.len() as f32 * data.row_height, ), // ACTUAL: Where these rows start in virtual space (e.g., y=300 if showing rows 10-30) scroll_offset: LogicalPosition::new( 0.0, first_row as f32 * data.row_height, ), // VIRTUAL: Size if all 1000 rows were rendered (30,000px tall) virtual_scroll_size: LogicalSize::new( info.bounds.size.width, data.total_rows as f32 * data.row_height, ), // VIRTUAL: Usually starts at origin virtual_scroll_offset: LogicalPosition::zero(), } } ``` In this example: - Only 20-30 rows are rendered at a time (~600-900px of DOM nodes) - The scrollbar represents all 1000 rows (30,000px virtual height) - When user scrolls near the bottom of rendered content, callback is re-invoked - New rows are rendered, and `scroll_size`/`scroll_offset` are updated - User experiences seamless scrolling through the full dataset # How the Layout Engine Uses These Values ## For Rendering - Uses `scroll_size` to determine the actual size of the IFrame's content box - Uses `scroll_offset` to position the content within the virtual space - Clips rendering to the visible viewport ## For Scrollbars - Uses `virtual_scroll_size` to calculate scrollbar thumb size and track length - Uses `virtual_scroll_offset` as the base for scroll position calculations - User sees scrollbar representing full virtual size, not just rendered content ## For Re-invocation Checks - Compares viewport bounds against `scroll_size` to detect edge proximity - Compares current scroll position against `scroll_offset + scroll_size` bounds - Triggers callback when user scrolls beyond the rendered content threshold
#[repr(C)] pub struct AzIFrameCallbackReturn { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Callback type that renders an OpenGL texture **IMPORTANT**: In azul-core, this is stored as `CoreRenderImageCallbackType = usize` to avoid circular dependencies. The actual function pointer is cast to usize for storage in the data model, then unsafely cast back to this type when invoked.
pub type AzRenderImageCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Core callback type - uses usize instead of function pointer to avoid circular dependencies. **IMPORTANT**: This is NOT actually a usize at runtime - it's a function pointer that is cast to usize for storage in the data model. When invoking the callback, this usize is unsafely cast back to the actual function pointer type: `extern "C" fn(&mut RefAny, &mut CallbackInfo) -> Update` This design allows azul-core to store callbacks without depending on azul-layout's CallbackInfo type. The actual function pointer type is defined in azul-layout as `CallbackType`.
pub type AzCoreCallbackType = Azusize<>;

/// Pointer to rust-allocated `Box<NumberInputOnFocusLostCallbackType>` struct
pub type AzNumberInputOnFocusLostCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputOnVirtualKeyDownCallbackType>` struct
pub type AzTextInputOnVirtualKeyDownCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ButtonOnClickCallbackType>` struct
pub type AzButtonOnClickCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CheckBoxOnToggleCallbackType>` struct
pub type AzCheckBoxOnToggleCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NumberInputOnValueChangeCallbackType>` struct
pub type AzNumberInputOnValueChangeCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewOnColumnClickCallbackType>` struct
pub type AzListViewOnColumnClickCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewOnRowClickCallbackType>` struct
pub type AzListViewOnRowClickCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColorInputOnValueChangeCallbackType>` struct
pub type AzColorInputOnValueChangeCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputOnTextInputCallbackType>` struct
pub type AzTextInputOnTextInputCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FontRefDestructorCallbackType>` struct
pub type AzFontRefDestructorCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputOnFocusLostCallbackType>` struct
pub type AzTextInputOnFocusLostCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TabOnClickCallbackType>` struct
pub type AzTabOnClickCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewOnLazyLoadScrollCallbackType>` struct
pub type AzListViewOnLazyLoadScrollCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FileInputOnPathChangeCallbackType>` struct
pub type AzFileInputOnPathChangeCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<IFrameCallbackInfo>` struct
#[repr(C)] pub struct AzIFrameCallbackInfo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CallbackInfo>` struct
#[repr(C)] pub struct AzCallbackInfo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RenderImageCallbackInfo>` struct
#[repr(C)] pub struct AzRenderImageCallbackInfo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<IFrameCallbackReason>` struct
#[repr(C)] pub struct AzIFrameCallbackReason { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InstantPtrCloneCallbackType>` struct
pub type AzInstantPtrCloneCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InstantPtrDestructorCallbackType>` struct
pub type AzInstantPtrDestructorCallbackType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `MarshaledLayoutCallbackType` struct
pub use azul_core::callbacks::MarshaledLayoutCallbackType as AzMarshaledLayoutCallbackTypeTT;
pub use AzMarshaledLayoutCallbackTypeTT as AzMarshaledLayoutCallbackType;
/// Clones the object
#[no_mangle] pub extern "C" fn AzMarshaledLayoutCallbackType_deepCopy(object: &AzMarshaledLayoutCallbackType) -> AzMarshaledLayoutCallbackType { object.clone() }

/// Pointer to rust-allocated `Box<MarshaledLayoutCallbackInner>` struct
#[repr(C)] pub struct AzMarshaledLayoutCallbackInner { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `LayoutCallbackType` struct
pub use azul_core::callbacks::LayoutCallbackType as AzLayoutCallbackTypeTT;
pub use AzLayoutCallbackTypeTT as AzLayoutCallbackType;
/// Clones the object
#[no_mangle] pub extern "C" fn AzLayoutCallbackType_deepCopy(object: &AzLayoutCallbackType) -> AzLayoutCallbackType { object.clone() }

/// Pointer to rust-allocated `Box<LayoutCallbackInner>` struct
#[repr(C)] pub struct AzLayoutCallbackInner { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<MarshaledLayoutCallback>` struct
#[repr(C)] pub struct AzMarshaledLayoutCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutCallback>` struct
#[repr(C)] pub struct AzLayoutCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// The document model, similar to HTML. This is a create-only structure, you don't actually read anything back from it. It's designed for ease of construction.
#[repr(C)] pub struct AzDom { pub ptr: *mut c_void }
/// Creates a generic block-level container.
/// 
/// **Accessibility**: Prefer semantic elements like `<article>`, `<section>`, `<nav>` when
/// applicable.
#[no_mangle] pub extern "C" fn AzDom_div () -> AzDom { let object: Dom = crate::azul_impl::Dom::div(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzDom { ptr } }
/// Equivalent to the Rust `Dom::swap_with_default()` function.
#[no_mangle] pub extern "C" fn AzDom_swapWithDefault (){ let object = unsafe { &mut *object };
    object.swap_with_default() }
/// Equivalent to the Rust `Dom::add_child()` function.
#[no_mangle] pub extern "C" fn AzDom_addChild (child: AzDom){ let object = unsafe { &mut *object };
    object.add_child(child) }
/// Equivalent to the Rust `Dom::set_children()` function.
#[no_mangle] pub extern "C" fn AzDom_setChildren (children: AzDomVec){ let object: &mut crate::azul_impl = unsafe { &mut *object };
    object.set_children(children) }
/// Equivalent to the Rust `Dom::copy_except_for_root()` function.
#[no_mangle] pub extern "C" fn AzDom_copyExceptForRoot (){ let object = unsafe { &mut *object };
    object.copy_except_for_root() }
/// Equivalent to the Rust `Dom::node_count()` function.
#[no_mangle] pub extern "C" fn AzDom_nodeCount () -> usize{ let object = unsafe { &*object };
    object.node_count() }
/// Equivalent to the Rust `Dom::style()` function.
#[no_mangle] pub extern "C" fn AzDom_style () -> AzStyledDom{ let object = unsafe { &mut *object };
    object.style(css) }
/// Equivalent to the Rust `Dom::with_children()` function.
#[no_mangle] pub extern "C" fn AzDom_withChildren (children: AzDomVec){ let object = unsafe { *object };
    object.with_children(children) }
/// Equivalent to the Rust `Dom::with_child()` function.
#[no_mangle] pub extern "C" fn AzDom_withChild (){ let object = unsafe { &mut *object };
    object.with_child(child) }
/// Equivalent to the Rust `Dom::with_tab_index()` function.
#[no_mangle] pub extern "C" fn AzDom_withTabIndex (tab_index: AzTabIndex){ let object = unsafe { *object };
    object.with_tab_index(tab_index) }
/// Equivalent to the Rust `Dom::with_dataset()` function.
#[no_mangle] pub extern "C" fn AzDom_withDataset (data: AzOptionRefAny){ let object = unsafe { *object };
    object.with_dataset(data) }
/// Equivalent to the Rust `Dom::with_ids_and_classes()` function.
#[no_mangle] pub extern "C" fn AzDom_withIdsAndClasses (ids_and_classes: AzIdOrClassVec){ let object = unsafe { *object };
    object.with_ids_and_classes(ids_and_classes) }
/// Adds an attribute to this DOM element.
/// **Example:**
/// ```ignore
/// Dom::div()
/// .with_attribute(AttributeType::Id("main".into()))
/// .with_attribute(AttributeType::AriaLabel("Main content".into()))
/// ```ignore
#[no_mangle] pub extern "C" fn AzDom_withAttribute (attr: AzAttributeType){ let object = unsafe { *object };
    object.with_attribute(attr) }
/// Adds multiple attributes to this DOM element.
#[no_mangle] pub extern "C" fn AzDom_withAttributes (attributes: AzAttributeVec){ let object = unsafe { *object };
    object.with_attributes(attributes) }
/// Equivalent to the Rust `Dom::with_callbacks()` function.
#[no_mangle] pub extern "C" fn AzDom_withCallbacks (callbacks: AzCoreCallbackDataVec){ let object = unsafe { *object };
    object.with_callbacks(callbacks) }
/// Equivalent to the Rust `Dom::with_inline_css_props()` function.
#[no_mangle] pub extern "C" fn AzDom_withInlineCssProps (inline_css_props: AzNodeDataInlineCssPropertyVec){ let object = unsafe { *object };
    object.with_inline_css_props(inline_css_props) }
/// Equivalent to the Rust `Dom::set_inline_style()` function.
#[no_mangle] pub extern "C" fn AzDom_setInlineStyle (){ let object: &mut crate::azul_impl = unsafe { &mut *object };
    object.set_inline_style(style) }
/// Equivalent to the Rust `Dom::with_inline_style()` function.
#[no_mangle] pub extern "C" fn AzDom_withInlineStyle (){ let object = unsafe { *object };
    object.with_inline_style(style) }
/// Equivalent to the Rust `Dom::with_context_menu()` function.
#[no_mangle] pub extern "C" fn AzDom_withContextMenu (context_menu: AzMenu){ let object = unsafe { *object };
    object.with_context_menu(context_menu) }
/// Equivalent to the Rust `Dom::with_menu_bar()` function.
#[no_mangle] pub extern "C" fn AzDom_withMenuBar (menu_bar: AzMenu){ let object = unsafe { *object };
    object.with_menu_bar(menu_bar) }
/// Equivalent to the Rust `Dom::with_clip_mask()` function.
#[no_mangle] pub extern "C" fn AzDom_withClipMask (clip_mask: AzImageMask){ let object = unsafe { *object };
    object.with_clip_mask(clip_mask) }
/// Equivalent to the Rust `Dom::with_accessibility_info()` function.
#[no_mangle] pub extern "C" fn AzDom_withAccessibilityInfo (accessibility_info: AzAccessibilityInfo){ let object = unsafe { *object };
    object.with_accessibility_info(accessibility_info) }
/// Equivalent to the Rust `Dom::fixup_children_estimated()` function.
#[no_mangle] pub extern "C" fn AzDom_fixupChildrenEstimated () -> usize{ let object = unsafe { &mut *object };
    object.fixup_children_estimated() }
/* Error: Type is not stack allocated! */

/// Represents all data associated with a single DOM node, such as its type, classes, IDs, callbacks, and inline styles.
#[repr(C)] pub struct AzNodeData { pub ptr: *mut c_void }
/// Creates an new, empty `NodeData` struct
#[no_mangle] pub extern "C" fn AzNodeData_new (node_type: AzNodeType) -> AzNodeData { let object: NodeData = azul_core::dom::NodeData::new(node_type); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzNodeData { ptr } }
/// Creates a new `NodeData` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `NodeData::body()` constructor.
#[no_mangle] pub extern "C" fn AzNodeData_body () -> AzNodeData { let object: NodeData = azul_core::dom::NodeData::body(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzNodeData { ptr } }
/// Creates a new `NodeData` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `NodeData::div()` constructor.
#[no_mangle] pub extern "C" fn AzNodeData_div () -> AzNodeData { let object: NodeData = azul_core::dom::NodeData::div(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzNodeData { ptr } }
/// Creates a new `NodeData` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `NodeData::br()` constructor.
#[no_mangle] pub extern "C" fn AzNodeData_br () -> AzNodeData { let object: NodeData = azul_core::dom::NodeData::br(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzNodeData { ptr } }
/// Creates a new `NodeData` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `NodeData::text()` constructor.
#[no_mangle] pub extern "C" fn AzNodeData_text (string: AzString) -> AzNodeData { let object: NodeData = azul_core::dom::NodeData::text(string); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzNodeData { ptr } }
/// Creates a new `NodeData` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `NodeData::image()` constructor.
#[no_mangle] pub extern "C" fn AzNodeData_image (image: AzImageRef) -> AzNodeData { let object: NodeData = azul_core::dom::NodeData::image(image); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzNodeData { ptr } }
/// Creates a new `NodeData` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `NodeData::iframe()` constructor.
#[no_mangle] pub extern "C" fn AzNodeData_iframe (data: AzRefAny, callback: AzIFrameCallbackType) -> AzNodeData { let object: NodeData = azul_core::dom::NodeData::iframe(data, callback); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzNodeData { ptr } }
/// Equivalent to the Rust `NodeData::set_node_type()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setNodeType (nodedata: &mut AzNodeData, node_type: AzNodeType){ nodedata.set_node_type(node_type) }
/// Equivalent to the Rust `NodeData::with_node_type()` function.
#[no_mangle] pub extern "C" fn AzNodeData_withNodeType (nodedata: &mut AzNodeData, node_type: AzNodeType) -> AzNodeData{ let mut nodedata = nodedata.swap_with_default(); nodedata.set_node_type(node_type); nodedata }
/// Equivalent to the Rust `NodeData::set_dataset()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setDataset (nodedata: &mut AzNodeData, dataset: AzRefAny){ nodedata.set_dataset(Some(dataset).into()) }
/// Equivalent to the Rust `NodeData::with_dataset()` function.
#[no_mangle] pub extern "C" fn AzNodeData_withDataset (nodedata: &mut AzNodeData, dataset: AzRefAny) -> AzNodeData{ let mut nodedata = nodedata.swap_with_default(); nodedata.set_dataset(Some(dataset).into()); nodedata }
/// Equivalent to the Rust `NodeData::set_ids_and_classes()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setIdsAndClasses (nodedata: &mut AzNodeData, ids_and_classes: AzIdOrClassVec){ nodedata.set_ids_and_classes(ids_and_classes) }
/// Equivalent to the Rust `NodeData::with_ids_and_classes()` function.
#[no_mangle] pub extern "C" fn AzNodeData_withIdsAndClasses (nodedata: &mut AzNodeData, ids_and_classes: AzIdOrClassVec) -> AzNodeData{ let mut nodedata = nodedata.swap_with_default(); nodedata.set_ids_and_classes(ids_and_classes); nodedata }
/// Adds a callback this DOM (potentially heap-allocates in Rust code)
#[no_mangle] pub extern "C" fn AzNodeData_addCallback (nodedata: &mut AzNodeData, event: AzEventFilter, data: AzRefAny, callback: AzCallbackType){ nodedata.add_callback(event, data, callback as usize) }
/// Same as add_child, but as a builder method.
#[no_mangle] pub extern "C" fn AzNodeData_withCallback (nodedata: &mut AzNodeData, event: AzEventFilter, data: AzRefAny, callback: AzCallbackType) -> AzNodeData{ let mut nodedata = nodedata.swap_with_default(); nodedata.add_callback(event, data, callback as usize); nodedata }
/// Equivalent to the Rust `NodeData::set_callbacks()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setCallbacks (nodedata: &mut AzNodeData, callbacks: AzCoreCallbackDataVec){ nodedata.set_callbacks(callbacks) }
/// Equivalent to the Rust `NodeData::with_callbacks()` function.
#[no_mangle] pub extern "C" fn AzNodeData_withCallbacks (nodedata: &mut AzNodeData, callbacks: AzCoreCallbackDataVec) -> AzNodeData{ let mut nodedata = nodedata.swap_with_default(); nodedata.set_callbacks(callbacks); nodedata }
/// Equivalent to the Rust `NodeData::set_inline_css_props()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setInlineCssProps (nodedata: &mut AzNodeData, css_properties: AzNodeDataInlineCssPropertyVec){ nodedata.set_inline_css_props(css_properties) }
/// Equivalent to the Rust `NodeData::with_inline_css_props()` function.
#[no_mangle] pub extern "C" fn AzNodeData_withInlineCssProps (nodedata: &mut AzNodeData, css_properties: AzNodeDataInlineCssPropertyVec) -> AzNodeData{ let mut nodedata = nodedata.swap_with_default(); nodedata.set_inline_css_props(css_properties); nodedata }
/// Equivalent to the Rust `NodeData::set_inline_style()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setInlineStyle (nodedata: &mut AzNodeData, style: AzString){ nodedata.set_inline_css_props(nodedata.get_inline_css_props().with_append(azul_core::dom::NodeDataInlineCssPropertyVec::parse_normal(style.as_str()))) }
/// Equivalent to the Rust `NodeData::set_inline_hover_style()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setInlineHoverStyle (nodedata: &mut AzNodeData, style: AzString){ nodedata.set_inline_css_props(nodedata.get_inline_css_props().with_append(azul_core::dom::NodeDataInlineCssPropertyVec::parse_hover(style.as_str()))) }
/// Equivalent to the Rust `NodeData::set_inline_active_style()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setInlineActiveStyle (nodedata: &mut AzNodeData, style: AzString){ nodedata.set_inline_css_props(nodedata.get_inline_css_props().with_append(azul_core::dom::NodeDataInlineCssPropertyVec::parse_active(style.as_str()))) }
/// Equivalent to the Rust `NodeData::set_inline_focus_style()` function.
#[no_mangle] pub extern "C" fn AzNodeData_setInlineFocusStyle (nodedata: &mut AzNodeData, style: AzString){ nodedata.set_inline_css_props(nodedata.get_inline_css_props().with_append(azul_core::dom::NodeDataInlineCssPropertyVec::parse_focus(style.as_str()))) }
/// Sets the `extra.clip_mask` field for this node
#[no_mangle] pub extern "C" fn AzNodeData_setClipMask (nodedata: &mut AzNodeData, image_mask: AzImageMask){ nodedata.set_clip_mask(image_mask) }
/// Sets the tab index for this node
#[no_mangle] pub extern "C" fn AzNodeData_setTabIndex (nodedata: &mut AzNodeData, tab_index: AzTabIndex){ nodedata.set_tab_index(tab_index) }
/// Sets accessibility attributes for this node
#[no_mangle] pub extern "C" fn AzNodeData_setAccessibilityInfo (nodedata: &mut AzNodeData, accessibility_info: AzAccessibilityInfo){ nodedata.set_accessibility_info(accessibility_info) }
/// Adds a (native) menu bar: If this node is the root node the menu bar will be added to the window, else it will be displayed using the width and position of the bounding rectangle
#[no_mangle] pub extern "C" fn AzNodeData_setMenuBar (nodedata: &mut AzNodeData, menu_bar: AzMenu){ nodedata.set_menu_bar(menu_bar) }
/// Signalizes that this node has a (native) context-aware menu. If set, the user can left-click the node to open the menu
#[no_mangle] pub extern "C" fn AzNodeData_setContextMenu (nodedata: &mut AzNodeData, context_menu: AzMenu){ nodedata.set_context_menu(context_menu) }
/// Calculates the hash of this node (note: in order to be truly unique, you also have to hash the DOM and Node ID).
#[no_mangle] pub extern "C" fn AzNodeData_hash (nodedata: &AzNodeData) -> u64{ nodedata.calculate_node_data_hash().0 }
/* Error: Type is not stack allocated! */

/// List of core DOM node types built into `azul`. This enum defines the building blocks of the UI, similar to HTML tags.
#[repr(C)] pub struct AzNodeType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Holds information about a UI element for accessibility purposes (e.g., screen readers). This is a wrapper for platform-specific accessibility APIs like MSAA.
#[repr(C)] pub struct AzAccessibilityInfo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Defines the element's purpose for accessibility APIs, informing assistive technologies like screen readers about the function of a UI element. Each variant corresponds to a standard control type or UI structure. For more details, see the [MSDN Role Constants page](https://docs.microsoft.com/en-us/windows/winauto/object-roles).
#[repr(C)] pub struct AzAccessibilityRole { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Defines the current state of an element for accessibility APIs (e.g., focused, checked). These states provide dynamic information to assistive technologies about the element's condition. See the [MSDN State Constants page](https://docs.microsoft.com/en-us/windows/win32/winauto/object-state-constants) for more details.
#[repr(C)] pub struct AzAccessibilityState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Determines the behavior of an element in sequential focus navigation
#[repr(C)] pub struct AzTabIndex { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents an inline CSS property attached to a node for a specific interaction state. This allows defining styles for `:hover`, `:focus`, etc., directly on a DOM node.
#[repr(C)] pub struct AzNodeDataInlineCssProperty { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// A unique, runtime-generated identifier for a single `Dom` instance.
#[repr(C)] pub struct AzDomId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// A UUID for a DOM node within a `LayoutWindow`.
#[repr(C)] pub struct AzDomNodeId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AccessibilityAction>` struct
#[repr(C)] pub struct AzAccessibilityAction { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewOnColumnClickCallback>` struct
#[repr(C)] pub struct AzListViewOnColumnClickCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TagIdToNodeIdMapping>` struct
#[repr(C)] pub struct AzTagIdToNodeIdMapping { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CoreCallback>` struct
#[repr(C)] pub struct AzCoreCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeHierarchyItemId>` struct
#[repr(C)] pub struct AzNodeHierarchyItemId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgXmlNode>` struct
#[repr(C)] pub struct AzSvgXmlNode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CoreCallbackData>` struct
#[repr(C)] pub struct AzCoreCallbackData { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewOnRowClickCallback>` struct
#[repr(C)] pub struct AzListViewOnRowClickCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgSimpleNode>` struct
#[repr(C)] pub struct AzSvgSimpleNode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CoreMenuCallback>` struct
#[repr(C)] pub struct AzCoreMenuCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AttributeNameValue>` struct
#[repr(C)] pub struct AzAttributeNameValue { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Tag of an XML node, such as the "button" in `<button>Hello</button>`.
pub type AzXmlTagName = AzString<>;

/// Pointer to rust-allocated `Box<CheckBoxOnToggleCallback>` struct
#[repr(C)] pub struct AzCheckBoxOnToggleCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TabOnClickCallback>` struct
#[repr(C)] pub struct AzTabOnClickCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ParentWithNodeDepth>` struct
#[repr(C)] pub struct AzParentWithNodeDepth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewOnLazyLoadScrollCallback>` struct
#[repr(C)] pub struct AzListViewOnLazyLoadScrollCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AttributeType>` struct
#[repr(C)] pub struct AzAttributeType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<XmlNodeChild>` struct
#[repr(C)] pub struct AzXmlNodeChild { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeHierarchyItem>` struct
#[repr(C)] pub struct AzNodeHierarchyItem { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ButtonOnClickCallback>` struct
#[repr(C)] pub struct AzButtonOnClickCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<XmlNode>` struct
#[repr(C)] pub struct AzXmlNode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TagId>` struct
#[repr(C)] pub struct AzTagId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Attributes of an XML node, such as `["color" => "blue"]` in `<button color="blue" />`.
pub type AzXmlAttributeMap = AzStringPairVec<>;

/// Pointer to rust-allocated `Box<NodeTypeTag>` struct
#[repr(C)] pub struct AzNodeTypeTag { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VertexAttributeType>` struct
#[repr(C)] pub struct AzVertexAttributeType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VertexAttribute>` struct
#[repr(C)] pub struct AzVertexAttribute { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InstantPtrCloneCallback>` struct
#[repr(C)] pub struct AzInstantPtrCloneCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InstantPtrDestructorCallback>` struct
#[repr(C)] pub struct AzInstantPtrDestructorCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TouchState>` struct
#[repr(C)] pub struct AzTouchState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DebugState>` struct
#[repr(C)] pub struct AzDebugState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Callback>` struct
#[repr(C)] pub struct AzCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<MouseState>` struct
#[repr(C)] pub struct AzMouseState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<KeyboardState>` struct
#[repr(C)] pub struct AzKeyboardState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a menu (context menu, dropdown menu, or application menu). A menu consists of a list of items that can be displayed as a popup or attached to a window's menu bar. Modeled after the Windows API for cross-platform consistency. # Fields * `items` - The menu items to display * `position` - Where the menu should appear (for popups) * `context_mouse_btn` - Which mouse button triggers the context menu
#[repr(C)] pub struct AzMenu { pub ptr: *mut c_void }
/// Creates an new, empty Menu
#[no_mangle] pub extern "C" fn AzMenu_new (items: AzMenuItemVec) -> AzMenu { let object: Menu = azul_core::menu::Menu::new(items); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzMenu { ptr } }
/// Sets the popup position of the menu, ignored on menu bars
#[no_mangle] pub extern "C" fn AzMenu_setPopupPosition (menu: &mut AzMenu, position: AzMenuPopupPosition){ menu.position = position; }
/// Sets the popup position of the menu, ignored on menu bars (builder method)
#[no_mangle] pub extern "C" fn AzMenu_withPopupPosition (menu: &mut AzMenu, position: AzMenuPopupPosition) -> AzMenu{ let mut menu = menu.swap_with_default(); menu.position = position; menu }
/* Error: Type is not stack allocated! */

/// Determines whether this context menu should pop up on a left, right or middle click
#[repr(C)] pub struct AzContextMenuMouseButton { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Specifies where a popup menu should appear relative to the cursor or clicked element. This positioning information is ignored for application-level menus (menu bars) and only applies to context menus and dropdowns.
#[repr(C)] pub struct AzMenuPopupPosition { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a single item in a menu. Menu items can be regular text items with labels and callbacks, visual separators, or line breaks for horizontal menu layouts.
#[repr(C)] pub struct AzMenuItem { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// A menu item with a text label and optional features. `StringMenuItem` represents a clickable menu entry that can have: - A text label - An optional keyboard accelerator (e.g., Ctrl+C) - An optional callback function - An optional icon (checkbox or image) - A state (normal, greyed, or disabled) - Child menu items (for sub-menus) # Examples ```rust,no_run use azul_core::menu::StringMenuItem; use azul_css::AzString; let item = StringMenuItem::new(AzString::from_const_str("Copy")); ```
#[repr(C)] pub struct AzStringMenuItem { pub ptr: *mut c_void }
/// Creates a new menu item
#[no_mangle] pub extern "C" fn AzStringMenuItem_new (label: AzString) -> AzStringMenuItem { let object: StringMenuItem = azul_core::menu::StringMenuItem::new(label); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzStringMenuItem { ptr } }
/// Adds a callback to the menu item
#[no_mangle] pub extern "C" fn AzStringMenuItem_setCallback (stringmenuitem: &mut AzStringMenuItem, data: AzRefAny, callback: AzCallbackType){ stringmenuitem.callback = azul_core::menu::OptionCoreMenuCallback::Some(azul_core::menu::CoreMenuCallback { data, callback: azul_core::callbacks::CoreCallback { cb: callback as usize } }); }
/// Adds a callback to the menu item
#[no_mangle] pub extern "C" fn AzStringMenuItem_withCallback (stringmenuitem: &mut AzStringMenuItem, data: AzRefAny, callback: AzCallbackType) -> AzStringMenuItem{ let mut stringmenuitem = stringmenuitem.swap_with_default(); stringmenuitem.callback = azul_core::menu::OptionCoreMenuCallback::Some(azul_core::menu::CoreMenuCallback { data, callback: azul_core::callbacks::CoreCallback { cb: callback as usize } }); stringmenuitem }
/// Adds a single child submenu to the current menu
#[no_mangle] pub extern "C" fn AzStringMenuItem_addChild (stringmenuitem: &mut AzStringMenuItem, child: AzMenuItem){ let mut m = stringmenuitem.children.clone().into_library_owned_vec(); m.push(child); stringmenuitem.children = m.into(); }
/// Adds a single child submenu to the current menu
#[no_mangle] pub extern "C" fn AzStringMenuItem_withChild (stringmenuitem: &mut AzStringMenuItem, child: AzMenuItem) -> AzStringMenuItem{ let mut stringmenuitem = stringmenuitem.swap_with_default(); let mut m = stringmenuitem.children.clone().into_library_owned_vec(); m.push(child); stringmenuitem.children = m.into(); stringmenuitem }
/// Sets the children of this menu
#[no_mangle] pub extern "C" fn AzStringMenuItem_setChildren (stringmenuitem: &mut AzStringMenuItem, children: AzMenuItemVec){ stringmenuitem.children = children; }
/// Adds a child submenu to the current menu
#[no_mangle] pub extern "C" fn AzStringMenuItem_withChildren (stringmenuitem: &mut AzStringMenuItem, children: AzMenuItemVec) -> AzStringMenuItem{ let mut stringmenuitem = stringmenuitem.swap_with_default(); stringmenuitem.children = children; stringmenuitem }
/* Error: Type is not stack allocated! */

/// Optional icon displayed next to a menu item. Icons can be either: - A checkbox (checked or unchecked) - A custom image (typically 16x16 pixels)
#[repr(C)] pub struct AzMenuItemIcon { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Describes the interactive state of a menu item. Menu items can be in different states that affect their appearance and behavior: - Normal items are clickable and render normally - Greyed items are visually disabled (greyed out) and non-clickable - Disabled items are non-clickable but retain normal appearance
#[repr(C)] pub struct AzMenuItemState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// One block of rules that applies a bunch of rules to a "path" in the style, i.e. `div#myid.myclass -> { ("justify-content", "center") }`
#[repr(C)] pub struct AzCssRuleBlock { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents one parsed CSS key-value pair, such as `"width: 20px"` => `CssProperty::Width(LayoutWidth::px(20.0))`
#[repr(C)] pub struct AzCssProperty { pub ptr: *mut c_void }
/// Returns the key of the CSS property as a string, i.e. `background`
#[no_mangle] pub extern "C" fn AzCssProperty_getKeyString (cssproperty: &AzCssProperty) -> AzString{ cssproperty.key().into() }
/// Returns the value of the CSS property as a string, i.e. `linear-gradient(red, blue)`
#[no_mangle] pub extern "C" fn AzCssProperty_getValueString (cssproperty: &AzCssProperty) -> AzString{ cssproperty.value().into() }
/// Returns the CSS key-value pair as a string, i.e. `background: linear-gradient(red, blue)`
#[no_mangle] pub extern "C" fn AzCssProperty_getKeyValueString (cssproperty: &AzCssProperty) -> AzString{ cssproperty.format_css().into() }
/// Interpolates two CSS properties given a value `t` ranging from 0.0 to 1.0. The interpolation function can be set on the `context` (`Ease`, `Linear`, etc.).
#[no_mangle] pub extern "C" fn AzCssProperty_interpolate (cssproperty: &AzCssProperty, other: AzCssProperty, t: f32, context: AzInterpolateResolver) -> AzCssProperty{ cssproperty.interpolate(&other, t, &context) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssNthChildSelector>` struct
#[repr(C)] pub struct AzCssNthChildSelector { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssNthChildPattern>` struct
#[repr(C)] pub struct AzCssNthChildPattern { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Stylesheet>` struct
#[repr(C)] pub struct AzStylesheet { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Css stylesheet - contains a parsed CSS stylesheet in "rule blocks", i.e. blocks of key-value pairs associated with a selector path.
#[repr(C)] pub struct AzCss { pub ptr: *mut c_void }
/// Returns an empty CSS style
#[no_mangle] pub extern "C" fn AzCss_empty () -> AzCss { let object: Css = azul_css::css::Css::empty(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzCss { ptr } }
/// Returns a CSS style parsed from a `String`
#[no_mangle] pub extern "C" fn AzCss_fromString (s: AzString) -> AzCss { let object: Css = azul_css::css::Css::from_string(s); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzCss { ptr } }
/* Error: Type is not stack allocated! */

/// Contains one parsed `key: value` pair, static or dynamic
#[repr(C)] pub struct AzCssDeclaration { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// A `DynamicCssProperty` is a type of css property that can be changed on possibly every frame by the Rust code - for example to implement an `On::Hover` behaviour. The syntax for such a property looks like this: ```no_run,ignore #my_div { padding: var(--my_dynamic_property_id, 400px); } ``` Azul will register a dynamic property with the key "my_dynamic_property_id" and the default value of 400px. If the property gets overridden during one frame, the overridden property takes precedence. At runtime the style is immutable (which is a performance optimization - if we can assume that the property never changes at runtime), we can do some optimizations on it. Dynamic style properties can also be used for animations and conditional styles (i.e. `hover`, `focus`, etc.), thereby leading to cleaner code, since all of these special cases now use one single API.
#[repr(C)] pub struct AzDynamicCssProperty { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents an animation timing function.
#[repr(C)] pub struct AzAnimationInterpolationFunction { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// u8-based color, range 0 to 255 (similar to webrenders ColorU)
#[repr(C)] pub struct AzColorU { pub ptr: *mut c_void }
/// Creates a new `ColorU` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `ColorU::from_str()` constructor.
#[no_mangle] pub extern "C" fn AzColorU_fromStr (string: AzString) -> AzColorU { let object: ColorU = azul_css::props::basic::color::parse_css_color(string.as_str()).ok().unwrap_or(azul_css::props::basic::color::ColorU::BLACK); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzColorU { ptr } }
/// Creates a new `ColorU` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `ColorU::transparent()` constructor.
#[no_mangle] pub extern "C" fn AzColorU_transparent () -> AzColorU { let object: ColorU = azul_css::props::basic::color::ColorU::TRANSPARENT; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzColorU { ptr } }
/// Creates a new `ColorU` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `ColorU::white()` constructor.
#[no_mangle] pub extern "C" fn AzColorU_white () -> AzColorU { let object: ColorU = azul_css::props::basic::color::ColorU::WHITE; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzColorU { ptr } }
/// Creates a new `ColorU` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `ColorU::black()` constructor.
#[no_mangle] pub extern "C" fn AzColorU_black () -> AzColorU { let object: ColorU = azul_css::props::basic::color::ColorU::BLACK; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzColorU { ptr } }
/// Equivalent to the Rust `ColorU::to_hash()` function.
#[no_mangle] pub extern "C" fn AzColorU_toHash (coloru: &AzColorU) -> AzString{ coloru.to_hash().into() }
/* Error: Type is not stack allocated! */

/// Enum representing the metric associated with a number (px, pt, em, etc.)
#[repr(C)] pub struct AzSizeMetric { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<PixelValue>` struct
#[repr(C)] pub struct AzPixelValue { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Same as PixelValue, but doesn't allow a "%" sign
#[repr(C)] pub struct AzPixelValueNoPercent { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// What direction should a `box-shadow` be clipped in (inset or outset).
#[repr(C)] pub struct AzBoxShadowClipMode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `box-shadow` or `text-shadow` property.
#[repr(C)] pub struct AzStyleBoxShadow { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `mix-blend-mode` attribute, which determines how an element's content should blend with the content of the element's parent.
#[repr(C)] pub struct AzStyleMixBlendMode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleFilter>` struct
#[repr(C)] pub struct AzStyleFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBlur>` struct
#[repr(C)] pub struct AzStyleBlur { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleColorMatrix>` struct
#[repr(C)] pub struct AzStyleColorMatrix { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleFilterOffset>` struct
#[repr(C)] pub struct AzStyleFilterOffset { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleCompositeFilter>` struct
#[repr(C)] pub struct AzStyleCompositeFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents an `align-content` attribute, which aligns a flex container's lines within it when there is extra space in the cross-axis. Default: `Stretch`
#[repr(C)] pub struct AzLayoutAlignContent { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents an `align-items` attribute, which defines the default behavior for how flex items are laid out along the cross axis on the current line. Default: `Stretch`
#[repr(C)] pub struct AzLayoutAlignItems { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutBottom>` struct
#[repr(C)] pub struct AzLayoutBottom { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `box-sizing` attribute
#[repr(C)] pub struct AzLayoutBoxSizing { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `flex-direction` attribute, which establishes the main-axis, thus defining the direction flex items are placed in the flex container. Default: `Row`
#[repr(C)] pub struct AzLayoutFlexDirection { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `display` CSS property value
#[repr(C)] pub struct AzLayoutDisplay { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `flex-grow` attribute, which dictates what proportion of the remaining space in the flex container should be assigned to the item. Default: 0
#[repr(C)] pub struct AzLayoutFlexGrow { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `flex-shrink` attribute, which dictates what proportion of the negative space in the flex container should be removed from the item. Default: 1
#[repr(C)] pub struct AzLayoutFlexShrink { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `float` attribute
#[repr(C)] pub struct AzLayoutFloat { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutHeight>` struct
#[repr(C)] pub struct AzLayoutHeight { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `justify-content` attribute, which defines the alignment along the main axis. Default: `Start` (flex-start)
#[repr(C)] pub struct AzLayoutJustifyContent { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutLeft>` struct
#[repr(C)] pub struct AzLayoutLeft { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Layout margin bottom value
#[repr(C)] pub struct AzLayoutMarginBottom { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Layout margin left value
#[repr(C)] pub struct AzLayoutMarginLeft { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Layout margin right value
#[repr(C)] pub struct AzLayoutMarginRight { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Layout margin top value
#[repr(C)] pub struct AzLayoutMarginTop { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutMaxHeight>` struct
#[repr(C)] pub struct AzLayoutMaxHeight { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutMaxWidth>` struct
#[repr(C)] pub struct AzLayoutMaxWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutMinHeight>` struct
#[repr(C)] pub struct AzLayoutMinHeight { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutMinWidth>` struct
#[repr(C)] pub struct AzLayoutMinWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Layout padding bottom value
#[repr(C)] pub struct AzLayoutPaddingBottom { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutPaddingLeft>` struct
#[repr(C)] pub struct AzLayoutPaddingLeft { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Layout padding right value
#[repr(C)] pub struct AzLayoutPaddingRight { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Layout padding top value
#[repr(C)] pub struct AzLayoutPaddingTop { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `position` attribute - default: `Static`
#[repr(C)] pub struct AzLayoutPosition { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutRight>` struct
#[repr(C)] pub struct AzLayoutRight { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutTop>` struct
#[repr(C)] pub struct AzLayoutTop { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutWidth>` struct
#[repr(C)] pub struct AzLayoutWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `flex-wrap` attribute, which determines whether flex items are forced onto one line or can wrap onto multiple lines. Default: `NoWrap`
#[repr(C)] pub struct AzLayoutFlexWrap { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents an `overflow-x` or `overflow-y` property. Determines what to do when content overflows an element's box.
#[repr(C)] pub struct AzLayoutOverflow { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper around an f32 value that is internally casted to an isize, in order to provide hash-ability (to avoid numerical instability).
#[repr(C)] pub struct AzFloatValue { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper around FloatValue, represents a percentage instead of just being a regular floating-point value, i.e `5` = `5%`
#[repr(C)] pub struct AzPercentageValue { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Enum representing the metric associated with an angle (deg, rad, etc.)
#[repr(C)] pub struct AzAngleMetric { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// FloatValue, but associated with a certain metric (i.e. deg, rad, etc.)
#[repr(C)] pub struct AzAngleValue { pub ptr: *mut c_void }
/// Equivalent to the Rust `AngleValue::get_degrees()` function.
#[no_mangle] pub extern "C" fn AzAngleValue_getDegrees (anglevalue: &AzAngleValue) -> f32{ anglevalue.to_degrees() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NormalizedLinearColorStop>` struct
#[repr(C)] pub struct AzNormalizedLinearColorStop { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NormalizedRadialColorStop>` struct
#[repr(C)] pub struct AzNormalizedRadialColorStop { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DirectionCorner>` struct
#[repr(C)] pub struct AzDirectionCorner { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DirectionCorners>` struct
#[repr(C)] pub struct AzDirectionCorners { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// CSS direction (necessary for gradients). Can either be a fixed angle or a direction ("to right" / "to left", etc.).
#[repr(C)] pub struct AzDirection { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LinearGradient>` struct
#[repr(C)] pub struct AzLinearGradient { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Shape>` struct
#[repr(C)] pub struct AzShape { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RadialGradientSize>` struct
#[repr(C)] pub struct AzRadialGradientSize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RadialGradient>` struct
#[repr(C)] pub struct AzRadialGradient { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ConicGradient>` struct
#[repr(C)] pub struct AzConicGradient { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBackgroundContent>` struct
#[repr(C)] pub struct AzStyleBackgroundContent { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<BackgroundPositionHorizontal>` struct
#[repr(C)] pub struct AzBackgroundPositionHorizontal { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<BackgroundPositionVertical>` struct
#[repr(C)] pub struct AzBackgroundPositionVertical { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBackgroundPosition>` struct
#[repr(C)] pub struct AzStyleBackgroundPosition { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBackgroundRepeat>` struct
#[repr(C)] pub struct AzStyleBackgroundRepeat { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBackgroundSize>` struct
#[repr(C)] pub struct AzStyleBackgroundSize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderBottomColor>` struct
#[repr(C)] pub struct AzStyleBorderBottomColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderBottomLeftRadius>` struct
#[repr(C)] pub struct AzStyleBorderBottomLeftRadius { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderBottomRightRadius>` struct
#[repr(C)] pub struct AzStyleBorderBottomRightRadius { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Style of a `border`: solid, double, dash, ridge, etc.
#[repr(C)] pub struct AzBorderStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderBottomStyle>` struct
#[repr(C)] pub struct AzStyleBorderBottomStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutBorderBottomWidth>` struct
#[repr(C)] pub struct AzLayoutBorderBottomWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderLeftColor>` struct
#[repr(C)] pub struct AzStyleBorderLeftColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderLeftStyle>` struct
#[repr(C)] pub struct AzStyleBorderLeftStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutBorderLeftWidth>` struct
#[repr(C)] pub struct AzLayoutBorderLeftWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderRightColor>` struct
#[repr(C)] pub struct AzStyleBorderRightColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderRightStyle>` struct
#[repr(C)] pub struct AzStyleBorderRightStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutBorderRightWidth>` struct
#[repr(C)] pub struct AzLayoutBorderRightWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderTopColor>` struct
#[repr(C)] pub struct AzStyleBorderTopColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderTopLeftRadius>` struct
#[repr(C)] pub struct AzStyleBorderTopLeftRadius { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderTopRightRadius>` struct
#[repr(C)] pub struct AzStyleBorderTopRightRadius { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBorderTopStyle>` struct
#[repr(C)] pub struct AzStyleBorderTopStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutBorderTopWidth>` struct
#[repr(C)] pub struct AzLayoutBorderTopWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Holds info necessary for layouting / styling -webkit-scrollbar properties.
#[repr(C)] pub struct AzScrollbarInfo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Scrollbar style for both horizontal and vertical scrollbars.
#[repr(C)] pub struct AzScrollbarStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `font-family` attribute
#[repr(C)] pub struct AzStyleFontFamily { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `font-size` attribute
#[repr(C)] pub struct AzStyleFontSize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `letter-spacing` attribute
#[repr(C)] pub struct AzStyleLetterSpacing { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `line-height` attribute
#[repr(C)] pub struct AzStyleLineHeight { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `tab-width` attribute
#[repr(C)] pub struct AzStyleTabWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents an `opacity` attribute, a value from 0.0 to 1.0.
#[repr(C)] pub struct AzStyleOpacity { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `transform-origin` attribute
#[repr(C)] pub struct AzStyleTransformOrigin { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `backface-visibility` attribute
#[repr(C)] pub struct AzStyleBackfaceVisibility { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents one component of a `transform` attribute
#[repr(C)] pub struct AzStyleTransform { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformMatrix2D>` struct
#[repr(C)] pub struct AzStyleTransformMatrix2D { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformMatrix3D>` struct
#[repr(C)] pub struct AzStyleTransformMatrix3D { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformTranslate2D>` struct
#[repr(C)] pub struct AzStyleTransformTranslate2D { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformTranslate3D>` struct
#[repr(C)] pub struct AzStyleTransformTranslate3D { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformRotate3D>` struct
#[repr(C)] pub struct AzStyleTransformRotate3D { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformScale2D>` struct
#[repr(C)] pub struct AzStyleTransformScale2D { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformScale3D>` struct
#[repr(C)] pub struct AzStyleTransformScale3D { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformSkew2D>` struct
#[repr(C)] pub struct AzStyleTransformSkew2D { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Horizontal text alignment enum (left, center, right) - default: `Left`
#[repr(C)] pub struct AzStyleTextAlign { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `color` attribute.
#[repr(C)] pub struct AzStyleTextColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `word-spacing` attribute
#[repr(C)] pub struct AzStyleWordSpacing { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for CssPropertyValue < StyleBoxShadow >
pub type AzStyleBoxShadowValue = AzCssPropertyValue<AzStyleBoxShadow>;

/// Type alias for CssPropertyValue < LayoutAlignContent >
pub type AzLayoutAlignContentValue = AzCssPropertyValue<AzLayoutAlignContent>;

/// Type alias for CssPropertyValue < LayoutAlignItems >
pub type AzLayoutAlignItemsValue = AzCssPropertyValue<AzLayoutAlignItems>;

/// Type alias for CssPropertyValue < LayoutBottom >
pub type AzLayoutBottomValue = AzCssPropertyValue<AzLayoutBottom>;

/// Type alias for CssPropertyValue < LayoutBoxSizing >
pub type AzLayoutBoxSizingValue = AzCssPropertyValue<AzLayoutBoxSizing>;

/// Type alias for CssPropertyValue < LayoutFlexDirection >
pub type AzLayoutFlexDirectionValue = AzCssPropertyValue<AzLayoutFlexDirection>;

/// Type alias for CssPropertyValue < LayoutDisplay >
pub type AzLayoutDisplayValue = AzCssPropertyValue<AzLayoutDisplay>;

/// Type alias for CssPropertyValue < LayoutFlexGrow >
pub type AzLayoutFlexGrowValue = AzCssPropertyValue<AzLayoutFlexGrow>;

/// Type alias for CssPropertyValue < LayoutFlexShrink >
pub type AzLayoutFlexShrinkValue = AzCssPropertyValue<AzLayoutFlexShrink>;

/// Type alias for CssPropertyValue < LayoutFloat >
pub type AzLayoutFloatValue = AzCssPropertyValue<AzLayoutFloat>;

/// Type alias for CssPropertyValue < LayoutHeight >
pub type AzLayoutHeightValue = AzCssPropertyValue<AzLayoutHeight>;

/// Type alias for CssPropertyValue < LayoutJustifyContent >
pub type AzLayoutJustifyContentValue = AzCssPropertyValue<AzLayoutJustifyContent>;

/// Type alias for CssPropertyValue < LayoutLeft >
pub type AzLayoutLeftValue = AzCssPropertyValue<AzLayoutLeft>;

/// Type alias for CssPropertyValue < LayoutMarginBottom >
pub type AzLayoutMarginBottomValue = AzCssPropertyValue<AzLayoutMarginBottom>;

/// Type alias for CssPropertyValue < LayoutMarginLeft >
pub type AzLayoutMarginLeftValue = AzCssPropertyValue<AzLayoutMarginLeft>;

/// Type alias for CssPropertyValue < LayoutMarginRight >
pub type AzLayoutMarginRightValue = AzCssPropertyValue<AzLayoutMarginRight>;

/// Type alias for CssPropertyValue < LayoutMarginTop >
pub type AzLayoutMarginTopValue = AzCssPropertyValue<AzLayoutMarginTop>;

/// Type alias for CssPropertyValue < LayoutMaxHeight >
pub type AzLayoutMaxHeightValue = AzCssPropertyValue<AzLayoutMaxHeight>;

/// Type alias for CssPropertyValue < LayoutMaxWidth >
pub type AzLayoutMaxWidthValue = AzCssPropertyValue<AzLayoutMaxWidth>;

/// Type alias for CssPropertyValue < LayoutMinHeight >
pub type AzLayoutMinHeightValue = AzCssPropertyValue<AzLayoutMinHeight>;

/// Type alias for CssPropertyValue < LayoutMinWidth >
pub type AzLayoutMinWidthValue = AzCssPropertyValue<AzLayoutMinWidth>;

/// Type alias for CssPropertyValue < LayoutPaddingBottom >
pub type AzLayoutPaddingBottomValue = AzCssPropertyValue<AzLayoutPaddingBottom>;

/// Type alias for CssPropertyValue < LayoutPaddingLeft >
pub type AzLayoutPaddingLeftValue = AzCssPropertyValue<AzLayoutPaddingLeft>;

/// Type alias for CssPropertyValue < LayoutPaddingRight >
pub type AzLayoutPaddingRightValue = AzCssPropertyValue<AzLayoutPaddingRight>;

/// Type alias for CssPropertyValue < LayoutPaddingTop >
pub type AzLayoutPaddingTopValue = AzCssPropertyValue<AzLayoutPaddingTop>;

/// Type alias for CssPropertyValue < LayoutPosition >
pub type AzLayoutPositionValue = AzCssPropertyValue<AzLayoutPosition>;

/// Type alias for CssPropertyValue < LayoutRight >
pub type AzLayoutRightValue = AzCssPropertyValue<AzLayoutRight>;

/// Type alias for CssPropertyValue < LayoutTop >
pub type AzLayoutTopValue = AzCssPropertyValue<AzLayoutTop>;

/// Type alias for CssPropertyValue < LayoutWidth >
pub type AzLayoutWidthValue = AzCssPropertyValue<AzLayoutWidth>;

/// Type alias for CssPropertyValue < LayoutFlexWrap >
pub type AzLayoutFlexWrapValue = AzCssPropertyValue<AzLayoutFlexWrap>;

/// Type alias for CssPropertyValue < LayoutOverflow >
pub type AzLayoutOverflowValue = AzCssPropertyValue<AzLayoutOverflow>;

/// Type alias for CssPropertyValue < ScrollbarStyle >
pub type AzScrollbarStyleValue = AzCssPropertyValue<AzScrollbarStyle>;

/// Type alias for CssPropertyValue < StyleBackgroundContentVec >
pub type AzStyleBackgroundContentVecValue = AzCssPropertyValue<AzStyleBackgroundContentVec>;

/// Type alias for CssPropertyValue < StyleBackgroundPositionVec >
pub type AzStyleBackgroundPositionVecValue = AzCssPropertyValue<AzStyleBackgroundPositionVec>;

/// Type alias for CssPropertyValue < StyleBackgroundRepeatVec >
pub type AzStyleBackgroundRepeatVecValue = AzCssPropertyValue<AzStyleBackgroundRepeatVec>;

/// Type alias for CssPropertyValue < StyleBackgroundSizeVec >
pub type AzStyleBackgroundSizeVecValue = AzCssPropertyValue<AzStyleBackgroundSizeVec>;

/// Type alias for CssPropertyValue < StyleBorderBottomColor >
pub type AzStyleBorderBottomColorValue = AzCssPropertyValue<AzStyleBorderBottomColor>;

/// Type alias for CssPropertyValue < StyleBorderBottomLeftRadius >
pub type AzStyleBorderBottomLeftRadiusValue = AzCssPropertyValue<AzStyleBorderBottomLeftRadius>;

/// Type alias for CssPropertyValue < StyleBorderBottomRightRadius >
pub type AzStyleBorderBottomRightRadiusValue = AzCssPropertyValue<AzStyleBorderBottomRightRadius>;

/// Type alias for CssPropertyValue < StyleBorderBottomStyle >
pub type AzStyleBorderBottomStyleValue = AzCssPropertyValue<AzStyleBorderBottomStyle>;

/// Type alias for CssPropertyValue < LayoutBorderBottomWidth >
pub type AzLayoutBorderBottomWidthValue = AzCssPropertyValue<AzLayoutBorderBottomWidth>;

/// Type alias for CssPropertyValue < StyleBorderLeftColor >
pub type AzStyleBorderLeftColorValue = AzCssPropertyValue<AzStyleBorderLeftColor>;

/// Type alias for CssPropertyValue < StyleBorderLeftStyle >
pub type AzStyleBorderLeftStyleValue = AzCssPropertyValue<AzStyleBorderLeftStyle>;

/// Type alias for CssPropertyValue < LayoutBorderLeftWidth >
pub type AzLayoutBorderLeftWidthValue = AzCssPropertyValue<AzLayoutBorderLeftWidth>;

/// Type alias for CssPropertyValue < StyleBorderRightColor >
pub type AzStyleBorderRightColorValue = AzCssPropertyValue<AzStyleBorderRightColor>;

/// Type alias for CssPropertyValue < StyleBorderRightStyle >
pub type AzStyleBorderRightStyleValue = AzCssPropertyValue<AzStyleBorderRightStyle>;

/// Type alias for CssPropertyValue < LayoutBorderRightWidth >
pub type AzLayoutBorderRightWidthValue = AzCssPropertyValue<AzLayoutBorderRightWidth>;

/// Type alias for CssPropertyValue < StyleBorderTopColor >
pub type AzStyleBorderTopColorValue = AzCssPropertyValue<AzStyleBorderTopColor>;

/// Type alias for CssPropertyValue < StyleBorderTopLeftRadius >
pub type AzStyleBorderTopLeftRadiusValue = AzCssPropertyValue<AzStyleBorderTopLeftRadius>;

/// Type alias for CssPropertyValue < StyleBorderTopRightRadius >
pub type AzStyleBorderTopRightRadiusValue = AzCssPropertyValue<AzStyleBorderTopRightRadius>;

/// Type alias for CssPropertyValue < StyleBorderTopStyle >
pub type AzStyleBorderTopStyleValue = AzCssPropertyValue<AzStyleBorderTopStyle>;

/// Type alias for CssPropertyValue < LayoutBorderTopWidth >
pub type AzLayoutBorderTopWidthValue = AzCssPropertyValue<AzLayoutBorderTopWidth>;

/// Type alias for CssPropertyValue < StyleFontFamilyVec >
pub type AzStyleFontFamilyVecValue = AzCssPropertyValue<AzStyleFontFamilyVec>;

/// Type alias for CssPropertyValue < StyleFontSize >
pub type AzStyleFontSizeValue = AzCssPropertyValue<AzStyleFontSize>;

/// Type alias for CssPropertyValue < StyleLetterSpacing >
pub type AzStyleLetterSpacingValue = AzCssPropertyValue<AzStyleLetterSpacing>;

/// Type alias for CssPropertyValue < StyleLineHeight >
pub type AzStyleLineHeightValue = AzCssPropertyValue<AzStyleLineHeight>;

/// Type alias for CssPropertyValue < StyleTabWidth >
pub type AzStyleTabWidthValue = AzCssPropertyValue<AzStyleTabWidth>;

/// Type alias for CssPropertyValue < StyleTextAlign >
pub type AzStyleTextAlignValue = AzCssPropertyValue<AzStyleTextAlign>;

/// Type alias for CssPropertyValue < StyleTextColor >
pub type AzStyleTextColorValue = AzCssPropertyValue<AzStyleTextColor>;

/// Type alias for CssPropertyValue < StyleWordSpacing >
pub type AzStyleWordSpacingValue = AzCssPropertyValue<AzStyleWordSpacing>;

/// Type alias for CssPropertyValue < StyleOpacity >
pub type AzStyleOpacityValue = AzCssPropertyValue<AzStyleOpacity>;

/// Type alias for CssPropertyValue < StyleTransformVec >
pub type AzStyleTransformVecValue = AzCssPropertyValue<AzStyleTransformVec>;

/// Type alias for CssPropertyValue < StyleTransformOrigin >
pub type AzStyleTransformOriginValue = AzCssPropertyValue<AzStyleTransformOrigin>;

/// Type alias for CssPropertyValue < StylePerspectiveOrigin >
pub type AzStylePerspectiveOriginValue = AzCssPropertyValue<AzStylePerspectiveOrigin>;

/// Type alias for CssPropertyValue < StyleBackfaceVisibility >
pub type AzStyleBackfaceVisibilityValue = AzCssPropertyValue<AzStyleBackfaceVisibility>;

/// Type alias for CssPropertyValue < StyleMixBlendMode >
pub type AzStyleMixBlendModeValue = AzCssPropertyValue<AzStyleMixBlendMode>;

/// Type alias for CssPropertyValue < StyleFilterVec >
pub type AzStyleFilterVecValue = AzCssPropertyValue<AzStyleFilterVec>;

/// Type alias for CssPropertyValue < StyleVisibility >
pub type AzStyleVisibilityValue = AzCssPropertyValue<AzStyleVisibility>;

/// Type alias for CssPropertyValue < ColumnRuleStyle >
pub type AzColumnRuleStyleValue = AzCssPropertyValue<AzColumnRuleStyle>;

/// Type alias for CssPropertyValue < GridAutoTracks >
pub type AzLayoutGridAutoColumnsValue = AzCssPropertyValue<AzGridAutoTracks>;

/// Type alias for CssPropertyValue < LayoutGap >
pub type AzLayoutGapValue = AzCssPropertyValue<AzLayoutGap>;

/// Type alias for CssPropertyValue < ShapeOutside >
pub type AzShapeOutsideValue = AzCssPropertyValue<AzShapeOutside>;

/// Type alias for CssPropertyValue < BoxDecorationBreak >
pub type AzBoxDecorationBreakValue = AzCssPropertyValue<AzBoxDecorationBreak>;

/// Type alias for CssPropertyValue < BreakInside >
pub type AzBreakInsideValue = AzCssPropertyValue<AzBreakInside>;

/// Type alias for CssPropertyValue < StyleHyphens >
pub type AzStyleHyphensValue = AzCssPropertyValue<AzStyleHyphens>;

/// Type alias for CssPropertyValue < LayoutZIndex >
pub type AzLayoutZIndexValue = AzCssPropertyValue<AzLayoutZIndex>;

/// Type alias for CssPropertyValue < ColumnRuleColor >
pub type AzColumnRuleColorValue = AzCssPropertyValue<AzColumnRuleColor>;

/// Type alias for CssPropertyValue < CounterReset >
pub type AzCounterResetValue = AzCssPropertyValue<AzCounterReset>;

/// Type alias for CssPropertyValue < LayoutScrollbarWidth >
pub type AzLayoutScrollbarWidthValue = AzCssPropertyValue<AzLayoutScrollbarWidth>;

/// Type alias for CssPropertyValue < PageBreak >
pub type AzPageBreakValue = AzCssPropertyValue<AzPageBreak>;

/// Type alias for CssPropertyValue < LayoutFlexBasis >
pub type AzLayoutFlexBasisValue = AzCssPropertyValue<AzLayoutFlexBasis>;

/// Type alias for CssPropertyValue < CounterIncrement >
pub type AzCounterIncrementValue = AzCssPropertyValue<AzCounterIncrement>;

/// Type alias for CssPropertyValue < ColumnFill >
pub type AzColumnFillValue = AzCssPropertyValue<AzColumnFill>;

/// Type alias for CssPropertyValue < Orphans >
pub type AzOrphansValue = AzCssPropertyValue<AzOrphans>;

/// Type alias for CssPropertyValue < ColumnWidth >
pub type AzColumnWidthValue = AzCssPropertyValue<AzColumnWidth>;

/// Type alias for CssPropertyValue < LayoutJustifySelf >
pub type AzLayoutJustifySelfValue = AzCssPropertyValue<AzLayoutJustifySelf>;

/// Type alias for CssPropertyValue < ShapeMargin >
pub type AzShapeMarginValue = AzCssPropertyValue<AzShapeMargin>;

/// Type alias for CssPropertyValue < GridPlacement >
pub type AzLayoutGridColumnValue = AzCssPropertyValue<AzGridPlacement>;

/// Type alias for CssPropertyValue < ColumnSpan >
pub type AzColumnSpanValue = AzCssPropertyValue<AzColumnSpan>;

/// Type alias for CssPropertyValue < LayoutAlignSelf >
pub type AzLayoutAlignSelfValue = AzCssPropertyValue<AzLayoutAlignSelf>;

/// Type alias for CssPropertyValue < Widows >
pub type AzWidowsValue = AzCssPropertyValue<AzWidows>;

/// Type alias for CssPropertyValue < ColumnCount >
pub type AzColumnCountValue = AzCssPropertyValue<AzColumnCount>;

/// Type alias for CssPropertyValue < StyleScrollbarColor >
pub type AzStyleScrollbarColorValue = AzCssPropertyValue<AzStyleScrollbarColor>;

/// Type alias for CssPropertyValue < StyleFontFamilyVec >
pub type AzStyleFontValue = AzCssPropertyValue<AzStyleFontFamilyVec>;

/// Type alias for CssPropertyValue < GridTemplate >
pub type AzLayoutGridTemplateRowsValue = AzCssPropertyValue<AzGridTemplate>;

/// Type alias for CssPropertyValue < LayoutJustifyItems >
pub type AzLayoutJustifyItemsValue = AzCssPropertyValue<AzLayoutJustifyItems>;

/// Type alias for CssPropertyValue < LayoutTextJustify >
pub type AzLayoutTextJustifyValue = AzCssPropertyValue<AzLayoutTextJustify>;

/// Type alias for CssPropertyValue < SelectionColor >
pub type AzSelectionColorValue = AzCssPropertyValue<AzSelectionColor>;

/// Type alias for CssPropertyValue < LayoutWritingMode >
pub type AzLayoutWritingModeValue = AzCssPropertyValue<AzLayoutWritingMode>;

/// Type alias for CssPropertyValue < StyleDirection >
pub type AzStyleDirectionValue = AzCssPropertyValue<AzStyleDirection>;

/// Type alias for CssPropertyValue < LayoutColumnGap >
pub type AzLayoutColumnGapValue = AzCssPropertyValue<AzLayoutColumnGap>;

/// Type alias for CssPropertyValue < GridTemplate >
pub type AzLayoutGridTemplateColumnsValue = AzCssPropertyValue<AzGridTemplate>;

/// Type alias for CssPropertyValue < ShapeImageThreshold >
pub type AzShapeImageThresholdValue = AzCssPropertyValue<AzShapeImageThreshold>;

/// Type alias for CssPropertyValue < CaretAnimationDuration >
pub type AzCaretAnimationDurationValue = AzCssPropertyValue<AzCaretAnimationDuration>;

/// Type alias for CssPropertyValue < LayoutClear >
pub type AzLayoutClearValue = AzCssPropertyValue<AzLayoutClear>;

/// Type alias for CssPropertyValue < SelectionBackgroundColor >
pub type AzSelectionBackgroundColorValue = AzCssPropertyValue<AzSelectionBackgroundColor>;

/// Type alias for CssPropertyValue < GridAutoTracks >
pub type AzLayoutGridAutoRowsValue = AzCssPropertyValue<AzGridAutoTracks>;

/// Type alias for CssPropertyValue < StyleWhiteSpace >
pub type AzStyleWhiteSpaceValue = AzCssPropertyValue<AzStyleWhiteSpace>;

/// Type alias for CssPropertyValue < CaretColor >
pub type AzCaretColorValue = AzCssPropertyValue<AzCaretColor>;

/// Type alias for CssPropertyValue < LayoutGridAutoFlow >
pub type AzLayoutGridAutoFlowValue = AzCssPropertyValue<AzLayoutGridAutoFlow>;

/// Type alias for CssPropertyValue < StyleTextDecoration >
pub type AzStyleTextDecorationValue = AzCssPropertyValue<AzStyleTextDecoration>;

/// Type alias for CssPropertyValue < Content >
pub type AzContentValue = AzCssPropertyValue<AzContent>;

/// Type alias for CssPropertyValue < ColumnRuleWidth >
pub type AzColumnRuleWidthValue = AzCssPropertyValue<AzColumnRuleWidth>;

/// Type alias for CssPropertyValue < StyleUserSelect >
pub type AzStyleUserSelectValue = AzCssPropertyValue<AzStyleUserSelect>;

/// Type alias for CssPropertyValue < LayoutRowGap >
pub type AzLayoutRowGapValue = AzCssPropertyValue<AzLayoutRowGap>;

/// Type alias for CssPropertyValue < GridPlacement >
pub type AzLayoutGridRowValue = AzCssPropertyValue<AzGridPlacement>;

/// Generic CSS property value that can be Auto, None, Initial, Inherit, or an exact value
#[repr(C)] pub struct AzCssPropertyValue { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CounterReset>` struct
#[repr(C)] pub struct AzCounterReset { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a grid line position (start or end)
#[repr(C)] pub struct AzGridLine { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `perspective-origin` attribute
#[repr(C)] pub struct AzStylePerspectiveOrigin { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `z-index` attribute - controls stacking order of positioned elements
#[repr(C)] pub struct AzLayoutZIndex { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents `justify-items` for grid containers
#[repr(C)] pub struct AzLayoutJustifyItems { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SelectionBackgroundColor>` struct
#[repr(C)] pub struct AzSelectionBackgroundColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColumnRuleColor>` struct
#[repr(C)] pub struct AzColumnRuleColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColumnSpan>` struct
#[repr(C)] pub struct AzColumnSpan { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `clear` attribute
#[repr(C)] pub struct AzLayoutClear { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// How to handle white space inside an element.
#[repr(C)] pub struct AzStyleWhiteSpace { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `break-inside` CSS property value.
#[repr(C)] pub struct AzBreakInside { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents an `align-self` attribute, which allows the default alignment (or the one specified by align-items) to be overridden for individual flex items. Default: `Auto`
#[repr(C)] pub struct AzLayoutAlignSelf { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CaretAnimationDuration>` struct
#[repr(C)] pub struct AzCaretAnimationDuration { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColumnRuleStyle>` struct
#[repr(C)] pub struct AzColumnRuleStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents `grid-row` or `grid-column` (start / end)
#[repr(C)] pub struct AzGridPlacement { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// CSS shape-outside property for wrapping text around shapes
#[repr(C)] pub struct AzShapeOutside { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColumnCount>` struct
#[repr(C)] pub struct AzColumnCount { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `writing-mode` attribute
#[repr(C)] pub struct AzLayoutWritingMode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Controls whether the user can select text. Used to prevent accidental text selection on UI controls like buttons.
#[repr(C)] pub struct AzStyleUserSelect { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents `grid-template-columns` or `grid-template-rows`
#[repr(C)] pub struct AzGridTemplate { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents `justify-self` for grid items
#[repr(C)] pub struct AzLayoutJustifySelf { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Content>` struct
#[repr(C)] pub struct AzContent { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Hyphenation rules.
#[repr(C)] pub struct AzStyleHyphens { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutGap>` struct
#[repr(C)] pub struct AzLayoutGap { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Text direction.
#[repr(C)] pub struct AzStyleDirection { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `flex-basis` attribute
#[repr(C)] pub struct AzLayoutFlexBasis { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ShapeMargin>` struct
#[repr(C)] pub struct AzShapeMargin { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutTextJustify>` struct
#[repr(C)] pub struct AzLayoutTextJustify { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColumnWidth>` struct
#[repr(C)] pub struct AzColumnWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CounterIncrement>` struct
#[repr(C)] pub struct AzCounterIncrement { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `box-decoration-break` CSS property value.
#[repr(C)] pub struct AzBoxDecorationBreak { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SelectionColor>` struct
#[repr(C)] pub struct AzSelectionColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `visibility` attribute, controlling element visibility.
#[repr(C)] pub struct AzStyleVisibility { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ShapeImageThreshold>` struct
#[repr(C)] pub struct AzShapeImageThreshold { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents the `grid-auto-flow` property
#[repr(C)] pub struct AzLayoutGridAutoFlow { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColumnRuleWidth>` struct
#[repr(C)] pub struct AzColumnRuleWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Text decoration (underline, overline, line-through).
#[repr(C)] pub struct AzStyleTextDecoration { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CaretColor>` struct
#[repr(C)] pub struct AzCaretColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Only used for calculations: Size (width, height) in layout space.
#[repr(C)] pub struct AzLayoutSize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColumnFill>` struct
#[repr(C)] pub struct AzColumnFill { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for GridTemplate
pub type AzGridAutoTracks = AzGridTemplate<>;

/// Represents a `break-before` or `break-after` CSS property value.
#[repr(C)] pub struct AzPageBreak { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents the standard `scrollbar-width` property.
#[repr(C)] pub struct AzLayoutScrollbarWidth { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents the standard `scrollbar-color` property.
#[repr(C)] pub struct AzStyleScrollbarColor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Vertical text alignment enum (top, center, bottom) - default: `Top`
#[repr(C)] pub struct AzStyleVerticalAlign { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for CssPropertyValue < SelectionRadius >
pub type AzSelectionRadiusValue = AzCssPropertyValue<AzSelectionRadius>;

/// line-clamp property for limiting visible lines
#[repr(C)] pub struct AzStyleLineClamp { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for CssPropertyValue < StyleTextCombineUpright >
pub type AzStyleTextCombineUprightValue = AzCssPropertyValue<AzStyleTextCombineUpright>;

/// CSS shape-inside property for flowing text within shapes
#[repr(C)] pub struct AzShapeInside { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SelectionRadius>` struct
#[repr(C)] pub struct AzSelectionRadius { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Orphans>` struct
#[repr(C)] pub struct AzOrphans { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Represents a `text-indent` attribute (indentation of first line in a block).
#[repr(C)] pub struct AzStyleTextIndent { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Sets the distance between the borders of adjacent cells. The `border-spacing` property is only applicable when `border-collapse` is set to `separate`. It can have one or two values: - One value: Sets both horizontal and vertical spacing - Two values: First is horizontal, second is vertical This struct represents a single spacing value (either horizontal or vertical).
#[repr(C)] pub struct AzLayoutBorderSpacing { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutPaddingInlineStart>` struct
#[repr(C)] pub struct AzLayoutPaddingInlineStart { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for CssPropertyValue < StyleTextIndent >
pub type AzStyleTextIndentValue = AzCssPropertyValue<AzStyleTextIndent>;

/// Represents the `font-weight` property.
#[repr(C)] pub struct AzStyleFontWeight { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for CssPropertyValue < StyleFontWeight >
pub type AzStyleFontWeightValue = AzCssPropertyValue<AzStyleFontWeight>;

/// `-azul-exclusion-margin` property: defines margin around shape exclusions This property controls the spacing between text and shapes that text flows around. It's similar to `shape-margin` but specifically for exclusions (text wrapping). # Example ```css .element { -azul-exclusion-margin: 10.5; } ```
#[repr(C)] pub struct AzStyleExclusionMargin { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Widows>` struct
#[repr(C)] pub struct AzWidows { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutColumnGap>` struct
#[repr(C)] pub struct AzLayoutColumnGap { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LayoutPaddingInlineEnd>` struct
#[repr(C)] pub struct AzLayoutPaddingInlineEnd { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleListStyleType>` struct
#[repr(C)] pub struct AzStyleListStyleType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// CSS clip-path property for clipping element rendering
#[repr(C)] pub struct AzClipPath { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for CssPropertyValue < ShapeInside >
pub type AzShapeInsideValue = AzCssPropertyValue<AzShapeInside>;

/// Type alias for CssPropertyValue < StyleVerticalAlign >
pub type AzStyleVerticalAlignValue = AzCssPropertyValue<AzStyleVerticalAlign>;

/// Type alias for CssPropertyValue < LayoutPaddingInlineEnd >
pub type AzLayoutPaddingInlineEndValue = AzCssPropertyValue<AzLayoutPaddingInlineEnd>;

/// `-azul-hyphenation-language` property: specifies language for hyphenation This property defines the language code (BCP 47 format) used for automatic hyphenation. Examples: "en-US", "de-DE", "fr-FR" # Example ```css .element { -azul-hyphenation-language: "en-US"; } ```
#[repr(C)] pub struct AzStyleHyphenationLanguage { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for CssPropertyValue < StyleListStylePosition >
pub type AzStyleListStylePositionValue = AzCssPropertyValue<AzStyleListStylePosition>;

/// Type alias for CssPropertyValue < LayoutTableLayout >
pub type AzLayoutTableLayoutValue = AzCssPropertyValue<AzLayoutTableLayout>;

/// Type alias for CssPropertyValue < LayoutPaddingInlineStart >
pub type AzLayoutPaddingInlineStartValue = AzCssPropertyValue<AzLayoutPaddingInlineStart>;

/// Type alias for CssPropertyValue < StyleFontStyle >
pub type AzStyleFontStyleValue = AzCssPropertyValue<AzStyleFontStyle>;

/// Type alias for CssPropertyValue < ClipPath >
pub type AzClipPathValue = AzCssPropertyValue<AzClipPath>;

/// Type alias for CssPropertyValue < StyleLineClamp >
pub type AzStyleLineClampValue = AzCssPropertyValue<AzStyleLineClamp>;

/// Type alias for CssPropertyValue < StyleEmptyCells >
pub type AzStyleEmptyCellsValue = AzCssPropertyValue<AzStyleEmptyCells>;

/// Type alias for CssPropertyValue < StyleCaptionSide >
pub type AzStyleCaptionSideValue = AzCssPropertyValue<AzStyleCaptionSide>;

/// Pointer to rust-allocated `Box<StyleListStylePosition>` struct
#[repr(C)] pub struct AzStyleListStylePosition { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Specifies whether cell borders are collapsed into a single border or separated. The `border-collapse` property determines the border rendering model: - **separate**: Each cell has its own border (default, uses border-spacing) - **collapse**: Adjacent cells share borders (ignores border-spacing)
#[repr(C)] pub struct AzStyleBorderCollapse { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Specifies the placement of a table caption. The `caption-side` property positions the caption either above or below the table.
#[repr(C)] pub struct AzStyleCaptionSide { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for CssPropertyValue < StyleBorderCollapse >
pub type AzStyleBorderCollapseValue = AzCssPropertyValue<AzStyleBorderCollapse>;

/// Type alias for CssPropertyValue < StyleExclusionMargin >
pub type AzStyleExclusionMarginValue = AzCssPropertyValue<AzStyleExclusionMargin>;

/// Type alias for CssPropertyValue < StyleListStyleType >
pub type AzStyleListStyleTypeValue = AzCssPropertyValue<AzStyleListStyleType>;

/// Pointer to rust-allocated `Box<LayoutRowGap>` struct
#[repr(C)] pub struct AzLayoutRowGap { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// hanging-punctuation property for hanging punctuation marks
#[repr(C)] pub struct AzStyleHangingPunctuation { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Controls the algorithm used to lay out table cells, rows, and columns. The `table-layout` property determines whether the browser should use: - **auto**: Column widths are determined by the content (slower but flexible) - **fixed**: Column widths are determined by the first row (faster and predictable)
#[repr(C)] pub struct AzLayoutTableLayout { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// initial-letter property for drop caps
#[repr(C)] pub struct AzStyleInitialLetter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Specifies whether or not to display borders and background on empty cells. The `empty-cells` property only applies when `border-collapse` is set to `separate`. A cell is considered empty if it contains no visible content.
#[repr(C)] pub struct AzStyleEmptyCells { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for CssPropertyValue < StyleInitialLetter >
pub type AzStyleInitialLetterValue = AzCssPropertyValue<AzStyleInitialLetter>;

/// Represents the `font-style` property.
#[repr(C)] pub struct AzStyleFontStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for CssPropertyValue < LayoutBorderSpacing >
pub type AzLayoutBorderSpacingValue = AzCssPropertyValue<AzLayoutBorderSpacing>;

/// text-combine-upright property for combining horizontal text in vertical layout
#[repr(C)] pub struct AzStyleTextCombineUpright { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for CssPropertyValue < StyleHangingPunctuation >
pub type AzStyleHangingPunctuationValue = AzCssPropertyValue<AzStyleHangingPunctuation>;

/// Type alias for CssPropertyValue < StyleHyphenationLanguage >
pub type AzStyleHyphenationLanguageValue = AzCssPropertyValue<AzStyleHyphenationLanguage>;

/// Pointer to rust-allocated `Box<GridTrackSizing>` struct
#[repr(C)] pub struct AzGridTrackSizing { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Physical size with u32 dimensions
pub type AzPhysicalSizeU32 = AzPhysicalSize<Azu32>;

/// Pointer to rust-allocated `Box<HoverEventFilter>` struct
#[repr(C)] pub struct AzHoverEventFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextSelectionStartEnd>` struct
#[repr(C)] pub struct AzTextSelectionStartEnd { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ShapeRendering>` struct
#[repr(C)] pub struct AzShapeRendering { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ApplicationEventFilter>` struct
#[repr(C)] pub struct AzApplicationEventFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgFillStyle>` struct
#[repr(C)] pub struct AzSvgFillStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<XmlTextPos>` struct
#[repr(C)] pub struct AzXmlTextPos { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LogicalSize>` struct
#[repr(C)] pub struct AzLogicalSize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyledNodeState>` struct
#[repr(C)] pub struct AzStyledNodeState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssPropertyCachePtr>` struct
#[repr(C)] pub struct AzCssPropertyCachePtr { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgRenderTransform>` struct
#[repr(C)] pub struct AzSvgRenderTransform { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextRendering>` struct
#[repr(C)] pub struct AzTextRendering { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FocusEventFilter>` struct
#[repr(C)] pub struct AzFocusEventFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LogicalPosition>` struct
#[repr(C)] pub struct AzLogicalPosition { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<EventFilter>` struct
#[repr(C)] pub struct AzEventFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<PhysicalSize>` struct
#[repr(C)] pub struct AzPhysicalSize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgStyle>` struct
#[repr(C)] pub struct AzSvgStyle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Indent>` struct
#[repr(C)] pub struct AzIndent { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FontDatabase>` struct
#[repr(C)] pub struct AzFontDatabase { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyledDom>` struct
#[repr(C)] pub struct AzStyledDom { pub ptr: *mut c_void }
/// Styles a `Dom` with the given `Css`, returning the `StyledDom` - complexity `O(count(dom_nodes) * count(css_blocks))`: make sure that the `Dom` and the `Css` are as small as possible, use inline CSS if the performance isn't good enough
#[no_mangle] pub extern "C" fn AzStyledDom_new (dom: AzDom, css: AzCss) -> AzStyledDom { let object: StyledDom = let mut dom = dom; azul_core::styled_dom::StyledDom::new(&mut dom, css.into()); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzStyledDom { ptr } }
/// Returns a default, empty `Dom`, usually returned if you don't want to crash in an error case.
#[no_mangle] pub extern "C" fn AzStyledDom_default () -> AzStyledDom { let object: StyledDom = azul_core::styled_dom::StyledDom::default(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzStyledDom { ptr } }
/// Returns a DOM loaded from an XML file
#[no_mangle] pub extern "C" fn AzStyledDom_fromXml (xml_string: AzString) -> AzStyledDom { let object: StyledDom = azul_layout::extra::styled_dom_from_str(xml_string.as_str()); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzStyledDom { ptr } }
/// Same as `from_xml`, but loads the file relative to the current directory
#[no_mangle] pub extern "C" fn AzStyledDom_fromFile (xml_file_path: AzString) -> AzStyledDom { let object: StyledDom = azul_layout::extra::styled_dom_from_file(xml_file_path.as_str()); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzStyledDom { ptr } }
/// Appends an already styled list of DOM nodes to the current `dom.root` - complexity `O(count(dom.dom_nodes))`
#[no_mangle] pub extern "C" fn AzStyledDom_appendChild (styleddom: &mut AzStyledDom, dom: AzStyledDom){ styleddom.append_child(dom); }
/// Same as `append_child()`, but as a builder method
#[no_mangle] pub extern "C" fn AzStyledDom_withChild (styleddom: &mut AzStyledDom, dom: AzStyledDom) -> AzStyledDom{ styleddom.with_child(dom) }
/// Restyles an already styled DOM with a new CSS - overwrites old styles, but does not replace them, useful for implementing user styles that are applied on top of the existing application style
#[no_mangle] pub extern "C" fn AzStyledDom_restyle (styleddom: &mut AzStyledDom, css: AzCss){ styleddom.restyle(css.into()); }
/// Returns the number of nodes in the styled DOM
#[no_mangle] pub extern "C" fn AzStyledDom_nodeCount (styleddom: &AzStyledDom) -> usize{ styleddom.node_count() }
/// Returns a HTML string that you can write to a file in order to debug the UI structure and debug potential cascading issues
#[no_mangle] pub extern "C" fn AzStyledDom_getHtmlString (styleddom: &AzStyledDom) -> AzString{ styleddom.get_html_string("", "", false).into() }
/// Returns a HTML for unit testing
#[no_mangle] pub extern "C" fn AzStyledDom_getHtmlStringTest (styleddom: &AzStyledDom) -> AzString{ styleddom.get_html_string("", "", true).into() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyledNode>` struct
#[repr(C)] pub struct AzStyledNode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NotEventFilter>` struct
#[repr(C)] pub struct AzNotEventFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ComponentEventFilter>` struct
#[repr(C)] pub struct AzComponentEventFilter { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgTransform>` struct
#[repr(C)] pub struct AzSvgTransform { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VertexLayout>` struct
#[repr(C)] pub struct AzVertexLayout { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GridMinMax>` struct
#[repr(C)] pub struct AzGridMinMax { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NamedGridLine>` struct
#[repr(C)] pub struct AzNamedGridLine { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ScrollbarColorCustom>` struct
#[repr(C)] pub struct AzScrollbarColorCustom { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ShapeInset>` struct
#[repr(C)] pub struct AzShapeInset { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssShape>` struct
#[repr(C)] pub struct AzCssShape { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ShapePath>` struct
#[repr(C)] pub struct AzShapePath { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ShapeEllipse>` struct
#[repr(C)] pub struct AzShapeEllipse { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ShapePoint>` struct
#[repr(C)] pub struct AzShapePoint { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Srgb>` struct
#[repr(C)] pub struct AzSrgb { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `PhysicalPositionI32` struct
pub use azul_core::geom::PhysicalPositionI32 as AzPhysicalPositionI32TT;
pub use AzPhysicalPositionI32TT as AzPhysicalPositionI32;
/// Clones the object
#[no_mangle] pub extern "C" fn AzPhysicalPositionI32_deepCopy(object: &AzPhysicalPositionI32) -> AzPhysicalPositionI32 { object.clone() }

/// Pointer to rust-allocated `Box<WindowDecorations>` struct
#[repr(C)] pub struct AzWindowDecorations { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ImePosition>` struct
#[repr(C)] pub struct AzImePosition { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WindowPosition>` struct
#[repr(C)] pub struct AzWindowPosition { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CursorPosition>` struct
#[repr(C)] pub struct AzCursorPosition { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<WindowBackgroundMaterial>` struct
#[repr(C)] pub struct AzWindowBackgroundMaterial { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Button>` struct
#[repr(C)] pub struct AzButton { pub ptr: *mut c_void }
/// Creates a new labeled button
#[no_mangle] pub extern "C" fn AzButton_new (label: AzString) -> AzButton { let object: Button = azul_layout::widgets::button::Button::new(label); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzButton { ptr } }
/// Equivalent to the Rust `Button::set_on_click()` function.
#[no_mangle] pub extern "C" fn AzButton_setOnClick (button: &mut AzButton, data: AzRefAny, callback: AzCallbackType){ button.set_on_click(data, callback); }
/// Equivalent to the Rust `Button::with_on_click()` function.
#[no_mangle] pub extern "C" fn AzButton_withOnClick (button: &mut AzButton, data: AzRefAny, callback: AzCallbackType) -> AzButton{ let mut button = button.swap_with_default(); button.set_on_click(data, callback); button }
/// Equivalent to the Rust `Button::dom()` function.
#[no_mangle] pub extern "C" fn AzButton_dom (button: &mut AzButton) -> AzDom{ button.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ButtonOnClick>` struct
#[repr(C)] pub struct AzButtonOnClick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FileInput>` struct
#[repr(C)] pub struct AzFileInput { pub ptr: *mut c_void }
/// Creates a new file input button
#[no_mangle] pub extern "C" fn AzFileInput_new (path: AzOptionString) -> AzFileInput { let object: FileInput = azul_layout::widgets::file_input::FileInput::new(path); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzFileInput { ptr } }
/// Equivalent to the Rust `FileInput::set_default_text()` function.
#[no_mangle] pub extern "C" fn AzFileInput_setDefaultText (fileinput: &mut AzFileInput, default_text: AzString){ fileinput.set_default_text(default_text); }
/// Equivalent to the Rust `FileInput::with_default_text()` function.
#[no_mangle] pub extern "C" fn AzFileInput_withDefaultText (fileinput: &mut AzFileInput, default_text: AzString) -> AzFileInput{ let mut fileinput = fileinput.swap_with_default(); fileinput.set_default_text(default_text); fileinput }
/// Equivalent to the Rust `FileInput::set_on_path_change()` function.
#[no_mangle] pub extern "C" fn AzFileInput_setOnPathChange (fileinput: &mut AzFileInput, data: AzRefAny, callback: AzFileInputOnPathChangeCallbackType){ fileinput.set_on_path_change(data, callback); }
/// Equivalent to the Rust `FileInput::with_on_path_change()` function.
#[no_mangle] pub extern "C" fn AzFileInput_withOnPathChange (fileinput: &mut AzFileInput, data: AzRefAny, callback: AzFileInputOnPathChangeCallbackType) -> AzFileInput{ let mut fileinput = fileinput.swap_with_default(); fileinput.set_on_path_change(data, callback); fileinput }
/// Equivalent to the Rust `FileInput::dom()` function.
#[no_mangle] pub extern "C" fn AzFileInput_dom (fileinput: &mut AzFileInput) -> AzDom{ fileinput.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FileInputStateWrapper>` struct
#[repr(C)] pub struct AzFileInputStateWrapper { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FileInputState>` struct
#[repr(C)] pub struct AzFileInputState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FileInputOnPathChange>` struct
#[repr(C)] pub struct AzFileInputOnPathChange { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FileInputOnPathChangeCallback>` struct
#[repr(C)] pub struct AzFileInputOnPathChangeCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CheckBox>` struct
#[repr(C)] pub struct AzCheckBox { pub ptr: *mut c_void }
/// Creates a new checkbox, disabled or enabled
#[no_mangle] pub extern "C" fn AzCheckBox_new (checked: bool) -> AzCheckBox { let object: CheckBox = azul_layout::widgets::check_box::CheckBox::new(checked); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzCheckBox { ptr } }
/// Equivalent to the Rust `CheckBox::set_on_toggle()` function.
#[no_mangle] pub extern "C" fn AzCheckBox_setOnToggle (checkbox: &mut AzCheckBox, data: AzRefAny, callback: AzCheckBoxOnToggleCallbackType){ checkbox.set_on_toggle(data, callback); }
/// Equivalent to the Rust `CheckBox::with_on_toggle()` function.
#[no_mangle] pub extern "C" fn AzCheckBox_withOnToggle (checkbox: &mut AzCheckBox, data: AzRefAny, callback: AzCheckBoxOnToggleCallbackType) -> AzCheckBox{ let mut checkbox = checkbox.swap_with_default(); checkbox.set_on_toggle(data, callback); checkbox }
/// Equivalent to the Rust `CheckBox::dom()` function.
#[no_mangle] pub extern "C" fn AzCheckBox_dom (checkbox: &mut AzCheckBox) -> AzDom{ checkbox.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CheckBoxStateWrapper>` struct
#[repr(C)] pub struct AzCheckBoxStateWrapper { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CheckBoxOnToggle>` struct
#[repr(C)] pub struct AzCheckBoxOnToggle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CheckBoxState>` struct
#[repr(C)] pub struct AzCheckBoxState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColorInput>` struct
#[repr(C)] pub struct AzColorInput { pub ptr: *mut c_void }
/// Creates a new `ColorInput` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `ColorInput::new()` constructor.
#[no_mangle] pub extern "C" fn AzColorInput_new (color: AzColorU) -> AzColorInput { let object: ColorInput = azul_layout::widgets::color_input::ColorInput::new(color); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzColorInput { ptr } }
/// Equivalent to the Rust `ColorInput::set_on_value_change()` function.
#[no_mangle] pub extern "C" fn AzColorInput_setOnValueChange (colorinput: &mut AzColorInput, data: AzRefAny, callback: AzColorInputOnValueChangeCallbackType){ colorinput.set_on_value_change(data, callback) }
/// Equivalent to the Rust `ColorInput::with_on_value_change()` function.
#[no_mangle] pub extern "C" fn AzColorInput_withOnValueChange (colorinput: &mut AzColorInput, data: AzRefAny, callback: AzColorInputOnValueChangeCallbackType) -> AzColorInput{ let mut colorinput = colorinput.swap_with_default(); colorinput.set_on_value_change(data, callback); colorinput }
/// Equivalent to the Rust `ColorInput::dom()` function.
#[no_mangle] pub extern "C" fn AzColorInput_dom (colorinput: &mut AzColorInput) -> AzDom{ colorinput.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColorInputStateWrapper>` struct
#[repr(C)] pub struct AzColorInputStateWrapper { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColorInputState>` struct
#[repr(C)] pub struct AzColorInputState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColorInputOnValueChange>` struct
#[repr(C)] pub struct AzColorInputOnValueChange { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ColorInputOnValueChangeCallback>` struct
#[repr(C)] pub struct AzColorInputOnValueChangeCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInput>` struct
#[repr(C)] pub struct AzTextInput { pub ptr: *mut c_void }
/// Creates a new `TextInput` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `TextInput::new()` constructor.
#[no_mangle] pub extern "C" fn AzTextInput_new () -> AzTextInput { let object: TextInput = azul_layout::widgets::text_input::TextInput::new(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTextInput { ptr } }
/// Equivalent to the Rust `TextInput::set_text()` function.
#[no_mangle] pub extern "C" fn AzTextInput_setText (textinput: &mut AzTextInput, text: AzString){ textinput.set_text(text) }
/// Equivalent to the Rust `TextInput::with_text()` function.
#[no_mangle] pub extern "C" fn AzTextInput_withText (textinput: &mut AzTextInput, text: AzString) -> AzTextInput{ textinput.with_text(text) }
/// Equivalent to the Rust `TextInput::set_placeholder()` function.
#[no_mangle] pub extern "C" fn AzTextInput_setPlaceholder (textinput: &mut AzTextInput, text: AzString){ textinput.set_placeholder(text) }
/// Equivalent to the Rust `TextInput::with_placeholder()` function.
#[no_mangle] pub extern "C" fn AzTextInput_withPlaceholder (textinput: &mut AzTextInput, text: AzString) -> AzTextInput{ textinput.with_placeholder(text) }
/// Equivalent to the Rust `TextInput::set_on_text_input()` function.
#[no_mangle] pub extern "C" fn AzTextInput_setOnTextInput (textinput: &mut AzTextInput, data: AzRefAny, callback: AzTextInputOnTextInputCallbackType){ textinput.set_on_text_input(data, callback) }
/// Equivalent to the Rust `TextInput::with_on_text_input()` function.
#[no_mangle] pub extern "C" fn AzTextInput_withOnTextInput (textinput: &mut AzTextInput, data: AzRefAny, callback: AzTextInputOnTextInputCallbackType) -> AzTextInput{ let mut textinput = textinput.swap_with_default(); textinput.set_on_text_input(data, callback); textinput }
/// Equivalent to the Rust `TextInput::set_on_virtual_key_down()` function.
#[no_mangle] pub extern "C" fn AzTextInput_setOnVirtualKeyDown (textinput: &mut AzTextInput, data: AzRefAny, callback: AzTextInputOnVirtualKeyDownCallbackType){ textinput.set_on_virtual_key_down(data, callback) }
/// Equivalent to the Rust `TextInput::with_on_virtual_key_down()` function.
#[no_mangle] pub extern "C" fn AzTextInput_withOnVirtualKeyDown (textinput: &mut AzTextInput, data: AzRefAny, callback: AzTextInputOnVirtualKeyDownCallbackType) -> AzTextInput{ let mut textinput = textinput.swap_with_default(); textinput.set_on_virtual_key_down(data, callback); textinput }
/// Equivalent to the Rust `TextInput::set_on_focus_lost()` function.
#[no_mangle] pub extern "C" fn AzTextInput_setOnFocusLost (textinput: &mut AzTextInput, data: AzRefAny, callback: AzTextInputOnFocusLostCallbackType){ textinput.set_on_focus_lost(data, callback) }
/// Equivalent to the Rust `TextInput::with_on_focus_lost()` function.
#[no_mangle] pub extern "C" fn AzTextInput_withOnFocusLost (textinput: &mut AzTextInput, data: AzRefAny, callback: AzTextInputOnFocusLostCallbackType) -> AzTextInput{ let mut textinput = textinput.swap_with_default(); textinput.set_on_focus_lost(data, callback); textinput }
/// Equivalent to the Rust `TextInput::set_placeholder_style()` function.
#[no_mangle] pub extern "C" fn AzTextInput_setPlaceholderStyle (textinput: &mut AzTextInput, placeholder_style: AzNodeDataInlineCssPropertyVec){ textinput.set_placeholder_style(placeholder_style) }
/// Equivalent to the Rust `TextInput::with_placeholder_style()` function.
#[no_mangle] pub extern "C" fn AzTextInput_withPlaceholderStyle (textinput: &mut AzTextInput, placeholder_style: AzNodeDataInlineCssPropertyVec) -> AzTextInput{ let mut textinput = textinput.swap_with_default(); textinput.set_placeholder_style(placeholder_style); textinput }
/// Equivalent to the Rust `TextInput::set_container_style()` function.
#[no_mangle] pub extern "C" fn AzTextInput_setContainerStyle (textinput: &mut AzTextInput, container_style: AzNodeDataInlineCssPropertyVec){  textinput.set_container_style(container_style) }
/// Equivalent to the Rust `TextInput::with_container_style()` function.
#[no_mangle] pub extern "C" fn AzTextInput_withContainerStyle (textinput: &mut AzTextInput, container_style: AzNodeDataInlineCssPropertyVec) -> AzTextInput{ let mut textinput = textinput.swap_with_default(); textinput.set_container_style(container_style); textinput }
/// Equivalent to the Rust `TextInput::set_label_style()` function.
#[no_mangle] pub extern "C" fn AzTextInput_setLabelStyle (textinput: &mut AzTextInput, label_style: AzNodeDataInlineCssPropertyVec){ textinput.set_container_style(label_style) }
/// Equivalent to the Rust `TextInput::with_label_style()` function.
#[no_mangle] pub extern "C" fn AzTextInput_withLabelStyle (textinput: &mut AzTextInput, label_style: AzNodeDataInlineCssPropertyVec) -> AzTextInput{ let mut textinput = textinput.swap_with_default(); textinput.set_label_style(label_style); textinput }
/// Equivalent to the Rust `TextInput::dom()` function.
#[no_mangle] pub extern "C" fn AzTextInput_dom (textinput: &mut AzTextInput) -> AzDom{ textinput.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputStateWrapper>` struct
#[repr(C)] pub struct AzTextInputStateWrapper { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputState>` struct
#[repr(C)] pub struct AzTextInputState { pub ptr: *mut c_void }
/// Equivalent to the Rust `TextInputState::get_text()` function.
#[no_mangle] pub extern "C" fn AzTextInputState_getText (textinputstate: &AzTextInputState) -> AzString{ textinputstate.get_text().into() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputSelection>` struct
#[repr(C)] pub struct AzTextInputSelection { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputSelectionRange>` struct
#[repr(C)] pub struct AzTextInputSelectionRange { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputOnTextInput>` struct
#[repr(C)] pub struct AzTextInputOnTextInput { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputOnTextInputCallback>` struct
#[repr(C)] pub struct AzTextInputOnTextInputCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputOnVirtualKeyDown>` struct
#[repr(C)] pub struct AzTextInputOnVirtualKeyDown { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputOnVirtualKeyDownCallback>` struct
#[repr(C)] pub struct AzTextInputOnVirtualKeyDownCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputOnFocusLost>` struct
#[repr(C)] pub struct AzTextInputOnFocusLost { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputOnFocusLostCallback>` struct
#[repr(C)] pub struct AzTextInputOnFocusLostCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OnTextInputReturn>` struct
#[repr(C)] pub struct AzOnTextInputReturn { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextInputValid>` struct
#[repr(C)] pub struct AzTextInputValid { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NumberInput>` struct
#[repr(C)] pub struct AzNumberInput { pub ptr: *mut c_void }
/// Creates a new `NumberInput` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `NumberInput::new()` constructor.
#[no_mangle] pub extern "C" fn AzNumberInput_new (number: f32) -> AzNumberInput { let object: NumberInput = azul_layout::widgets::number_input::NumberInput::new(number); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzNumberInput { ptr } }
/// Equivalent to the Rust `NumberInput::set_on_text_input()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_setOnTextInput (numberinput: &mut AzNumberInput, data: AzRefAny, callback: AzTextInputOnTextInputCallbackType){ numberinput.set_on_text_input(data, callback) }
/// Equivalent to the Rust `NumberInput::with_on_text_input()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_withOnTextInput (numberinput: &mut AzNumberInput, data: AzRefAny, callback: AzTextInputOnTextInputCallbackType) -> AzNumberInput{ let mut numberinput = numberinput.swap_with_default(); numberinput.set_on_text_input(data, callback); numberinput }
/// Equivalent to the Rust `NumberInput::set_on_virtual_key_down()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_setOnVirtualKeyDown (numberinput: &mut AzNumberInput, data: AzRefAny, callback: AzTextInputOnVirtualKeyDownCallbackType){ numberinput.set_on_virtual_key_down(data, callback) }
/// Equivalent to the Rust `NumberInput::with_on_virtual_key_down()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_withOnVirtualKeyDown (numberinput: &mut AzNumberInput, data: AzRefAny, callback: AzTextInputOnVirtualKeyDownCallbackType) -> AzNumberInput{ let mut numberinput = numberinput.swap_with_default(); numberinput.set_on_virtual_key_down(data, callback); numberinput }
/// Equivalent to the Rust `NumberInput::set_on_focus_lost()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_setOnFocusLost (numberinput: &mut AzNumberInput, data: AzRefAny, callback: AzNumberInputOnFocusLostCallbackType){ numberinput.set_on_focus_lost(data, callback) }
/// Equivalent to the Rust `NumberInput::with_on_focus_lost()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_withOnFocusLost (numberinput: &mut AzNumberInput, data: AzRefAny, callback: AzNumberInputOnFocusLostCallbackType) -> AzNumberInput{ let mut numberinput = numberinput.swap_with_default(); numberinput.set_on_focus_lost(data, callback); numberinput }
/// Equivalent to the Rust `NumberInput::set_placeholder_style()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_setPlaceholderStyle (numberinput: &mut AzNumberInput, style: AzNodeDataInlineCssPropertyVec){ numberinput.set_placeholder_style(style) }
/// Equivalent to the Rust `NumberInput::with_placeholder_style()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_withPlaceholderStyle (numberinput: &mut AzNumberInput, style: AzNodeDataInlineCssPropertyVec) -> AzNumberInput{ let mut numberinput = numberinput.swap_with_default(); numberinput.set_placeholder_style(style); numberinput }
/// Equivalent to the Rust `NumberInput::set_container_style()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_setContainerStyle (numberinput: &mut AzNumberInput, style: AzNodeDataInlineCssPropertyVec){ numberinput.set_container_style(style) }
/// Equivalent to the Rust `NumberInput::with_container_style()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_withContainerStyle (numberinput: &mut AzNumberInput, style: AzNodeDataInlineCssPropertyVec) -> AzNumberInput{ let mut numberinput = numberinput.swap_with_default(); numberinput.set_container_style(style); numberinput }
/// Equivalent to the Rust `NumberInput::set_label_style()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_setLabelStyle (numberinput: &mut AzNumberInput, style: AzNodeDataInlineCssPropertyVec){ numberinput.set_label_style(style) }
/// Equivalent to the Rust `NumberInput::with_label_style()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_withLabelStyle (numberinput: &mut AzNumberInput, style: AzNodeDataInlineCssPropertyVec) -> AzNumberInput{ let mut numberinput = numberinput.swap_with_default(); numberinput.set_label_style(style); numberinput }
/// Equivalent to the Rust `NumberInput::set_on_value_change()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_setOnValueChange (numberinput: &mut AzNumberInput, data: AzRefAny, callback: AzNumberInputOnValueChangeCallbackType){ numberinput.set_on_value_change(data, callback) }
/// Equivalent to the Rust `NumberInput::with_on_value_change()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_withOnValueChange (numberinput: &mut AzNumberInput, data: AzRefAny, callback: AzNumberInputOnValueChangeCallbackType) -> AzNumberInput{ let mut numberinput = numberinput.swap_with_default(); numberinput.set_on_value_change(data, callback); numberinput }
/// Equivalent to the Rust `NumberInput::dom()` function.
#[no_mangle] pub extern "C" fn AzNumberInput_dom (numberinput: &mut AzNumberInput) -> AzDom{ numberinput.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NumberInputStateWrapper>` struct
#[repr(C)] pub struct AzNumberInputStateWrapper { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NumberInputState>` struct
#[repr(C)] pub struct AzNumberInputState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NumberInputOnValueChange>` struct
#[repr(C)] pub struct AzNumberInputOnValueChange { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NumberInputOnValueChangeCallback>` struct
#[repr(C)] pub struct AzNumberInputOnValueChangeCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NumberInputOnFocusLost>` struct
#[repr(C)] pub struct AzNumberInputOnFocusLost { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NumberInputOnFocusLostCallback>` struct
#[repr(C)] pub struct AzNumberInputOnFocusLostCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ProgressBar>` struct
#[repr(C)] pub struct AzProgressBar { pub ptr: *mut c_void }
/// Creates a new `ProgressBar` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `ProgressBar::new()` constructor.
#[no_mangle] pub extern "C" fn AzProgressBar_new (percent_done: f32) -> AzProgressBar { let object: ProgressBar = azul_layout::widgets::progressbar::ProgressBar::new(percent_done); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzProgressBar { ptr } }
/// Equivalent to the Rust `ProgressBar::set_height()` function.
#[no_mangle] pub extern "C" fn AzProgressBar_setHeight (progressbar: &mut AzProgressBar, height: AzPixelValue){ progressbar.set_height(height); }
/// Equivalent to the Rust `ProgressBar::with_height()` function.
#[no_mangle] pub extern "C" fn AzProgressBar_withHeight (progressbar: &mut AzProgressBar, height: AzPixelValue) -> AzProgressBar{ let mut progressbar = progressbar.swap_with_default(); progressbar.set_height(height); progressbar }
/// Equivalent to the Rust `ProgressBar::set_container_background()` function.
#[no_mangle] pub extern "C" fn AzProgressBar_setContainerBackground (progressbar: &mut AzProgressBar, background: AzStyleBackgroundContentVec){ progressbar.set_container_background(background); }
/// Equivalent to the Rust `ProgressBar::with_container_style()` function.
#[no_mangle] pub extern "C" fn AzProgressBar_withContainerStyle (progressbar: &mut AzProgressBar, background: AzStyleBackgroundContentVec) -> AzProgressBar{ let mut progressbar = progressbar.swap_with_default(); progressbar.set_container_background(background); progressbar }
/// Equivalent to the Rust `ProgressBar::set_bar_background()` function.
#[no_mangle] pub extern "C" fn AzProgressBar_setBarBackground (progressbar: &mut AzProgressBar, background: AzStyleBackgroundContentVec){ progressbar.set_bar_background(background); }
/// Equivalent to the Rust `ProgressBar::with_bar_background()` function.
#[no_mangle] pub extern "C" fn AzProgressBar_withBarBackground (progressbar: &mut AzProgressBar, background: AzStyleBackgroundContentVec) -> AzProgressBar{ let mut progressbar = progressbar.swap_with_default(); progressbar.set_bar_background(background); progressbar }
/// Equivalent to the Rust `ProgressBar::dom()` function.
#[no_mangle] pub extern "C" fn AzProgressBar_dom (progressbar: &mut AzProgressBar) -> AzDom{ progressbar.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ProgressBarState>` struct
#[repr(C)] pub struct AzProgressBarState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TabHeader>` struct
#[repr(C)] pub struct AzTabHeader { pub ptr: *mut c_void }
/// Creates a new `TabHeader` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `TabHeader::new()` constructor.
#[no_mangle] pub extern "C" fn AzTabHeader_new (tabs: AzStringVec) -> AzTabHeader { let object: TabHeader = azul_layout::widgets::tabs::TabHeader::new(tabs); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTabHeader { ptr } }
/// Equivalent to the Rust `TabHeader::set_active_tab()` function.
#[no_mangle] pub extern "C" fn AzTabHeader_setActiveTab (tabheader: &mut AzTabHeader, active_tab: usize){ tabheader.set_active_tab(active_tab) }
/// Equivalent to the Rust `TabHeader::with_active_tab()` function.
#[no_mangle] pub extern "C" fn AzTabHeader_withActiveTab (tabheader: &mut AzTabHeader, active_tab: usize) -> AzTabHeader{ tabheader.with_active_tab(active_tab) }
/// Equivalent to the Rust `TabHeader::set_on_click()` function.
#[no_mangle] pub extern "C" fn AzTabHeader_setOnClick (tabheader: &mut AzTabHeader, data: AzRefAny, callback: AzTabOnClickCallbackType){ tabheader.set_on_click(data, callback) }
/// Equivalent to the Rust `TabHeader::with_on_click()` function.
#[no_mangle] pub extern "C" fn AzTabHeader_withOnClick (tabheader: &mut AzTabHeader, data: AzRefAny, callback: AzTabOnClickCallbackType) -> AzTabHeader{ tabheader.with_on_click(data, callback) }
/// Equivalent to the Rust `TabHeader::dom()` function.
#[no_mangle] pub extern "C" fn AzTabHeader_dom (tabheader: &mut AzTabHeader) -> AzDom{ tabheader.dom() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TabOnClick>` struct
#[repr(C)] pub struct AzTabOnClick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Frame>` struct
#[repr(C)] pub struct AzFrame { pub ptr: *mut c_void }
/// Creates a new `Frame` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Frame::new()` constructor.
#[no_mangle] pub extern "C" fn AzFrame_new (title: AzString, dom: AzDom) -> AzFrame { let object: Frame = azul_layout::widgets::frame::Frame::new(title, dom); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzFrame { ptr } }
/// Equivalent to the Rust `Frame::set_flex_grow()` function.
#[no_mangle] pub extern "C" fn AzFrame_setFlexGrow (frame: &mut AzFrame, flex_grow: f32){ frame.set_flex_grow(flex_grow) }
/// Equivalent to the Rust `Frame::with_flex_grow()` function.
#[no_mangle] pub extern "C" fn AzFrame_withFlexGrow (frame: &mut AzFrame, flex_grow: f32) -> AzFrame{ let mut frame = frame.swap_with_default(); frame.set_flex_grow(flex_grow); frame }
/// Equivalent to the Rust `Frame::dom()` function.
#[no_mangle] pub extern "C" fn AzFrame_dom (frame: &mut AzFrame) -> AzDom{ frame.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// List view, optionally able to lazy-load data
#[repr(C)] pub struct AzListView { pub ptr: *mut c_void }
/// Creates a new `ListView` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `ListView::new()` constructor.
#[no_mangle] pub extern "C" fn AzListView_new (columns: AzStringVec) -> AzListView { let object: ListView = azul_layout::widgets::list_view::ListView::new(columns); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzListView { ptr } }
/// Equivalent to the Rust `ListView::with_rows()` function.
#[no_mangle] pub extern "C" fn AzListView_withRows (listview: &mut AzListView, rows: AzListViewRowVec) -> AzListView{ listview.with_rows(rows) }
/// Equivalent to the Rust `ListView::dom()` function.
#[no_mangle] pub extern "C" fn AzListView_dom (listview: &mut AzListView) -> AzDom{ listview.swap_with_default().dom() }
/* Error: Type is not stack allocated! */

/// Row of the ListView
#[repr(C)] pub struct AzListViewRow { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewOnLazyLoadScroll>` struct
#[repr(C)] pub struct AzListViewOnLazyLoadScroll { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewOnColumnClick>` struct
#[repr(C)] pub struct AzListViewOnColumnClick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewOnRowClick>` struct
#[repr(C)] pub struct AzListViewOnRowClick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<IFrameNode>` struct
#[repr(C)] pub struct AzIFrameNode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewState>` struct
#[repr(C)] pub struct AzListViewState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TabHeaderState>` struct
#[repr(C)] pub struct AzTabHeaderState { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// OpenGL texture, use `ReadOnlyWindow::create_texture` to create a texture
pub use azul_core::gl::Texture as AzTextureTT;
pub use AzTextureTT as AzTexture;
/// Creates a new `Texture` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Texture::new()` constructor.
#[no_mangle] pub extern "C" fn AzTexture_new (texture_id: u32, flags: AzTextureFlags, size: AzPhysicalSizeU32, background_color: AzColorU, gl_context: AzGlContextPtr, format: AzRawImageFormat) -> AzTexture { let object: Texture = azul_core::gl::Texture::new(texture_id, flags, size, background_color, gl_context, format); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTexture { ptr } }
/// Allocates an OpenGL texture of a given size with a single red channel (used for image masks)
#[no_mangle] pub extern "C" fn AzTexture_allocateRgba8 (gl: AzGlContextPtr, size: AzPhysicalSizeU32, background: AzColorU) -> AzTexture { let object: Texture = azul_core::gl::Texture::allocate_rgba8(gl, size, background); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTexture { ptr } }
/// Allocates an OpenGL texture of a given size with a single red channel (used for image masks)
#[no_mangle] pub extern "C" fn AzTexture_allocateClipMask (gl: AzGlContextPtr, size: AzPhysicalSizeU32, background: AzColorU) -> AzTexture { let object: Texture = azul_layout::xml::svg::allocate_clipmask_texture(gl, size, background); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTexture { ptr } }
/// Clears the texture with the currently set background color
#[no_mangle] pub extern "C" fn AzTexture_clear (texture: &mut AzTexture){ texture.clear() }
/// Draws a vertex / index buffer (aka. `&TessellatedSvgNode`) to the texture
#[no_mangle] pub extern "C" fn AzTexture_drawClipMask (texture: &mut AzTexture, node: AzTessellatedSvgNode) -> bool{ azul_layout::xml::svg::render_tessellated_node_gpu(texture, &node).is_some() }
/// Applies an FXAA filter to the texture
#[no_mangle] pub extern "C" fn AzTexture_applyFxaa (texture: &mut AzTexture) -> bool{ azul_layout::xml::svg::apply_fxaa(texture).is_some() }
/* Error: Type is not stack allocated! */

/// Passing *const c_void is not easily possible when generating APIs, so this wrapper struct is for easier API generation
pub use azul_core::gl::GlVoidPtrConst as AzGlVoidPtrConstTT;
pub use AzGlVoidPtrConstTT as AzGlVoidPtrConst;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GlVoidPtrMut>` struct
#[repr(C)] pub struct AzGlVoidPtrMut { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TextureFlags>` struct
#[repr(C)] pub struct AzTextureFlags { pub ptr: *mut c_void }
/// Default texture flags (not opaque, not a video texture)
#[no_mangle] pub extern "C" fn AzTextureFlags_default () -> AzTextureFlags { let object: TextureFlags = azul_core::gl::TextureFlags::default(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTextureFlags { ptr } }
/* Error: Type is not stack allocated! */

/// For .get_gl_precision_format(), but ABI-safe - returning an array or a tuple is not ABI-safe
#[repr(C)] pub struct AzGlShaderPrecisionFormatReturn { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GlContextPtr>` struct
pub use azul_core::gl::GlContextPtr as AzGlContextPtrTT;
pub use AzGlContextPtrTT as AzGlContextPtr;
/// Equivalent to the Rust `GlContextPtr::get_type()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getType (glcontextptr: &AzGlContextPtr) -> AzGlType{ glcontextptr.get_type() }
/// Equivalent to the Rust `GlContextPtr::buffer_data_untyped()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bufferDataUntyped (glcontextptr: &AzGlContextPtr, target: u32, size: isize, data: AzGlVoidPtrConst, usage: u32){ glcontextptr.buffer_data_untyped(target, size, data, usage) }
/// Equivalent to the Rust `GlContextPtr::buffer_sub_data_untyped()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bufferSubDataUntyped (glcontextptr: &AzGlContextPtr, target: u32, offset: isize, size: isize, data: AzGlVoidPtrConst){ glcontextptr.buffer_sub_data_untyped(target, offset, size, data) }
/// Equivalent to the Rust `GlContextPtr::map_buffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_mapBuffer (glcontextptr: &AzGlContextPtr, target: u32, access: u32) -> AzGlVoidPtrMut{ glcontextptr.map_buffer(target, access) }
/// Equivalent to the Rust `GlContextPtr::map_buffer_range()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_mapBufferRange (glcontextptr: &AzGlContextPtr, target: u32, offset: isize, length: isize, access: u32) -> AzGlVoidPtrMut{ glcontextptr.map_buffer_range(target, offset, length, access) }
/// Equivalent to the Rust `GlContextPtr::unmap_buffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_unmapBuffer (glcontextptr: &AzGlContextPtr, target: u32) -> u8{ glcontextptr.unmap_buffer(target) }
/// Equivalent to the Rust `GlContextPtr::tex_buffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texBuffer (glcontextptr: &AzGlContextPtr, target: u32, internal_format: u32, buffer: u32){ glcontextptr.tex_buffer(target, internal_format, buffer) }
/// Equivalent to the Rust `GlContextPtr::shader_source()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_shaderSource (glcontextptr: &AzGlContextPtr, shader: u32, strings: AzStringVec){ glcontextptr.shader_source(shader, strings) }
/// Equivalent to the Rust `GlContextPtr::read_buffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_readBuffer (glcontextptr: &AzGlContextPtr, mode: u32){ glcontextptr.read_buffer(mode) }
/// Equivalent to the Rust `GlContextPtr::read_pixels_into_buffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_readPixelsIntoBuffer (glcontextptr: &AzGlContextPtr, x: i32, y: i32, width: i32, height: i32, format: u32, pixel_type: u32, dst_buffer: AzU8VecRefMut){ glcontextptr.read_pixels_into_buffer(x, y, width, height, format, pixel_type, dst_buffer) }
/// Equivalent to the Rust `GlContextPtr::read_pixels()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_readPixels (glcontextptr: &AzGlContextPtr, x: i32, y: i32, width: i32, height: i32, format: u32, pixel_type: u32) -> AzU8Vec{ glcontextptr.read_pixels(x, y, width, height, format, pixel_type) }
/// Equivalent to the Rust `GlContextPtr::read_pixels_into_pbo()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_readPixelsIntoPbo (glcontextptr: &AzGlContextPtr, x: i32, y: i32, width: i32, height: i32, format: u32, pixel_type: u32){ glcontextptr.read_pixels_into_pbo(x, y, width, height, format, pixel_type) }
/// Equivalent to the Rust `GlContextPtr::sample_coverage()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_sampleCoverage (glcontextptr: &AzGlContextPtr, value: f32, invert: bool){ glcontextptr.sample_coverage(value, invert) }
/// Equivalent to the Rust `GlContextPtr::polygon_offset()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_polygonOffset (glcontextptr: &AzGlContextPtr, factor: f32, units: f32){ glcontextptr.polygon_offset(factor, units) }
/// Equivalent to the Rust `GlContextPtr::pixel_store_i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_pixelStoreI (glcontextptr: &AzGlContextPtr, name: u32, param: i32){ glcontextptr.pixel_store_i(name, param) }
/// Equivalent to the Rust `GlContextPtr::gen_buffers()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_genBuffers (glcontextptr: &AzGlContextPtr, n: i32) -> AzGLuintVec{ glcontextptr.gen_buffers(n) }
/// Equivalent to the Rust `GlContextPtr::gen_renderbuffers()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_genRenderbuffers (glcontextptr: &AzGlContextPtr, n: i32) -> AzGLuintVec{ glcontextptr.gen_renderbuffers(n) }
/// Equivalent to the Rust `GlContextPtr::gen_framebuffers()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_genFramebuffers (glcontextptr: &AzGlContextPtr, n: i32) -> AzGLuintVec{ glcontextptr.gen_framebuffers(n) }
/// Equivalent to the Rust `GlContextPtr::gen_textures()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_genTextures (glcontextptr: &AzGlContextPtr, n: i32) -> AzGLuintVec{ glcontextptr.gen_textures(n) }
/// Equivalent to the Rust `GlContextPtr::gen_vertex_arrays()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_genVertexArrays (glcontextptr: &AzGlContextPtr, n: i32) -> AzGLuintVec{ glcontextptr.gen_vertex_arrays(n) }
/// Equivalent to the Rust `GlContextPtr::gen_queries()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_genQueries (glcontextptr: &AzGlContextPtr, n: i32) -> AzGLuintVec{ glcontextptr.gen_queries(n) }
/// Equivalent to the Rust `GlContextPtr::begin_query()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_beginQuery (glcontextptr: &AzGlContextPtr, target: u32, id: u32){ glcontextptr.begin_query(target, id) }
/// Equivalent to the Rust `GlContextPtr::end_query()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_endQuery (glcontextptr: &AzGlContextPtr, target: u32){ glcontextptr.end_query(target) }
/// Equivalent to the Rust `GlContextPtr::query_counter()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_queryCounter (glcontextptr: &AzGlContextPtr, id: u32, target: u32){ glcontextptr.query_counter(id, target) }
/// Equivalent to the Rust `GlContextPtr::get_query_object_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getQueryObjectIv (glcontextptr: &AzGlContextPtr, id: u32, pname: u32) -> i32{ glcontextptr.get_query_object_iv(id, pname) }
/// Equivalent to the Rust `GlContextPtr::get_query_object_uiv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getQueryObjectUiv (glcontextptr: &AzGlContextPtr, id: u32, pname: u32) -> u32{ glcontextptr.get_query_object_uiv(id, pname) }
/// Equivalent to the Rust `GlContextPtr::get_query_object_i64v()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getQueryObjectI64v (glcontextptr: &AzGlContextPtr, id: u32, pname: u32) -> i64{ glcontextptr.get_query_object_i64v(id, pname) }
/// Equivalent to the Rust `GlContextPtr::get_query_object_ui64v()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getQueryObjectUi64v (glcontextptr: &AzGlContextPtr, id: u32, pname: u32) -> u64{ glcontextptr.get_query_object_ui64v(id, pname) }
/// Equivalent to the Rust `GlContextPtr::delete_queries()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteQueries (glcontextptr: &AzGlContextPtr, queries: AzGLuintVecRef){ glcontextptr.delete_queries(queries) }
/// Equivalent to the Rust `GlContextPtr::delete_vertex_arrays()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteVertexArrays (glcontextptr: &AzGlContextPtr, vertex_arrays: AzGLuintVecRef){ glcontextptr.delete_vertex_arrays(vertex_arrays) }
/// Equivalent to the Rust `GlContextPtr::delete_buffers()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteBuffers (glcontextptr: &AzGlContextPtr, buffers: AzGLuintVecRef){ glcontextptr.delete_buffers(buffers) }
/// Equivalent to the Rust `GlContextPtr::delete_renderbuffers()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteRenderbuffers (glcontextptr: &AzGlContextPtr, renderbuffers: AzGLuintVecRef){ glcontextptr.delete_renderbuffers(renderbuffers) }
/// Equivalent to the Rust `GlContextPtr::delete_framebuffers()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteFramebuffers (glcontextptr: &AzGlContextPtr, framebuffers: AzGLuintVecRef){ glcontextptr.delete_framebuffers(framebuffers) }
/// Equivalent to the Rust `GlContextPtr::delete_textures()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteTextures (glcontextptr: &AzGlContextPtr, textures: AzGLuintVecRef){ glcontextptr.delete_textures(textures) }
/// Equivalent to the Rust `GlContextPtr::framebuffer_renderbuffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_framebufferRenderbuffer (glcontextptr: &AzGlContextPtr, target: u32, attachment: u32, renderbuffertarget: u32, renderbuffer: u32){ glcontextptr.framebuffer_renderbuffer(target, attachment, renderbuffertarget, renderbuffer) }
/// Equivalent to the Rust `GlContextPtr::renderbuffer_storage()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_renderbufferStorage (glcontextptr: &AzGlContextPtr, target: u32, internalformat: u32, width: i32, height: i32){ glcontextptr.renderbuffer_storage(target, internalformat, width, height) }
/// Equivalent to the Rust `GlContextPtr::depth_func()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_depthFunc (glcontextptr: &AzGlContextPtr, func: u32){ glcontextptr.depth_func(func) }
/// Equivalent to the Rust `GlContextPtr::active_texture()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_activeTexture (glcontextptr: &AzGlContextPtr, texture: u32){ glcontextptr.active_texture(texture) }
/// Equivalent to the Rust `GlContextPtr::attach_shader()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_attachShader (glcontextptr: &AzGlContextPtr, program: u32, shader: u32){ glcontextptr.attach_shader(program, shader) }
/// Equivalent to the Rust `GlContextPtr::bind_attrib_location()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindAttribLocation (glcontextptr: &AzGlContextPtr, program: u32, index: u32, name: AzRefstr){ glcontextptr.bind_attrib_location(program, index, name) }
/// Equivalent to the Rust `GlContextPtr::get_uniform_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getUniformIv (glcontextptr: &AzGlContextPtr, program: u32, location: i32, result: AzGLintVecRefMut){ glcontextptr.get_uniform_iv(program, location, result) }
/// Equivalent to the Rust `GlContextPtr::get_uniform_fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getUniformFv (glcontextptr: &AzGlContextPtr, program: u32, location: i32, result: AzGLfloatVecRefMut){ glcontextptr.get_uniform_fv(program, location, result) }
/// Equivalent to the Rust `GlContextPtr::get_uniform_block_index()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getUniformBlockIndex (glcontextptr: &AzGlContextPtr, program: u32, name: AzRefstr) -> u32{ glcontextptr.get_uniform_block_index(program, name) }
/// Equivalent to the Rust `GlContextPtr::get_uniform_indices()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getUniformIndices (glcontextptr: &AzGlContextPtr, program: u32, names: AzRefstrVecRef) -> AzGLuintVec{ glcontextptr.get_uniform_indices(program, names) }
/// Equivalent to the Rust `GlContextPtr::bind_buffer_base()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindBufferBase (glcontextptr: &AzGlContextPtr, target: u32, index: u32, buffer: u32){ glcontextptr.bind_buffer_base(target, index, buffer) }
/// Equivalent to the Rust `GlContextPtr::bind_buffer_range()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindBufferRange (glcontextptr: &AzGlContextPtr, target: u32, index: u32, buffer: u32, offset: isize, size: isize){ glcontextptr.bind_buffer_range(target, index, buffer, offset, size) }
/// Equivalent to the Rust `GlContextPtr::uniform_block_binding()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniformBlockBinding (glcontextptr: &AzGlContextPtr, program: u32, uniform_block_index: u32, uniform_block_binding: u32){ glcontextptr.uniform_block_binding(program, uniform_block_index, uniform_block_binding) }
/// Equivalent to the Rust `GlContextPtr::bind_buffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindBuffer (glcontextptr: &AzGlContextPtr, target: u32, buffer: u32){ glcontextptr.bind_buffer(target, buffer) }
/// Equivalent to the Rust `GlContextPtr::bind_vertex_array()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindVertexArray (glcontextptr: &AzGlContextPtr, vao: u32){ glcontextptr.bind_vertex_array(vao) }
/// Equivalent to the Rust `GlContextPtr::bind_renderbuffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindRenderbuffer (glcontextptr: &AzGlContextPtr, target: u32, renderbuffer: u32){ glcontextptr.bind_renderbuffer(target, renderbuffer) }
/// Equivalent to the Rust `GlContextPtr::bind_framebuffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindFramebuffer (glcontextptr: &AzGlContextPtr, target: u32, framebuffer: u32){ glcontextptr.bind_framebuffer(target, framebuffer) }
/// Equivalent to the Rust `GlContextPtr::bind_texture()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindTexture (glcontextptr: &AzGlContextPtr, target: u32, texture: u32){ glcontextptr.bind_texture(target, texture) }
/// Equivalent to the Rust `GlContextPtr::draw_buffers()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_drawBuffers (glcontextptr: &AzGlContextPtr, bufs: AzGLenumVecRef){ glcontextptr.draw_buffers(bufs) }
/// Equivalent to the Rust `GlContextPtr::tex_image_2d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texImage2d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, internal_format: i32, width: i32, height: i32, border: i32, format: u32, ty: u32, opt_data: AzOptionU8VecRef){ glcontextptr.tex_image_2d(target, level, internal_format, width, height, border, format, ty, opt_data) }
/// Equivalent to the Rust `GlContextPtr::compressed_tex_image_2d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_compressedTexImage2d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, internal_format: u32, width: i32, height: i32, border: i32, data: AzU8VecRef){ glcontextptr.compressed_tex_image_2d(target, level, internal_format, width, height, border, data) }
/// Equivalent to the Rust `GlContextPtr::compressed_tex_sub_image_2d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_compressedTexSubImage2d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, data: AzU8VecRef){ glcontextptr.compressed_tex_sub_image_2d(target, level, xoffset, yoffset, width, height, format, data) }
/// Equivalent to the Rust `GlContextPtr::tex_image_3d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texImage3d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, internal_format: i32, width: i32, height: i32, depth: i32, border: i32, format: u32, ty: u32, opt_data: AzOptionU8VecRef){ glcontextptr.tex_image_3d(target, level, internal_format, width, height, depth, border, format, ty, opt_data) }
/// Equivalent to the Rust `GlContextPtr::copy_tex_image_2d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_copyTexImage2d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, internal_format: u32, x: i32, y: i32, width: i32, height: i32, border: i32){ glcontextptr.copy_tex_image_2d(target, level, internal_format, x, y, width, height, border) }
/// Equivalent to the Rust `GlContextPtr::copy_tex_sub_image_2d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_copyTexSubImage2d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, xoffset: i32, yoffset: i32, x: i32, y: i32, width: i32, height: i32){ glcontextptr.copy_tex_sub_image_2d(target, level, xoffset, yoffset, x, y, width, height) }
/// Equivalent to the Rust `GlContextPtr::copy_tex_sub_image_3d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_copyTexSubImage3d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, x: i32, y: i32, width: i32, height: i32){ glcontextptr.copy_tex_sub_image_3d(target, level, xoffset, yoffset, zoffset, x, y, width, height) }
/// Equivalent to the Rust `GlContextPtr::tex_sub_image_2d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texSubImage2d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, ty: u32, data: AzU8VecRef){ glcontextptr.tex_sub_image_2d(target, level, xoffset, yoffset, width, height, format, ty, data) }
/// Equivalent to the Rust `GlContextPtr::tex_sub_image_2d_pbo()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texSubImage2dPbo (glcontextptr: &AzGlContextPtr, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, ty: u32, offset: usize){ glcontextptr.tex_sub_image_2d_pbo(target, level, xoffset, yoffset, width, height, format, ty, offset) }
/// Equivalent to the Rust `GlContextPtr::tex_sub_image_3d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texSubImage3d (glcontextptr: &AzGlContextPtr, target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, width: i32, height: i32, depth: i32, format: u32, ty: u32, data: AzU8VecRef){ glcontextptr.tex_sub_image_3d(target, level, xoffset, yoffset, zoffset, width, height, depth, format, ty, data) }
/// Equivalent to the Rust `GlContextPtr::tex_sub_image_3d_pbo()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texSubImage3dPbo (glcontextptr: &AzGlContextPtr, target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, width: i32, height: i32, depth: i32, format: u32, ty: u32, offset: usize){ glcontextptr.tex_sub_image_3d_pbo(target, level, xoffset, yoffset, zoffset, width, height, depth, format, ty, offset) }
/// Equivalent to the Rust `GlContextPtr::tex_storage_2d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texStorage2d (glcontextptr: &AzGlContextPtr, target: u32, levels: i32, internal_format: u32, width: i32, height: i32){ glcontextptr.tex_storage_2d(target, levels, internal_format, width, height) }
/// Equivalent to the Rust `GlContextPtr::tex_storage_3d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texStorage3d (glcontextptr: &AzGlContextPtr, target: u32, levels: i32, internal_format: u32, width: i32, height: i32, depth: i32){ glcontextptr.tex_storage_3d(target, levels, internal_format, width, height, depth) }
/// Equivalent to the Rust `GlContextPtr::get_tex_image_into_buffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getTexImageIntoBuffer (glcontextptr: &AzGlContextPtr, target: u32, level: i32, format: u32, ty: u32, output: AzU8VecRefMut){ glcontextptr.get_tex_image_into_buffer(target, level, format, ty, output) }
/// Equivalent to the Rust `GlContextPtr::copy_image_sub_data()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_copyImageSubData (glcontextptr: &AzGlContextPtr, src_name: u32, src_target: u32, src_level: i32, src_x: i32, src_y: i32, src_z: i32, dst_name: u32, dst_target: u32, dst_level: i32, dst_x: i32, dst_y: i32, dst_z: i32, src_width: i32, src_height: i32, src_depth: i32){ glcontextptr.copy_image_sub_data(src_name, src_target, src_level, src_x, src_y, src_z, dst_name, dst_target, dst_level, dst_x, dst_y, dst_z, src_width, src_height, src_depth) }
/// Equivalent to the Rust `GlContextPtr::invalidate_framebuffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_invalidateFramebuffer (glcontextptr: &AzGlContextPtr, target: u32, attachments: AzGLenumVecRef){ glcontextptr.invalidate_framebuffer(target, attachments) }
/// Equivalent to the Rust `GlContextPtr::invalidate_sub_framebuffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_invalidateSubFramebuffer (glcontextptr: &AzGlContextPtr, target: u32, attachments: AzGLenumVecRef, xoffset: i32, yoffset: i32, width: i32, height: i32){ glcontextptr.invalidate_sub_framebuffer(target, attachments, xoffset, yoffset, width, height) }
/// Equivalent to the Rust `GlContextPtr::get_integer_v()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getIntegerV (glcontextptr: &AzGlContextPtr, name: u32, result: AzGLintVecRefMut){ glcontextptr.get_integer_v(name, result) }
/// Equivalent to the Rust `GlContextPtr::get_integer_64v()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getInteger64v (glcontextptr: &AzGlContextPtr, name: u32, result: AzGLint64VecRefMut){ glcontextptr.get_integer_64v(name, result) }
/// Equivalent to the Rust `GlContextPtr::get_integer_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getIntegerIv (glcontextptr: &AzGlContextPtr, name: u32, index: u32, result: AzGLintVecRefMut){ glcontextptr.get_integer_iv(name, index, result) }
/// Equivalent to the Rust `GlContextPtr::get_integer_64iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getInteger64iv (glcontextptr: &AzGlContextPtr, name: u32, index: u32, result: AzGLint64VecRefMut){ glcontextptr.get_integer_64iv(name, index, result) }
/// Equivalent to the Rust `GlContextPtr::get_boolean_v()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getBooleanV (glcontextptr: &AzGlContextPtr, name: u32, result: AzGLbooleanVecRefMut){ glcontextptr.get_boolean_v(name, result) }
/// Equivalent to the Rust `GlContextPtr::get_float_v()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getFloatV (glcontextptr: &AzGlContextPtr, name: u32, result: AzGLfloatVecRefMut){ glcontextptr.get_float_v(name, result) }
/// Equivalent to the Rust `GlContextPtr::get_framebuffer_attachment_parameter_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getFramebufferAttachmentParameterIv (glcontextptr: &AzGlContextPtr, target: u32, attachment: u32, pname: u32) -> i32{ glcontextptr.get_framebuffer_attachment_parameter_iv(target, attachment, pname) }
/// Equivalent to the Rust `GlContextPtr::get_renderbuffer_parameter_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getRenderbufferParameterIv (glcontextptr: &AzGlContextPtr, target: u32, pname: u32) -> i32{ glcontextptr.get_renderbuffer_parameter_iv(target, pname) }
/// Equivalent to the Rust `GlContextPtr::get_tex_parameter_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getTexParameterIv (glcontextptr: &AzGlContextPtr, target: u32, name: u32) -> i32{ glcontextptr.get_tex_parameter_iv(target, name) }
/// Equivalent to the Rust `GlContextPtr::get_tex_parameter_fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getTexParameterFv (glcontextptr: &AzGlContextPtr, target: u32, name: u32) -> f32{ glcontextptr.get_tex_parameter_fv(target, name) }
/// Equivalent to the Rust `GlContextPtr::tex_parameter_i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texParameterI (glcontextptr: &AzGlContextPtr, target: u32, pname: u32, param: i32){ glcontextptr.tex_parameter_i(target, pname, param) }
/// Equivalent to the Rust `GlContextPtr::tex_parameter_f()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_texParameterF (glcontextptr: &AzGlContextPtr, target: u32, pname: u32, param: f32){ glcontextptr.tex_parameter_f(target, pname, param) }
/// Equivalent to the Rust `GlContextPtr::framebuffer_texture_2d()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_framebufferTexture2d (glcontextptr: &AzGlContextPtr, target: u32, attachment: u32, textarget: u32, texture: u32, level: i32){ glcontextptr.framebuffer_texture_2d(target, attachment, textarget, texture, level) }
/// Equivalent to the Rust `GlContextPtr::framebuffer_texture_layer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_framebufferTextureLayer (glcontextptr: &AzGlContextPtr, target: u32, attachment: u32, texture: u32, level: i32, layer: i32){ glcontextptr.framebuffer_texture_layer(target, attachment, texture, level, layer) }
/// Equivalent to the Rust `GlContextPtr::blit_framebuffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_blitFramebuffer (glcontextptr: &AzGlContextPtr, src_x0: i32, src_y0: i32, src_x1: i32, src_y1: i32, dst_x0: i32, dst_y0: i32, dst_x1: i32, dst_y1: i32, mask: u32, filter: u32){ glcontextptr.blit_framebuffer(src_x0, src_y0, src_x1, src_y1, dst_x0, dst_y0, dst_x1, dst_y1, mask, filter) }
/// Equivalent to the Rust `GlContextPtr::vertex_attrib_4f()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_vertexAttrib4f (glcontextptr: &AzGlContextPtr, index: u32, x: f32, y: f32, z: f32, w: f32){ glcontextptr.vertex_attrib_4f(index, x, y, z, w) }
/// Equivalent to the Rust `GlContextPtr::vertex_attrib_pointer_f32()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_vertexAttribPointerF32 (glcontextptr: &AzGlContextPtr, index: u32, size: i32, normalized: bool, stride: i32, offset: u32){ glcontextptr.vertex_attrib_pointer_f32(index, size, normalized, stride, offset) }
/// Equivalent to the Rust `GlContextPtr::vertex_attrib_pointer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_vertexAttribPointer (glcontextptr: &AzGlContextPtr, index: u32, size: i32, type_: u32, normalized: bool, stride: i32, offset: u32){ glcontextptr.vertex_attrib_pointer(index, size, type_, normalized, stride, offset) }
/// Equivalent to the Rust `GlContextPtr::vertex_attrib_i_pointer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_vertexAttribIPointer (glcontextptr: &AzGlContextPtr, index: u32, size: i32, type_: u32, stride: i32, offset: u32){ glcontextptr.vertex_attrib_i_pointer(index, size, type_, stride, offset) }
/// Equivalent to the Rust `GlContextPtr::vertex_attrib_divisor()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_vertexAttribDivisor (glcontextptr: &AzGlContextPtr, index: u32, divisor: u32){ glcontextptr.vertex_attrib_divisor(index, divisor) }
/// Equivalent to the Rust `GlContextPtr::viewport()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_viewport (glcontextptr: &AzGlContextPtr, x: i32, y: i32, width: i32, height: i32){ glcontextptr.viewport(x, y, width, height) }
/// Equivalent to the Rust `GlContextPtr::scissor()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_scissor (glcontextptr: &AzGlContextPtr, x: i32, y: i32, width: i32, height: i32){ glcontextptr.scissor(x, y, width, height) }
/// Equivalent to the Rust `GlContextPtr::line_width()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_lineWidth (glcontextptr: &AzGlContextPtr, width: f32){ glcontextptr.line_width(width) }
/// Equivalent to the Rust `GlContextPtr::use_program()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_useProgram (glcontextptr: &AzGlContextPtr, program: u32){ glcontextptr.use_program(program) }
/// Equivalent to the Rust `GlContextPtr::validate_program()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_validateProgram (glcontextptr: &AzGlContextPtr, program: u32){ glcontextptr.validate_program(program) }
/// Equivalent to the Rust `GlContextPtr::draw_arrays()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_drawArrays (glcontextptr: &AzGlContextPtr, mode: u32, first: i32, count: i32){ glcontextptr.draw_arrays(mode, first, count) }
/// Equivalent to the Rust `GlContextPtr::draw_arrays_instanced()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_drawArraysInstanced (glcontextptr: &AzGlContextPtr, mode: u32, first: i32, count: i32, primcount: i32){ glcontextptr.draw_arrays_instanced(mode, first, count, primcount) }
/// Equivalent to the Rust `GlContextPtr::draw_elements()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_drawElements (glcontextptr: &AzGlContextPtr, mode: u32, count: i32, element_type: u32, indices_offset: u32){ glcontextptr.draw_elements(mode, count, element_type, indices_offset) }
/// Equivalent to the Rust `GlContextPtr::draw_elements_instanced()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_drawElementsInstanced (glcontextptr: &AzGlContextPtr, mode: u32, count: i32, element_type: u32, indices_offset: u32, primcount: i32){ glcontextptr.draw_elements_instanced(mode, count, element_type, indices_offset, primcount) }
/// Equivalent to the Rust `GlContextPtr::blend_color()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_blendColor (glcontextptr: &AzGlContextPtr, r: f32, g: f32, b: f32, a: f32){ glcontextptr.blend_color(r, g, b, a) }
/// Equivalent to the Rust `GlContextPtr::blend_func()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_blendFunc (glcontextptr: &AzGlContextPtr, sfactor: u32, dfactor: u32){ glcontextptr.blend_func(sfactor, dfactor) }
/// Equivalent to the Rust `GlContextPtr::blend_func_separate()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_blendFuncSeparate (glcontextptr: &AzGlContextPtr, src_rgb: u32, dest_rgb: u32, src_alpha: u32, dest_alpha: u32){ glcontextptr.blend_func_separate(src_rgb, dest_rgb, src_alpha, dest_alpha) }
/// Equivalent to the Rust `GlContextPtr::blend_equation()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_blendEquation (glcontextptr: &AzGlContextPtr, mode: u32){ glcontextptr.blend_equation(mode) }
/// Equivalent to the Rust `GlContextPtr::blend_equation_separate()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_blendEquationSeparate (glcontextptr: &AzGlContextPtr, mode_rgb: u32, mode_alpha: u32){ glcontextptr.blend_equation_separate(mode_rgb, mode_alpha) }
/// Equivalent to the Rust `GlContextPtr::color_mask()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_colorMask (glcontextptr: &AzGlContextPtr, r: bool, g: bool, b: bool, a: bool){ glcontextptr.color_mask(r, g, b, a) }
/// Equivalent to the Rust `GlContextPtr::cull_face()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_cullFace (glcontextptr: &AzGlContextPtr, mode: u32){ glcontextptr.cull_face(mode) }
/// Equivalent to the Rust `GlContextPtr::front_face()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_frontFace (glcontextptr: &AzGlContextPtr, mode: u32){ glcontextptr.front_face(mode) }
/// Equivalent to the Rust `GlContextPtr::enable()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_enable (glcontextptr: &AzGlContextPtr, cap: u32){ glcontextptr.enable(cap) }
/// Equivalent to the Rust `GlContextPtr::disable()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_disable (glcontextptr: &AzGlContextPtr, cap: u32){ glcontextptr.disable(cap) }
/// Equivalent to the Rust `GlContextPtr::hint()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_hint (glcontextptr: &AzGlContextPtr, param_name: u32, param_val: u32){ glcontextptr.hint(param_name, param_val) }
/// Equivalent to the Rust `GlContextPtr::is_enabled()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_isEnabled (glcontextptr: &AzGlContextPtr, cap: u32) -> u8{ glcontextptr.is_enabled(cap) }
/// Equivalent to the Rust `GlContextPtr::is_shader()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_isShader (glcontextptr: &AzGlContextPtr, shader: u32) -> u8{ glcontextptr.is_shader(shader) }
/// Equivalent to the Rust `GlContextPtr::is_texture()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_isTexture (glcontextptr: &AzGlContextPtr, texture: u32) -> u8{ glcontextptr.is_texture(texture) }
/// Equivalent to the Rust `GlContextPtr::is_framebuffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_isFramebuffer (glcontextptr: &AzGlContextPtr, framebuffer: u32) -> u8{ glcontextptr.is_framebuffer(framebuffer) }
/// Equivalent to the Rust `GlContextPtr::is_renderbuffer()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_isRenderbuffer (glcontextptr: &AzGlContextPtr, renderbuffer: u32) -> u8{ glcontextptr.is_renderbuffer(renderbuffer) }
/// Equivalent to the Rust `GlContextPtr::check_frame_buffer_status()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_checkFrameBufferStatus (glcontextptr: &AzGlContextPtr, target: u32) -> u32{ glcontextptr.check_frame_buffer_status(target) }
/// Equivalent to the Rust `GlContextPtr::enable_vertex_attrib_array()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_enableVertexAttribArray (glcontextptr: &AzGlContextPtr, index: u32){ glcontextptr.enable_vertex_attrib_array(index) }
/// Equivalent to the Rust `GlContextPtr::disable_vertex_attrib_array()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_disableVertexAttribArray (glcontextptr: &AzGlContextPtr, index: u32){ glcontextptr.disable_vertex_attrib_array(index) }
/// Equivalent to the Rust `GlContextPtr::uniform_1f()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform1f (glcontextptr: &AzGlContextPtr, location: i32, v0: f32){ glcontextptr.uniform_1f(location, v0) }
/// Equivalent to the Rust `GlContextPtr::uniform_1fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform1fv (glcontextptr: &AzGlContextPtr, location: i32, values: AzF32VecRef){ glcontextptr.uniform_1fv(location, values) }
/// Equivalent to the Rust `GlContextPtr::uniform_1i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform1i (glcontextptr: &AzGlContextPtr, location: i32, v0: i32){ glcontextptr.uniform_1i(location, v0) }
/// Equivalent to the Rust `GlContextPtr::uniform_1iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform1iv (glcontextptr: &AzGlContextPtr, location: i32, values: AzI32VecRef){ glcontextptr.uniform_1iv(location, values) }
/// Equivalent to the Rust `GlContextPtr::uniform_1ui()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform1ui (glcontextptr: &AzGlContextPtr, location: i32, v0: u32){ glcontextptr.uniform_1ui(location, v0) }
/// Equivalent to the Rust `GlContextPtr::uniform_2f()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform2f (glcontextptr: &AzGlContextPtr, location: i32, v0: f32, v1: f32){ glcontextptr.uniform_2f(location, v0, v1) }
/// Equivalent to the Rust `GlContextPtr::uniform_2fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform2fv (glcontextptr: &AzGlContextPtr, location: i32, values: AzF32VecRef){ glcontextptr.uniform_2fv(location, values) }
/// Equivalent to the Rust `GlContextPtr::uniform_2i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform2i (glcontextptr: &AzGlContextPtr, location: i32, v0: i32, v1: i32){ glcontextptr.uniform_2i(location, v0, v1) }
/// Equivalent to the Rust `GlContextPtr::uniform_2iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform2iv (glcontextptr: &AzGlContextPtr, location: i32, values: AzI32VecRef){ glcontextptr.uniform_2iv(location, values) }
/// Equivalent to the Rust `GlContextPtr::uniform_2ui()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform2ui (glcontextptr: &AzGlContextPtr, location: i32, v0: u32, v1: u32){ glcontextptr.uniform_2ui(location, v0, v1) }
/// Equivalent to the Rust `GlContextPtr::uniform_3f()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform3f (glcontextptr: &AzGlContextPtr, location: i32, v0: f32, v1: f32, v2: f32){ glcontextptr.uniform_3f(location, v0, v1, v2) }
/// Equivalent to the Rust `GlContextPtr::uniform_3fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform3fv (glcontextptr: &AzGlContextPtr, location: i32, values: AzF32VecRef){ glcontextptr.uniform_3fv(location, values) }
/// Equivalent to the Rust `GlContextPtr::uniform_3i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform3i (glcontextptr: &AzGlContextPtr, location: i32, v0: i32, v1: i32, v2: i32){ glcontextptr.uniform_3i(location, v0, v1, v2) }
/// Equivalent to the Rust `GlContextPtr::uniform_3iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform3iv (glcontextptr: &AzGlContextPtr, location: i32, values: AzI32VecRef){ glcontextptr.uniform_3iv(location, values) }
/// Equivalent to the Rust `GlContextPtr::uniform_3ui()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform3ui (glcontextptr: &AzGlContextPtr, location: i32, v0: u32, v1: u32, v2: u32){ glcontextptr.uniform_3ui(location, v0, v1, v2) }
/// Equivalent to the Rust `GlContextPtr::uniform_4f()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform4f (glcontextptr: &AzGlContextPtr, location: i32, x: f32, y: f32, z: f32, w: f32){ glcontextptr.uniform_4f(location, x, y, z, w) }
/// Equivalent to the Rust `GlContextPtr::uniform_4i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform4i (glcontextptr: &AzGlContextPtr, location: i32, x: i32, y: i32, z: i32, w: i32){ glcontextptr.uniform_4i(location, x, y, z, w) }
/// Equivalent to the Rust `GlContextPtr::uniform_4iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform4iv (glcontextptr: &AzGlContextPtr, location: i32, values: AzI32VecRef){ glcontextptr.uniform_4iv(location, values) }
/// Equivalent to the Rust `GlContextPtr::uniform_4ui()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform4ui (glcontextptr: &AzGlContextPtr, location: i32, x: u32, y: u32, z: u32, w: u32){ glcontextptr.uniform_4ui(location, x, y, z, w) }
/// Equivalent to the Rust `GlContextPtr::uniform_4fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniform4fv (glcontextptr: &AzGlContextPtr, location: i32, values: AzF32VecRef){ glcontextptr.uniform_4fv(location, values) }
/// Equivalent to the Rust `GlContextPtr::uniform_matrix_2fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniformMatrix2fv (glcontextptr: &AzGlContextPtr, location: i32, transpose: bool, value: AzF32VecRef){ glcontextptr.uniform_matrix_2fv(location, transpose, value) }
/// Equivalent to the Rust `GlContextPtr::uniform_matrix_3fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniformMatrix3fv (glcontextptr: &AzGlContextPtr, location: i32, transpose: bool, value: AzF32VecRef){ glcontextptr.uniform_matrix_3fv(location, transpose, value) }
/// Equivalent to the Rust `GlContextPtr::uniform_matrix_4fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_uniformMatrix4fv (glcontextptr: &AzGlContextPtr, location: i32, transpose: bool, value: AzF32VecRef){ glcontextptr.uniform_matrix_4fv(location, transpose, value) }
/// Equivalent to the Rust `GlContextPtr::depth_mask()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_depthMask (glcontextptr: &AzGlContextPtr, flag: bool){ glcontextptr.depth_mask(flag) }
/// Equivalent to the Rust `GlContextPtr::depth_range()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_depthRange (glcontextptr: &AzGlContextPtr, near: f64, far: f64){ glcontextptr.depth_range(near, far) }
/// Equivalent to the Rust `GlContextPtr::get_active_attrib()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getActiveAttrib (glcontextptr: &AzGlContextPtr, program: u32, index: u32) -> AzGetActiveAttribReturn{ glcontextptr.get_active_attrib(program, index) }
/// Equivalent to the Rust `GlContextPtr::get_active_uniform()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getActiveUniform (glcontextptr: &AzGlContextPtr, program: u32, index: u32) -> AzGetActiveUniformReturn{ glcontextptr.get_active_uniform(program, index) }
/// Equivalent to the Rust `GlContextPtr::get_active_uniforms_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getActiveUniformsIv (glcontextptr: &AzGlContextPtr, program: u32, indices: AzGLuintVec, pname: u32) -> AzGLintVec{ glcontextptr.get_active_uniforms_iv(program, indices, pname) }
/// Equivalent to the Rust `GlContextPtr::get_active_uniform_block_i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getActiveUniformBlockI (glcontextptr: &AzGlContextPtr, program: u32, index: u32, pname: u32) -> i32{ glcontextptr.get_active_uniform_block_i(program, index, pname) }
/// Equivalent to the Rust `GlContextPtr::get_active_uniform_block_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getActiveUniformBlockIv (glcontextptr: &AzGlContextPtr, program: u32, index: u32, pname: u32) -> AzGLintVec{ glcontextptr.get_active_uniform_block_iv(program, index, pname) }
/// Equivalent to the Rust `GlContextPtr::get_active_uniform_block_name()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getActiveUniformBlockName (glcontextptr: &AzGlContextPtr, program: u32, index: u32) -> AzString{ glcontextptr.get_active_uniform_block_name(program, index) }
/// Equivalent to the Rust `GlContextPtr::get_attrib_location()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getAttribLocation (glcontextptr: &AzGlContextPtr, program: u32, name: AzRefstr) -> i32{ glcontextptr.get_attrib_location(program, name) }
/// Equivalent to the Rust `GlContextPtr::get_frag_data_location()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getFragDataLocation (glcontextptr: &AzGlContextPtr, program: u32, name: AzRefstr) -> i32{ glcontextptr.get_frag_data_location(program, name) }
/// Equivalent to the Rust `GlContextPtr::get_uniform_location()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getUniformLocation (glcontextptr: &AzGlContextPtr, program: u32, name: AzRefstr) -> i32{ glcontextptr.get_uniform_location(program, name) }
/// Equivalent to the Rust `GlContextPtr::get_program_info_log()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getProgramInfoLog (glcontextptr: &AzGlContextPtr, program: u32) -> AzString{ glcontextptr.get_program_info_log(program) }
/// Equivalent to the Rust `GlContextPtr::get_program_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getProgramIv (glcontextptr: &AzGlContextPtr, program: u32, pname: u32, result: AzGLintVecRefMut){ glcontextptr.get_program_iv(program, pname, result) }
/// Equivalent to the Rust `GlContextPtr::get_program_binary()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getProgramBinary (glcontextptr: &AzGlContextPtr, program: u32) -> AzGetProgramBinaryReturn{ glcontextptr.get_program_binary(program) }
/// Equivalent to the Rust `GlContextPtr::program_binary()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_programBinary (glcontextptr: &AzGlContextPtr, program: u32, format: u32, binary: AzU8VecRef){ glcontextptr.program_binary(program, format, binary) }
/// Equivalent to the Rust `GlContextPtr::program_parameter_i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_programParameterI (glcontextptr: &AzGlContextPtr, program: u32, pname: u32, value: i32){ glcontextptr.program_parameter_i(program, pname, value) }
/// Equivalent to the Rust `GlContextPtr::get_vertex_attrib_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getVertexAttribIv (glcontextptr: &AzGlContextPtr, index: u32, pname: u32, result: AzGLintVecRefMut){ glcontextptr.get_vertex_attrib_iv(index, pname, result) }
/// Equivalent to the Rust `GlContextPtr::get_vertex_attrib_fv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getVertexAttribFv (glcontextptr: &AzGlContextPtr, index: u32, pname: u32, result: AzGLfloatVecRefMut){ glcontextptr.get_vertex_attrib_fv(index, pname, result) }
/// Equivalent to the Rust `GlContextPtr::get_vertex_attrib_pointer_v()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getVertexAttribPointerV (glcontextptr: &AzGlContextPtr, index: u32, pname: u32) -> isize{ glcontextptr.get_vertex_attrib_pointer_v(index, pname) }
/// Equivalent to the Rust `GlContextPtr::get_buffer_parameter_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getBufferParameterIv (glcontextptr: &AzGlContextPtr, target: u32, pname: u32) -> i32{ glcontextptr.get_buffer_parameter_iv(target, pname) }
/// Equivalent to the Rust `GlContextPtr::get_shader_info_log()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getShaderInfoLog (glcontextptr: &AzGlContextPtr, shader: u32) -> AzString{ glcontextptr.get_shader_info_log(shader) }
/// Equivalent to the Rust `GlContextPtr::get_string()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getString (glcontextptr: &AzGlContextPtr, which: u32) -> AzString{ glcontextptr.get_string(which) }
/// Equivalent to the Rust `GlContextPtr::get_string_i()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getStringI (glcontextptr: &AzGlContextPtr, which: u32, index: u32) -> AzString{ glcontextptr.get_string_i(which, index) }
/// Equivalent to the Rust `GlContextPtr::get_shader_iv()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getShaderIv (glcontextptr: &AzGlContextPtr, shader: u32, pname: u32, result: AzGLintVecRefMut){ glcontextptr.get_shader_iv(shader, pname, result) }
/// Equivalent to the Rust `GlContextPtr::get_shader_precision_format()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getShaderPrecisionFormat (glcontextptr: &AzGlContextPtr, shader_type: u32, precision_type: u32) -> AzGlShaderPrecisionFormatReturn{ glcontextptr.get_shader_precision_format(shader_type, precision_type) }
/// Equivalent to the Rust `GlContextPtr::compile_shader()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_compileShader (glcontextptr: &AzGlContextPtr, shader: u32){ glcontextptr.compile_shader(shader) }
/// Equivalent to the Rust `GlContextPtr::create_program()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_createProgram (glcontextptr: &AzGlContextPtr) -> u32{ glcontextptr.create_program() }
/// Equivalent to the Rust `GlContextPtr::delete_program()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteProgram (glcontextptr: &AzGlContextPtr, program: u32){ glcontextptr.delete_program(program) }
/// Equivalent to the Rust `GlContextPtr::create_shader()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_createShader (glcontextptr: &AzGlContextPtr, shader_type: u32) -> u32{ glcontextptr.create_shader(shader_type) }
/// Equivalent to the Rust `GlContextPtr::delete_shader()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteShader (glcontextptr: &AzGlContextPtr, shader: u32){ glcontextptr.delete_shader(shader) }
/// Equivalent to the Rust `GlContextPtr::detach_shader()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_detachShader (glcontextptr: &AzGlContextPtr, program: u32, shader: u32){ glcontextptr.detach_shader(program, shader) }
/// Equivalent to the Rust `GlContextPtr::link_program()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_linkProgram (glcontextptr: &AzGlContextPtr, program: u32){ glcontextptr.link_program(program) }
/// Equivalent to the Rust `GlContextPtr::clear_color()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_clearColor (glcontextptr: &AzGlContextPtr, r: f32, g: f32, b: f32, a: f32){ glcontextptr.clear_color(r, g, b, a) }
/// Equivalent to the Rust `GlContextPtr::clear()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_clear (glcontextptr: &AzGlContextPtr, buffer_mask: u32){ glcontextptr.clear(buffer_mask) }
/// Equivalent to the Rust `GlContextPtr::clear_depth()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_clearDepth (glcontextptr: &AzGlContextPtr, depth: f64){ glcontextptr.clear_depth(depth) }
/// Equivalent to the Rust `GlContextPtr::clear_stencil()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_clearStencil (glcontextptr: &AzGlContextPtr, s: i32){ glcontextptr.clear_stencil(s) }
/// Equivalent to the Rust `GlContextPtr::flush()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_flush (glcontextptr: &AzGlContextPtr){ glcontextptr.flush() }
/// Equivalent to the Rust `GlContextPtr::finish()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_finish (glcontextptr: &AzGlContextPtr){ glcontextptr.finish() }
/// Equivalent to the Rust `GlContextPtr::get_error()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getError (glcontextptr: &AzGlContextPtr) -> u32{ glcontextptr.get_error() }
/// Equivalent to the Rust `GlContextPtr::stencil_mask()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_stencilMask (glcontextptr: &AzGlContextPtr, mask: u32){ glcontextptr.stencil_mask(mask) }
/// Equivalent to the Rust `GlContextPtr::stencil_mask_separate()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_stencilMaskSeparate (glcontextptr: &AzGlContextPtr, face: u32, mask: u32){ glcontextptr.stencil_mask_separate(face, mask) }
/// Equivalent to the Rust `GlContextPtr::stencil_func()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_stencilFunc (glcontextptr: &AzGlContextPtr, func: u32, ref_: i32, mask: u32){ glcontextptr.stencil_func(func, ref_, mask) }
/// Equivalent to the Rust `GlContextPtr::stencil_func_separate()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_stencilFuncSeparate (glcontextptr: &AzGlContextPtr, face: u32, func: u32, ref_: i32, mask: u32){ glcontextptr.stencil_func_separate(face, func, ref_, mask) }
/// Equivalent to the Rust `GlContextPtr::stencil_op()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_stencilOp (glcontextptr: &AzGlContextPtr, sfail: u32, dpfail: u32, dppass: u32){ glcontextptr.stencil_op(sfail, dpfail, dppass) }
/// Equivalent to the Rust `GlContextPtr::stencil_op_separate()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_stencilOpSeparate (glcontextptr: &AzGlContextPtr, face: u32, sfail: u32, dpfail: u32, dppass: u32){ glcontextptr.stencil_op_separate(face, sfail, dpfail, dppass) }
/// Equivalent to the Rust `GlContextPtr::egl_image_target_texture2d_oes()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_eglImageTargetTexture2dOes (glcontextptr: &AzGlContextPtr, target: u32, image: AzGlVoidPtrConst){ glcontextptr.egl_image_target_texture2d_oes(target, image) }
/// Equivalent to the Rust `GlContextPtr::generate_mipmap()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_generateMipmap (glcontextptr: &AzGlContextPtr, target: u32){ glcontextptr.generate_mipmap(target) }
/// Equivalent to the Rust `GlContextPtr::insert_event_marker_ext()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_insertEventMarkerExt (glcontextptr: &AzGlContextPtr, message: AzRefstr){ glcontextptr.insert_event_marker_ext(message) }
/// Equivalent to the Rust `GlContextPtr::push_group_marker_ext()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_pushGroupMarkerExt (glcontextptr: &AzGlContextPtr, message: AzRefstr){ glcontextptr.push_group_marker_ext(message) }
/// Equivalent to the Rust `GlContextPtr::pop_group_marker_ext()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_popGroupMarkerExt (glcontextptr: &AzGlContextPtr){ glcontextptr.pop_group_marker_ext() }
/// Equivalent to the Rust `GlContextPtr::debug_message_insert_khr()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_debugMessageInsertKhr (glcontextptr: &AzGlContextPtr, source: u32, type_: u32, id: u32, severity: u32, message: AzRefstr){ glcontextptr.debug_message_insert_khr(source, type_, id, severity, message) }
/// Equivalent to the Rust `GlContextPtr::push_debug_group_khr()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_pushDebugGroupKhr (glcontextptr: &AzGlContextPtr, source: u32, id: u32, message: AzRefstr){ glcontextptr.push_debug_group_khr(source, id, message) }
/// Equivalent to the Rust `GlContextPtr::pop_debug_group_khr()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_popDebugGroupKhr (glcontextptr: &AzGlContextPtr){ glcontextptr.pop_debug_group_khr() }
/// Equivalent to the Rust `GlContextPtr::fence_sync()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_fenceSync (glcontextptr: &AzGlContextPtr, condition: u32, flags: u32) -> AzGLsyncPtr{ glcontextptr.fence_sync(condition, flags) }
/// Equivalent to the Rust `GlContextPtr::client_wait_sync()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_clientWaitSync (glcontextptr: &AzGlContextPtr, sync: AzGLsyncPtr, flags: u32, timeout: u64) -> u32{ glcontextptr.client_wait_sync(sync, flags, timeout) }
/// Equivalent to the Rust `GlContextPtr::wait_sync()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_waitSync (glcontextptr: &AzGlContextPtr, sync: AzGLsyncPtr, flags: u32, timeout: u64){ glcontextptr.wait_sync(sync, flags, timeout) }
/// Equivalent to the Rust `GlContextPtr::delete_sync()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteSync (glcontextptr: &AzGlContextPtr, sync: AzGLsyncPtr){ glcontextptr.delete_sync(sync) }
/// Equivalent to the Rust `GlContextPtr::texture_range_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_textureRangeApple (glcontextptr: &AzGlContextPtr, target: u32, data: AzU8VecRef){ glcontextptr.texture_range_apple(target, data) }
/// Equivalent to the Rust `GlContextPtr::gen_fences_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_genFencesApple (glcontextptr: &AzGlContextPtr, n: i32) -> AzGLuintVec{ glcontextptr.gen_fences_apple(n) }
/// Equivalent to the Rust `GlContextPtr::delete_fences_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteFencesApple (glcontextptr: &AzGlContextPtr, fences: AzGLuintVecRef){ glcontextptr.delete_fences_apple(fences) }
/// Equivalent to the Rust `GlContextPtr::set_fence_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_setFenceApple (glcontextptr: &AzGlContextPtr, fence: u32){ glcontextptr.set_fence_apple(fence) }
/// Equivalent to the Rust `GlContextPtr::finish_fence_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_finishFenceApple (glcontextptr: &AzGlContextPtr, fence: u32){ glcontextptr.finish_fence_apple(fence) }
/// Equivalent to the Rust `GlContextPtr::test_fence_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_testFenceApple (glcontextptr: &AzGlContextPtr, fence: u32){ glcontextptr.test_fence_apple(fence) }
/// Equivalent to the Rust `GlContextPtr::test_object_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_testObjectApple (glcontextptr: &AzGlContextPtr, object: u32, name: u32) -> u8{ glcontextptr.test_object_apple(object, name) }
/// Equivalent to the Rust `GlContextPtr::finish_object_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_finishObjectApple (glcontextptr: &AzGlContextPtr, object: u32, name: u32){ glcontextptr.finish_object_apple(object, name) }
/// Equivalent to the Rust `GlContextPtr::get_frag_data_index()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getFragDataIndex (glcontextptr: &AzGlContextPtr, program: u32, name: AzRefstr) -> i32{ glcontextptr.get_frag_data_index(program, name) }
/// Equivalent to the Rust `GlContextPtr::blend_barrier_khr()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_blendBarrierKhr (glcontextptr: &AzGlContextPtr){ glcontextptr.blend_barrier_khr() }
/// Equivalent to the Rust `GlContextPtr::bind_frag_data_location_indexed()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindFragDataLocationIndexed (glcontextptr: &AzGlContextPtr, program: u32, color_number: u32, index: u32, name: AzRefstr){ glcontextptr.bind_frag_data_location_indexed(program, color_number, index, name) }
/// Equivalent to the Rust `GlContextPtr::get_debug_messages()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_getDebugMessages (glcontextptr: &AzGlContextPtr) -> AzDebugMessageVec{ glcontextptr.get_debug_messages() }
/// Equivalent to the Rust `GlContextPtr::provoking_vertex_angle()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_provokingVertexAngle (glcontextptr: &AzGlContextPtr, mode: u32){ glcontextptr.provoking_vertex_angle(mode) }
/// Equivalent to the Rust `GlContextPtr::gen_vertex_arrays_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_genVertexArraysApple (glcontextptr: &AzGlContextPtr, n: i32) -> AzGLuintVec{ glcontextptr.gen_vertex_arrays_apple(n) }
/// Equivalent to the Rust `GlContextPtr::bind_vertex_array_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bindVertexArrayApple (glcontextptr: &AzGlContextPtr, vao: u32){ glcontextptr.bind_vertex_array_apple(vao) }
/// Equivalent to the Rust `GlContextPtr::delete_vertex_arrays_apple()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_deleteVertexArraysApple (glcontextptr: &AzGlContextPtr, vertex_arrays: AzGLuintVecRef){ glcontextptr.delete_vertex_arrays_apple(vertex_arrays) }
/// Equivalent to the Rust `GlContextPtr::copy_texture_chromium()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_copyTextureChromium (glcontextptr: &AzGlContextPtr, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, internal_format: i32, dest_type: u32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8){ glcontextptr.copy_texture_chromium(source_id, source_level, dest_target, dest_id, dest_level, internal_format, dest_type, unpack_flip_y, unpack_premultiply_alpha, unpack_unmultiply_alpha) }
/// Equivalent to the Rust `GlContextPtr::copy_sub_texture_chromium()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_copySubTextureChromium (glcontextptr: &AzGlContextPtr, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, x_offset: i32, y_offset: i32, x: i32, y: i32, width: i32, height: i32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8){ glcontextptr.copy_sub_texture_chromium(source_id, source_level, dest_target, dest_id, dest_level, x_offset, y_offset, x, y, width, height, unpack_flip_y, unpack_premultiply_alpha, unpack_unmultiply_alpha) }
/// Equivalent to the Rust `GlContextPtr::egl_image_target_renderbuffer_storage_oes()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_eglImageTargetRenderbufferStorageOes (glcontextptr: &AzGlContextPtr, target: u32, image: AzGlVoidPtrConst){ glcontextptr.egl_image_target_renderbuffer_storage_oes(target, image) }
/// Equivalent to the Rust `GlContextPtr::copy_texture_3d_angle()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_copyTexture3dAngle (glcontextptr: &AzGlContextPtr, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, internal_format: i32, dest_type: u32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8){ glcontextptr.copy_texture_3d_angle(source_id, source_level, dest_target, dest_id, dest_level, internal_format, dest_type, unpack_flip_y, unpack_premultiply_alpha, unpack_unmultiply_alpha) }
/// Equivalent to the Rust `GlContextPtr::copy_sub_texture_3d_angle()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_copySubTexture3dAngle (glcontextptr: &AzGlContextPtr, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, x_offset: i32, y_offset: i32, z_offset: i32, x: i32, y: i32, z: i32, width: i32, height: i32, depth: i32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8){ glcontextptr.copy_sub_texture_3d_angle(source_id, source_level, dest_target, dest_id, dest_level, x_offset, y_offset, z_offset, x, y, z, width, height, depth, unpack_flip_y, unpack_premultiply_alpha, unpack_unmultiply_alpha) }
/// Equivalent to the Rust `GlContextPtr::buffer_storage()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_bufferStorage (glcontextptr: &AzGlContextPtr, target: u32, size: isize, data: AzGlVoidPtrConst, flags: u32){ glcontextptr.buffer_storage(target, size, data, flags) }
/// Equivalent to the Rust `GlContextPtr::flush_mapped_buffer_range()` function.
#[no_mangle] pub extern "C" fn AzGlContextPtr_flushMappedBufferRange (glcontextptr: &AzGlContextPtr, target: u32, offset: isize, length: isize){ glcontextptr.flush_mapped_buffer_range(target, offset, length) }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `(U8Vec, u32)`
#[repr(C)] pub struct AzGetProgramBinaryReturn { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `(i32, u32, AzString)`
#[repr(C)] pub struct AzGetActiveAttribReturn { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `*const gleam::gl::GLsync`
pub use azul_core::gl::GLsyncPtr as AzGLsyncPtrTT;
pub use AzGLsyncPtrTT as AzGLsyncPtr;
/* Error: Type is not stack allocated! */

/// C-ABI stable reexport of `(i32, u32, AzString)`
#[repr(C)] pub struct AzGetActiveUniformReturn { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgVertex>` struct
#[repr(C)] pub struct AzSvgVertex { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VertexArrayObject>` struct
#[repr(C)] pub struct AzVertexArrayObject { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<IndexBufferFormat>` struct
#[repr(C)] pub struct AzIndexBufferFormat { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VertexBuffer>` struct
#[repr(C)] pub struct AzVertexBuffer { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GlType>` struct
#[repr(C)] pub struct AzGlType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

pub type AzGLuint = Azu32<>;

pub type AzGLint = Azi32<>;

pub type AzGLenum = Azu32<>;

/// Pointer to rust-allocated `Box<ImageRef>` struct
pub use azul_core::resources::ImageRef as AzImageRefTT;
pub use AzImageRefTT as AzImageRef;
/// Creates an "invalid" image with a width and height that reserves an image key, but does not render anything
#[no_mangle] pub extern "C" fn AzImageRef_nullImage (width: usize, height: usize, format: AzRawImageFormat, tag: AzU8Vec) -> AzImageRef { let object: ImageRef = azul_core::resources::ImageRef::null_image(width, height, format, tag.as_ref().to_vec()); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzImageRef { ptr } }
/// Creates an image reference from a CPU-backed buffer
#[no_mangle] pub extern "C" fn AzImageRef_rawImage (data: AzRawImage) -> AzOptionImageRef { let object: ImageRef = azul_core::resources::ImageRef::new_rawimage(data).into(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzImageRef { ptr } }
/// Creates an image reference from an OpenGL texture
#[no_mangle] pub extern "C" fn AzImageRef_glTexture (texture: AzTexture) -> AzImageRef { let object: ImageRef = azul_core::resources::ImageRef::new_gltexture(texture); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzImageRef { ptr } }
/// Creates a new copy of the image bytes instead of shallow-copying the reference
#[no_mangle] pub extern "C" fn AzImageRef_cloneBytes (imageref: &AzImageRef) -> AzImageRef{ imageref.deep_copy() }
/// Returns whether the image is a null (invalid) image
#[no_mangle] pub extern "C" fn AzImageRef_isInvalid (imageref: &AzImageRef) -> bool{ imageref.is_null_image() }
/// Returns whether the image is a GL texture
#[no_mangle] pub extern "C" fn AzImageRef_isGlTexture (imageref: &AzImageRef) -> bool{ imageref.is_gl_texture() }
/// Returns whether the image is a raw (CPU-decoded) image
#[no_mangle] pub extern "C" fn AzImageRef_isRawImage (imageref: &AzImageRef) -> bool{ imageref.is_raw_image() }
/// Returns whether the image is a `RenderImageCallback`
#[no_mangle] pub extern "C" fn AzImageRef_isCallback (imageref: &AzImageRef) -> bool{ imageref.is_callback() }
/// If the image is a RawImage, returns a COPY of the internal image bytes (useful for encoding the RawImage / exporting the ImageRef to a file)
#[no_mangle] pub extern "C" fn AzImageRef_getRawImage (imageref: &AzImageRef) -> AzOptionRawImage{ imageref.get_rawimage().into() }
/// Returns the hash of the ImageRef (fast)
#[no_mangle] pub extern "C" fn AzImageRef_getHash (imageref: &AzImageRef) -> u64{ imageref.get_hash().0 as u64 }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RawImage>` struct
#[repr(C)] pub struct AzRawImage { pub ptr: *mut c_void }
/// Returns a zero-sized image
#[no_mangle] pub extern "C" fn AzRawImage_empty () -> AzRawImage { let object: RawImage = azul_core::resources::RawImage::null_image(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzRawImage { ptr } }
/// Allocates a width * height, single-channel image with zeroed bytes
#[no_mangle] pub extern "C" fn AzRawImage_allocateClipMask (size: AzLayoutSize) -> AzRawImage { let object: RawImage = azul_core::resources::RawImage::allocate_mask(size); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzRawImage { ptr } }
/// Decodes a RawImage from any supported image format - automatically guesses the format based on magic header
#[no_mangle] pub extern "C" fn AzRawImage_decodeImageBytesAny (bytes: AzU8VecRef) -> AzResultRawImageDecodeImageError { let object: RawImage = azul_layout::image::decode::decode_raw_image_from_any_bytes(bytes.as_slice()); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzRawImage { ptr } }
/// Equivalent to the Rust `RawImage::draw_clip_mask()` function.
#[no_mangle] pub extern "C" fn AzRawImage_drawClipMask (rawimage: &mut AzRawImage, node: AzSvgNode, style: AzSvgStyle) -> bool{ azul_layout::xml::svg::render_node_clipmask_cpu(rawimage, &node, style).is_some() }
/// Encodes the RawImage in the BMP image format
#[no_mangle] pub extern "C" fn AzRawImage_encodeBmp (rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError{ azul_layout::image::encode::encode_bmp(rawimage) }
/// Encodes the RawImage in the PNG image format
#[no_mangle] pub extern "C" fn AzRawImage_encodePng (rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError{ azul_layout::image::encode::encode_png(rawimage) }
/// Encodes the RawImage in the JPG image format
#[no_mangle] pub extern "C" fn AzRawImage_encodeJpeg (rawimage: &AzRawImage, quality: u8) -> AzResultU8VecEncodeImageError{ azul_layout::image::encode::encode_jpeg(rawimage, quality) }
/// Encodes the RawImage in the TGA image format
#[no_mangle] pub extern "C" fn AzRawImage_encodeTga (rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError{ azul_layout::image::encode::encode_tga(rawimage) }
/// Encodes the RawImage in the PNM image format
#[no_mangle] pub extern "C" fn AzRawImage_encodePnm (rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError{ azul_layout::image::encode::encode_pnm(rawimage) }
/// Encodes the RawImage in the GIF image format
#[no_mangle] pub extern "C" fn AzRawImage_encodeGif (rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError{ azul_layout::image::encode::encode_gif(rawimage) }
/// Encodes the RawImage in the TIFF image format
#[no_mangle] pub extern "C" fn AzRawImage_encodeTiff (rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError{ azul_layout::image::encode::encode_tiff(rawimage) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ImageMask>` struct
#[repr(C)] pub struct AzImageMask { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RawImageFormat>` struct
#[repr(C)] pub struct AzRawImageFormat { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RawImageData>` struct
#[repr(C)] pub struct AzRawImageData { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ImageRendering>` struct
#[repr(C)] pub struct AzImageRendering { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Font metrics structure containing all font-related measurements from the font file tables (head, hhea, and os/2 tables).
#[repr(C)] pub struct AzFontMetrics { pub ptr: *mut c_void }
/// Returns a FontMetrics struct with all fields set to 0
#[no_mangle] pub extern "C" fn AzFontMetrics_zero () -> AzFontMetrics { let object: FontMetrics = azul_css::props::basic::FontMetrics::zero(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzFontMetrics { ptr } }
/* Error: Type is not stack allocated! */

/// FontRef is a reference-counted pointer to a parsed font. It holds a *const c_void that points to the actual parsed font data (typically a ParsedFont from the layout crate). The parsed data is managed via atomic reference counting, allowing safe sharing across threads without duplicating the font data.
pub use azul_css::props::basic::font::FontRef as AzFontRefTT;
pub use AzFontRefTT as AzFontRef;
/// Parses a new font from bytes. Returns `None` if the font could not be parsed correctly.
#[no_mangle] pub extern "C" fn AzFontRef_parse (source: AzLoadedFontSource) -> AzOptionFontRef { let object: FontRef = azul_layout::parse_font_fn(source).into(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzFontRef { ptr } }
/// Returns the hash of the FontRef (fast)
#[no_mangle] pub extern "C" fn AzFontRef_getHash (fontref: &AzFontRef) -> u64{ azul_core::resources::font_ref_get_hash(fontref) }
/* Error: Type is not stack allocated! */

/// Source data of a font file (bytes)
#[repr(C)] pub struct AzLoadedFontSource { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Svg>` struct
pub use azul_core::svg::Svg as AzSvgTT;
pub use AzSvgTT as AzSvg;
/// Creates a new `Svg` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Svg::from_string()` constructor.
#[no_mangle] pub extern "C" fn AzSvg_fromString (svg_string: AzString, parse_options: AzSvgParseOptions) -> AzResultSvgSvgParseError { let object: Svg = match azul_layout::xml::svg::svg_parse(svg_string.as_ref().as_bytes(), parse_options) { Ok(o) => azul_core::svg::ResultSvgSvgParseError::Ok(unsafe { core::mem::transmute(o) }), Err(e) => azul_core::svg::ResultSvgSvgParseError::Err(e) }; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzSvg { ptr } }
/// Creates a new `Svg` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `Svg::from_bytes()` constructor.
#[no_mangle] pub extern "C" fn AzSvg_fromBytes (svg_bytes: AzU8VecRef, parse_options: AzSvgParseOptions) -> AzResultSvgSvgParseError { let object: Svg = match azul_layout::xml::svg::svg_parse(svg_bytes.as_slice(), parse_options) { Ok(o) => azul_core::svg::ResultSvgSvgParseError::Ok(unsafe { core::mem::transmute(o) }), Err(e) => azul_core::svg::ResultSvgSvgParseError::Err(e) }; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzSvg { ptr } }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgMultiPolygon>` struct
#[repr(C)] pub struct AzSvgMultiPolygon { pub ptr: *mut c_void }
/// Returns the bounds of the polygon
#[no_mangle] pub extern "C" fn AzSvgMultiPolygon_getBounds (svgmultipolygon: &AzSvgMultiPolygon) -> AzSvgRect{ svgmultipolygon.get_bounds() }
/// Returns whether the polygon contains a point
#[no_mangle] pub extern "C" fn AzSvgMultiPolygon_containsPoint (svgmultipolygon: &AzSvgMultiPolygon, point: AzSvgPoint, fill_rule: AzSvgFillRule, tolerance: f32) -> bool{ azul_layout::xml::svg::polygon_contains_point(svgmultipolygon, point, fill_rule, tolerance) }
/// Unions two MultiPolygons, returns the unioned MultiPolygon
#[no_mangle] pub extern "C" fn AzSvgMultiPolygon_union (svgmultipolygon: &AzSvgMultiPolygon, other: AzSvgMultiPolygon) -> AzSvgMultiPolygon{ azul_layout::xml::svg::svg_multi_polygon_union(svgmultipolygon, &other) }
/// Intersects two MultiPolygons, returns the intersected MultiPolygon
#[no_mangle] pub extern "C" fn AzSvgMultiPolygon_intersection (svgmultipolygon: &AzSvgMultiPolygon, other: AzSvgMultiPolygon) -> AzSvgMultiPolygon{ azul_layout::xml::svg::svg_multi_polygon_intersection(svgmultipolygon, &other) }
/// Calculates the difference two MultiPolygons, returns a MultiPolygon
#[no_mangle] pub extern "C" fn AzSvgMultiPolygon_difference (svgmultipolygon: &AzSvgMultiPolygon, other: AzSvgMultiPolygon) -> AzSvgMultiPolygon{ azul_layout::xml::svg::svg_multi_polygon_difference(svgmultipolygon, &other) }
/// Xors two MultiPolygons, returns a MultiPolygon
#[no_mangle] pub extern "C" fn AzSvgMultiPolygon_xor (svgmultipolygon: &AzSvgMultiPolygon, other: AzSvgMultiPolygon) -> AzSvgMultiPolygon{ azul_layout::xml::svg::svg_multi_polygon_xor(svgmultipolygon, &other) }
/// Equivalent to the Rust `SvgMultiPolygon::tessellate_fill()` function.
#[no_mangle] pub extern "C" fn AzSvgMultiPolygon_tessellateFill (svgmultipolygon: &AzSvgMultiPolygon, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_multi_polygon_fill(svgmultipolygon, fill_style) }
/// Equivalent to the Rust `SvgMultiPolygon::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgMultiPolygon_tessellateStroke (svgmultipolygon: &AzSvgMultiPolygon, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_multi_polygon_stroke(svgmultipolygon, stroke_style) }
/* Error: Type is not stack allocated! */

/// One `SvgNode` corresponds to one SVG `<path></path>` element
#[repr(C)] pub struct AzSvgNode { pub ptr: *mut c_void }
/// Equivalent to the Rust `SvgNode::tessellate_fill()` function.
#[no_mangle] pub extern "C" fn AzSvgNode_tessellateFill (svgnode: &AzSvgNode, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_node_fill(svgnode, fill_style) }
/// Equivalent to the Rust `SvgNode::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgNode_tessellateStroke (svgnode: &AzSvgNode, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_node_stroke(svgnode, stroke_style) }
/// Returns whether the shape is closed
#[no_mangle] pub extern "C" fn AzSvgNode_isClosed (svgnode: &AzSvgNode) -> bool{ svgnode.is_closed() }
/// Returns the bounds of the polygon
#[no_mangle] pub extern "C" fn AzSvgNode_containsPoint (svgnode: &AzSvgNode, point: AzSvgPoint, fill_rule: AzSvgFillRule, tolerance: f32) -> bool{ azul_layout::xml::svg::svg_node_contains_point(svgnode, point, fill_rule, tolerance) }
/// Equivalent to the Rust `SvgNode::get_bounds()` function.
#[no_mangle] pub extern "C" fn AzSvgNode_getBounds (svgnode: &AzSvgNode) -> AzSvgRect{ svgnode.get_bounds() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgCircle>` struct
#[repr(C)] pub struct AzSvgCircle { pub ptr: *mut c_void }
/// Equivalent to the Rust `SvgCircle::tessellate_fill()` function.
#[no_mangle] pub extern "C" fn AzSvgCircle_tessellateFill (svgcircle: &AzSvgCircle, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_circle_fill(svgcircle, fill_style) }
/// Equivalent to the Rust `SvgCircle::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgCircle_tessellateStroke (svgcircle: &AzSvgCircle, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_circle_stroke(svgcircle, stroke_style) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgPath>` struct
#[repr(C)] pub struct AzSvgPath { pub ptr: *mut c_void }
/// Returns whether the path is closed
#[no_mangle] pub extern "C" fn AzSvgPath_isClosed (svgpath: &AzSvgPath) -> bool{ svgpath.is_closed() }
/// Reverses the order of points in the path so that the path runs in the opposite direction afterwards
#[no_mangle] pub extern "C" fn AzSvgPath_reverse (svgpath: &mut AzSvgPath){ svgpath.reverse() }
/// Returns the first point of the path (or None if path has no items)
#[no_mangle] pub extern "C" fn AzSvgPath_getStart (svgpath: &AzSvgPath) -> AzOptionSvgPoint{ svgpath.get_start().into() }
/// Returns the first point of the path (or None if path has no items)
#[no_mangle] pub extern "C" fn AzSvgPath_getEnd (svgpath: &AzSvgPath) -> AzOptionSvgPoint{ svgpath.get_end().into() }
/// Returns the axis-aligned bounding rect of this path
#[no_mangle] pub extern "C" fn AzSvgPath_getBounds (svgpath: &mut AzSvgPath) -> AzSvgRect{ svgpath.get_bounds() }
/// Adds a path to the end of the current path
#[no_mangle] pub extern "C" fn AzSvgPath_joinWith (svgpath: &mut AzSvgPath, path: AzSvgPath){ svgpath.join_with(path); }
/// Offset the path by a certain distance. Will create bezier curves around the edges when the path is closed
#[no_mangle] pub extern "C" fn AzSvgPath_offset (svgpath: &mut AzSvgPath, distance: f32, join: AzSvgLineJoin, cap: AzSvgLineCap) -> AzSvgPath{ azul_layout::xml::svg::svg_path_offset(svgpath, distance, join, cap) }
/// Round the edges with a cubic curve
#[no_mangle] pub extern "C" fn AzSvgPath_bevel (svgpath: &mut AzSvgPath, distance: f32) -> AzSvgPath{ azul_layout::xml::svg::svg_path_bevel(svgpath, distance) }
/// Equivalent to the Rust `SvgPath::tessellate_fill()` function.
#[no_mangle] pub extern "C" fn AzSvgPath_tessellateFill (svgpath: &AzSvgPath, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_path_fill(svgpath, fill_style) }
/// Equivalent to the Rust `SvgPath::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgPath_tessellateStroke (svgpath: &AzSvgPath, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_path_stroke(svgpath, stroke_style) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgPathElement>` struct
#[repr(C)] pub struct AzSvgPathElement { pub ptr: *mut c_void }
/// Reverses the order of points in the path so that the path runs in the opposite direction afterwards
#[no_mangle] pub extern "C" fn AzSvgPathElement_reverse (svgpathelement: &mut AzSvgPathElement){ svgpathelement.reverse() }
/// Returns the starting point of this item
#[no_mangle] pub extern "C" fn AzSvgPathElement_getStart (svgpathelement: &AzSvgPathElement) -> AzSvgPoint{ svgpathelement.get_start() }
/// Returns the ending point of this item
#[no_mangle] pub extern "C" fn AzSvgPathElement_getEnd (svgpathelement: &AzSvgPathElement) -> AzSvgPoint{ svgpathelement.get_end() }
/// Returns the bounding box of this item
#[no_mangle] pub extern "C" fn AzSvgPathElement_getBounds (svgpathelement: &AzSvgPathElement) -> AzSvgRect{ svgpathelement.get_bounds() }
/// Returns the length of the line or curve
#[no_mangle] pub extern "C" fn AzSvgPathElement_getLength (svgpathelement: &AzSvgPathElement) -> f64{ svgpathelement.get_length() }
/// Returns the interpolation value t (between 0 and 1) at the given offset from the line or curve start
#[no_mangle] pub extern "C" fn AzSvgPathElement_getTAtOffset (svgpathelement: &AzSvgPathElement, offset: f64) -> f64{ svgpathelement.get_t_at_offset(offset) }
/// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
#[no_mangle] pub extern "C" fn AzSvgPathElement_getXAtT (svgpathelement: &AzSvgPathElement, t: f64) -> f64{ svgpathelement.get_x_at_t(t) }
/// Returns the y position of the line or curve at t
#[no_mangle] pub extern "C" fn AzSvgPathElement_getYAtT (svgpathelement: &AzSvgPathElement, t: f64) -> f64{ svgpathelement.get_y_at_t(t) }
/// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between 0 and 1)
#[no_mangle] pub extern "C" fn AzSvgPathElement_getTangentVectorAtT (svgpathelement: &AzSvgPathElement, t: f64) -> AzSvgVector{ svgpathelement.get_tangent_vector_at_t(t) }
/// Equivalent to the Rust `SvgPathElement::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgPathElement_tessellateStroke (svgpathelement: &AzSvgPathElement, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_svgpathelement_stroke(svgpathelement, stroke_style) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgPoint>` struct
#[repr(C)] pub struct AzSvgPoint { pub ptr: *mut c_void }
/// Returns the euclidean distance to some other point
#[no_mangle] pub extern "C" fn AzSvgPoint_distance (svgpoint: &AzSvgPoint, other: AzSvgPoint) -> f64{ svgpoint.distance(other) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgVector>` struct
#[repr(C)] pub struct AzSvgVector { pub ptr: *mut c_void }
/// Returns the angle of this vector in degrees
#[no_mangle] pub extern "C" fn AzSvgVector_angleDegrees (svgvector: &AzSvgVector) -> f64{ svgvector.angle_degrees() }
/// Normalizes the vector, returning the normalized vector
#[no_mangle] pub extern "C" fn AzSvgVector_normalize (svgvector: &AzSvgVector) -> AzSvgVector{ svgvector.normalize() }
/// Rotates the vector 90 degrees counter clockwise, returning the rotated vector
#[no_mangle] pub extern "C" fn AzSvgVector_rotate90degCcw (svgvector: &AzSvgVector) -> AzSvgVector{ svgvector.rotate_90deg_ccw() }
/* Error: Type is not stack allocated! */

/// A line segment in 2D space.
#[repr(C)] pub struct AzSvgLine { pub ptr: *mut c_void }
/// Reverses the order of points in the path so that the path runs in the opposite direction afterwards
#[no_mangle] pub extern "C" fn AzSvgLine_reverse (svgline: &mut AzSvgLine){ svgline.reverse() }
/// Returns the starting point of this item
#[no_mangle] pub extern "C" fn AzSvgLine_getStart (svgline: &AzSvgLine) -> AzSvgPoint{ svgline.get_start() }
/// Returns the ending point of this item
#[no_mangle] pub extern "C" fn AzSvgLine_getEnd (svgline: &AzSvgLine) -> AzSvgPoint{ svgline.get_end() }
/// Returns the bounding box of this item
#[no_mangle] pub extern "C" fn AzSvgLine_getBounds (svgline: &AzSvgLine) -> AzSvgRect{ svgline.get_bounds() }
/// Returns the length of the line or curve
#[no_mangle] pub extern "C" fn AzSvgLine_getLength (svgline: &AzSvgLine) -> f64{ svgline.get_length() }
/// Returns the interpolation value t (between 0 and 1) at the given offset from the line or curve start
#[no_mangle] pub extern "C" fn AzSvgLine_getTAtOffset (svgline: &AzSvgLine, offset: f64) -> f64{ svgline.get_t_at_offset(offset) }
/// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
#[no_mangle] pub extern "C" fn AzSvgLine_getXAtT (svgline: &AzSvgLine, t: f64) -> f64{ svgline.get_x_at_t(t) }
/// Returns the y position of the line or curve at t
#[no_mangle] pub extern "C" fn AzSvgLine_getYAtT (svgline: &AzSvgLine, t: f64) -> f64{ svgline.get_y_at_t(t) }
/// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between 0 and 1)
#[no_mangle] pub extern "C" fn AzSvgLine_getTangentVectorAtT (svgline: &AzSvgLine, t: f64) -> AzSvgVector{ svgline.get_tangent_vector_at_t(t) }
/// Intersect two lines EVEN IF THEY ARE DISTINCT. Only returns None on parallel lines (never intersect)
#[no_mangle] pub extern "C" fn AzSvgLine_intersect (svgline: &AzSvgLine, other: AzSvgLine) -> AzOptionSvgPoint{ azul_layout::xml::svg::raw_line_intersection(svgline, &other).into() }
/// Equivalent to the Rust `SvgLine::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgLine_tessellateStroke (svgline: &AzSvgLine, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_line_stroke(svgline, stroke_style) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgQuadraticCurve>` struct
#[repr(C)] pub struct AzSvgQuadraticCurve { pub ptr: *mut c_void }
/// Reverses the order of points in the curve so that the curve runs in the opposite direction afterwards
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_reverse (svgquadraticcurve: &mut AzSvgQuadraticCurve){ svgquadraticcurve.reverse() }
/// Returns the starting point of this item
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_getStart (svgquadraticcurve: &AzSvgQuadraticCurve) -> AzSvgPoint{ svgquadraticcurve.get_start() }
/// Returns the ending point of this item
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_getEnd (svgquadraticcurve: &AzSvgQuadraticCurve) -> AzSvgPoint{ svgquadraticcurve.get_end() }
/// Returns the bounding box of this item
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_getBounds (svgquadraticcurve: &AzSvgQuadraticCurve) -> AzSvgRect{ svgquadraticcurve.get_bounds() }
/// Returns the length of the line or curve
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_getLength (svgquadraticcurve: &AzSvgQuadraticCurve) -> f64{ svgquadraticcurve.get_length() }
/// Returns the interpolation value t (between 0 and 1) at the given offset from the line or curve start
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_getTAtOffset (svgquadraticcurve: &AzSvgQuadraticCurve, offset: f64) -> f64{ svgquadraticcurve.get_t_at_offset(offset) }
/// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_getXAtT (svgquadraticcurve: &AzSvgQuadraticCurve, t: f64) -> f64{ svgquadraticcurve.get_x_at_t(t) }
/// Returns the y position of the line or curve at t
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_getYAtT (svgquadraticcurve: &AzSvgQuadraticCurve, t: f64) -> f64{ svgquadraticcurve.get_y_at_t(t) }
/// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between 0 and 1)
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_getTangentVectorAtT (svgquadraticcurve: &AzSvgQuadraticCurve, t: f64) -> AzSvgVector{ svgquadraticcurve.get_tangent_vector_at_t(t) }
/// Equivalent to the Rust `SvgQuadraticCurve::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgQuadraticCurve_tessellateStroke (svgquadraticcurve: &AzSvgQuadraticCurve, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_quadraticcurve_stroke(svgquadraticcurve, stroke_style) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgCubicCurve>` struct
#[repr(C)] pub struct AzSvgCubicCurve { pub ptr: *mut c_void }
/// Reverses the order of points in the curve so that the curve runs in the opposite direction afterwards
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_reverse (svgcubiccurve: &mut AzSvgCubicCurve){ svgcubiccurve.reverse() }
/// Returns the starting point of this item
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_getStart (svgcubiccurve: &AzSvgCubicCurve) -> AzSvgPoint{ svgcubiccurve.get_start() }
/// Returns the ending point of this item
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_getEnd (svgcubiccurve: &AzSvgCubicCurve) -> AzSvgPoint{ svgcubiccurve.get_end() }
/// Returns the bounding box of this item
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_getBounds (svgcubiccurve: &AzSvgCubicCurve) -> AzSvgRect{ svgcubiccurve.get_bounds() }
/// Returns the length of the line or curve
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_getLength (svgcubiccurve: &AzSvgCubicCurve) -> f64{ svgcubiccurve.get_length() }
/// Returns the interpolation value t (between 0 and 1) at the given offset from the line or curve start
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_getTAtOffset (svgcubiccurve: &AzSvgCubicCurve, offset: f64) -> f64{ svgcubiccurve.get_t_at_offset(offset) }
/// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_getXAtT (svgcubiccurve: &AzSvgCubicCurve, t: f64) -> f64{ svgcubiccurve.get_x_at_t(t) }
/// Returns the y position of the line or curve at t
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_getYAtT (svgcubiccurve: &AzSvgCubicCurve, t: f64) -> f64{ svgcubiccurve.get_y_at_t(t) }
/// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between 0 and 1)
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_getTangentVectorAtT (svgcubiccurve: &AzSvgCubicCurve, t: f64) -> AzSvgVector{ svgcubiccurve.get_tangent_vector_at_t(t) }
/// Equivalent to the Rust `SvgCubicCurve::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgCubicCurve_tessellateStroke (svgcubiccurve: &AzSvgCubicCurve, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_cubiccurve_stroke(svgcubiccurve, stroke_style) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgRect>` struct
#[repr(C)] pub struct AzSvgRect { pub ptr: *mut c_void }
/// Equivalent to the Rust `SvgRect::get_center()` function.
#[no_mangle] pub extern "C" fn AzSvgRect_getCenter (svgrect: &AzSvgRect) -> AzSvgPoint{ svgrect.get_center() }
/// Equivalent to the Rust `SvgRect::contains_point()` function.
#[no_mangle] pub extern "C" fn AzSvgRect_containsPoint (svgrect: &AzSvgRect, point: AzSvgPoint) -> bool{ svgrect.contains_point(point.x, point.y) }
/// Equivalent to the Rust `SvgRect::expand()` function.
#[no_mangle] pub extern "C" fn AzSvgRect_expand (svgrect: &AzSvgRect, padding_top: f32, padding_bottom: f32, padding_left: f32, padding_right: f32) -> AzSvgRect{ svgrect.expand(padding_top, padding_bottom, padding_left, padding_right) }
/// Equivalent to the Rust `SvgRect::tessellate_fill()` function.
#[no_mangle] pub extern "C" fn AzSvgRect_tessellateFill (svgrect: &AzSvgRect, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_rect_fill(svgrect, fill_style) }
/// Equivalent to the Rust `SvgRect::tessellate_stroke()` function.
#[no_mangle] pub extern "C" fn AzSvgRect_tessellateStroke (svgrect: &AzSvgRect, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode{ azul_layout::xml::svg::tessellate_rect_stroke(svgrect, stroke_style) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TessellatedSvgNode>` struct
#[repr(C)] pub struct AzTessellatedSvgNode { pub ptr: *mut c_void }
/// Returns an empty buffer vertices / indices
#[no_mangle] pub extern "C" fn AzTessellatedSvgNode_empty () -> AzTessellatedSvgNode { let object: TessellatedSvgNode = azul_core::svg::TessellatedSvgNode::empty(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTessellatedSvgNode { ptr } }
/// Creates a new TessellatedSvgNode by joining all the given nodes together into one array and inserting a `GL_RESTART_INDEX` (`u32::MAX`) into the indices (so that the resulting buffer can be drawn in one draw call).
#[no_mangle] pub extern "C" fn AzTessellatedSvgNode_fromNodes (nodes: AzTessellatedSvgNodeVecRef) -> AzTessellatedSvgNode { let object: TessellatedSvgNode = azul_layout::xml::svg::join_tessellated_nodes(nodes.as_slice()); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzTessellatedSvgNode { ptr } }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgDashPattern>` struct
#[repr(C)] pub struct AzSvgDashPattern { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgFitTo>` struct
#[repr(C)] pub struct AzSvgFitTo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgFillRule>` struct
#[repr(C)] pub struct AzSvgFillRule { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgStrokeStyle>` struct
#[repr(C)] pub struct AzSvgStrokeStyle { pub ptr: *mut c_void }
/// Creates a new `SvgStrokeStyle` instance whose memory is owned by the rust allocator
/// Equivalent to the Rust `SvgStrokeStyle::default()` constructor.
#[no_mangle] pub extern "C" fn AzSvgStrokeStyle_default () -> AzSvgStrokeStyle { let object: SvgStrokeStyle = azul_core::svg::SvgStrokeStyle::default(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzSvgStrokeStyle { ptr } }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgLineJoin>` struct
#[repr(C)] pub struct AzSvgLineJoin { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgLineCap>` struct
#[repr(C)] pub struct AzSvgLineCap { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssPathPseudoSelector>` struct
#[repr(C)] pub struct AzCssPathPseudoSelector { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<LogicalRect>` struct
#[repr(C)] pub struct AzLogicalRect { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssPathSelector>` struct
#[repr(C)] pub struct AzCssPathSelector { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssPath>` struct
#[repr(C)] pub struct AzCssPath { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TessellatedGPUSvgNode>` struct
#[repr(C)] pub struct AzTessellatedGPUSvgNode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TessellatedColoredGPUSvgNode>` struct
#[repr(C)] pub struct AzTessellatedColoredGPUSvgNode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ShapeCircle>` struct
#[repr(C)] pub struct AzShapeCircle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ShapePolygon>` struct
#[repr(C)] pub struct AzShapePolygon { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Xml>` struct
#[repr(C)] pub struct AzXml { pub ptr: *mut c_void }
/// Parses an XML document with one or more root nodes
#[no_mangle] pub extern "C" fn AzXml_fromStr (xml_string: AzRefstr) -> AzResultXmlXmlError { let object: Xml = azul_layout::xml::parse_xml(xml_string.as_str()).into(); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzXml { ptr } }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Instant>` struct
#[repr(C)] pub struct AzInstant { pub ptr: *mut c_void }
/// Returns the duration since and earlier instant or None if the earlier instant is later than self
#[no_mangle] pub extern "C" fn AzInstant_durationSince (instant: &AzInstant, earlier: AzInstant) -> AzOptionDuration{ if &earlier < instant { Some(instant.duration_since(&earlier)).into() } else { None.into() } }
/// Adds a duration to the current time instant, returning the new `Instant`
#[no_mangle] pub extern "C" fn AzInstant_addDuration (instant: &mut AzInstant, duration: AzDuration) -> AzInstant{ instant.add_optional_duration(Some(&duration)) }
/// Linearly interpolates between [start, end] if the `self` Instant lies between start and end. Returns values between 0.0 and 1.0
#[no_mangle] pub extern "C" fn AzInstant_linearInterpolate (instant: &AzInstant, start: AzInstant, end: AzInstant) -> f32{ instant.linear_interpolate(start, end) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SystemTickDiff>` struct
#[repr(C)] pub struct AzSystemTickDiff { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SystemTick>` struct
#[repr(C)] pub struct AzSystemTick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Duration>` struct
#[repr(C)] pub struct AzDuration { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SystemTimeDiff>` struct
#[repr(C)] pub struct AzSystemTimeDiff { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TimerId>` struct
#[repr(C)] pub struct AzTimerId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InstantPtr>` struct
#[repr(C)] pub struct AzInstantPtr { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssDuration>` struct
#[repr(C)] pub struct AzCssDuration { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<String>` struct
#[repr(C)] pub struct AzString { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Refstr>` struct
#[repr(C)] pub struct AzRefstr { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StringPair>` struct
#[repr(C)] pub struct AzStringPair { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for CssPropertyValue < StringSet >
pub type AzStringSetValue = AzCssPropertyValue<AzStringSet>;

/// Pointer to rust-allocated `Box<StringSet>` struct
#[repr(C)] pub struct AzStringSet { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<ListViewRow>
#[repr(C)] pub struct AzListViewRowVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<StyleFilter>
#[repr(C)] pub struct AzStyleFilterVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<AccessibilityState>
#[repr(C)] pub struct AzAccessibilityStateVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<MenuItem>
#[repr(C)] pub struct AzMenuItemVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<StyleFontFamily>
#[repr(C)] pub struct AzStyleFontFamilyVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<Dom>
#[repr(C)] pub struct AzDomVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<IdOrClass>
#[repr(C)] pub struct AzIdOrClassVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<NodeDataInlineCssProperty>
#[repr(C)] pub struct AzNodeDataInlineCssPropertyVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundContent>
#[repr(C)] pub struct AzStyleBackgroundContentVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundPosition>
#[repr(C)] pub struct AzStyleBackgroundPositionVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundRepeat>
#[repr(C)] pub struct AzStyleBackgroundRepeatVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundSize>
#[repr(C)] pub struct AzStyleBackgroundSizeVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<StyleTransform>
#[repr(C)] pub struct AzStyleTransformVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<SvgMultiPolygon>
#[repr(C)] pub struct AzSvgMultiPolygonVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<SvgSimpleNode>
#[repr(C)] pub struct AzSvgSimpleNodeVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<SvgPath>
#[repr(C)] pub struct AzSvgPathVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<SvgPathElement>
#[repr(C)] pub struct AzSvgPathElementVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<SvgVertex>
#[repr(C)] pub struct AzSvgVertexVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<u32>
#[repr(C)] pub struct AzU32Vec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<VirtualKeyCode>
#[repr(C)] pub struct AzVirtualKeyCodeVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<CascadeInfo>
#[repr(C)] pub struct AzCascadeInfoVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<CssDeclaration>
#[repr(C)] pub struct AzCssDeclarationVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<CssPathSelector>
#[repr(C)] pub struct AzCssPathSelectorVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<Stylesheet>
#[repr(C)] pub struct AzStylesheetVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<CssRuleBlock>
#[repr(C)] pub struct AzCssRuleBlockVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<u16>
#[repr(C)] pub struct AzU16Vec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<f32>
#[repr(C)] pub struct AzF32Vec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<u8>
#[repr(C)] pub struct AzU8Vec { pub ptr: *mut c_void }
/// Creates a new, heap-allocated U8Vec by copying the memory into Rust (heap allocation)
#[no_mangle] pub extern "C" fn AzU8Vec_copyFromBytes (ptr: *const u8, start: usize, len: usize) -> AzU8Vec { let object: U8Vec =  unsafe { let start_ptr = ptr.offset(start.max(core::isize::MAX as usize) as isize); let s = core::slice::from_raw_parts(start_ptr, len); s.to_vec().into() }; let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzU8Vec { ptr } }
/// Returns the `U8Vec` as a non-owning slice, NOTE: The `U8Vec` that this slice was borrowed from MUST NOT be deleted before the `U8VecRef`
#[no_mangle] pub extern "C" fn AzU8Vec_asRefVec (u8vec: &AzU8Vec) -> AzU8VecRef{ u8vec.as_ref().into() }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<GLuint>
#[repr(C)] pub struct AzGLuintVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<GLint>
#[repr(C)] pub struct AzGLintVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<String>
#[repr(C)] pub struct AzStringVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<StringPair>
#[repr(C)] pub struct AzStringPairVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<NormalizedLinearColorStop>
#[repr(C)] pub struct AzNormalizedLinearColorStopVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<NormalizedRadialColorStop>
#[repr(C)] pub struct AzNormalizedRadialColorStopVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<NodeId>
#[repr(C)] pub struct AzNodeIdVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<NodeHierarchyItem>
#[repr(C)] pub struct AzNodeHierarchyItemVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<StyledNode>
#[repr(C)] pub struct AzStyledNodeVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<TagIdToNodeIdMapping>
#[repr(C)] pub struct AzTagIdToNodeIdMappingVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<ParentWithNodeDepth>
#[repr(C)] pub struct AzParentWithNodeDepthVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<NodeData>
#[repr(C)] pub struct AzNodeDataVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<Attribute>
#[repr(C)] pub struct AzAttributeVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<CoreCallbackData>
#[repr(C)] pub struct AzCoreCallbackDataVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<AccessibilityAction>
#[repr(C)] pub struct AzAccessibilityActionVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<XmlNodeChild>
#[repr(C)] pub struct AzXmlNodeChildVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Wrapper over a Rust-allocated `Vec<GridTrackSizing>
#[repr(C)] pub struct AzGridTrackSizingVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GLbooleanVecRefMut>` struct
#[repr(C)] pub struct AzGLbooleanVecRefMut { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RefstrVecRef>` struct
#[repr(C)] pub struct AzRefstrVecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GLfloatVecRefMut>` struct
#[repr(C)] pub struct AzGLfloatVecRefMut { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<U8VecRefMut>` struct
#[repr(C)] pub struct AzU8VecRefMut { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TessellatedSvgNodeVecRef>` struct
#[repr(C)] pub struct AzTessellatedSvgNodeVecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<F32VecRef>` struct
#[repr(C)] pub struct AzF32VecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GLuintVecRef>` struct
#[repr(C)] pub struct AzGLuintVecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<I32VecRef>` struct
#[repr(C)] pub struct AzI32VecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<U8VecRef>` struct
#[repr(C)] pub struct AzU8VecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GLintVecRefMut>` struct
#[repr(C)] pub struct AzGLintVecRefMut { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GLenumVecRef>` struct
#[repr(C)] pub struct AzGLenumVecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GLint64VecRefMut>` struct
#[repr(C)] pub struct AzGLint64VecRefMut { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionU8VecRef>` struct
#[repr(C)] pub struct AzOptionU8VecRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBackgroundContentVecDestructorType>` struct
pub type AzStyleBackgroundContentVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgPathVecDestructor>` struct
#[repr(C)] pub struct AzSvgPathVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBackgroundRepeatVecDestructorType>` struct
pub type AzStyleBackgroundRepeatVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleFilterVecDestructor>` struct
#[repr(C)] pub struct AzStyleFilterVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformVecDestructor>` struct
#[repr(C)] pub struct AzStyleTransformVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<MenuItemVecDestructorType>` struct
pub type AzMenuItemVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AccessibilityStateVecDestructorType>` struct
pub type AzAccessibilityStateVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeDataInlineCssPropertyVecDestructorType>` struct
pub type AzNodeDataInlineCssPropertyVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NormalizedLinearColorStopVecDestructorType>` struct
pub type AzNormalizedLinearColorStopVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<F32VecDestructorType>` struct
pub type AzF32VecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GLuintVecDestructor>` struct
#[repr(C)] pub struct AzGLuintVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<XmlNodeChildVecDestructor>` struct
#[repr(C)] pub struct AzXmlNodeChildVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBackgroundSizeVecDestructorType>` struct
pub type AzStyleBackgroundSizeVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBackgroundContentVecDestructor>` struct
#[repr(C)] pub struct AzStyleBackgroundContentVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StringVecDestructorType>` struct
pub type AzStringVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CascadeInfoVecDestructor>` struct
#[repr(C)] pub struct AzCascadeInfoVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DomVecDestructorType>` struct
pub type AzDomVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AccessibilityStateVecDestructor>` struct
#[repr(C)] pub struct AzAccessibilityStateVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StringPairVecDestructorType>` struct
pub type AzStringPairVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DomVecDestructor>` struct
#[repr(C)] pub struct AzDomVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StringVecDestructor>` struct
#[repr(C)] pub struct AzStringVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssRuleBlockVecDestructorType>` struct
pub type AzCssRuleBlockVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeDataVecDestructor>` struct
#[repr(C)] pub struct AzNodeDataVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<MenuItemVecDestructor>` struct
#[repr(C)] pub struct AzMenuItemVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AttributeVecDestructorType>` struct
pub type AzAttributeVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgMultiPolygonVecDestructor>` struct
#[repr(C)] pub struct AzSvgMultiPolygonVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewRowVecDestructor>` struct
#[repr(C)] pub struct AzListViewRowVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeIdVecDestructorType>` struct
pub type AzNodeIdVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleFilterVecDestructorType>` struct
pub type AzStyleFilterVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<U32VecDestructorType>` struct
pub type AzU32VecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgVertexVecDestructor>` struct
#[repr(C)] pub struct AzSvgVertexVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StylesheetVecDestructor>` struct
#[repr(C)] pub struct AzStylesheetVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<U32VecDestructor>` struct
#[repr(C)] pub struct AzU32VecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssRuleBlockVecDestructor>` struct
#[repr(C)] pub struct AzCssRuleBlockVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ParentWithNodeDepthVecDestructorType>` struct
pub type AzParentWithNodeDepthVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NormalizedLinearColorStopVecDestructor>` struct
#[repr(C)] pub struct AzNormalizedLinearColorStopVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CoreCallbackDataVecDestructorType>` struct
pub type AzCoreCallbackDataVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleFontFamilyVecDestructor>` struct
#[repr(C)] pub struct AzStyleFontFamilyVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CascadeInfoVecDestructorType>` struct
pub type AzCascadeInfoVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<U8VecDestructorType>` struct
pub type AzU8VecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeHierarchyItemVecDestructorType>` struct
pub type AzNodeHierarchyItemVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssPathSelectorVecDestructor>` struct
#[repr(C)] pub struct AzCssPathSelectorVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBackgroundPositionVecDestructorType>` struct
pub type AzStyleBackgroundPositionVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VirtualKeyCodeVecDestructorType>` struct
pub type AzVirtualKeyCodeVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeHierarchyItemVecDestructor>` struct
#[repr(C)] pub struct AzNodeHierarchyItemVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VirtualKeyCodeVecDestructor>` struct
#[repr(C)] pub struct AzVirtualKeyCodeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgVertexVecDestructorType>` struct
pub type AzSvgVertexVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<F32VecDestructor>` struct
#[repr(C)] pub struct AzF32VecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgPathElementVecDestructorType>` struct
pub type AzSvgPathElementVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBackgroundRepeatVecDestructor>` struct
#[repr(C)] pub struct AzStyleBackgroundRepeatVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AccessibilityActionVecDestructor>` struct
#[repr(C)] pub struct AzAccessibilityActionVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ListViewRowVecDestructorType>` struct
pub type AzListViewRowVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GLuintVecDestructorType>` struct
pub type AzGLuintVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleTransformVecDestructorType>` struct
pub type AzStyleTransformVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TagIdToNodeIdMappingVecDestructorType>` struct
pub type AzTagIdToNodeIdMappingVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<U16VecDestructor>` struct
#[repr(C)] pub struct AzU16VecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<TagIdToNodeIdMappingVecDestructor>` struct
#[repr(C)] pub struct AzTagIdToNodeIdMappingVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeIdVecDestructor>` struct
#[repr(C)] pub struct AzNodeIdVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<U16VecDestructorType>` struct
pub type AzU16VecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgSimpleNodeVecDestructorType>` struct
pub type AzSvgSimpleNodeVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GridTrackSizingVecDestructorType>` struct
pub type AzGridTrackSizingVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssDeclarationVecDestructorType>` struct
pub type AzCssDeclarationVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ParentWithNodeDepthVecDestructor>` struct
#[repr(C)] pub struct AzParentWithNodeDepthVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GLintVecDestructor>` struct
#[repr(C)] pub struct AzGLintVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeDataInlineCssPropertyVecDestructor>` struct
#[repr(C)] pub struct AzNodeDataInlineCssPropertyVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NormalizedRadialColorStopVecDestructorType>` struct
pub type AzNormalizedRadialColorStopVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NormalizedRadialColorStopVecDestructor>` struct
#[repr(C)] pub struct AzNormalizedRadialColorStopVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyledNodeVecDestructor>` struct
#[repr(C)] pub struct AzStyledNodeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBackgroundPositionVecDestructor>` struct
#[repr(C)] pub struct AzStyleBackgroundPositionVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgMultiPolygonVecDestructorType>` struct
pub type AzSvgMultiPolygonVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgSimpleNodeVecDestructor>` struct
#[repr(C)] pub struct AzSvgSimpleNodeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AccessibilityActionVecDestructorType>` struct
pub type AzAccessibilityActionVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GLintVecDestructorType>` struct
pub type AzGLintVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AttributeVecDestructor>` struct
#[repr(C)] pub struct AzAttributeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NodeDataVecDestructorType>` struct
pub type AzNodeDataVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssDeclarationVecDestructor>` struct
#[repr(C)] pub struct AzCssDeclarationVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyledNodeVecDestructorType>` struct
pub type AzStyledNodeVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<IdOrClassVecDestructor>` struct
#[repr(C)] pub struct AzIdOrClassVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleBackgroundSizeVecDestructor>` struct
#[repr(C)] pub struct AzStyleBackgroundSizeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgPathVecDestructorType>` struct
pub type AzSvgPathVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StyleFontFamilyVecDestructorType>` struct
pub type AzStyleFontFamilyVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StringPairVecDestructor>` struct
#[repr(C)] pub struct AzStringPairVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CoreCallbackDataVecDestructor>` struct
#[repr(C)] pub struct AzCoreCallbackDataVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgPathElementVecDestructor>` struct
#[repr(C)] pub struct AzSvgPathElementVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<U8VecDestructor>` struct
#[repr(C)] pub struct AzU8VecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<GridTrackSizingVecDestructor>` struct
#[repr(C)] pub struct AzGridTrackSizingVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<IdOrClassVecDestructorType>` struct
pub type AzIdOrClassVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<XmlNodeChildVecDestructorType>` struct
pub type AzXmlNodeChildVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<StylesheetVecDestructorType>` struct
pub type AzStylesheetVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<CssPathSelectorVecDestructorType>` struct
pub type AzCssPathSelectorVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VertexAttributeVecDestructorType>` struct
pub type AzVertexAttributeVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VertexAttributeVecDestructor>` struct
#[repr(C)] pub struct AzVertexAttributeVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VertexAttributeVec>` struct
#[repr(C)] pub struct AzVertexAttributeVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DebugMessageVecDestructor>` struct
#[repr(C)] pub struct AzDebugMessageVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DebugMessageVecDestructorType>` struct
pub type AzDebugMessageVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DebugMessageVec>` struct
#[repr(C)] pub struct AzDebugMessageVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ShapePointVecDestructor>` struct
#[repr(C)] pub struct AzShapePointVecDestructor { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ShapePointVecDestructorType>` struct
pub type AzShapePointVecDestructorType = /* callback signature would go here */;
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ShapePointVec>` struct
#[repr(C)] pub struct AzShapePointVec { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `XWindowTypeVec` struct
pub use azul_core::window::XWindowTypeVec as AzXWindowTypeVecTT;
pub use AzXWindowTypeVecTT as AzXWindowTypeVec;
/// Clones the object
#[no_mangle] pub extern "C" fn AzXWindowTypeVec_deepCopy(object: &AzXWindowTypeVec) -> AzXWindowTypeVec { object.clone() }

/// Re-export of rust-allocated (stack based) `ScanCodeVec` struct
pub use azul_core::window::ScanCodeVec as AzScanCodeVecTT;
pub use AzScanCodeVecTT as AzScanCodeVec;
/// Clones the object
#[no_mangle] pub extern "C" fn AzScanCodeVec_deepCopy(object: &AzScanCodeVec) -> AzScanCodeVec { object.clone() }

/// Pointer to rust-allocated `Box<OptionSvgPoint>` struct
#[repr(C)] pub struct AzOptionSvgPoint { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionListViewOnRowClick>` struct
#[repr(C)] pub struct AzOptionListViewOnRowClick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionListViewOnColumnClick>` struct
#[repr(C)] pub struct AzOptionListViewOnColumnClick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionListViewOnLazyLoadScroll>` struct
#[repr(C)] pub struct AzOptionListViewOnLazyLoadScroll { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionMenu>` struct
#[repr(C)] pub struct AzOptionMenu { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionPixelValueNoPercent>` struct
#[repr(C)] pub struct AzOptionPixelValueNoPercent { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionColorInputOnValueChange>` struct
#[repr(C)] pub struct AzOptionColorInputOnValueChange { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionButtonOnClick>` struct
#[repr(C)] pub struct AzOptionButtonOnClick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTabOnClick>` struct
#[repr(C)] pub struct AzOptionTabOnClick { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionFileInputOnPathChange>` struct
#[repr(C)] pub struct AzOptionFileInputOnPathChange { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionCheckBoxOnToggle>` struct
#[repr(C)] pub struct AzOptionCheckBoxOnToggle { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTextInputOnTextInput>` struct
#[repr(C)] pub struct AzOptionTextInputOnTextInput { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTextInputOnVirtualKeyDown>` struct
#[repr(C)] pub struct AzOptionTextInputOnVirtualKeyDown { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTextInputOnFocusLost>` struct
#[repr(C)] pub struct AzOptionTextInputOnFocusLost { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTextInputSelection>` struct
#[repr(C)] pub struct AzOptionTextInputSelection { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionNumberInputOnFocusLost>` struct
#[repr(C)] pub struct AzOptionNumberInputOnFocusLost { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionNumberInputOnValueChange>` struct
#[repr(C)] pub struct AzOptionNumberInputOnValueChange { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionMenuItemIcon>` struct
#[repr(C)] pub struct AzOptionMenuItemIcon { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionVirtualKeyCodeCombo>` struct
#[repr(C)] pub struct AzOptionVirtualKeyCodeCombo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTimerId>` struct
#[repr(C)] pub struct AzOptionTimerId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionI16>` struct
#[repr(C)] pub struct AzOptionI16 { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionU16>` struct
#[repr(C)] pub struct AzOptionU16 { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionU32>` struct
#[repr(C)] pub struct AzOptionU32 { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionImageRef>` struct
#[repr(C)] pub struct AzOptionImageRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionFontRef>` struct
#[repr(C)] pub struct AzOptionFontRef { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionRefAny>` struct
#[repr(C)] pub struct AzOptionRefAny { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionLayoutSize>` struct
#[repr(C)] pub struct AzOptionLayoutSize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionDomNodeId>` struct
#[repr(C)] pub struct AzOptionDomNodeId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionColorU>` struct
#[repr(C)] pub struct AzOptionColorU { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionRawImage>` struct
#[repr(C)] pub struct AzOptionRawImage { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionSvgDashPattern>` struct
#[repr(C)] pub struct AzOptionSvgDashPattern { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTabIndex>` struct
#[repr(C)] pub struct AzOptionTabIndex { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionTagId>` struct
#[repr(C)] pub struct AzOptionTagId { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionDuration>` struct
#[repr(C)] pub struct AzOptionDuration { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionUsize>` struct
#[repr(C)] pub struct AzOptionUsize { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionCoreMenuCallback>` struct
#[repr(C)] pub struct AzOptionCoreMenuCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionStyledDom>` struct
#[repr(C)] pub struct AzOptionStyledDom { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgParseOptions>` struct
#[repr(C)] pub struct AzSvgParseOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgXmlOptions>` struct
#[repr(C)] pub struct AzSvgXmlOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgRenderOptions>` struct
#[repr(C)] pub struct AzSvgRenderOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionLogicalPosition>` struct
#[repr(C)] pub struct AzOptionLogicalPosition { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionString>` struct
#[repr(C)] pub struct AzOptionString { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<OptionF32>` struct
#[repr(C)] pub struct AzOptionF32 { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `OptionWindowIcon` struct
pub use azul_core::window::OptionWindowIcon as AzOptionWindowIconTT;
pub use AzOptionWindowIconTT as AzOptionWindowIcon;
/// Clones the object
#[no_mangle] pub extern "C" fn AzOptionWindowIcon_deepCopy(object: &AzOptionWindowIcon) -> AzOptionWindowIcon { object.clone() }

/// Re-export of rust-allocated (stack based) `OptionI32` struct
pub use azul_css::corety::OptionI32 as AzOptionI32TT;
pub use AzOptionI32TT as AzOptionI32;
/// Clones the object
#[no_mangle] pub extern "C" fn AzOptionI32_deepCopy(object: &AzOptionI32) -> AzOptionI32 { object.clone() }

/// Re-export of rust-allocated (stack based) `OptionMouseCursorType` struct
pub use azul_core::window::OptionMouseCursorType as AzOptionMouseCursorTypeTT;
pub use AzOptionMouseCursorTypeTT as AzOptionMouseCursorType;
/// Clones the object
#[no_mangle] pub extern "C" fn AzOptionMouseCursorType_deepCopy(object: &AzOptionMouseCursorType) -> AzOptionMouseCursorType { object.clone() }

/// Re-export of rust-allocated (stack based) `OptionWindowTheme` struct
pub use azul_core::window::OptionWindowTheme as AzOptionWindowThemeTT;
pub use AzOptionWindowThemeTT as AzOptionWindowTheme;
/// Clones the object
#[no_mangle] pub extern "C" fn AzOptionWindowTheme_deepCopy(object: &AzOptionWindowTheme) -> AzOptionWindowTheme { object.clone() }

/// Re-export of rust-allocated (stack based) `OptionTaskBarIcon` struct
pub use azul_core::window::OptionTaskBarIcon as AzOptionTaskBarIconTT;
pub use AzOptionTaskBarIconTT as AzOptionTaskBarIcon;
/// Clones the object
#[no_mangle] pub extern "C" fn AzOptionTaskBarIcon_deepCopy(object: &AzOptionTaskBarIcon) -> AzOptionTaskBarIcon { object.clone() }

/// Re-export of rust-allocated (stack based) `OptionLogicalSize` struct
pub use azul_core::geom::OptionLogicalSize as AzOptionLogicalSizeTT;
pub use AzOptionLogicalSizeTT as AzOptionLogicalSize;
/// Clones the object
#[no_mangle] pub extern "C" fn AzOptionLogicalSize_deepCopy(object: &AzOptionLogicalSize) -> AzOptionLogicalSize { object.clone() }

/// Re-export of rust-allocated (stack based) `OptionVirtualKeyCode` struct
pub use azul_core::window::OptionVirtualKeyCode as AzOptionVirtualKeyCodeTT;
pub use AzOptionVirtualKeyCodeTT as AzOptionVirtualKeyCode;
/// Clones the object
#[no_mangle] pub extern "C" fn AzOptionVirtualKeyCode_deepCopy(object: &AzOptionVirtualKeyCode) -> AzOptionVirtualKeyCode { object.clone() }

/// Re-export of rust-allocated (stack based) `OptionX11Visual` struct
pub use azul_core::window::OptionX11Visual as AzOptionX11VisualTT;
pub use AzOptionX11VisualTT as AzOptionX11Visual;
/// Clones the object
#[no_mangle] pub extern "C" fn AzOptionX11Visual_deepCopy(object: &AzOptionX11Visual) -> AzOptionX11Visual { object.clone() }

/// Re-export of rust-allocated (stack based) `OptionRendererOptions` struct
pub use azul_core::window::OptionRendererOptions as AzOptionRendererOptionsTT;
pub use AzOptionRendererOptionsTT as AzOptionRendererOptions;
/// Clones the object
#[no_mangle] pub extern "C" fn AzOptionRendererOptions_deepCopy(object: &AzOptionRendererOptions) -> AzOptionRendererOptions { object.clone() }

/// Pointer to rust-allocated `Box<RendererOptions>` struct
#[repr(C)] pub struct AzRendererOptions { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `OptionWaylandTheme` struct
pub use azul_core::window::OptionWaylandTheme as AzOptionWaylandThemeTT;
pub use AzOptionWaylandThemeTT as AzOptionWaylandTheme;
/// Clones the object
#[no_mangle] pub extern "C" fn AzOptionWaylandTheme_deepCopy(object: &AzOptionWaylandTheme) -> AzOptionWaylandTheme { object.clone() }

/// Pointer to rust-allocated `Box<OptionCallback>` struct
#[repr(C)] pub struct AzOptionCallback { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Re-export of rust-allocated (stack based) `OptionHwndHandle` struct
pub use azul_core::window::OptionHwndHandle as AzOptionHwndHandleTT;
pub use AzOptionHwndHandleTT as AzOptionHwndHandle;
/// Clones the object
#[no_mangle] pub extern "C" fn AzOptionHwndHandle_deepCopy(object: &AzOptionHwndHandle) -> AzOptionHwndHandle { object.clone() }

/// Re-export of rust-allocated (stack based) `OptionLinuxDecorationsState` struct
pub use azul_core::window::OptionLinuxDecorationsState as AzOptionLinuxDecorationsStateTT;
pub use AzOptionLinuxDecorationsStateTT as AzOptionLinuxDecorationsState;
/// Clones the object
#[no_mangle] pub extern "C" fn AzOptionLinuxDecorationsState_deepCopy(object: &AzOptionLinuxDecorationsState) -> AzOptionLinuxDecorationsState { object.clone() }

/// Pointer to rust-allocated `Box<ResultXmlXmlError>` struct
#[repr(C)] pub struct AzResultXmlXmlError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ResultSvgSvgParseError>` struct
#[repr(C)] pub struct AzResultSvgSvgParseError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<SvgParseError>` struct
#[repr(C)] pub struct AzSvgParseError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<XmlError>` struct
#[repr(C)] pub struct AzXmlError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DuplicatedNamespaceError>` struct
#[repr(C)] pub struct AzDuplicatedNamespaceError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<UnknownNamespaceError>` struct
#[repr(C)] pub struct AzUnknownNamespaceError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<UnexpectedCloseTagError>` struct
#[repr(C)] pub struct AzUnexpectedCloseTagError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<UnknownEntityReferenceError>` struct
#[repr(C)] pub struct AzUnknownEntityReferenceError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DuplicatedAttributeError>` struct
#[repr(C)] pub struct AzDuplicatedAttributeError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<XmlParseError>` struct
#[repr(C)] pub struct AzXmlParseError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<XmlTextError>` struct
#[repr(C)] pub struct AzXmlTextError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<XmlStreamError>` struct
#[repr(C)] pub struct AzXmlStreamError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<NonXmlCharError>` struct
#[repr(C)] pub struct AzNonXmlCharError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InvalidCharError>` struct
#[repr(C)] pub struct AzInvalidCharError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InvalidCharMultipleError>` struct
#[repr(C)] pub struct AzInvalidCharMultipleError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InvalidQuoteError>` struct
#[repr(C)] pub struct AzInvalidQuoteError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InvalidSpaceError>` struct
#[repr(C)] pub struct AzInvalidSpaceError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InvalidStringError>` struct
#[repr(C)] pub struct AzInvalidStringError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<MalformedHierarchyError>` struct
#[repr(C)] pub struct AzMalformedHierarchyError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<EncodeImageError>` struct
#[repr(C)] pub struct AzEncodeImageError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ResultRawImageDecodeImageError>` struct
#[repr(C)] pub struct AzResultRawImageDecodeImageError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DecodeImageError>` struct
#[repr(C)] pub struct AzDecodeImageError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ResultU8VecEncodeImageError>` struct
#[repr(C)] pub struct AzResultU8VecEncodeImageError { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Has all the necessary information about the style CSS path
#[repr(C)] pub struct AzCascadeInfo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RendererType>` struct
#[repr(C)] pub struct AzRendererType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<ExtendMode>` struct
#[repr(C)] pub struct AzExtendMode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FlowInto>` struct
#[repr(C)] pub struct AzFlowInto { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VirtualKeyCode>` struct
#[repr(C)] pub struct AzVirtualKeyCode { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<VirtualKeyCodeCombo>` struct
#[repr(C)] pub struct AzVirtualKeyCodeCombo { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Type alias for CssPropertyValue < FlowFrom >
pub type AzFlowFromValue = AzCssPropertyValue<AzFlowFrom>;

/// Pointer to rust-allocated `Box<IdOrClass>` struct
#[repr(C)] pub struct AzIdOrClass { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<InterpolateResolver>` struct
#[repr(C)] pub struct AzInterpolateResolver { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<FlowFrom>` struct
#[repr(C)] pub struct AzFlowFrom { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RefCount>` struct
#[repr(C)] pub struct AzRefCount { pub ptr: *mut c_void }
/// Returns true if this RefCount can be shared (no mutable borrows active)
#[no_mangle] pub extern "C" fn AzRefCount_canBeShared (refcount: &AzRefCount) -> bool{ self.can_be_shared() }
/// Returns true if this RefCount can be mutably shared (no borrows active)
#[no_mangle] pub extern "C" fn AzRefCount_canBeSharedMut (refcount: &AzRefCount) -> bool{ self.can_be_shared_mut() }
/// Increases the shared reference count
#[no_mangle] pub extern "C" fn AzRefCount_increaseRef (refcount: &AzRefCount){ self.increase_ref() }
/// Decreases the shared reference count
#[no_mangle] pub extern "C" fn AzRefCount_decreaseRef (refcount: &AzRefCount){ self.decrease_ref() }
/// Increases the mutable reference count
#[no_mangle] pub extern "C" fn AzRefCount_increaseRefmut (refcount: &AzRefCount){ self.increase_refmut() }
/// Decreases the mutable reference count
#[no_mangle] pub extern "C" fn AzRefCount_decreaseRefmut (refcount: &AzRefCount){ self.decrease_refmut() }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<Update>` struct
#[repr(C)] pub struct AzUpdate { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<RefAny>` struct
#[repr(C)] pub struct AzRefAny { pub ptr: *mut c_void }
/// Creates a new RefAny from a raw pointer wrapper, size, alignment, type_id, type_name and destructor
#[no_mangle] pub extern "C" fn AzRefAny_newC (ptr: AzGlVoidPtrConst, len: usize, align: usize, type_id: u64, type_name: AzString, destructor: AzRefAnyDestructorType) -> AzRefAny { let object: RefAny = RefAny::new_c(ptr.ptr, len, align, type_id, type_name, destructor); let ptr = Box::into_raw(Box::new(object)) as *mut c_void; AzRefAny { ptr } }
/// Returns the type ID of this RefAny
#[no_mangle] pub extern "C" fn AzRefAny_getTypeId (refany: &AzRefAny) -> u64{ self.get_type_id() }
/// Returns true if this RefAny is of the given type ID
#[no_mangle] pub extern "C" fn AzRefAny_isType (refany: &AzRefAny, type_id: u64) -> bool{ self.get_type_id() == type_id }
/* Error: Type is not stack allocated! */

/// Type alias for CssPropertyValue < FlowInto >
pub type AzFlowIntoValue = AzCssPropertyValue<AzFlowInto>;

/// Pointer to rust-allocated `Box<EdgeType>` struct
#[repr(C)] pub struct AzEdgeType { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<DebugMessage>` struct
#[repr(C)] pub struct AzDebugMessage { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AppLogLevel>` struct
#[repr(C)] pub struct AzAppLogLevel { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<App>` struct
#[repr(C)] pub struct AzApp { pub ptr: *mut c_void }
/// Start the rendering loop for the currently added windows. The run() function
/// takes one `WindowCreateOptions` as an argument, which is the "root" window, i.e.
/// the main application window.
#[no_mangle] pub extern "C" fn AzApp_run (root_window: AzWindowCreateOptions){ object.run(root_window) }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AppConfig>` struct
#[repr(C)] pub struct AzAppConfig { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */

/// Pointer to rust-allocated `Box<AppTerminationBehavior>` struct
#[repr(C)] pub struct AzAppTerminationBehavior { pub ptr: *mut c_void }
/* Error: Type is not stack allocated! */


#[cfg(all(test, not(feature = "rlib")))]
#[allow(dead_code)]
mod test_sizes {

    #[cfg(not(feature = "link-static"))]
    impl AzString {
        #[inline]
        pub fn as_str(&self) -> &str {
            unsafe { core::str::from_utf8_unchecked(self.as_bytes()) }
        }
        #[inline]
        pub fn as_bytes(&self) -> &[u8] {
            unsafe { core::slice::from_raw_parts(self.vec.ptr, self.vec.len) }
        }
    }

    #[cfg(not(feature = "link-static"))]
    pub use self::dummy::*;

    #[cfg(not(feature = "link-static"))]
    pub mod dummy {
        use super::*;
        impl ::core::fmt::Debug for AzCallback                          { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzLayoutCallbackInner               { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzMarshaledLayoutCallbackInner      { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzRenderImageCallback               { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzIFrameCallback                    { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzTimerCallback                     { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzWriteBackCallback                 { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzThreadDestructorFn                { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzLibraryReceiveThreadMsgFn         { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzLibrarySendThreadMsgFn            { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzCheckThreadFinishedFn             { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzGetSystemTimeFn                   { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzCreateThreadFn                    { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzThreadRecvFn                      { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzThreadReceiverDestructorFn        { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzThreadSenderDestructorFn          { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzInstantPtrDestructorFn            { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzInstantPtrCloneFn                 { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzThreadSendFn                      { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzCheckBoxOnToggleCallback          { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzColorInputOnValueChangeCallback   { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzTextInputOnTextInputCallback      { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzTextInputOnVirtualKeyDownCallback { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzTextInputOnFocusLostCallback      { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzNumberInputOnValueChangeCallback  { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
        impl ::core::fmt::Debug for AzTabOnClickCallback                { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}

        impl ::core::fmt::Debug for AzDomVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzDomVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzIdOrClassVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzIdOrClassVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzNodeDataInlineCssPropertyVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzNodeDataInlineCssPropertyVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStyleBackgroundContentVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStyleBackgroundContentVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStyleBackgroundPositionVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStyleBackgroundPositionVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStyleBackgroundRepeatVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStyleBackgroundRepeatVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStyleBackgroundSizeVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStyleBackgroundSizeVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStyleTransformVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStyleTransformVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzCssPropertyVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzCssPropertyVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzSvgMultiPolygonVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzSvgMultiPolygonVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzSvgPathVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzSvgPathVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzVertexAttributeVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzVertexAttributeVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzSvgPathElementVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzSvgPathElementVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzSvgVertexVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzSvgVertexVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzSvgColoredVertexVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzSvgColoredVertexVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzU32VecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzU32VecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzXWindowTypeVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzXWindowTypeVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzVirtualKeyCodeVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzVirtualKeyCodeVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzCascadeInfoVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzCascadeInfoVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzScanCodeVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzScanCodeVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzCssDeclarationVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzCssDeclarationVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzCssPathSelectorVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzCssPathSelectorVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStylesheetVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStylesheetVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzCssRuleBlockVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzCssRuleBlockVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzU8VecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzU8VecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzCallbackDataVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzCallbackDataVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzDebugMessageVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzDebugMessageVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzGLuintVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzGLuintVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzGLintVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzGLintVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStringVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStringVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStringPairVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStringPairVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzNormalizedLinearColorStopVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzNormalizedLinearColorStopVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzNormalizedRadialColorStopVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzNormalizedRadialColorStopVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzNodeIdVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzNodeIdVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzNodeHierarchyItemVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzNodeHierarchyItemVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzStyledNodeVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzStyledNodeVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzTagIdToNodeIdMappingVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzTagIdToNodeIdMappingVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzParentWithNodeDepthVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzParentWithNodeDepthVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzNodeDataVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzNodeDataVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
        impl ::core::fmt::Debug for AzSvgSimpleNodeVecDestructor { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { use AzSvgSimpleNodeVecDestructor::*; match self { DefaultRust => write!(f, "DefaultRust"), NoDestructor => write!(f, "NoDestructor"), External(_) => write!(f, "External"), }}}
    }


    // Generated structs would go here
    use core::ffi::c_void;
    use azul_impl::css::*;

    #[test]
    fn test_size() {
         use core::alloc::Layout;
        assert_eq!((Layout::new::<azul_css::props::style::effects::StyleCursor>(), "AzStyleCursor"), (Layout::new::<AzStyleCursor>(), "AzStyleCursor"));
        assert_eq!((Layout::new::<azul_core::events::WindowEventFilter>(), "AzWindowEventFilter"), (Layout::new::<AzWindowEventFilter>(), "AzWindowEventFilter"));
        assert_eq!((Layout::new::<azul_core::callbacks::HidpiAdjustedBounds>(), "AzHidpiAdjustedBounds"), (Layout::new::<AzHidpiAdjustedBounds>(), "AzHidpiAdjustedBounds"));
        assert_eq!((Layout::new::<azul_core::window::WindowTheme>(), "AzWindowTheme"), (Layout::new::<AzWindowTheme>(), "AzWindowTheme"));
        assert_eq!((Layout::new::<azul_core::resources::DpiScaleFactor>(), "AzDpiScaleFactor"), (Layout::new::<AzDpiScaleFactor>(), "AzDpiScaleFactor"));
        assert_eq!((Layout::new::<azul_layout::window_state::WindowCreateOptions>(), "AzWindowCreateOptions"), (Layout::new::<AzWindowCreateOptions>(), "AzWindowCreateOptions"));
        assert_eq!((Layout::new::<azul_core::window::WasmWindowOptions>(), "AzWasmWindowOptions"), (Layout::new::<AzWasmWindowOptions>(), "AzWasmWindowOptions"));
        assert_eq!((Layout::new::<azul_core::window::WindowFrame>(), "AzWindowFrame"), (Layout::new::<AzWindowFrame>(), "AzWindowFrame"));
        assert_eq!((Layout::new::<azul_core::window::WindowSize>(), "AzWindowSize"), (Layout::new::<AzWindowSize>(), "AzWindowSize"));
        assert_eq!((Layout::new::<azul_core::window::LinuxWindowOptions>(), "AzLinuxWindowOptions"), (Layout::new::<AzLinuxWindowOptions>(), "AzLinuxWindowOptions"));
        assert_eq!((Layout::new::<azul_core::window::PlatformSpecificOptions>(), "AzPlatformSpecificOptions"), (Layout::new::<AzPlatformSpecificOptions>(), "AzPlatformSpecificOptions"));
        assert_eq!((Layout::new::<azul_core::window::WindowType>(), "AzWindowType"), (Layout::new::<AzWindowType>(), "AzWindowType"));
        assert_eq!((Layout::new::<azul_layout::window_state::FullWindowState>(), "AzFullWindowState"), (Layout::new::<AzFullWindowState>(), "AzFullWindowState"));
        assert_eq!((Layout::new::<azul_core::window::MacWindowOptions>(), "AzMacWindowOptions"), (Layout::new::<AzMacWindowOptions>(), "AzMacWindowOptions"));
        assert_eq!((Layout::new::<azul_core::window::HwAcceleration>(), "AzHwAcceleration"), (Layout::new::<AzHwAcceleration>(), "AzHwAcceleration"));
        assert_eq!((Layout::new::<azul_core::window::UserAttentionType>(), "AzUserAttentionType"), (Layout::new::<AzUserAttentionType>(), "AzUserAttentionType"));
        assert_eq!((Layout::new::<azul_core::window::WindowFlags>(), "AzWindowFlags"), (Layout::new::<AzWindowFlags>(), "AzWindowFlags"));
        assert_eq!((Layout::new::<azul_core::window::WindowsWindowOptions>(), "AzWindowsWindowOptions"), (Layout::new::<AzWindowsWindowOptions>(), "AzWindowsWindowOptions"));
        assert_eq!((Layout::new::<azul_core::window::Vsync>(), "AzVsync"), (Layout::new::<AzVsync>(), "AzVsync"));
        assert_eq!((Layout::new::<azul_core::refany::RefAnyDestructorType>(), "AzRefAnyDestructorType"), (Layout::new::<AzRefAnyDestructorType>(), "AzRefAnyDestructorType"));
        assert_eq!((Layout::new::<azul_layout::callbacks::CallbackType>(), "AzCallbackType"), (Layout::new::<AzCallbackType>(), "AzCallbackType"));
        assert_eq!((Layout::new::<azul_core::callbacks::IFrameCallback>(), "AzIFrameCallback"), (Layout::new::<AzIFrameCallback>(), "AzIFrameCallback"));
        assert_eq!((Layout::new::<azul_core::callbacks::IFrameCallbackType>(), "AzIFrameCallbackType"), (Layout::new::<AzIFrameCallbackType>(), "AzIFrameCallbackType"));
        assert_eq!((Layout::new::<azul_core::callbacks::IFrameCallbackReturn>(), "AzIFrameCallbackReturn"), (Layout::new::<AzIFrameCallbackReturn>(), "AzIFrameCallbackReturn"));
        assert_eq!((Layout::new::<azul_layout::callbacks::RenderImageCallbackType>(), "AzRenderImageCallbackType"), (Layout::new::<AzRenderImageCallbackType>(), "AzRenderImageCallbackType"));
        assert_eq!((Layout::new::<azul_layout::widgets::number_input::NumberInputOnFocusLostCallbackType>(), "AzNumberInputOnFocusLostCallbackType"), (Layout::new::<AzNumberInputOnFocusLostCallbackType>(), "AzNumberInputOnFocusLostCallbackType"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::TextInputOnVirtualKeyDownCallbackType>(), "AzTextInputOnVirtualKeyDownCallbackType"), (Layout::new::<AzTextInputOnVirtualKeyDownCallbackType>(), "AzTextInputOnVirtualKeyDownCallbackType"));
        assert_eq!((Layout::new::<azul_layout::widgets::button::ButtonOnClickCallbackType>(), "AzButtonOnClickCallbackType"), (Layout::new::<AzButtonOnClickCallbackType>(), "AzButtonOnClickCallbackType"));
        assert_eq!((Layout::new::<azul_layout::widgets::check_box::CheckBoxOnToggleCallbackType>(), "AzCheckBoxOnToggleCallbackType"), (Layout::new::<AzCheckBoxOnToggleCallbackType>(), "AzCheckBoxOnToggleCallbackType"));
        assert_eq!((Layout::new::<azul_layout::widgets::number_input::NumberInputOnValueChangeCallbackType>(), "AzNumberInputOnValueChangeCallbackType"), (Layout::new::<AzNumberInputOnValueChangeCallbackType>(), "AzNumberInputOnValueChangeCallbackType"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::ListViewOnColumnClickCallbackType>(), "AzListViewOnColumnClickCallbackType"), (Layout::new::<AzListViewOnColumnClickCallbackType>(), "AzListViewOnColumnClickCallbackType"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::ListViewOnRowClickCallbackType>(), "AzListViewOnRowClickCallbackType"), (Layout::new::<AzListViewOnRowClickCallbackType>(), "AzListViewOnRowClickCallbackType"));
        assert_eq!((Layout::new::<azul_layout::widgets::color_input::ColorInputOnValueChangeCallbackType>(), "AzColorInputOnValueChangeCallbackType"), (Layout::new::<AzColorInputOnValueChangeCallbackType>(), "AzColorInputOnValueChangeCallbackType"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::TextInputOnTextInputCallbackType>(), "AzTextInputOnTextInputCallbackType"), (Layout::new::<AzTextInputOnTextInputCallbackType>(), "AzTextInputOnTextInputCallbackType"));
        assert_eq!((Layout::new::<azul_css::props::basic::font::FontRefDestructorCallbackType>(), "AzFontRefDestructorCallbackType"), (Layout::new::<AzFontRefDestructorCallbackType>(), "AzFontRefDestructorCallbackType"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::TextInputOnFocusLostCallbackType>(), "AzTextInputOnFocusLostCallbackType"), (Layout::new::<AzTextInputOnFocusLostCallbackType>(), "AzTextInputOnFocusLostCallbackType"));
        assert_eq!((Layout::new::<azul_layout::widgets::tabs::TabOnClickCallbackType>(), "AzTabOnClickCallbackType"), (Layout::new::<AzTabOnClickCallbackType>(), "AzTabOnClickCallbackType"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::ListViewOnLazyLoadScrollCallbackType>(), "AzListViewOnLazyLoadScrollCallbackType"), (Layout::new::<AzListViewOnLazyLoadScrollCallbackType>(), "AzListViewOnLazyLoadScrollCallbackType"));
        assert_eq!((Layout::new::<azul_layout::widgets::file_input::FileInputOnPathChangeCallbackType>(), "AzFileInputOnPathChangeCallbackType"), (Layout::new::<AzFileInputOnPathChangeCallbackType>(), "AzFileInputOnPathChangeCallbackType"));
        assert_eq!((Layout::new::<azul_core::callbacks::IFrameCallbackInfo>(), "AzIFrameCallbackInfo"), (Layout::new::<AzIFrameCallbackInfo>(), "AzIFrameCallbackInfo"));
        assert_eq!((Layout::new::<azul_layout::callbacks::CallbackInfo>(), "AzCallbackInfo"), (Layout::new::<AzCallbackInfo>(), "AzCallbackInfo"));
        assert_eq!((Layout::new::<azul_layout::callbacks::RenderImageCallbackInfo>(), "AzRenderImageCallbackInfo"), (Layout::new::<AzRenderImageCallbackInfo>(), "AzRenderImageCallbackInfo"));
        assert_eq!((Layout::new::<azul_core::callbacks::IFrameCallbackReason>(), "AzIFrameCallbackReason"), (Layout::new::<AzIFrameCallbackReason>(), "AzIFrameCallbackReason"));
        assert_eq!((Layout::new::<azul_core::task::InstantPtrCloneCallbackType>(), "AzInstantPtrCloneCallbackType"), (Layout::new::<AzInstantPtrCloneCallbackType>(), "AzInstantPtrCloneCallbackType"));
        assert_eq!((Layout::new::<azul_core::task::InstantPtrDestructorCallbackType>(), "AzInstantPtrDestructorCallbackType"), (Layout::new::<AzInstantPtrDestructorCallbackType>(), "AzInstantPtrDestructorCallbackType"));
        assert_eq!((Layout::new::<azul_core::callbacks::MarshaledLayoutCallbackInner>(), "AzMarshaledLayoutCallbackInner"), (Layout::new::<AzMarshaledLayoutCallbackInner>(), "AzMarshaledLayoutCallbackInner"));
        assert_eq!((Layout::new::<azul_core::callbacks::LayoutCallbackInner>(), "AzLayoutCallbackInner"), (Layout::new::<AzLayoutCallbackInner>(), "AzLayoutCallbackInner"));
        assert_eq!((Layout::new::<azul_core::callbacks::MarshaledLayoutCallback>(), "AzMarshaledLayoutCallback"), (Layout::new::<AzMarshaledLayoutCallback>(), "AzMarshaledLayoutCallback"));
        assert_eq!((Layout::new::<azul_core::callbacks::LayoutCallback>(), "AzLayoutCallback"), (Layout::new::<AzLayoutCallback>(), "AzLayoutCallback"));
        assert_eq!((Layout::new::<azul_core::dom::Dom>(), "AzDom"), (Layout::new::<AzDom>(), "AzDom"));
        assert_eq!((Layout::new::<azul_core::dom::NodeData>(), "AzNodeData"), (Layout::new::<AzNodeData>(), "AzNodeData"));
        assert_eq!((Layout::new::<azul_core::dom::NodeType>(), "AzNodeType"), (Layout::new::<AzNodeType>(), "AzNodeType"));
        assert_eq!((Layout::new::<azul_core::dom::AccessibilityInfo>(), "AzAccessibilityInfo"), (Layout::new::<AzAccessibilityInfo>(), "AzAccessibilityInfo"));
        assert_eq!((Layout::new::<azul_core::dom::AccessibilityRole>(), "AzAccessibilityRole"), (Layout::new::<AzAccessibilityRole>(), "AzAccessibilityRole"));
        assert_eq!((Layout::new::<azul_core::dom::AccessibilityState>(), "AzAccessibilityState"), (Layout::new::<AzAccessibilityState>(), "AzAccessibilityState"));
        assert_eq!((Layout::new::<azul_core::dom::TabIndex>(), "AzTabIndex"), (Layout::new::<AzTabIndex>(), "AzTabIndex"));
        assert_eq!((Layout::new::<azul_core::dom::NodeDataInlineCssProperty>(), "AzNodeDataInlineCssProperty"), (Layout::new::<AzNodeDataInlineCssProperty>(), "AzNodeDataInlineCssProperty"));
        assert_eq!((Layout::new::<azul_core::dom::DomId>(), "AzDomId"), (Layout::new::<AzDomId>(), "AzDomId"));
        assert_eq!((Layout::new::<azul_core::dom::DomNodeId>(), "AzDomNodeId"), (Layout::new::<AzDomNodeId>(), "AzDomNodeId"));
        assert_eq!((Layout::new::<azul_core::dom::AccessibilityAction>(), "AzAccessibilityAction"), (Layout::new::<AzAccessibilityAction>(), "AzAccessibilityAction"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::ListViewOnColumnClickCallback>(), "AzListViewOnColumnClickCallback"), (Layout::new::<AzListViewOnColumnClickCallback>(), "AzListViewOnColumnClickCallback"));
        assert_eq!((Layout::new::<azul_core::styled_dom::TagIdToNodeIdMapping>(), "AzTagIdToNodeIdMapping"), (Layout::new::<AzTagIdToNodeIdMapping>(), "AzTagIdToNodeIdMapping"));
        assert_eq!((Layout::new::<azul_core::callbacks::CoreCallback>(), "AzCoreCallback"), (Layout::new::<AzCoreCallback>(), "AzCoreCallback"));
        assert_eq!((Layout::new::<azul_core::styled_dom::NodeHierarchyItemId>(), "AzNodeHierarchyItemId"), (Layout::new::<AzNodeHierarchyItemId>(), "AzNodeHierarchyItemId"));
        assert_eq!((Layout::new::<azul_core::svg::SvgXmlNode>(), "AzSvgXmlNode"), (Layout::new::<AzSvgXmlNode>(), "AzSvgXmlNode"));
        assert_eq!((Layout::new::<azul_core::callbacks::CoreCallbackData>(), "AzCoreCallbackData"), (Layout::new::<AzCoreCallbackData>(), "AzCoreCallbackData"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::ListViewOnRowClickCallback>(), "AzListViewOnRowClickCallback"), (Layout::new::<AzListViewOnRowClickCallback>(), "AzListViewOnRowClickCallback"));
        assert_eq!((Layout::new::<azul_core::svg::SvgSimpleNode>(), "AzSvgSimpleNode"), (Layout::new::<AzSvgSimpleNode>(), "AzSvgSimpleNode"));
        assert_eq!((Layout::new::<azul_core::menu::CoreMenuCallback>(), "AzCoreMenuCallback"), (Layout::new::<AzCoreMenuCallback>(), "AzCoreMenuCallback"));
        assert_eq!((Layout::new::<azul_core::dom::AttributeNameValue>(), "AzAttributeNameValue"), (Layout::new::<AzAttributeNameValue>(), "AzAttributeNameValue"));
        assert_eq!((Layout::new::<azul_layout::widgets::check_box::CheckBoxOnToggleCallback>(), "AzCheckBoxOnToggleCallback"), (Layout::new::<AzCheckBoxOnToggleCallback>(), "AzCheckBoxOnToggleCallback"));
        assert_eq!((Layout::new::<azul_layout::widgets::tabs::TabOnClickCallback>(), "AzTabOnClickCallback"), (Layout::new::<AzTabOnClickCallback>(), "AzTabOnClickCallback"));
        assert_eq!((Layout::new::<azul_core::styled_dom::ParentWithNodeDepth>(), "AzParentWithNodeDepth"), (Layout::new::<AzParentWithNodeDepth>(), "AzParentWithNodeDepth"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::ListViewOnLazyLoadScrollCallback>(), "AzListViewOnLazyLoadScrollCallback"), (Layout::new::<AzListViewOnLazyLoadScrollCallback>(), "AzListViewOnLazyLoadScrollCallback"));
        assert_eq!((Layout::new::<azul_core::dom::AttributeType>(), "AzAttributeType"), (Layout::new::<AzAttributeType>(), "AzAttributeType"));
        assert_eq!((Layout::new::<azul_core::xml::XmlNodeChild>(), "AzXmlNodeChild"), (Layout::new::<AzXmlNodeChild>(), "AzXmlNodeChild"));
        assert_eq!((Layout::new::<azul_core::styled_dom::NodeHierarchyItem>(), "AzNodeHierarchyItem"), (Layout::new::<AzNodeHierarchyItem>(), "AzNodeHierarchyItem"));
        assert_eq!((Layout::new::<azul_layout::widgets::button::ButtonOnClickCallback>(), "AzButtonOnClickCallback"), (Layout::new::<AzButtonOnClickCallback>(), "AzButtonOnClickCallback"));
        assert_eq!((Layout::new::<azul_core::xml::XmlNode>(), "AzXmlNode"), (Layout::new::<AzXmlNode>(), "AzXmlNode"));
        assert_eq!((Layout::new::<azul_core::dom::TagId>(), "AzTagId"), (Layout::new::<AzTagId>(), "AzTagId"));
        assert_eq!((Layout::new::<azul_css::css::NodeTypeTag>(), "AzNodeTypeTag"), (Layout::new::<AzNodeTypeTag>(), "AzNodeTypeTag"));
        assert_eq!((Layout::new::<azul_core::gl::VertexAttributeType>(), "AzVertexAttributeType"), (Layout::new::<AzVertexAttributeType>(), "AzVertexAttributeType"));
        assert_eq!((Layout::new::<azul_core::gl::VertexAttribute>(), "AzVertexAttribute"), (Layout::new::<AzVertexAttribute>(), "AzVertexAttribute"));
        assert_eq!((Layout::new::<azul_core::task::InstantPtrCloneCallback>(), "AzInstantPtrCloneCallback"), (Layout::new::<AzInstantPtrCloneCallback>(), "AzInstantPtrCloneCallback"));
        assert_eq!((Layout::new::<azul_core::task::InstantPtrDestructorCallback>(), "AzInstantPtrDestructorCallback"), (Layout::new::<AzInstantPtrDestructorCallback>(), "AzInstantPtrDestructorCallback"));
        assert_eq!((Layout::new::<azul_core::window::TouchState>(), "AzTouchState"), (Layout::new::<AzTouchState>(), "AzTouchState"));
        assert_eq!((Layout::new::<azul_core::window::DebugState>(), "AzDebugState"), (Layout::new::<AzDebugState>(), "AzDebugState"));
        assert_eq!((Layout::new::<azul_layout::callbacks::Callback>(), "AzCallback"), (Layout::new::<AzCallback>(), "AzCallback"));
        assert_eq!((Layout::new::<azul_core::window::MouseState>(), "AzMouseState"), (Layout::new::<AzMouseState>(), "AzMouseState"));
        assert_eq!((Layout::new::<azul_core::window::KeyboardState>(), "AzKeyboardState"), (Layout::new::<AzKeyboardState>(), "AzKeyboardState"));
        assert_eq!((Layout::new::<azul_core::menu::Menu>(), "AzMenu"), (Layout::new::<AzMenu>(), "AzMenu"));
        assert_eq!((Layout::new::<azul_core::window::ContextMenuMouseButton>(), "AzContextMenuMouseButton"), (Layout::new::<AzContextMenuMouseButton>(), "AzContextMenuMouseButton"));
        assert_eq!((Layout::new::<azul_core::menu::MenuPopupPosition>(), "AzMenuPopupPosition"), (Layout::new::<AzMenuPopupPosition>(), "AzMenuPopupPosition"));
        assert_eq!((Layout::new::<azul_core::menu::MenuItem>(), "AzMenuItem"), (Layout::new::<AzMenuItem>(), "AzMenuItem"));
        assert_eq!((Layout::new::<azul_core::menu::StringMenuItem>(), "AzStringMenuItem"), (Layout::new::<AzStringMenuItem>(), "AzStringMenuItem"));
        assert_eq!((Layout::new::<azul_core::menu::MenuItemIcon>(), "AzMenuItemIcon"), (Layout::new::<AzMenuItemIcon>(), "AzMenuItemIcon"));
        assert_eq!((Layout::new::<azul_core::menu::MenuItemState>(), "AzMenuItemState"), (Layout::new::<AzMenuItemState>(), "AzMenuItemState"));
        assert_eq!((Layout::new::<azul_css::css::CssRuleBlock>(), "AzCssRuleBlock"), (Layout::new::<AzCssRuleBlock>(), "AzCssRuleBlock"));
        assert_eq!((Layout::new::<azul_css::props::property::CssProperty>(), "AzCssProperty"), (Layout::new::<AzCssProperty>(), "AzCssProperty"));
        assert_eq!((Layout::new::<azul_css::css::CssNthChildSelector>(), "AzCssNthChildSelector"), (Layout::new::<AzCssNthChildSelector>(), "AzCssNthChildSelector"));
        assert_eq!((Layout::new::<azul_css::css::CssNthChildPattern>(), "AzCssNthChildPattern"), (Layout::new::<AzCssNthChildPattern>(), "AzCssNthChildPattern"));
        assert_eq!((Layout::new::<azul_css::css::Stylesheet>(), "AzStylesheet"), (Layout::new::<AzStylesheet>(), "AzStylesheet"));
        assert_eq!((Layout::new::<azul_css::css::Css>(), "AzCss"), (Layout::new::<AzCss>(), "AzCss"));
        assert_eq!((Layout::new::<azul_css::css::CssDeclaration>(), "AzCssDeclaration"), (Layout::new::<AzCssDeclaration>(), "AzCssDeclaration"));
        assert_eq!((Layout::new::<azul_css::css::DynamicCssProperty>(), "AzDynamicCssProperty"), (Layout::new::<AzDynamicCssProperty>(), "AzDynamicCssProperty"));
        assert_eq!((Layout::new::<azul_css::props::basic::animation::AnimationInterpolationFunction>(), "AzAnimationInterpolationFunction"), (Layout::new::<AzAnimationInterpolationFunction>(), "AzAnimationInterpolationFunction"));
        assert_eq!((Layout::new::<azul_css::props::basic::color::ColorU>(), "AzColorU"), (Layout::new::<AzColorU>(), "AzColorU"));
        assert_eq!((Layout::new::<azul_css::props::basic::length::SizeMetric>(), "AzSizeMetric"), (Layout::new::<AzSizeMetric>(), "AzSizeMetric"));
        assert_eq!((Layout::new::<azul_css::props::basic::pixel::PixelValue>(), "AzPixelValue"), (Layout::new::<AzPixelValue>(), "AzPixelValue"));
        assert_eq!((Layout::new::<azul_css::props::basic::pixel::PixelValueNoPercent>(), "AzPixelValueNoPercent"), (Layout::new::<AzPixelValueNoPercent>(), "AzPixelValueNoPercent"));
        assert_eq!((Layout::new::<azul_css::props::style::box_shadow::BoxShadowClipMode>(), "AzBoxShadowClipMode"), (Layout::new::<AzBoxShadowClipMode>(), "AzBoxShadowClipMode"));
        assert_eq!((Layout::new::<azul_css::props::style::box_shadow::StyleBoxShadow>(), "AzStyleBoxShadow"), (Layout::new::<AzStyleBoxShadow>(), "AzStyleBoxShadow"));
        assert_eq!((Layout::new::<azul_css::props::style::effects::StyleMixBlendMode>(), "AzStyleMixBlendMode"), (Layout::new::<AzStyleMixBlendMode>(), "AzStyleMixBlendMode"));
        assert_eq!((Layout::new::<azul_css::props::style::filter::StyleFilter>(), "AzStyleFilter"), (Layout::new::<AzStyleFilter>(), "AzStyleFilter"));
        assert_eq!((Layout::new::<azul_css::props::style::filter::StyleBlur>(), "AzStyleBlur"), (Layout::new::<AzStyleBlur>(), "AzStyleBlur"));
        assert_eq!((Layout::new::<azul_css::props::style::filter::StyleColorMatrix>(), "AzStyleColorMatrix"), (Layout::new::<AzStyleColorMatrix>(), "AzStyleColorMatrix"));
        assert_eq!((Layout::new::<azul_css::props::style::filter::StyleFilterOffset>(), "AzStyleFilterOffset"), (Layout::new::<AzStyleFilterOffset>(), "AzStyleFilterOffset"));
        assert_eq!((Layout::new::<azul_css::props::style::filter::StyleCompositeFilter>(), "AzStyleCompositeFilter"), (Layout::new::<AzStyleCompositeFilter>(), "AzStyleCompositeFilter"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutAlignContent>(), "AzLayoutAlignContent"), (Layout::new::<AzLayoutAlignContent>(), "AzLayoutAlignContent"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutAlignItems>(), "AzLayoutAlignItems"), (Layout::new::<AzLayoutAlignItems>(), "AzLayoutAlignItems"));
        assert_eq!((Layout::new::<azul_css::props::layout::position::LayoutBottom>(), "AzLayoutBottom"), (Layout::new::<AzLayoutBottom>(), "AzLayoutBottom"));
        assert_eq!((Layout::new::<azul_css::props::layout::dimensions::LayoutBoxSizing>(), "AzLayoutBoxSizing"), (Layout::new::<AzLayoutBoxSizing>(), "AzLayoutBoxSizing"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutFlexDirection>(), "AzLayoutFlexDirection"), (Layout::new::<AzLayoutFlexDirection>(), "AzLayoutFlexDirection"));
        assert_eq!((Layout::new::<azul_css::props::layout::display::LayoutDisplay>(), "AzLayoutDisplay"), (Layout::new::<AzLayoutDisplay>(), "AzLayoutDisplay"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutFlexGrow>(), "AzLayoutFlexGrow"), (Layout::new::<AzLayoutFlexGrow>(), "AzLayoutFlexGrow"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutFlexShrink>(), "AzLayoutFlexShrink"), (Layout::new::<AzLayoutFlexShrink>(), "AzLayoutFlexShrink"));
        assert_eq!((Layout::new::<azul_css::props::layout::display::LayoutFloat>(), "AzLayoutFloat"), (Layout::new::<AzLayoutFloat>(), "AzLayoutFloat"));
        assert_eq!((Layout::new::<azul_css::props::layout::dimensions::LayoutHeight>(), "AzLayoutHeight"), (Layout::new::<AzLayoutHeight>(), "AzLayoutHeight"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutJustifyContent>(), "AzLayoutJustifyContent"), (Layout::new::<AzLayoutJustifyContent>(), "AzLayoutJustifyContent"));
        assert_eq!((Layout::new::<azul_css::props::layout::position::LayoutLeft>(), "AzLayoutLeft"), (Layout::new::<AzLayoutLeft>(), "AzLayoutLeft"));
        assert_eq!((Layout::new::<azul_css::props::layout::spacing::LayoutMarginBottom>(), "AzLayoutMarginBottom"), (Layout::new::<AzLayoutMarginBottom>(), "AzLayoutMarginBottom"));
        assert_eq!((Layout::new::<azul_css::props::layout::spacing::LayoutMarginLeft>(), "AzLayoutMarginLeft"), (Layout::new::<AzLayoutMarginLeft>(), "AzLayoutMarginLeft"));
        assert_eq!((Layout::new::<azul_css::props::layout::spacing::LayoutMarginRight>(), "AzLayoutMarginRight"), (Layout::new::<AzLayoutMarginRight>(), "AzLayoutMarginRight"));
        assert_eq!((Layout::new::<azul_css::props::layout::spacing::LayoutMarginTop>(), "AzLayoutMarginTop"), (Layout::new::<AzLayoutMarginTop>(), "AzLayoutMarginTop"));
        assert_eq!((Layout::new::<azul_css::props::layout::dimensions::LayoutMaxHeight>(), "AzLayoutMaxHeight"), (Layout::new::<AzLayoutMaxHeight>(), "AzLayoutMaxHeight"));
        assert_eq!((Layout::new::<azul_css::props::layout::dimensions::LayoutMaxWidth>(), "AzLayoutMaxWidth"), (Layout::new::<AzLayoutMaxWidth>(), "AzLayoutMaxWidth"));
        assert_eq!((Layout::new::<azul_css::props::layout::dimensions::LayoutMinHeight>(), "AzLayoutMinHeight"), (Layout::new::<AzLayoutMinHeight>(), "AzLayoutMinHeight"));
        assert_eq!((Layout::new::<azul_css::props::layout::dimensions::LayoutMinWidth>(), "AzLayoutMinWidth"), (Layout::new::<AzLayoutMinWidth>(), "AzLayoutMinWidth"));
        assert_eq!((Layout::new::<azul_css::props::layout::spacing::LayoutPaddingBottom>(), "AzLayoutPaddingBottom"), (Layout::new::<AzLayoutPaddingBottom>(), "AzLayoutPaddingBottom"));
        assert_eq!((Layout::new::<azul_css::props::layout::spacing::LayoutPaddingLeft>(), "AzLayoutPaddingLeft"), (Layout::new::<AzLayoutPaddingLeft>(), "AzLayoutPaddingLeft"));
        assert_eq!((Layout::new::<azul_css::props::layout::spacing::LayoutPaddingRight>(), "AzLayoutPaddingRight"), (Layout::new::<AzLayoutPaddingRight>(), "AzLayoutPaddingRight"));
        assert_eq!((Layout::new::<azul_css::props::layout::spacing::LayoutPaddingTop>(), "AzLayoutPaddingTop"), (Layout::new::<AzLayoutPaddingTop>(), "AzLayoutPaddingTop"));
        assert_eq!((Layout::new::<azul_css::props::layout::position::LayoutPosition>(), "AzLayoutPosition"), (Layout::new::<AzLayoutPosition>(), "AzLayoutPosition"));
        assert_eq!((Layout::new::<azul_css::props::layout::position::LayoutRight>(), "AzLayoutRight"), (Layout::new::<AzLayoutRight>(), "AzLayoutRight"));
        assert_eq!((Layout::new::<azul_css::props::layout::position::LayoutTop>(), "AzLayoutTop"), (Layout::new::<AzLayoutTop>(), "AzLayoutTop"));
        assert_eq!((Layout::new::<azul_css::props::layout::dimensions::LayoutWidth>(), "AzLayoutWidth"), (Layout::new::<AzLayoutWidth>(), "AzLayoutWidth"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutFlexWrap>(), "AzLayoutFlexWrap"), (Layout::new::<AzLayoutFlexWrap>(), "AzLayoutFlexWrap"));
        assert_eq!((Layout::new::<azul_css::props::layout::overflow::LayoutOverflow>(), "AzLayoutOverflow"), (Layout::new::<AzLayoutOverflow>(), "AzLayoutOverflow"));
        assert_eq!((Layout::new::<azul_css::props::basic::length::FloatValue>(), "AzFloatValue"), (Layout::new::<AzFloatValue>(), "AzFloatValue"));
        assert_eq!((Layout::new::<azul_css::props::basic::length::PercentageValue>(), "AzPercentageValue"), (Layout::new::<AzPercentageValue>(), "AzPercentageValue"));
        assert_eq!((Layout::new::<azul_css::props::basic::angle::AngleMetric>(), "AzAngleMetric"), (Layout::new::<AzAngleMetric>(), "AzAngleMetric"));
        assert_eq!((Layout::new::<azul_css::props::basic::angle::AngleValue>(), "AzAngleValue"), (Layout::new::<AzAngleValue>(), "AzAngleValue"));
        assert_eq!((Layout::new::<azul_css::props::style::background::NormalizedLinearColorStop>(), "AzNormalizedLinearColorStop"), (Layout::new::<AzNormalizedLinearColorStop>(), "AzNormalizedLinearColorStop"));
        assert_eq!((Layout::new::<azul_css::props::style::background::NormalizedRadialColorStop>(), "AzNormalizedRadialColorStop"), (Layout::new::<AzNormalizedRadialColorStop>(), "AzNormalizedRadialColorStop"));
        assert_eq!((Layout::new::<azul_css::props::basic::direction::DirectionCorner>(), "AzDirectionCorner"), (Layout::new::<AzDirectionCorner>(), "AzDirectionCorner"));
        assert_eq!((Layout::new::<azul_css::props::basic::direction::DirectionCorners>(), "AzDirectionCorners"), (Layout::new::<AzDirectionCorners>(), "AzDirectionCorners"));
        assert_eq!((Layout::new::<azul_css::props::basic::direction::Direction>(), "AzDirection"), (Layout::new::<AzDirection>(), "AzDirection"));
        assert_eq!((Layout::new::<azul_css::props::style::background::LinearGradient>(), "AzLinearGradient"), (Layout::new::<AzLinearGradient>(), "AzLinearGradient"));
        assert_eq!((Layout::new::<azul_css::props::style::background::Shape>(), "AzShape"), (Layout::new::<AzShape>(), "AzShape"));
        assert_eq!((Layout::new::<azul_css::props::style::background::RadialGradientSize>(), "AzRadialGradientSize"), (Layout::new::<AzRadialGradientSize>(), "AzRadialGradientSize"));
        assert_eq!((Layout::new::<azul_css::props::style::background::RadialGradient>(), "AzRadialGradient"), (Layout::new::<AzRadialGradient>(), "AzRadialGradient"));
        assert_eq!((Layout::new::<azul_css::props::style::background::ConicGradient>(), "AzConicGradient"), (Layout::new::<AzConicGradient>(), "AzConicGradient"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundContent>(), "AzStyleBackgroundContent"), (Layout::new::<AzStyleBackgroundContent>(), "AzStyleBackgroundContent"));
        assert_eq!((Layout::new::<azul_css::props::style::background::BackgroundPositionHorizontal>(), "AzBackgroundPositionHorizontal"), (Layout::new::<AzBackgroundPositionHorizontal>(), "AzBackgroundPositionHorizontal"));
        assert_eq!((Layout::new::<azul_css::props::style::background::BackgroundPositionVertical>(), "AzBackgroundPositionVertical"), (Layout::new::<AzBackgroundPositionVertical>(), "AzBackgroundPositionVertical"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundPosition>(), "AzStyleBackgroundPosition"), (Layout::new::<AzStyleBackgroundPosition>(), "AzStyleBackgroundPosition"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundRepeat>(), "AzStyleBackgroundRepeat"), (Layout::new::<AzStyleBackgroundRepeat>(), "AzStyleBackgroundRepeat"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundSize>(), "AzStyleBackgroundSize"), (Layout::new::<AzStyleBackgroundSize>(), "AzStyleBackgroundSize"));
        assert_eq!((Layout::new::<azul_css::props::style::border::StyleBorderBottomColor>(), "AzStyleBorderBottomColor"), (Layout::new::<AzStyleBorderBottomColor>(), "AzStyleBorderBottomColor"));
        assert_eq!((Layout::new::<azul_css::props::style::border_radius::StyleBorderBottomLeftRadius>(), "AzStyleBorderBottomLeftRadius"), (Layout::new::<AzStyleBorderBottomLeftRadius>(), "AzStyleBorderBottomLeftRadius"));
        assert_eq!((Layout::new::<azul_css::props::style::border_radius::StyleBorderBottomRightRadius>(), "AzStyleBorderBottomRightRadius"), (Layout::new::<AzStyleBorderBottomRightRadius>(), "AzStyleBorderBottomRightRadius"));
        assert_eq!((Layout::new::<azul_css::props::style::border::BorderStyle>(), "AzBorderStyle"), (Layout::new::<AzBorderStyle>(), "AzBorderStyle"));
        assert_eq!((Layout::new::<azul_css::props::style::border::StyleBorderBottomStyle>(), "AzStyleBorderBottomStyle"), (Layout::new::<AzStyleBorderBottomStyle>(), "AzStyleBorderBottomStyle"));
        assert_eq!((Layout::new::<azul_css::props::style::border::LayoutBorderBottomWidth>(), "AzLayoutBorderBottomWidth"), (Layout::new::<AzLayoutBorderBottomWidth>(), "AzLayoutBorderBottomWidth"));
        assert_eq!((Layout::new::<azul_css::props::style::border::StyleBorderLeftColor>(), "AzStyleBorderLeftColor"), (Layout::new::<AzStyleBorderLeftColor>(), "AzStyleBorderLeftColor"));
        assert_eq!((Layout::new::<azul_css::props::style::border::StyleBorderLeftStyle>(), "AzStyleBorderLeftStyle"), (Layout::new::<AzStyleBorderLeftStyle>(), "AzStyleBorderLeftStyle"));
        assert_eq!((Layout::new::<azul_css::props::style::border::LayoutBorderLeftWidth>(), "AzLayoutBorderLeftWidth"), (Layout::new::<AzLayoutBorderLeftWidth>(), "AzLayoutBorderLeftWidth"));
        assert_eq!((Layout::new::<azul_css::props::style::border::StyleBorderRightColor>(), "AzStyleBorderRightColor"), (Layout::new::<AzStyleBorderRightColor>(), "AzStyleBorderRightColor"));
        assert_eq!((Layout::new::<azul_css::props::style::border::StyleBorderRightStyle>(), "AzStyleBorderRightStyle"), (Layout::new::<AzStyleBorderRightStyle>(), "AzStyleBorderRightStyle"));
        assert_eq!((Layout::new::<azul_css::props::style::border::LayoutBorderRightWidth>(), "AzLayoutBorderRightWidth"), (Layout::new::<AzLayoutBorderRightWidth>(), "AzLayoutBorderRightWidth"));
        assert_eq!((Layout::new::<azul_css::props::style::border::StyleBorderTopColor>(), "AzStyleBorderTopColor"), (Layout::new::<AzStyleBorderTopColor>(), "AzStyleBorderTopColor"));
        assert_eq!((Layout::new::<azul_css::props::style::border_radius::StyleBorderTopLeftRadius>(), "AzStyleBorderTopLeftRadius"), (Layout::new::<AzStyleBorderTopLeftRadius>(), "AzStyleBorderTopLeftRadius"));
        assert_eq!((Layout::new::<azul_css::props::style::border_radius::StyleBorderTopRightRadius>(), "AzStyleBorderTopRightRadius"), (Layout::new::<AzStyleBorderTopRightRadius>(), "AzStyleBorderTopRightRadius"));
        assert_eq!((Layout::new::<azul_css::props::style::border::StyleBorderTopStyle>(), "AzStyleBorderTopStyle"), (Layout::new::<AzStyleBorderTopStyle>(), "AzStyleBorderTopStyle"));
        assert_eq!((Layout::new::<azul_css::props::style::border::LayoutBorderTopWidth>(), "AzLayoutBorderTopWidth"), (Layout::new::<AzLayoutBorderTopWidth>(), "AzLayoutBorderTopWidth"));
        assert_eq!((Layout::new::<azul_css::props::style::scrollbar::ScrollbarInfo>(), "AzScrollbarInfo"), (Layout::new::<AzScrollbarInfo>(), "AzScrollbarInfo"));
        assert_eq!((Layout::new::<azul_css::props::style::scrollbar::ScrollbarStyle>(), "AzScrollbarStyle"), (Layout::new::<AzScrollbarStyle>(), "AzScrollbarStyle"));
        assert_eq!((Layout::new::<azul_css::props::basic::font::StyleFontFamily>(), "AzStyleFontFamily"), (Layout::new::<AzStyleFontFamily>(), "AzStyleFontFamily"));
        assert_eq!((Layout::new::<azul_css::props::basic::font::StyleFontSize>(), "AzStyleFontSize"), (Layout::new::<AzStyleFontSize>(), "AzStyleFontSize"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleLetterSpacing>(), "AzStyleLetterSpacing"), (Layout::new::<AzStyleLetterSpacing>(), "AzStyleLetterSpacing"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleLineHeight>(), "AzStyleLineHeight"), (Layout::new::<AzStyleLineHeight>(), "AzStyleLineHeight"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleTabWidth>(), "AzStyleTabWidth"), (Layout::new::<AzStyleTabWidth>(), "AzStyleTabWidth"));
        assert_eq!((Layout::new::<azul_css::props::style::effects::StyleOpacity>(), "AzStyleOpacity"), (Layout::new::<AzStyleOpacity>(), "AzStyleOpacity"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformOrigin>(), "AzStyleTransformOrigin"), (Layout::new::<AzStyleTransformOrigin>(), "AzStyleTransformOrigin"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleBackfaceVisibility>(), "AzStyleBackfaceVisibility"), (Layout::new::<AzStyleBackfaceVisibility>(), "AzStyleBackfaceVisibility"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransform>(), "AzStyleTransform"), (Layout::new::<AzStyleTransform>(), "AzStyleTransform"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformMatrix2D>(), "AzStyleTransformMatrix2D"), (Layout::new::<AzStyleTransformMatrix2D>(), "AzStyleTransformMatrix2D"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformMatrix3D>(), "AzStyleTransformMatrix3D"), (Layout::new::<AzStyleTransformMatrix3D>(), "AzStyleTransformMatrix3D"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformTranslate2D>(), "AzStyleTransformTranslate2D"), (Layout::new::<AzStyleTransformTranslate2D>(), "AzStyleTransformTranslate2D"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformTranslate3D>(), "AzStyleTransformTranslate3D"), (Layout::new::<AzStyleTransformTranslate3D>(), "AzStyleTransformTranslate3D"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformRotate3D>(), "AzStyleTransformRotate3D"), (Layout::new::<AzStyleTransformRotate3D>(), "AzStyleTransformRotate3D"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformScale2D>(), "AzStyleTransformScale2D"), (Layout::new::<AzStyleTransformScale2D>(), "AzStyleTransformScale2D"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformScale3D>(), "AzStyleTransformScale3D"), (Layout::new::<AzStyleTransformScale3D>(), "AzStyleTransformScale3D"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformSkew2D>(), "AzStyleTransformSkew2D"), (Layout::new::<AzStyleTransformSkew2D>(), "AzStyleTransformSkew2D"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleTextAlign>(), "AzStyleTextAlign"), (Layout::new::<AzStyleTextAlign>(), "AzStyleTextAlign"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleTextColor>(), "AzStyleTextColor"), (Layout::new::<AzStyleTextColor>(), "AzStyleTextColor"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleWordSpacing>(), "AzStyleWordSpacing"), (Layout::new::<AzStyleWordSpacing>(), "AzStyleWordSpacing"));
        assert_eq!((Layout::new::<azul_css::css::CssPropertyValue>(), "AzCssPropertyValue"), (Layout::new::<AzCssPropertyValue>(), "AzCssPropertyValue"));
        assert_eq!((Layout::new::<azul_css::props::style::content::CounterReset>(), "AzCounterReset"), (Layout::new::<AzCounterReset>(), "AzCounterReset"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::GridLine>(), "AzGridLine"), (Layout::new::<AzGridLine>(), "AzGridLine"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StylePerspectiveOrigin>(), "AzStylePerspectiveOrigin"), (Layout::new::<AzStylePerspectiveOrigin>(), "AzStylePerspectiveOrigin"));
        assert_eq!((Layout::new::<azul_css::props::layout::position::LayoutZIndex>(), "AzLayoutZIndex"), (Layout::new::<AzLayoutZIndex>(), "AzLayoutZIndex"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::LayoutJustifyItems>(), "AzLayoutJustifyItems"), (Layout::new::<AzLayoutJustifyItems>(), "AzLayoutJustifyItems"));
        assert_eq!((Layout::new::<azul_css::props::style::selection::SelectionBackgroundColor>(), "AzSelectionBackgroundColor"), (Layout::new::<AzSelectionBackgroundColor>(), "AzSelectionBackgroundColor"));
        assert_eq!((Layout::new::<azul_css::props::layout::column::ColumnRuleColor>(), "AzColumnRuleColor"), (Layout::new::<AzColumnRuleColor>(), "AzColumnRuleColor"));
        assert_eq!((Layout::new::<azul_css::props::layout::column::ColumnSpan>(), "AzColumnSpan"), (Layout::new::<AzColumnSpan>(), "AzColumnSpan"));
        assert_eq!((Layout::new::<azul_css::props::layout::wrapping::LayoutClear>(), "AzLayoutClear"), (Layout::new::<AzLayoutClear>(), "AzLayoutClear"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleWhiteSpace>(), "AzStyleWhiteSpace"), (Layout::new::<AzStyleWhiteSpace>(), "AzStyleWhiteSpace"));
        assert_eq!((Layout::new::<azul_css::props::layout::fragmentation::BreakInside>(), "AzBreakInside"), (Layout::new::<AzBreakInside>(), "AzBreakInside"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutAlignSelf>(), "AzLayoutAlignSelf"), (Layout::new::<AzLayoutAlignSelf>(), "AzLayoutAlignSelf"));
        assert_eq!((Layout::new::<azul_css::props::style::text::CaretAnimationDuration>(), "AzCaretAnimationDuration"), (Layout::new::<AzCaretAnimationDuration>(), "AzCaretAnimationDuration"));
        assert_eq!((Layout::new::<azul_css::props::layout::column::ColumnRuleStyle>(), "AzColumnRuleStyle"), (Layout::new::<AzColumnRuleStyle>(), "AzColumnRuleStyle"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::GridPlacement>(), "AzGridPlacement"), (Layout::new::<AzGridPlacement>(), "AzGridPlacement"));
        assert_eq!((Layout::new::<azul_css::props::layout::shape::ShapeOutside>(), "AzShapeOutside"), (Layout::new::<AzShapeOutside>(), "AzShapeOutside"));
        assert_eq!((Layout::new::<azul_css::props::layout::column::ColumnCount>(), "AzColumnCount"), (Layout::new::<AzColumnCount>(), "AzColumnCount"));
        assert_eq!((Layout::new::<azul_css::props::layout::wrapping::LayoutWritingMode>(), "AzLayoutWritingMode"), (Layout::new::<AzLayoutWritingMode>(), "AzLayoutWritingMode"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleUserSelect>(), "AzStyleUserSelect"), (Layout::new::<AzStyleUserSelect>(), "AzStyleUserSelect"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::GridTemplate>(), "AzGridTemplate"), (Layout::new::<AzGridTemplate>(), "AzGridTemplate"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::LayoutJustifySelf>(), "AzLayoutJustifySelf"), (Layout::new::<AzLayoutJustifySelf>(), "AzLayoutJustifySelf"));
        assert_eq!((Layout::new::<azul_css::props::style::content::Content>(), "AzContent"), (Layout::new::<AzContent>(), "AzContent"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleHyphens>(), "AzStyleHyphens"), (Layout::new::<AzStyleHyphens>(), "AzStyleHyphens"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::LayoutGap>(), "AzLayoutGap"), (Layout::new::<AzLayoutGap>(), "AzLayoutGap"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleDirection>(), "AzStyleDirection"), (Layout::new::<AzStyleDirection>(), "AzStyleDirection"));
        assert_eq!((Layout::new::<azul_css::props::layout::flex::LayoutFlexBasis>(), "AzLayoutFlexBasis"), (Layout::new::<AzLayoutFlexBasis>(), "AzLayoutFlexBasis"));
        assert_eq!((Layout::new::<azul_css::props::layout::shape::ShapeMargin>(), "AzShapeMargin"), (Layout::new::<AzShapeMargin>(), "AzShapeMargin"));
        assert_eq!((Layout::new::<azul_css::props::layout::text::LayoutTextJustify>(), "AzLayoutTextJustify"), (Layout::new::<AzLayoutTextJustify>(), "AzLayoutTextJustify"));
        assert_eq!((Layout::new::<azul_css::props::layout::column::ColumnWidth>(), "AzColumnWidth"), (Layout::new::<AzColumnWidth>(), "AzColumnWidth"));
        assert_eq!((Layout::new::<azul_css::props::style::content::CounterIncrement>(), "AzCounterIncrement"), (Layout::new::<AzCounterIncrement>(), "AzCounterIncrement"));
        assert_eq!((Layout::new::<azul_css::props::layout::fragmentation::BoxDecorationBreak>(), "AzBoxDecorationBreak"), (Layout::new::<AzBoxDecorationBreak>(), "AzBoxDecorationBreak"));
        assert_eq!((Layout::new::<azul_css::props::style::selection::SelectionColor>(), "AzSelectionColor"), (Layout::new::<AzSelectionColor>(), "AzSelectionColor"));
        assert_eq!((Layout::new::<azul_css::props::style::effects::StyleVisibility>(), "AzStyleVisibility"), (Layout::new::<AzStyleVisibility>(), "AzStyleVisibility"));
        assert_eq!((Layout::new::<azul_css::props::layout::shape::ShapeImageThreshold>(), "AzShapeImageThreshold"), (Layout::new::<AzShapeImageThreshold>(), "AzShapeImageThreshold"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::LayoutGridAutoFlow>(), "AzLayoutGridAutoFlow"), (Layout::new::<AzLayoutGridAutoFlow>(), "AzLayoutGridAutoFlow"));
        assert_eq!((Layout::new::<azul_css::props::layout::column::ColumnRuleWidth>(), "AzColumnRuleWidth"), (Layout::new::<AzColumnRuleWidth>(), "AzColumnRuleWidth"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleTextDecoration>(), "AzStyleTextDecoration"), (Layout::new::<AzStyleTextDecoration>(), "AzStyleTextDecoration"));
        assert_eq!((Layout::new::<azul_css::props::style::text::CaretColor>(), "AzCaretColor"), (Layout::new::<AzCaretColor>(), "AzCaretColor"));
        assert_eq!((Layout::new::<azul_css::props::basic::geometry::LayoutSize>(), "AzLayoutSize"), (Layout::new::<AzLayoutSize>(), "AzLayoutSize"));
        assert_eq!((Layout::new::<azul_css::props::layout::column::ColumnFill>(), "AzColumnFill"), (Layout::new::<AzColumnFill>(), "AzColumnFill"));
        assert_eq!((Layout::new::<azul_css::props::layout::fragmentation::PageBreak>(), "AzPageBreak"), (Layout::new::<AzPageBreak>(), "AzPageBreak"));
        assert_eq!((Layout::new::<azul_css::props::style::scrollbar::LayoutScrollbarWidth>(), "AzLayoutScrollbarWidth"), (Layout::new::<AzLayoutScrollbarWidth>(), "AzLayoutScrollbarWidth"));
        assert_eq!((Layout::new::<azul_css::props::style::scrollbar::StyleScrollbarColor>(), "AzStyleScrollbarColor"), (Layout::new::<AzStyleScrollbarColor>(), "AzStyleScrollbarColor"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleVerticalAlign>(), "AzStyleVerticalAlign"), (Layout::new::<AzStyleVerticalAlign>(), "AzStyleVerticalAlign"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleLineClamp>(), "AzStyleLineClamp"), (Layout::new::<AzStyleLineClamp>(), "AzStyleLineClamp"));
        assert_eq!((Layout::new::<azul_css::props::layout::shape::ShapeInside>(), "AzShapeInside"), (Layout::new::<AzShapeInside>(), "AzShapeInside"));
        assert_eq!((Layout::new::<azul_css::props::style::selection::SelectionRadius>(), "AzSelectionRadius"), (Layout::new::<AzSelectionRadius>(), "AzSelectionRadius"));
        assert_eq!((Layout::new::<azul_css::props::layout::fragmentation::Orphans>(), "AzOrphans"), (Layout::new::<AzOrphans>(), "AzOrphans"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleTextIndent>(), "AzStyleTextIndent"), (Layout::new::<AzStyleTextIndent>(), "AzStyleTextIndent"));
        assert_eq!((Layout::new::<azul_css::props::layout::table::LayoutBorderSpacing>(), "AzLayoutBorderSpacing"), (Layout::new::<AzLayoutBorderSpacing>(), "AzLayoutBorderSpacing"));
        assert_eq!((Layout::new::<azul_css::props::layout::spacing::LayoutPaddingInlineStart>(), "AzLayoutPaddingInlineStart"), (Layout::new::<AzLayoutPaddingInlineStart>(), "AzLayoutPaddingInlineStart"));
        assert_eq!((Layout::new::<azul_css::props::basic::font::StyleFontWeight>(), "AzStyleFontWeight"), (Layout::new::<AzStyleFontWeight>(), "AzStyleFontWeight"));
        assert_eq!((Layout::new::<azul_css::props::style::azul_exclusion::StyleExclusionMargin>(), "AzStyleExclusionMargin"), (Layout::new::<AzStyleExclusionMargin>(), "AzStyleExclusionMargin"));
        assert_eq!((Layout::new::<azul_css::props::layout::fragmentation::Widows>(), "AzWidows"), (Layout::new::<AzWidows>(), "AzWidows"));
        assert_eq!((Layout::new::<azul_css::props::layout::spacing::LayoutColumnGap>(), "AzLayoutColumnGap"), (Layout::new::<AzLayoutColumnGap>(), "AzLayoutColumnGap"));
        assert_eq!((Layout::new::<azul_css::props::layout::spacing::LayoutPaddingInlineEnd>(), "AzLayoutPaddingInlineEnd"), (Layout::new::<AzLayoutPaddingInlineEnd>(), "AzLayoutPaddingInlineEnd"));
        assert_eq!((Layout::new::<azul_css::props::style::lists::StyleListStyleType>(), "AzStyleListStyleType"), (Layout::new::<AzStyleListStyleType>(), "AzStyleListStyleType"));
        assert_eq!((Layout::new::<azul_css::props::layout::shape::ClipPath>(), "AzClipPath"), (Layout::new::<AzClipPath>(), "AzClipPath"));
        assert_eq!((Layout::new::<azul_css::props::style::azul_exclusion::StyleHyphenationLanguage>(), "AzStyleHyphenationLanguage"), (Layout::new::<AzStyleHyphenationLanguage>(), "AzStyleHyphenationLanguage"));
        assert_eq!((Layout::new::<azul_css::props::style::lists::StyleListStylePosition>(), "AzStyleListStylePosition"), (Layout::new::<AzStyleListStylePosition>(), "AzStyleListStylePosition"));
        assert_eq!((Layout::new::<azul_css::props::layout::table::StyleBorderCollapse>(), "AzStyleBorderCollapse"), (Layout::new::<AzStyleBorderCollapse>(), "AzStyleBorderCollapse"));
        assert_eq!((Layout::new::<azul_css::props::layout::table::StyleCaptionSide>(), "AzStyleCaptionSide"), (Layout::new::<AzStyleCaptionSide>(), "AzStyleCaptionSide"));
        assert_eq!((Layout::new::<azul_css::props::layout::spacing::LayoutRowGap>(), "AzLayoutRowGap"), (Layout::new::<AzLayoutRowGap>(), "AzLayoutRowGap"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleHangingPunctuation>(), "AzStyleHangingPunctuation"), (Layout::new::<AzStyleHangingPunctuation>(), "AzStyleHangingPunctuation"));
        assert_eq!((Layout::new::<azul_css::props::layout::table::LayoutTableLayout>(), "AzLayoutTableLayout"), (Layout::new::<AzLayoutTableLayout>(), "AzLayoutTableLayout"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleInitialLetter>(), "AzStyleInitialLetter"), (Layout::new::<AzStyleInitialLetter>(), "AzStyleInitialLetter"));
        assert_eq!((Layout::new::<azul_css::props::layout::table::StyleEmptyCells>(), "AzStyleEmptyCells"), (Layout::new::<AzStyleEmptyCells>(), "AzStyleEmptyCells"));
        assert_eq!((Layout::new::<azul_css::props::basic::font::StyleFontStyle>(), "AzStyleFontStyle"), (Layout::new::<AzStyleFontStyle>(), "AzStyleFontStyle"));
        assert_eq!((Layout::new::<azul_css::props::style::text::StyleTextCombineUpright>(), "AzStyleTextCombineUpright"), (Layout::new::<AzStyleTextCombineUpright>(), "AzStyleTextCombineUpright"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::GridTrackSizing>(), "AzGridTrackSizing"), (Layout::new::<AzGridTrackSizing>(), "AzGridTrackSizing"));
        assert_eq!((Layout::new::<azul_core::events::HoverEventFilter>(), "AzHoverEventFilter"), (Layout::new::<AzHoverEventFilter>(), "AzHoverEventFilter"));
        assert_eq!((Layout::new::<azul_core::dom::TextSelectionStartEnd>(), "AzTextSelectionStartEnd"), (Layout::new::<AzTextSelectionStartEnd>(), "AzTextSelectionStartEnd"));
        assert_eq!((Layout::new::<azul_core::svg::ShapeRendering>(), "AzShapeRendering"), (Layout::new::<AzShapeRendering>(), "AzShapeRendering"));
        assert_eq!((Layout::new::<azul_core::events::ApplicationEventFilter>(), "AzApplicationEventFilter"), (Layout::new::<AzApplicationEventFilter>(), "AzApplicationEventFilter"));
        assert_eq!((Layout::new::<azul_core::svg::SvgFillStyle>(), "AzSvgFillStyle"), (Layout::new::<AzSvgFillStyle>(), "AzSvgFillStyle"));
        assert_eq!((Layout::new::<azul_core::xml::XmlTextPos>(), "AzXmlTextPos"), (Layout::new::<AzXmlTextPos>(), "AzXmlTextPos"));
        assert_eq!((Layout::new::<azul_core::geom::LogicalSize>(), "AzLogicalSize"), (Layout::new::<AzLogicalSize>(), "AzLogicalSize"));
        assert_eq!((Layout::new::<azul_core::styled_dom::StyledNodeState>(), "AzStyledNodeState"), (Layout::new::<AzStyledNodeState>(), "AzStyledNodeState"));
        assert_eq!((Layout::new::<azul_core::prop_cache::CssPropertyCachePtr>(), "AzCssPropertyCachePtr"), (Layout::new::<AzCssPropertyCachePtr>(), "AzCssPropertyCachePtr"));
        assert_eq!((Layout::new::<azul_core::svg::SvgRenderTransform>(), "AzSvgRenderTransform"), (Layout::new::<AzSvgRenderTransform>(), "AzSvgRenderTransform"));
        assert_eq!((Layout::new::<azul_core::svg::TextRendering>(), "AzTextRendering"), (Layout::new::<AzTextRendering>(), "AzTextRendering"));
        assert_eq!((Layout::new::<azul_core::events::FocusEventFilter>(), "AzFocusEventFilter"), (Layout::new::<AzFocusEventFilter>(), "AzFocusEventFilter"));
        assert_eq!((Layout::new::<azul_core::geom::LogicalPosition>(), "AzLogicalPosition"), (Layout::new::<AzLogicalPosition>(), "AzLogicalPosition"));
        assert_eq!((Layout::new::<azul_core::events::EventFilter>(), "AzEventFilter"), (Layout::new::<AzEventFilter>(), "AzEventFilter"));
        assert_eq!((Layout::new::<azul_core::geom::PhysicalSize>(), "AzPhysicalSize"), (Layout::new::<AzPhysicalSize>(), "AzPhysicalSize"));
        assert_eq!((Layout::new::<azul_core::svg::SvgStyle>(), "AzSvgStyle"), (Layout::new::<AzSvgStyle>(), "AzSvgStyle"));
        assert_eq!((Layout::new::<azul_core::svg::Indent>(), "AzIndent"), (Layout::new::<AzIndent>(), "AzIndent"));
        assert_eq!((Layout::new::<azul_core::svg::FontDatabase>(), "AzFontDatabase"), (Layout::new::<AzFontDatabase>(), "AzFontDatabase"));
        assert_eq!((Layout::new::<azul_core::styled_dom::StyledDom>(), "AzStyledDom"), (Layout::new::<AzStyledDom>(), "AzStyledDom"));
        assert_eq!((Layout::new::<azul_core::styled_dom::StyledNode>(), "AzStyledNode"), (Layout::new::<AzStyledNode>(), "AzStyledNode"));
        assert_eq!((Layout::new::<azul_core::events::NotEventFilter>(), "AzNotEventFilter"), (Layout::new::<AzNotEventFilter>(), "AzNotEventFilter"));
        assert_eq!((Layout::new::<azul_core::events::ComponentEventFilter>(), "AzComponentEventFilter"), (Layout::new::<AzComponentEventFilter>(), "AzComponentEventFilter"));
        assert_eq!((Layout::new::<azul_core::svg::SvgTransform>(), "AzSvgTransform"), (Layout::new::<AzSvgTransform>(), "AzSvgTransform"));
        assert_eq!((Layout::new::<azul_core::gl::VertexLayout>(), "AzVertexLayout"), (Layout::new::<AzVertexLayout>(), "AzVertexLayout"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::GridMinMax>(), "AzGridMinMax"), (Layout::new::<AzGridMinMax>(), "AzGridMinMax"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::NamedGridLine>(), "AzNamedGridLine"), (Layout::new::<AzNamedGridLine>(), "AzNamedGridLine"));
        assert_eq!((Layout::new::<azul_css::props::style::scrollbar::ScrollbarColorCustom>(), "AzScrollbarColorCustom"), (Layout::new::<AzScrollbarColorCustom>(), "AzScrollbarColorCustom"));
        assert_eq!((Layout::new::<azul_css::shape::ShapeInset>(), "AzShapeInset"), (Layout::new::<AzShapeInset>(), "AzShapeInset"));
        assert_eq!((Layout::new::<azul_css::shape::CssShape>(), "AzCssShape"), (Layout::new::<AzCssShape>(), "AzCssShape"));
        assert_eq!((Layout::new::<azul_css::shape::ShapePath>(), "AzShapePath"), (Layout::new::<AzShapePath>(), "AzShapePath"));
        assert_eq!((Layout::new::<azul_css::shape::ShapeEllipse>(), "AzShapeEllipse"), (Layout::new::<AzShapeEllipse>(), "AzShapeEllipse"));
        assert_eq!((Layout::new::<azul_css::shape::ShapePoint>(), "AzShapePoint"), (Layout::new::<AzShapePoint>(), "AzShapePoint"));
        assert_eq!((Layout::new::<azul_core::window::Srgb>(), "AzSrgb"), (Layout::new::<AzSrgb>(), "AzSrgb"));
        assert_eq!((Layout::new::<azul_core::window::WindowDecorations>(), "AzWindowDecorations"), (Layout::new::<AzWindowDecorations>(), "AzWindowDecorations"));
        assert_eq!((Layout::new::<azul_core::window::ImePosition>(), "AzImePosition"), (Layout::new::<AzImePosition>(), "AzImePosition"));
        assert_eq!((Layout::new::<azul_core::window::WindowPosition>(), "AzWindowPosition"), (Layout::new::<AzWindowPosition>(), "AzWindowPosition"));
        assert_eq!((Layout::new::<azul_core::window::CursorPosition>(), "AzCursorPosition"), (Layout::new::<AzCursorPosition>(), "AzCursorPosition"));
        assert_eq!((Layout::new::<azul_core::window::WindowBackgroundMaterial>(), "AzWindowBackgroundMaterial"), (Layout::new::<AzWindowBackgroundMaterial>(), "AzWindowBackgroundMaterial"));
        assert_eq!((Layout::new::<azul_layout::widgets::button::Button>(), "AzButton"), (Layout::new::<AzButton>(), "AzButton"));
        assert_eq!((Layout::new::<azul_layout::widgets::button::ButtonOnClick>(), "AzButtonOnClick"), (Layout::new::<AzButtonOnClick>(), "AzButtonOnClick"));
        assert_eq!((Layout::new::<azul_layout::widgets::file_input::FileInput>(), "AzFileInput"), (Layout::new::<AzFileInput>(), "AzFileInput"));
        assert_eq!((Layout::new::<azul_layout::widgets::file_input::FileInputStateWrapper>(), "AzFileInputStateWrapper"), (Layout::new::<AzFileInputStateWrapper>(), "AzFileInputStateWrapper"));
        assert_eq!((Layout::new::<azul_layout::widgets::file_input::FileInputState>(), "AzFileInputState"), (Layout::new::<AzFileInputState>(), "AzFileInputState"));
        assert_eq!((Layout::new::<azul_layout::widgets::file_input::FileInputOnPathChange>(), "AzFileInputOnPathChange"), (Layout::new::<AzFileInputOnPathChange>(), "AzFileInputOnPathChange"));
        assert_eq!((Layout::new::<azul_layout::widgets::file_input::FileInputOnPathChangeCallback>(), "AzFileInputOnPathChangeCallback"), (Layout::new::<AzFileInputOnPathChangeCallback>(), "AzFileInputOnPathChangeCallback"));
        assert_eq!((Layout::new::<azul_layout::widgets::check_box::CheckBox>(), "AzCheckBox"), (Layout::new::<AzCheckBox>(), "AzCheckBox"));
        assert_eq!((Layout::new::<azul_layout::widgets::check_box::CheckBoxStateWrapper>(), "AzCheckBoxStateWrapper"), (Layout::new::<AzCheckBoxStateWrapper>(), "AzCheckBoxStateWrapper"));
        assert_eq!((Layout::new::<azul_layout::widgets::check_box::CheckBoxOnToggle>(), "AzCheckBoxOnToggle"), (Layout::new::<AzCheckBoxOnToggle>(), "AzCheckBoxOnToggle"));
        assert_eq!((Layout::new::<azul_layout::widgets::check_box::CheckBoxState>(), "AzCheckBoxState"), (Layout::new::<AzCheckBoxState>(), "AzCheckBoxState"));
        assert_eq!((Layout::new::<azul_layout::widgets::color_input::ColorInput>(), "AzColorInput"), (Layout::new::<AzColorInput>(), "AzColorInput"));
        assert_eq!((Layout::new::<azul_layout::widgets::color_input::ColorInputStateWrapper>(), "AzColorInputStateWrapper"), (Layout::new::<AzColorInputStateWrapper>(), "AzColorInputStateWrapper"));
        assert_eq!((Layout::new::<azul_layout::widgets::color_input::ColorInputState>(), "AzColorInputState"), (Layout::new::<AzColorInputState>(), "AzColorInputState"));
        assert_eq!((Layout::new::<azul_layout::widgets::color_input::ColorInputOnValueChange>(), "AzColorInputOnValueChange"), (Layout::new::<AzColorInputOnValueChange>(), "AzColorInputOnValueChange"));
        assert_eq!((Layout::new::<azul_layout::widgets::color_input::ColorInputOnValueChangeCallback>(), "AzColorInputOnValueChangeCallback"), (Layout::new::<AzColorInputOnValueChangeCallback>(), "AzColorInputOnValueChangeCallback"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::TextInput>(), "AzTextInput"), (Layout::new::<AzTextInput>(), "AzTextInput"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::TextInputStateWrapper>(), "AzTextInputStateWrapper"), (Layout::new::<AzTextInputStateWrapper>(), "AzTextInputStateWrapper"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::TextInputState>(), "AzTextInputState"), (Layout::new::<AzTextInputState>(), "AzTextInputState"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::TextInputSelection>(), "AzTextInputSelection"), (Layout::new::<AzTextInputSelection>(), "AzTextInputSelection"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::TextInputSelectionRange>(), "AzTextInputSelectionRange"), (Layout::new::<AzTextInputSelectionRange>(), "AzTextInputSelectionRange"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::TextInputOnTextInput>(), "AzTextInputOnTextInput"), (Layout::new::<AzTextInputOnTextInput>(), "AzTextInputOnTextInput"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::TextInputOnTextInputCallback>(), "AzTextInputOnTextInputCallback"), (Layout::new::<AzTextInputOnTextInputCallback>(), "AzTextInputOnTextInputCallback"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::TextInputOnVirtualKeyDown>(), "AzTextInputOnVirtualKeyDown"), (Layout::new::<AzTextInputOnVirtualKeyDown>(), "AzTextInputOnVirtualKeyDown"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::TextInputOnVirtualKeyDownCallback>(), "AzTextInputOnVirtualKeyDownCallback"), (Layout::new::<AzTextInputOnVirtualKeyDownCallback>(), "AzTextInputOnVirtualKeyDownCallback"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::TextInputOnFocusLost>(), "AzTextInputOnFocusLost"), (Layout::new::<AzTextInputOnFocusLost>(), "AzTextInputOnFocusLost"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::TextInputOnFocusLostCallback>(), "AzTextInputOnFocusLostCallback"), (Layout::new::<AzTextInputOnFocusLostCallback>(), "AzTextInputOnFocusLostCallback"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::OnTextInputReturn>(), "AzOnTextInputReturn"), (Layout::new::<AzOnTextInputReturn>(), "AzOnTextInputReturn"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::TextInputValid>(), "AzTextInputValid"), (Layout::new::<AzTextInputValid>(), "AzTextInputValid"));
        assert_eq!((Layout::new::<azul_layout::widgets::number_input::NumberInput>(), "AzNumberInput"), (Layout::new::<AzNumberInput>(), "AzNumberInput"));
        assert_eq!((Layout::new::<azul_layout::widgets::number_input::NumberInputStateWrapper>(), "AzNumberInputStateWrapper"), (Layout::new::<AzNumberInputStateWrapper>(), "AzNumberInputStateWrapper"));
        assert_eq!((Layout::new::<azul_layout::widgets::number_input::NumberInputState>(), "AzNumberInputState"), (Layout::new::<AzNumberInputState>(), "AzNumberInputState"));
        assert_eq!((Layout::new::<azul_layout::widgets::number_input::NumberInputOnValueChange>(), "AzNumberInputOnValueChange"), (Layout::new::<AzNumberInputOnValueChange>(), "AzNumberInputOnValueChange"));
        assert_eq!((Layout::new::<azul_layout::widgets::number_input::NumberInputOnValueChangeCallback>(), "AzNumberInputOnValueChangeCallback"), (Layout::new::<AzNumberInputOnValueChangeCallback>(), "AzNumberInputOnValueChangeCallback"));
        assert_eq!((Layout::new::<azul_layout::widgets::number_input::NumberInputOnFocusLost>(), "AzNumberInputOnFocusLost"), (Layout::new::<AzNumberInputOnFocusLost>(), "AzNumberInputOnFocusLost"));
        assert_eq!((Layout::new::<azul_layout::widgets::number_input::NumberInputOnFocusLostCallback>(), "AzNumberInputOnFocusLostCallback"), (Layout::new::<AzNumberInputOnFocusLostCallback>(), "AzNumberInputOnFocusLostCallback"));
        assert_eq!((Layout::new::<azul_layout::widgets::progressbar::ProgressBar>(), "AzProgressBar"), (Layout::new::<AzProgressBar>(), "AzProgressBar"));
        assert_eq!((Layout::new::<azul_layout::widgets::progressbar::ProgressBarState>(), "AzProgressBarState"), (Layout::new::<AzProgressBarState>(), "AzProgressBarState"));
        assert_eq!((Layout::new::<azul_layout::widgets::tabs::TabHeader>(), "AzTabHeader"), (Layout::new::<AzTabHeader>(), "AzTabHeader"));
        assert_eq!((Layout::new::<azul_layout::widgets::tabs::TabOnClick>(), "AzTabOnClick"), (Layout::new::<AzTabOnClick>(), "AzTabOnClick"));
        assert_eq!((Layout::new::<azul_layout::widgets::frame::Frame>(), "AzFrame"), (Layout::new::<AzFrame>(), "AzFrame"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::ListView>(), "AzListView"), (Layout::new::<AzListView>(), "AzListView"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::ListViewRow>(), "AzListViewRow"), (Layout::new::<AzListViewRow>(), "AzListViewRow"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::ListViewOnLazyLoadScroll>(), "AzListViewOnLazyLoadScroll"), (Layout::new::<AzListViewOnLazyLoadScroll>(), "AzListViewOnLazyLoadScroll"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::ListViewOnColumnClick>(), "AzListViewOnColumnClick"), (Layout::new::<AzListViewOnColumnClick>(), "AzListViewOnColumnClick"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::ListViewOnRowClick>(), "AzListViewOnRowClick"), (Layout::new::<AzListViewOnRowClick>(), "AzListViewOnRowClick"));
        assert_eq!((Layout::new::<azul_core::dom::IFrameNode>(), "AzIFrameNode"), (Layout::new::<AzIFrameNode>(), "AzIFrameNode"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::ListViewState>(), "AzListViewState"), (Layout::new::<AzListViewState>(), "AzListViewState"));
        assert_eq!((Layout::new::<azul_layout::widgets::tabs::TabHeaderState>(), "AzTabHeaderState"), (Layout::new::<AzTabHeaderState>(), "AzTabHeaderState"));
        assert_eq!((Layout::new::<azul_core::gl::Texture>(), "AzTexture"), (Layout::new::<AzTexture>(), "AzTexture"));
        assert_eq!((Layout::new::<azul_core::gl::GlVoidPtrConst>(), "AzGlVoidPtrConst"), (Layout::new::<AzGlVoidPtrConst>(), "AzGlVoidPtrConst"));
        assert_eq!((Layout::new::<azul_core::gl::GlVoidPtrMut>(), "AzGlVoidPtrMut"), (Layout::new::<AzGlVoidPtrMut>(), "AzGlVoidPtrMut"));
        assert_eq!((Layout::new::<azul_core::gl::TextureFlags>(), "AzTextureFlags"), (Layout::new::<AzTextureFlags>(), "AzTextureFlags"));
        assert_eq!((Layout::new::<azul_core::gl::GlShaderPrecisionFormatReturn>(), "AzGlShaderPrecisionFormatReturn"), (Layout::new::<AzGlShaderPrecisionFormatReturn>(), "AzGlShaderPrecisionFormatReturn"));
        assert_eq!((Layout::new::<azul_core::gl::GlContextPtr>(), "AzGlContextPtr"), (Layout::new::<AzGlContextPtr>(), "AzGlContextPtr"));
        assert_eq!((Layout::new::<azul_core::gl::GetProgramBinaryReturn>(), "AzGetProgramBinaryReturn"), (Layout::new::<AzGetProgramBinaryReturn>(), "AzGetProgramBinaryReturn"));
        assert_eq!((Layout::new::<azul_core::gl::GetActiveAttribReturn>(), "AzGetActiveAttribReturn"), (Layout::new::<AzGetActiveAttribReturn>(), "AzGetActiveAttribReturn"));
        assert_eq!((Layout::new::<azul_core::gl::GLsyncPtr>(), "AzGLsyncPtr"), (Layout::new::<AzGLsyncPtr>(), "AzGLsyncPtr"));
        assert_eq!((Layout::new::<azul_core::gl::GetActiveUniformReturn>(), "AzGetActiveUniformReturn"), (Layout::new::<AzGetActiveUniformReturn>(), "AzGetActiveUniformReturn"));
        assert_eq!((Layout::new::<azul_core::svg::SvgVertex>(), "AzSvgVertex"), (Layout::new::<AzSvgVertex>(), "AzSvgVertex"));
        assert_eq!((Layout::new::<azul_core::gl::VertexArrayObject>(), "AzVertexArrayObject"), (Layout::new::<AzVertexArrayObject>(), "AzVertexArrayObject"));
        assert_eq!((Layout::new::<azul_core::gl::IndexBufferFormat>(), "AzIndexBufferFormat"), (Layout::new::<AzIndexBufferFormat>(), "AzIndexBufferFormat"));
        assert_eq!((Layout::new::<azul_core::gl::VertexBuffer>(), "AzVertexBuffer"), (Layout::new::<AzVertexBuffer>(), "AzVertexBuffer"));
        assert_eq!((Layout::new::<azul_core::gl::GlType>(), "AzGlType"), (Layout::new::<AzGlType>(), "AzGlType"));
        assert_eq!((Layout::new::<azul_core::resources::ImageRef>(), "AzImageRef"), (Layout::new::<AzImageRef>(), "AzImageRef"));
        assert_eq!((Layout::new::<azul_core::resources::RawImage>(), "AzRawImage"), (Layout::new::<AzRawImage>(), "AzRawImage"));
        assert_eq!((Layout::new::<azul_core::resources::ImageMask>(), "AzImageMask"), (Layout::new::<AzImageMask>(), "AzImageMask"));
        assert_eq!((Layout::new::<azul_core::resources::RawImageFormat>(), "AzRawImageFormat"), (Layout::new::<AzRawImageFormat>(), "AzRawImageFormat"));
        assert_eq!((Layout::new::<azul_core::resources::RawImageData>(), "AzRawImageData"), (Layout::new::<AzRawImageData>(), "AzRawImageData"));
        assert_eq!((Layout::new::<azul_core::svg::ImageRendering>(), "AzImageRendering"), (Layout::new::<AzImageRendering>(), "AzImageRendering"));
        assert_eq!((Layout::new::<azul_css::props::basic::font::FontMetrics>(), "AzFontMetrics"), (Layout::new::<AzFontMetrics>(), "AzFontMetrics"));
        assert_eq!((Layout::new::<azul_css::props::basic::font::FontRef>(), "AzFontRef"), (Layout::new::<AzFontRef>(), "AzFontRef"));
        assert_eq!((Layout::new::<azul_core::resources::LoadedFontSource>(), "AzLoadedFontSource"), (Layout::new::<AzLoadedFontSource>(), "AzLoadedFontSource"));
        assert_eq!((Layout::new::<azul_core::svg::Svg>(), "AzSvg"), (Layout::new::<AzSvg>(), "AzSvg"));
        assert_eq!((Layout::new::<azul_core::svg::SvgMultiPolygon>(), "AzSvgMultiPolygon"), (Layout::new::<AzSvgMultiPolygon>(), "AzSvgMultiPolygon"));
        assert_eq!((Layout::new::<azul_core::svg::SvgNode>(), "AzSvgNode"), (Layout::new::<AzSvgNode>(), "AzSvgNode"));
        assert_eq!((Layout::new::<azul_core::svg::SvgCircle>(), "AzSvgCircle"), (Layout::new::<AzSvgCircle>(), "AzSvgCircle"));
        assert_eq!((Layout::new::<azul_core::svg::SvgPath>(), "AzSvgPath"), (Layout::new::<AzSvgPath>(), "AzSvgPath"));
        assert_eq!((Layout::new::<azul_core::svg::SvgPathElement>(), "AzSvgPathElement"), (Layout::new::<AzSvgPathElement>(), "AzSvgPathElement"));
        assert_eq!((Layout::new::<azul_css::props::basic::animation::SvgPoint>(), "AzSvgPoint"), (Layout::new::<AzSvgPoint>(), "AzSvgPoint"));
        assert_eq!((Layout::new::<azul_css::props::basic::animation::SvgVector>(), "AzSvgVector"), (Layout::new::<AzSvgVector>(), "AzSvgVector"));
        assert_eq!((Layout::new::<azul_core::svg::SvgLine>(), "AzSvgLine"), (Layout::new::<AzSvgLine>(), "AzSvgLine"));
        assert_eq!((Layout::new::<azul_css::props::basic::animation::SvgQuadraticCurve>(), "AzSvgQuadraticCurve"), (Layout::new::<AzSvgQuadraticCurve>(), "AzSvgQuadraticCurve"));
        assert_eq!((Layout::new::<azul_css::props::basic::animation::SvgCubicCurve>(), "AzSvgCubicCurve"), (Layout::new::<AzSvgCubicCurve>(), "AzSvgCubicCurve"));
        assert_eq!((Layout::new::<azul_css::props::basic::animation::SvgRect>(), "AzSvgRect"), (Layout::new::<AzSvgRect>(), "AzSvgRect"));
        assert_eq!((Layout::new::<azul_core::svg::TessellatedSvgNode>(), "AzTessellatedSvgNode"), (Layout::new::<AzTessellatedSvgNode>(), "AzTessellatedSvgNode"));
        assert_eq!((Layout::new::<azul_core::svg::SvgDashPattern>(), "AzSvgDashPattern"), (Layout::new::<AzSvgDashPattern>(), "AzSvgDashPattern"));
        assert_eq!((Layout::new::<azul_core::svg::SvgFitTo>(), "AzSvgFitTo"), (Layout::new::<AzSvgFitTo>(), "AzSvgFitTo"));
        assert_eq!((Layout::new::<azul_core::svg::SvgFillRule>(), "AzSvgFillRule"), (Layout::new::<AzSvgFillRule>(), "AzSvgFillRule"));
        assert_eq!((Layout::new::<azul_core::svg::SvgStrokeStyle>(), "AzSvgStrokeStyle"), (Layout::new::<AzSvgStrokeStyle>(), "AzSvgStrokeStyle"));
        assert_eq!((Layout::new::<azul_core::svg::SvgLineJoin>(), "AzSvgLineJoin"), (Layout::new::<AzSvgLineJoin>(), "AzSvgLineJoin"));
        assert_eq!((Layout::new::<azul_core::svg::SvgLineCap>(), "AzSvgLineCap"), (Layout::new::<AzSvgLineCap>(), "AzSvgLineCap"));
        assert_eq!((Layout::new::<azul_css::css::CssPathPseudoSelector>(), "AzCssPathPseudoSelector"), (Layout::new::<AzCssPathPseudoSelector>(), "AzCssPathPseudoSelector"));
        assert_eq!((Layout::new::<azul_core::geom::LogicalRect>(), "AzLogicalRect"), (Layout::new::<AzLogicalRect>(), "AzLogicalRect"));
        assert_eq!((Layout::new::<azul_css::css::CssPathSelector>(), "AzCssPathSelector"), (Layout::new::<AzCssPathSelector>(), "AzCssPathSelector"));
        assert_eq!((Layout::new::<azul_css::css::CssPath>(), "AzCssPath"), (Layout::new::<AzCssPath>(), "AzCssPath"));
        assert_eq!((Layout::new::<azul_core::svg::TessellatedGPUSvgNode>(), "AzTessellatedGPUSvgNode"), (Layout::new::<AzTessellatedGPUSvgNode>(), "AzTessellatedGPUSvgNode"));
        assert_eq!((Layout::new::<azul_core::svg::TessellatedColoredGPUSvgNode>(), "AzTessellatedColoredGPUSvgNode"), (Layout::new::<AzTessellatedColoredGPUSvgNode>(), "AzTessellatedColoredGPUSvgNode"));
        assert_eq!((Layout::new::<azul_css::shape::ShapeCircle>(), "AzShapeCircle"), (Layout::new::<AzShapeCircle>(), "AzShapeCircle"));
        assert_eq!((Layout::new::<azul_css::shape::ShapePolygon>(), "AzShapePolygon"), (Layout::new::<AzShapePolygon>(), "AzShapePolygon"));
        assert_eq!((Layout::new::<azul_core::xml::Xml>(), "AzXml"), (Layout::new::<AzXml>(), "AzXml"));
        assert_eq!((Layout::new::<azul_core::task::Instant>(), "AzInstant"), (Layout::new::<AzInstant>(), "AzInstant"));
        assert_eq!((Layout::new::<azul_core::task::SystemTickDiff>(), "AzSystemTickDiff"), (Layout::new::<AzSystemTickDiff>(), "AzSystemTickDiff"));
        assert_eq!((Layout::new::<azul_core::task::SystemTick>(), "AzSystemTick"), (Layout::new::<AzSystemTick>(), "AzSystemTick"));
        assert_eq!((Layout::new::<azul_core::task::Duration>(), "AzDuration"), (Layout::new::<AzDuration>(), "AzDuration"));
        assert_eq!((Layout::new::<azul_core::task::SystemTimeDiff>(), "AzSystemTimeDiff"), (Layout::new::<AzSystemTimeDiff>(), "AzSystemTimeDiff"));
        assert_eq!((Layout::new::<azul_core::task::TimerId>(), "AzTimerId"), (Layout::new::<AzTimerId>(), "AzTimerId"));
        assert_eq!((Layout::new::<azul_core::task::InstantPtr>(), "AzInstantPtr"), (Layout::new::<AzInstantPtr>(), "AzInstantPtr"));
        assert_eq!((Layout::new::<azul_css::props::basic::time::CssDuration>(), "AzCssDuration"), (Layout::new::<AzCssDuration>(), "AzCssDuration"));
        assert_eq!((Layout::new::<azul_css::corety::AzString>(), "AzString"), (Layout::new::<AzString>(), "AzString"));
        assert_eq!((Layout::new::<azul_core::gl::Refstr>(), "AzRefstr"), (Layout::new::<AzRefstr>(), "AzRefstr"));
        assert_eq!((Layout::new::<azul_core::window::AzStringPair>(), "AzStringPair"), (Layout::new::<AzStringPair>(), "AzStringPair"));
        assert_eq!((Layout::new::<azul_css::props::style::content::StringSet>(), "AzStringSet"), (Layout::new::<AzStringSet>(), "AzStringSet"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::ListViewRowVec>(), "AzListViewRowVec"), (Layout::new::<AzListViewRowVec>(), "AzListViewRowVec"));
        assert_eq!((Layout::new::<azul_css::props::style::filter::StyleFilterVec>(), "AzStyleFilterVec"), (Layout::new::<AzStyleFilterVec>(), "AzStyleFilterVec"));
        assert_eq!((Layout::new::<azul_core::dom::AccessibilityStateVec>(), "AzAccessibilityStateVec"), (Layout::new::<AzAccessibilityStateVec>(), "AzAccessibilityStateVec"));
        assert_eq!((Layout::new::<azul_core::menu::MenuItemVec>(), "AzMenuItemVec"), (Layout::new::<AzMenuItemVec>(), "AzMenuItemVec"));
        assert_eq!((Layout::new::<azul_css::props::basic::font::StyleFontFamilyVec>(), "AzStyleFontFamilyVec"), (Layout::new::<AzStyleFontFamilyVec>(), "AzStyleFontFamilyVec"));
        assert_eq!((Layout::new::<azul_core::dom::DomVec>(), "AzDomVec"), (Layout::new::<AzDomVec>(), "AzDomVec"));
        assert_eq!((Layout::new::<azul_core::dom::IdOrClassVec>(), "AzIdOrClassVec"), (Layout::new::<AzIdOrClassVec>(), "AzIdOrClassVec"));
        assert_eq!((Layout::new::<azul_core::dom::NodeDataInlineCssPropertyVec>(), "AzNodeDataInlineCssPropertyVec"), (Layout::new::<AzNodeDataInlineCssPropertyVec>(), "AzNodeDataInlineCssPropertyVec"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundContentVec>(), "AzStyleBackgroundContentVec"), (Layout::new::<AzStyleBackgroundContentVec>(), "AzStyleBackgroundContentVec"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundPositionVec>(), "AzStyleBackgroundPositionVec"), (Layout::new::<AzStyleBackgroundPositionVec>(), "AzStyleBackgroundPositionVec"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundRepeatVec>(), "AzStyleBackgroundRepeatVec"), (Layout::new::<AzStyleBackgroundRepeatVec>(), "AzStyleBackgroundRepeatVec"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundSizeVec>(), "AzStyleBackgroundSizeVec"), (Layout::new::<AzStyleBackgroundSizeVec>(), "AzStyleBackgroundSizeVec"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformVec>(), "AzStyleTransformVec"), (Layout::new::<AzStyleTransformVec>(), "AzStyleTransformVec"));
        assert_eq!((Layout::new::<azul_core::svg::SvgMultiPolygonVec>(), "AzSvgMultiPolygonVec"), (Layout::new::<AzSvgMultiPolygonVec>(), "AzSvgMultiPolygonVec"));
        assert_eq!((Layout::new::<azul_core::svg::SvgSimpleNodeVec>(), "AzSvgSimpleNodeVec"), (Layout::new::<AzSvgSimpleNodeVec>(), "AzSvgSimpleNodeVec"));
        assert_eq!((Layout::new::<azul_core::svg::SvgPathVec>(), "AzSvgPathVec"), (Layout::new::<AzSvgPathVec>(), "AzSvgPathVec"));
        assert_eq!((Layout::new::<azul_core::svg::SvgPathElementVec>(), "AzSvgPathElementVec"), (Layout::new::<AzSvgPathElementVec>(), "AzSvgPathElementVec"));
        assert_eq!((Layout::new::<azul_core::svg::SvgVertexVec>(), "AzSvgVertexVec"), (Layout::new::<AzSvgVertexVec>(), "AzSvgVertexVec"));
        assert_eq!((Layout::new::<azul_css::corety::U32Vec>(), "AzU32Vec"), (Layout::new::<AzU32Vec>(), "AzU32Vec"));
        assert_eq!((Layout::new::<azul_core::window::VirtualKeyCodeVec>(), "AzVirtualKeyCodeVec"), (Layout::new::<AzVirtualKeyCodeVec>(), "AzVirtualKeyCodeVec"));
        assert_eq!((Layout::new::<azul_core::style::CascadeInfoVec>(), "AzCascadeInfoVec"), (Layout::new::<AzCascadeInfoVec>(), "AzCascadeInfoVec"));
        assert_eq!((Layout::new::<azul_css::css::CssDeclarationVec>(), "AzCssDeclarationVec"), (Layout::new::<AzCssDeclarationVec>(), "AzCssDeclarationVec"));
        assert_eq!((Layout::new::<azul_css::css::CssPathSelectorVec>(), "AzCssPathSelectorVec"), (Layout::new::<AzCssPathSelectorVec>(), "AzCssPathSelectorVec"));
        assert_eq!((Layout::new::<azul_css::css::StylesheetVec>(), "AzStylesheetVec"), (Layout::new::<AzStylesheetVec>(), "AzStylesheetVec"));
        assert_eq!((Layout::new::<azul_css::css::CssRuleBlockVec>(), "AzCssRuleBlockVec"), (Layout::new::<AzCssRuleBlockVec>(), "AzCssRuleBlockVec"));
        assert_eq!((Layout::new::<azul_css::corety::U16Vec>(), "AzU16Vec"), (Layout::new::<AzU16Vec>(), "AzU16Vec"));
        assert_eq!((Layout::new::<azul_css::corety::F32Vec>(), "AzF32Vec"), (Layout::new::<AzF32Vec>(), "AzF32Vec"));
        assert_eq!((Layout::new::<azul_css::corety::U8Vec>(), "AzU8Vec"), (Layout::new::<AzU8Vec>(), "AzU8Vec"));
        assert_eq!((Layout::new::<azul_core::gl::GLuintVec>(), "AzGLuintVec"), (Layout::new::<AzGLuintVec>(), "AzGLuintVec"));
        assert_eq!((Layout::new::<azul_core::gl::GLintVec>(), "AzGLintVec"), (Layout::new::<AzGLintVec>(), "AzGLintVec"));
        assert_eq!((Layout::new::<azul_css::corety::StringVec>(), "AzStringVec"), (Layout::new::<AzStringVec>(), "AzStringVec"));
        assert_eq!((Layout::new::<azul_core::window::StringPairVec>(), "AzStringPairVec"), (Layout::new::<AzStringPairVec>(), "AzStringPairVec"));
        assert_eq!((Layout::new::<azul_css::props::style::background::NormalizedLinearColorStopVec>(), "AzNormalizedLinearColorStopVec"), (Layout::new::<AzNormalizedLinearColorStopVec>(), "AzNormalizedLinearColorStopVec"));
        assert_eq!((Layout::new::<azul_css::props::style::background::NormalizedRadialColorStopVec>(), "AzNormalizedRadialColorStopVec"), (Layout::new::<AzNormalizedRadialColorStopVec>(), "AzNormalizedRadialColorStopVec"));
        assert_eq!((Layout::new::<azul_core::styled_dom::NodeIdVec>(), "AzNodeIdVec"), (Layout::new::<AzNodeIdVec>(), "AzNodeIdVec"));
        assert_eq!((Layout::new::<azul_core::styled_dom::NodeHierarchyItemVec>(), "AzNodeHierarchyItemVec"), (Layout::new::<AzNodeHierarchyItemVec>(), "AzNodeHierarchyItemVec"));
        assert_eq!((Layout::new::<azul_core::styled_dom::StyledNodeVec>(), "AzStyledNodeVec"), (Layout::new::<AzStyledNodeVec>(), "AzStyledNodeVec"));
        assert_eq!((Layout::new::<azul_core::styled_dom::TagIdToNodeIdMappingVec>(), "AzTagIdToNodeIdMappingVec"), (Layout::new::<AzTagIdToNodeIdMappingVec>(), "AzTagIdToNodeIdMappingVec"));
        assert_eq!((Layout::new::<azul_core::styled_dom::ParentWithNodeDepthVec>(), "AzParentWithNodeDepthVec"), (Layout::new::<AzParentWithNodeDepthVec>(), "AzParentWithNodeDepthVec"));
        assert_eq!((Layout::new::<azul_core::dom::NodeDataVec>(), "AzNodeDataVec"), (Layout::new::<AzNodeDataVec>(), "AzNodeDataVec"));
        assert_eq!((Layout::new::<azul_core::dom::AttributeVec>(), "AzAttributeVec"), (Layout::new::<AzAttributeVec>(), "AzAttributeVec"));
        assert_eq!((Layout::new::<azul_core::callbacks::CoreCallbackDataVec>(), "AzCoreCallbackDataVec"), (Layout::new::<AzCoreCallbackDataVec>(), "AzCoreCallbackDataVec"));
        assert_eq!((Layout::new::<azul_core::dom::AccessibilityActionVec>(), "AzAccessibilityActionVec"), (Layout::new::<AzAccessibilityActionVec>(), "AzAccessibilityActionVec"));
        assert_eq!((Layout::new::<azul_core::xml::XmlNodeChildVec>(), "AzXmlNodeChildVec"), (Layout::new::<AzXmlNodeChildVec>(), "AzXmlNodeChildVec"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::GridTrackSizingVec>(), "AzGridTrackSizingVec"), (Layout::new::<AzGridTrackSizingVec>(), "AzGridTrackSizingVec"));
        assert_eq!((Layout::new::<azul_core::gl::GLbooleanVecRefMut>(), "AzGLbooleanVecRefMut"), (Layout::new::<AzGLbooleanVecRefMut>(), "AzGLbooleanVecRefMut"));
        assert_eq!((Layout::new::<azul_core::gl::RefstrVecRef>(), "AzRefstrVecRef"), (Layout::new::<AzRefstrVecRef>(), "AzRefstrVecRef"));
        assert_eq!((Layout::new::<azul_core::gl::GLfloatVecRefMut>(), "AzGLfloatVecRefMut"), (Layout::new::<AzGLfloatVecRefMut>(), "AzGLfloatVecRefMut"));
        assert_eq!((Layout::new::<azul_core::gl::U8VecRefMut>(), "AzU8VecRefMut"), (Layout::new::<AzU8VecRefMut>(), "AzU8VecRefMut"));
        assert_eq!((Layout::new::<azul_core::svg::TessellatedSvgNodeVecRef>(), "AzTessellatedSvgNodeVecRef"), (Layout::new::<AzTessellatedSvgNodeVecRef>(), "AzTessellatedSvgNodeVecRef"));
        assert_eq!((Layout::new::<azul_core::gl::F32VecRef>(), "AzF32VecRef"), (Layout::new::<AzF32VecRef>(), "AzF32VecRef"));
        assert_eq!((Layout::new::<azul_core::gl::GLuintVecRef>(), "AzGLuintVecRef"), (Layout::new::<AzGLuintVecRef>(), "AzGLuintVecRef"));
        assert_eq!((Layout::new::<azul_core::gl::I32VecRef>(), "AzI32VecRef"), (Layout::new::<AzI32VecRef>(), "AzI32VecRef"));
        assert_eq!((Layout::new::<azul_core::gl::U8VecRef>(), "AzU8VecRef"), (Layout::new::<AzU8VecRef>(), "AzU8VecRef"));
        assert_eq!((Layout::new::<azul_core::gl::GLintVecRefMut>(), "AzGLintVecRefMut"), (Layout::new::<AzGLintVecRefMut>(), "AzGLintVecRefMut"));
        assert_eq!((Layout::new::<azul_core::gl::GLenumVecRef>(), "AzGLenumVecRef"), (Layout::new::<AzGLenumVecRef>(), "AzGLenumVecRef"));
        assert_eq!((Layout::new::<azul_core::gl::GLint64VecRefMut>(), "AzGLint64VecRefMut"), (Layout::new::<AzGLint64VecRefMut>(), "AzGLint64VecRefMut"));
        assert_eq!((Layout::new::<azul_core::gl::OptionU8VecRef>(), "AzOptionU8VecRef"), (Layout::new::<AzOptionU8VecRef>(), "AzOptionU8VecRef"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundContentVecDestructorType>(), "AzStyleBackgroundContentVecDestructorType"), (Layout::new::<AzStyleBackgroundContentVecDestructorType>(), "AzStyleBackgroundContentVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::svg::SvgPathVecDestructor>(), "AzSvgPathVecDestructor"), (Layout::new::<AzSvgPathVecDestructor>(), "AzSvgPathVecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundRepeatVecDestructorType>(), "AzStyleBackgroundRepeatVecDestructorType"), (Layout::new::<AzStyleBackgroundRepeatVecDestructorType>(), "AzStyleBackgroundRepeatVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::props::style::filter::StyleFilterVecDestructor>(), "AzStyleFilterVecDestructor"), (Layout::new::<AzStyleFilterVecDestructor>(), "AzStyleFilterVecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformVecDestructor>(), "AzStyleTransformVecDestructor"), (Layout::new::<AzStyleTransformVecDestructor>(), "AzStyleTransformVecDestructor"));
        assert_eq!((Layout::new::<azul_core::menu::MenuItemVecDestructorType>(), "AzMenuItemVecDestructorType"), (Layout::new::<AzMenuItemVecDestructorType>(), "AzMenuItemVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::dom::AccessibilityStateVecDestructorType>(), "AzAccessibilityStateVecDestructorType"), (Layout::new::<AzAccessibilityStateVecDestructorType>(), "AzAccessibilityStateVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::dom::NodeDataInlineCssPropertyVecDestructorType>(), "AzNodeDataInlineCssPropertyVecDestructorType"), (Layout::new::<AzNodeDataInlineCssPropertyVecDestructorType>(), "AzNodeDataInlineCssPropertyVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::props::style::background::NormalizedLinearColorStopVecDestructorType>(), "AzNormalizedLinearColorStopVecDestructorType"), (Layout::new::<AzNormalizedLinearColorStopVecDestructorType>(), "AzNormalizedLinearColorStopVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::corety::F32VecDestructorType>(), "AzF32VecDestructorType"), (Layout::new::<AzF32VecDestructorType>(), "AzF32VecDestructorType"));
        assert_eq!((Layout::new::<azul_core::gl::GLuintVecDestructor>(), "AzGLuintVecDestructor"), (Layout::new::<AzGLuintVecDestructor>(), "AzGLuintVecDestructor"));
        assert_eq!((Layout::new::<azul_core::xml::XmlNodeChildVecDestructor>(), "AzXmlNodeChildVecDestructor"), (Layout::new::<AzXmlNodeChildVecDestructor>(), "AzXmlNodeChildVecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundSizeVecDestructorType>(), "AzStyleBackgroundSizeVecDestructorType"), (Layout::new::<AzStyleBackgroundSizeVecDestructorType>(), "AzStyleBackgroundSizeVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundContentVecDestructor>(), "AzStyleBackgroundContentVecDestructor"), (Layout::new::<AzStyleBackgroundContentVecDestructor>(), "AzStyleBackgroundContentVecDestructor"));
        assert_eq!((Layout::new::<azul_css::corety::StringVecDestructorType>(), "AzStringVecDestructorType"), (Layout::new::<AzStringVecDestructorType>(), "AzStringVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::style::CascadeInfoVecDestructor>(), "AzCascadeInfoVecDestructor"), (Layout::new::<AzCascadeInfoVecDestructor>(), "AzCascadeInfoVecDestructor"));
        assert_eq!((Layout::new::<azul_core::dom::DomVecDestructorType>(), "AzDomVecDestructorType"), (Layout::new::<AzDomVecDestructorType>(), "AzDomVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::dom::AccessibilityStateVecDestructor>(), "AzAccessibilityStateVecDestructor"), (Layout::new::<AzAccessibilityStateVecDestructor>(), "AzAccessibilityStateVecDestructor"));
        assert_eq!((Layout::new::<azul_core::window::StringPairVecDestructorType>(), "AzStringPairVecDestructorType"), (Layout::new::<AzStringPairVecDestructorType>(), "AzStringPairVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::dom::DomVecDestructor>(), "AzDomVecDestructor"), (Layout::new::<AzDomVecDestructor>(), "AzDomVecDestructor"));
        assert_eq!((Layout::new::<azul_css::corety::StringVecDestructor>(), "AzStringVecDestructor"), (Layout::new::<AzStringVecDestructor>(), "AzStringVecDestructor"));
        assert_eq!((Layout::new::<azul_css::css::CssRuleBlockVecDestructorType>(), "AzCssRuleBlockVecDestructorType"), (Layout::new::<AzCssRuleBlockVecDestructorType>(), "AzCssRuleBlockVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::dom::NodeDataVecDestructor>(), "AzNodeDataVecDestructor"), (Layout::new::<AzNodeDataVecDestructor>(), "AzNodeDataVecDestructor"));
        assert_eq!((Layout::new::<azul_core::menu::MenuItemVecDestructor>(), "AzMenuItemVecDestructor"), (Layout::new::<AzMenuItemVecDestructor>(), "AzMenuItemVecDestructor"));
        assert_eq!((Layout::new::<azul_core::dom::AttributeVecDestructorType>(), "AzAttributeVecDestructorType"), (Layout::new::<AzAttributeVecDestructorType>(), "AzAttributeVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::svg::SvgMultiPolygonVecDestructor>(), "AzSvgMultiPolygonVecDestructor"), (Layout::new::<AzSvgMultiPolygonVecDestructor>(), "AzSvgMultiPolygonVecDestructor"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::ListViewRowVecDestructor>(), "AzListViewRowVecDestructor"), (Layout::new::<AzListViewRowVecDestructor>(), "AzListViewRowVecDestructor"));
        assert_eq!((Layout::new::<azul_core::styled_dom::NodeIdVecDestructorType>(), "AzNodeIdVecDestructorType"), (Layout::new::<AzNodeIdVecDestructorType>(), "AzNodeIdVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::props::style::filter::StyleFilterVecDestructorType>(), "AzStyleFilterVecDestructorType"), (Layout::new::<AzStyleFilterVecDestructorType>(), "AzStyleFilterVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::corety::U32VecDestructorType>(), "AzU32VecDestructorType"), (Layout::new::<AzU32VecDestructorType>(), "AzU32VecDestructorType"));
        assert_eq!((Layout::new::<azul_core::svg::SvgVertexVecDestructor>(), "AzSvgVertexVecDestructor"), (Layout::new::<AzSvgVertexVecDestructor>(), "AzSvgVertexVecDestructor"));
        assert_eq!((Layout::new::<azul_css::css::StylesheetVecDestructor>(), "AzStylesheetVecDestructor"), (Layout::new::<AzStylesheetVecDestructor>(), "AzStylesheetVecDestructor"));
        assert_eq!((Layout::new::<azul_css::corety::U32VecDestructor>(), "AzU32VecDestructor"), (Layout::new::<AzU32VecDestructor>(), "AzU32VecDestructor"));
        assert_eq!((Layout::new::<azul_css::css::CssRuleBlockVecDestructor>(), "AzCssRuleBlockVecDestructor"), (Layout::new::<AzCssRuleBlockVecDestructor>(), "AzCssRuleBlockVecDestructor"));
        assert_eq!((Layout::new::<azul_core::styled_dom::ParentWithNodeDepthVecDestructorType>(), "AzParentWithNodeDepthVecDestructorType"), (Layout::new::<AzParentWithNodeDepthVecDestructorType>(), "AzParentWithNodeDepthVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::props::style::background::NormalizedLinearColorStopVecDestructor>(), "AzNormalizedLinearColorStopVecDestructor"), (Layout::new::<AzNormalizedLinearColorStopVecDestructor>(), "AzNormalizedLinearColorStopVecDestructor"));
        assert_eq!((Layout::new::<azul_core::callbacks::CoreCallbackDataVecDestructorType>(), "AzCoreCallbackDataVecDestructorType"), (Layout::new::<AzCoreCallbackDataVecDestructorType>(), "AzCoreCallbackDataVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::props::basic::font::StyleFontFamilyVecDestructor>(), "AzStyleFontFamilyVecDestructor"), (Layout::new::<AzStyleFontFamilyVecDestructor>(), "AzStyleFontFamilyVecDestructor"));
        assert_eq!((Layout::new::<azul_core::style::CascadeInfoVecDestructorType>(), "AzCascadeInfoVecDestructorType"), (Layout::new::<AzCascadeInfoVecDestructorType>(), "AzCascadeInfoVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::corety::U8VecDestructorType>(), "AzU8VecDestructorType"), (Layout::new::<AzU8VecDestructorType>(), "AzU8VecDestructorType"));
        assert_eq!((Layout::new::<azul_core::styled_dom::NodeHierarchyItemVecDestructorType>(), "AzNodeHierarchyItemVecDestructorType"), (Layout::new::<AzNodeHierarchyItemVecDestructorType>(), "AzNodeHierarchyItemVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::css::CssPathSelectorVecDestructor>(), "AzCssPathSelectorVecDestructor"), (Layout::new::<AzCssPathSelectorVecDestructor>(), "AzCssPathSelectorVecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundPositionVecDestructorType>(), "AzStyleBackgroundPositionVecDestructorType"), (Layout::new::<AzStyleBackgroundPositionVecDestructorType>(), "AzStyleBackgroundPositionVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::window::VirtualKeyCodeVecDestructorType>(), "AzVirtualKeyCodeVecDestructorType"), (Layout::new::<AzVirtualKeyCodeVecDestructorType>(), "AzVirtualKeyCodeVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::styled_dom::NodeHierarchyItemVecDestructor>(), "AzNodeHierarchyItemVecDestructor"), (Layout::new::<AzNodeHierarchyItemVecDestructor>(), "AzNodeHierarchyItemVecDestructor"));
        assert_eq!((Layout::new::<azul_core::window::VirtualKeyCodeVecDestructor>(), "AzVirtualKeyCodeVecDestructor"), (Layout::new::<AzVirtualKeyCodeVecDestructor>(), "AzVirtualKeyCodeVecDestructor"));
        assert_eq!((Layout::new::<azul_core::svg::SvgVertexVecDestructorType>(), "AzSvgVertexVecDestructorType"), (Layout::new::<AzSvgVertexVecDestructorType>(), "AzSvgVertexVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::corety::F32VecDestructor>(), "AzF32VecDestructor"), (Layout::new::<AzF32VecDestructor>(), "AzF32VecDestructor"));
        assert_eq!((Layout::new::<azul_core::svg::SvgPathElementVecDestructorType>(), "AzSvgPathElementVecDestructorType"), (Layout::new::<AzSvgPathElementVecDestructorType>(), "AzSvgPathElementVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundRepeatVecDestructor>(), "AzStyleBackgroundRepeatVecDestructor"), (Layout::new::<AzStyleBackgroundRepeatVecDestructor>(), "AzStyleBackgroundRepeatVecDestructor"));
        assert_eq!((Layout::new::<azul_core::dom::AccessibilityActionVecDestructor>(), "AzAccessibilityActionVecDestructor"), (Layout::new::<AzAccessibilityActionVecDestructor>(), "AzAccessibilityActionVecDestructor"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::ListViewRowVecDestructorType>(), "AzListViewRowVecDestructorType"), (Layout::new::<AzListViewRowVecDestructorType>(), "AzListViewRowVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::gl::GLuintVecDestructorType>(), "AzGLuintVecDestructorType"), (Layout::new::<AzGLuintVecDestructorType>(), "AzGLuintVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::props::style::transform::StyleTransformVecDestructorType>(), "AzStyleTransformVecDestructorType"), (Layout::new::<AzStyleTransformVecDestructorType>(), "AzStyleTransformVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::styled_dom::TagIdToNodeIdMappingVecDestructorType>(), "AzTagIdToNodeIdMappingVecDestructorType"), (Layout::new::<AzTagIdToNodeIdMappingVecDestructorType>(), "AzTagIdToNodeIdMappingVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::corety::U16VecDestructor>(), "AzU16VecDestructor"), (Layout::new::<AzU16VecDestructor>(), "AzU16VecDestructor"));
        assert_eq!((Layout::new::<azul_core::styled_dom::TagIdToNodeIdMappingVecDestructor>(), "AzTagIdToNodeIdMappingVecDestructor"), (Layout::new::<AzTagIdToNodeIdMappingVecDestructor>(), "AzTagIdToNodeIdMappingVecDestructor"));
        assert_eq!((Layout::new::<azul_core::styled_dom::NodeIdVecDestructor>(), "AzNodeIdVecDestructor"), (Layout::new::<AzNodeIdVecDestructor>(), "AzNodeIdVecDestructor"));
        assert_eq!((Layout::new::<azul_css::corety::U16VecDestructorType>(), "AzU16VecDestructorType"), (Layout::new::<AzU16VecDestructorType>(), "AzU16VecDestructorType"));
        assert_eq!((Layout::new::<azul_core::svg::SvgSimpleNodeVecDestructorType>(), "AzSvgSimpleNodeVecDestructorType"), (Layout::new::<AzSvgSimpleNodeVecDestructorType>(), "AzSvgSimpleNodeVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::GridTrackSizingVecDestructorType>(), "AzGridTrackSizingVecDestructorType"), (Layout::new::<AzGridTrackSizingVecDestructorType>(), "AzGridTrackSizingVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::css::CssDeclarationVecDestructorType>(), "AzCssDeclarationVecDestructorType"), (Layout::new::<AzCssDeclarationVecDestructorType>(), "AzCssDeclarationVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::styled_dom::ParentWithNodeDepthVecDestructor>(), "AzParentWithNodeDepthVecDestructor"), (Layout::new::<AzParentWithNodeDepthVecDestructor>(), "AzParentWithNodeDepthVecDestructor"));
        assert_eq!((Layout::new::<azul_core::gl::GLintVecDestructor>(), "AzGLintVecDestructor"), (Layout::new::<AzGLintVecDestructor>(), "AzGLintVecDestructor"));
        assert_eq!((Layout::new::<azul_core::dom::NodeDataInlineCssPropertyVecDestructor>(), "AzNodeDataInlineCssPropertyVecDestructor"), (Layout::new::<AzNodeDataInlineCssPropertyVecDestructor>(), "AzNodeDataInlineCssPropertyVecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::style::background::NormalizedRadialColorStopVecDestructorType>(), "AzNormalizedRadialColorStopVecDestructorType"), (Layout::new::<AzNormalizedRadialColorStopVecDestructorType>(), "AzNormalizedRadialColorStopVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::props::style::background::NormalizedRadialColorStopVecDestructor>(), "AzNormalizedRadialColorStopVecDestructor"), (Layout::new::<AzNormalizedRadialColorStopVecDestructor>(), "AzNormalizedRadialColorStopVecDestructor"));
        assert_eq!((Layout::new::<azul_core::styled_dom::StyledNodeVecDestructor>(), "AzStyledNodeVecDestructor"), (Layout::new::<AzStyledNodeVecDestructor>(), "AzStyledNodeVecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundPositionVecDestructor>(), "AzStyleBackgroundPositionVecDestructor"), (Layout::new::<AzStyleBackgroundPositionVecDestructor>(), "AzStyleBackgroundPositionVecDestructor"));
        assert_eq!((Layout::new::<azul_core::svg::SvgMultiPolygonVecDestructorType>(), "AzSvgMultiPolygonVecDestructorType"), (Layout::new::<AzSvgMultiPolygonVecDestructorType>(), "AzSvgMultiPolygonVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::svg::SvgSimpleNodeVecDestructor>(), "AzSvgSimpleNodeVecDestructor"), (Layout::new::<AzSvgSimpleNodeVecDestructor>(), "AzSvgSimpleNodeVecDestructor"));
        assert_eq!((Layout::new::<azul_core::dom::AccessibilityActionVecDestructorType>(), "AzAccessibilityActionVecDestructorType"), (Layout::new::<AzAccessibilityActionVecDestructorType>(), "AzAccessibilityActionVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::gl::GLintVecDestructorType>(), "AzGLintVecDestructorType"), (Layout::new::<AzGLintVecDestructorType>(), "AzGLintVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::dom::AttributeVecDestructor>(), "AzAttributeVecDestructor"), (Layout::new::<AzAttributeVecDestructor>(), "AzAttributeVecDestructor"));
        assert_eq!((Layout::new::<azul_core::dom::NodeDataVecDestructorType>(), "AzNodeDataVecDestructorType"), (Layout::new::<AzNodeDataVecDestructorType>(), "AzNodeDataVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::css::CssDeclarationVecDestructor>(), "AzCssDeclarationVecDestructor"), (Layout::new::<AzCssDeclarationVecDestructor>(), "AzCssDeclarationVecDestructor"));
        assert_eq!((Layout::new::<azul_core::styled_dom::StyledNodeVecDestructorType>(), "AzStyledNodeVecDestructorType"), (Layout::new::<AzStyledNodeVecDestructorType>(), "AzStyledNodeVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::dom::IdOrClassVecDestructor>(), "AzIdOrClassVecDestructor"), (Layout::new::<AzIdOrClassVecDestructor>(), "AzIdOrClassVecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::style::background::StyleBackgroundSizeVecDestructor>(), "AzStyleBackgroundSizeVecDestructor"), (Layout::new::<AzStyleBackgroundSizeVecDestructor>(), "AzStyleBackgroundSizeVecDestructor"));
        assert_eq!((Layout::new::<azul_core::svg::SvgPathVecDestructorType>(), "AzSvgPathVecDestructorType"), (Layout::new::<AzSvgPathVecDestructorType>(), "AzSvgPathVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::props::basic::font::StyleFontFamilyVecDestructorType>(), "AzStyleFontFamilyVecDestructorType"), (Layout::new::<AzStyleFontFamilyVecDestructorType>(), "AzStyleFontFamilyVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::window::StringPairVecDestructor>(), "AzStringPairVecDestructor"), (Layout::new::<AzStringPairVecDestructor>(), "AzStringPairVecDestructor"));
        assert_eq!((Layout::new::<azul_core::callbacks::CoreCallbackDataVecDestructor>(), "AzCoreCallbackDataVecDestructor"), (Layout::new::<AzCoreCallbackDataVecDestructor>(), "AzCoreCallbackDataVecDestructor"));
        assert_eq!((Layout::new::<azul_core::svg::SvgPathElementVecDestructor>(), "AzSvgPathElementVecDestructor"), (Layout::new::<AzSvgPathElementVecDestructor>(), "AzSvgPathElementVecDestructor"));
        assert_eq!((Layout::new::<azul_css::corety::U8VecDestructor>(), "AzU8VecDestructor"), (Layout::new::<AzU8VecDestructor>(), "AzU8VecDestructor"));
        assert_eq!((Layout::new::<azul_css::props::layout::grid::GridTrackSizingVecDestructor>(), "AzGridTrackSizingVecDestructor"), (Layout::new::<AzGridTrackSizingVecDestructor>(), "AzGridTrackSizingVecDestructor"));
        assert_eq!((Layout::new::<azul_core::dom::IdOrClassVecDestructorType>(), "AzIdOrClassVecDestructorType"), (Layout::new::<AzIdOrClassVecDestructorType>(), "AzIdOrClassVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::xml::XmlNodeChildVecDestructorType>(), "AzXmlNodeChildVecDestructorType"), (Layout::new::<AzXmlNodeChildVecDestructorType>(), "AzXmlNodeChildVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::css::StylesheetVecDestructorType>(), "AzStylesheetVecDestructorType"), (Layout::new::<AzStylesheetVecDestructorType>(), "AzStylesheetVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::css::CssPathSelectorVecDestructorType>(), "AzCssPathSelectorVecDestructorType"), (Layout::new::<AzCssPathSelectorVecDestructorType>(), "AzCssPathSelectorVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::gl::VertexAttributeVecDestructorType>(), "AzVertexAttributeVecDestructorType"), (Layout::new::<AzVertexAttributeVecDestructorType>(), "AzVertexAttributeVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::gl::VertexAttributeVecDestructor>(), "AzVertexAttributeVecDestructor"), (Layout::new::<AzVertexAttributeVecDestructor>(), "AzVertexAttributeVecDestructor"));
        assert_eq!((Layout::new::<azul_core::gl::VertexAttributeVec>(), "AzVertexAttributeVec"), (Layout::new::<AzVertexAttributeVec>(), "AzVertexAttributeVec"));
        assert_eq!((Layout::new::<azul_core::gl::DebugMessageVecDestructor>(), "AzDebugMessageVecDestructor"), (Layout::new::<AzDebugMessageVecDestructor>(), "AzDebugMessageVecDestructor"));
        assert_eq!((Layout::new::<azul_core::gl::DebugMessageVecDestructorType>(), "AzDebugMessageVecDestructorType"), (Layout::new::<AzDebugMessageVecDestructorType>(), "AzDebugMessageVecDestructorType"));
        assert_eq!((Layout::new::<azul_core::gl::DebugMessageVec>(), "AzDebugMessageVec"), (Layout::new::<AzDebugMessageVec>(), "AzDebugMessageVec"));
        assert_eq!((Layout::new::<azul_css::shape::ShapePointVecDestructor>(), "AzShapePointVecDestructor"), (Layout::new::<AzShapePointVecDestructor>(), "AzShapePointVecDestructor"));
        assert_eq!((Layout::new::<azul_css::shape::ShapePointVecDestructorType>(), "AzShapePointVecDestructorType"), (Layout::new::<AzShapePointVecDestructorType>(), "AzShapePointVecDestructorType"));
        assert_eq!((Layout::new::<azul_css::shape::ShapePointVec>(), "AzShapePointVec"), (Layout::new::<AzShapePointVec>(), "AzShapePointVec"));
        assert_eq!((Layout::new::<azul_css::props::basic::animation::OptionSvgPoint>(), "AzOptionSvgPoint"), (Layout::new::<AzOptionSvgPoint>(), "AzOptionSvgPoint"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::OptionListViewOnRowClick>(), "AzOptionListViewOnRowClick"), (Layout::new::<AzOptionListViewOnRowClick>(), "AzOptionListViewOnRowClick"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::OptionListViewOnColumnClick>(), "AzOptionListViewOnColumnClick"), (Layout::new::<AzOptionListViewOnColumnClick>(), "AzOptionListViewOnColumnClick"));
        assert_eq!((Layout::new::<azul_layout::widgets::list_view::OptionListViewOnLazyLoadScroll>(), "AzOptionListViewOnLazyLoadScroll"), (Layout::new::<AzOptionListViewOnLazyLoadScroll>(), "AzOptionListViewOnLazyLoadScroll"));
        assert_eq!((Layout::new::<azul_core::menu::OptionMenu>(), "AzOptionMenu"), (Layout::new::<AzOptionMenu>(), "AzOptionMenu"));
        assert_eq!((Layout::new::<azul_css::props::basic::pixel::OptionPixelValueNoPercent>(), "AzOptionPixelValueNoPercent"), (Layout::new::<AzOptionPixelValueNoPercent>(), "AzOptionPixelValueNoPercent"));
        assert_eq!((Layout::new::<azul_layout::widgets::color_input::OptionColorInputOnValueChange>(), "AzOptionColorInputOnValueChange"), (Layout::new::<AzOptionColorInputOnValueChange>(), "AzOptionColorInputOnValueChange"));
        assert_eq!((Layout::new::<azul_layout::widgets::button::OptionButtonOnClick>(), "AzOptionButtonOnClick"), (Layout::new::<AzOptionButtonOnClick>(), "AzOptionButtonOnClick"));
        assert_eq!((Layout::new::<azul_layout::widgets::tabs::OptionTabOnClick>(), "AzOptionTabOnClick"), (Layout::new::<AzOptionTabOnClick>(), "AzOptionTabOnClick"));
        assert_eq!((Layout::new::<azul_layout::widgets::file_input::OptionFileInputOnPathChange>(), "AzOptionFileInputOnPathChange"), (Layout::new::<AzOptionFileInputOnPathChange>(), "AzOptionFileInputOnPathChange"));
        assert_eq!((Layout::new::<azul_layout::widgets::check_box::OptionCheckBoxOnToggle>(), "AzOptionCheckBoxOnToggle"), (Layout::new::<AzOptionCheckBoxOnToggle>(), "AzOptionCheckBoxOnToggle"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::OptionTextInputOnTextInput>(), "AzOptionTextInputOnTextInput"), (Layout::new::<AzOptionTextInputOnTextInput>(), "AzOptionTextInputOnTextInput"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::OptionTextInputOnVirtualKeyDown>(), "AzOptionTextInputOnVirtualKeyDown"), (Layout::new::<AzOptionTextInputOnVirtualKeyDown>(), "AzOptionTextInputOnVirtualKeyDown"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::OptionTextInputOnFocusLost>(), "AzOptionTextInputOnFocusLost"), (Layout::new::<AzOptionTextInputOnFocusLost>(), "AzOptionTextInputOnFocusLost"));
        assert_eq!((Layout::new::<azul_layout::widgets::text_input::OptionTextInputSelection>(), "AzOptionTextInputSelection"), (Layout::new::<AzOptionTextInputSelection>(), "AzOptionTextInputSelection"));
        assert_eq!((Layout::new::<azul_layout::widgets::number_input::OptionNumberInputOnFocusLost>(), "AzOptionNumberInputOnFocusLost"), (Layout::new::<AzOptionNumberInputOnFocusLost>(), "AzOptionNumberInputOnFocusLost"));
        assert_eq!((Layout::new::<azul_layout::widgets::number_input::OptionNumberInputOnValueChange>(), "AzOptionNumberInputOnValueChange"), (Layout::new::<AzOptionNumberInputOnValueChange>(), "AzOptionNumberInputOnValueChange"));
        assert_eq!((Layout::new::<azul_core::menu::OptionMenuItemIcon>(), "AzOptionMenuItemIcon"), (Layout::new::<AzOptionMenuItemIcon>(), "AzOptionMenuItemIcon"));
        assert_eq!((Layout::new::<azul_core::window::OptionVirtualKeyCodeCombo>(), "AzOptionVirtualKeyCodeCombo"), (Layout::new::<AzOptionVirtualKeyCodeCombo>(), "AzOptionVirtualKeyCodeCombo"));
        assert_eq!((Layout::new::<azul_core::task::OptionTimerId>(), "AzOptionTimerId"), (Layout::new::<AzOptionTimerId>(), "AzOptionTimerId"));
        assert_eq!((Layout::new::<azul_css::corety::OptionI16>(), "AzOptionI16"), (Layout::new::<AzOptionI16>(), "AzOptionI16"));
        assert_eq!((Layout::new::<azul_css::corety::OptionU16>(), "AzOptionU16"), (Layout::new::<AzOptionU16>(), "AzOptionU16"));
        assert_eq!((Layout::new::<azul_css::corety::OptionU32>(), "AzOptionU32"), (Layout::new::<AzOptionU32>(), "AzOptionU32"));
        assert_eq!((Layout::new::<azul_core::resources::OptionImageRef>(), "AzOptionImageRef"), (Layout::new::<AzOptionImageRef>(), "AzOptionImageRef"));
        assert_eq!((Layout::new::<azul_css::props::basic::font::OptionFontRef>(), "AzOptionFontRef"), (Layout::new::<AzOptionFontRef>(), "AzOptionFontRef"));
        assert_eq!((Layout::new::<azul_core::refany::OptionRefAny>(), "AzOptionRefAny"), (Layout::new::<AzOptionRefAny>(), "AzOptionRefAny"));
        assert_eq!((Layout::new::<azul_css::props::basic::geometry::OptionLayoutSize>(), "AzOptionLayoutSize"), (Layout::new::<AzOptionLayoutSize>(), "AzOptionLayoutSize"));
        assert_eq!((Layout::new::<azul_core::dom::OptionDomNodeId>(), "AzOptionDomNodeId"), (Layout::new::<AzOptionDomNodeId>(), "AzOptionDomNodeId"));
        assert_eq!((Layout::new::<azul_css::props::basic::color::OptionColorU>(), "AzOptionColorU"), (Layout::new::<AzOptionColorU>(), "AzOptionColorU"));
        assert_eq!((Layout::new::<azul_core::resources::OptionRawImage>(), "AzOptionRawImage"), (Layout::new::<AzOptionRawImage>(), "AzOptionRawImage"));
        assert_eq!((Layout::new::<azul_core::svg::OptionSvgDashPattern>(), "AzOptionSvgDashPattern"), (Layout::new::<AzOptionSvgDashPattern>(), "AzOptionSvgDashPattern"));
        assert_eq!((Layout::new::<azul_core::dom::OptionTabIndex>(), "AzOptionTabIndex"), (Layout::new::<AzOptionTabIndex>(), "AzOptionTabIndex"));
        assert_eq!((Layout::new::<azul_core::dom::OptionTagId>(), "AzOptionTagId"), (Layout::new::<AzOptionTagId>(), "AzOptionTagId"));
        assert_eq!((Layout::new::<azul_core::task::OptionDuration>(), "AzOptionDuration"), (Layout::new::<AzOptionDuration>(), "AzOptionDuration"));
        assert_eq!((Layout::new::<azul_core::gl::OptionUsize>(), "AzOptionUsize"), (Layout::new::<AzOptionUsize>(), "AzOptionUsize"));
        assert_eq!((Layout::new::<azul_core::menu::OptionCoreMenuCallback>(), "AzOptionCoreMenuCallback"), (Layout::new::<AzOptionCoreMenuCallback>(), "AzOptionCoreMenuCallback"));
        assert_eq!((Layout::new::<azul_core::styled_dom::OptionStyledDom>(), "AzOptionStyledDom"), (Layout::new::<AzOptionStyledDom>(), "AzOptionStyledDom"));
        assert_eq!((Layout::new::<azul_core::svg::SvgParseOptions>(), "AzSvgParseOptions"), (Layout::new::<AzSvgParseOptions>(), "AzSvgParseOptions"));
        assert_eq!((Layout::new::<azul_core::svg::SvgXmlOptions>(), "AzSvgXmlOptions"), (Layout::new::<AzSvgXmlOptions>(), "AzSvgXmlOptions"));
        assert_eq!((Layout::new::<azul_core::svg::SvgRenderOptions>(), "AzSvgRenderOptions"), (Layout::new::<AzSvgRenderOptions>(), "AzSvgRenderOptions"));
        assert_eq!((Layout::new::<azul_core::geom::OptionLogicalPosition>(), "AzOptionLogicalPosition"), (Layout::new::<AzOptionLogicalPosition>(), "AzOptionLogicalPosition"));
        assert_eq!((Layout::new::<azul_css::corety::OptionString>(), "AzOptionString"), (Layout::new::<AzOptionString>(), "AzOptionString"));
        assert_eq!((Layout::new::<azul_css::corety::OptionF32>(), "AzOptionF32"), (Layout::new::<AzOptionF32>(), "AzOptionF32"));
        assert_eq!((Layout::new::<azul_core::window::RendererOptions>(), "AzRendererOptions"), (Layout::new::<AzRendererOptions>(), "AzRendererOptions"));
        assert_eq!((Layout::new::<azul_layout::callbacks::OptionCallback>(), "AzOptionCallback"), (Layout::new::<AzOptionCallback>(), "AzOptionCallback"));
        assert_eq!((Layout::new::<azul_core::xml::ResultXmlXmlError>(), "AzResultXmlXmlError"), (Layout::new::<AzResultXmlXmlError>(), "AzResultXmlXmlError"));
        assert_eq!((Layout::new::<azul_core::svg::ResultSvgSvgParseError>(), "AzResultSvgSvgParseError"), (Layout::new::<AzResultSvgSvgParseError>(), "AzResultSvgSvgParseError"));
        assert_eq!((Layout::new::<azul_core::svg::SvgParseError>(), "AzSvgParseError"), (Layout::new::<AzSvgParseError>(), "AzSvgParseError"));
        assert_eq!((Layout::new::<azul_core::xml::XmlError>(), "AzXmlError"), (Layout::new::<AzXmlError>(), "AzXmlError"));
        assert_eq!((Layout::new::<azul_core::xml::DuplicatedNamespaceError>(), "AzDuplicatedNamespaceError"), (Layout::new::<AzDuplicatedNamespaceError>(), "AzDuplicatedNamespaceError"));
        assert_eq!((Layout::new::<azul_core::xml::UnknownNamespaceError>(), "AzUnknownNamespaceError"), (Layout::new::<AzUnknownNamespaceError>(), "AzUnknownNamespaceError"));
        assert_eq!((Layout::new::<azul_core::xml::UnexpectedCloseTagError>(), "AzUnexpectedCloseTagError"), (Layout::new::<AzUnexpectedCloseTagError>(), "AzUnexpectedCloseTagError"));
        assert_eq!((Layout::new::<azul_core::xml::UnknownEntityReferenceError>(), "AzUnknownEntityReferenceError"), (Layout::new::<AzUnknownEntityReferenceError>(), "AzUnknownEntityReferenceError"));
        assert_eq!((Layout::new::<azul_core::xml::DuplicatedAttributeError>(), "AzDuplicatedAttributeError"), (Layout::new::<AzDuplicatedAttributeError>(), "AzDuplicatedAttributeError"));
        assert_eq!((Layout::new::<azul_core::xml::XmlParseError>(), "AzXmlParseError"), (Layout::new::<AzXmlParseError>(), "AzXmlParseError"));
        assert_eq!((Layout::new::<azul_core::xml::XmlTextError>(), "AzXmlTextError"), (Layout::new::<AzXmlTextError>(), "AzXmlTextError"));
        assert_eq!((Layout::new::<azul_core::xml::XmlStreamError>(), "AzXmlStreamError"), (Layout::new::<AzXmlStreamError>(), "AzXmlStreamError"));
        assert_eq!((Layout::new::<azul_core::xml::NonXmlCharError>(), "AzNonXmlCharError"), (Layout::new::<AzNonXmlCharError>(), "AzNonXmlCharError"));
        assert_eq!((Layout::new::<azul_core::xml::InvalidCharError>(), "AzInvalidCharError"), (Layout::new::<AzInvalidCharError>(), "AzInvalidCharError"));
        assert_eq!((Layout::new::<azul_core::xml::InvalidCharMultipleError>(), "AzInvalidCharMultipleError"), (Layout::new::<AzInvalidCharMultipleError>(), "AzInvalidCharMultipleError"));
        assert_eq!((Layout::new::<azul_core::xml::InvalidQuoteError>(), "AzInvalidQuoteError"), (Layout::new::<AzInvalidQuoteError>(), "AzInvalidQuoteError"));
        assert_eq!((Layout::new::<azul_core::xml::InvalidSpaceError>(), "AzInvalidSpaceError"), (Layout::new::<AzInvalidSpaceError>(), "AzInvalidSpaceError"));
        assert_eq!((Layout::new::<azul_core::xml::InvalidStringError>(), "AzInvalidStringError"), (Layout::new::<AzInvalidStringError>(), "AzInvalidStringError"));
        assert_eq!((Layout::new::<azul_core::xml::MalformedHierarchyError>(), "AzMalformedHierarchyError"), (Layout::new::<AzMalformedHierarchyError>(), "AzMalformedHierarchyError"));
        assert_eq!((Layout::new::<azul_layout::image::encode::EncodeImageError>(), "AzEncodeImageError"), (Layout::new::<AzEncodeImageError>(), "AzEncodeImageError"));
        assert_eq!((Layout::new::<azul_layout::image::decode::ResultRawImageDecodeImageError>(), "AzResultRawImageDecodeImageError"), (Layout::new::<AzResultRawImageDecodeImageError>(), "AzResultRawImageDecodeImageError"));
        assert_eq!((Layout::new::<azul_layout::image::decode::DecodeImageError>(), "AzDecodeImageError"), (Layout::new::<AzDecodeImageError>(), "AzDecodeImageError"));
        assert_eq!((Layout::new::<azul_layout::image::encode::ResultU8VecEncodeImageError>(), "AzResultU8VecEncodeImageError"), (Layout::new::<AzResultU8VecEncodeImageError>(), "AzResultU8VecEncodeImageError"));
        assert_eq!((Layout::new::<azul_core::style::CascadeInfo>(), "AzCascadeInfo"), (Layout::new::<AzCascadeInfo>(), "AzCascadeInfo"));
        assert_eq!((Layout::new::<azul_core::window::RendererType>(), "AzRendererType"), (Layout::new::<AzRendererType>(), "AzRendererType"));
        assert_eq!((Layout::new::<azul_css::props::style::background::ExtendMode>(), "AzExtendMode"), (Layout::new::<AzExtendMode>(), "AzExtendMode"));
        assert_eq!((Layout::new::<azul_css::props::layout::flow::FlowInto>(), "AzFlowInto"), (Layout::new::<AzFlowInto>(), "AzFlowInto"));
        assert_eq!((Layout::new::<azul_core::window::VirtualKeyCode>(), "AzVirtualKeyCode"), (Layout::new::<AzVirtualKeyCode>(), "AzVirtualKeyCode"));
        assert_eq!((Layout::new::<azul_core::window::VirtualKeyCodeCombo>(), "AzVirtualKeyCodeCombo"), (Layout::new::<AzVirtualKeyCodeCombo>(), "AzVirtualKeyCodeCombo"));
        assert_eq!((Layout::new::<azul_core::dom::IdOrClass>(), "AzIdOrClass"), (Layout::new::<AzIdOrClass>(), "AzIdOrClass"));
        assert_eq!((Layout::new::<azul_css::props::basic::animation::InterpolateResolver>(), "AzInterpolateResolver"), (Layout::new::<AzInterpolateResolver>(), "AzInterpolateResolver"));
        assert_eq!((Layout::new::<azul_css::props::layout::flow::FlowFrom>(), "AzFlowFrom"), (Layout::new::<AzFlowFrom>(), "AzFlowFrom"));
        assert_eq!((Layout::new::<azul_core::refany::RefCount>(), "AzRefCount"), (Layout::new::<AzRefCount>(), "AzRefCount"));
        assert_eq!((Layout::new::<azul_core::callbacks::Update>(), "AzUpdate"), (Layout::new::<AzUpdate>(), "AzUpdate"));
        assert_eq!((Layout::new::<azul_core::refany::RefAny>(), "AzRefAny"), (Layout::new::<AzRefAny>(), "AzRefAny"));
        assert_eq!((Layout::new::<azul_core::callbacks::EdgeType>(), "AzEdgeType"), (Layout::new::<AzEdgeType>(), "AzEdgeType"));
        assert_eq!((Layout::new::<azul_core::gl::DebugMessage>(), "AzDebugMessage"), (Layout::new::<AzDebugMessage>(), "AzDebugMessage"));
        assert_eq!((Layout::new::<azul_core::resources::AppLogLevel>(), "AzAppLogLevel"), (Layout::new::<AzAppLogLevel>(), "AzAppLogLevel"));
        assert_eq!((Layout::new::<azul_dll::desktop::app::App>(), "AzApp"), (Layout::new::<AzApp>(), "AzApp"));
        assert_eq!((Layout::new::<azul_core::resources::AppConfig>(), "AzAppConfig"), (Layout::new::<AzAppConfig>(), "AzAppConfig"));
        assert_eq!((Layout::new::<azul_core::resources::AppTerminationBehavior>(), "AzAppTerminationBehavior"), (Layout::new::<AzAppTerminationBehavior>(), "AzAppTerminationBehavior"));
    }
}
